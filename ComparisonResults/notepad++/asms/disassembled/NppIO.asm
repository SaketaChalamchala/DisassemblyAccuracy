.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : B2E08883AE6E14DF100439F5FF272B99
.rdata:00000000 ; Input CRC32 : 43D2EEF2
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\NppIO.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000000 _rdata          segment para public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG145408       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:0000197Co
.rdata:0000000C ; wchar_t _SG176129
.rdata:0000000C $SG176129       dd offset aC5990dd      ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64):loc_247Fo
.rdata:0000000C                                         ; "c #5990DD"
.rdata:00000010 $SG145409       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00001980o
.rdata:0000001C $SG145410       db  23h ; #             ; DATA XREF: .data:00001984o
.rdata:0000001D                 db    9
.rdata:0000001E                 db  63h ; c
.rdata:0000001F                 db  20h
.rdata:00000020 unk_20          db  23h ; #             ; DATA XREF: .rdata:$SG176356o
.rdata:00000021                 db  36h ; 6
.rdata:00000022 a397e1          db '397E1',0            ; DATA XREF: .rdata:$SG176213o
.rdata:00000022                                         ; .rdata:$SG176214o ...
.rdata:00000028 $SG145411       db  24h ; $             ; DATA XREF: .data:00001988o
.rdata:00000029                 db    9
.rdata:0000002A aC5990dd        db 'c #5990DD',0        ; DATA XREF: .rdata:$SG176129o
.rdata:0000002A                                         ; .rdata:$SG176194o ...
.rdata:00000034 $SG145412       db  25h ; %             ; DATA XREF: .data:0000198Co
.rdata:00000035                 db    9
.rdata:00000036                 db  63h ; c
.rdata:00000037                 db  20h
.rdata:00000038                 db  23h ; #
.rdata:00000039                 db  42h ; B
.rdata:0000003A                 db  42h ; B
.rdata:0000003B aD2f0           db 'D2F0',0             ; DATA XREF: .rdata:$SG176282o
.rdata:0000003B                                         ; .rdata:$SG176288o
.rdata:00000040 ; wchar_t _SG176133
.rdata:00000040 $SG176133:                              ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+A53o
.rdata:00000040                 unicode 0, <Amount of files to open is too large>,0
.rdata:0000008A                 align 4
.rdata:0000008C $SG145413       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00001990o
.rdata:00000098 ; wchar_t _SG176134
.rdata:00000098 $SG176134:                              ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+A58o
.rdata:00000098                 unicode 0, <$INT_REPLACE$ files are about to be opened.>
.rdata:00000098                 dw 0Dh
.rdata:00000098                 unicode 0, <Are you sure to open them?>,0
.rdata:00000126                 align 4
.rdata:00000128 $SG145414       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:00001994o
.rdata:00000134 ; char _SG176135[]
.rdata:00000134 $SG176135       db 'NbFileToOpenImportantWarning',0
.rdata:00000134                                         ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+A6Co
.rdata:00000151                 align 4
.rdata:00000154 $SG145415       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00001998o
.rdata:00000160 $SG145416       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:0000199Co
.rdata:0000016C $SG145417       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:000019A0o
.rdata:00000178 $SG145418       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:000019A4o
.rdata:00000184 $SG145419       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:000019A8o
.rdata:00000190 $SG145420       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:000019ACo
.rdata:0000019C $SG145421       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:000019B0o
.rdata:000001A8 $SG145422       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:000019B4o
.rdata:000001B4 ; wchar_t _SG176143
.rdata:000001B4 $SG176143:                              ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64):loc_25FBo
.rdata:000001B4                 unicode 0, <Can not open file ">,0
.rdata:000001DC $SG145423       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:000019B8o
.rdata:000001E8 ; wchar_t _SG176144
.rdata:000001E8 $SG176144:                              ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+B59o
.rdata:000001E8                 unicode 0, <".>,0
.rdata:000001EE                 align 10h
.rdata:000001F0 $SG145424       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:000019BCo
.rdata:000001FC ; const WCHAR _SG176145
.rdata:000001FC $SG176145:                              ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+B6Bo
.rdata:000001FC                 unicode 0, <ERROR>,0
.rdata:00000208 $SG145425       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:000019C0o
.rdata:00000214 $SG145426       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:000019C4o
.rdata:00000220 $SG145427       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:000019C8o
.rdata:0000022C $SG145428       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:000019CCo
.rdata:00000238 $SG145429       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:000019D0o
.rdata:00000244 $SG145430       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:000019D4o
.rdata:00000250 $SG145431       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:000019D8o
.rdata:0000025C $SG145432       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:000019DCo
.rdata:00000268 $SG145433       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:000019E0o
.rdata:00000274 $SG145434       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:000019E4o
.rdata:00000280 ; wchar_t _SG176155
.rdata:00000280 $SG176155:                              ; DATA XREF: Notepad_plus::doReload(Buffer *,bool)+17o
.rdata:00000280                 unicode 0, <Reload>,0
.rdata:0000028E                 align 10h
.rdata:00000290 $SG145435       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:000019E8o
.rdata:0000029C $SG145436       db '2',9,'c #679ADC',0  ; DATA XREF: .data:000019ECo
.rdata:000002A8 ; wchar_t _SG176156
.rdata:000002A8 $SG176156:                              ; DATA XREF: Notepad_plus::doReload(Buffer *,bool)+1Co
.rdata:000002A8                 unicode 0, <Are you sure you want to reload the current file and lose>
.rdata:000002A8                 unicode 0, < the changes made in Notepad++?>,0
.rdata:0000035A                 align 4
.rdata:0000035C ; char _SG176157[]
.rdata:0000035C $SG176157       db 'DocReloadWarning',0 ; DATA XREF: Notepad_plus::doReload(Buffer *,bool)+2Do
.rdata:0000036D                 align 10h
.rdata:00000370 $SG145437       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:000019F0o
.rdata:0000037C $SG145438       db '4',9,'c #195CC6',0  ; DATA XREF: .data:000019F4o
.rdata:00000388 $SG145439       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:000019F8o
.rdata:00000394 $SG145440       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:000019FCo
.rdata:000003A0 $SG145441       db '7',9,'c #4885D6',0  ; DATA XREF: .data:00001A00o
.rdata:000003AC $SG145442       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:00001A04o
.rdata:000003B8 $SG145443       db '9',9,'c #6698DB',0  ; DATA XREF: .data:00001A08o
.rdata:000003C4 $SG145444       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:00001A0Co
.rdata:000003D0 $SG145445       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:00001A10o
.rdata:000003DC $SG145446       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:00001A14o
.rdata:000003E8 $SG145447       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:00001A18o
.rdata:000003F4 $SG145448       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:00001A1Co
.rdata:00000400 $SG145449       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:00001A20o
.rdata:0000040C $SG145450       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:00001A24o
.rdata:00000418 $SG145451       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:00001A28o
.rdata:00000424 $SG145452       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:00001A2Co
.rdata:00000430 $SG145453       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:00001A30o
.rdata:0000043C $SG145454       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:00001A34o
.rdata:00000448 $SG145455       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:00001A38o
.rdata:00000454 $SG145456       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:00001A3Co
.rdata:00000460 $SG145457       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:00001A40o
.rdata:0000046C $SG145458       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:00001A44o
.rdata:00000478 $SG145459       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:00001A48o
.rdata:00000484 $SG145460       db '         .+ ',0     ; DATA XREF: .data:00001A4Co
.rdata:00000491                 align 4
.rdata:00000494 $SG145461       db '        @#$ ',0     ; DATA XREF: .data:00001A50o
.rdata:000004A1                 align 4
.rdata:000004A4 $SG145462       db '       %&*= L',0    ; DATA XREF: .data:00001A54o
.rdata:000004B2                 align 4
.rdata:000004B4 $SG145463       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00001A58o
.rdata:000004C1                 align 4
.rdata:000004C4 $SG145464       db '     )!>~{] ',0     ; DATA XREF: .data:00001A5Co
.rdata:000004D1                 align 4
.rdata:000004D4 ; wchar_t _SG176185
.rdata:000004D4 $SG176185:                              ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+12Co
.rdata:000004D4                 unicode 0, <Save failed>,0
.rdata:000004EC $SG145465       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00001A60o
.rdata:000004F9                 align 4
.rdata:000004FC ; char _SG176187[]
.rdata:000004FC $SG176187       db 'OpenInAdminMode',0  ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+145o
.rdata:0000050C $SG145473       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:00000517                 align 4
.rdata:00000518 ; wchar_t _SG176186
.rdata:00000518 $SG176186:                              ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+131o
.rdata:00000518                 unicode 0, <The file cannot be saved and it may be protected.>
.rdata:00000518                 dw 0Dh
.rdata:00000518                 unicode 0, <Do you want to launch Notepad++ in Administrator mode?>,0
.rdata:000005EA                 align 4
.rdata:000005EC $SG145466       db '    (}|1234 ',0     ; DATA XREF: .data:00001A64o
.rdata:000005F9                 align 4
.rdata:000005FC $SG145467       db '    567890a ',0     ; DATA XREF: .data:00001A68o
.rdata:00000609                 align 4
.rdata:0000060C $SG145468       db '      bcdef ',0     ; DATA XREF: .data:00001A6Co
.rdata:00000619                 align 4
.rdata:0000061C $SG145469       db '       ghij ',0     ; DATA XREF: .data:00001A70o
.rdata:00000629                 align 4
.rdata:0000062C $SG145470       db '        klm ',0     ; DATA XREF: .data:00001A74o
.rdata:00000639                 align 4
.rdata:0000063C ; wchar_t _SG176191
.rdata:0000063C $SG176191:                              ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+182o
.rdata:0000063C                 unicode 0, <-multiInst>,0
.rdata:00000652                 align 4
.rdata:00000654 $SG145471       db '         no ',0     ; DATA XREF: .data:00001A78o
.rdata:00000661                 align 4
.rdata:00000664 ; const WCHAR _SG176194
.rdata:00000664 $SG176194       dd offset aC5990dd+4    ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+198o
.rdata:00000664                                         ; "990DD"
.rdata:00000668 $SG145474       db ' ',9,'c None',0     ; DATA XREF: .data:00001744o
.rdata:00000671                 align 4
.rdata:00000674 ; const WCHAR _SG176195
.rdata:00000674 $SG176195:                              ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+1B0o
.rdata:00000674                 unicode 0, <runas>,0
.rdata:00000680 $SG145475       db '.',9,'c #545254',0  ; DATA XREF: .data:00001748o
.rdata:0000068C $SG145476       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:0000174Co
.rdata:00000698 ; wchar_t _SG176197
.rdata:00000698 $SG176197:                              ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+1DFo
.rdata:00000698                 unicode 0, <Open in Administrator mode failed>,0
.rdata:000006DC $SG145477       db '@',9,'c #646464',0  ; DATA XREF: .data:00001750o
.rdata:000006E8 ; wchar_t _SG176198
.rdata:000006E8 $SG176198:                              ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+1E4o
.rdata:000006E8                 unicode 0, <Notepad++ cannot be opened in Administrator mode.>,0
.rdata:0000074C $SG145478       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:00001754o
.rdata:00000758 ; char _SG176199[]
.rdata:00000758 $SG176199       db 'OpenInAdminModeFailed',0
.rdata:00000758                                         ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+1F8o
.rdata:0000076E                 align 10h
.rdata:00000770 $SG145479       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00001758o
.rdata:0000077C $SG145480       db '%',9,'c #747284',0  ; DATA XREF: .data:0000175Co
.rdata:00000788 $SG145481       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00001760o
.rdata:00000794 $SG145482       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:00001764o
.rdata:000007A0 ; wchar_t _SG176203
.rdata:000007A0 $SG176203:                              ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+245o
.rdata:000007A0                 unicode 0, <Save failed>,0
.rdata:000007B8 $SG145483       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00001768o
.rdata:000007C4 $SG145484       db '-',9,'c #403E58',0  ; DATA XREF: .data:0000176Co
.rdata:000007D0 ; wchar_t _SG176204
.rdata:000007D0 $SG176204:                              ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+24Ao
.rdata:000007D0                 unicode 0, <The file cannot be saved and it may be protected.>
.rdata:000007D0                 dw 0Dh
.rdata:000007D0                 unicode 0, <Do you want to launch Notepad++ in Administrator mode?>,0
.rdata:000008A2                 align 4
.rdata:000008A4 ; char _SG176205[]
.rdata:000008A4 $SG176205       db 'OpenInAdminModeWithoutCloseCurrent',0
.rdata:000008A4                                         ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+25Eo
.rdata:000008C7                 align 4
.rdata:000008C8 $SG145485       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00001770o
.rdata:000008D4 $SG145486       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:00001774o
.rdata:000008E0 $SG145487       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00001778o
.rdata:000008EC $SG145488       db 27h,9,'c #242644',0  ; DATA XREF: .data:0000177Co
.rdata:000008F8 $SG145489       db ')',9,'c #282668',0  ; DATA XREF: .data:00001780o
.rdata:00000904 $SG145490       db '!',9,'c #24367C',0  ; DATA XREF: .data:00001784o
.rdata:00000910 $SG145491       db '~',9,'c #244A84',0  ; DATA XREF: .data:00001788o
.rdata:0000091C ; wchar_t _SG176212
.rdata:0000091C $SG176212:                              ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+2F2o
.rdata:0000091C                 unicode 0, <-multiInst -nosession >,0
.rdata:0000094A                 align 4
.rdata:0000094C $SG145492       db '{',9,'c #2C5098',0  ; DATA XREF: .data:0000178Co
.rdata:00000958 ; wchar_t _SG176213
.rdata:00000958 $SG176213       dd offset a397e1        ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+306o
.rdata:00000958                                         ; "397E1"
.rdata:0000095C $SG145493       db ']',9,'c #14162C',0  ; DATA XREF: .data:00001790o
.rdata:00000968 ; wchar_t _SG176214
.rdata:00000968 $SG176214       dd offset a397e1        ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+328o
.rdata:00000968                                         ; "397E1"
.rdata:0000096C $SG145494       db '^',9,'c #142E7C',0  ; DATA XREF: .data:00001794o
.rdata:00000978 $SG145495       db '/',9,'c #143789',0  ; DATA XREF: .data:00001798o
.rdata:00000984 $SG145496       db '(',9,'c #204990',0  ; DATA XREF: .data:0000179Co
.rdata:00000990 ; const WCHAR _SG176217
.rdata:00000990 $SG176217       dd offset aC5990dd+4    ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+33Ao
.rdata:00000990                                         ; "990DD"
.rdata:00000994 $SG145497       db '_',9,'c #174091',0  ; DATA XREF: .data:000017A0o
.rdata:000009A0 ; const WCHAR _SG176218
.rdata:000009A0 $SG176218:                              ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+352o
.rdata:000009A0                 unicode 0, <runas>,0
.rdata:000009AC $SG145498       db ':',9,'c #0C0630',0  ; DATA XREF: .data:000017A4o
.rdata:000009B8 $SG145499       db '<',9,'c #24327C',0  ; DATA XREF: .data:000017A8o
.rdata:000009C4 $SG145500       db '[',9,'c #2450A0',0  ; DATA XREF: .data:000017ACo
.rdata:000009D0 ; wchar_t _SG176220
.rdata:000009D0 $SG176220:                              ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+381o
.rdata:000009D0                 unicode 0, <Open in Administrator mode failed>,0
.rdata:00000A14 $SG145501       db '}',9,'c #345DB4',0  ; DATA XREF: .data:000017B0o
.rdata:00000A20 ; wchar_t _SG176221
.rdata:00000A20 $SG176221:                              ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+386o
.rdata:00000A20                 unicode 0, <Notepad++ cannot be opened in Administrator mode.>,0
.rdata:00000A84 ; char _SG176222[]
.rdata:00000A84 $SG176222       db 'OpenInAdminModeFailed',0
.rdata:00000A84                                         ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+39Ao
.rdata:00000A9A                 align 4
.rdata:00000A9C $SG145502       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:000017B4o
.rdata:00000AA8 $SG145503       db '1',9,'c #141244',0  ; DATA XREF: .data:000017B8o
.rdata:00000AB4 $SG145504       db '2',9,'c #24428C',0  ; DATA XREF: .data:000017BCo
.rdata:00000AC0 ; wchar_t _SG176225
.rdata:00000AC0 $SG176225:                              ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+3E8o
.rdata:00000AC0                 unicode 0, <Save failed>,0
.rdata:00000AD8 $SG145505       db '3',9,'c #3462B9',0  ; DATA XREF: .data:000017C0o
.rdata:00000AE4 $SG145506       db '4',9,'c #4470C4',0  ; DATA XREF: .data:000017C4o
.rdata:00000AF0 ; wchar_t _SG176226
.rdata:00000AF0 $SG176226:                              ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+3EDo
.rdata:00000AF0                 unicode 0, <Please check if this file is opened in another program.>,0
.rdata:00000B60 ; char _SG176227[]
.rdata:00000B60 $SG176227       db 'FileLockedWarning',0
.rdata:00000B60                                         ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+401o
.rdata:00000B72                 align 4
.rdata:00000B74 $SG145507       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:000017C8o
.rdata:00000B80 $SG145508       db '6',9,'c #4472CC',0  ; DATA XREF: .data:000017CCo
.rdata:00000B8C ; const WCHAR _SG176229
.rdata:00000B8C $SG176229:                              ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+41Bo
.rdata:00000B8C                 unicode 0, <Save failed>,0
.rdata:00000BA4 $SG145509       db '7',9,'c #24224C',0  ; DATA XREF: .data:000017D0o
.rdata:00000BB0 $SG145510       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:000017D4o
.rdata:00000BBC $SG145511       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:000017D8o
.rdata:00000BC8 $SG145512       db '0',9,'c #5482DF',0  ; DATA XREF: .data:000017DCo
.rdata:00000BD4 $SG145513       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:000017E0o
.rdata:00000BE0 $SG145514       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:000017E4o
.rdata:00000BEC $SG145515       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:000017E8o
.rdata:00000BF8 $SG145516       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:000017ECo
.rdata:00000C04 $SG145517       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:000017F0o
.rdata:00000C10 $SG145518       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:000017F4o
.rdata:00000C1C $SG145519       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:000017F8o
.rdata:00000C28 $SG145520       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:000017FCo
.rdata:00000C34 $SG145521       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:00001800o
.rdata:00000C40 $SG145522       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:00001804o
.rdata:00000C4C $SG145523       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:00001808o
.rdata:00000C58 $SG145524       db 'l',9,'c #243250',0  ; DATA XREF: .data:0000180Co
.rdata:00000C64 $SG145525       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:00001810o
.rdata:00000C70 $SG145526       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:00001814o
.rdata:00000C7C $SG145527       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00001818o
.rdata:00000C88 $SG145528       db '     .+.     ',0    ; DATA XREF: .data:0000181Co
.rdata:00000C96                 align 4
.rdata:00000C98 $SG145529       db '   @##$##@   ',0    ; DATA XREF: .data:00001820o
.rdata:00000CA6                 align 4
.rdata:00000CA8 $SG145530       db '  @%&***&%@  ',0    ; DATA XREF: .data:00001824o
.rdata:00000CB6                 align 4
.rdata:00000CB8 $SG145531       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00001828o
.rdata:00000CC6                 align 4
.rdata:00000CC8 $SG145532       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:00000CC8                                         ; DATA XREF: .data:0000182Co
.rdata:00000CD6                 align 4
.rdata:00000CD8 $SG145533       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00001830o
.rdata:00000CE6                 align 4
.rdata:00000CE8 $SG145534       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:00001834o
.rdata:00000CF6                 align 4
.rdata:00000CF8 $SG145535       db '12[3455563[21',0    ; DATA XREF: .data:00001838o
.rdata:00000D06                 align 4
.rdata:00000D08 $SG145536       db '7_365899063_7',0    ; DATA XREF: .data:0000183Co
.rdata:00000D16                 align 4
.rdata:00000D18 ; wchar_t _SG177281
.rdata:00000D18 $SG177281       dw 0                    ; DATA XREF: Notepad_plus::loadSession(Session &,bool)+191o
.rdata:00000D1A                 db    0
.rdata:00000D1B                 db    0
.rdata:00000D1C $SG145537       db ' /|09abc904/ ',0    ; DATA XREF: .data:00001840o
.rdata:00000D2A                 align 4
.rdata:00000D2C $SG145538       db ' d}8efgfb83d ',0    ; DATA XREF: .data:00001844o
.rdata:00000D3A                 align 4
.rdata:00000D3C $SG145539       db '  hiafjgakh  ',0    ; DATA XREF: .data:00001848o
.rdata:00000D4A                 align 4
.rdata:00000D4C $SG145540       db '   l~mnm~l   ',0    ; DATA XREF: .data:0000184Co
.rdata:00000D5A                 align 4
.rdata:00000D5C $SG145541       db '     o@o     ',0    ; DATA XREF: .data:00001850o
.rdata:00000D6A                 align 4
.rdata:00000D6C ; wchar_t _SG176269
.rdata:00000D6C $SG176269       dw 0                    ; DATA XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+50o
.rdata:00000D6E                 db    0
.rdata:00000D6F                 db    0
.rdata:00000D70 ; wchar_t _SG176281
.rdata:00000D70 $SG176281:                              ; DATA XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+124o
.rdata:00000D70                 unicode 0, <*.>,0
.rdata:00000D76                 align 4
.rdata:00000D78 ; wchar_t _SG176282
.rdata:00000D78 $SG176282       dd offset aD2f0         ; DATA XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+146o
.rdata:00000D78                                         ; "D2F0"
.rdata:00000D7C ; wchar_t _SG176287
.rdata:00000D7C $SG176287:                              ; DATA XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+1E9o
.rdata:00000D7C                 unicode 0, <*.>,0
.rdata:00000D82                 align 4
.rdata:00000D84 ; wchar_t _SG176288
.rdata:00000D84 $SG176288       dd offset aD2f0         ; DATA XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+20Bo
.rdata:00000D84                                         ; "D2F0"
.rdata:00000D88 ; wchar_t _SG177334
.rdata:00000D88 $SG177334       dw 0                    ; DATA XREF: Notepad_plus::loadSession(Session &,bool)+442o
.rdata:00000D8A                 db    0
.rdata:00000D8B                 db    0
.rdata:00000D8C ; wchar_t UNTITLED_STR
.rdata:00000D8C _UNTITLED_STR:                          ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+15Eo
.rdata:00000D8C                 unicode 0, <new >,0
.rdata:00000D96                 align 4
.rdata:00000D98 ; wchar_t _SG176353
.rdata:00000D98 $SG176353       dw 0                    ; DATA XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int):loc_683Ao
.rdata:00000D9A                 db    0
.rdata:00000D9B                 db    0
.rdata:00000D9C ; wchar_t _SG176356
.rdata:00000D9C $SG176356       dd offset unk_20        ; DATA XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+194o
.rdata:00000DA0 ; wchar_t _SG177388
.rdata:00000DA0 $SG177388       dw 0                    ; DATA XREF: Notepad_plus::loadSession(Session &,bool)+790o
.rdata:00000DA2                 db    0
.rdata:00000DA3                 db    0
.rdata:00000DA4 ; const WCHAR _SG177443
.rdata:00000DA4 $SG177443:                              ; DATA XREF: Notepad_plus::loadSession(Session &,bool)+A38o
.rdata:00000DA4                 unicode 0, <User Defined>,0
.rdata:00000DBE                 align 10h
.rdata:00000DC0 $SG177444       db    0                 ; DATA XREF: Notepad_plus::loadSession(Session &,bool)+A4Bo
.rdata:00000DC1                 db    0
.rdata:00000DC2                 db    0
.rdata:00000DC3                 db    0
.rdata:00000DC4 ; wchar_t _SG177462
.rdata:00000DC4 $SG177462       dw 0                    ; DATA XREF: Notepad_plus::loadSession(Session &,bool)+A85o
.rdata:00000DC6                 db    0
.rdata:00000DC7                 db    0
.rdata:00000DC8 ; wchar_t _SG176439
.rdata:00000DC8 $SG176439       dw 0                    ; DATA XREF: Notepad_plus::fileCloseAll(bool,bool)+F4o
.rdata:00000DCA                 db    0
.rdata:00000DCB                 db    0
.rdata:00000DCC ; wchar_t _SG176445
.rdata:00000DCC $SG176445:                              ; DATA XREF: Notepad_plus::fileCloseAll(bool,bool)+29Do
.rdata:00000DCC                 unicode 0, <Save>,0
.rdata:00000DD6                 align 4
.rdata:00000DD8 $SG176442:                              ; DATA XREF: Notepad_plus::fileCloseAll(bool,bool)+253o
.rdata:00000DD8                 unicode 0, <Your backup file cannot be found (deleted from outside).>
.rdata:00000DD8                 dw 0Dh
.rdata:00000DD8                 unicode 0, <Save it otherwise your data will be lost>
.rdata:00000DD8                 dw 0Dh
.rdata:00000DD8                 unicode 0, <Do you want to save file "%s" ?>,0
.rdata:00000EDC ; wchar_t _SG177511
.rdata:00000EDC $SG177511:                              ; DATA XREF: Notepad_plus::fileLoadSession(wchar_t const *)+82o
.rdata:00000EDC                 unicode 0, <.*>,0
.rdata:00000EE2                 align 4
.rdata:00000EE4 ; wchar_t _SG176487
.rdata:00000EE4 $SG176487       dw 0                    ; DATA XREF: Notepad_plus::fileCloseAll(bool,bool)+443o
.rdata:00000EE6                 db    0
.rdata:00000EE7                 db    0
.rdata:00000EE8 ; wchar_t _SG177512
.rdata:00000EE8 $SG177512:                              ; DATA XREF: Notepad_plus::fileLoadSession(wchar_t const *)+87o
.rdata:00000EE8                 unicode 0, <All types>,0
.rdata:00000EFC ; wchar_t _SG177515
.rdata:00000EFC $SG177515       dw 0                    ; DATA XREF: Notepad_plus::fileLoadSession(wchar_t const *)+B9o
.rdata:00000EFE                 db    0
.rdata:00000EFF                 db    0
.rdata:00000F00 $SG176489:                              ; DATA XREF: Notepad_plus::fileCloseAll(bool,bool)+587o
.rdata:00000F00                 unicode 0, <Your backup file cannot be found (deleted from outside).>
.rdata:00000F00                 dw 0Dh
.rdata:00000F00                 unicode 0, <Save it otherwise your data will be lost>
.rdata:00000F00                 dw 0Dh
.rdata:00000F00                 unicode 0, <Do you want to save file "%s" ?>,0
.rdata:00001004 ; wchar_t _SG176492
.rdata:00001004 $SG176492:                              ; DATA XREF: Notepad_plus::fileCloseAll(bool,bool)+5E0o
.rdata:00001004                 unicode 0, <Save>,0
.rdata:0000100E                 align 10h
.rdata:00001010 ; wchar_t _SG177518
.rdata:00001010 $SG177518       dd offset aC5990dd+4    ; DATA XREF: Notepad_plus::fileLoadSession(wchar_t const *)+E8o
.rdata:00001010                                         ; "990DD"
.rdata:00001014 ; wchar_t _SG177519
.rdata:00001014 $SG177519:                              ; DATA XREF: Notepad_plus::fileLoadSession(wchar_t const *)+118o
.rdata:00001014                 unicode 0, <Session file>,0
.rdata:0000102E                 align 10h
.rdata:00001030 ; wchar_t _SG177581
.rdata:00001030 $SG177581:                              ; DATA XREF: Notepad_plus::fileLoadSession(wchar_t const *)+2D6o
.rdata:00001030                 unicode 0, <-multiInst -nosession -openSession >,0
.rdata:00001078 ; wchar_t _SG177582
.rdata:00001078 $SG177582       dd offset a397e1        ; DATA XREF: Notepad_plus::fileLoadSession(wchar_t const *)+2EDo
.rdata:00001078                                         ; "397E1"
.rdata:0000107C ; wchar_t _SG177583
.rdata:0000107C $SG177583       dd offset a397e1        ; DATA XREF: Notepad_plus::fileLoadSession(wchar_t const *)+30Fo
.rdata:0000107C                                         ; "397E1"
.rdata:00001080 ; const WCHAR _SG177584
.rdata:00001080 $SG177584       dd offset aC5990dd+4    ; DATA XREF: Notepad_plus::fileLoadSession(wchar_t const *)+321o
.rdata:00001080                                         ; "990DD"
.rdata:00001084 ; const WCHAR _SG177585
.rdata:00001084 $SG177585:                              ; DATA XREF: Notepad_plus::fileLoadSession(wchar_t const *)+339o
.rdata:00001084                 unicode 0, <open>,0
.rdata:0000108E                 align 10h
.rdata:00001090 ; wchar_t _SG177622
.rdata:00001090 $SG177622:                              ; DATA XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *)+8Fo
.rdata:00001090                 unicode 0, <.*>,0
.rdata:00001096                 align 4
.rdata:00001098 ; wchar_t _SG177623
.rdata:00001098 $SG177623:                              ; DATA XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *)+94o
.rdata:00001098                 unicode 0, <All types>,0
.rdata:000010AC ; wchar_t _SG177625
.rdata:000010AC $SG177625       dw 0                    ; DATA XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *)+A8o
.rdata:000010AE                 db    0
.rdata:000010AF                 db    0
.rdata:000010B0 ; wchar_t _SG177628
.rdata:000010B0 $SG177628       dd offset aC5990dd+4    ; DATA XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *)+D4o
.rdata:000010B0                                         ; "990DD"
.rdata:000010B4 ; wchar_t _SG177629
.rdata:000010B4 $SG177629:                              ; DATA XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *)+FBo
.rdata:000010B4                 unicode 0, <Session file>,0
.rdata:000010CE                 align 10h
.rdata:000010D0 ; wchar_t _SG176851
.rdata:000010D0 $SG176851       dw 0                    ; DATA XREF: Notepad_plus::fileSave(Buffer *)+14Bo
.rdata:000010D2                 db    0
.rdata:000010D3                 db    0
.rdata:000010D4 ; wchar_t _SG176852
.rdata:000010D4 $SG176852       dd offset $SG176133+1Ch ; DATA XREF: Notepad_plus::fileSave(Buffer *)+183o
.rdata:000010D4                                         ; "s to open is too large"
.rdata:000010D8 ; wchar_t _SG176854
.rdata:000010D8 $SG176854:                              ; DATA XREF: Notepad_plus::fileSave(Buffer *):loc_4381o
.rdata:000010D8                 unicode 0, <.bak>,0
.rdata:000010E2                 align 4
.rdata:000010E4 ; wchar_t _SG176874
.rdata:000010E4 $SG176874       dw 0                    ; DATA XREF: Notepad_plus::fileSave(Buffer *)+208o
.rdata:000010E6                 db    0
.rdata:000010E7                 db    0
.rdata:000010E8 ; wchar_t _SG176892
.rdata:000010E8 $SG176892       dw 0                    ; DATA XREF: Notepad_plus::fileSave(Buffer *)+22Do
.rdata:000010EA                 db    0
.rdata:000010EB                 db    0
.rdata:000010EC ; wchar_t _SG176893
.rdata:000010EC $SG176893       dd offset $SG176133+1Ch ; DATA XREF: Notepad_plus::fileSave(Buffer *)+262o
.rdata:000010EC                                         ; "s to open is too large"
.rdata:000010F0 $SG176896:                              ; DATA XREF: Notepad_plus::fileSave(Buffer *):loc_443Co
.rdata:000010F0                 unicode 0, <nppBackup>,0
.rdata:00001104 ; wchar_t _SG176899
.rdata:00001104 $SG176899       dd offset $SG176133+1Ch ; DATA XREF: Notepad_plus::fileSave(Buffer *)+2C9o
.rdata:00001104                                         ; "s to open is too large"
.rdata:00001108 ; wchar_t _SG176900
.rdata:00001108 $SG176900       dd offset $SG176133+1Ch ; DATA XREF: Notepad_plus::fileSave(Buffer *)+2E5o
.rdata:00001108                                         ; "s to open is too large"
.rdata:0000110C ; wchar_t _SG176906
.rdata:0000110C $SG176906:                              ; DATA XREF: Notepad_plus::fileSave(Buffer *)+370o
.rdata:0000110C                 unicode 0, <%Y-%m-%d_%H%M%S>,0
.rdata:0000112C ; wchar_t _SG176907
.rdata:0000112C $SG176907       dd offset aC5990dd+4    ; DATA XREF: Notepad_plus::fileSave(Buffer *)+383o
.rdata:0000112C                                         ; "990DD"
.rdata:00001130 ; wchar_t _SG176908
.rdata:00001130 $SG176908:                              ; DATA XREF: Notepad_plus::fileSave(Buffer *)+39Co
.rdata:00001130                 unicode 0, <.bak>,0
.rdata:0000113A                 align 4
.rdata:0000113C ; wchar_t _SG176934
.rdata:0000113C $SG176934:                              ; DATA XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+A6o
.rdata:0000113C                 unicode 0, <.*>,0
.rdata:00001142                 align 4
.rdata:00001144 ; wchar_t _SG176935
.rdata:00001144 $SG176935:                              ; DATA XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+ABo
.rdata:00001144                 unicode 0, <All types>,0
.rdata:00001158 ; wchar_t _SG176950
.rdata:00001158 $SG176950:                              ; DATA XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+1EEo
.rdata:00001158                 unicode 0, <ERROR>,0
.rdata:00001164 ; wchar_t _SG176968
.rdata:00001164 $SG176968:                              ; DATA XREF: Notepad_plus::fileRename(Buffer *)+EDo
.rdata:00001164                 unicode 0, <All types>,0
.rdata:00001178 ; wchar_t _SG176951
.rdata:00001178 $SG176951:                              ; DATA XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+1F3o
.rdata:00001178                 unicode 0, <The file is already opened in the Notepad++.>,0
.rdata:000011D2                 align 4
.rdata:000011D4 ; char _SG176952[]
.rdata:000011D4 $SG176952       db 'FileAlreadyOpenedInNpp',0
.rdata:000011D4                                         ; DATA XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+207o
.rdata:000011EB                 align 4
.rdata:000011EC ; wchar_t _SG176967
.rdata:000011EC $SG176967:                              ; DATA XREF: Notepad_plus::fileRename(Buffer *)+E8o
.rdata:000011EC                 unicode 0, <.*>,0
.rdata:000011F2                 align 4
.rdata:000011F4 ; wchar_t _SG175951
.rdata:000011F4 $SG175951:                              ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+A0o
.rdata:000011F4                 unicode 0, <..\src\NppIO.cpp>,0
.rdata:00001216                 align 4
.rdata:00001218 ; wchar_t _SG175952
.rdata:00001218 $SG175952:                              ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+A5o
.rdata:00001218                 unicode 0, <_tcslen( longFileName ) == getFullPathNameResult>,0
.rdata:0000127A                 align 4
.rdata:0000127C ; const WCHAR _SG175981
.rdata:0000127C $SG175981:                              ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+3F5o
.rdata:0000127C                 unicode 0, <%s doesn>
.rdata:0000127C                 dw 27h
.rdata:0000127C                 unicode 0, <t exist. Create it?>,0
.rdata:000012B6                 align 4
.rdata:000012B8 ; const WCHAR _SG175983
.rdata:000012B8 $SG175983:                              ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+40Co
.rdata:000012B8                 unicode 0, <Create new file>,0
.rdata:000012D8 ; const WCHAR _SG175987
.rdata:000012D8 $SG175987:                              ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+46Do
.rdata:000012D8                 unicode 0, <Cannot create the file "%s">,0
.rdata:00001310 ; const WCHAR _SG175988
.rdata:00001310 $SG175988:                              ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+484o
.rdata:00001310                 unicode 0, <Create new file>,0
.rdata:00001330 ; wchar_t _SG177022
.rdata:00001330 $SG177022:                              ; DATA XREF: Notepad_plus::fileDelete(Buffer *)+E0o
.rdata:00001330                 unicode 0, <Delete File>,0
.rdata:00001348 ; wchar_t _SG177023
.rdata:00001348 $SG177023:                              ; DATA XREF: Notepad_plus::fileDelete(Buffer *)+E5o
.rdata:00001348                 unicode 0, <Delete File failed>,0
.rdata:0000136E                 align 10h
.rdata:00001370 ; char _SG177024[]
.rdata:00001370 $SG177024       db 'DeleteFileFailed',0 ; DATA XREF: Notepad_plus::fileDelete(Buffer *)+F6o
.rdata:00001381                 align 4
.rdata:00001384 ; wchar_t _SG177031
.rdata:00001384 $SG177031:                              ; DATA XREF: Notepad_plus::fileOpen(void)+67o
.rdata:00001384                 unicode 0, <.*>,0
.rdata:0000138A                 align 4
.rdata:0000138C ; wchar_t _SG177032
.rdata:0000138C $SG177032:                              ; DATA XREF: Notepad_plus::fileOpen(void)+6Co
.rdata:0000138C                 unicode 0, <All types>,0
.rdata:000013A0 $SG176010       db    0                 ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+70Do
.rdata:000013A1                 db    0
.rdata:000013A2                 db    0
.rdata:000013A3                 db    0
.rdata:000013A4 ; wchar_t _SG177060
.rdata:000013A4 $SG177060       dw 0                    ; DATA XREF: Notepad_plus::isFileSession(wchar_t const *)+79o
.rdata:000013A6                 db    0
.rdata:000013A7                 db    0
.rdata:000013A8 ; wchar_t _SG177062
.rdata:000013A8 $SG177062       dd offset aC5990dd+4    ; DATA XREF: Notepad_plus::isFileSession(wchar_t const *)+95o
.rdata:000013A8                                         ; "990DD"
.rdata:000013AC $SG145335       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:000013B7                 align 4
.rdata:000013B8 $SG145336       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:0000185Co
.rdata:000013C4 $SG145337       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00001860o
.rdata:000013D0 $SG145338       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:00001864o
.rdata:000013DC $SG145339       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00001868o
.rdata:000013E8 $SG145340       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:0000186Co
.rdata:000013F4 $SG145341       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00001870o
.rdata:00001400 $SG145342       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:00001874o
.rdata:0000140C $SG145343       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:00001878o
.rdata:00001418 $SG145344       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:0000187Co
.rdata:00001424 $SG145345       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00001880o
.rdata:00001430 $SG145346       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:00001884o
.rdata:0000143C $SG145347       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00001888o
.rdata:00001448 $SG145348       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:0000188Co
.rdata:00001454 $SG145349       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00001890o
.rdata:00001460 $SG145350       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:00001894o
.rdata:0000146C $SG145351       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00001898o
.rdata:00001478 $SG145352       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:0000189Co
.rdata:00001484 $SG145353       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:000018A0o
.rdata:00001490 $SG145354       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:000018A4o
.rdata:0000149C $SG145355       db ']',9,'c #6197DD',0  ; DATA XREF: .data:000018A8o
.rdata:000014A8 $SG145356       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:000018ACo
.rdata:000014B4 $SG145357       db '/',9,'c #538EDB',0  ; DATA XREF: .data:000018B0o
.rdata:000014C0 $SG145358       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:000018B4o
.rdata:000014CC $SG145359       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:000018B8o
.rdata:000014D8 $SG145360       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:000018BCo
.rdata:000014E4 $SG145361       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:000018C0o
.rdata:000014F0 $SG145362       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:000018C4o
.rdata:000014FC $SG145363       db '}',9,'c #4882D1',0  ; DATA XREF: .data:000018C8o
.rdata:00001508 $SG145364       db '|',9,'c #4384D6',0  ; DATA XREF: .data:000018CCo
.rdata:00001514 $SG145365       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:000018D0o
.rdata:00001520 $SG145366       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:000018D4o
.rdata:0000152C $SG145367       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:000018D8o
.rdata:00001538 $SG145368       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:000018DCo
.rdata:00001544 $SG145369       db '5',9,'c #437FD3',0  ; DATA XREF: .data:000018E0o
.rdata:00001550 $SG145370       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:000018E4o
.rdata:0000155C $SG145371       db '7',9,'c #3577D2',0  ; DATA XREF: .data:000018E8o
.rdata:00001568 $SG145372       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:000018ECo
.rdata:00001574 $SG145373       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:000018F0o
.rdata:00001580 $SG145374       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:000018F4o
.rdata:0000158C $SG145375       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:000018F8o
.rdata:00001598 $SG145376       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:000018FCo
.rdata:000015A4 $SG145377       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:00001900o
.rdata:000015B0 $SG145378       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:00001904o
.rdata:000015BC $SG145379       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:00001908o
.rdata:000015C8 $SG145380       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:0000190Co
.rdata:000015D4 $SG145381       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:00001910o
.rdata:000015E0 $SG145382       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:00001914o
.rdata:000015EC $SG145383       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:00001918o
.rdata:000015F8 $SG145384       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:0000191Co
.rdata:00001604 $SG145385       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:00001920o
.rdata:00001610 $SG145386       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:00001924o
.rdata:0000161C $SG145387       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:00001928o
.rdata:00001628 $SG145388       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:0000192Co
.rdata:00001634 $SG145389       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:00001930o
.rdata:00001640 $SG145390       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:00001934o
.rdata:0000164C $SG145391       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:00001938o
.rdata:00001658 $SG145392       db '    .+      ',0     ; DATA XREF: .data:0000193Co
.rdata:00001665                 align 4
.rdata:00001668 $SG145393       db '    @#$     ',0     ; DATA XREF: .data:00001940o
.rdata:00001675                 align 4
.rdata:00001678 $SG145394       db '    %&*=    ',0     ; DATA XREF: .data:00001944o
.rdata:00001685                 align 4
.rdata:00001688 $SG145395       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:00001948o
.rdata:00001695                 align 4
.rdata:00001698 $SG145396       db '    )!~{]^  ',0     ; DATA XREF: .data:0000194Co
.rdata:000016A5                 align 4
.rdata:000016A8 $SG145397       db '    /(_:<[} ',0     ; DATA XREF: .data:00001950o
.rdata:000016B5                 align 4
.rdata:000016B8 $SG145398       db '    |123456 ',0     ; DATA XREF: .data:00001954o
.rdata:000016C5                 align 4
.rdata:000016C8 $SG145399       db '    7890abc ',0     ; DATA XREF: .data:00001958o
.rdata:000016D5                 align 4
.rdata:000016D8 $SG145400       db '    defgh   ',0     ; DATA XREF: .data:0000195Co
.rdata:000016E5                 align 4
.rdata:000016E8 $SG145401       db '    ijkl    ',0     ; DATA XREF: .data:00001960o
.rdata:000016F5                 align 4
.rdata:000016F8 $SG145402       db '    mno     ',0     ; DATA XREF: .data:00001964o
.rdata:00001705                 align 4
.rdata:00001708 $SG145403       db '    pq      ',0     ; DATA XREF: .data:00001968o
.rdata:00001715                 align 4
.rdata:00001718 $SG145405       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:00001723                 align 4
.rdata:00001724 $SG145406       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00001974o
.rdata:00001730 ; wchar_t _SG176127
.rdata:00001730 $SG176127       dd offset $SG176133+1Ch ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+9A7o
.rdata:00001730                                         ; "s to open is too large"
.rdata:00001734 $SG145407       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00001978o
.rdata:00001734 _rdata          ends
.rdata:00001734
.data:00001740 ; ===========================================================================
.data:00001740
.data:00001740 ; Segment type: Pure data
.data:00001740 ; Segment permissions: Read/Write
.data:00001740 ; Segment alignment 'qword' can not be represented in assembly
.data:00001740 _data           segment para public 'DATA' use32
.data:00001740                 assume cs:_data
.data:00001740                 ;org 1740h
.data:00001740 _bookmark_xpm   dd offset $SG145473     ; "13 14 54 1"
.data:00001744                 dd offset $SG145474     ; " \tc None"
.data:00001748                 dd offset $SG145475     ; ".\tc #545254"
.data:0000174C                 dd offset $SG145476     ; "+\tc #3C3E3C"
.data:00001750                 dd offset $SG145477     ; "@\tc #646464"
.data:00001754                 dd offset $SG145478     ; "#\tc #A4A4A4"
.data:00001758                 dd offset $SG145479     ; "$\tc #B7B8B7"
.data:0000175C                 dd offset $SG145480     ; "%\tc #747284"
.data:00001760                 dd offset $SG145481     ; "&\tc #B4B2C4"
.data:00001764                 dd offset $SG145482     ; "*\tc #DCD7E4"
.data:00001768                 dd offset $SG145483     ; "=\tc #1C1A1C"
.data:0000176C                 dd offset $SG145484     ; "-\tc #403E58"
.data:00001770                 dd offset $SG145485     ; ";\tc #5C5A8C"
.data:00001774                 dd offset $SG145486     ; ">\tc #7C7EAC"
.data:00001778                 dd offset $SG145487     ; ",\tc #7C8EBC"
.data:0000177C                 dd offset $SG145488     ; "'\tc #242644"
.data:00001780                 dd offset $SG145489     ; ")\tc #282668"
.data:00001784                 dd offset $SG145490     ; "!\tc #24367C"
.data:00001788                 dd offset $SG145491     ; "~\tc #244A84"
.data:0000178C                 dd offset $SG145492     ; "{\tc #2C5098"
.data:00001790                 dd offset $SG145493     ; "]\tc #14162C"
.data:00001794                 dd offset $SG145494     ; "^\tc #142E7C"
.data:00001798                 dd offset $SG145495     ; "/\tc #143789"
.data:0000179C                 dd offset $SG145496     ; "(\tc #204990"
.data:000017A0                 dd offset $SG145497     ; "_\tc #174091"
.data:000017A4                 dd offset $SG145498     ; ":\tc #0C0630"
.data:000017A8                 dd offset $SG145499     ; "<\tc #24327C"
.data:000017AC                 dd offset $SG145500     ; "[\tc #2450A0"
.data:000017B0                 dd offset $SG145501     ; "}\tc #345DB4"
.data:000017B4                 dd offset $SG145502     ; "|\tc #3C68B8"
.data:000017B8                 dd offset $SG145503     ; "1\tc #141244"
.data:000017BC                 dd offset $SG145504     ; "2\tc #24428C"
.data:000017C0                 dd offset $SG145505     ; "3\tc #3462B9"
.data:000017C4                 dd offset $SG145506     ; "4\tc #4470C4"
.data:000017C8                 dd offset $SG145507     ; "5\tc #4C7FD6"
.data:000017CC                 dd offset $SG145508     ; "6\tc #4472CC"
.data:000017D0                 dd offset $SG145509     ; "7\tc #24224C"
.data:000017D4                 dd offset $SG145510     ; "8\tc #5C8DEC"
.data:000017D8                 dd offset $SG145511     ; "9\tc #5C94F6"
.data:000017DC                 dd offset $SG145512     ; "0\tc #5482DF"
.data:000017E0                 dd offset $SG145513     ; "a\tc #619DF7"
.data:000017E4                 dd offset $SG145514     ; "b\tc #6CA6FC"
.data:000017E8                 dd offset $SG145515     ; "c\tc #64A2FC"
.data:000017EC                 dd offset $SG145516     ; "d\tc #1C2E5C"
.data:000017F0                 dd offset $SG145517     ; "e\tc #6CA2FC"
.data:000017F4                 dd offset $SG145518     ; "f\tc #74B2FC"
.data:000017F8                 dd offset $SG145519     ; "g\tc #7CB8FC"
.data:000017FC                 dd offset $SG145520     ; "h\tc #1C3264"
.data:00001800                 dd offset $SG145521     ; "i\tc #346AD4"
.data:00001804                 dd offset $SG145522     ; "j\tc #7CBEFC"
.data:00001808                 dd offset $SG145523     ; "k\tc #3C72DC"
.data:0000180C                 dd offset $SG145524     ; "l\tc #243250"
.data:00001810                 dd offset $SG145525     ; "m\tc #346AB4"
.data:00001814                 dd offset $SG145526     ; "n\tc #3C82DC"
.data:00001818                 dd offset $SG145527     ; "o\tc #6C6A6C"
.data:0000181C                 dd offset $SG145528     ; "     .+.     "
.data:00001820                 dd offset $SG145529     ; "   @##$##@   "
.data:00001824                 dd offset $SG145530     ; "  @%&***&%@  "
.data:00001828                 dd offset $SG145531     ; " =-;>,,,>;-= "
.data:0000182C                 dd offset $SG145532     ; " ')!~{{{~!)' "
.data:00001830                 dd offset $SG145533     ; "])^/({{{(_^)]"
.data:00001834                 dd offset $SG145534     ; ":<_[}|||}[_<:"
.data:00001838                 dd offset $SG145535     ; "12[3455563[21"
.data:0000183C                 dd offset $SG145536     ; "7_365899063_7"
.data:00001840                 dd offset $SG145537     ; " /|09abc904/ "
.data:00001844                 dd offset $SG145538     ; " d}8efgfb83d "
.data:00001848                 dd offset $SG145539     ; "  hiafjgakh  "
.data:0000184C                 dd offset $SG145540     ; "   l~mnm~l   "
.data:00001850                 dd offset $SG145541     ; "     o@o     "
.data:00001854                 align 8
.data:00001858 _acTop_xpm      dd offset $SG145335     ; "12 12 56 1"
.data:0000185C                 dd offset $SG145336     ; " \tc #FFFFFF"
.data:00001860                 dd offset $SG145337     ; ".\tc #8AB2E9"
.data:00001864                 dd offset $SG145338     ; "+\tc #CCDCF6"
.data:00001868                 dd offset $SG145339     ; "@\tc #80ABEA"
.data:0000186C                 dd offset $SG145340     ; "#\tc #7DA9E8"
.data:00001870                 dd offset $SG145341     ; "$\tc #C7DAF3"
.data:00001874                 dd offset $SG145342     ; "%\tc #79A7E6"
.data:00001878                 dd offset $SG145343     ; "&\tc #ADC8EF"
.data:0000187C                 dd offset $SG145344     ; "*\tc #87B0E8"
.data:00001880                 dd offset $SG145345     ; "=\tc #BBD2F0"
.data:00001884                 dd offset $SG145346     ; "-\tc #6EA0E2"
.data:00001888                 dd offset $SG145347     ; ";\tc #A8C7EE"
.data:0000188C                 dd offset $SG145348     ; ">\tc #A3C2ED"
.data:00001890                 dd offset $SG145349     ; ",\tc #75A4E3"
.data:00001894                 dd offset $SG145350     ; "'\tc #A7C4EB"
.data:00001898                 dd offset $SG145351     ; ")\tc #6297E1"
.data:0000189C                 dd offset $SG145352     ; "!\tc #A1C1EC"
.data:000018A0                 dd offset $SG145353     ; "~\tc #92B7E8"
.data:000018A4                 dd offset $SG145354     ; "{\tc #99BBE9"
.data:000018A8                 dd offset $SG145355     ; "]\tc #6197DD"
.data:000018AC                 dd offset $SG145356     ; "^\tc #96B9E6"
.data:000018B0                 dd offset $SG145357     ; "/\tc #538EDB"
.data:000018B4                 dd offset $SG145358     ; "(\tc #99BBEA"
.data:000018B8                 dd offset $SG145359     ; "_\tc #80AAE3"
.data:000018BC                 dd offset $SG145360     ; ":\tc #81ABE3"
.data:000018C0                 dd offset $SG145361     ; "<\tc #8AB1E4"
.data:000018C4                 dd offset $SG145362     ; "[\tc #4B88D6"
.data:000018C8                 dd offset $SG145363     ; "}\tc #4882D1"
.data:000018CC                 dd offset $SG145364     ; "|\tc #4384D6"
.data:000018D0                 dd offset $SG145365     ; "1\tc #90B5E7"
.data:000018D4                 dd offset $SG145366     ; "2\tc #74A3E0"
.data:000018D8                 dd offset $SG145367     ; "3\tc #77A4E0"
.data:000018DC                 dd offset $SG145368     ; "4\tc #81ABE2"
.data:000018E0                 dd offset $SG145369     ; "5\tc #437FD3"
.data:000018E4                 dd offset $SG145370     ; "6\tc #7FA2DF"
.data:000018E8                 dd offset $SG145371     ; "7\tc #3577D2"
.data:000018EC                 dd offset $SG145372     ; "8\tc #87AFE4"
.data:000018F0                 dd offset $SG145373     ; "9\tc #72A1DF"
.data:000018F4                 dd offset $SG145374     ; "0\tc #7CA9E1"
.data:000018F8                 dd offset $SG145375     ; "a\tc #3F7AD0"
.data:000018FC                 dd offset $SG145376     ; "b\tc #85A4DE"
.data:00001900                 dd offset $SG145377     ; "c\tc #FBFCFE"
.data:00001904                 dd offset $SG145378     ; "d\tc #236ECD"
.data:00001908                 dd offset $SG145379     ; "e\tc #7EA8E1"
.data:0000190C                 dd offset $SG145380     ; "f\tc #79A6E0"
.data:00001910                 dd offset $SG145381     ; "g\tc #3D77D0"
.data:00001914                 dd offset $SG145382     ; "h\tc #87A4DC"
.data:00001918                 dd offset $SG145383     ; "i\tc #1A62C9"
.data:0000191C                 dd offset $SG145384     ; "j\tc #75A3DF"
.data:00001920                 dd offset $SG145385     ; "k\tc #3C74CF"
.data:00001924                 dd offset $SG145386     ; "l\tc #8DA6DE"
.data:00001928                 dd offset $SG145387     ; "m\tc #1859C4"
.data:0000192C                 dd offset $SG145388     ; "n\tc #3B71CC"
.data:00001930                 dd offset $SG145389     ; "o\tc #8EA5DD"
.data:00001934                 dd offset $SG145390     ; "p\tc #164EC0"
.data:00001938                 dd offset $SG145391     ; "q\tc #92A7DD"
.data:0000193C                 dd offset $SG145392     ; "    .+      "
.data:00001940                 dd offset $SG145393     ; "    @#$     "
.data:00001944                 dd offset $SG145394     ; "    %&*=    "
.data:00001948                 dd offset $SG145395     ; "    -;>,'   "
.data:0000194C                 dd offset $SG145396     ; "    )!~{]^  "
.data:00001950                 dd offset $SG145397     ; "    /(_:<[} "
.data:00001954                 dd offset $SG145398     ; "    |123456 "
.data:00001958                 dd offset $SG145399     ; "    7890abc "
.data:0000195C                 dd offset $SG145400     ; "    defgh   "
.data:00001960                 dd offset $SG145401     ; "    ijkl    "
.data:00001964                 dd offset $SG145402     ; "    mno     "
.data:00001968                 dd offset $SG145403     ; "    pq      "
.data:0000196C                 align 10h
.data:00001970 _acBottom_xpm   dd offset $SG145405     ; "12 12 54 1"
.data:00001974                 dd offset $SG145406     ; " \tc #FFFFFF"
.data:00001978                 dd offset $SG145407     ; ".\tc #C4D7F3"
.data:0000197C                 dd offset $SG145408     ; "+\tc #72A1E3"
.data:00001980                 dd offset $SG145409     ; "@\tc #C1D6F2"
.data:00001984                 dd offset $SG145410
.data:00001988                 dd offset $SG145411
.data:0000198C                 dd offset $SG145412
.data:00001990                 dd offset $SG145413     ; "&\tc #7AA6E5"
.data:00001994                 dd offset $SG145414     ; "*\tc #9ABDEA"
.data:00001998                 dd offset $SG145415     ; "=\tc #4A87D9"
.data:0000199C                 dd offset $SG145416     ; "-\tc #B1CAEE"
.data:000019A0                 dd offset $SG145417     ; ";\tc #75A4E3"
.data:000019A4                 dd offset $SG145418     ; ">\tc #99BBE9"
.data:000019A8                 dd offset $SG145419     ; ",\tc #95B9E8"
.data:000019AC                 dd offset $SG145420     ; "'\tc #3A7CD4"
.data:000019B0                 dd offset $SG145421     ; ")\tc #A9C6EC"
.data:000019B4                 dd offset $SG145422     ; "!\tc #71A0E0"
.data:000019B8                 dd offset $SG145423     ; "~\tc #86AFE5"
.data:000019BC                 dd offset $SG145424     ; "{\tc #8DB2E6"
.data:000019C0                 dd offset $SG145425     ; "]\tc #2A72CF"
.data:000019C4                 dd offset $SG145426     ; "^\tc #73A0E0"
.data:000019C8                 dd offset $SG145427     ; "/\tc #6B9DE0"
.data:000019CC                 dd offset $SG145428     ; "(\tc #95B8E8"
.data:000019D0                 dd offset $SG145429     ; "_\tc #81ABE3"
.data:000019D4                 dd offset $SG145430     ; ":\tc #72A1DF"
.data:000019D8                 dd offset $SG145431     ; "<\tc #83ADE3"
.data:000019DC                 dd offset $SG145432     ; "[\tc #1B65C9"
.data:000019E0                 dd offset $SG145433     ; "}\tc #5F95DC"
.data:000019E4                 dd offset $SG145434     ; "|\tc #8BB3E5"
.data:000019E8                 dd offset $SG145435     ; "1\tc #77A4E0"
.data:000019EC                 dd offset $SG145436     ; "2\tc #679ADC"
.data:000019F0                 dd offset $SG145437     ; "3\tc #7AA6E1"
.data:000019F4                 dd offset $SG145438     ; "4\tc #195CC6"
.data:000019F8                 dd offset $SG145439     ; "5\tc #FCFDFE"
.data:000019FC                 dd offset $SG145440     ; "6\tc #8DB2E4"
.data:00001A00                 dd offset $SG145441     ; "7\tc #4885D6"
.data:00001A04                 dd offset $SG145442     ; "8\tc #7CA9E1"
.data:00001A08                 dd offset $SG145443     ; "9\tc #6698DB"
.data:00001A0C                 dd offset $SG145444     ; "0\tc #71A1DE"
.data:00001A10                 dd offset $SG145445     ; "a\tc #1752C0"
.data:00001A14                 dd offset $SG145446     ; "b\tc #88ABE0"
.data:00001A18                 dd offset $SG145447     ; "c\tc #3D77D0"
.data:00001A1C                 dd offset $SG145448     ; "d\tc #6E9FDD"
.data:00001A20                 dd offset $SG145449     ; "e\tc #699BDC"
.data:00001A24                 dd offset $SG145450     ; "f\tc #1547BD"
.data:00001A28                 dd offset $SG145451     ; "g\tc #8DA6DE"
.data:00001A2C                 dd offset $SG145452     ; "h\tc #376BC9"
.data:00001A30                 dd offset $SG145453     ; "i\tc #6295DA"
.data:00001A34                 dd offset $SG145454     ; "j\tc #1440B9"
.data:00001A38                 dd offset $SG145455     ; "k\tc #8DA0DB"
.data:00001A3C                 dd offset $SG145456     ; "l\tc #315FC4"
.data:00001A40                 dd offset $SG145457     ; "m\tc #1339B7"
.data:00001A44                 dd offset $SG145458     ; "n\tc #909FDA"
.data:00001A48                 dd offset $SG145459     ; "o\tc #1233B4"
.data:00001A4C                 dd offset $SG145460     ; "         .+ "
.data:00001A50                 dd offset $SG145461     ; "        @#$ "
.data:00001A54                 dd offset $SG145462     ; "       %&*= L"
.data:00001A58                 dd offset $SG145463     ; "      -;>,' "
.data:00001A5C                 dd offset $SG145464     ; "     )!>~{] "
.data:00001A60                 dd offset $SG145465     ; "    ^/(_:<[ "
.data:00001A64                 dd offset $SG145466     ; "    (}|1234 "
.data:00001A68                 dd offset $SG145467     ; "    567890a "
.data:00001A6C                 dd offset $SG145468     ; "      bcdef "
.data:00001A70                 dd offset $SG145469     ; "       ghij "
.data:00001A74                 dd offset $SG145470     ; "        klm "
.data:00001A78                 dd offset $SG145471     ; "         no "
.data:00001A78 _data           ends
.data:00001A78
.bss:00001A7C ; ===========================================================================
.bss:00001A7C
.bss:00001A7C ; Segment type: Uninitialized
.bss:00001A7C ; Segment permissions: Read/Write
.bss:00001A7C _bss            segment dword public 'BSS' use32
.bss:00001A7C                 assume cs:_bss
.bss:00001A7C                 ;org 1A7Ch
.bss:00001A7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001A7C _hWndServer     db    ? ;
.bss:00001A7D                 db    ? ;
.bss:00001A7E                 db    ? ;
.bss:00001A7F                 db    ? ;
.bss:00001A80 _hook           db    ? ;
.bss:00001A81                 db    ? ;
.bss:00001A82                 db    ? ;
.bss:00001A83                 db    ? ;
.bss:00001A84 __Tuple_alloc   db    ? ;
.bss:00001A85 ; std::_Ignore ignore
.bss:00001A85 _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:00001A86 _allocator_arg  db    ? ;
.bss:00001A87 _piecewise_construct db    ? ;
.bss:00001A87 _bss            ends
.bss:00001A87
.text$mn:00001A88 ; ===========================================================================
.text$mn:00001A88
.text$mn:00001A88 ; Segment type: Pure code
.text$mn:00001A88 ; Segment permissions: Read/Execute
.text$mn:00001A88 _text$mn        segment para public 'CODE' use32
.text$mn:00001A88                 assume cs:_text$mn
.text$mn:00001A88                 ;org 1A88h
.text$mn:00001A88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A88
.text$mn:00001A88 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A88
.text$mn:00001A88 ; Attributes: bp-based frame
.text$mn:00001A88
.text$mn:00001A88 ; struct tm *__cdecl static localtime(const time_t *Time)
.text$mn:00001A88 _localtime      proc near               ; CODE XREF: Notepad_plus::fileSave(Buffer *)+35Bp
.text$mn:00001A88
.text$mn:00001A88 Time            = dword ptr  8
.text$mn:00001A88
.text$mn:00001A88                 push    ebp
.text$mn:00001A89                 mov     ebp, esp
.text$mn:00001A8B                 mov     eax, [ebp+Time]
.text$mn:00001A8E                 push    eax             ; Time
.text$mn:00001A8F                 call    __localtime64
.text$mn:00001A94                 add     esp, 4
.text$mn:00001A97                 pop     ebp
.text$mn:00001A98                 retn
.text$mn:00001A98 _localtime      endp
.text$mn:00001A98
.text$mn:00001A98 ; ---------------------------------------------------------------------------
.text$mn:00001A99                 db 0Fh dup(0CCh)
.text$mn:00001AA8
.text$mn:00001AA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AA8
.text$mn:00001AA8 ; Attributes: bp-based frame
.text$mn:00001AA8
.text$mn:00001AA8 ; time_t __cdecl static time(time_t *Time)
.text$mn:00001AA8 _time           proc near               ; CODE XREF: Notepad_plus::fileSave(Buffer *)+340p
.text$mn:00001AA8
.text$mn:00001AA8 Time            = dword ptr  8
.text$mn:00001AA8
.text$mn:00001AA8                 push    ebp
.text$mn:00001AA9                 mov     ebp, esp
.text$mn:00001AAB                 mov     eax, [ebp+Time]
.text$mn:00001AAE                 push    eax             ; Time
.text$mn:00001AAF                 call    __time64
.text$mn:00001AB4                 add     esp, 4
.text$mn:00001AB7                 pop     ebp
.text$mn:00001AB8                 retn
.text$mn:00001AB8 _time           endp
.text$mn:00001AB8
.text$mn:00001AB8 ; ---------------------------------------------------------------------------
.text$mn:00001AB9                 db 0Fh dup(0CCh)
.text$mn:00001AC8
.text$mn:00001AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AC8
.text$mn:00001AC8 ; Attributes: bp-based frame
.text$mn:00001AC8
.text$mn:00001AC8 ; struct Buffer *__thiscall Notepad_plus::doOpen(Notepad_plus *this, LPCWSTR lpFileName, bool, bool, int, LPCWSTR pszPath, __int64)
.text$mn:00001AC8                 public ?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z
.text$mn:00001AC8 ?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z proc near
.text$mn:00001AC8                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+B09p
.text$mn:00001AC8                                         ; Notepad_plus::fileOpen(void)+12Fp ...
.text$mn:00001AC8
.text$mn:00001AC8 var_844         = dword ptr -844h
.text$mn:00001AC8 var_840         = dword ptr -840h
.text$mn:00001AC8 var_83C         = dword ptr -83Ch
.text$mn:00001AC8 var_7E8         = dword ptr -7E8h
.text$mn:00001AC8 var_7E4         = dword ptr -7E4h
.text$mn:00001AC8 var_7E0         = dword ptr -7E0h
.text$mn:00001AC8 var_78C         = dword ptr -78Ch
.text$mn:00001AC8 var_788         = byte ptr -788h
.text$mn:00001AC8 var_778         = byte ptr -778h
.text$mn:00001AC8 var_768         = dword ptr -768h
.text$mn:00001AC8 var_764         = dword ptr -764h
.text$mn:00001AC8 var_760         = dword ptr -760h
.text$mn:00001AC8 var_75C         = dword ptr -75Ch
.text$mn:00001AC8 var_758         = dword ptr -758h
.text$mn:00001AC8 var_754         = dword ptr -754h
.text$mn:00001AC8 var_750         = dword ptr -750h
.text$mn:00001AC8 var_74C         = dword ptr -74Ch
.text$mn:00001AC8 var_748         = dword ptr -748h
.text$mn:00001AC8 var_744         = dword ptr -744h
.text$mn:00001AC8 var_740         = dword ptr -740h
.text$mn:00001AC8 var_73C         = dword ptr -73Ch
.text$mn:00001AC8 var_738         = dword ptr -738h
.text$mn:00001AC8 var_734         = dword ptr -734h
.text$mn:00001AC8 var_730         = dword ptr -730h
.text$mn:00001AC8 var_72C         = dword ptr -72Ch
.text$mn:00001AC8 var_728         = dword ptr -728h
.text$mn:00001AC8 var_724         = dword ptr -724h
.text$mn:00001AC8 var_720         = dword ptr -720h
.text$mn:00001AC8 var_71A         = byte ptr -71Ah
.text$mn:00001AC8 var_719         = byte ptr -719h
.text$mn:00001AC8 var_718         = dword ptr -718h
.text$mn:00001AC8 var_712         = byte ptr -712h
.text$mn:00001AC8 var_711         = byte ptr -711h
.text$mn:00001AC8 var_710         = byte ptr -710h
.text$mn:00001AC8 var_70F         = byte ptr -70Fh
.text$mn:00001AC8 var_70E         = byte ptr -70Eh
.text$mn:00001AC8 var_70D         = byte ptr -70Dh
.text$mn:00001AC8 var_70C         = dword ptr -70Ch
.text$mn:00001AC8 var_708         = byte ptr -708h
.text$mn:00001AC8 var_6EC         = byte ptr -6ECh
.text$mn:00001AC8 var_6D0         = byte ptr -6D0h
.text$mn:00001AC8 var_6B4         = byte ptr -6B4h
.text$mn:00001AC8 var_698         = byte ptr -698h
.text$mn:00001AC8 var_67C         = byte ptr -67Ch
.text$mn:00001AC8 var_660         = byte ptr -660h
.text$mn:00001AC8 var_644         = byte ptr -644h
.text$mn:00001AC8 Text            = word ptr -628h
.text$mn:00001AC8 Buffer          = word ptr -218h
.text$mn:00001AC8 var_10          = dword ptr -10h
.text$mn:00001AC8 var_C           = dword ptr -0Ch
.text$mn:00001AC8 var_4           = dword ptr -4
.text$mn:00001AC8 lpFileName      = dword ptr  8
.text$mn:00001AC8 arg_4           = byte ptr  0Ch
.text$mn:00001AC8 arg_8           = byte ptr  10h
.text$mn:00001AC8 arg_C           = dword ptr  14h
.text$mn:00001AC8 pszPath         = dword ptr  18h
.text$mn:00001AC8 arg_14          = qword ptr  1Ch
.text$mn:00001AC8
.text$mn:00001AC8                 push    ebp
.text$mn:00001AC9                 mov     ebp, esp
.text$mn:00001ACB                 push    0FFFFFFFFh
.text$mn:00001ACD                 push    offset __ehhandler$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z
.text$mn:00001AD2                 mov     eax, large fs:0
.text$mn:00001AD8                 push    eax
.text$mn:00001AD9                 sub     esp, 838h
.text$mn:00001ADF                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001AE4                 xor     eax, ebp
.text$mn:00001AE6                 mov     [ebp+var_10], eax
.text$mn:00001AE9                 push    eax
.text$mn:00001AEA                 lea     eax, [ebp+var_C]
.text$mn:00001AED                 mov     large fs:0, eax
.text$mn:00001AF3                 mov     [ebp+var_70C], ecx
.text$mn:00001AF9                 mov     [ebp+var_78C], 104h
.text$mn:00001B03                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00001B08                 mov     [ebp+var_72C], eax
.text$mn:00001B0E                 push    0               ; lpFilePart
.text$mn:00001B10                 lea     eax, [ebp+Buffer]
.text$mn:00001B16                 push    eax             ; lpBuffer
.text$mn:00001B17                 push    104h            ; nBufferLength
.text$mn:00001B1C                 mov     ecx, [ebp+lpFileName]
.text$mn:00001B1F                 push    ecx             ; lpFileName
.text$mn:00001B20                 call    dword ptr ds:__imp__GetFullPathNameW@16 ; GetFullPathNameW(x,x,x,x)
.text$mn:00001B26                 mov     [ebp+var_734], eax
.text$mn:00001B2C                 cmp     [ebp+var_734], 0
.text$mn:00001B33                 jnz     short loc_1B3C
.text$mn:00001B35                 xor     eax, eax
.text$mn:00001B37                 jmp     loc_26D3
.text$mn:00001B3C ; ---------------------------------------------------------------------------
.text$mn:00001B3C
.text$mn:00001B3C loc_1B3C:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+6Bj
.text$mn:00001B3C                 cmp     [ebp+var_734], 104h
.text$mn:00001B46                 jbe     short loc_1B4F
.text$mn:00001B48                 xor     eax, eax
.text$mn:00001B4A                 jmp     loc_26D3
.text$mn:00001B4F ; ---------------------------------------------------------------------------
.text$mn:00001B4F
.text$mn:00001B4F loc_1B4F:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+7Ej
.text$mn:00001B4F                 lea     edx, [ebp+Buffer]
.text$mn:00001B55                 push    edx             ; Str
.text$mn:00001B56                 call    _wcslen
.text$mn:00001B5B                 add     esp, 4
.text$mn:00001B5E                 cmp     eax, [ebp+var_734]
.text$mn:00001B64                 jz      short loc_1B7A
.text$mn:00001B66                 push    3Dh ; '='       ; Line
.text$mn:00001B68                 push    offset $SG175951 ; "..\\src\\NppIO.cpp"
.text$mn:00001B6D                 push    offset $SG175952 ; "_tcslen( longFileName ) == getFullPathN"...
.text$mn:00001B72                 call    __wassert
.text$mn:00001B77 ; ---------------------------------------------------------------------------
.text$mn:00001B77                 add     esp, 0Ch
.text$mn:00001B7A
.text$mn:00001B7A loc_1B7A:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+9Cj
.text$mn:00001B7A                 push    104h            ; cchBuffer
.text$mn:00001B7F                 lea     ecx, [ebp+Buffer]
.text$mn:00001B85                 push    ecx             ; lpszLongPath
.text$mn:00001B86                 lea     edx, [ebp+Buffer]
.text$mn:00001B8C                 push    edx             ; lpszShortPath
.text$mn:00001B8D                 call    dword ptr ds:__imp__GetLongPathNameW@12 ; GetLongPathNameW(x,x,x)
.text$mn:00001B93                 cmp     [ebp+pszPath], 0
.text$mn:00001B97                 jz      short loc_1BB3
.text$mn:00001B99                 mov     eax, [ebp+pszPath]
.text$mn:00001B9C                 push    eax             ; pszPath
.text$mn:00001B9D                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:00001BA3                 test    eax, eax
.text$mn:00001BA5                 jz      short loc_1BB3
.text$mn:00001BA7                 mov     [ebp+var_74C], 1
.text$mn:00001BB1                 jmp     short loc_1BBD
.text$mn:00001BB3 ; ---------------------------------------------------------------------------
.text$mn:00001BB3
.text$mn:00001BB3 loc_1BB3:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+CFj
.text$mn:00001BB3                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+DDj
.text$mn:00001BB3                 mov     [ebp+var_74C], 0
.text$mn:00001BBD
.text$mn:00001BBD loc_1BBD:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+E9j
.text$mn:00001BBD                 mov     cl, byte ptr [ebp+var_74C]
.text$mn:00001BC3                 mov     [ebp+var_70D], cl
.text$mn:00001BC9                 movzx   edx, [ebp+var_70D]
.text$mn:00001BD0                 test    edx, edx
.text$mn:00001BD2                 jz      short loc_1BF6
.text$mn:00001BD4                 lea     eax, [ebp+Buffer]
.text$mn:00001BDA                 push    eax             ; pszPath
.text$mn:00001BDB                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:00001BE1                 test    eax, eax
.text$mn:00001BE3                 jnz     short loc_1BF6
.text$mn:00001BE5                 mov     ecx, [ebp+lpFileName]
.text$mn:00001BE8                 push    ecx             ; lpString2
.text$mn:00001BE9                 lea     edx, [ebp+Buffer]
.text$mn:00001BEF                 push    edx             ; lpString1
.text$mn:00001BF0                 call    dword ptr ds:__imp__lstrcpyW@8 ; lstrcpyW(x,x)
.text$mn:00001BF6
.text$mn:00001BF6 loc_1BF6:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+10Aj
.text$mn:00001BF6                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+11Bj
.text$mn:00001BF6                 lea     eax, [ebp+Buffer]
.text$mn:00001BFC                 push    eax             ; wchar_t *
.text$mn:00001BFD                 mov     ecx, [ebp+var_70C]
.text$mn:00001C03                 add     ecx, 54A90h     ; this
.text$mn:00001C09                 call    ?remove@LastRecentFileList@@QAEXPB_W@Z ; LastRecentFileList::remove(wchar_t const *)
.text$mn:00001C0E                 mov     ecx, [ebp+lpFileName]
.text$mn:00001C11                 push    ecx             ; Str
.text$mn:00001C12                 lea     ecx, [ebp+var_644]
.text$mn:00001C18                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00001C1D                 mov     [ebp+var_4], 0
.text$mn:00001C24                 push    0               ; int
.text$mn:00001C26                 push    offset _UNTITLED_STR ; "new "
.text$mn:00001C2B                 lea     ecx, [ebp+var_644]
.text$mn:00001C31                 call    ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_of(wchar_t const *,uint)
.text$mn:00001C36                 mov     [ebp+var_748], eax
.text$mn:00001C3C                 mov     edx, [ebp+var_748]
.text$mn:00001C42                 cmp     edx, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:00001C48                 jz      short loc_1C5E
.text$mn:00001C4A                 cmp     [ebp+var_748], 0
.text$mn:00001C51                 jnz     short loc_1C5E
.text$mn:00001C53                 mov     eax, [ebp+lpFileName]
.text$mn:00001C56                 mov     [ebp+var_740], eax
.text$mn:00001C5C                 jmp     short loc_1C6A
.text$mn:00001C5E ; ---------------------------------------------------------------------------
.text$mn:00001C5E
.text$mn:00001C5E loc_1C5E:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+180j
.text$mn:00001C5E                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+189j
.text$mn:00001C5E                 lea     ecx, [ebp+Buffer]
.text$mn:00001C64                 mov     [ebp+var_740], ecx
.text$mn:00001C6A
.text$mn:00001C6A loc_1C6A:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+194j
.text$mn:00001C6A                 mov     edx, [ebp+var_740]
.text$mn:00001C70                 push    edx             ; wchar_t *
.text$mn:00001C71                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00001C76                 mov     ecx, eax        ; this
.text$mn:00001C78                 call    ?getBufferFromName@FileManager@@QAEPAVBuffer@@PB_W@Z ; FileManager::getBufferFromName(wchar_t const *)
.text$mn:00001C7D                 mov     [ebp+var_744], eax
.text$mn:00001C83                 cmp     [ebp+var_744], 0
.text$mn:00001C8A                 jz      loc_1D49
.text$mn:00001C90                 movzx   eax, [ebp+var_70D]
.text$mn:00001C97                 test    eax, eax
.text$mn:00001C99                 jnz     loc_1D49
.text$mn:00001C9F                 mov     ecx, [ebp+var_70C]
.text$mn:00001CA5                 cmp     dword ptr [ecx+54B90h], 0
.text$mn:00001CAC                 jz      short loc_1D20
.text$mn:00001CAE                 mov     edx, [ebp+var_70C]
.text$mn:00001CB4                 mov     ecx, [edx+54B90h] ; this
.text$mn:00001CBA                 call    ?isInTray@trayIconControler@@QBE_NXZ ; trayIconControler::isInTray(void)
.text$mn:00001CBF                 movzx   eax, al
.text$mn:00001CC2                 test    eax, eax
.text$mn:00001CC4                 jz      short loc_1D20
.text$mn:00001CC6                 push    5               ; nCmdShow
.text$mn:00001CC8                 mov     ecx, [ebp+var_70C]
.text$mn:00001CCE                 mov     ecx, [ecx+4]    ; this
.text$mn:00001CD1                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001CD6                 push    eax             ; hWnd
.text$mn:00001CD7                 call    dword ptr ds:__imp__ShowWindow@8 ; ShowWindow(x,x)
.text$mn:00001CDD                 mov     edx, [ebp+var_70C]
.text$mn:00001CE3                 mov     ecx, [edx+4]    ; this
.text$mn:00001CE6                 call    ?isPrelaunch@Notepad_plus_Window@@QBE_NXZ ; Notepad_plus_Window::isPrelaunch(void)
.text$mn:00001CEB                 movzx   eax, al
.text$mn:00001CEE                 test    eax, eax
.text$mn:00001CF0                 jnz     short loc_1D05
.text$mn:00001CF2                 push    2               ; unsigned __int32
.text$mn:00001CF4                 mov     ecx, [ebp+var_70C]
.text$mn:00001CFA                 mov     ecx, [ecx+54B90h] ; this
.text$mn:00001D00                 call    ?doTrayIcon@trayIconControler@@QAEHK@Z ; trayIconControler::doTrayIcon(ulong)
.text$mn:00001D05
.text$mn:00001D05 loc_1D05:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+228j
.text$mn:00001D05                 push    0               ; lParam
.text$mn:00001D07                 push    0               ; wParam
.text$mn:00001D09                 push    5               ; Msg
.text$mn:00001D0B                 mov     edx, [ebp+var_70C]
.text$mn:00001D11                 mov     ecx, [edx+4]    ; this
.text$mn:00001D14                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001D19                 push    eax             ; hWnd
.text$mn:00001D1A                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001D20
.text$mn:00001D20 loc_1D20:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+1E4j
.text$mn:00001D20                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+1FCj
.text$mn:00001D20                 mov     eax, [ebp+var_744]
.text$mn:00001D26                 mov     [ebp+var_75C], eax
.text$mn:00001D2C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001D33                 lea     ecx, [ebp+var_644]
.text$mn:00001D39                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001D3E                 mov     eax, [ebp+var_75C]
.text$mn:00001D44                 jmp     loc_26D3
.text$mn:00001D49 ; ---------------------------------------------------------------------------
.text$mn:00001D49
.text$mn:00001D49 loc_1D49:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+1C2j
.text$mn:00001D49                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+1D1j
.text$mn:00001D49                 lea     ecx, [ebp+Buffer]
.text$mn:00001D4F                 push    ecx             ; wchar_t *
.text$mn:00001D50                 mov     ecx, [ebp+var_70C] ; this
.text$mn:00001D56                 call    ?isFileSession@Notepad_plus@@QAE_NPB_W@Z ; Notepad_plus::isFileSession(wchar_t const *)
.text$mn:00001D5B                 movzx   edx, al
.text$mn:00001D5E                 test    edx, edx
.text$mn:00001D60                 jz      short loc_1DAC
.text$mn:00001D62                 lea     eax, [ebp+Buffer]
.text$mn:00001D68                 push    eax             ; pszPath
.text$mn:00001D69                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:00001D6F                 test    eax, eax
.text$mn:00001D71                 jz      short loc_1DAC
.text$mn:00001D73                 lea     ecx, [ebp+Buffer]
.text$mn:00001D79                 push    ecx             ; wchar_t *
.text$mn:00001D7A                 mov     ecx, [ebp+var_70C] ; this
.text$mn:00001D80                 call    ?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z ; Notepad_plus::fileLoadSession(wchar_t const *)
.text$mn:00001D85                 mov     [ebp+var_768], 0
.text$mn:00001D8F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001D96                 lea     ecx, [ebp+var_644]
.text$mn:00001D9C                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001DA1                 mov     eax, [ebp+var_768]
.text$mn:00001DA7                 jmp     loc_26D3
.text$mn:00001DAC ; ---------------------------------------------------------------------------
.text$mn:00001DAC
.text$mn:00001DAC loc_1DAC:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+298j
.text$mn:00001DAC                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+2A9j
.text$mn:00001DAC                 mov     [ebp+var_70E], 0
.text$mn:00001DB3                 lea     edx, [ebp+Buffer]
.text$mn:00001DB9                 push    edx             ; pszPath
.text$mn:00001DBA                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:00001DC0                 test    eax, eax
.text$mn:00001DC2                 jnz     short loc_1DD8
.text$mn:00001DC4                 push    0               ; int
.text$mn:00001DC6                 mov     ecx, [ebp+var_72C] ; this
.text$mn:00001DCC                 call    ?safeWow64EnableWow64FsRedirection@NppParameters@@QAEXH@Z ; NppParameters::safeWow64EnableWow64FsRedirection(int)
.text$mn:00001DD1                 mov     [ebp+var_70E], 1
.text$mn:00001DD8
.text$mn:00001DD8 loc_1DD8:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+2FAj
.text$mn:00001DD8                 push    2Ah ; '*'       ; wchar_t
.text$mn:00001DDA                 lea     eax, [ebp+Buffer]
.text$mn:00001DE0                 push    eax             ; Str
.text$mn:00001DE1                 call    ?wcsrchr@@YAPA_WPA_W_W@Z ; wcsrchr(wchar_t *,wchar_t)
.text$mn:00001DE6                 add     esp, 8
.text$mn:00001DE9                 test    eax, eax
.text$mn:00001DEB                 jnz     short loc_1E0E
.text$mn:00001DED                 push    3Fh ; '?'       ; wchar_t
.text$mn:00001DEF                 lea     ecx, [ebp+Buffer]
.text$mn:00001DF5                 push    ecx             ; Str
.text$mn:00001DF6                 call    ?wcsrchr@@YAPA_WPA_W_W@Z ; wcsrchr(wchar_t *,wchar_t)
.text$mn:00001DFB                 add     esp, 8
.text$mn:00001DFE                 test    eax, eax
.text$mn:00001E00                 jnz     short loc_1E0E
.text$mn:00001E02                 mov     [ebp+var_73C], 0
.text$mn:00001E0C                 jmp     short loc_1E18
.text$mn:00001E0E ; ---------------------------------------------------------------------------
.text$mn:00001E0E
.text$mn:00001E0E loc_1E0E:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+323j
.text$mn:00001E0E                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+338j
.text$mn:00001E0E                 mov     [ebp+var_73C], 1
.text$mn:00001E18
.text$mn:00001E18 loc_1E18:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+344j
.text$mn:00001E18                 mov     dl, byte ptr [ebp+var_73C]
.text$mn:00001E1E                 mov     [ebp+var_70F], dl
.text$mn:00001E24                 mov     [ebp+var_712], 0
.text$mn:00001E2B                 movzx   eax, [ebp+var_70D]
.text$mn:00001E32                 test    eax, eax
.text$mn:00001E34                 jnz     loc_1FDC
.text$mn:00001E3A                 lea     ecx, [ebp+Buffer]
.text$mn:00001E40                 push    ecx             ; pszPath
.text$mn:00001E41                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:00001E47                 test    eax, eax
.text$mn:00001E49                 jnz     loc_1FDC
.text$mn:00001E4F                 movzx   edx, [ebp+var_70F]
.text$mn:00001E56                 test    edx, edx
.text$mn:00001E58                 jnz     loc_1FDC
.text$mn:00001E5E                 lea     eax, [ebp+Buffer]
.text$mn:00001E64                 push    eax             ; Str
.text$mn:00001E65                 lea     ecx, [ebp+var_660]
.text$mn:00001E6B                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00001E70                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001E74                 lea     ecx, [ebp+var_660]
.text$mn:00001E7A                 push    ecx
.text$mn:00001E7B                 lea     edx, [ebp+var_708]
.text$mn:00001E81                 push    edx
.text$mn:00001E82                 call    ?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z ; PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00001E87                 add     esp, 8
.text$mn:00001E8A                 lea     ecx, [ebp+var_708]
.text$mn:00001E90                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001E95                 mov     [ebp+var_710], 0
.text$mn:00001E9C                 lea     ecx, [ebp+var_660]
.text$mn:00001EA2                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00001EA7                 push    eax             ; pszPath
.text$mn:00001EA8                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:00001EAE                 test    eax, eax
.text$mn:00001EB0                 jz      loc_1F6D
.text$mn:00001EB6                 lea     eax, [ebp+Buffer]
.text$mn:00001EBC                 push    eax
.text$mn:00001EBD                 push    offset $SG175981 ; "%s doesn't exist. Create it?"
.text$mn:00001EC2                 lea     ecx, [ebp+Text]
.text$mn:00001EC8                 push    ecx             ; LPWSTR
.text$mn:00001EC9                 call    dword ptr ds:__imp__wsprintfW
.text$mn:00001ECF                 add     esp, 0Ch
.text$mn:00001ED2                 push    4               ; uType
.text$mn:00001ED4                 push    offset $SG175983 ; "Create new file"
.text$mn:00001ED9                 lea     edx, [ebp+Text]
.text$mn:00001EDF                 push    edx             ; lpText
.text$mn:00001EE0                 mov     eax, [ebp+var_70C]
.text$mn:00001EE6                 mov     ecx, [eax+4]    ; this
.text$mn:00001EE9                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001EEE                 push    eax             ; hWnd
.text$mn:00001EEF                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:00001EF5                 cmp     eax, 6
.text$mn:00001EF8                 jnz     short loc_1F6D
.text$mn:00001EFA                 lea     ecx, [ebp+Buffer]
.text$mn:00001F00                 push    ecx             ; wchar_t *
.text$mn:00001F01                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00001F06                 mov     ecx, eax        ; this
.text$mn:00001F08                 call    ?createEmptyFile@FileManager@@QAE_NPB_W@Z ; FileManager::createEmptyFile(wchar_t const *)
.text$mn:00001F0D                 mov     [ebp+var_719], al
.text$mn:00001F13                 movzx   edx, [ebp+var_719]
.text$mn:00001F1A                 test    edx, edx
.text$mn:00001F1C                 jz      short loc_1F2E
.text$mn:00001F1E                 mov     [ebp+var_710], 1
.text$mn:00001F25                 mov     [ebp+var_712], 1
.text$mn:00001F2C                 jmp     short loc_1F6D
.text$mn:00001F2E ; ---------------------------------------------------------------------------
.text$mn:00001F2E
.text$mn:00001F2E loc_1F2E:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+454j
.text$mn:00001F2E                 lea     eax, [ebp+Buffer]
.text$mn:00001F34                 push    eax
.text$mn:00001F35                 push    offset $SG175987 ; "Cannot create the file \"%s\""
.text$mn:00001F3A                 lea     ecx, [ebp+Text]
.text$mn:00001F40                 push    ecx             ; LPWSTR
.text$mn:00001F41                 call    dword ptr ds:__imp__wsprintfW
.text$mn:00001F47                 add     esp, 0Ch
.text$mn:00001F4A                 push    0               ; uType
.text$mn:00001F4C                 push    offset $SG175988 ; "Create new file"
.text$mn:00001F51                 lea     edx, [ebp+Text]
.text$mn:00001F57                 push    edx             ; lpText
.text$mn:00001F58                 mov     eax, [ebp+var_70C]
.text$mn:00001F5E                 mov     ecx, [eax+4]    ; this
.text$mn:00001F61                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001F66                 push    eax             ; hWnd
.text$mn:00001F67                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:00001F6D
.text$mn:00001F6D loc_1F6D:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+3E8j
.text$mn:00001F6D                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+430j ...
.text$mn:00001F6D                 movzx   ecx, [ebp+var_710]
.text$mn:00001F74                 test    ecx, ecx
.text$mn:00001F76                 jnz     short loc_1FCD
.text$mn:00001F78                 movzx   edx, [ebp+var_70E]
.text$mn:00001F7F                 test    edx, edx
.text$mn:00001F81                 jz      short loc_1F97
.text$mn:00001F83                 push    1               ; int
.text$mn:00001F85                 mov     ecx, [ebp+var_72C] ; this
.text$mn:00001F8B                 call    ?safeWow64EnableWow64FsRedirection@NppParameters@@QAEXH@Z ; NppParameters::safeWow64EnableWow64FsRedirection(int)
.text$mn:00001F90                 mov     [ebp+var_70E], 0
.text$mn:00001F97
.text$mn:00001F97 loc_1F97:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+4B9j
.text$mn:00001F97                 mov     [ebp+var_764], 0
.text$mn:00001FA1                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001FA5                 lea     ecx, [ebp+var_660]
.text$mn:00001FAB                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001FB0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001FB7                 lea     ecx, [ebp+var_644]
.text$mn:00001FBD                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001FC2                 mov     eax, [ebp+var_764]
.text$mn:00001FC8                 jmp     loc_26D3
.text$mn:00001FCD ; ---------------------------------------------------------------------------
.text$mn:00001FCD
.text$mn:00001FCD loc_1FCD:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+4AEj
.text$mn:00001FCD                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001FD1                 lea     ecx, [ebp+var_660]
.text$mn:00001FD7                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001FDC
.text$mn:00001FDC loc_1FDC:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+36Cj
.text$mn:00001FDC                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+381j ...
.text$mn:00001FDC                 mov     [ebp+var_7E0], 3F6h
.text$mn:00001FE6                 mov     eax, [ebp+var_70C]
.text$mn:00001FEC                 mov     ecx, [eax+4]    ; this
.text$mn:00001FEF                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001FF4                 mov     [ebp+var_7E8], eax
.text$mn:00001FFA                 mov     [ebp+var_7E4], 0
.text$mn:00002004                 lea     ecx, [ebp+var_7E8]
.text$mn:0000200A                 push    ecx             ; struct SCNotification *
.text$mn:0000200B                 mov     ecx, [ebp+var_70C]
.text$mn:00002011                 add     ecx, 54BCCh     ; this
.text$mn:00002017                 call    ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z ; PluginsManager::notify(SCNotification const *)
.text$mn:0000201C                 cmp     [ebp+arg_C], 0FFFFFFFFh
.text$mn:00002020                 jnz     short loc_2037
.text$mn:00002022                 lea     edx, [ebp+Buffer]
.text$mn:00002028                 push    edx             ; wchar_t *
.text$mn:00002029                 mov     ecx, [ebp+var_70C] ; this
.text$mn:0000202F                 call    ?getHtmlXmlEncoding@Notepad_plus@@QBEHPB_W@Z ; Notepad_plus::getHtmlXmlEncoding(wchar_t const *)
.text$mn:00002034                 mov     [ebp+arg_C], eax
.text$mn:00002037
.text$mn:00002037 loc_2037:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+558j
.text$mn:00002037                 movzx   eax, [ebp+var_70D]
.text$mn:0000203E                 test    eax, eax
.text$mn:00002040                 jz      loc_2106
.text$mn:00002046                 mov     ecx, dword ptr [ebp+arg_14+4]
.text$mn:00002049                 push    ecx
.text$mn:0000204A                 mov     edx, dword ptr [ebp+arg_14]
.text$mn:0000204D                 push    edx             ; __int64
.text$mn:0000204E                 mov     eax, [ebp+pszPath]
.text$mn:00002051                 push    eax             ; wchar_t *
.text$mn:00002052                 mov     ecx, [ebp+arg_C]
.text$mn:00002055                 push    ecx             ; int
.text$mn:00002056                 push    0               ; __int32
.text$mn:00002058                 lea     edx, [ebp+Buffer]
.text$mn:0000205E                 push    edx             ; wchar_t *
.text$mn:0000205F                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00002064                 mov     ecx, eax        ; this
.text$mn:00002066                 call    ?loadFile@FileManager@@QAEPAVBuffer@@PB_WJH0_J@Z ; FileManager::loadFile(wchar_t const *,long,int,wchar_t const *,__int64)
.text$mn:0000206B                 mov     [ebp+var_718], eax
.text$mn:00002071                 cmp     [ebp+var_718], 0
.text$mn:00002078                 jz      loc_2104
.text$mn:0000207E                 cmp     [ebp+pszPath], 0
.text$mn:00002082                 jz      short loc_209E
.text$mn:00002084                 mov     eax, [ebp+pszPath]
.text$mn:00002087                 push    eax             ; pszPath
.text$mn:00002088                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:0000208E                 test    eax, eax
.text$mn:00002090                 jz      short loc_209E
.text$mn:00002092                 mov     [ebp+var_738], 1
.text$mn:0000209C                 jmp     short loc_20A8
.text$mn:0000209E ; ---------------------------------------------------------------------------
.text$mn:0000209E
.text$mn:0000209E loc_209E:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+5BAj
.text$mn:0000209E                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+5C8j
.text$mn:0000209E                 mov     [ebp+var_738], 0
.text$mn:000020A8
.text$mn:000020A8 loc_20A8:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+5D4j
.text$mn:000020A8                 mov     cl, byte ptr [ebp+var_738]
.text$mn:000020AE                 mov     [ebp+var_71A], cl
.text$mn:000020B4                 movzx   edx, [ebp+var_71A]
.text$mn:000020BB                 test    edx, edx
.text$mn:000020BD                 jz      short loc_2104
.text$mn:000020BF                 mov     [ebp+var_844], 0
.text$mn:000020C9                 mov     eax, [ebp+var_718]
.text$mn:000020CF                 mov     [ebp+var_840], eax
.text$mn:000020D5                 mov     [ebp+var_83C], 3FAh
.text$mn:000020DF                 lea     ecx, [ebp+var_844]
.text$mn:000020E5                 push    ecx             ; struct SCNotification *
.text$mn:000020E6                 mov     ecx, [ebp+var_70C]
.text$mn:000020EC                 add     ecx, 54BCCh     ; this
.text$mn:000020F2                 call    ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z ; PluginsManager::notify(SCNotification const *)
.text$mn:000020F7                 push    1               ; bool
.text$mn:000020F9                 mov     ecx, [ebp+var_718] ; this
.text$mn:000020FF                 call    ?setLoadedDirty@Buffer@@QAEX_N@Z ; Buffer::setLoadedDirty(bool)
.text$mn:00002104
.text$mn:00002104 loc_2104:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+5B0j
.text$mn:00002104                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+5F5j
.text$mn:00002104                 jmp     short loc_212B
.text$mn:00002106 ; ---------------------------------------------------------------------------
.text$mn:00002106
.text$mn:00002106 loc_2106:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+578j
.text$mn:00002106                 push    0
.text$mn:00002108                 push    0               ; __int64
.text$mn:0000210A                 push    0               ; wchar_t *
.text$mn:0000210C                 mov     edx, [ebp+arg_C]
.text$mn:0000210F                 push    edx             ; int
.text$mn:00002110                 push    0               ; __int32
.text$mn:00002112                 lea     eax, [ebp+Buffer]
.text$mn:00002118                 push    eax             ; wchar_t *
.text$mn:00002119                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:0000211E                 mov     ecx, eax        ; this
.text$mn:00002120                 call    ?loadFile@FileManager@@QAEPAVBuffer@@PB_WJH0_J@Z ; FileManager::loadFile(wchar_t const *,long,int,wchar_t const *,__int64)
.text$mn:00002125                 mov     [ebp+var_718], eax
.text$mn:0000212B
.text$mn:0000212B loc_212B:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64):loc_2104j
.text$mn:0000212B                 cmp     [ebp+var_718], 0
.text$mn:00002132                 jz      loc_233F
.text$mn:00002138                 mov     ecx, [ebp+var_70C]
.text$mn:0000213E                 mov     byte ptr [ecx+54C4Ch], 1
.text$mn:00002145                 mov     edx, [ebp+var_718]
.text$mn:0000214B                 push    edx             ; struct Buffer *
.text$mn:0000214C                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00002151                 mov     ecx, eax        ; this
.text$mn:00002153                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00002158                 mov     [ebp+var_720], eax
.text$mn:0000215E                 movzx   eax, [ebp+arg_8]
.text$mn:00002162                 test    eax, eax
.text$mn:00002164                 jz      short loc_2173
.text$mn:00002166                 push    1               ; bool
.text$mn:00002168                 mov     ecx, [ebp+var_720] ; this
.text$mn:0000216E                 call    ?setUserReadOnly@Buffer@@QAEX_N@Z ; Buffer::setUserReadOnly(bool)
.text$mn:00002173
.text$mn:00002173 loc_2173:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+69Cj
.text$mn:00002173                 movzx   ecx, [ebp+var_712]
.text$mn:0000217A                 test    ecx, ecx
.text$mn:0000217C                 jz      short loc_21EF
.text$mn:0000217E                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00002183                 mov     ecx, eax        ; this
.text$mn:00002185                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:0000218A                 mov     ecx, eax        ; this
.text$mn:0000218C                 call    ?getNewDocDefaultSettings@NppGUI@@QBEABUNewDocDefaultSettings@@XZ ; NppGUI::getNewDocDefaultSettings(void)
.text$mn:00002191                 mov     [ebp+var_728], eax
.text$mn:00002197                 mov     edx, [ebp+var_728]
.text$mn:0000219D                 mov     eax, [edx+10h]
.text$mn:000021A0                 push    eax             ; int
.text$mn:000021A1                 mov     ecx, [ebp+var_720] ; this
.text$mn:000021A7                 call    ?setEncoding@Buffer@@QAEXH@Z ; Buffer::setEncoding(int)
.text$mn:000021AC                 mov     ecx, [ebp+var_728]
.text$mn:000021B2                 mov     edx, [ecx]
.text$mn:000021B4                 push    edx
.text$mn:000021B5                 mov     ecx, [ebp+var_720]
.text$mn:000021BB                 call    ?setFormat@Buffer@@QAEXW4formatType@@@Z ; Buffer::setFormat(formatType)
.text$mn:000021C0                 mov     eax, [ebp+var_728]
.text$mn:000021C6                 mov     ecx, [eax+4]
.text$mn:000021C9                 push    ecx
.text$mn:000021CA                 mov     ecx, [ebp+var_720]
.text$mn:000021D0                 call    ?setUnicodeMode@Buffer@@QAEXW4UniMode@@@Z ; Buffer::setUnicodeMode(UniMode)
.text$mn:000021D5                 push    offset $SG176010
.text$mn:000021DA                 mov     edx, [ebp+var_728]
.text$mn:000021E0                 mov     eax, [edx+0Ch]
.text$mn:000021E3                 push    eax
.text$mn:000021E4                 mov     ecx, [ebp+var_720]
.text$mn:000021EA                 call    ?setLangType@Buffer@@QAEXW4LangType@@PB_W@Z ; Buffer::setLangType(LangType,wchar_t const *)
.text$mn:000021EF
.text$mn:000021EF loc_21EF:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+6B4j
.text$mn:000021EF                 mov     [ebp+var_7E0], 3EEh
.text$mn:000021F9                 mov     ecx, [ebp+var_718]
.text$mn:000021FF                 mov     [ebp+var_7E4], ecx
.text$mn:00002205                 lea     edx, [ebp+var_7E8]
.text$mn:0000220B                 push    edx             ; struct SCNotification *
.text$mn:0000220C                 mov     ecx, [ebp+var_70C]
.text$mn:00002212                 add     ecx, 54BCCh     ; this
.text$mn:00002218                 call    ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z ; PluginsManager::notify(SCNotification const *)
.text$mn:0000221D                 push    0               ; bool
.text$mn:0000221F                 mov     ecx, [ebp+var_70C] ; this
.text$mn:00002225                 call    ?currentView@Notepad_plus@@AAEHXZ ; Notepad_plus::currentView(void)
.text$mn:0000222A                 push    eax             ; int
.text$mn:0000222B                 mov     eax, [ebp+var_718]
.text$mn:00002231                 push    eax             ; struct Buffer *
.text$mn:00002232                 mov     ecx, [ebp+var_70C] ; this
.text$mn:00002238                 call    ?loadBufferIntoView@Notepad_plus@@AAEXPAVBuffer@@H_N@Z ; Notepad_plus::loadBufferIntoView(Buffer *,int,bool)
.text$mn:0000223D                 mov     ecx, [ebp+var_70C]
.text$mn:00002243                 cmp     dword ptr [ecx+54B90h], 0
.text$mn:0000224A                 jz      short loc_22BE
.text$mn:0000224C                 mov     edx, [ebp+var_70C]
.text$mn:00002252                 mov     ecx, [edx+54B90h] ; this
.text$mn:00002258                 call    ?isInTray@trayIconControler@@QBE_NXZ ; trayIconControler::isInTray(void)
.text$mn:0000225D                 movzx   eax, al
.text$mn:00002260                 test    eax, eax
.text$mn:00002262                 jz      short loc_22BE
.text$mn:00002264                 push    5               ; nCmdShow
.text$mn:00002266                 mov     ecx, [ebp+var_70C]
.text$mn:0000226C                 mov     ecx, [ecx+4]    ; this
.text$mn:0000226F                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002274                 push    eax             ; hWnd
.text$mn:00002275                 call    dword ptr ds:__imp__ShowWindow@8 ; ShowWindow(x,x)
.text$mn:0000227B                 mov     edx, [ebp+var_70C]
.text$mn:00002281                 mov     ecx, [edx+4]    ; this
.text$mn:00002284                 call    ?isPrelaunch@Notepad_plus_Window@@QBE_NXZ ; Notepad_plus_Window::isPrelaunch(void)
.text$mn:00002289                 movzx   eax, al
.text$mn:0000228C                 test    eax, eax
.text$mn:0000228E                 jnz     short loc_22A3
.text$mn:00002290                 push    2               ; unsigned __int32
.text$mn:00002292                 mov     ecx, [ebp+var_70C]
.text$mn:00002298                 mov     ecx, [ecx+54B90h] ; this
.text$mn:0000229E                 call    ?doTrayIcon@trayIconControler@@QAEHK@Z ; trayIconControler::doTrayIcon(ulong)
.text$mn:000022A3
.text$mn:000022A3 loc_22A3:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+7C6j
.text$mn:000022A3                 push    0               ; lParam
.text$mn:000022A5                 push    0               ; wParam
.text$mn:000022A7                 push    5               ; Msg
.text$mn:000022A9                 mov     edx, [ebp+var_70C]
.text$mn:000022AF                 mov     ecx, [edx+4]    ; this
.text$mn:000022B2                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000022B7                 push    eax             ; hWnd
.text$mn:000022B8                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000022BE
.text$mn:000022BE loc_22BE:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+782j
.text$mn:000022BE                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+79Aj
.text$mn:000022BE                 lea     eax, [ebp+Buffer]
.text$mn:000022C4                 push    eax             ; pszPath
.text$mn:000022C5                 call    dword ptr ds:__imp__PathRemoveFileSpecW@4 ; PathRemoveFileSpecW(x)
.text$mn:000022CB                 mov     ecx, [ebp+var_70C]
.text$mn:000022D1                 mov     byte ptr [ecx+54B68h], 1
.text$mn:000022D8                 mov     edx, [ebp+var_70C]
.text$mn:000022DE                 mov     byte ptr [edx+54C4Ch], 0
.text$mn:000022E5                 mov     [ebp+var_7E0], 3ECh
.text$mn:000022EF                 lea     eax, [ebp+var_7E8]
.text$mn:000022F5                 push    eax             ; struct SCNotification *
.text$mn:000022F6                 mov     ecx, [ebp+var_70C]
.text$mn:000022FC                 add     ecx, 54BCCh     ; this
.text$mn:00002302                 call    ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z ; PluginsManager::notify(SCNotification const *)
.text$mn:00002307                 mov     ecx, [ebp+var_70C]
.text$mn:0000230D                 cmp     dword ptr [ecx+551ACh], 0
.text$mn:00002314                 jz      short loc_233A
.text$mn:00002316                 mov     ecx, [ebp+var_70C] ; this
.text$mn:0000231C                 call    ?currentView@Notepad_plus@@AAEHXZ ; Notepad_plus::currentView(void)
.text$mn:00002321                 push    eax             ; int
.text$mn:00002322                 mov     edx, [ebp+var_720]
.text$mn:00002328                 push    edx             ; int
.text$mn:00002329                 mov     eax, [ebp+var_70C]
.text$mn:0000232F                 mov     ecx, [eax+551ACh] ; this
.text$mn:00002335                 call    ?newItem@VerticalFileSwitcher@@QAEHHH@Z ; VerticalFileSwitcher::newItem(int,int)
.text$mn:0000233A
.text$mn:0000233A loc_233A:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+84Cj
.text$mn:0000233A                 jmp     loc_2697
.text$mn:0000233F ; ---------------------------------------------------------------------------
.text$mn:0000233F
.text$mn:0000233F loc_233F:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+66Aj
.text$mn:0000233F                 movzx   ecx, [ebp+var_70F]
.text$mn:00002346                 test    ecx, ecx
.text$mn:00002348                 jnz     short loc_235C
.text$mn:0000234A                 mov     edx, [ebp+lpFileName]
.text$mn:0000234D                 push    edx             ; pszPath
.text$mn:0000234E                 call    dword ptr ds:__imp__PathIsDirectoryW@4 ; PathIsDirectoryW(x)
.text$mn:00002354                 test    eax, eax
.text$mn:00002356                 jz      loc_25FB
.text$mn:0000235C
.text$mn:0000235C loc_235C:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+880j
.text$mn:0000235C                 lea     ecx, [ebp+var_778]
.text$mn:00002362                 call    ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:00002367                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000236B                 lea     ecx, [ebp+var_788]
.text$mn:00002371                 call    ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:00002376                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000237A                 movzx   eax, [ebp+var_70F]
.text$mn:00002381                 test    eax, eax
.text$mn:00002383                 jz      loc_2445
.text$mn:00002389                 push    5Ch ; '\'       ; Ch
.text$mn:0000238B                 mov     ecx, [ebp+lpFileName]
.text$mn:0000238E                 push    ecx             ; Str
.text$mn:0000238F                 call    _wcsrchr
.text$mn:00002394                 add     esp, 8
.text$mn:00002397                 mov     [ebp+var_754], eax
.text$mn:0000239D                 mov     edx, [ebp+var_754]
.text$mn:000023A3                 sub     edx, [ebp+lpFileName]
.text$mn:000023A6                 sar     edx, 1
.text$mn:000023A8                 mov     [ebp+var_758], edx
.text$mn:000023AE                 mov     eax, [ebp+var_754]
.text$mn:000023B4                 add     eax, 2
.text$mn:000023B7                 push    eax             ; Str
.text$mn:000023B8                 lea     ecx, [ebp+var_6EC]
.text$mn:000023BE                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000023C3                 mov     byte ptr [ebp+var_4], 4
.text$mn:000023C7                 lea     ecx, [ebp+var_6EC]
.text$mn:000023CD                 push    ecx
.text$mn:000023CE                 lea     ecx, [ebp+var_788]
.text$mn:000023D4                 call    ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:000023D9                 mov     byte ptr [ebp+var_4], 3
.text$mn:000023DD                 lea     ecx, [ebp+var_6EC]
.text$mn:000023E3                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000023E8                 mov     edx, [ebp+var_758]
.text$mn:000023EE                 add     edx, 1
.text$mn:000023F1                 push    edx             ; int
.text$mn:000023F2                 mov     eax, [ebp+lpFileName]
.text$mn:000023F5                 push    eax             ; Src
.text$mn:000023F6                 lea     ecx, [ebp+var_6D0]
.text$mn:000023FC                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *,uint)
.text$mn:00002401                 mov     byte ptr [ebp+var_4], 5
.text$mn:00002405                 push    0
.text$mn:00002407                 movzx   ecx, [ebp+arg_4]
.text$mn:0000240B                 push    ecx
.text$mn:0000240C                 lea     edx, [ebp+var_778]
.text$mn:00002412                 push    edx
.text$mn:00002413                 lea     eax, [ebp+var_788]
.text$mn:00002419                 push    eax
.text$mn:0000241A                 lea     ecx, [ebp+var_6D0]
.text$mn:00002420                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002425                 push    eax
.text$mn:00002426                 mov     ecx, [ebp+var_70C]
.text$mn:0000242C                 call    ?getMatchedFileNames@Notepad_plus@@AAEXPB_WABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAV23@_N3@Z ; Notepad_plus::getMatchedFileNames(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> const &,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,bool,bool)
.text$mn:00002431                 mov     byte ptr [ebp+var_4], 3
.text$mn:00002435                 lea     ecx, [ebp+var_6D0]
.text$mn:0000243B                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002440                 jmp     loc_24EC
.text$mn:00002445 ; ---------------------------------------------------------------------------
.text$mn:00002445
.text$mn:00002445 loc_2445:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+8BBj
.text$mn:00002445                 mov     ecx, [ebp+lpFileName]
.text$mn:00002448                 push    ecx             ; Str
.text$mn:00002449                 lea     ecx, [ebp+var_698]
.text$mn:0000244F                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00002454                 mov     byte ptr [ebp+var_4], 6
.text$mn:00002458                 mov     edx, [ebp+lpFileName]
.text$mn:0000245B                 push    edx             ; lpString
.text$mn:0000245C                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00002462                 mov     ecx, [ebp+lpFileName]
.text$mn:00002465                 movzx   edx, word ptr [ecx+eax*2-2]
.text$mn:0000246A                 cmp     edx, 5Ch ; '\'
.text$mn:0000246D                 jz      short loc_247F
.text$mn:0000246F                 push    offset $SG176127 ; Str
.text$mn:00002474                 lea     ecx, [ebp+var_698]
.text$mn:0000247A                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:0000247F
.text$mn:0000247F loc_247F:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+9A5j
.text$mn:0000247F                 push    offset $SG176129 ; Str
.text$mn:00002484                 lea     ecx, [ebp+var_6B4]
.text$mn:0000248A                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000248F                 mov     byte ptr [ebp+var_4], 7
.text$mn:00002493                 lea     eax, [ebp+var_6B4]
.text$mn:00002499                 push    eax
.text$mn:0000249A                 lea     ecx, [ebp+var_788]
.text$mn:000024A0                 call    ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:000024A5                 mov     byte ptr [ebp+var_4], 6
.text$mn:000024A9                 lea     ecx, [ebp+var_6B4]
.text$mn:000024AF                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000024B4                 push    0
.text$mn:000024B6                 push    1
.text$mn:000024B8                 lea     ecx, [ebp+var_778]
.text$mn:000024BE                 push    ecx
.text$mn:000024BF                 lea     edx, [ebp+var_788]
.text$mn:000024C5                 push    edx
.text$mn:000024C6                 lea     ecx, [ebp+var_698]
.text$mn:000024CC                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000024D1                 push    eax
.text$mn:000024D2                 mov     ecx, [ebp+var_70C]
.text$mn:000024D8                 call    ?getMatchedFileNames@Notepad_plus@@AAEXPB_WABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAV23@_N3@Z ; Notepad_plus::getMatchedFileNames(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> const &,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,bool,bool)
.text$mn:000024DD                 mov     byte ptr [ebp+var_4], 3
.text$mn:000024E1                 lea     ecx, [ebp+var_698]
.text$mn:000024E7                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000024EC
.text$mn:000024EC loc_24EC:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+978j
.text$mn:000024EC                 mov     [ebp+var_711], 1
.text$mn:000024F3                 lea     ecx, [ebp+var_778]
.text$mn:000024F9                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:000024FE                 mov     [ebp+var_730], eax
.text$mn:00002504                 cmp     [ebp+var_730], 0C8h ; '+'
.text$mn:0000250E                 jbe     short loc_2571
.text$mn:00002510                 push    0               ; wchar_t *
.text$mn:00002512                 mov     eax, [ebp+var_730]
.text$mn:00002518                 push    eax             ; int
.text$mn:00002519                 push    4               ; int
.text$mn:0000251B                 push    offset $SG176133 ; "Amount of files to open is too large"
.text$mn:00002520                 push    offset $SG176134 ; "$INT_REPLACE$ files are about to be ope"...
.text$mn:00002525                 mov     ecx, [ebp+var_70C]
.text$mn:0000252B                 mov     ecx, [ecx+4]    ; this
.text$mn:0000252E                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002533                 push    eax             ; HWND
.text$mn:00002534                 push    offset $SG176135 ; "NbFileToOpenImportantWarning"
.text$mn:00002539                 mov     ecx, [ebp+var_70C]
.text$mn:0000253F                 add     ecx, 34Ch       ; this
.text$mn:00002545                 call    ?messageBox@NativeLangSpeaker@@QAEHPBDPAUHWND__@@PB_W2HH2@Z ; NativeLangSpeaker::messageBox(char const *,HWND__ *,wchar_t const *,wchar_t const *,int,int,wchar_t const *)
.text$mn:0000254A                 cmp     eax, 6
.text$mn:0000254D                 jnz     short loc_255B
.text$mn:0000254F                 mov     [ebp+var_750], 1
.text$mn:00002559                 jmp     short loc_2565
.text$mn:0000255B ; ---------------------------------------------------------------------------
.text$mn:0000255B
.text$mn:0000255B loc_255B:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+A85j
.text$mn:0000255B                 mov     [ebp+var_750], 0
.text$mn:00002565
.text$mn:00002565 loc_2565:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+A91j
.text$mn:00002565                 mov     dl, byte ptr [ebp+var_750]
.text$mn:0000256B                 mov     [ebp+var_711], dl
.text$mn:00002571
.text$mn:00002571 loc_2571:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+A46j
.text$mn:00002571                 movzx   eax, [ebp+var_711]
.text$mn:00002578                 test    eax, eax
.text$mn:0000257A                 jz      short loc_25D8
.text$mn:0000257C                 mov     [ebp+var_724], 0
.text$mn:00002586                 jmp     short loc_2597
.text$mn:00002588 ; ---------------------------------------------------------------------------
.text$mn:00002588
.text$mn:00002588 loc_2588:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+B0Ej
.text$mn:00002588                 mov     ecx, [ebp+var_724]
.text$mn:0000258E                 add     ecx, 1
.text$mn:00002591                 mov     [ebp+var_724], ecx
.text$mn:00002597
.text$mn:00002597 loc_2597:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+ABEj
.text$mn:00002597                 mov     edx, [ebp+var_724]
.text$mn:0000259D                 cmp     edx, [ebp+var_730]
.text$mn:000025A3                 jnb     short loc_25D8
.text$mn:000025A5                 push    0
.text$mn:000025A7                 push    0               ; __int64
.text$mn:000025A9                 push    0               ; pszPath
.text$mn:000025AB                 push    0FFFFFFFFh      ; int
.text$mn:000025AD                 push    0               ; bool
.text$mn:000025AF                 push    0               ; bool
.text$mn:000025B1                 mov     eax, [ebp+var_724]
.text$mn:000025B7                 push    eax
.text$mn:000025B8                 lea     ecx, [ebp+var_778]
.text$mn:000025BE                 call    ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@I@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)
.text$mn:000025C3                 mov     ecx, eax
.text$mn:000025C5                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000025CA                 push    eax             ; lpFileName
.text$mn:000025CB                 mov     ecx, [ebp+var_70C] ; this
.text$mn:000025D1                 call    ?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)
.text$mn:000025D6                 jmp     short loc_2588
.text$mn:000025D8 ; ---------------------------------------------------------------------------
.text$mn:000025D8
.text$mn:000025D8 loc_25D8:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+AB2j
.text$mn:000025D8                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+ADBj
.text$mn:000025D8                 mov     byte ptr [ebp+var_4], 2
.text$mn:000025DC                 lea     ecx, [ebp+var_788]
.text$mn:000025E2                 call    ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:000025E7                 mov     byte ptr [ebp+var_4], 0
.text$mn:000025EB                 lea     ecx, [ebp+var_778]
.text$mn:000025F1                 call    ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:000025F6                 jmp     loc_2697
.text$mn:000025FB ; ---------------------------------------------------------------------------
.text$mn:000025FB
.text$mn:000025FB loc_25FB:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+88Ej
.text$mn:000025FB                 push    offset $SG176143 ; "Can not open file \""
.text$mn:00002600                 lea     ecx, [ebp+var_67C]
.text$mn:00002606                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000260B                 mov     byte ptr [ebp+var_4], 8
.text$mn:0000260F                 lea     ecx, [ebp+Buffer]
.text$mn:00002615                 push    ecx             ; Str
.text$mn:00002616                 lea     ecx, [ebp+var_67C]
.text$mn:0000261C                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00002621                 push    offset $SG176144 ; "\"."
.text$mn:00002626                 lea     ecx, [ebp+var_67C]
.text$mn:0000262C                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00002631                 push    0               ; uType
.text$mn:00002633                 push    offset $SG176145 ; "ERROR"
.text$mn:00002638                 lea     ecx, [ebp+var_67C]
.text$mn:0000263E                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002643                 push    eax             ; lpText
.text$mn:00002644                 mov     edx, [ebp+var_70C]
.text$mn:0000264A                 mov     ecx, [edx+4]    ; this
.text$mn:0000264D                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002652                 push    eax             ; hWnd
.text$mn:00002653                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:00002659                 mov     eax, [ebp+var_70C]
.text$mn:0000265F                 mov     byte ptr [eax+54C4Ch], 0
.text$mn:00002666                 mov     [ebp+var_7E0], 3F7h
.text$mn:00002670                 lea     ecx, [ebp+var_7E8]
.text$mn:00002676                 push    ecx             ; struct SCNotification *
.text$mn:00002677                 mov     ecx, [ebp+var_70C]
.text$mn:0000267D                 add     ecx, 54BCCh     ; this
.text$mn:00002683                 call    ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z ; PluginsManager::notify(SCNotification const *)
.text$mn:00002688                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000268C                 lea     ecx, [ebp+var_67C]
.text$mn:00002692                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002697
.text$mn:00002697 loc_2697:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64):loc_233Aj
.text$mn:00002697                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+B2Ej
.text$mn:00002697                 movzx   edx, [ebp+var_70E]
.text$mn:0000269E                 test    edx, edx
.text$mn:000026A0                 jz      short loc_26AF
.text$mn:000026A2                 push    1               ; int
.text$mn:000026A4                 mov     ecx, [ebp+var_72C] ; this
.text$mn:000026AA                 call    ?safeWow64EnableWow64FsRedirection@NppParameters@@QAEXH@Z ; NppParameters::safeWow64EnableWow64FsRedirection(int)
.text$mn:000026AF
.text$mn:000026AF loc_26AF:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+BD8j
.text$mn:000026AF                 mov     eax, [ebp+var_718]
.text$mn:000026B5                 mov     [ebp+var_760], eax
.text$mn:000026BB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000026C2                 lea     ecx, [ebp+var_644]
.text$mn:000026C8                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000026CD                 mov     eax, [ebp+var_760]
.text$mn:000026D3
.text$mn:000026D3 loc_26D3:                               ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+6Fj
.text$mn:000026D3                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+82j ...
.text$mn:000026D3                 mov     ecx, [ebp+var_C]
.text$mn:000026D6                 mov     large fs:0, ecx
.text$mn:000026DD                 pop     ecx
.text$mn:000026DE                 mov     ecx, [ebp+var_10]
.text$mn:000026E1                 xor     ecx, ebp
.text$mn:000026E3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000026E8                 mov     esp, ebp
.text$mn:000026EA                 pop     ebp
.text$mn:000026EB                 retn    1Ch
.text$mn:000026EB ?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z endp ; sp-analysis failed
.text$mn:000026EB
.text$mn:000026EB ; ---------------------------------------------------------------------------
.text$mn:000026EE                 db 0Ah dup(0CCh)
.text$mn:000026F8
.text$mn:000026F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000026F8
.text$mn:000026F8 ; Attributes: bp-based frame
.text$mn:000026F8
.text$mn:000026F8 ; bool __thiscall Notepad_plus::doReload(Notepad_plus *this, struct Buffer *, bool)
.text$mn:000026F8                 public ?doReload@Notepad_plus@@QAE_NPAVBuffer@@_N@Z
.text$mn:000026F8 ?doReload@Notepad_plus@@QAE_NPAVBuffer@@_N@Z proc near
.text$mn:000026F8
.text$mn:000026F8 var_18          = dword ptr -18h
.text$mn:000026F8 var_14          = dword ptr -14h
.text$mn:000026F8 var_10          = dword ptr -10h
.text$mn:000026F8 var_C           = dword ptr -0Ch
.text$mn:000026F8 var_8           = dword ptr -8
.text$mn:000026F8 var_3           = byte ptr -3
.text$mn:000026F8 var_2           = byte ptr -2
.text$mn:000026F8 var_1           = byte ptr -1
.text$mn:000026F8 arg_0           = dword ptr  8
.text$mn:000026F8 arg_4           = byte ptr  0Ch
.text$mn:000026F8
.text$mn:000026F8                 push    ebp
.text$mn:000026F9                 mov     ebp, esp
.text$mn:000026FB                 sub     esp, 18h
.text$mn:000026FE                 mov     [ebp+var_8], ecx
.text$mn:00002701                 movzx   eax, [ebp+arg_4]
.text$mn:00002705                 test    eax, eax
.text$mn:00002707                 jz      short loc_2748
.text$mn:00002709                 push    0               ; wchar_t *
.text$mn:0000270B                 push    0               ; int
.text$mn:0000270D                 push    34h ; '4'       ; int
.text$mn:0000270F                 push    offset $SG176155 ; "Reload"
.text$mn:00002714                 push    offset $SG176156 ; "Are you sure you want to reload the cur"...
.text$mn:00002719                 mov     ecx, [ebp+var_8]
.text$mn:0000271C                 mov     ecx, [ecx+4]    ; this
.text$mn:0000271F                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002724                 push    eax             ; HWND
.text$mn:00002725                 push    offset $SG176157 ; "DocReloadWarning"
.text$mn:0000272A                 mov     ecx, [ebp+var_8]
.text$mn:0000272D                 add     ecx, 34Ch       ; this
.text$mn:00002733                 call    ?messageBox@NativeLangSpeaker@@QAEHPBDPAUHWND__@@PB_W2HH2@Z ; NativeLangSpeaker::messageBox(char const *,HWND__ *,wchar_t const *,wchar_t const *,int,int,wchar_t const *)
.text$mn:00002738                 mov     [ebp+var_18], eax
.text$mn:0000273B                 cmp     [ebp+var_18], 6
.text$mn:0000273F                 jz      short loc_2748
.text$mn:00002741                 xor     al, al
.text$mn:00002743                 jmp     loc_28AA
.text$mn:00002748 ; ---------------------------------------------------------------------------
.text$mn:00002748
.text$mn:00002748 loc_2748:                               ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+Fj
.text$mn:00002748                                         ; Notepad_plus::doReload(Buffer *,bool)+47j
.text$mn:00002748                 mov     ecx, [ebp+var_8]
.text$mn:0000274B                 add     ecx, 4C0h       ; this
.text$mn:00002751                 call    ?getCurrentBufferID@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBufferID(void)
.text$mn:00002756                 cmp     eax, [ebp+arg_0]
.text$mn:00002759                 jnz     short loc_2764
.text$mn:0000275B                 mov     [ebp+var_C], 1
.text$mn:00002762                 jmp     short loc_276B
.text$mn:00002764 ; ---------------------------------------------------------------------------
.text$mn:00002764
.text$mn:00002764 loc_2764:                               ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+61j
.text$mn:00002764                 mov     [ebp+var_C], 0
.text$mn:0000276B
.text$mn:0000276B loc_276B:                               ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+6Aj
.text$mn:0000276B                 mov     dl, byte ptr [ebp+var_C]
.text$mn:0000276E                 mov     [ebp+var_1], dl
.text$mn:00002771                 mov     ecx, [ebp+var_8]
.text$mn:00002774                 add     ecx, 464h       ; this
.text$mn:0000277A                 call    ?getCurrentBufferID@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBufferID(void)
.text$mn:0000277F                 cmp     eax, [ebp+arg_0]
.text$mn:00002782                 jnz     short loc_278D
.text$mn:00002784                 mov     [ebp+var_10], 1
.text$mn:0000278B                 jmp     short loc_2794
.text$mn:0000278D ; ---------------------------------------------------------------------------
.text$mn:0000278D
.text$mn:0000278D loc_278D:                               ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+8Aj
.text$mn:0000278D                 mov     [ebp+var_10], 0
.text$mn:00002794
.text$mn:00002794 loc_2794:                               ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+93j
.text$mn:00002794                 mov     al, byte ptr [ebp+var_10]
.text$mn:00002797                 mov     [ebp+var_2], al
.text$mn:0000279A                 movzx   ecx, [ebp+var_1]
.text$mn:0000279E                 test    ecx, ecx
.text$mn:000027A0                 jz      short loc_27C7
.text$mn:000027A2                 mov     ecx, [ebp+var_8]
.text$mn:000027A5                 add     ecx, 4C0h       ; this
.text$mn:000027AB                 call    ?saveCurrentPos@ScintillaEditView@@QAEXXZ ; ScintillaEditView::saveCurrentPos(void)
.text$mn:000027B0                 push    0               ; __int32
.text$mn:000027B2                 push    0               ; unsigned int
.text$mn:000027B4                 push    936h            ; unsigned int
.text$mn:000027B9                 mov     ecx, [ebp+var_8]
.text$mn:000027BC                 add     ecx, 4C0h       ; this
.text$mn:000027C2                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000027C7
.text$mn:000027C7 loc_27C7:                               ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+A8j
.text$mn:000027C7                 movzx   edx, [ebp+var_2]
.text$mn:000027CB                 test    edx, edx
.text$mn:000027CD                 jz      short loc_27F4
.text$mn:000027CF                 mov     ecx, [ebp+var_8]
.text$mn:000027D2                 add     ecx, 464h       ; this
.text$mn:000027D8                 call    ?saveCurrentPos@ScintillaEditView@@QAEXXZ ; ScintillaEditView::saveCurrentPos(void)
.text$mn:000027DD                 push    0               ; __int32
.text$mn:000027DF                 push    0               ; unsigned int
.text$mn:000027E1                 push    936h            ; unsigned int
.text$mn:000027E6                 mov     ecx, [ebp+var_8]
.text$mn:000027E9                 add     ecx, 464h       ; this
.text$mn:000027EF                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000027F4
.text$mn:000027F4 loc_27F4:                               ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+D5j
.text$mn:000027F4                 movzx   eax, [ebp+var_1]
.text$mn:000027F8                 test    eax, eax
.text$mn:000027FA                 jnz     short loc_2819
.text$mn:000027FC                 movzx   ecx, [ebp+var_2]
.text$mn:00002800                 test    ecx, ecx
.text$mn:00002802                 jnz     short loc_2819
.text$mn:00002804                 mov     edx, [ebp+arg_0]
.text$mn:00002807                 push    edx             ; struct Buffer *
.text$mn:00002808                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:0000280D                 mov     ecx, eax        ; this
.text$mn:0000280F                 call    ?reloadBufferDeferred@FileManager@@QAE_NPAVBuffer@@@Z ; FileManager::reloadBufferDeferred(Buffer *)
.text$mn:00002814                 jmp     loc_28AA
.text$mn:00002819 ; ---------------------------------------------------------------------------
.text$mn:00002819
.text$mn:00002819 loc_2819:                               ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+102j
.text$mn:00002819                                         ; Notepad_plus::doReload(Buffer *,bool)+10Aj
.text$mn:00002819                 mov     eax, [ebp+arg_0]
.text$mn:0000281C                 push    eax             ; struct Buffer *
.text$mn:0000281D                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00002822                 mov     ecx, eax        ; this
.text$mn:00002824                 call    ?reloadBuffer@FileManager@@QAE_NPAVBuffer@@@Z ; FileManager::reloadBuffer(Buffer *)
.text$mn:00002829                 mov     [ebp+var_3], al
.text$mn:0000282C                 mov     ecx, [ebp+arg_0]
.text$mn:0000282F                 push    ecx             ; struct Buffer *
.text$mn:00002830                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00002835                 mov     ecx, eax        ; this
.text$mn:00002837                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:0000283C                 mov     [ebp+var_14], eax
.text$mn:0000283F                 movzx   edx, [ebp+var_1]
.text$mn:00002843                 test    edx, edx
.text$mn:00002845                 jz      short loc_2873
.text$mn:00002847                 mov     ecx, [ebp+var_14] ; this
.text$mn:0000284A                 call    ?getDocument@Buffer@@QAEJXZ ; Buffer::getDocument(void)
.text$mn:0000284F                 push    eax             ; __int32
.text$mn:00002850                 push    0               ; unsigned int
.text$mn:00002852                 push    936h            ; unsigned int
.text$mn:00002857                 mov     ecx, [ebp+var_8]
.text$mn:0000285A                 add     ecx, 4C0h       ; this
.text$mn:00002860                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00002865                 mov     ecx, [ebp+var_8]
.text$mn:00002868                 add     ecx, 4C0h       ; this
.text$mn:0000286E                 call    ?restoreCurrentPos@ScintillaEditView@@QAEXXZ ; ScintillaEditView::restoreCurrentPos(void)
.text$mn:00002873
.text$mn:00002873 loc_2873:                               ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+14Dj
.text$mn:00002873                 movzx   eax, [ebp+var_2]
.text$mn:00002877                 test    eax, eax
.text$mn:00002879                 jz      short loc_28A7
.text$mn:0000287B                 mov     ecx, [ebp+var_14] ; this
.text$mn:0000287E                 call    ?getDocument@Buffer@@QAEJXZ ; Buffer::getDocument(void)
.text$mn:00002883                 push    eax             ; __int32
.text$mn:00002884                 push    0               ; unsigned int
.text$mn:00002886                 push    936h            ; unsigned int
.text$mn:0000288B                 mov     ecx, [ebp+var_8]
.text$mn:0000288E                 add     ecx, 464h       ; this
.text$mn:00002894                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00002899                 mov     ecx, [ebp+var_8]
.text$mn:0000289C                 add     ecx, 464h       ; this
.text$mn:000028A2                 call    ?restoreCurrentPos@ScintillaEditView@@QAEXXZ ; ScintillaEditView::restoreCurrentPos(void)
.text$mn:000028A7
.text$mn:000028A7 loc_28A7:                               ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+181j
.text$mn:000028A7                 mov     al, [ebp+var_3]
.text$mn:000028AA
.text$mn:000028AA loc_28AA:                               ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+4Bj
.text$mn:000028AA                                         ; Notepad_plus::doReload(Buffer *,bool)+11Cj
.text$mn:000028AA                 mov     esp, ebp
.text$mn:000028AC                 pop     ebp
.text$mn:000028AD                 retn    8
.text$mn:000028AD ?doReload@Notepad_plus@@QAE_NPAVBuffer@@_N@Z endp
.text$mn:000028AD
.text$mn:000028AD ; ---------------------------------------------------------------------------
.text$mn:000028B0                 db 8 dup(0CCh)
.text$mn:000028B8
.text$mn:000028B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000028B8
.text$mn:000028B8 ; Attributes: bp-based frame
.text$mn:000028B8
.text$mn:000028B8 ; bool __thiscall Notepad_plus::doSave(Notepad_plus *this, struct Buffer *, const wchar_t *, bool)
.text$mn:000028B8                 public ?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z
.text$mn:000028B8 ?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z proc near
.text$mn:000028B8                                         ; CODE XREF: Notepad_plus::fileSave(Buffer *)+3EBp
.text$mn:000028B8                                         ; Notepad_plus::fileSaveAs(Buffer *,bool)+1B2p
.text$mn:000028B8
.text$mn:000028B8 var_50C         = dword ptr -50Ch
.text$mn:000028B8 var_508         = dword ptr -508h
.text$mn:000028B8 var_504         = dword ptr -504h
.text$mn:000028B8 var_4B0         = dword ptr -4B0h
.text$mn:000028B8 var_4AC         = dword ptr -4ACh
.text$mn:000028B8 var_4A8         = dword ptr -4A8h
.text$mn:000028B8 var_4A4         = dword ptr -4A4h
.text$mn:000028B8 var_4A0         = dword ptr -4A0h
.text$mn:000028B8 var_49C         = dword ptr -49Ch
.text$mn:000028B8 var_497         = byte ptr -497h
.text$mn:000028B8 var_496         = byte ptr -496h
.text$mn:000028B8 var_495         = byte ptr -495h
.text$mn:000028B8 var_494         = dword ptr -494h
.text$mn:000028B8 var_490         = byte ptr -490h
.text$mn:000028B8 var_474         = byte ptr -474h
.text$mn:000028B8 var_458         = byte ptr -458h
.text$mn:000028B8 var_43C         = byte ptr -43Ch
.text$mn:000028B8 File            = word ptr -420h
.text$mn:000028B8 Filename        = word ptr -218h
.text$mn:000028B8 var_10          = dword ptr -10h
.text$mn:000028B8 var_C           = dword ptr -0Ch
.text$mn:000028B8 var_4           = dword ptr -4
.text$mn:000028B8 arg_0           = dword ptr  8
.text$mn:000028B8 arg_4           = dword ptr  0Ch
.text$mn:000028B8 arg_8           = byte ptr  10h
.text$mn:000028B8
.text$mn:000028B8                 push    ebp
.text$mn:000028B9                 mov     ebp, esp
.text$mn:000028BB                 push    0FFFFFFFFh
.text$mn:000028BD                 push    offset __ehhandler$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z
.text$mn:000028C2                 mov     eax, large fs:0
.text$mn:000028C8                 push    eax
.text$mn:000028C9                 sub     esp, 500h
.text$mn:000028CF                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000028D4                 xor     eax, ebp
.text$mn:000028D6                 mov     [ebp+var_10], eax
.text$mn:000028D9                 push    eax
.text$mn:000028DA                 lea     eax, [ebp+var_C]
.text$mn:000028DD                 mov     large fs:0, eax
.text$mn:000028E3                 mov     [ebp+var_494], ecx
.text$mn:000028E9                 movzx   eax, [ebp+arg_8]
.text$mn:000028ED                 test    eax, eax
.text$mn:000028EF                 jnz     short loc_2930
.text$mn:000028F1                 mov     [ebp+var_504], 3EFh
.text$mn:000028FB                 mov     ecx, [ebp+var_494]
.text$mn:00002901                 mov     ecx, [ecx+4]    ; this
.text$mn:00002904                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002909                 mov     [ebp+var_50C], eax
.text$mn:0000290F                 mov     edx, [ebp+arg_0]
.text$mn:00002912                 mov     [ebp+var_508], edx
.text$mn:00002918                 lea     eax, [ebp+var_50C]
.text$mn:0000291E                 push    eax             ; struct SCNotification *
.text$mn:0000291F                 mov     ecx, [ebp+var_494]
.text$mn:00002925                 add     ecx, 54BCCh     ; this
.text$mn:0000292B                 call    ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z ; PluginsManager::notify(SCNotification const *)
.text$mn:00002930
.text$mn:00002930 loc_2930:                               ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+37j
.text$mn:00002930                 lea     ecx, [ebp+var_458]
.text$mn:00002936                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000293B                 mov     [ebp+var_4], 0
.text$mn:00002942                 lea     ecx, [ebp+var_458]
.text$mn:00002948                 push    ecx
.text$mn:00002949                 movzx   edx, [ebp+arg_8]
.text$mn:0000294D                 push    edx
.text$mn:0000294E                 mov     eax, [ebp+arg_4]
.text$mn:00002951                 push    eax
.text$mn:00002952                 mov     ecx, [ebp+arg_0]
.text$mn:00002955                 push    ecx
.text$mn:00002956                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:0000295B                 mov     ecx, eax
.text$mn:0000295D                 call    ?saveBuffer@FileManager@@QAE_NPAVBuffer@@PB_W_NPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; FileManager::saveBuffer(Buffer *,wchar_t const *,bool,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00002962                 mov     [ebp+var_495], al
.text$mn:00002968                 movzx   edx, [ebp+arg_8]
.text$mn:0000296C                 test    edx, edx
.text$mn:0000296E                 jnz     short loc_2992
.text$mn:00002970                 mov     [ebp+var_504], 3F0h
.text$mn:0000297A                 lea     eax, [ebp+var_50C]
.text$mn:00002980                 push    eax             ; struct SCNotification *
.text$mn:00002981                 mov     ecx, [ebp+var_494]
.text$mn:00002987                 add     ecx, 54BCCh     ; this
.text$mn:0000298D                 call    ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z ; PluginsManager::notify(SCNotification const *)
.text$mn:00002992
.text$mn:00002992 loc_2992:                               ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+B6j
.text$mn:00002992                 movzx   ecx, [ebp+var_495]
.text$mn:00002999                 test    ecx, ecx
.text$mn:0000299B                 jnz     loc_2CF9
.text$mn:000029A1                 mov     edx, [ebp+var_494]
.text$mn:000029A7                 movzx   eax, byte ptr [edx+54C4Dh]
.text$mn:000029AE                 test    eax, eax
.text$mn:000029B0                 jnz     loc_2C88
.text$mn:000029B6                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000029BB                 mov     ecx, eax        ; this
.text$mn:000029BD                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:000029C2                 mov     ecx, eax        ; this
.text$mn:000029C4                 call    ?isSnapshotMode@NppGUI@@QBE_NXZ ; NppGUI::isSnapshotMode(void)
.text$mn:000029C9                 mov     [ebp+var_496], al
.text$mn:000029CF                 movzx   ecx, [ebp+var_496]
.text$mn:000029D6                 test    ecx, ecx
.text$mn:000029D8                 jz      loc_2AF7
.text$mn:000029DE                 push    0               ; wchar_t *
.text$mn:000029E0                 push    0               ; int
.text$mn:000029E2                 push    4               ; int
.text$mn:000029E4                 push    offset $SG176185 ; "Save failed"
.text$mn:000029E9                 push    offset $SG176186 ; "The file cannot be saved and it may be "...
.text$mn:000029EE                 mov     edx, [ebp+var_494]
.text$mn:000029F4                 mov     ecx, [edx+4]    ; this
.text$mn:000029F7                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000029FC                 push    eax             ; HWND
.text$mn:000029FD                 push    offset $SG176187 ; "OpenInAdminMode"
.text$mn:00002A02                 mov     ecx, [ebp+var_494]
.text$mn:00002A08                 add     ecx, 34Ch       ; this
.text$mn:00002A0E                 call    ?messageBox@NativeLangSpeaker@@QAEHPBDPAUHWND__@@PB_W2HH2@Z ; NativeLangSpeaker::messageBox(char const *,HWND__ *,wchar_t const *,wchar_t const *,int,int,wchar_t const *)
.text$mn:00002A13                 mov     [ebp+var_4A8], eax
.text$mn:00002A19                 cmp     [ebp+var_4A8], 6
.text$mn:00002A20                 jnz     loc_2AF2
.text$mn:00002A26                 push    104h            ; nSize
.text$mn:00002A2B                 lea     eax, [ebp+Filename]
.text$mn:00002A31                 push    eax             ; lpFilename
.text$mn:00002A32                 push    0               ; hModule
.text$mn:00002A34                 call    dword ptr ds:__imp__GetModuleFileNameW@12 ; GetModuleFileNameW(x,x,x)
.text$mn:00002A3A                 push    offset $SG176191 ; "-multiInst"
.text$mn:00002A3F                 lea     ecx, [ebp+var_474]
.text$mn:00002A45                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00002A4A                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002A4E                 push    5               ; nShowCmd
.text$mn:00002A50                 push    offset $SG176194 ; lpDirectory
.text$mn:00002A55                 lea     ecx, [ebp+var_474]
.text$mn:00002A5B                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002A60                 push    eax             ; lpParameters
.text$mn:00002A61                 lea     ecx, [ebp+Filename]
.text$mn:00002A67                 push    ecx             ; lpFile
.text$mn:00002A68                 push    offset $SG176195 ; "runas"
.text$mn:00002A6D                 mov     edx, [ebp+var_494]
.text$mn:00002A73                 mov     ecx, [edx+4]    ; this
.text$mn:00002A76                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002A7B                 push    eax             ; hwnd
.text$mn:00002A7C                 call    dword ptr ds:__imp__ShellExecuteW@24 ; ShellExecuteW(x,x,x,x,x,x)
.text$mn:00002A82                 mov     [ebp+var_4B0], eax
.text$mn:00002A88                 cmp     [ebp+var_4B0], 20h ; ' '
.text$mn:00002A8F                 jnb     short loc_2AC8
.text$mn:00002A91                 push    0               ; wchar_t *
.text$mn:00002A93                 push    0               ; int
.text$mn:00002A95                 push    0               ; int
.text$mn:00002A97                 push    offset $SG176197 ; "Open in Administrator mode failed"
.text$mn:00002A9C                 push    offset $SG176198 ; "Notepad++ cannot be opened in Administr"...
.text$mn:00002AA1                 mov     eax, [ebp+var_494]
.text$mn:00002AA7                 mov     ecx, [eax+4]    ; this
.text$mn:00002AAA                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002AAF                 push    eax             ; HWND
.text$mn:00002AB0                 push    offset $SG176199 ; "OpenInAdminModeFailed"
.text$mn:00002AB5                 mov     ecx, [ebp+var_494]
.text$mn:00002ABB                 add     ecx, 34Ch       ; this
.text$mn:00002AC1                 call    ?messageBox@NativeLangSpeaker@@QAEHPBDPAUHWND__@@PB_W2HH2@Z ; NativeLangSpeaker::messageBox(char const *,HWND__ *,wchar_t const *,wchar_t const *,int,int,wchar_t const *)
.text$mn:00002AC6                 jmp     short loc_2AE3
.text$mn:00002AC8 ; ---------------------------------------------------------------------------
.text$mn:00002AC8
.text$mn:00002AC8 loc_2AC8:                               ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+1D7j
.text$mn:00002AC8                 push    0               ; lParam
.text$mn:00002ACA                 push    0               ; wParam
.text$mn:00002ACC                 push    10h             ; Msg
.text$mn:00002ACE                 mov     ecx, [ebp+var_494]
.text$mn:00002AD4                 mov     ecx, [ecx+4]    ; this
.text$mn:00002AD7                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002ADC                 push    eax             ; hWnd
.text$mn:00002ADD                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00002AE3
.text$mn:00002AE3 loc_2AE3:                               ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+20Ej
.text$mn:00002AE3                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002AE7                 lea     ecx, [ebp+var_474]
.text$mn:00002AED                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002AF2
.text$mn:00002AF2 loc_2AF2:                               ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+168j
.text$mn:00002AF2                 jmp     loc_2C86
.text$mn:00002AF7 ; ---------------------------------------------------------------------------
.text$mn:00002AF7
.text$mn:00002AF7 loc_2AF7:                               ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+120j
.text$mn:00002AF7                 push    0               ; wchar_t *
.text$mn:00002AF9                 push    0               ; int
.text$mn:00002AFB                 push    4               ; int
.text$mn:00002AFD                 push    offset $SG176203 ; "Save failed"
.text$mn:00002B02                 push    offset $SG176204 ; "The file cannot be saved and it may be "...
.text$mn:00002B07                 mov     edx, [ebp+var_494]
.text$mn:00002B0D                 mov     ecx, [edx+4]    ; this
.text$mn:00002B10                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002B15                 push    eax             ; HWND
.text$mn:00002B16                 push    offset $SG176205 ; "OpenInAdminModeWithoutCloseCurrent"
.text$mn:00002B1B                 mov     ecx, [ebp+var_494]
.text$mn:00002B21                 add     ecx, 34Ch       ; this
.text$mn:00002B27                 call    ?messageBox@NativeLangSpeaker@@QAEHPBDPAUHWND__@@PB_W2HH2@Z ; NativeLangSpeaker::messageBox(char const *,HWND__ *,wchar_t const *,wchar_t const *,int,int,wchar_t const *)
.text$mn:00002B2C                 mov     [ebp+var_4AC], eax
.text$mn:00002B32                 cmp     [ebp+var_4AC], 6
.text$mn:00002B39                 jnz     loc_2C86
.text$mn:00002B3F                 push    104h            ; nSize
.text$mn:00002B44                 lea     eax, [ebp+File]
.text$mn:00002B4A                 push    eax             ; lpFilename
.text$mn:00002B4B                 push    0               ; hModule
.text$mn:00002B4D                 call    dword ptr ds:__imp__GetModuleFileNameW@12 ; GetModuleFileNameW(x,x,x)
.text$mn:00002B53                 mov     ecx, [ebp+var_494]
.text$mn:00002B59                 mov     ecx, [ecx+5D4h] ; this
.text$mn:00002B5F                 call    ?getCurrentBufferID@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBufferID(void)
.text$mn:00002B64                 mov     [ebp+var_49C], eax
.text$mn:00002B6A                 mov     edx, [ebp+var_49C]
.text$mn:00002B70                 mov     [ebp+var_49C], edx
.text$mn:00002B76                 mov     eax, [ebp+var_49C]
.text$mn:00002B7C                 push    eax             ; struct Buffer *
.text$mn:00002B7D                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00002B82                 mov     ecx, eax        ; this
.text$mn:00002B84                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00002B89                 mov     [ebp+var_4A0], eax
.text$mn:00002B8F                 mov     ecx, [ebp+var_4A0] ; this
.text$mn:00002B95                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00002B9A                 push    eax             ; Str
.text$mn:00002B9B                 lea     ecx, [ebp+var_490]
.text$mn:00002BA1                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00002BA6                 mov     byte ptr [ebp+var_4], 2
.text$mn:00002BAA                 push    offset $SG176212 ; "-multiInst -nosession "
.text$mn:00002BAF                 lea     ecx, [ebp+var_43C]
.text$mn:00002BB5                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00002BBA                 mov     byte ptr [ebp+var_4], 3
.text$mn:00002BBE                 push    offset $SG176213 ; Str
.text$mn:00002BC3                 lea     ecx, [ebp+var_43C]
.text$mn:00002BC9                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00002BCE                 lea     ecx, [ebp+var_490]
.text$mn:00002BD4                 push    ecx
.text$mn:00002BD5                 lea     ecx, [ebp+var_43C]
.text$mn:00002BDB                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00002BE0                 push    offset $SG176214 ; Str
.text$mn:00002BE5                 lea     ecx, [ebp+var_43C]
.text$mn:00002BEB                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00002BF0                 push    5               ; nShowCmd
.text$mn:00002BF2                 push    offset $SG176217 ; lpDirectory
.text$mn:00002BF7                 lea     ecx, [ebp+var_43C]
.text$mn:00002BFD                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002C02                 push    eax             ; lpParameters
.text$mn:00002C03                 lea     edx, [ebp+File]
.text$mn:00002C09                 push    edx             ; lpFile
.text$mn:00002C0A                 push    offset $SG176218 ; "runas"
.text$mn:00002C0F                 mov     eax, [ebp+var_494]
.text$mn:00002C15                 mov     ecx, [eax+4]    ; this
.text$mn:00002C18                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002C1D                 push    eax             ; hwnd
.text$mn:00002C1E                 call    dword ptr ds:__imp__ShellExecuteW@24 ; ShellExecuteW(x,x,x,x,x,x)
.text$mn:00002C24                 mov     [ebp+var_4A4], eax
.text$mn:00002C2A                 cmp     [ebp+var_4A4], 20h ; ' '
.text$mn:00002C31                 jnb     short loc_2C68
.text$mn:00002C33                 push    0               ; wchar_t *
.text$mn:00002C35                 push    0               ; int
.text$mn:00002C37                 push    0               ; int
.text$mn:00002C39                 push    offset $SG176220 ; "Open in Administrator mode failed"
.text$mn:00002C3E                 push    offset $SG176221 ; "Notepad++ cannot be opened in Administr"...
.text$mn:00002C43                 mov     ecx, [ebp+var_494]
.text$mn:00002C49                 mov     ecx, [ecx+4]    ; this
.text$mn:00002C4C                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002C51                 push    eax             ; HWND
.text$mn:00002C52                 push    offset $SG176222 ; "OpenInAdminModeFailed"
.text$mn:00002C57                 mov     ecx, [ebp+var_494]
.text$mn:00002C5D                 add     ecx, 34Ch       ; this
.text$mn:00002C63                 call    ?messageBox@NativeLangSpeaker@@QAEHPBDPAUHWND__@@PB_W2HH2@Z ; NativeLangSpeaker::messageBox(char const *,HWND__ *,wchar_t const *,wchar_t const *,int,int,wchar_t const *)
.text$mn:00002C68
.text$mn:00002C68 loc_2C68:                               ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+379j
.text$mn:00002C68                 mov     byte ptr [ebp+var_4], 2
.text$mn:00002C6C                 lea     ecx, [ebp+var_43C]
.text$mn:00002C72                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002C77                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002C7B                 lea     ecx, [ebp+var_490]
.text$mn:00002C81                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002C86
.text$mn:00002C86 loc_2C86:                               ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool):loc_2AF2j
.text$mn:00002C86                                         ; Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+281j
.text$mn:00002C86                 jmp     short loc_2CF9
.text$mn:00002C88 ; ---------------------------------------------------------------------------
.text$mn:00002C88
.text$mn:00002C88 loc_2C88:                               ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+F8j
.text$mn:00002C88                 lea     ecx, [ebp+var_458]
.text$mn:00002C8E                 call    ?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::empty(void)
.text$mn:00002C93                 movzx   edx, al
.text$mn:00002C96                 test    edx, edx
.text$mn:00002C98                 jz      short loc_2CD1
.text$mn:00002C9A                 push    0               ; wchar_t *
.text$mn:00002C9C                 push    0               ; int
.text$mn:00002C9E                 push    0               ; int
.text$mn:00002CA0                 push    offset $SG176225 ; "Save failed"
.text$mn:00002CA5                 push    offset $SG176226 ; "Please check if this file is opened in "...
.text$mn:00002CAA                 mov     eax, [ebp+var_494]
.text$mn:00002CB0                 mov     ecx, [eax+4]    ; this
.text$mn:00002CB3                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002CB8                 push    eax             ; HWND
.text$mn:00002CB9                 push    offset $SG176227 ; "FileLockedWarning"
.text$mn:00002CBE                 mov     ecx, [ebp+var_494]
.text$mn:00002CC4                 add     ecx, 34Ch       ; this
.text$mn:00002CCA                 call    ?messageBox@NativeLangSpeaker@@QAEHPBDPAUHWND__@@PB_W2HH2@Z ; NativeLangSpeaker::messageBox(char const *,HWND__ *,wchar_t const *,wchar_t const *,int,int,wchar_t const *)
.text$mn:00002CCF                 jmp     short loc_2CF9
.text$mn:00002CD1 ; ---------------------------------------------------------------------------
.text$mn:00002CD1
.text$mn:00002CD1 loc_2CD1:                               ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+3E0j
.text$mn:00002CD1                 push    0               ; uType
.text$mn:00002CD3                 push    offset $SG176229 ; "Save failed"
.text$mn:00002CD8                 lea     ecx, [ebp+var_458]
.text$mn:00002CDE                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002CE3                 push    eax             ; lpText
.text$mn:00002CE4                 mov     ecx, [ebp+var_494]
.text$mn:00002CEA                 mov     ecx, [ecx+4]    ; this
.text$mn:00002CED                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002CF2                 push    eax             ; hWnd
.text$mn:00002CF3                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:00002CF9
.text$mn:00002CF9 loc_2CF9:                               ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+E3j
.text$mn:00002CF9                                         ; Notepad_plus::doSave(Buffer *,wchar_t const *,bool):loc_2C86j ...
.text$mn:00002CF9                 movzx   edx, [ebp+var_495]
.text$mn:00002D00                 test    edx, edx
.text$mn:00002D02                 jz      short loc_2D62
.text$mn:00002D04                 mov     eax, [ebp+var_494]
.text$mn:00002D0A                 cmp     dword ptr [eax+551C0h], 0
.text$mn:00002D11                 jz      short loc_2D62
.text$mn:00002D13                 mov     ecx, [ebp+var_494]
.text$mn:00002D19                 mov     ecx, [ecx+551C0h] ; this
.text$mn:00002D1F                 call    ?isClosed@DockingDlgInterface@@QBE_NXZ ; DockingDlgInterface::isClosed(void)
.text$mn:00002D24                 movzx   edx, al
.text$mn:00002D27                 test    edx, edx
.text$mn:00002D29                 jnz     short loc_2D62
.text$mn:00002D2B                 mov     eax, [ebp+var_494]
.text$mn:00002D31                 mov     ecx, [eax+551C0h]
.text$mn:00002D37                 mov     edx, [ebp+var_494]
.text$mn:00002D3D                 mov     eax, [ecx]
.text$mn:00002D3F                 mov     ecx, [edx+551C0h]
.text$mn:00002D45                 mov     edx, [eax+2Ch]
.text$mn:00002D48                 call    edx
.text$mn:00002D4A                 movzx   eax, al
.text$mn:00002D4D                 test    eax, eax
.text$mn:00002D4F                 jz      short loc_2D62
.text$mn:00002D51                 mov     ecx, [ebp+var_494]
.text$mn:00002D57                 mov     ecx, [ecx+551C0h] ; this
.text$mn:00002D5D                 call    ?reload@FunctionListPanel@@QAEXXZ ; FunctionListPanel::reload(void)
.text$mn:00002D62
.text$mn:00002D62 loc_2D62:                               ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+44Aj
.text$mn:00002D62                                         ; Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+459j ...
.text$mn:00002D62                 mov     dl, [ebp+var_495]
.text$mn:00002D68                 mov     [ebp+var_497], dl
.text$mn:00002D6E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002D75                 lea     ecx, [ebp+var_458]
.text$mn:00002D7B                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002D80                 mov     al, [ebp+var_497]
.text$mn:00002D86                 mov     ecx, [ebp+var_C]
.text$mn:00002D89                 mov     large fs:0, ecx
.text$mn:00002D90                 pop     ecx
.text$mn:00002D91                 mov     ecx, [ebp+var_10]
.text$mn:00002D94                 xor     ecx, ebp
.text$mn:00002D96                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00002D9B                 mov     esp, ebp
.text$mn:00002D9D                 pop     ebp
.text$mn:00002D9E                 retn    0Ch
.text$mn:00002D9E ?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z endp
.text$mn:00002D9E
.text$mn:00002D9E ; ---------------------------------------------------------------------------
.text$mn:00002DA1                 align 8
.text$mn:00002DA8
.text$mn:00002DA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DA8
.text$mn:00002DA8 ; Attributes: bp-based frame
.text$mn:00002DA8
.text$mn:00002DA8 ; void __thiscall Notepad_plus::doClose(Notepad_plus *this, struct Buffer *, LPARAM lParam, bool)
.text$mn:00002DA8                 public ?doClose@Notepad_plus@@QAEXPAVBuffer@@H_N@Z
.text$mn:00002DA8 ?doClose@Notepad_plus@@QAEXPAVBuffer@@H_N@Z proc near
.text$mn:00002DA8                                         ; CODE XREF: Notepad_plus::fileClose(Buffer *,int)+E5p
.text$mn:00002DA8                                         ; Notepad_plus::fileCloseAll(bool,bool)+756p ...
.text$mn:00002DA8
.text$mn:00002DA8 var_88          = dword ptr -88h
.text$mn:00002DA8 var_84          = dword ptr -84h
.text$mn:00002DA8 var_80          = dword ptr -80h
.text$mn:00002DA8 var_2C          = dword ptr -2Ch
.text$mn:00002DA8 var_28          = dword ptr -28h
.text$mn:00002DA8 pszPath         = dword ptr -24h
.text$mn:00002DA8 var_20          = dword ptr -20h
.text$mn:00002DA8 var_1C          = dword ptr -1Ch
.text$mn:00002DA8 var_18          = dword ptr -18h
.text$mn:00002DA8 var_14          = dword ptr -14h
.text$mn:00002DA8 var_10          = dword ptr -10h
.text$mn:00002DA8 var_C           = dword ptr -0Ch
.text$mn:00002DA8 var_6           = byte ptr -6
.text$mn:00002DA8 var_5           = byte ptr -5
.text$mn:00002DA8 var_4           = dword ptr -4
.text$mn:00002DA8 arg_0           = dword ptr  8
.text$mn:00002DA8 lParam          = dword ptr  0Ch
.text$mn:00002DA8 arg_8           = byte ptr  10h
.text$mn:00002DA8
.text$mn:00002DA8                 push    ebp
.text$mn:00002DA9                 mov     ebp, esp
.text$mn:00002DAB                 sub     esp, 88h
.text$mn:00002DB1                 mov     [ebp+var_4], ecx
.text$mn:00002DB4                 cmp     [ebp+lParam], 0
.text$mn:00002DB8                 jnz     short loc_2DC7
.text$mn:00002DBA                 mov     eax, [ebp+var_4]
.text$mn:00002DBD                 add     eax, 35Ch
.text$mn:00002DC2                 mov     [ebp+var_18], eax
.text$mn:00002DC5                 jmp     short loc_2DD3
.text$mn:00002DC7 ; ---------------------------------------------------------------------------
.text$mn:00002DC7
.text$mn:00002DC7 loc_2DC7:                               ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+10j
.text$mn:00002DC7                 mov     ecx, [ebp+var_4]
.text$mn:00002DCA                 add     ecx, 3DCh
.text$mn:00002DD0                 mov     [ebp+var_18], ecx
.text$mn:00002DD3
.text$mn:00002DD3 loc_2DD3:                               ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+1Dj
.text$mn:00002DD3                 mov     edx, [ebp+var_18]
.text$mn:00002DD6                 mov     [ebp+var_2C], edx
.text$mn:00002DD9                 mov     eax, [ebp+arg_0]
.text$mn:00002DDC                 push    eax             ; struct Buffer *
.text$mn:00002DDD                 mov     ecx, [ebp+var_2C] ; this
.text$mn:00002DE0                 call    ?getIndexByBuffer@DocTabView@@QAEHPAVBuffer@@@Z ; DocTabView::getIndexByBuffer(Buffer *)
.text$mn:00002DE5                 mov     [ebp+var_20], eax
.text$mn:00002DE8                 cmp     [ebp+var_20], 0FFFFFFFFh
.text$mn:00002DEC                 jnz     short loc_2DF3
.text$mn:00002DEE                 jmp     loc_2FCC
.text$mn:00002DF3 ; ---------------------------------------------------------------------------
.text$mn:00002DF3
.text$mn:00002DF3 loc_2DF3:                               ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+44j
.text$mn:00002DF3                 movzx   ecx, [ebp+arg_8]
.text$mn:00002DF7                 test    ecx, ecx
.text$mn:00002DF9                 jz      short loc_2E07
.text$mn:00002DFB                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00002E00                 mov     ecx, eax        ; this
.text$mn:00002E02                 call    ?deleteCurrentBufferBackup@FileManager@@QAE_NXZ ; FileManager::deleteCurrentBufferBackup(void)
.text$mn:00002E07
.text$mn:00002E07 loc_2E07:                               ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+51j
.text$mn:00002E07                 mov     edx, [ebp+arg_0]
.text$mn:00002E0A                 push    edx             ; struct Buffer *
.text$mn:00002E0B                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00002E10                 mov     ecx, eax        ; this
.text$mn:00002E12                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00002E17                 mov     [ebp+var_C], eax
.text$mn:00002E1A                 mov     [ebp+var_80], 3EBh
.text$mn:00002E21                 mov     eax, [ebp+var_4]
.text$mn:00002E24                 mov     ecx, [eax+4]    ; this
.text$mn:00002E27                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002E2C                 mov     [ebp+var_88], eax
.text$mn:00002E32                 mov     ecx, [ebp+arg_0]
.text$mn:00002E35                 mov     [ebp+var_84], ecx
.text$mn:00002E3B                 lea     edx, [ebp+var_88]
.text$mn:00002E41                 push    edx             ; struct SCNotification *
.text$mn:00002E42                 mov     ecx, [ebp+var_4]
.text$mn:00002E45                 add     ecx, 54BCCh     ; this
.text$mn:00002E4B                 call    ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z ; PluginsManager::notify(SCNotification const *)
.text$mn:00002E50                 mov     ecx, [ebp+var_C] ; this
.text$mn:00002E53                 call    ?isUntitled@Buffer@@QBE_NXZ ; Buffer::isUntitled(void)
.text$mn:00002E58                 movzx   eax, al
.text$mn:00002E5B                 test    eax, eax
.text$mn:00002E5D                 jnz     short loc_2ECE
.text$mn:00002E5F                 mov     [ebp+var_5], 0
.text$mn:00002E63                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00002E68                 mov     [ebp+var_14], eax
.text$mn:00002E6B                 mov     ecx, [ebp+var_C] ; this
.text$mn:00002E6E                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00002E73                 mov     [ebp+pszPath], eax
.text$mn:00002E76                 mov     ecx, [ebp+pszPath]
.text$mn:00002E79                 push    ecx             ; pszPath
.text$mn:00002E7A                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:00002E80                 test    eax, eax
.text$mn:00002E82                 jnz     short loc_2E92
.text$mn:00002E84                 push    0               ; int
.text$mn:00002E86                 mov     ecx, [ebp+var_14] ; this
.text$mn:00002E89                 call    ?safeWow64EnableWow64FsRedirection@NppParameters@@QAEXH@Z ; NppParameters::safeWow64EnableWow64FsRedirection(int)
.text$mn:00002E8E                 mov     [ebp+var_5], 1
.text$mn:00002E92
.text$mn:00002E92 loc_2E92:                               ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+DAj
.text$mn:00002E92                 mov     ecx, [ebp+var_C] ; this
.text$mn:00002E95                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00002E9A                 push    eax             ; pszPath
.text$mn:00002E9B                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:00002EA1                 test    eax, eax
.text$mn:00002EA3                 jz      short loc_2EBC
.text$mn:00002EA5                 mov     ecx, [ebp+var_C] ; this
.text$mn:00002EA8                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00002EAD                 push    eax             ; wchar_t *
.text$mn:00002EAE                 mov     ecx, [ebp+var_4]
.text$mn:00002EB1                 add     ecx, 54A90h     ; this
.text$mn:00002EB7                 call    ?add@LastRecentFileList@@QAEXPB_W@Z ; LastRecentFileList::add(wchar_t const *)
.text$mn:00002EBC
.text$mn:00002EBC loc_2EBC:                               ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+FBj
.text$mn:00002EBC                 movzx   edx, [ebp+var_5]
.text$mn:00002EC0                 test    edx, edx
.text$mn:00002EC2                 jz      short loc_2ECE
.text$mn:00002EC4                 push    1               ; int
.text$mn:00002EC6                 mov     ecx, [ebp+var_14] ; this
.text$mn:00002EC9                 call    ?safeWow64EnableWow64FsRedirection@NppParameters@@QAEXH@Z ; NppParameters::safeWow64EnableWow64FsRedirection(int)
.text$mn:00002ECE
.text$mn:00002ECE loc_2ECE:                               ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+B5j
.text$mn:00002ECE                                         ; Notepad_plus::doClose(Buffer *,int,bool)+11Aj
.text$mn:00002ECE                 cmp     [ebp+lParam], 0
.text$mn:00002ED2                 jnz     short loc_2EE7
.text$mn:00002ED4                 mov     ecx, [ebp+var_4]
.text$mn:00002ED7                 add     ecx, 35Ch       ; this
.text$mn:00002EDD                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:00002EE2                 mov     [ebp+var_1C], eax
.text$mn:00002EE5                 jmp     short loc_2EF8
.text$mn:00002EE7 ; ---------------------------------------------------------------------------
.text$mn:00002EE7
.text$mn:00002EE7 loc_2EE7:                               ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+12Aj
.text$mn:00002EE7                 mov     ecx, [ebp+var_4]
.text$mn:00002EEA                 add     ecx, 3DCh       ; this
.text$mn:00002EF0                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:00002EF5                 mov     [ebp+var_1C], eax
.text$mn:00002EF8
.text$mn:00002EF8 loc_2EF8:                               ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+13Dj
.text$mn:00002EF8                 mov     eax, [ebp+var_1C]
.text$mn:00002EFB                 mov     [ebp+var_28], eax
.text$mn:00002EFE                 mov     ecx, [ebp+lParam]
.text$mn:00002F01                 push    ecx             ; int
.text$mn:00002F02                 mov     edx, [ebp+arg_0]
.text$mn:00002F05                 push    edx             ; struct Buffer *
.text$mn:00002F06                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002F09                 call    ?removeBufferFromView@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::removeBufferFromView(Buffer *,int)
.text$mn:00002F0E                 mov     [ebp+var_6], al
.text$mn:00002F11                 mov     [ebp+var_10], 0FFFFFFFFh
.text$mn:00002F18                 cmp     [ebp+var_28], 1
.text$mn:00002F1C                 jnz     short loc_2F5D
.text$mn:00002F1E                 mov     eax, [ebp+lParam]
.text$mn:00002F21                 push    eax             ; int
.text$mn:00002F22                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002F25                 call    ?canHideView@Notepad_plus@@AAE_NH@Z ; Notepad_plus::canHideView(int)
.text$mn:00002F2A                 movzx   ecx, al
.text$mn:00002F2D                 test    ecx, ecx
.text$mn:00002F2F                 jz      short loc_2F5D
.text$mn:00002F31                 mov     edx, [ebp+lParam]
.text$mn:00002F34                 push    edx             ; int
.text$mn:00002F35                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002F38                 call    ?hideView@Notepad_plus@@AAEXH@Z ; Notepad_plus::hideView(int)
.text$mn:00002F3D                 mov     eax, [ebp+lParam]
.text$mn:00002F40                 push    eax             ; lParam
.text$mn:00002F41                 push    0               ; wParam
.text$mn:00002F43                 push    823h            ; Msg
.text$mn:00002F48                 mov     ecx, [ebp+var_4]
.text$mn:00002F4B                 mov     ecx, [ecx+4]    ; this
.text$mn:00002F4E                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002F53                 push    eax             ; hWnd
.text$mn:00002F54                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00002F5A                 mov     [ebp+var_10], eax
.text$mn:00002F5D
.text$mn:00002F5D loc_2F5D:                               ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+174j
.text$mn:00002F5D                                         ; Notepad_plus::doClose(Buffer *,int,bool)+187j
.text$mn:00002F5D                 movzx   edx, [ebp+var_6]
.text$mn:00002F61                 test    edx, edx
.text$mn:00002F63                 jz      short loc_2FBF
.text$mn:00002F65                 mov     [ebp+var_80], 3EDh
.text$mn:00002F6C                 lea     eax, [ebp+var_88]
.text$mn:00002F72                 push    eax             ; struct SCNotification *
.text$mn:00002F73                 mov     ecx, [ebp+var_4]
.text$mn:00002F76                 add     ecx, 54BCCh     ; this
.text$mn:00002F7C                 call    ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z ; PluginsManager::notify(SCNotification const *)
.text$mn:00002F81                 mov     ecx, [ebp+var_4]
.text$mn:00002F84                 cmp     dword ptr [ecx+551ACh], 0
.text$mn:00002F8B                 jz      short loc_2FBF
.text$mn:00002F8D                 mov     edx, [ebp+lParam]
.text$mn:00002F90                 push    edx             ; int
.text$mn:00002F91                 mov     eax, [ebp+arg_0]
.text$mn:00002F94                 push    eax             ; int
.text$mn:00002F95                 mov     ecx, [ebp+var_4]
.text$mn:00002F98                 mov     ecx, [ecx+551ACh] ; this
.text$mn:00002F9E                 call    ?closeItem@VerticalFileSwitcher@@QAEHHH@Z ; VerticalFileSwitcher::closeItem(int,int)
.text$mn:00002FA3                 cmp     [ebp+var_10], 0FFFFFFFFh
.text$mn:00002FA7                 jz      short loc_2FBF
.text$mn:00002FA9                 mov     edx, [ebp+lParam]
.text$mn:00002FAC                 push    edx             ; int
.text$mn:00002FAD                 mov     eax, [ebp+var_10]
.text$mn:00002FB0                 push    eax             ; int
.text$mn:00002FB1                 mov     ecx, [ebp+var_4]
.text$mn:00002FB4                 mov     ecx, [ecx+551ACh] ; this
.text$mn:00002FBA                 call    ?closeItem@VerticalFileSwitcher@@QAEHHH@Z ; VerticalFileSwitcher::closeItem(int,int)
.text$mn:00002FBF
.text$mn:00002FBF loc_2FBF:                               ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+1BBj
.text$mn:00002FBF                                         ; Notepad_plus::doClose(Buffer *,int,bool)+1E3j ...
.text$mn:00002FBF                 push    0AC08h          ; int
.text$mn:00002FC4                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002FC7                 call    ?command@Notepad_plus@@AAEXH@Z ; Notepad_plus::command(int)
.text$mn:00002FCC
.text$mn:00002FCC loc_2FCC:                               ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+46j
.text$mn:00002FCC                 mov     esp, ebp
.text$mn:00002FCE                 pop     ebp
.text$mn:00002FCF                 retn    0Ch
.text$mn:00002FCF ?doClose@Notepad_plus@@QAEXPAVBuffer@@H_N@Z endp
.text$mn:00002FCF
.text$mn:00002FCF ; ---------------------------------------------------------------------------
.text$mn:00002FD2                 align 8
.text$mn:00002FD8
.text$mn:00002FD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FD8
.text$mn:00002FD8 ; Attributes: bp-based frame
.text$mn:00002FD8
.text$mn:00002FD8 ; void __thiscall Notepad_plus::fileOpen(Notepad_plus *__hidden this)
.text$mn:00002FD8                 public ?fileOpen@Notepad_plus@@QAEXXZ
.text$mn:00002FD8 ?fileOpen@Notepad_plus@@QAEXXZ proc near
.text$mn:00002FD8
.text$mn:00002FD8 var_10E4        = dword ptr -10E4h
.text$mn:00002FD8 var_10E0        = dword ptr -10E0h
.text$mn:00002FD8 var_10DC        = dword ptr -10DCh
.text$mn:00002FD8 var_10D8        = dword ptr -10D8h
.text$mn:00002FD8 var_10D4        = dword ptr -10D4h
.text$mn:00002FD8 var_10D0        = dword ptr -10D0h
.text$mn:00002FD8 var_10CC        = byte ptr -10CCh
.text$mn:00002FD8 var_10          = dword ptr -10h
.text$mn:00002FD8 var_C           = dword ptr -0Ch
.text$mn:00002FD8 var_4           = dword ptr -4
.text$mn:00002FD8
.text$mn:00002FD8                 push    ebp
.text$mn:00002FD9                 mov     ebp, esp
.text$mn:00002FDB                 push    0FFFFFFFFh
.text$mn:00002FDD                 push    offset __ehhandler$?fileOpen@Notepad_plus@@QAEXXZ
.text$mn:00002FE2                 mov     eax, large fs:0
.text$mn:00002FE8                 push    eax
.text$mn:00002FE9                 mov     eax, 10D8h
.text$mn:00002FEE                 call    __chkstk
.text$mn:00002FF3                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002FF8                 xor     eax, ebp
.text$mn:00002FFA                 mov     [ebp+var_10], eax
.text$mn:00002FFD                 push    eax
.text$mn:00002FFE                 lea     eax, [ebp+var_C]
.text$mn:00003001                 mov     large fs:0, eax
.text$mn:00003007                 mov     [ebp+var_10D0], ecx
.text$mn:0000300D                 mov     eax, [ebp+var_10D0]
.text$mn:00003013                 mov     ecx, [eax+4]    ; this
.text$mn:00003016                 call    ?getHinst@Window@@QBEPAUHINSTANCE__@@XZ ; Window::getHinst(void)
.text$mn:0000301B                 push    eax
.text$mn:0000301C                 mov     ecx, [ebp+var_10D0]
.text$mn:00003022                 mov     ecx, [ecx+4]    ; this
.text$mn:00003025                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:0000302A                 push    eax
.text$mn:0000302B                 lea     ecx, [ebp+var_10CC]
.text$mn:00003031                 call    ??0FileDialog@@QAE@PAUHWND__@@PAUHINSTANCE__@@@Z ; FileDialog::FileDialog(HWND__ *,HINSTANCE__ *)
.text$mn:00003036                 mov     [ebp+var_4], 0
.text$mn:0000303D                 push    0
.text$mn:0000303F                 push    offset $SG177031 ; ".*"
.text$mn:00003044                 push    offset $SG177032 ; "All types"
.text$mn:00003049                 lea     edx, [ebp+var_10CC]
.text$mn:0000304F                 push    edx             ; this
.text$mn:00003050                 call    ?setExtFilter@FileDialog@@QAAXPB_W0ZZ ; FileDialog::setExtFilter(wchar_t const *,wchar_t const *,...)
.text$mn:00003055                 add     esp, 10h
.text$mn:00003058                 push    0FFFFFFFFh      ; int
.text$mn:0000305A                 lea     eax, [ebp+var_10CC]
.text$mn:00003060                 push    eax             ; struct FileDialog *
.text$mn:00003061                 mov     ecx, [ebp+var_10D0] ; this
.text$mn:00003067                 call    ?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z ; Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)
.text$mn:0000306C                 mov     [ebp+var_10D8], 0
.text$mn:00003076                 lea     ecx, [ebp+var_10CC]
.text$mn:0000307C                 call    ?doOpenMultiFilesDlg@FileDialog@@QAEPAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@XZ ; FileDialog::doOpenMultiFilesDlg(void)
.text$mn:00003081                 mov     [ebp+var_10DC], eax
.text$mn:00003087                 cmp     [ebp+var_10DC], 0
.text$mn:0000308E                 jz      loc_3129
.text$mn:00003094                 mov     ecx, [ebp+var_10DC]
.text$mn:0000309A                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:0000309F                 mov     [ebp+var_10E4], eax
.text$mn:000030A5                 mov     [ebp+var_10D4], 0
.text$mn:000030AF                 jmp     short loc_30C0
.text$mn:000030B1 ; ---------------------------------------------------------------------------
.text$mn:000030B1
.text$mn:000030B1 loc_30B1:                               ; CODE XREF: Notepad_plus::fileOpen(void):loc_3127j
.text$mn:000030B1                 mov     ecx, [ebp+var_10D4]
.text$mn:000030B7                 add     ecx, 1
.text$mn:000030BA                 mov     [ebp+var_10D4], ecx
.text$mn:000030C0
.text$mn:000030C0 loc_30C0:                               ; CODE XREF: Notepad_plus::fileOpen(void)+D7j
.text$mn:000030C0                 mov     edx, [ebp+var_10D4]
.text$mn:000030C6                 cmp     edx, [ebp+var_10E4]
.text$mn:000030CC                 jnb     short loc_3129
.text$mn:000030CE                 push    0
.text$mn:000030D0                 push    0               ; __int64
.text$mn:000030D2                 push    0               ; pszPath
.text$mn:000030D4                 push    0FFFFFFFFh      ; int
.text$mn:000030D6                 push    0               ; bool
.text$mn:000030D8                 lea     ecx, [ebp+var_10CC] ; this
.text$mn:000030DE                 call    ?isReadOnly@FileDialog@@QAE_NXZ ; FileDialog::isReadOnly(void)
.text$mn:000030E3                 movzx   eax, al
.text$mn:000030E6                 push    eax             ; bool
.text$mn:000030E7                 mov     ecx, [ebp+var_10D4]
.text$mn:000030ED                 push    ecx
.text$mn:000030EE                 mov     ecx, [ebp+var_10DC]
.text$mn:000030F4                 call    ?at@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::at(uint)
.text$mn:000030F9                 mov     ecx, eax
.text$mn:000030FB                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00003100                 push    eax             ; lpFileName
.text$mn:00003101                 mov     ecx, [ebp+var_10D0] ; this
.text$mn:00003107                 call    ?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)
.text$mn:0000310C                 mov     [ebp+var_10E0], eax
.text$mn:00003112                 cmp     [ebp+var_10E0], 0
.text$mn:00003119                 jz      short loc_3127
.text$mn:0000311B                 mov     edx, [ebp+var_10E0]
.text$mn:00003121                 mov     [ebp+var_10D8], edx
.text$mn:00003127
.text$mn:00003127 loc_3127:                               ; CODE XREF: Notepad_plus::fileOpen(void)+141j
.text$mn:00003127                 jmp     short loc_30B1
.text$mn:00003129 ; ---------------------------------------------------------------------------
.text$mn:00003129
.text$mn:00003129 loc_3129:                               ; CODE XREF: Notepad_plus::fileOpen(void)+B6j
.text$mn:00003129                                         ; Notepad_plus::fileOpen(void)+F4j
.text$mn:00003129                 cmp     [ebp+var_10D8], 0
.text$mn:00003130                 jz      short loc_3144
.text$mn:00003132                 mov     eax, [ebp+var_10D8]
.text$mn:00003138                 push    eax             ; struct Buffer *
.text$mn:00003139                 mov     ecx, [ebp+var_10D0] ; this
.text$mn:0000313F                 call    ?switchToFile@Notepad_plus@@QAE_NPAVBuffer@@@Z ; Notepad_plus::switchToFile(Buffer *)
.text$mn:00003144
.text$mn:00003144 loc_3144:                               ; CODE XREF: Notepad_plus::fileOpen(void)+158j
.text$mn:00003144                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000314B                 lea     ecx, [ebp+var_10CC] ; this
.text$mn:00003151                 call    ??1FileDialog@@QAE@XZ ; FileDialog::~FileDialog(void)
.text$mn:00003156                 mov     ecx, [ebp+var_C]
.text$mn:00003159                 mov     large fs:0, ecx
.text$mn:00003160                 pop     ecx
.text$mn:00003161                 mov     ecx, [ebp+var_10]
.text$mn:00003164                 xor     ecx, ebp
.text$mn:00003166                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000316B                 mov     esp, ebp
.text$mn:0000316D                 pop     ebp
.text$mn:0000316E                 retn
.text$mn:0000316E ?fileOpen@Notepad_plus@@QAEXXZ endp
.text$mn:0000316E
.text$mn:0000316E ; ---------------------------------------------------------------------------
.text$mn:0000316F                 db 9 dup(0CCh)
.text$mn:00003178
.text$mn:00003178 ; =============== S U B R O U T I N E =======================================
.text$mn:00003178
.text$mn:00003178 ; Attributes: bp-based frame
.text$mn:00003178
.text$mn:00003178 ; void __thiscall Notepad_plus::fileNew(Notepad_plus *__hidden this)
.text$mn:00003178                 public ?fileNew@Notepad_plus@@QAEXXZ
.text$mn:00003178 ?fileNew@Notepad_plus@@QAEXXZ proc near
.text$mn:00003178
.text$mn:00003178 var_8           = dword ptr -8
.text$mn:00003178 var_4           = dword ptr -4
.text$mn:00003178
.text$mn:00003178                 push    ebp
.text$mn:00003179                 mov     ebp, esp
.text$mn:0000317B                 sub     esp, 8
.text$mn:0000317E                 mov     [ebp+var_4], ecx
.text$mn:00003181                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00003186                 mov     ecx, eax        ; this
.text$mn:00003188                 call    ?newEmptyDocument@FileManager@@QAEPAVBuffer@@XZ ; FileManager::newEmptyDocument(void)
.text$mn:0000318D                 mov     [ebp+var_8], eax
.text$mn:00003190                 push    1               ; bool
.text$mn:00003192                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003195                 call    ?currentView@Notepad_plus@@AAEHXZ ; Notepad_plus::currentView(void)
.text$mn:0000319A                 push    eax             ; int
.text$mn:0000319B                 mov     eax, [ebp+var_8]
.text$mn:0000319E                 push    eax             ; struct Buffer *
.text$mn:0000319F                 mov     ecx, [ebp+var_4] ; this
.text$mn:000031A2                 call    ?loadBufferIntoView@Notepad_plus@@AAEXPAVBuffer@@H_N@Z ; Notepad_plus::loadBufferIntoView(Buffer *,int,bool)
.text$mn:000031A7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000031AA                 call    ?currentView@Notepad_plus@@AAEHXZ ; Notepad_plus::currentView(void)
.text$mn:000031AF                 push    eax             ; int
.text$mn:000031B0                 mov     ecx, [ebp+var_8]
.text$mn:000031B3                 push    ecx             ; struct Buffer *
.text$mn:000031B4                 mov     ecx, [ebp+var_4] ; this
.text$mn:000031B7                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:000031BC                 mov     esp, ebp
.text$mn:000031BE                 pop     ebp
.text$mn:000031BF                 retn
.text$mn:000031BF ?fileNew@Notepad_plus@@QAEXXZ endp
.text$mn:000031BF
.text$mn:000031BF ; ---------------------------------------------------------------------------
.text$mn:000031C0                 db 8 dup(0CCh)
.text$mn:000031C8
.text$mn:000031C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000031C8
.text$mn:000031C8 ; Attributes: bp-based frame
.text$mn:000031C8
.text$mn:000031C8 ; bool __thiscall Notepad_plus::fileClose(Notepad_plus *this, struct Buffer *, int)
.text$mn:000031C8                 public ?fileClose@Notepad_plus@@QAE_NPAVBuffer@@H@Z
.text$mn:000031C8 ?fileClose@Notepad_plus@@QAE_NPAVBuffer@@H@Z proc near
.text$mn:000031C8
.text$mn:000031C8 var_1C          = dword ptr -1Ch
.text$mn:000031C8 lParam          = dword ptr -18h
.text$mn:000031C8 var_14          = dword ptr -14h
.text$mn:000031C8 var_10          = dword ptr -10h
.text$mn:000031C8 var_C           = dword ptr -0Ch
.text$mn:000031C8 var_8           = dword ptr -8
.text$mn:000031C8 var_1           = byte ptr -1
.text$mn:000031C8 arg_0           = dword ptr  8
.text$mn:000031C8 arg_4           = dword ptr  0Ch
.text$mn:000031C8
.text$mn:000031C8                 push    ebp
.text$mn:000031C9                 mov     ebp, esp
.text$mn:000031CB                 sub     esp, 1Ch
.text$mn:000031CE                 mov     [ebp+var_8], ecx
.text$mn:000031D1                 mov     eax, [ebp+arg_0]
.text$mn:000031D4                 mov     [ebp+var_10], eax
.text$mn:000031D7                 cmp     [ebp+arg_0], 0
.text$mn:000031DB                 jnz     short loc_31EE
.text$mn:000031DD                 mov     ecx, [ebp+var_8]
.text$mn:000031E0                 mov     ecx, [ecx+5D4h] ; this
.text$mn:000031E6                 call    ?getCurrentBufferID@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBufferID(void)
.text$mn:000031EB                 mov     [ebp+var_10], eax
.text$mn:000031EE
.text$mn:000031EE loc_31EE:                               ; CODE XREF: Notepad_plus::fileClose(Buffer *,int)+13j
.text$mn:000031EE                 mov     edx, [ebp+var_10]
.text$mn:000031F1                 push    edx             ; struct Buffer *
.text$mn:000031F2                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:000031F7                 mov     ecx, eax        ; this
.text$mn:000031F9                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:000031FE                 mov     [ebp+var_C], eax
.text$mn:00003201                 mov     ecx, [ebp+var_C] ; this
.text$mn:00003204                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00003209                 mov     [ebp+var_1C], eax
.text$mn:0000320C                 mov     ecx, [ebp+var_C] ; this
.text$mn:0000320F                 call    ?isUntitled@Buffer@@QBE_NXZ ; Buffer::isUntitled(void)
.text$mn:00003214                 movzx   eax, al
.text$mn:00003217                 test    eax, eax
.text$mn:00003219                 jz      short loc_3229
.text$mn:0000321B                 mov     ecx, [ebp+var_C] ; this
.text$mn:0000321E                 call    ?docLength@Buffer@@QBEHXZ ; Buffer::docLength(void)
.text$mn:00003223                 test    eax, eax
.text$mn:00003225                 jnz     short loc_3229
.text$mn:00003227                 jmp     short loc_3270
.text$mn:00003229 ; ---------------------------------------------------------------------------
.text$mn:00003229
.text$mn:00003229 loc_3229:                               ; CODE XREF: Notepad_plus::fileClose(Buffer *,int)+51j
.text$mn:00003229                                         ; Notepad_plus::fileClose(Buffer *,int)+5Dj
.text$mn:00003229                 mov     ecx, [ebp+var_C] ; this
.text$mn:0000322C                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:00003231                 movzx   ecx, al
.text$mn:00003234                 test    ecx, ecx
.text$mn:00003236                 jz      short loc_3270
.text$mn:00003238                 mov     edx, [ebp+var_1C]
.text$mn:0000323B                 push    edx             ; wchar_t *
.text$mn:0000323C                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000323F                 call    ?doSaveOrNot@Notepad_plus@@AAEHPB_W@Z ; Notepad_plus::doSaveOrNot(wchar_t const *)
.text$mn:00003244                 mov     [ebp+var_14], eax
.text$mn:00003247                 cmp     [ebp+var_14], 6
.text$mn:0000324B                 jnz     short loc_3266
.text$mn:0000324D                 mov     eax, [ebp+arg_0]
.text$mn:00003250                 push    eax             ; struct Buffer *
.text$mn:00003251                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003254                 call    ?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z ; Notepad_plus::fileSave(Buffer *)
.text$mn:00003259                 movzx   ecx, al
.text$mn:0000325C                 test    ecx, ecx
.text$mn:0000325E                 jnz     short loc_3264
.text$mn:00003260                 xor     al, al
.text$mn:00003262                 jmp     short loc_32B4
.text$mn:00003264 ; ---------------------------------------------------------------------------
.text$mn:00003264
.text$mn:00003264 loc_3264:                               ; CODE XREF: Notepad_plus::fileClose(Buffer *,int)+96j
.text$mn:00003264                 jmp     short loc_3270
.text$mn:00003266 ; ---------------------------------------------------------------------------
.text$mn:00003266
.text$mn:00003266 loc_3266:                               ; CODE XREF: Notepad_plus::fileClose(Buffer *,int)+83j
.text$mn:00003266                 cmp     [ebp+var_14], 2
.text$mn:0000326A                 jnz     short loc_3270
.text$mn:0000326C                 xor     al, al
.text$mn:0000326E                 jmp     short loc_32B4
.text$mn:00003270 ; ---------------------------------------------------------------------------
.text$mn:00003270
.text$mn:00003270 loc_3270:                               ; CODE XREF: Notepad_plus::fileClose(Buffer *,int)+5Fj
.text$mn:00003270                                         ; Notepad_plus::fileClose(Buffer *,int)+6Ej ...
.text$mn:00003270                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003273                 call    ?currentView@Notepad_plus@@AAEHXZ ; Notepad_plus::currentView(void)
.text$mn:00003278                 mov     [ebp+lParam], eax
.text$mn:0000327B                 cmp     [ebp+arg_4], 0FFFFFFFFh
.text$mn:0000327F                 jz      short loc_3287
.text$mn:00003281                 mov     edx, [ebp+arg_4]
.text$mn:00003284                 mov     [ebp+lParam], edx
.text$mn:00003287
.text$mn:00003287 loc_3287:                               ; CODE XREF: Notepad_plus::fileClose(Buffer *,int)+B7j
.text$mn:00003287                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:0000328C                 mov     ecx, eax        ; this
.text$mn:0000328E                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00003293                 mov     ecx, eax        ; this
.text$mn:00003295                 call    ?isSnapshotMode@NppGUI@@QBE_NXZ ; NppGUI::isSnapshotMode(void)
.text$mn:0000329A                 mov     [ebp+var_1], al
.text$mn:0000329D                 movzx   eax, [ebp+var_1]
.text$mn:000032A1                 push    eax             ; bool
.text$mn:000032A2                 mov     ecx, [ebp+lParam]
.text$mn:000032A5                 push    ecx             ; lParam
.text$mn:000032A6                 mov     edx, [ebp+var_10]
.text$mn:000032A9                 push    edx             ; struct Buffer *
.text$mn:000032AA                 mov     ecx, [ebp+var_8] ; this
.text$mn:000032AD                 call    ?doClose@Notepad_plus@@QAEXPAVBuffer@@H_N@Z ; Notepad_plus::doClose(Buffer *,int,bool)
.text$mn:000032B2                 mov     al, 1
.text$mn:000032B4
.text$mn:000032B4 loc_32B4:                               ; CODE XREF: Notepad_plus::fileClose(Buffer *,int)+9Aj
.text$mn:000032B4                                         ; Notepad_plus::fileClose(Buffer *,int)+A6j
.text$mn:000032B4                 mov     esp, ebp
.text$mn:000032B6                 pop     ebp
.text$mn:000032B7                 retn    8
.text$mn:000032B7 ?fileClose@Notepad_plus@@QAE_NPAVBuffer@@H@Z endp
.text$mn:000032B7
.text$mn:000032B7 ; ---------------------------------------------------------------------------
.text$mn:000032BA                 db 0Eh dup(0CCh)
.text$mn:000032C8
.text$mn:000032C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000032C8
.text$mn:000032C8 ; Attributes: bp-based frame
.text$mn:000032C8
.text$mn:000032C8 ; bool __thiscall Notepad_plus::fileCloseAll(Notepad_plus *this, bool, bool)
.text$mn:000032C8                 public ?fileCloseAll@Notepad_plus@@QAE_N_N0@Z
.text$mn:000032C8 ?fileCloseAll@Notepad_plus@@QAE_N_N0@Z proc near
.text$mn:000032C8
.text$mn:000032C8 var_B18         = dword ptr -0B18h
.text$mn:000032C8 var_B14         = dword ptr -0B14h
.text$mn:000032C8 var_B10         = dword ptr -0B10h
.text$mn:000032C8 var_B0C         = dword ptr -0B0Ch
.text$mn:000032C8 var_B08         = dword ptr -0B08h
.text$mn:000032C8 var_B04         = dword ptr -0B04h
.text$mn:000032C8 var_B00         = dword ptr -0B00h
.text$mn:000032C8 var_AFC         = dword ptr -0AFCh
.text$mn:000032C8 var_AF8         = dword ptr -0AF8h
.text$mn:000032C8 var_AF4         = dword ptr -0AF4h
.text$mn:000032C8 var_AF0         = dword ptr -0AF0h
.text$mn:000032C8 var_AEC         = dword ptr -0AECh
.text$mn:000032C8 var_AE8         = dword ptr -0AE8h
.text$mn:000032C8 var_AE4         = dword ptr -0AE4h
.text$mn:000032C8 var_AE0         = dword ptr -0AE0h
.text$mn:000032C8 var_ADC         = dword ptr -0ADCh
.text$mn:000032C8 var_AD8         = dword ptr -0AD8h
.text$mn:000032C8 var_AD4         = dword ptr -0AD4h
.text$mn:000032C8 var_AD0         = dword ptr -0AD0h
.text$mn:000032C8 var_ACC         = dword ptr -0ACCh
.text$mn:000032C8 var_AC5         = byte ptr -0AC5h
.text$mn:000032C8 var_AC4         = dword ptr -0AC4h
.text$mn:000032C8 var_AC0         = dword ptr -0AC0h
.text$mn:000032C8 var_AB9         = byte ptr -0AB9h
.text$mn:000032C8 var_AB8         = dword ptr -0AB8h
.text$mn:000032C8 var_AB4         = dword ptr -0AB4h
.text$mn:000032C8 var_AB0         = byte ptr -0AB0h
.text$mn:000032C8 var_A94         = byte ptr -0A94h
.text$mn:000032C8 var_A78         = byte ptr -0A78h
.text$mn:000032C8 var_A5C         = byte ptr -0A5Ch
.text$mn:000032C8 var_A40         = word ptr -0A40h
.text$mn:000032C8 var_640         = word ptr -640h
.text$mn:000032C8 var_240         = word ptr -240h
.text$mn:000032C8 var_13C         = dword ptr -13Ch
.text$mn:000032C8 var_138         = dword ptr -138h
.text$mn:000032C8 var_134         = dword ptr -134h
.text$mn:000032C8 var_130         = dword ptr -130h
.text$mn:000032C8 var_12C         = dword ptr -12Ch
.text$mn:000032C8 var_128         = word ptr -128h
.text$mn:000032C8 var_24          = dword ptr -24h
.text$mn:000032C8 var_20          = dword ptr -20h
.text$mn:000032C8 var_1C          = dword ptr -1Ch
.text$mn:000032C8 var_18          = dword ptr -18h
.text$mn:000032C8 var_14          = dword ptr -14h
.text$mn:000032C8 var_10          = dword ptr -10h
.text$mn:000032C8 var_C           = dword ptr -0Ch
.text$mn:000032C8 var_4           = dword ptr -4
.text$mn:000032C8 arg_0           = byte ptr  8
.text$mn:000032C8 arg_4           = byte ptr  0Ch
.text$mn:000032C8
.text$mn:000032C8                 push    ebp
.text$mn:000032C9                 mov     ebp, esp
.text$mn:000032CB                 push    0FFFFFFFFh
.text$mn:000032CD                 push    offset __ehhandler$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z
.text$mn:000032D2                 mov     eax, large fs:0
.text$mn:000032D8                 push    eax
.text$mn:000032D9                 sub     esp, 0B0Ch
.text$mn:000032DF                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000032E4                 xor     eax, ebp
.text$mn:000032E6                 mov     [ebp+var_10], eax
.text$mn:000032E9                 push    esi
.text$mn:000032EA                 push    edi
.text$mn:000032EB                 push    eax
.text$mn:000032EC                 lea     eax, [ebp+var_C]
.text$mn:000032EF                 mov     large fs:0, eax
.text$mn:000032F5                 mov     [ebp+var_AB4], ecx
.text$mn:000032FB                 mov     [ebp+var_AB8], 0
.text$mn:00003305                 mov     [ebp+var_AD8], 0
.text$mn:0000330F                 jmp     short loc_3320
.text$mn:00003311 ; ---------------------------------------------------------------------------
.text$mn:00003311
.text$mn:00003311 loc_3311:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool):loc_364Fj
.text$mn:00003311                 mov     eax, [ebp+var_AD8]
.text$mn:00003317                 add     eax, 1
.text$mn:0000331A                 mov     [ebp+var_AD8], eax
.text$mn:00003320
.text$mn:00003320 loc_3320:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+47j
.text$mn:00003320                 mov     ecx, [ebp+var_AB4]
.text$mn:00003326                 add     ecx, 35Ch       ; this
.text$mn:0000332C                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:00003331                 cmp     [ebp+var_AD8], eax
.text$mn:00003337                 jge     loc_3654
.text$mn:0000333D                 mov     ecx, [ebp+var_AD8]
.text$mn:00003343                 push    ecx             ; int
.text$mn:00003344                 mov     ecx, [ebp+var_AB4]
.text$mn:0000334A                 add     ecx, 35Ch       ; this
.text$mn:00003350                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00003355                 mov     [ebp+var_AC0], eax
.text$mn:0000335B                 mov     edx, [ebp+var_AC0]
.text$mn:00003361                 push    edx             ; struct Buffer *
.text$mn:00003362                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00003367                 mov     ecx, eax        ; this
.text$mn:00003369                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:0000336E                 mov     [ebp+var_AC4], eax
.text$mn:00003374                 mov     ecx, [ebp+var_AC4] ; this
.text$mn:0000337A                 call    ?isUntitled@Buffer@@QBE_NXZ ; Buffer::isUntitled(void)
.text$mn:0000337F                 movzx   eax, al
.text$mn:00003382                 test    eax, eax
.text$mn:00003384                 jz      short loc_339A
.text$mn:00003386                 mov     ecx, [ebp+var_AC4] ; this
.text$mn:0000338C                 call    ?docLength@Buffer@@QBEHXZ ; Buffer::docLength(void)
.text$mn:00003391                 test    eax, eax
.text$mn:00003393                 jnz     short loc_339A
.text$mn:00003395                 jmp     loc_364F
.text$mn:0000339A ; ---------------------------------------------------------------------------
.text$mn:0000339A
.text$mn:0000339A loc_339A:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+BCj
.text$mn:0000339A                                         ; Notepad_plus::fileCloseAll(bool,bool)+CBj
.text$mn:0000339A                 mov     ecx, [ebp+var_AC4] ; this
.text$mn:000033A0                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:000033A5                 movzx   ecx, al
.text$mn:000033A8                 test    ecx, ecx
.text$mn:000033AA                 jz      loc_364F
.text$mn:000033B0                 movzx   edx, [ebp+arg_4]
.text$mn:000033B4                 test    edx, edx
.text$mn:000033B6                 jz      loc_35BB
.text$mn:000033BC                 push    offset $SG176439 ; Str
.text$mn:000033C1                 lea     eax, [ebp+var_A78]
.text$mn:000033C7                 push    eax
.text$mn:000033C8                 mov     ecx, [ebp+var_AC4]
.text$mn:000033CE                 call    ?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Buffer::getBackupFileName(void)
.text$mn:000033D3                 mov     [ebp+var_B08], eax
.text$mn:000033D9                 mov     ecx, [ebp+var_B08]
.text$mn:000033DF                 mov     [ebp+var_B10], ecx
.text$mn:000033E5                 mov     [ebp+var_4], 0
.text$mn:000033EC                 mov     edx, [ebp+var_AB8]
.text$mn:000033F2                 or      edx, 1
.text$mn:000033F5                 mov     [ebp+var_AB8], edx
.text$mn:000033FB                 mov     eax, [ebp+var_B10]
.text$mn:00003401                 push    eax             ; int
.text$mn:00003402                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00003407                 add     esp, 8
.text$mn:0000340A                 movzx   ecx, al
.text$mn:0000340D                 test    ecx, ecx
.text$mn:0000340F                 jnz     short loc_346D
.text$mn:00003411                 lea     edx, [ebp+var_A5C]
.text$mn:00003417                 push    edx
.text$mn:00003418                 mov     ecx, [ebp+var_AC4]
.text$mn:0000341E                 call    ?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Buffer::getBackupFileName(void)
.text$mn:00003423                 mov     [ebp+var_B18], eax
.text$mn:00003429                 mov     eax, [ebp+var_B18]
.text$mn:0000342F                 mov     [ebp+var_AFC], eax
.text$mn:00003435                 mov     [ebp+var_4], 1
.text$mn:0000343C                 mov     ecx, [ebp+var_AB8]
.text$mn:00003442                 or      ecx, 2
.text$mn:00003445                 mov     [ebp+var_AB8], ecx
.text$mn:0000344B                 mov     ecx, [ebp+var_AFC]
.text$mn:00003451                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00003456                 push    eax             ; pszPath
.text$mn:00003457                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:0000345D                 test    eax, eax
.text$mn:0000345F                 jz      short loc_346D
.text$mn:00003461                 mov     [ebp+var_AF8], 0
.text$mn:0000346B                 jmp     short loc_3477
.text$mn:0000346D ; ---------------------------------------------------------------------------
.text$mn:0000346D
.text$mn:0000346D loc_346D:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+147j
.text$mn:0000346D                                         ; Notepad_plus::fileCloseAll(bool,bool)+197j
.text$mn:0000346D                 mov     [ebp+var_AF8], 1
.text$mn:00003477
.text$mn:00003477 loc_3477:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+1A3j
.text$mn:00003477                 mov     dl, byte ptr [ebp+var_AF8]
.text$mn:0000347D                 mov     [ebp+var_AB9], dl
.text$mn:00003483                 mov     [ebp+var_4], 0
.text$mn:0000348A                 mov     eax, [ebp+var_AB8]
.text$mn:00003490                 and     eax, 2
.text$mn:00003493                 jz      short loc_34A7
.text$mn:00003495                 and     [ebp+var_AB8], 0FFFFFFFDh
.text$mn:0000349C                 lea     ecx, [ebp+var_A5C]
.text$mn:000034A2                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000034A7
.text$mn:000034A7 loc_34A7:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+1CBj
.text$mn:000034A7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000034AE                 mov     ecx, [ebp+var_AB8]
.text$mn:000034B4                 and     ecx, 1
.text$mn:000034B7                 jz      short loc_34CB
.text$mn:000034B9                 and     [ebp+var_AB8], 0FFFFFFFEh
.text$mn:000034C0                 lea     ecx, [ebp+var_A78]
.text$mn:000034C6                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000034CB
.text$mn:000034CB loc_34CB:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+1EFj
.text$mn:000034CB                 movzx   edx, [ebp+var_AB9]
.text$mn:000034D2                 test    edx, edx
.text$mn:000034D4                 jz      loc_35B6
.text$mn:000034DA                 push    0               ; int
.text$mn:000034DC                 mov     eax, [ebp+var_AC0]
.text$mn:000034E2                 push    eax             ; struct Buffer *
.text$mn:000034E3                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:000034E9                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:000034EE                 push    1               ; int
.text$mn:000034F0                 mov     ecx, [ebp+var_AC0]
.text$mn:000034F6                 push    ecx             ; struct Buffer *
.text$mn:000034F7                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:000034FD                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:00003502                 movzx   edx, al
.text$mn:00003505                 test    edx, edx
.text$mn:00003507                 jnz     short loc_3516
.text$mn:00003509                 push    0               ; int
.text$mn:0000350B                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:00003511                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:00003516
.text$mn:00003516 loc_3516:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+23Fj
.text$mn:00003516                 mov     ecx, 41h ; 'A'
.text$mn:0000351B                 mov     esi, offset $SG176442 ; "Your backup file cannot be found (delet"...
.text$mn:00003520                 lea     edi, [ebp+var_128]
.text$mn:00003526                 rep movsd
.text$mn:00003528                 xor     eax, eax
.text$mn:0000352A                 mov     [ebp+var_24], eax
.text$mn:0000352D                 mov     [ebp+var_20], eax
.text$mn:00003530                 mov     [ebp+var_1C], eax
.text$mn:00003533                 mov     [ebp+var_18], eax
.text$mn:00003536                 mov     [ebp+var_14], eax
.text$mn:00003539                 mov     ecx, [ebp+var_AC4] ; this
.text$mn:0000353F                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00003544                 push    eax
.text$mn:00003545                 lea     ecx, [ebp+var_128]
.text$mn:0000354B                 push    ecx             ; LPCWSTR
.text$mn:0000354C                 lea     edx, [ebp+var_640]
.text$mn:00003552                 push    edx             ; LPWSTR
.text$mn:00003553                 call    dword ptr ds:__imp__wsprintfW
.text$mn:00003559                 add     esp, 0Ch
.text$mn:0000355C                 push    23h ; '#'       ; int
.text$mn:0000355E                 lea     eax, [ebp+var_640]
.text$mn:00003564                 push    eax             ; wchar_t *
.text$mn:00003565                 push    offset $SG176445 ; "Save"
.text$mn:0000356A                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:00003570                 call    ?doActionOrNot@Notepad_plus@@AAEHPB_W0H@Z ; Notepad_plus::doActionOrNot(wchar_t const *,wchar_t const *,int)
.text$mn:00003575                 mov     [ebp+var_AEC], eax
.text$mn:0000357B                 cmp     [ebp+var_AEC], 6
.text$mn:00003582                 jnz     short loc_35A6
.text$mn:00003584                 mov     ecx, [ebp+var_AC0]
.text$mn:0000358A                 push    ecx             ; struct Buffer *
.text$mn:0000358B                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:00003591                 call    ?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z ; Notepad_plus::fileSave(Buffer *)
.text$mn:00003596                 movzx   edx, al
.text$mn:00003599                 test    edx, edx
.text$mn:0000359B                 jnz     short loc_35A4
.text$mn:0000359D                 xor     al, al
.text$mn:0000359F                 jmp     loc_3ABD
.text$mn:000035A4 ; ---------------------------------------------------------------------------
.text$mn:000035A4
.text$mn:000035A4 loc_35A4:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+2D3j
.text$mn:000035A4                 jmp     short loc_35B6
.text$mn:000035A6 ; ---------------------------------------------------------------------------
.text$mn:000035A6
.text$mn:000035A6 loc_35A6:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+2BAj
.text$mn:000035A6                 cmp     [ebp+var_AEC], 2
.text$mn:000035AD                 jnz     short loc_35B6
.text$mn:000035AF                 xor     al, al
.text$mn:000035B1                 jmp     loc_3ABD
.text$mn:000035B6 ; ---------------------------------------------------------------------------
.text$mn:000035B6
.text$mn:000035B6 loc_35B6:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+20Cj
.text$mn:000035B6                                         ; Notepad_plus::fileCloseAll(bool,bool):loc_35A4j ...
.text$mn:000035B6                 jmp     loc_364F
.text$mn:000035BB ; ---------------------------------------------------------------------------
.text$mn:000035BB
.text$mn:000035BB loc_35BB:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+EEj
.text$mn:000035BB                 push    0               ; int
.text$mn:000035BD                 mov     eax, [ebp+var_AC0]
.text$mn:000035C3                 push    eax             ; struct Buffer *
.text$mn:000035C4                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:000035CA                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:000035CF                 push    1               ; int
.text$mn:000035D1                 mov     ecx, [ebp+var_AC0]
.text$mn:000035D7                 push    ecx             ; struct Buffer *
.text$mn:000035D8                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:000035DE                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:000035E3                 movzx   edx, al
.text$mn:000035E6                 test    edx, edx
.text$mn:000035E8                 jnz     short loc_35F7
.text$mn:000035EA                 push    0               ; int
.text$mn:000035EC                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:000035F2                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:000035F7
.text$mn:000035F7 loc_35F7:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+320j
.text$mn:000035F7                 mov     ecx, [ebp+var_AC4] ; this
.text$mn:000035FD                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00003602                 push    eax             ; wchar_t *
.text$mn:00003603                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:00003609                 call    ?doSaveOrNot@Notepad_plus@@AAEHPB_W@Z ; Notepad_plus::doSaveOrNot(wchar_t const *)
.text$mn:0000360E                 mov     [ebp+var_AE8], eax
.text$mn:00003614                 cmp     [ebp+var_AE8], 6
.text$mn:0000361B                 jnz     short loc_363F
.text$mn:0000361D                 mov     eax, [ebp+var_AC0]
.text$mn:00003623                 push    eax             ; struct Buffer *
.text$mn:00003624                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:0000362A                 call    ?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z ; Notepad_plus::fileSave(Buffer *)
.text$mn:0000362F                 movzx   ecx, al
.text$mn:00003632                 test    ecx, ecx
.text$mn:00003634                 jnz     short loc_363D
.text$mn:00003636                 xor     al, al
.text$mn:00003638                 jmp     loc_3ABD
.text$mn:0000363D ; ---------------------------------------------------------------------------
.text$mn:0000363D
.text$mn:0000363D loc_363D:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+36Cj
.text$mn:0000363D                 jmp     short loc_364F
.text$mn:0000363F ; ---------------------------------------------------------------------------
.text$mn:0000363F
.text$mn:0000363F loc_363F:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+353j
.text$mn:0000363F                 cmp     [ebp+var_AE8], 2
.text$mn:00003646                 jnz     short loc_364F
.text$mn:00003648                 xor     al, al
.text$mn:0000364A                 jmp     loc_3ABD
.text$mn:0000364F ; ---------------------------------------------------------------------------
.text$mn:0000364F
.text$mn:0000364F loc_364F:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+CDj
.text$mn:0000364F                                         ; Notepad_plus::fileCloseAll(bool,bool)+E2j ...
.text$mn:0000364F                 jmp     loc_3311
.text$mn:00003654 ; ---------------------------------------------------------------------------
.text$mn:00003654
.text$mn:00003654 loc_3654:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+6Fj
.text$mn:00003654                 mov     [ebp+var_AD4], 0
.text$mn:0000365E                 jmp     short loc_366F
.text$mn:00003660 ; ---------------------------------------------------------------------------
.text$mn:00003660
.text$mn:00003660 loc_3660:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool):loc_3974j
.text$mn:00003660                 mov     edx, [ebp+var_AD4]
.text$mn:00003666                 add     edx, 1
.text$mn:00003669                 mov     [ebp+var_AD4], edx
.text$mn:0000366F
.text$mn:0000366F loc_366F:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+396j
.text$mn:0000366F                 mov     ecx, [ebp+var_AB4]
.text$mn:00003675                 add     ecx, 3DCh       ; this
.text$mn:0000367B                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:00003680                 cmp     [ebp+var_AD4], eax
.text$mn:00003686                 jge     loc_3979
.text$mn:0000368C                 mov     eax, [ebp+var_AD4]
.text$mn:00003692                 push    eax             ; int
.text$mn:00003693                 mov     ecx, [ebp+var_AB4]
.text$mn:00003699                 add     ecx, 3DCh       ; this
.text$mn:0000369F                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:000036A4                 mov     [ebp+var_AD0], eax
.text$mn:000036AA                 mov     ecx, [ebp+var_AD0]
.text$mn:000036B0                 push    ecx             ; struct Buffer *
.text$mn:000036B1                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:000036B6                 mov     ecx, eax        ; this
.text$mn:000036B8                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:000036BD                 mov     [ebp+var_ACC], eax
.text$mn:000036C3                 mov     ecx, [ebp+var_ACC] ; this
.text$mn:000036C9                 call    ?isUntitled@Buffer@@QBE_NXZ ; Buffer::isUntitled(void)
.text$mn:000036CE                 movzx   edx, al
.text$mn:000036D1                 test    edx, edx
.text$mn:000036D3                 jz      short loc_36E9
.text$mn:000036D5                 mov     ecx, [ebp+var_ACC] ; this
.text$mn:000036DB                 call    ?docLength@Buffer@@QBEHXZ ; Buffer::docLength(void)
.text$mn:000036E0                 test    eax, eax
.text$mn:000036E2                 jnz     short loc_36E9
.text$mn:000036E4                 jmp     loc_3974
.text$mn:000036E9 ; ---------------------------------------------------------------------------
.text$mn:000036E9
.text$mn:000036E9 loc_36E9:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+40Bj
.text$mn:000036E9                                         ; Notepad_plus::fileCloseAll(bool,bool)+41Aj
.text$mn:000036E9                 mov     ecx, [ebp+var_ACC] ; this
.text$mn:000036EF                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:000036F4                 movzx   eax, al
.text$mn:000036F7                 test    eax, eax
.text$mn:000036F9                 jz      loc_3974
.text$mn:000036FF                 movzx   ecx, [ebp+arg_4]
.text$mn:00003703                 test    ecx, ecx
.text$mn:00003705                 jz      loc_38FB
.text$mn:0000370B                 push    offset $SG176487 ; Str
.text$mn:00003710                 lea     edx, [ebp+var_AB0]
.text$mn:00003716                 push    edx
.text$mn:00003717                 mov     ecx, [ebp+var_ACC]
.text$mn:0000371D                 call    ?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Buffer::getBackupFileName(void)
.text$mn:00003722                 mov     [ebp+var_B04], eax
.text$mn:00003728                 mov     eax, [ebp+var_B04]
.text$mn:0000372E                 mov     [ebp+var_B00], eax
.text$mn:00003734                 mov     [ebp+var_4], 2
.text$mn:0000373B                 mov     ecx, [ebp+var_AB8]
.text$mn:00003741                 or      ecx, 4
.text$mn:00003744                 mov     [ebp+var_AB8], ecx
.text$mn:0000374A                 mov     edx, [ebp+var_B00]
.text$mn:00003750                 push    edx             ; int
.text$mn:00003751                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00003756                 add     esp, 8
.text$mn:00003759                 movzx   eax, al
.text$mn:0000375C                 test    eax, eax
.text$mn:0000375E                 jnz     short loc_37BC
.text$mn:00003760                 lea     ecx, [ebp+var_A94]
.text$mn:00003766                 push    ecx
.text$mn:00003767                 mov     ecx, [ebp+var_ACC]
.text$mn:0000376D                 call    ?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Buffer::getBackupFileName(void)
.text$mn:00003772                 mov     [ebp+var_B14], eax
.text$mn:00003778                 mov     edx, [ebp+var_B14]
.text$mn:0000377E                 mov     [ebp+var_B0C], edx
.text$mn:00003784                 mov     [ebp+var_4], 3
.text$mn:0000378B                 mov     eax, [ebp+var_AB8]
.text$mn:00003791                 or      eax, 8
.text$mn:00003794                 mov     [ebp+var_AB8], eax
.text$mn:0000379A                 mov     ecx, [ebp+var_B0C]
.text$mn:000037A0                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000037A5                 push    eax             ; pszPath
.text$mn:000037A6                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:000037AC                 test    eax, eax
.text$mn:000037AE                 jz      short loc_37BC
.text$mn:000037B0                 mov     [ebp+var_AF0], 0
.text$mn:000037BA                 jmp     short loc_37C6
.text$mn:000037BC ; ---------------------------------------------------------------------------
.text$mn:000037BC
.text$mn:000037BC loc_37BC:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+496j
.text$mn:000037BC                                         ; Notepad_plus::fileCloseAll(bool,bool)+4E6j
.text$mn:000037BC                 mov     [ebp+var_AF0], 1
.text$mn:000037C6
.text$mn:000037C6 loc_37C6:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+4F2j
.text$mn:000037C6                 mov     cl, byte ptr [ebp+var_AF0]
.text$mn:000037CC                 mov     [ebp+var_AC5], cl
.text$mn:000037D2                 mov     [ebp+var_4], 2
.text$mn:000037D9                 mov     edx, [ebp+var_AB8]
.text$mn:000037DF                 and     edx, 8
.text$mn:000037E2                 jz      short loc_37F6
.text$mn:000037E4                 and     [ebp+var_AB8], 0FFFFFFF7h
.text$mn:000037EB                 lea     ecx, [ebp+var_A94]
.text$mn:000037F1                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000037F6
.text$mn:000037F6 loc_37F6:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+51Aj
.text$mn:000037F6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000037FD                 mov     eax, [ebp+var_AB8]
.text$mn:00003803                 and     eax, 4
.text$mn:00003806                 jz      short loc_381A
.text$mn:00003808                 and     [ebp+var_AB8], 0FFFFFFFBh
.text$mn:0000380F                 lea     ecx, [ebp+var_AB0]
.text$mn:00003815                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000381A
.text$mn:0000381A loc_381A:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+53Ej
.text$mn:0000381A                 movzx   ecx, [ebp+var_AC5]
.text$mn:00003821                 test    ecx, ecx
.text$mn:00003823                 jz      loc_38F9
.text$mn:00003829                 push    1               ; int
.text$mn:0000382B                 mov     edx, [ebp+var_AD0]
.text$mn:00003831                 push    edx             ; struct Buffer *
.text$mn:00003832                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:00003838                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:0000383D                 push    1               ; int
.text$mn:0000383F                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:00003845                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:0000384A                 mov     ecx, 41h ; 'A'
.text$mn:0000384F                 mov     esi, offset $SG176489 ; "Your backup file cannot be found (delet"...
.text$mn:00003854                 lea     edi, [ebp+var_240]
.text$mn:0000385A                 rep movsd
.text$mn:0000385C                 xor     eax, eax
.text$mn:0000385E                 mov     [ebp+var_13C], eax
.text$mn:00003864                 mov     [ebp+var_138], eax
.text$mn:0000386A                 mov     [ebp+var_134], eax
.text$mn:00003870                 mov     [ebp+var_130], eax
.text$mn:00003876                 mov     [ebp+var_12C], eax
.text$mn:0000387C                 mov     ecx, [ebp+var_ACC] ; this
.text$mn:00003882                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00003887                 push    eax
.text$mn:00003888                 lea     ecx, [ebp+var_240]
.text$mn:0000388E                 push    ecx             ; LPCWSTR
.text$mn:0000388F                 lea     edx, [ebp+var_A40]
.text$mn:00003895                 push    edx             ; LPWSTR
.text$mn:00003896                 call    dword ptr ds:__imp__wsprintfW
.text$mn:0000389C                 add     esp, 0Ch
.text$mn:0000389F                 push    23h ; '#'       ; int
.text$mn:000038A1                 lea     eax, [ebp+var_A40]
.text$mn:000038A7                 push    eax             ; wchar_t *
.text$mn:000038A8                 push    offset $SG176492 ; "Save"
.text$mn:000038AD                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:000038B3                 call    ?doActionOrNot@Notepad_plus@@AAEHPB_W0H@Z ; Notepad_plus::doActionOrNot(wchar_t const *,wchar_t const *,int)
.text$mn:000038B8                 mov     [ebp+var_AE4], eax
.text$mn:000038BE                 cmp     [ebp+var_AE4], 6
.text$mn:000038C5                 jnz     short loc_38E9
.text$mn:000038C7                 mov     ecx, [ebp+var_AD0]
.text$mn:000038CD                 push    ecx             ; struct Buffer *
.text$mn:000038CE                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:000038D4                 call    ?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z ; Notepad_plus::fileSave(Buffer *)
.text$mn:000038D9                 movzx   edx, al
.text$mn:000038DC                 test    edx, edx
.text$mn:000038DE                 jnz     short loc_38E7
.text$mn:000038E0                 xor     al, al
.text$mn:000038E2                 jmp     loc_3ABD
.text$mn:000038E7 ; ---------------------------------------------------------------------------
.text$mn:000038E7
.text$mn:000038E7 loc_38E7:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+616j
.text$mn:000038E7                 jmp     short loc_38F9
.text$mn:000038E9 ; ---------------------------------------------------------------------------
.text$mn:000038E9
.text$mn:000038E9 loc_38E9:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+5FDj
.text$mn:000038E9                 cmp     [ebp+var_AE4], 2
.text$mn:000038F0                 jnz     short loc_38F9
.text$mn:000038F2                 xor     al, al
.text$mn:000038F4                 jmp     loc_3ABD
.text$mn:000038F9 ; ---------------------------------------------------------------------------
.text$mn:000038F9
.text$mn:000038F9 loc_38F9:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+55Bj
.text$mn:000038F9                                         ; Notepad_plus::fileCloseAll(bool,bool):loc_38E7j ...
.text$mn:000038F9                 jmp     short loc_3974
.text$mn:000038FB ; ---------------------------------------------------------------------------
.text$mn:000038FB
.text$mn:000038FB loc_38FB:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+43Dj
.text$mn:000038FB                 push    1               ; int
.text$mn:000038FD                 mov     eax, [ebp+var_AD0]
.text$mn:00003903                 push    eax             ; struct Buffer *
.text$mn:00003904                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:0000390A                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:0000390F                 push    1               ; int
.text$mn:00003911                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:00003917                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:0000391C                 mov     ecx, [ebp+var_ACC] ; this
.text$mn:00003922                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00003927                 push    eax             ; wchar_t *
.text$mn:00003928                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:0000392E                 call    ?doSaveOrNot@Notepad_plus@@AAEHPB_W@Z ; Notepad_plus::doSaveOrNot(wchar_t const *)
.text$mn:00003933                 mov     [ebp+var_AF4], eax
.text$mn:00003939                 cmp     [ebp+var_AF4], 6
.text$mn:00003940                 jnz     short loc_3964
.text$mn:00003942                 mov     ecx, [ebp+var_AD0]
.text$mn:00003948                 push    ecx             ; struct Buffer *
.text$mn:00003949                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:0000394F                 call    ?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z ; Notepad_plus::fileSave(Buffer *)
.text$mn:00003954                 movzx   edx, al
.text$mn:00003957                 test    edx, edx
.text$mn:00003959                 jnz     short loc_3962
.text$mn:0000395B                 xor     al, al
.text$mn:0000395D                 jmp     loc_3ABD
.text$mn:00003962 ; ---------------------------------------------------------------------------
.text$mn:00003962
.text$mn:00003962 loc_3962:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+691j
.text$mn:00003962                 jmp     short loc_3974
.text$mn:00003964 ; ---------------------------------------------------------------------------
.text$mn:00003964
.text$mn:00003964 loc_3964:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+678j
.text$mn:00003964                 cmp     [ebp+var_AF4], 2
.text$mn:0000396B                 jnz     short loc_3974
.text$mn:0000396D                 xor     al, al
.text$mn:0000396F                 jmp     loc_3ABD
.text$mn:00003974 ; ---------------------------------------------------------------------------
.text$mn:00003974
.text$mn:00003974 loc_3974:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+41Cj
.text$mn:00003974                                         ; Notepad_plus::fileCloseAll(bool,bool)+431j ...
.text$mn:00003974                 jmp     loc_3660
.text$mn:00003979 ; ---------------------------------------------------------------------------
.text$mn:00003979
.text$mn:00003979 loc_3979:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+3BEj
.text$mn:00003979                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:0000397F                 call    ?bothActive@Notepad_plus@@AAE_NXZ ; Notepad_plus::bothActive(void)
.text$mn:00003984                 movzx   eax, al
.text$mn:00003987                 test    eax, eax
.text$mn:00003989                 jz      loc_3A25
.text$mn:0000398F                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:00003995                 call    ?otherView@Notepad_plus@@AAEHXZ ; Notepad_plus::otherView(void)
.text$mn:0000399A                 push    eax             ; int
.text$mn:0000399B                 push    0               ; int
.text$mn:0000399D                 mov     ecx, [ebp+var_AB4]
.text$mn:000039A3                 mov     ecx, [ecx+460h] ; this
.text$mn:000039A9                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:000039AE                 push    eax             ; struct Buffer *
.text$mn:000039AF                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:000039B5                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:000039BA                 mov     edx, [ebp+var_AB4]
.text$mn:000039C0                 mov     ecx, [edx+460h] ; this
.text$mn:000039C6                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:000039CB                 sub     eax, 1
.text$mn:000039CE                 mov     [ebp+var_AE0], eax
.text$mn:000039D4                 jmp     short loc_39E5
.text$mn:000039D6 ; ---------------------------------------------------------------------------
.text$mn:000039D6
.text$mn:000039D6 loc_39D6:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+75Bj
.text$mn:000039D6                 mov     eax, [ebp+var_AE0]
.text$mn:000039DC                 sub     eax, 1
.text$mn:000039DF                 mov     [ebp+var_AE0], eax
.text$mn:000039E5
.text$mn:000039E5 loc_39E5:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+70Cj
.text$mn:000039E5                 cmp     [ebp+var_AE0], 0
.text$mn:000039EC                 jl      short loc_3A25
.text$mn:000039EE                 movzx   ecx, [ebp+arg_0]
.text$mn:000039F2                 push    ecx             ; bool
.text$mn:000039F3                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:000039F9                 call    ?otherView@Notepad_plus@@AAEHXZ ; Notepad_plus::otherView(void)
.text$mn:000039FE                 push    eax             ; lParam
.text$mn:000039FF                 mov     edx, [ebp+var_AE0]
.text$mn:00003A05                 push    edx             ; int
.text$mn:00003A06                 mov     eax, [ebp+var_AB4]
.text$mn:00003A0C                 mov     ecx, [eax+460h] ; this
.text$mn:00003A12                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00003A17                 push    eax             ; struct Buffer *
.text$mn:00003A18                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:00003A1E                 call    ?doClose@Notepad_plus@@QAEXPAVBuffer@@H_N@Z ; Notepad_plus::doClose(Buffer *,int,bool)
.text$mn:00003A23                 jmp     short loc_39D6
.text$mn:00003A25 ; ---------------------------------------------------------------------------
.text$mn:00003A25
.text$mn:00003A25 loc_3A25:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+6C1j
.text$mn:00003A25                                         ; Notepad_plus::fileCloseAll(bool,bool)+724j
.text$mn:00003A25                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:00003A2B                 call    ?currentView@Notepad_plus@@AAEHXZ ; Notepad_plus::currentView(void)
.text$mn:00003A30                 push    eax             ; int
.text$mn:00003A31                 push    0               ; int
.text$mn:00003A33                 mov     ecx, [ebp+var_AB4]
.text$mn:00003A39                 mov     ecx, [ecx+45Ch] ; this
.text$mn:00003A3F                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00003A44                 push    eax             ; struct Buffer *
.text$mn:00003A45                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:00003A4B                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:00003A50                 mov     edx, [ebp+var_AB4]
.text$mn:00003A56                 mov     ecx, [edx+45Ch] ; this
.text$mn:00003A5C                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:00003A61                 sub     eax, 1
.text$mn:00003A64                 mov     [ebp+var_ADC], eax
.text$mn:00003A6A                 jmp     short loc_3A7B
.text$mn:00003A6C ; ---------------------------------------------------------------------------
.text$mn:00003A6C
.text$mn:00003A6C loc_3A6C:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+7F1j
.text$mn:00003A6C                 mov     eax, [ebp+var_ADC]
.text$mn:00003A72                 sub     eax, 1
.text$mn:00003A75                 mov     [ebp+var_ADC], eax
.text$mn:00003A7B
.text$mn:00003A7B loc_3A7B:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+7A2j
.text$mn:00003A7B                 cmp     [ebp+var_ADC], 0
.text$mn:00003A82                 jl      short loc_3ABB
.text$mn:00003A84                 movzx   ecx, [ebp+arg_0]
.text$mn:00003A88                 push    ecx             ; bool
.text$mn:00003A89                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:00003A8F                 call    ?currentView@Notepad_plus@@AAEHXZ ; Notepad_plus::currentView(void)
.text$mn:00003A94                 push    eax             ; lParam
.text$mn:00003A95                 mov     edx, [ebp+var_ADC]
.text$mn:00003A9B                 push    edx             ; int
.text$mn:00003A9C                 mov     eax, [ebp+var_AB4]
.text$mn:00003AA2                 mov     ecx, [eax+45Ch] ; this
.text$mn:00003AA8                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00003AAD                 push    eax             ; struct Buffer *
.text$mn:00003AAE                 mov     ecx, [ebp+var_AB4] ; this
.text$mn:00003AB4                 call    ?doClose@Notepad_plus@@QAEXPAVBuffer@@H_N@Z ; Notepad_plus::doClose(Buffer *,int,bool)
.text$mn:00003AB9                 jmp     short loc_3A6C
.text$mn:00003ABB ; ---------------------------------------------------------------------------
.text$mn:00003ABB
.text$mn:00003ABB loc_3ABB:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+7BAj
.text$mn:00003ABB                 mov     al, 1
.text$mn:00003ABD
.text$mn:00003ABD loc_3ABD:                               ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+2D7j
.text$mn:00003ABD                                         ; Notepad_plus::fileCloseAll(bool,bool)+2E9j ...
.text$mn:00003ABD                 mov     ecx, [ebp+var_C]
.text$mn:00003AC0                 mov     large fs:0, ecx
.text$mn:00003AC7                 pop     ecx
.text$mn:00003AC8                 pop     edi
.text$mn:00003AC9                 pop     esi
.text$mn:00003ACA                 mov     ecx, [ebp+var_10]
.text$mn:00003ACD                 xor     ecx, ebp
.text$mn:00003ACF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00003AD4                 mov     esp, ebp
.text$mn:00003AD6                 pop     ebp
.text$mn:00003AD7                 retn    8
.text$mn:00003AD7 ?fileCloseAll@Notepad_plus@@QAE_N_N0@Z endp
.text$mn:00003AD7
.text$mn:00003AD7 ; ---------------------------------------------------------------------------
.text$mn:00003ADA                 db 0Eh dup(0CCh)
.text$mn:00003AE8
.text$mn:00003AE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AE8
.text$mn:00003AE8 ; Attributes: bp-based frame
.text$mn:00003AE8
.text$mn:00003AE8 ; bool __thiscall Notepad_plus::fileCloseAllButCurrent(Notepad_plus *__hidden this)
.text$mn:00003AE8                 public ?fileCloseAllButCurrent@Notepad_plus@@QAE_NXZ
.text$mn:00003AE8 ?fileCloseAllButCurrent@Notepad_plus@@QAE_NXZ proc near
.text$mn:00003AE8
.text$mn:00003AE8 var_38          = dword ptr -38h
.text$mn:00003AE8 var_34          = dword ptr -34h
.text$mn:00003AE8 var_30          = dword ptr -30h
.text$mn:00003AE8 var_2C          = dword ptr -2Ch
.text$mn:00003AE8 var_28          = dword ptr -28h
.text$mn:00003AE8 var_24          = dword ptr -24h
.text$mn:00003AE8 var_20          = dword ptr -20h
.text$mn:00003AE8 var_1C          = dword ptr -1Ch
.text$mn:00003AE8 var_18          = dword ptr -18h
.text$mn:00003AE8 var_14          = dword ptr -14h
.text$mn:00003AE8 var_10          = dword ptr -10h
.text$mn:00003AE8 var_C           = dword ptr -0Ch
.text$mn:00003AE8 var_8           = dword ptr -8
.text$mn:00003AE8 var_1           = byte ptr -1
.text$mn:00003AE8
.text$mn:00003AE8                 push    ebp
.text$mn:00003AE9                 mov     ebp, esp
.text$mn:00003AEB                 sub     esp, 38h
.text$mn:00003AEE                 mov     [ebp+var_8], ecx
.text$mn:00003AF1                 mov     eax, [ebp+var_8]
.text$mn:00003AF4                 mov     ecx, [eax+5D4h] ; this
.text$mn:00003AFA                 call    ?getCurrentBufferID@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBufferID(void)
.text$mn:00003AFF                 mov     [ebp+var_30], eax
.text$mn:00003B02                 mov     ecx, [ebp+var_8]
.text$mn:00003B05                 mov     ecx, [ecx+45Ch] ; this
.text$mn:00003B0B                 call    ?getCurrentTabIndex@TabBar@@QBEHXZ ; TabBar::getCurrentTabIndex(void)
.text$mn:00003B10                 mov     [ebp+var_38], eax
.text$mn:00003B13                 mov     [ebp+var_14], 0
.text$mn:00003B1A                 jmp     short loc_3B25
.text$mn:00003B1C ; ---------------------------------------------------------------------------
.text$mn:00003B1C
.text$mn:00003B1C loc_3B1C:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+71j
.text$mn:00003B1C                                         ; Notepad_plus::fileCloseAllButCurrent(void):loc_3C0Aj
.text$mn:00003B1C                 mov     edx, [ebp+var_14]
.text$mn:00003B1F                 add     edx, 1
.text$mn:00003B22                 mov     [ebp+var_14], edx
.text$mn:00003B25
.text$mn:00003B25 loc_3B25:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+32j
.text$mn:00003B25                 mov     ecx, [ebp+var_8]
.text$mn:00003B28                 add     ecx, 35Ch       ; this
.text$mn:00003B2E                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:00003B33                 cmp     [ebp+var_14], eax
.text$mn:00003B36                 jge     loc_3C0F
.text$mn:00003B3C                 mov     eax, [ebp+var_14]
.text$mn:00003B3F                 push    eax             ; int
.text$mn:00003B40                 mov     ecx, [ebp+var_8]
.text$mn:00003B43                 add     ecx, 35Ch       ; this
.text$mn:00003B49                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00003B4E                 mov     [ebp+var_C], eax
.text$mn:00003B51                 mov     ecx, [ebp+var_C]
.text$mn:00003B54                 cmp     ecx, [ebp+var_30]
.text$mn:00003B57                 jnz     short loc_3B5B
.text$mn:00003B59                 jmp     short loc_3B1C
.text$mn:00003B5B ; ---------------------------------------------------------------------------
.text$mn:00003B5B
.text$mn:00003B5B loc_3B5B:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+6Fj
.text$mn:00003B5B                 mov     edx, [ebp+var_C]
.text$mn:00003B5E                 push    edx             ; struct Buffer *
.text$mn:00003B5F                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00003B64                 mov     ecx, eax        ; this
.text$mn:00003B66                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00003B6B                 mov     [ebp+var_18], eax
.text$mn:00003B6E                 mov     ecx, [ebp+var_18] ; this
.text$mn:00003B71                 call    ?isUntitled@Buffer@@QBE_NXZ ; Buffer::isUntitled(void)
.text$mn:00003B76                 movzx   eax, al
.text$mn:00003B79                 test    eax, eax
.text$mn:00003B7B                 jz      short loc_3B8B
.text$mn:00003B7D                 mov     ecx, [ebp+var_18] ; this
.text$mn:00003B80                 call    ?docLength@Buffer@@QBEHXZ ; Buffer::docLength(void)
.text$mn:00003B85                 test    eax, eax
.text$mn:00003B87                 jnz     short loc_3B8B
.text$mn:00003B89                 jmp     short loc_3C0A
.text$mn:00003B8B ; ---------------------------------------------------------------------------
.text$mn:00003B8B
.text$mn:00003B8B loc_3B8B:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+93j
.text$mn:00003B8B                                         ; Notepad_plus::fileCloseAllButCurrent(void)+9Fj
.text$mn:00003B8B                 mov     ecx, [ebp+var_18] ; this
.text$mn:00003B8E                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:00003B93                 movzx   ecx, al
.text$mn:00003B96                 test    ecx, ecx
.text$mn:00003B98                 jz      short loc_3C0A
.text$mn:00003B9A                 push    0               ; int
.text$mn:00003B9C                 mov     edx, [ebp+var_C]
.text$mn:00003B9F                 push    edx             ; struct Buffer *
.text$mn:00003BA0                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003BA3                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:00003BA8                 push    1               ; int
.text$mn:00003BAA                 mov     eax, [ebp+var_C]
.text$mn:00003BAD                 push    eax             ; struct Buffer *
.text$mn:00003BAE                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003BB1                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:00003BB6                 movzx   ecx, al
.text$mn:00003BB9                 test    ecx, ecx
.text$mn:00003BBB                 jnz     short loc_3BC7
.text$mn:00003BBD                 push    0               ; int
.text$mn:00003BBF                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003BC2                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:00003BC7
.text$mn:00003BC7 loc_3BC7:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+D3j
.text$mn:00003BC7                 mov     ecx, [ebp+var_18] ; this
.text$mn:00003BCA                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00003BCF                 push    eax             ; wchar_t *
.text$mn:00003BD0                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003BD3                 call    ?doSaveOrNot@Notepad_plus@@AAEHPB_W@Z ; Notepad_plus::doSaveOrNot(wchar_t const *)
.text$mn:00003BD8                 mov     [ebp+var_2C], eax
.text$mn:00003BDB                 cmp     [ebp+var_2C], 6
.text$mn:00003BDF                 jnz     short loc_3BFD
.text$mn:00003BE1                 mov     edx, [ebp+var_C]
.text$mn:00003BE4                 push    edx             ; struct Buffer *
.text$mn:00003BE5                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003BE8                 call    ?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z ; Notepad_plus::fileSave(Buffer *)
.text$mn:00003BED                 movzx   eax, al
.text$mn:00003BF0                 test    eax, eax
.text$mn:00003BF2                 jnz     short loc_3BFB
.text$mn:00003BF4                 xor     al, al
.text$mn:00003BF6                 jmp     loc_3E0B
.text$mn:00003BFB ; ---------------------------------------------------------------------------
.text$mn:00003BFB
.text$mn:00003BFB loc_3BFB:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+10Aj
.text$mn:00003BFB                 jmp     short loc_3C0A
.text$mn:00003BFD ; ---------------------------------------------------------------------------
.text$mn:00003BFD
.text$mn:00003BFD loc_3BFD:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+F7j
.text$mn:00003BFD                 cmp     [ebp+var_2C], 2
.text$mn:00003C01                 jnz     short loc_3C0A
.text$mn:00003C03                 xor     al, al
.text$mn:00003C05                 jmp     loc_3E0B
.text$mn:00003C0A ; ---------------------------------------------------------------------------
.text$mn:00003C0A
.text$mn:00003C0A loc_3C0A:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+A1j
.text$mn:00003C0A                                         ; Notepad_plus::fileCloseAllButCurrent(void)+B0j ...
.text$mn:00003C0A                 jmp     loc_3B1C
.text$mn:00003C0F ; ---------------------------------------------------------------------------
.text$mn:00003C0F
.text$mn:00003C0F loc_3C0F:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+4Ej
.text$mn:00003C0F                 mov     [ebp+var_1C], 0
.text$mn:00003C16                 jmp     short loc_3C21
.text$mn:00003C18 ; ---------------------------------------------------------------------------
.text$mn:00003C18
.text$mn:00003C18 loc_3C18:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+180j
.text$mn:00003C18                                         ; Notepad_plus::fileCloseAllButCurrent(void):loc_3CF1j
.text$mn:00003C18                 mov     ecx, [ebp+var_1C]
.text$mn:00003C1B                 add     ecx, 1
.text$mn:00003C1E                 mov     [ebp+var_1C], ecx
.text$mn:00003C21
.text$mn:00003C21 loc_3C21:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+12Ej
.text$mn:00003C21                 mov     ecx, [ebp+var_8]
.text$mn:00003C24                 add     ecx, 3DCh       ; this
.text$mn:00003C2A                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:00003C2F                 cmp     [ebp+var_1C], eax
.text$mn:00003C32                 jge     loc_3CF6
.text$mn:00003C38                 mov     edx, [ebp+var_1C]
.text$mn:00003C3B                 push    edx             ; int
.text$mn:00003C3C                 mov     ecx, [ebp+var_8]
.text$mn:00003C3F                 add     ecx, 3DCh       ; this
.text$mn:00003C45                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00003C4A                 mov     [ebp+var_24], eax
.text$mn:00003C4D                 mov     eax, [ebp+var_24]
.text$mn:00003C50                 push    eax             ; struct Buffer *
.text$mn:00003C51                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00003C56                 mov     ecx, eax        ; this
.text$mn:00003C58                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00003C5D                 mov     [ebp+var_20], eax
.text$mn:00003C60                 mov     ecx, [ebp+var_24]
.text$mn:00003C63                 cmp     ecx, [ebp+var_30]
.text$mn:00003C66                 jnz     short loc_3C6A
.text$mn:00003C68                 jmp     short loc_3C18
.text$mn:00003C6A ; ---------------------------------------------------------------------------
.text$mn:00003C6A
.text$mn:00003C6A loc_3C6A:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+17Ej
.text$mn:00003C6A                 mov     ecx, [ebp+var_20] ; this
.text$mn:00003C6D                 call    ?isUntitled@Buffer@@QBE_NXZ ; Buffer::isUntitled(void)
.text$mn:00003C72                 movzx   edx, al
.text$mn:00003C75                 test    edx, edx
.text$mn:00003C77                 jz      short loc_3C87
.text$mn:00003C79                 mov     ecx, [ebp+var_20] ; this
.text$mn:00003C7C                 call    ?docLength@Buffer@@QBEHXZ ; Buffer::docLength(void)
.text$mn:00003C81                 test    eax, eax
.text$mn:00003C83                 jnz     short loc_3C87
.text$mn:00003C85                 jmp     short loc_3CF1
.text$mn:00003C87 ; ---------------------------------------------------------------------------
.text$mn:00003C87
.text$mn:00003C87 loc_3C87:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+18Fj
.text$mn:00003C87                                         ; Notepad_plus::fileCloseAllButCurrent(void)+19Bj
.text$mn:00003C87                 mov     ecx, [ebp+var_20] ; this
.text$mn:00003C8A                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:00003C8F                 movzx   eax, al
.text$mn:00003C92                 test    eax, eax
.text$mn:00003C94                 jz      short loc_3CF1
.text$mn:00003C96                 push    1               ; int
.text$mn:00003C98                 mov     ecx, [ebp+var_24]
.text$mn:00003C9B                 push    ecx             ; struct Buffer *
.text$mn:00003C9C                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003C9F                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:00003CA4                 push    1               ; int
.text$mn:00003CA6                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003CA9                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:00003CAE                 mov     ecx, [ebp+var_20] ; this
.text$mn:00003CB1                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00003CB6                 push    eax             ; wchar_t *
.text$mn:00003CB7                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003CBA                 call    ?doSaveOrNot@Notepad_plus@@AAEHPB_W@Z ; Notepad_plus::doSaveOrNot(wchar_t const *)
.text$mn:00003CBF                 mov     [ebp+var_34], eax
.text$mn:00003CC2                 cmp     [ebp+var_34], 6
.text$mn:00003CC6                 jnz     short loc_3CE4
.text$mn:00003CC8                 mov     edx, [ebp+var_24]
.text$mn:00003CCB                 push    edx             ; struct Buffer *
.text$mn:00003CCC                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003CCF                 call    ?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z ; Notepad_plus::fileSave(Buffer *)
.text$mn:00003CD4                 movzx   eax, al
.text$mn:00003CD7                 test    eax, eax
.text$mn:00003CD9                 jnz     short loc_3CE2
.text$mn:00003CDB                 xor     al, al
.text$mn:00003CDD                 jmp     loc_3E0B
.text$mn:00003CE2 ; ---------------------------------------------------------------------------
.text$mn:00003CE2
.text$mn:00003CE2 loc_3CE2:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+1F1j
.text$mn:00003CE2                 jmp     short loc_3CF1
.text$mn:00003CE4 ; ---------------------------------------------------------------------------
.text$mn:00003CE4
.text$mn:00003CE4 loc_3CE4:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+1DEj
.text$mn:00003CE4                 cmp     [ebp+var_34], 2
.text$mn:00003CE8                 jnz     short loc_3CF1
.text$mn:00003CEA                 xor     al, al
.text$mn:00003CEC                 jmp     loc_3E0B
.text$mn:00003CF1 ; ---------------------------------------------------------------------------
.text$mn:00003CF1
.text$mn:00003CF1 loc_3CF1:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+19Dj
.text$mn:00003CF1                                         ; Notepad_plus::fileCloseAllButCurrent(void)+1ACj ...
.text$mn:00003CF1                 jmp     loc_3C18
.text$mn:00003CF6 ; ---------------------------------------------------------------------------
.text$mn:00003CF6
.text$mn:00003CF6 loc_3CF6:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+14Aj
.text$mn:00003CF6                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00003CFB                 mov     ecx, eax        ; this
.text$mn:00003CFD                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00003D02                 mov     ecx, eax        ; this
.text$mn:00003D04                 call    ?isSnapshotMode@NppGUI@@QBE_NXZ ; NppGUI::isSnapshotMode(void)
.text$mn:00003D09                 mov     [ebp+var_1], al
.text$mn:00003D0C                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003D0F                 call    ?bothActive@Notepad_plus@@AAE_NXZ ; Notepad_plus::bothActive(void)
.text$mn:00003D14                 movzx   ecx, al
.text$mn:00003D17                 test    ecx, ecx
.text$mn:00003D19                 jz      short loc_3D8D
.text$mn:00003D1B                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003D1E                 call    ?otherView@Notepad_plus@@AAEHXZ ; Notepad_plus::otherView(void)
.text$mn:00003D23                 push    eax             ; int
.text$mn:00003D24                 push    0               ; int
.text$mn:00003D26                 mov     edx, [ebp+var_8]
.text$mn:00003D29                 mov     ecx, [edx+460h] ; this
.text$mn:00003D2F                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00003D34                 push    eax             ; struct Buffer *
.text$mn:00003D35                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003D38                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:00003D3D                 mov     eax, [ebp+var_8]
.text$mn:00003D40                 mov     ecx, [eax+460h] ; this
.text$mn:00003D46                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:00003D4B                 sub     eax, 1
.text$mn:00003D4E                 mov     [ebp+var_28], eax
.text$mn:00003D51                 jmp     short loc_3D5C
.text$mn:00003D53 ; ---------------------------------------------------------------------------
.text$mn:00003D53
.text$mn:00003D53 loc_3D53:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+2A3j
.text$mn:00003D53                 mov     ecx, [ebp+var_28]
.text$mn:00003D56                 sub     ecx, 1
.text$mn:00003D59                 mov     [ebp+var_28], ecx
.text$mn:00003D5C
.text$mn:00003D5C loc_3D5C:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+269j
.text$mn:00003D5C                 cmp     [ebp+var_28], 0
.text$mn:00003D60                 jl      short loc_3D8D
.text$mn:00003D62                 movzx   edx, [ebp+var_1]
.text$mn:00003D66                 push    edx             ; bool
.text$mn:00003D67                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003D6A                 call    ?otherView@Notepad_plus@@AAEHXZ ; Notepad_plus::otherView(void)
.text$mn:00003D6F                 push    eax             ; lParam
.text$mn:00003D70                 mov     eax, [ebp+var_28]
.text$mn:00003D73                 push    eax             ; int
.text$mn:00003D74                 mov     ecx, [ebp+var_8]
.text$mn:00003D77                 mov     ecx, [ecx+460h] ; this
.text$mn:00003D7D                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00003D82                 push    eax             ; struct Buffer *
.text$mn:00003D83                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003D86                 call    ?doClose@Notepad_plus@@QAEXPAVBuffer@@H_N@Z ; Notepad_plus::doClose(Buffer *,int,bool)
.text$mn:00003D8B                 jmp     short loc_3D53
.text$mn:00003D8D ; ---------------------------------------------------------------------------
.text$mn:00003D8D
.text$mn:00003D8D loc_3D8D:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+231j
.text$mn:00003D8D                                         ; Notepad_plus::fileCloseAllButCurrent(void)+278j
.text$mn:00003D8D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003D90                 call    ?currentView@Notepad_plus@@AAEHXZ ; Notepad_plus::currentView(void)
.text$mn:00003D95                 push    eax             ; int
.text$mn:00003D96                 push    0               ; int
.text$mn:00003D98                 mov     edx, [ebp+var_8]
.text$mn:00003D9B                 mov     ecx, [edx+45Ch] ; this
.text$mn:00003DA1                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00003DA6                 push    eax             ; struct Buffer *
.text$mn:00003DA7                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003DAA                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:00003DAF                 mov     eax, [ebp+var_8]
.text$mn:00003DB2                 mov     ecx, [eax+45Ch] ; this
.text$mn:00003DB8                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:00003DBD                 sub     eax, 1
.text$mn:00003DC0                 mov     [ebp+var_10], eax
.text$mn:00003DC3                 jmp     short loc_3DCE
.text$mn:00003DC5 ; ---------------------------------------------------------------------------
.text$mn:00003DC5
.text$mn:00003DC5 loc_3DC5:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+2F4j
.text$mn:00003DC5                                         ; Notepad_plus::fileCloseAllButCurrent(void)+31Fj
.text$mn:00003DC5                 mov     ecx, [ebp+var_10]
.text$mn:00003DC8                 sub     ecx, 1
.text$mn:00003DCB                 mov     [ebp+var_10], ecx
.text$mn:00003DCE
.text$mn:00003DCE loc_3DCE:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+2DBj
.text$mn:00003DCE                 cmp     [ebp+var_10], 0
.text$mn:00003DD2                 jl      short loc_3E09
.text$mn:00003DD4                 mov     edx, [ebp+var_10]
.text$mn:00003DD7                 cmp     edx, [ebp+var_38]
.text$mn:00003DDA                 jnz     short loc_3DDE
.text$mn:00003DDC                 jmp     short loc_3DC5
.text$mn:00003DDE ; ---------------------------------------------------------------------------
.text$mn:00003DDE
.text$mn:00003DDE loc_3DDE:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+2F2j
.text$mn:00003DDE                 movzx   eax, [ebp+var_1]
.text$mn:00003DE2                 push    eax             ; bool
.text$mn:00003DE3                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003DE6                 call    ?currentView@Notepad_plus@@AAEHXZ ; Notepad_plus::currentView(void)
.text$mn:00003DEB                 push    eax             ; lParam
.text$mn:00003DEC                 mov     ecx, [ebp+var_10]
.text$mn:00003DEF                 push    ecx             ; int
.text$mn:00003DF0                 mov     edx, [ebp+var_8]
.text$mn:00003DF3                 mov     ecx, [edx+45Ch] ; this
.text$mn:00003DF9                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00003DFE                 push    eax             ; struct Buffer *
.text$mn:00003DFF                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003E02                 call    ?doClose@Notepad_plus@@QAEXPAVBuffer@@H_N@Z ; Notepad_plus::doClose(Buffer *,int,bool)
.text$mn:00003E07                 jmp     short loc_3DC5
.text$mn:00003E09 ; ---------------------------------------------------------------------------
.text$mn:00003E09
.text$mn:00003E09 loc_3E09:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+2EAj
.text$mn:00003E09                 mov     al, 1
.text$mn:00003E0B
.text$mn:00003E0B loc_3E0B:                               ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+10Ej
.text$mn:00003E0B                                         ; Notepad_plus::fileCloseAllButCurrent(void)+11Dj ...
.text$mn:00003E0B                 mov     esp, ebp
.text$mn:00003E0D                 pop     ebp
.text$mn:00003E0E                 retn
.text$mn:00003E0E ?fileCloseAllButCurrent@Notepad_plus@@QAE_NXZ endp
.text$mn:00003E0E
.text$mn:00003E0E ; ---------------------------------------------------------------------------
.text$mn:00003E0F                 db 9 dup(0CCh)
.text$mn:00003E18
.text$mn:00003E18 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E18
.text$mn:00003E18 ; Attributes: bp-based frame
.text$mn:00003E18
.text$mn:00003E18 ; public: bool __thiscall Notepad_plus::fileCloseAllGiven(class std::vector<int, class std::allocator<int>> const &)
.text$mn:00003E18                 public ?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z
.text$mn:00003E18 ?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z proc near
.text$mn:00003E18                                         ; CODE XREF: Notepad_plus::fileCloseAllToLeft(void)+71p
.text$mn:00003E18                                         ; Notepad_plus::fileCloseAllToRight(void)+84p
.text$mn:00003E18
.text$mn:00003E18 var_44          = byte ptr -44h
.text$mn:00003E18 var_38          = byte ptr -38h
.text$mn:00003E18 var_2C          = byte ptr -2Ch
.text$mn:00003E18 var_20          = dword ptr -20h
.text$mn:00003E18 var_1C          = dword ptr -1Ch
.text$mn:00003E18 var_18          = dword ptr -18h
.text$mn:00003E18 var_14          = dword ptr -14h
.text$mn:00003E18 var_10          = byte ptr -10h
.text$mn:00003E18 var_F           = byte ptr -0Fh
.text$mn:00003E18 var_E           = byte ptr -0Eh
.text$mn:00003E18 var_D           = byte ptr -0Dh
.text$mn:00003E18 var_C           = dword ptr -0Ch
.text$mn:00003E18 var_4           = dword ptr -4
.text$mn:00003E18 arg_0           = dword ptr  8
.text$mn:00003E18
.text$mn:00003E18                 push    ebp
.text$mn:00003E19                 mov     ebp, esp
.text$mn:00003E1B                 push    0FFFFFFFFh
.text$mn:00003E1D                 push    offset __ehhandler$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z
.text$mn:00003E22                 mov     eax, large fs:0
.text$mn:00003E28                 push    eax
.text$mn:00003E29                 sub     esp, 38h
.text$mn:00003E2C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003E31                 xor     eax, ebp
.text$mn:00003E33                 push    eax
.text$mn:00003E34                 lea     eax, [ebp+var_C]
.text$mn:00003E37                 mov     large fs:0, eax
.text$mn:00003E3D                 mov     [ebp+var_14], ecx
.text$mn:00003E40                 lea     eax, [ebp+var_38]
.text$mn:00003E43                 push    eax
.text$mn:00003E44                 mov     ecx, [ebp+arg_0]
.text$mn:00003E47                 call    ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::end(void)
.text$mn:00003E4C                 mov     [ebp+var_4], 0
.text$mn:00003E53                 lea     ecx, [ebp+var_2C]
.text$mn:00003E56                 push    ecx
.text$mn:00003E57                 mov     ecx, [ebp+arg_0]
.text$mn:00003E5A                 call    ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::begin(void)
.text$mn:00003E5F                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003E63                 jmp     short loc_3E6D
.text$mn:00003E65 ; ---------------------------------------------------------------------------
.text$mn:00003E65
.text$mn:00003E65 loc_3E65:                               ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &):loc_3FBCj
.text$mn:00003E65                 lea     ecx, [ebp+var_2C]
.text$mn:00003E68                 call    ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)
.text$mn:00003E6D
.text$mn:00003E6D loc_3E6D:                               ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+4Bj
.text$mn:00003E6D                 lea     edx, [ebp+var_38]
.text$mn:00003E70                 push    edx             ; std::_Iterator_base12 *
.text$mn:00003E71                 lea     ecx, [ebp+var_2C]
.text$mn:00003E74                 call    ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00003E79                 movzx   eax, al
.text$mn:00003E7C                 test    eax, eax
.text$mn:00003E7E                 jz      loc_3FC1
.text$mn:00003E84                 lea     ecx, [ebp+var_2C]
.text$mn:00003E87                 call    ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)
.text$mn:00003E8C                 mov     ecx, [eax]
.text$mn:00003E8E                 push    ecx             ; int
.text$mn:00003E8F                 mov     edx, [ebp+var_14]
.text$mn:00003E92                 mov     ecx, [edx+45Ch] ; this
.text$mn:00003E98                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00003E9D                 mov     [ebp+var_18], eax
.text$mn:00003EA0                 mov     eax, [ebp+var_18]
.text$mn:00003EA3                 push    eax             ; struct Buffer *
.text$mn:00003EA4                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00003EA9                 mov     ecx, eax        ; this
.text$mn:00003EAB                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00003EB0                 mov     [ebp+var_1C], eax
.text$mn:00003EB3                 mov     ecx, [ebp+var_1C] ; this
.text$mn:00003EB6                 call    ?isUntitled@Buffer@@QBE_NXZ ; Buffer::isUntitled(void)
.text$mn:00003EBB                 movzx   ecx, al
.text$mn:00003EBE                 test    ecx, ecx
.text$mn:00003EC0                 jz      short loc_3ED3
.text$mn:00003EC2                 mov     ecx, [ebp+var_1C] ; this
.text$mn:00003EC5                 call    ?docLength@Buffer@@QBEHXZ ; Buffer::docLength(void)
.text$mn:00003ECA                 test    eax, eax
.text$mn:00003ECC                 jnz     short loc_3ED3
.text$mn:00003ECE                 jmp     loc_3FBC
.text$mn:00003ED3 ; ---------------------------------------------------------------------------
.text$mn:00003ED3
.text$mn:00003ED3 loc_3ED3:                               ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+A8j
.text$mn:00003ED3                                         ; Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+B4j
.text$mn:00003ED3                 mov     ecx, [ebp+var_1C] ; this
.text$mn:00003ED6                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:00003EDB                 movzx   edx, al
.text$mn:00003EDE                 test    edx, edx
.text$mn:00003EE0                 jz      loc_3FBC
.text$mn:00003EE6                 mov     eax, [ebp+var_14]
.text$mn:00003EE9                 cmp     dword ptr [eax+551C8h], 0
.text$mn:00003EF0                 jnz     short loc_3F21
.text$mn:00003EF2                 push    0               ; int
.text$mn:00003EF4                 mov     ecx, [ebp+var_18]
.text$mn:00003EF7                 push    ecx             ; struct Buffer *
.text$mn:00003EF8                 mov     ecx, [ebp+var_14] ; this
.text$mn:00003EFB                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:00003F00                 push    1               ; int
.text$mn:00003F02                 mov     edx, [ebp+var_18]
.text$mn:00003F05                 push    edx             ; struct Buffer *
.text$mn:00003F06                 mov     ecx, [ebp+var_14] ; this
.text$mn:00003F09                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:00003F0E                 movzx   eax, al
.text$mn:00003F11                 test    eax, eax
.text$mn:00003F13                 jnz     short loc_3F1F
.text$mn:00003F15                 push    0               ; int
.text$mn:00003F17                 mov     ecx, [ebp+var_14] ; this
.text$mn:00003F1A                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:00003F1F
.text$mn:00003F1F loc_3F1F:                               ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+FBj
.text$mn:00003F1F                 jmp     short loc_3F39
.text$mn:00003F21 ; ---------------------------------------------------------------------------
.text$mn:00003F21
.text$mn:00003F21 loc_3F21:                               ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+D8j
.text$mn:00003F21                 push    1               ; int
.text$mn:00003F23                 mov     ecx, [ebp+var_18]
.text$mn:00003F26                 push    ecx             ; struct Buffer *
.text$mn:00003F27                 mov     ecx, [ebp+var_14] ; this
.text$mn:00003F2A                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:00003F2F                 push    1               ; int
.text$mn:00003F31                 mov     ecx, [ebp+var_14] ; this
.text$mn:00003F34                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:00003F39
.text$mn:00003F39 loc_3F39:                               ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &):loc_3F1Fj
.text$mn:00003F39                 mov     ecx, [ebp+var_1C] ; this
.text$mn:00003F3C                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00003F41                 push    eax             ; wchar_t *
.text$mn:00003F42                 mov     ecx, [ebp+var_14] ; this
.text$mn:00003F45                 call    ?doSaveOrNot@Notepad_plus@@AAEHPB_W@Z ; Notepad_plus::doSaveOrNot(wchar_t const *)
.text$mn:00003F4A                 mov     [ebp+var_20], eax
.text$mn:00003F4D                 cmp     [ebp+var_20], 6
.text$mn:00003F51                 jnz     short loc_3F8F
.text$mn:00003F53                 mov     edx, [ebp+var_18]
.text$mn:00003F56                 push    edx             ; struct Buffer *
.text$mn:00003F57                 mov     ecx, [ebp+var_14] ; this
.text$mn:00003F5A                 call    ?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z ; Notepad_plus::fileSave(Buffer *)
.text$mn:00003F5F                 movzx   eax, al
.text$mn:00003F62                 test    eax, eax
.text$mn:00003F64                 jnz     short loc_3F8D
.text$mn:00003F66                 mov     [ebp+var_D], 0
.text$mn:00003F6A                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003F6E                 lea     ecx, [ebp+var_2C]
.text$mn:00003F71                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00003F76                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003F7D                 lea     ecx, [ebp+var_38]
.text$mn:00003F80                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00003F85                 mov     al, [ebp+var_D]
.text$mn:00003F88                 jmp     loc_4064
.text$mn:00003F8D ; ---------------------------------------------------------------------------
.text$mn:00003F8D
.text$mn:00003F8D loc_3F8D:                               ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+14Cj
.text$mn:00003F8D                 jmp     short loc_3FBC
.text$mn:00003F8F ; ---------------------------------------------------------------------------
.text$mn:00003F8F
.text$mn:00003F8F loc_3F8F:                               ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+139j
.text$mn:00003F8F                 cmp     [ebp+var_20], 2
.text$mn:00003F93                 jnz     short loc_3FBC
.text$mn:00003F95                 mov     [ebp+var_E], 0
.text$mn:00003F99                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003F9D                 lea     ecx, [ebp+var_2C]
.text$mn:00003FA0                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00003FA5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003FAC                 lea     ecx, [ebp+var_38]
.text$mn:00003FAF                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00003FB4                 mov     al, [ebp+var_E]
.text$mn:00003FB7                 jmp     loc_4064
.text$mn:00003FBC ; ---------------------------------------------------------------------------
.text$mn:00003FBC
.text$mn:00003FBC loc_3FBC:                               ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+B6j
.text$mn:00003FBC                                         ; Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+C8j ...
.text$mn:00003FBC                 jmp     loc_3E65
.text$mn:00003FC1 ; ---------------------------------------------------------------------------
.text$mn:00003FC1
.text$mn:00003FC1 loc_3FC1:                               ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+66j
.text$mn:00003FC1                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003FC5                 lea     ecx, [ebp+var_2C]
.text$mn:00003FC8                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00003FCD                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00003FD2                 mov     ecx, eax        ; this
.text$mn:00003FD4                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00003FD9                 mov     ecx, eax        ; this
.text$mn:00003FDB                 call    ?isSnapshotMode@NppGUI@@QBE_NXZ ; NppGUI::isSnapshotMode(void)
.text$mn:00003FE0                 mov     [ebp+var_F], al
.text$mn:00003FE3                 lea     ecx, [ebp+var_44]
.text$mn:00003FE6                 push    ecx
.text$mn:00003FE7                 mov     ecx, [ebp+arg_0]
.text$mn:00003FEA                 call    ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::begin(void)
.text$mn:00003FEF                 mov     byte ptr [ebp+var_4], 2
.text$mn:00003FF3                 jmp     short loc_3FFD
.text$mn:00003FF5 ; ---------------------------------------------------------------------------
.text$mn:00003FF5
.text$mn:00003FF5 loc_3FF5:                               ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+228j
.text$mn:00003FF5                 lea     ecx, [ebp+var_44]
.text$mn:00003FF8                 call    ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)
.text$mn:00003FFD
.text$mn:00003FFD loc_3FFD:                               ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+1DBj
.text$mn:00003FFD                 lea     edx, [ebp+var_38]
.text$mn:00004000                 push    edx             ; std::_Iterator_base12 *
.text$mn:00004001                 lea     ecx, [ebp+var_44]
.text$mn:00004004                 call    ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00004009                 movzx   eax, al
.text$mn:0000400C                 test    eax, eax
.text$mn:0000400E                 jz      short loc_4042
.text$mn:00004010                 movzx   ecx, [ebp+var_F]
.text$mn:00004014                 push    ecx             ; bool
.text$mn:00004015                 mov     ecx, [ebp+var_14] ; this
.text$mn:00004018                 call    ?currentView@Notepad_plus@@AAEHXZ ; Notepad_plus::currentView(void)
.text$mn:0000401D                 push    eax             ; lParam
.text$mn:0000401E                 lea     ecx, [ebp+var_44]
.text$mn:00004021                 call    ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)
.text$mn:00004026                 mov     edx, [eax]
.text$mn:00004028                 push    edx             ; int
.text$mn:00004029                 mov     eax, [ebp+var_14]
.text$mn:0000402C                 mov     ecx, [eax+45Ch] ; this
.text$mn:00004032                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00004037                 push    eax             ; struct Buffer *
.text$mn:00004038                 mov     ecx, [ebp+var_14] ; this
.text$mn:0000403B                 call    ?doClose@Notepad_plus@@QAEXPAVBuffer@@H_N@Z ; Notepad_plus::doClose(Buffer *,int,bool)
.text$mn:00004040                 jmp     short loc_3FF5
.text$mn:00004042 ; ---------------------------------------------------------------------------
.text$mn:00004042
.text$mn:00004042 loc_4042:                               ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+1F6j
.text$mn:00004042                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004046                 lea     ecx, [ebp+var_44]
.text$mn:00004049                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:0000404E                 mov     [ebp+var_10], 1
.text$mn:00004052                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004059                 lea     ecx, [ebp+var_38]
.text$mn:0000405C                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00004061                 mov     al, [ebp+var_10]
.text$mn:00004064
.text$mn:00004064 loc_4064:                               ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+170j
.text$mn:00004064                                         ; Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+19Fj
.text$mn:00004064                 mov     ecx, [ebp+var_C]
.text$mn:00004067                 mov     large fs:0, ecx
.text$mn:0000406E                 pop     ecx
.text$mn:0000406F                 mov     esp, ebp
.text$mn:00004071                 pop     ebp
.text$mn:00004072                 retn    4
.text$mn:00004072 ?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z endp
.text$mn:00004072
.text$mn:00004072 ; ---------------------------------------------------------------------------
.text$mn:00004075                 align 4
.text$mn:00004078
.text$mn:00004078 ; =============== S U B R O U T I N E =======================================
.text$mn:00004078
.text$mn:00004078 ; Attributes: bp-based frame
.text$mn:00004078
.text$mn:00004078 ; bool __thiscall Notepad_plus::fileCloseAllToLeft(Notepad_plus *__hidden this)
.text$mn:00004078                 public ?fileCloseAllToLeft@Notepad_plus@@QAE_NXZ
.text$mn:00004078 ?fileCloseAllToLeft@Notepad_plus@@QAE_NXZ proc near
.text$mn:00004078
.text$mn:00004078 var_28          = byte ptr -28h
.text$mn:00004078 var_18          = dword ptr -18h
.text$mn:00004078 var_14          = dword ptr -14h
.text$mn:00004078 var_D           = byte ptr -0Dh
.text$mn:00004078 var_C           = dword ptr -0Ch
.text$mn:00004078 var_4           = dword ptr -4
.text$mn:00004078
.text$mn:00004078                 push    ebp
.text$mn:00004079                 mov     ebp, esp
.text$mn:0000407B                 push    0FFFFFFFFh
.text$mn:0000407D                 push    offset __ehhandler$?fileCloseAllToLeft@Notepad_plus@@QAE_NXZ
.text$mn:00004082                 mov     eax, large fs:0
.text$mn:00004088                 push    eax
.text$mn:00004089                 sub     esp, 1Ch
.text$mn:0000408C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004091                 xor     eax, ebp
.text$mn:00004093                 push    eax
.text$mn:00004094                 lea     eax, [ebp+var_C]
.text$mn:00004097                 mov     large fs:0, eax
.text$mn:0000409D                 mov     [ebp+var_18], ecx
.text$mn:000040A0                 lea     ecx, [ebp+var_28]
.text$mn:000040A3                 call    ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)
.text$mn:000040A8                 mov     [ebp+var_4], 0
.text$mn:000040AF                 mov     eax, [ebp+var_18]
.text$mn:000040B2                 mov     ecx, [eax+45Ch] ; this
.text$mn:000040B8                 call    ?getCurrentTabIndex@TabBar@@QBEHXZ ; TabBar::getCurrentTabIndex(void)
.text$mn:000040BD                 sub     eax, 1
.text$mn:000040C0                 mov     [ebp+var_14], eax
.text$mn:000040C3                 jmp     short loc_40CE
.text$mn:000040C5 ; ---------------------------------------------------------------------------
.text$mn:000040C5
.text$mn:000040C5 loc_40C5:                               ; CODE XREF: Notepad_plus::fileCloseAllToLeft(void)+68j
.text$mn:000040C5                 mov     ecx, [ebp+var_14]
.text$mn:000040C8                 sub     ecx, 1
.text$mn:000040CB                 mov     [ebp+var_14], ecx
.text$mn:000040CE
.text$mn:000040CE loc_40CE:                               ; CODE XREF: Notepad_plus::fileCloseAllToLeft(void)+4Bj
.text$mn:000040CE                 cmp     [ebp+var_14], 0
.text$mn:000040D2                 jl      short loc_40E2
.text$mn:000040D4                 lea     edx, [ebp+var_14]
.text$mn:000040D7                 push    edx
.text$mn:000040D8                 lea     ecx, [ebp+var_28]
.text$mn:000040DB                 call    ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int>>::push_back(int const &)
.text$mn:000040E0                 jmp     short loc_40C5
.text$mn:000040E2 ; ---------------------------------------------------------------------------
.text$mn:000040E2
.text$mn:000040E2 loc_40E2:                               ; CODE XREF: Notepad_plus::fileCloseAllToLeft(void)+5Aj
.text$mn:000040E2                 lea     eax, [ebp+var_28]
.text$mn:000040E5                 push    eax
.text$mn:000040E6                 mov     ecx, [ebp+var_18]
.text$mn:000040E9                 call    ?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z ; Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)
.text$mn:000040EE                 mov     [ebp+var_D], al
.text$mn:000040F1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000040F8                 lea     ecx, [ebp+var_28]
.text$mn:000040FB                 call    ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)
.text$mn:00004100                 mov     al, [ebp+var_D]
.text$mn:00004103                 mov     ecx, [ebp+var_C]
.text$mn:00004106                 mov     large fs:0, ecx
.text$mn:0000410D                 pop     ecx
.text$mn:0000410E                 mov     esp, ebp
.text$mn:00004110                 pop     ebp
.text$mn:00004111                 retn
.text$mn:00004111 ?fileCloseAllToLeft@Notepad_plus@@QAE_NXZ endp
.text$mn:00004111
.text$mn:00004111 ; ---------------------------------------------------------------------------
.text$mn:00004112                 align 8
.text$mn:00004118
.text$mn:00004118 ; =============== S U B R O U T I N E =======================================
.text$mn:00004118
.text$mn:00004118 ; Attributes: bp-based frame
.text$mn:00004118
.text$mn:00004118 ; bool __thiscall Notepad_plus::fileCloseAllToRight(Notepad_plus *__hidden this)
.text$mn:00004118                 public ?fileCloseAllToRight@Notepad_plus@@QAE_NXZ
.text$mn:00004118 ?fileCloseAllToRight@Notepad_plus@@QAE_NXZ proc near
.text$mn:00004118
.text$mn:00004118 var_2C          = byte ptr -2Ch
.text$mn:00004118 var_1C          = dword ptr -1Ch
.text$mn:00004118 var_18          = dword ptr -18h
.text$mn:00004118 var_14          = dword ptr -14h
.text$mn:00004118 var_D           = byte ptr -0Dh
.text$mn:00004118 var_C           = dword ptr -0Ch
.text$mn:00004118 var_4           = dword ptr -4
.text$mn:00004118
.text$mn:00004118                 push    ebp
.text$mn:00004119                 mov     ebp, esp
.text$mn:0000411B                 push    0FFFFFFFFh
.text$mn:0000411D                 push    offset __ehhandler$?fileCloseAllToRight@Notepad_plus@@QAE_NXZ
.text$mn:00004122                 mov     eax, large fs:0
.text$mn:00004128                 push    eax
.text$mn:00004129                 sub     esp, 20h
.text$mn:0000412C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004131                 xor     eax, ebp
.text$mn:00004133                 push    eax
.text$mn:00004134                 lea     eax, [ebp+var_C]
.text$mn:00004137                 mov     large fs:0, eax
.text$mn:0000413D                 mov     [ebp+var_18], ecx
.text$mn:00004140                 mov     eax, [ebp+var_18]
.text$mn:00004143                 mov     ecx, [eax+45Ch] ; this
.text$mn:00004149                 call    ?getCurrentTabIndex@TabBar@@QBEHXZ ; TabBar::getCurrentTabIndex(void)
.text$mn:0000414E                 mov     [ebp+var_1C], eax
.text$mn:00004151                 lea     ecx, [ebp+var_2C]
.text$mn:00004154                 call    ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)
.text$mn:00004159                 mov     [ebp+var_4], 0
.text$mn:00004160                 mov     ecx, [ebp+var_18]
.text$mn:00004163                 mov     ecx, [ecx+45Ch] ; this
.text$mn:00004169                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:0000416E                 sub     eax, 1
.text$mn:00004171                 mov     [ebp+var_14], eax
.text$mn:00004174                 jmp     short loc_417F
.text$mn:00004176 ; ---------------------------------------------------------------------------
.text$mn:00004176
.text$mn:00004176 loc_4176:                               ; CODE XREF: Notepad_plus::fileCloseAllToRight(void)+7Bj
.text$mn:00004176                 mov     edx, [ebp+var_14]
.text$mn:00004179                 sub     edx, 1
.text$mn:0000417C                 mov     [ebp+var_14], edx
.text$mn:0000417F
.text$mn:0000417F loc_417F:                               ; CODE XREF: Notepad_plus::fileCloseAllToRight(void)+5Cj
.text$mn:0000417F                 mov     eax, [ebp+var_14]
.text$mn:00004182                 cmp     eax, [ebp+var_1C]
.text$mn:00004185                 jle     short loc_4195
.text$mn:00004187                 lea     ecx, [ebp+var_14]
.text$mn:0000418A                 push    ecx
.text$mn:0000418B                 lea     ecx, [ebp+var_2C]
.text$mn:0000418E                 call    ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int>>::push_back(int const &)
.text$mn:00004193                 jmp     short loc_4176
.text$mn:00004195 ; ---------------------------------------------------------------------------
.text$mn:00004195
.text$mn:00004195 loc_4195:                               ; CODE XREF: Notepad_plus::fileCloseAllToRight(void)+6Dj
.text$mn:00004195                 lea     edx, [ebp+var_2C]
.text$mn:00004198                 push    edx
.text$mn:00004199                 mov     ecx, [ebp+var_18]
.text$mn:0000419C                 call    ?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z ; Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)
.text$mn:000041A1                 mov     [ebp+var_D], al
.text$mn:000041A4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000041AB                 lea     ecx, [ebp+var_2C]
.text$mn:000041AE                 call    ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)
.text$mn:000041B3                 mov     al, [ebp+var_D]
.text$mn:000041B6                 mov     ecx, [ebp+var_C]
.text$mn:000041B9                 mov     large fs:0, ecx
.text$mn:000041C0                 pop     ecx
.text$mn:000041C1                 mov     esp, ebp
.text$mn:000041C3                 pop     ebp
.text$mn:000041C4                 retn
.text$mn:000041C4 ?fileCloseAllToRight@Notepad_plus@@QAE_NXZ endp
.text$mn:000041C4
.text$mn:000041C4 ; ---------------------------------------------------------------------------
.text$mn:000041C5                 align 4
.text$mn:000041C8
.text$mn:000041C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000041C8
.text$mn:000041C8 ; Attributes: bp-based frame
.text$mn:000041C8
.text$mn:000041C8 ; bool __thiscall Notepad_plus::fileSave(Notepad_plus *this, struct Buffer *)
.text$mn:000041C8                 public ?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z
.text$mn:000041C8 ?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z proc near
.text$mn:000041C8                                         ; CODE XREF: Notepad_plus::fileClose(Buffer *,int)+8Cp
.text$mn:000041C8                                         ; Notepad_plus::fileCloseAll(bool,bool)+2C9p ...
.text$mn:000041C8
.text$mn:000041C8 var_F0          = dword ptr -0F0h
.text$mn:000041C8 Time            = dword ptr -0ECh
.text$mn:000041C8 var_E8          = dword ptr -0E8h
.text$mn:000041C8 Tm              = dword ptr -0E4h
.text$mn:000041C8 var_E0          = dword ptr -0E0h
.text$mn:000041C8 Str             = dword ptr -0DCh
.text$mn:000041C8 var_D8          = dword ptr -0D8h
.text$mn:000041C8 var_D4          = dword ptr -0D4h
.text$mn:000041C8 var_D0          = dword ptr -0D0h
.text$mn:000041C8 var_CC          = dword ptr -0CCh
.text$mn:000041C8 pszPath         = dword ptr -0C8h
.text$mn:000041C8 var_C4          = dword ptr -0C4h
.text$mn:000041C8 var_C0          = byte ptr -0C0h
.text$mn:000041C8 var_A4          = byte ptr -0A4h
.text$mn:000041C8 var_88          = byte ptr -88h
.text$mn:000041C8 var_6C          = byte ptr -6Ch
.text$mn:000041C8 Buf             = word ptr -50h
.text$mn:000041C8 var_10          = dword ptr -10h
.text$mn:000041C8 var_C           = dword ptr -0Ch
.text$mn:000041C8 var_4           = dword ptr -4
.text$mn:000041C8 arg_0           = dword ptr  8
.text$mn:000041C8
.text$mn:000041C8                 push    ebp
.text$mn:000041C9                 mov     ebp, esp
.text$mn:000041CB                 push    0FFFFFFFFh
.text$mn:000041CD                 push    offset __ehhandler$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z
.text$mn:000041D2                 mov     eax, large fs:0
.text$mn:000041D8                 push    eax
.text$mn:000041D9                 sub     esp, 0E4h
.text$mn:000041DF                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000041E4                 xor     eax, ebp
.text$mn:000041E6                 mov     [ebp+var_10], eax
.text$mn:000041E9                 push    eax
.text$mn:000041EA                 lea     eax, [ebp+var_C]
.text$mn:000041ED                 mov     large fs:0, eax
.text$mn:000041F3                 mov     [ebp+var_D4], ecx
.text$mn:000041F9                 mov     eax, [ebp+arg_0]
.text$mn:000041FC                 mov     [ebp+var_D0], eax
.text$mn:00004202                 cmp     [ebp+arg_0], 0
.text$mn:00004206                 jnz     short loc_421F
.text$mn:00004208                 mov     ecx, [ebp+var_D4]
.text$mn:0000420E                 mov     ecx, [ecx+5D4h] ; this
.text$mn:00004214                 call    ?getCurrentBufferID@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBufferID(void)
.text$mn:00004219                 mov     [ebp+var_D0], eax
.text$mn:0000421F
.text$mn:0000421F loc_421F:                               ; CODE XREF: Notepad_plus::fileSave(Buffer *)+3Ej
.text$mn:0000421F                 mov     edx, [ebp+var_D0]
.text$mn:00004225                 push    edx             ; struct Buffer *
.text$mn:00004226                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:0000422B                 mov     ecx, eax        ; this
.text$mn:0000422D                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00004232                 mov     [ebp+var_CC], eax
.text$mn:00004238                 mov     ecx, [ebp+var_CC] ; this
.text$mn:0000423E                 call    ?getFileReadOnly@Buffer@@QBE_NXZ ; Buffer::getFileReadOnly(void)
.text$mn:00004243                 movzx   eax, al
.text$mn:00004246                 test    eax, eax
.text$mn:00004248                 jnz     loc_45BA
.text$mn:0000424E                 mov     ecx, [ebp+var_CC] ; this
.text$mn:00004254                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:00004259                 movzx   ecx, al
.text$mn:0000425C                 test    ecx, ecx
.text$mn:0000425E                 jz      loc_45BA
.text$mn:00004264                 mov     ecx, [ebp+var_CC] ; this
.text$mn:0000426A                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:0000426F                 mov     [ebp+pszPath], eax
.text$mn:00004275                 mov     ecx, [ebp+var_CC] ; this
.text$mn:0000427B                 call    ?isUntitled@Buffer@@QBE_NXZ ; Buffer::isUntitled(void)
.text$mn:00004280                 movzx   edx, al
.text$mn:00004283                 test    edx, edx
.text$mn:00004285                 jz      short loc_42A5
.text$mn:00004287                 push    0               ; bool
.text$mn:00004289                 mov     eax, [ebp+var_D0]
.text$mn:0000428F                 push    eax             ; struct Buffer *
.text$mn:00004290                 mov     ecx, [ebp+var_D4] ; this
.text$mn:00004296                 call    ?fileSaveAs@Notepad_plus@@QAE_NPAVBuffer@@_N@Z ; Notepad_plus::fileSaveAs(Buffer *,bool)
.text$mn:0000429B                 jmp     loc_45BC
.text$mn:000042A0 ; ---------------------------------------------------------------------------
.text$mn:000042A0                 jmp     loc_45BA
.text$mn:000042A5 ; ---------------------------------------------------------------------------
.text$mn:000042A5
.text$mn:000042A5 loc_42A5:                               ; CODE XREF: Notepad_plus::fileSave(Buffer *)+BDj
.text$mn:000042A5                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000042AA                 mov     ecx, eax        ; this
.text$mn:000042AC                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:000042B1                 mov     [ebp+var_C4], eax
.text$mn:000042B7                 mov     ecx, [ebp+var_C4]
.text$mn:000042BD                 mov     edx, [ecx+180h]
.text$mn:000042C3                 mov     [ebp+var_D8], edx
.text$mn:000042C9                 mov     eax, [ebp+pszPath]
.text$mn:000042CF                 push    eax             ; pszPath
.text$mn:000042D0                 call    dword ptr ds:__imp__PathFindFileNameW@4 ; PathFindFileNameW(x)
.text$mn:000042D6                 mov     [ebp+Str], eax
.text$mn:000042DC                 cmp     [ebp+var_D8], 1
.text$mn:000042E3                 jnz     loc_43C3
.text$mn:000042E9                 mov     ecx, [ebp+pszPath]
.text$mn:000042EF                 push    ecx             ; Str
.text$mn:000042F0                 lea     ecx, [ebp+var_88]
.text$mn:000042F6                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000042FB                 mov     [ebp+var_4], 0
.text$mn:00004302                 mov     edx, [ebp+var_C4]
.text$mn:00004308                 movzx   eax, byte ptr [edx+184h]
.text$mn:0000430F                 test    eax, eax
.text$mn:00004311                 jz      short loc_436F
.text$mn:00004313                 push    offset $SG176851 ; Str
.text$mn:00004318                 mov     ecx, [ebp+var_C4]
.text$mn:0000431E                 add     ecx, 188h
.text$mn:00004324                 push    ecx             ; int
.text$mn:00004325                 call    ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:0000432A                 add     esp, 8
.text$mn:0000432D                 movzx   edx, al
.text$mn:00004330                 test    edx, edx
.text$mn:00004332                 jz      short loc_436F
.text$mn:00004334                 mov     eax, [ebp+var_C4]
.text$mn:0000433A                 add     eax, 188h
.text$mn:0000433F                 push    eax
.text$mn:00004340                 lea     ecx, [ebp+var_88]
.text$mn:00004346                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000434B                 push    offset $SG176852 ; Str
.text$mn:00004350                 lea     ecx, [ebp+var_88]
.text$mn:00004356                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:0000435B                 mov     ecx, [ebp+Str]
.text$mn:00004361                 push    ecx             ; Str
.text$mn:00004362                 lea     ecx, [ebp+var_88]
.text$mn:00004368                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:0000436D                 jmp     short loc_4381
.text$mn:0000436F ; ---------------------------------------------------------------------------
.text$mn:0000436F
.text$mn:0000436F loc_436F:                               ; CODE XREF: Notepad_plus::fileSave(Buffer *)+149j
.text$mn:0000436F                                         ; Notepad_plus::fileSave(Buffer *)+16Aj
.text$mn:0000436F                 mov     edx, [ebp+pszPath]
.text$mn:00004375                 push    edx             ; Str
.text$mn:00004376                 lea     ecx, [ebp+var_88]
.text$mn:0000437C                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:00004381
.text$mn:00004381 loc_4381:                               ; CODE XREF: Notepad_plus::fileSave(Buffer *)+1A5j
.text$mn:00004381                 push    offset $SG176854 ; ".bak"
.text$mn:00004386                 lea     ecx, [ebp+var_88]
.text$mn:0000438C                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00004391                 push    0               ; bFailIfExists
.text$mn:00004393                 lea     ecx, [ebp+var_88]
.text$mn:00004399                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000439E                 push    eax             ; lpNewFileName
.text$mn:0000439F                 mov     eax, [ebp+pszPath]
.text$mn:000043A5                 push    eax             ; lpExistingFileName
.text$mn:000043A6                 call    dword ptr ds:__imp__CopyFileW@12 ; CopyFileW(x,x,x)
.text$mn:000043AC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000043B3                 lea     ecx, [ebp+var_88]
.text$mn:000043B9                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000043BE                 jmp     loc_4598
.text$mn:000043C3 ; ---------------------------------------------------------------------------
.text$mn:000043C3
.text$mn:000043C3 loc_43C3:                               ; CODE XREF: Notepad_plus::fileSave(Buffer *)+11Bj
.text$mn:000043C3                 cmp     [ebp+var_D8], 2
.text$mn:000043CA                 jnz     loc_4598
.text$mn:000043D0                 push    offset $SG176874 ; Str
.text$mn:000043D5                 lea     ecx, [ebp+var_6C]
.text$mn:000043D8                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000043DD                 mov     [ebp+var_4], 1
.text$mn:000043E4                 mov     ecx, [ebp+var_C4]
.text$mn:000043EA                 movzx   edx, byte ptr [ecx+184h]
.text$mn:000043F1                 test    edx, edx
.text$mn:000043F3                 jz      short loc_443C
.text$mn:000043F5                 push    offset $SG176892 ; Str
.text$mn:000043FA                 mov     eax, [ebp+var_C4]
.text$mn:00004400                 add     eax, 188h
.text$mn:00004405                 push    eax             ; int
.text$mn:00004406                 call    ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:0000440B                 add     esp, 8
.text$mn:0000440E                 movzx   ecx, al
.text$mn:00004411                 test    ecx, ecx
.text$mn:00004413                 jz      short loc_443C
.text$mn:00004415                 mov     edx, [ebp+var_C4]
.text$mn:0000441B                 add     edx, 188h
.text$mn:00004421                 push    edx
.text$mn:00004422                 lea     ecx, [ebp+var_6C]
.text$mn:00004425                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000442A                 push    offset $SG176893 ; Str
.text$mn:0000442F                 lea     ecx, [ebp+var_6C]
.text$mn:00004432                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00004437                 jmp     loc_44ED
.text$mn:0000443C ; ---------------------------------------------------------------------------
.text$mn:0000443C
.text$mn:0000443C loc_443C:                               ; CODE XREF: Notepad_plus::fileSave(Buffer *)+22Bj
.text$mn:0000443C                                         ; Notepad_plus::fileSave(Buffer *)+24Bj
.text$mn:0000443C                 mov     [ebp+var_E0], offset $SG176896 ; "nppBackup"
.text$mn:00004446                 mov     eax, [ebp+pszPath]
.text$mn:0000444C                 push    eax             ; Str
.text$mn:0000444D                 lea     ecx, [ebp+var_A4]
.text$mn:00004453                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00004458                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000445C                 lea     ecx, [ebp+var_A4]
.text$mn:00004462                 push    ecx
.text$mn:00004463                 lea     edx, [ebp+var_C0]
.text$mn:00004469                 push    edx
.text$mn:0000446A                 call    ?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z ; PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:0000446F                 add     esp, 8
.text$mn:00004472                 lea     ecx, [ebp+var_C0]
.text$mn:00004478                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000447D                 lea     ecx, [ebp+var_A4]
.text$mn:00004483                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00004488                 push    eax             ; Str
.text$mn:00004489                 lea     ecx, [ebp+var_6C]
.text$mn:0000448C                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:00004491                 push    offset $SG176899 ; Str
.text$mn:00004496                 lea     ecx, [ebp+var_6C]
.text$mn:00004499                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:0000449E                 mov     eax, [ebp+var_E0]
.text$mn:000044A4                 push    eax             ; Str
.text$mn:000044A5                 lea     ecx, [ebp+var_6C]
.text$mn:000044A8                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:000044AD                 push    offset $SG176900 ; Str
.text$mn:000044B2                 lea     ecx, [ebp+var_6C]
.text$mn:000044B5                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:000044BA                 lea     ecx, [ebp+var_6C]
.text$mn:000044BD                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000044C2                 push    eax             ; pszPath
.text$mn:000044C3                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:000044C9                 test    eax, eax
.text$mn:000044CB                 jnz     short loc_44DE
.text$mn:000044CD                 push    0               ; lpSecurityAttributes
.text$mn:000044CF                 lea     ecx, [ebp+var_6C]
.text$mn:000044D2                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000044D7                 push    eax             ; lpPathName
.text$mn:000044D8                 call    dword ptr ds:__imp__CreateDirectoryW@8 ; CreateDirectoryW(x,x)
.text$mn:000044DE
.text$mn:000044DE loc_44DE:                               ; CODE XREF: Notepad_plus::fileSave(Buffer *)+303j
.text$mn:000044DE                 mov     byte ptr [ebp+var_4], 1
.text$mn:000044E2                 lea     ecx, [ebp+var_A4]
.text$mn:000044E8                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000044ED
.text$mn:000044ED loc_44ED:                               ; CODE XREF: Notepad_plus::fileSave(Buffer *)+26Fj
.text$mn:000044ED                 mov     ecx, [ebp+Str]
.text$mn:000044F3                 push    ecx             ; Str
.text$mn:000044F4                 lea     ecx, [ebp+var_6C]
.text$mn:000044F7                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:000044FC                 mov     [ebp+var_F0], 20h ; ' '
.text$mn:00004506                 push    0               ; Time
.text$mn:00004508                 call    _time
.text$mn:0000450D                 add     esp, 4
.text$mn:00004510                 mov     [ebp+Time], eax
.text$mn:00004516                 mov     [ebp+var_E8], edx
.text$mn:0000451C                 lea     edx, [ebp+Time]
.text$mn:00004522                 push    edx             ; Time
.text$mn:00004523                 call    _localtime
.text$mn:00004528                 add     esp, 4
.text$mn:0000452B                 mov     [ebp+Tm], eax
.text$mn:00004531                 mov     eax, [ebp+Tm]
.text$mn:00004537                 push    eax             ; Tm
.text$mn:00004538                 push    offset $SG176906 ; "%Y-%m-%d_%H%M%S"
.text$mn:0000453D                 push    20h ; ' '       ; SizeInWords
.text$mn:0000453F                 lea     ecx, [ebp+Buf]
.text$mn:00004542                 push    ecx             ; Buf
.text$mn:00004543                 call    _wcsftime
.text$mn:00004548                 add     esp, 10h
.text$mn:0000454B                 push    offset $SG176907 ; Str
.text$mn:00004550                 lea     ecx, [ebp+var_6C]
.text$mn:00004553                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00004558                 lea     edx, [ebp+Buf]
.text$mn:0000455B                 push    edx             ; Str
.text$mn:0000455C                 lea     ecx, [ebp+var_6C]
.text$mn:0000455F                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00004564                 push    offset $SG176908 ; ".bak"
.text$mn:00004569                 lea     ecx, [ebp+var_6C]
.text$mn:0000456C                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00004571                 push    0               ; bFailIfExists
.text$mn:00004573                 lea     ecx, [ebp+var_6C]
.text$mn:00004576                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000457B                 push    eax             ; lpNewFileName
.text$mn:0000457C                 mov     eax, [ebp+pszPath]
.text$mn:00004582                 push    eax             ; lpExistingFileName
.text$mn:00004583                 call    dword ptr ds:__imp__CopyFileW@12 ; CopyFileW(x,x,x)
.text$mn:00004589                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004590                 lea     ecx, [ebp+var_6C]
.text$mn:00004593                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00004598
.text$mn:00004598 loc_4598:                               ; CODE XREF: Notepad_plus::fileSave(Buffer *)+1F6j
.text$mn:00004598                                         ; Notepad_plus::fileSave(Buffer *)+202j
.text$mn:00004598                 push    0               ; bool
.text$mn:0000459A                 mov     ecx, [ebp+var_CC] ; this
.text$mn:000045A0                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:000045A5                 push    eax             ; wchar_t *
.text$mn:000045A6                 mov     ecx, [ebp+var_D0]
.text$mn:000045AC                 push    ecx             ; struct Buffer *
.text$mn:000045AD                 mov     ecx, [ebp+var_D4] ; this
.text$mn:000045B3                 call    ?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z ; Notepad_plus::doSave(Buffer *,wchar_t const *,bool)
.text$mn:000045B8                 jmp     short loc_45BC
.text$mn:000045BA ; ---------------------------------------------------------------------------
.text$mn:000045BA
.text$mn:000045BA loc_45BA:                               ; CODE XREF: Notepad_plus::fileSave(Buffer *)+80j
.text$mn:000045BA                                         ; Notepad_plus::fileSave(Buffer *)+96j ...
.text$mn:000045BA                 xor     al, al
.text$mn:000045BC
.text$mn:000045BC loc_45BC:                               ; CODE XREF: Notepad_plus::fileSave(Buffer *)+D3j
.text$mn:000045BC                                         ; Notepad_plus::fileSave(Buffer *)+3F0j
.text$mn:000045BC                 mov     ecx, [ebp+var_C]
.text$mn:000045BF                 mov     large fs:0, ecx
.text$mn:000045C6                 pop     ecx
.text$mn:000045C7                 mov     ecx, [ebp+var_10]
.text$mn:000045CA                 xor     ecx, ebp
.text$mn:000045CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000045D1                 mov     esp, ebp
.text$mn:000045D3                 pop     ebp
.text$mn:000045D4                 retn    4
.text$mn:000045D4 ?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z endp
.text$mn:000045D4
.text$mn:000045D4 ; ---------------------------------------------------------------------------
.text$mn:000045D7                 align 4
.text$mn:000045D8
.text$mn:000045D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000045D8
.text$mn:000045D8 ; Attributes: bp-based frame
.text$mn:000045D8
.text$mn:000045D8 ; bool __thiscall Notepad_plus::fileSaveAll(Notepad_plus *__hidden this)
.text$mn:000045D8                 public ?fileSaveAll@Notepad_plus@@QAE_NXZ
.text$mn:000045D8 ?fileSaveAll@Notepad_plus@@QAE_NXZ proc near
.text$mn:000045D8
.text$mn:000045D8 var_14          = dword ptr -14h
.text$mn:000045D8 var_10          = dword ptr -10h
.text$mn:000045D8 var_C           = dword ptr -0Ch
.text$mn:000045D8 var_8           = dword ptr -8
.text$mn:000045D8 var_4           = dword ptr -4
.text$mn:000045D8
.text$mn:000045D8                 push    ebp
.text$mn:000045D9                 mov     ebp, esp
.text$mn:000045DB                 sub     esp, 14h
.text$mn:000045DE                 mov     [ebp+var_4], ecx
.text$mn:000045E1                 push    0               ; int
.text$mn:000045E3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000045E6                 call    ?viewVisible@Notepad_plus@@AAE_NH@Z ; Notepad_plus::viewVisible(int)
.text$mn:000045EB                 movzx   eax, al
.text$mn:000045EE                 test    eax, eax
.text$mn:000045F0                 jz      short loc_463A
.text$mn:000045F2                 mov     [ebp+var_8], 0
.text$mn:000045F9                 jmp     short loc_4604
.text$mn:000045FB ; ---------------------------------------------------------------------------
.text$mn:000045FB
.text$mn:000045FB loc_45FB:                               ; CODE XREF: Notepad_plus::fileSaveAll(void)+60j
.text$mn:000045FB                 mov     ecx, [ebp+var_8]
.text$mn:000045FE                 add     ecx, 1
.text$mn:00004601                 mov     [ebp+var_8], ecx
.text$mn:00004604
.text$mn:00004604 loc_4604:                               ; CODE XREF: Notepad_plus::fileSaveAll(void)+21j
.text$mn:00004604                 mov     ecx, [ebp+var_4]
.text$mn:00004607                 add     ecx, 35Ch       ; this
.text$mn:0000460D                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:00004612                 cmp     [ebp+var_8], eax
.text$mn:00004615                 jge     short loc_463A
.text$mn:00004617                 mov     edx, [ebp+var_8]
.text$mn:0000461A                 push    edx             ; int
.text$mn:0000461B                 mov     ecx, [ebp+var_4]
.text$mn:0000461E                 add     ecx, 35Ch       ; this
.text$mn:00004624                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00004629                 mov     [ebp+var_10], eax
.text$mn:0000462C                 mov     eax, [ebp+var_10]
.text$mn:0000462F                 push    eax             ; struct Buffer *
.text$mn:00004630                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004633                 call    ?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z ; Notepad_plus::fileSave(Buffer *)
.text$mn:00004638                 jmp     short loc_45FB
.text$mn:0000463A ; ---------------------------------------------------------------------------
.text$mn:0000463A
.text$mn:0000463A loc_463A:                               ; CODE XREF: Notepad_plus::fileSaveAll(void)+18j
.text$mn:0000463A                                         ; Notepad_plus::fileSaveAll(void)+3Dj
.text$mn:0000463A                 push    1               ; int
.text$mn:0000463C                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000463F                 call    ?viewVisible@Notepad_plus@@AAE_NH@Z ; Notepad_plus::viewVisible(int)
.text$mn:00004644                 movzx   ecx, al
.text$mn:00004647                 test    ecx, ecx
.text$mn:00004649                 jz      short loc_4693
.text$mn:0000464B                 mov     [ebp+var_C], 0
.text$mn:00004652                 jmp     short loc_465D
.text$mn:00004654 ; ---------------------------------------------------------------------------
.text$mn:00004654
.text$mn:00004654 loc_4654:                               ; CODE XREF: Notepad_plus::fileSaveAll(void)+B9j
.text$mn:00004654                 mov     edx, [ebp+var_C]
.text$mn:00004657                 add     edx, 1
.text$mn:0000465A                 mov     [ebp+var_C], edx
.text$mn:0000465D
.text$mn:0000465D loc_465D:                               ; CODE XREF: Notepad_plus::fileSaveAll(void)+7Aj
.text$mn:0000465D                 mov     ecx, [ebp+var_4]
.text$mn:00004660                 add     ecx, 3DCh       ; this
.text$mn:00004666                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:0000466B                 cmp     [ebp+var_C], eax
.text$mn:0000466E                 jge     short loc_4693
.text$mn:00004670                 mov     eax, [ebp+var_C]
.text$mn:00004673                 push    eax             ; int
.text$mn:00004674                 mov     ecx, [ebp+var_4]
.text$mn:00004677                 add     ecx, 3DCh       ; this
.text$mn:0000467D                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00004682                 mov     [ebp+var_14], eax
.text$mn:00004685                 mov     ecx, [ebp+var_14]
.text$mn:00004688                 push    ecx             ; struct Buffer *
.text$mn:00004689                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000468C                 call    ?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z ; Notepad_plus::fileSave(Buffer *)
.text$mn:00004691                 jmp     short loc_4654
.text$mn:00004693 ; ---------------------------------------------------------------------------
.text$mn:00004693
.text$mn:00004693 loc_4693:                               ; CODE XREF: Notepad_plus::fileSaveAll(void)+71j
.text$mn:00004693                                         ; Notepad_plus::fileSaveAll(void)+96j
.text$mn:00004693                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004696                 call    ?checkDocState@Notepad_plus@@AAEXXZ ; Notepad_plus::checkDocState(void)
.text$mn:0000469B                 mov     al, 1
.text$mn:0000469D                 mov     esp, ebp
.text$mn:0000469F                 pop     ebp
.text$mn:000046A0                 retn
.text$mn:000046A0 ?fileSaveAll@Notepad_plus@@QAE_NXZ endp
.text$mn:000046A0
.text$mn:000046A0 ; ---------------------------------------------------------------------------
.text$mn:000046A1                 align 8
.text$mn:000046A8
.text$mn:000046A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000046A8
.text$mn:000046A8 ; Attributes: bp-based frame
.text$mn:000046A8
.text$mn:000046A8 ; bool __thiscall Notepad_plus::fileSaveAs(Notepad_plus *this, struct Buffer *, bool)
.text$mn:000046A8                 public ?fileSaveAs@Notepad_plus@@QAE_NPAVBuffer@@_N@Z
.text$mn:000046A8 ?fileSaveAs@Notepad_plus@@QAE_NPAVBuffer@@_N@Z proc near
.text$mn:000046A8                                         ; CODE XREF: Notepad_plus::fileSave(Buffer *)+CEp
.text$mn:000046A8
.text$mn:000046A8 var_10F0        = dword ptr -10F0h
.text$mn:000046A8 var_10EC        = dword ptr -10ECh
.text$mn:000046A8 var_10E8        = dword ptr -10E8h
.text$mn:000046A8 var_10E4        = dword ptr -10E4h
.text$mn:000046A8 var_10E0        = dword ptr -10E0h
.text$mn:000046A8 var_10DC        = dword ptr -10DCh
.text$mn:000046A8 var_10D8        = dword ptr -10D8h
.text$mn:000046A8 var_10D4        = byte ptr -10D4h
.text$mn:000046A8 var_10D3        = byte ptr -10D3h
.text$mn:000046A8 var_10D2        = byte ptr -10D2h
.text$mn:000046A8 var_10D1        = byte ptr -10D1h
.text$mn:000046A8 var_10D0        = dword ptr -10D0h
.text$mn:000046A8 var_10CC        = byte ptr -10CCh
.text$mn:000046A8 var_10          = dword ptr -10h
.text$mn:000046A8 var_C           = dword ptr -0Ch
.text$mn:000046A8 var_4           = dword ptr -4
.text$mn:000046A8 arg_0           = dword ptr  8
.text$mn:000046A8 arg_4           = byte ptr  0Ch
.text$mn:000046A8
.text$mn:000046A8                 push    ebp
.text$mn:000046A9                 mov     ebp, esp
.text$mn:000046AB                 push    0FFFFFFFFh
.text$mn:000046AD                 push    offset __ehhandler$?fileSaveAs@Notepad_plus@@QAE_NPAVBuffer@@_N@Z
.text$mn:000046B2                 mov     eax, large fs:0
.text$mn:000046B8                 push    eax
.text$mn:000046B9                 mov     eax, 10E4h
.text$mn:000046BE                 call    __chkstk
.text$mn:000046C3                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000046C8                 xor     eax, ebp
.text$mn:000046CA                 mov     [ebp+var_10], eax
.text$mn:000046CD                 push    eax
.text$mn:000046CE                 lea     eax, [ebp+var_C]
.text$mn:000046D1                 mov     large fs:0, eax
.text$mn:000046D7                 mov     [ebp+var_10D0], ecx
.text$mn:000046DD                 mov     eax, [ebp+arg_0]
.text$mn:000046E0                 mov     [ebp+var_10E0], eax
.text$mn:000046E6                 cmp     [ebp+arg_0], 0
.text$mn:000046EA                 jnz     short loc_4703
.text$mn:000046EC                 mov     ecx, [ebp+var_10D0]
.text$mn:000046F2                 mov     ecx, [ecx+5D4h] ; this
.text$mn:000046F8                 call    ?getCurrentBufferID@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBufferID(void)
.text$mn:000046FD                 mov     [ebp+var_10E0], eax
.text$mn:00004703
.text$mn:00004703 loc_4703:                               ; CODE XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+42j
.text$mn:00004703                 mov     edx, [ebp+var_10E0]
.text$mn:00004709                 push    edx             ; struct Buffer *
.text$mn:0000470A                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:0000470F                 mov     ecx, eax        ; this
.text$mn:00004711                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00004716                 mov     [ebp+var_10E8], eax
.text$mn:0000471C                 mov     eax, [ebp+var_10D0]
.text$mn:00004722                 mov     ecx, [eax+4]    ; this
.text$mn:00004725                 call    ?getHinst@Window@@QBEPAUHINSTANCE__@@XZ ; Window::getHinst(void)
.text$mn:0000472A                 push    eax
.text$mn:0000472B                 mov     ecx, [ebp+var_10D0]
.text$mn:00004731                 mov     ecx, [ecx+4]    ; this
.text$mn:00004734                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00004739                 push    eax
.text$mn:0000473A                 lea     ecx, [ebp+var_10CC]
.text$mn:00004740                 call    ??0FileDialog@@QAE@PAUHWND__@@PAUHINSTANCE__@@@Z ; FileDialog::FileDialog(HWND__ *,HINSTANCE__ *)
.text$mn:00004745                 mov     [ebp+var_4], 0
.text$mn:0000474C                 push    0
.text$mn:0000474E                 push    offset $SG176934 ; ".*"
.text$mn:00004753                 push    offset $SG176935 ; "All types"
.text$mn:00004758                 lea     edx, [ebp+var_10CC]
.text$mn:0000475E                 push    edx             ; this
.text$mn:0000475F                 call    ?setExtFilter@FileDialog@@QAAXPB_W0ZZ ; FileDialog::setExtFilter(wchar_t const *,wchar_t const *,...)
.text$mn:00004764                 add     esp, 10h
.text$mn:00004767                 mov     ecx, [ebp+var_10E8]
.text$mn:0000476D                 call    ?getLangType@Buffer@@QBE?AW4LangType@@XZ ; Buffer::getLangType(void)
.text$mn:00004772                 push    eax             ; int
.text$mn:00004773                 lea     eax, [ebp+var_10CC]
.text$mn:00004779                 push    eax             ; struct FileDialog *
.text$mn:0000477A                 mov     ecx, [ebp+var_10D0] ; this
.text$mn:00004780                 call    ?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z ; Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)
.text$mn:00004785                 mov     [ebp+var_10F0], eax
.text$mn:0000478B                 mov     ecx, [ebp+var_10E8] ; this
.text$mn:00004791                 call    ?getFileName@Buffer@@QBEPB_WXZ ; Buffer::getFileName(void)
.text$mn:00004796                 push    eax             ; wchar_t *
.text$mn:00004797                 lea     ecx, [ebp+var_10CC] ; this
.text$mn:0000479D                 call    ?setDefFileName@FileDialog@@QAEXPB_W@Z ; FileDialog::setDefFileName(wchar_t const *)
.text$mn:000047A2                 mov     ecx, [ebp+var_10F0]
.text$mn:000047A8                 add     ecx, 1
.text$mn:000047AB                 push    ecx             ; int
.text$mn:000047AC                 lea     ecx, [ebp+var_10CC] ; this
.text$mn:000047B2                 call    ?setExtIndex@FileDialog@@QAEXH@Z ; FileDialog::setExtIndex(int)
.text$mn:000047B7                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000047BC                 mov     [ebp+var_10DC], eax
.text$mn:000047C2                 mov     ecx, [ebp+var_10DC] ; this
.text$mn:000047C8                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:000047CD                 mov     edx, [eax+1Ch]
.text$mn:000047D0                 mov     [ebp+var_10EC], edx
.text$mn:000047D6                 mov     ecx, [ebp+var_10DC] ; this
.text$mn:000047DC                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:000047E1                 mov     dword ptr [eax+1Ch], 0
.text$mn:000047E8                 lea     ecx, [ebp+var_10CC] ; this
.text$mn:000047EE                 call    ?doSaveDlg@FileDialog@@QAEPA_WXZ ; FileDialog::doSaveDlg(void)
.text$mn:000047F3                 mov     [ebp+var_10D8], eax
.text$mn:000047F9                 mov     ecx, [ebp+var_10DC] ; this
.text$mn:000047FF                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00004804                 mov     ecx, [ebp+var_10EC]
.text$mn:0000480A                 mov     [eax+1Ch], ecx
.text$mn:0000480D                 cmp     [ebp+var_10D8], 0
.text$mn:00004814                 jz      loc_48FA
.text$mn:0000481A                 mov     edx, [ebp+var_10D8]
.text$mn:00004820                 push    edx             ; wchar_t *
.text$mn:00004821                 mov     eax, [ebp+var_10D0]
.text$mn:00004827                 mov     ecx, [eax+460h] ; this
.text$mn:0000482D                 call    ?findBufferByName@DocTabView@@QAEPAVBuffer@@PB_W@Z ; DocTabView::findBufferByName(wchar_t const *)
.text$mn:00004832                 mov     [ebp+var_10E4], eax
.text$mn:00004838                 cmp     [ebp+var_10E4], 0
.text$mn:0000483F                 jnz     short loc_4890
.text$mn:00004841                 movzx   ecx, [ebp+arg_4]
.text$mn:00004845                 push    ecx             ; bool
.text$mn:00004846                 mov     edx, [ebp+var_10D8]
.text$mn:0000484C                 push    edx             ; wchar_t *
.text$mn:0000484D                 mov     eax, [ebp+var_10E0]
.text$mn:00004853                 push    eax             ; struct Buffer *
.text$mn:00004854                 mov     ecx, [ebp+var_10D0] ; this
.text$mn:0000485A                 call    ?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z ; Notepad_plus::doSave(Buffer *,wchar_t const *,bool)
.text$mn:0000485F                 mov     [ebp+var_10D4], al
.text$mn:00004865                 mov     cl, [ebp+var_10D4]
.text$mn:0000486B                 mov     [ebp+var_10D2], cl
.text$mn:00004871                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004878                 lea     ecx, [ebp+var_10CC] ; this
.text$mn:0000487E                 call    ??1FileDialog@@QAE@XZ ; FileDialog::~FileDialog(void)
.text$mn:00004883                 mov     al, [ebp+var_10D2]
.text$mn:00004889                 jmp     loc_4938
.text$mn:0000488E ; ---------------------------------------------------------------------------
.text$mn:0000488E                 jmp     short loc_48F8
.text$mn:00004890 ; ---------------------------------------------------------------------------
.text$mn:00004890
.text$mn:00004890 loc_4890:                               ; CODE XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+197j
.text$mn:00004890                 push    0               ; wchar_t *
.text$mn:00004892                 push    0               ; int
.text$mn:00004894                 push    10h             ; int
.text$mn:00004896                 push    offset $SG176950 ; "ERROR"
.text$mn:0000489B                 push    offset $SG176951 ; "The file is already opened in the Notep"...
.text$mn:000048A0                 mov     edx, [ebp+var_10D0]
.text$mn:000048A6                 mov     ecx, [edx+4]    ; this
.text$mn:000048A9                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000048AE                 push    eax             ; HWND
.text$mn:000048AF                 push    offset $SG176952 ; "FileAlreadyOpenedInNpp"
.text$mn:000048B4                 mov     ecx, [ebp+var_10D0]
.text$mn:000048BA                 add     ecx, 34Ch       ; this
.text$mn:000048C0                 call    ?messageBox@NativeLangSpeaker@@QAEHPBDPAUHWND__@@PB_W2HH2@Z ; NativeLangSpeaker::messageBox(char const *,HWND__ *,wchar_t const *,wchar_t const *,int,int,wchar_t const *)
.text$mn:000048C5                 mov     eax, [ebp+var_10E4]
.text$mn:000048CB                 push    eax             ; struct Buffer *
.text$mn:000048CC                 mov     ecx, [ebp+var_10D0] ; this
.text$mn:000048D2                 call    ?switchToFile@Notepad_plus@@QAE_NPAVBuffer@@@Z ; Notepad_plus::switchToFile(Buffer *)
.text$mn:000048D7                 mov     [ebp+var_10D1], 0
.text$mn:000048DE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000048E5                 lea     ecx, [ebp+var_10CC] ; this
.text$mn:000048EB                 call    ??1FileDialog@@QAE@XZ ; FileDialog::~FileDialog(void)
.text$mn:000048F0                 mov     al, [ebp+var_10D1]
.text$mn:000048F6                 jmp     short loc_4938
.text$mn:000048F8 ; ---------------------------------------------------------------------------
.text$mn:000048F8
.text$mn:000048F8 loc_48F8:                               ; CODE XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+1E6j
.text$mn:000048F8                 jmp     short loc_4926
.text$mn:000048FA ; ---------------------------------------------------------------------------
.text$mn:000048FA
.text$mn:000048FA loc_48FA:                               ; CODE XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+16Cj
.text$mn:000048FA                 mov     ecx, [ebp+var_10D0] ; this
.text$mn:00004900                 call    ?checkModifiedDocument@Notepad_plus@@AAEXXZ ; Notepad_plus::checkModifiedDocument(void)
.text$mn:00004905                 mov     [ebp+var_10D3], 0
.text$mn:0000490C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004913                 lea     ecx, [ebp+var_10CC] ; this
.text$mn:00004919                 call    ??1FileDialog@@QAE@XZ ; FileDialog::~FileDialog(void)
.text$mn:0000491E                 mov     al, [ebp+var_10D3]
.text$mn:00004924                 jmp     short loc_4938
.text$mn:00004926 ; ---------------------------------------------------------------------------
.text$mn:00004926
.text$mn:00004926 loc_4926:                               ; CODE XREF: Notepad_plus::fileSaveAs(Buffer *,bool):loc_48F8j
.text$mn:00004926                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000492D                 lea     ecx, [ebp+var_10CC] ; this
.text$mn:00004933                 call    ??1FileDialog@@QAE@XZ ; FileDialog::~FileDialog(void)
.text$mn:00004938
.text$mn:00004938 loc_4938:                               ; CODE XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+1E1j
.text$mn:00004938                                         ; Notepad_plus::fileSaveAs(Buffer *,bool)+24Ej ...
.text$mn:00004938                 mov     ecx, [ebp+var_C]
.text$mn:0000493B                 mov     large fs:0, ecx
.text$mn:00004942                 pop     ecx
.text$mn:00004943                 mov     ecx, [ebp+var_10]
.text$mn:00004946                 xor     ecx, ebp
.text$mn:00004948                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000494D                 mov     esp, ebp
.text$mn:0000494F                 pop     ebp
.text$mn:00004950                 retn    8
.text$mn:00004950 ?fileSaveAs@Notepad_plus@@QAE_NPAVBuffer@@_N@Z endp
.text$mn:00004950
.text$mn:00004950 ; ---------------------------------------------------------------------------
.text$mn:00004953                 align 8
.text$mn:00004958
.text$mn:00004958 ; =============== S U B R O U T I N E =======================================
.text$mn:00004958
.text$mn:00004958 ; Attributes: bp-based frame
.text$mn:00004958
.text$mn:00004958 ; bool __thiscall Notepad_plus::fileDelete(Notepad_plus *this, struct Buffer *)
.text$mn:00004958                 public ?fileDelete@Notepad_plus@@QAE_NPAVBuffer@@@Z
.text$mn:00004958 ?fileDelete@Notepad_plus@@QAE_NPAVBuffer@@@Z proc near
.text$mn:00004958
.text$mn:00004958 var_78          = dword ptr -78h
.text$mn:00004958 var_74          = dword ptr -74h
.text$mn:00004958 var_70          = dword ptr -70h
.text$mn:00004958 var_1C          = dword ptr -1Ch
.text$mn:00004958 var_18          = dword ptr -18h
.text$mn:00004958 var_14          = dword ptr -14h
.text$mn:00004958 var_10          = dword ptr -10h
.text$mn:00004958 var_C           = dword ptr -0Ch
.text$mn:00004958 var_8           = dword ptr -8
.text$mn:00004958 var_2           = byte ptr -2
.text$mn:00004958 var_1           = byte ptr -1
.text$mn:00004958 arg_0           = dword ptr  8
.text$mn:00004958
.text$mn:00004958                 push    ebp
.text$mn:00004959                 mov     ebp, esp
.text$mn:0000495B                 sub     esp, 78h
.text$mn:0000495E                 mov     [ebp+var_8], ecx
.text$mn:00004961                 mov     eax, [ebp+arg_0]
.text$mn:00004964                 mov     [ebp+var_C], eax
.text$mn:00004967                 cmp     [ebp+arg_0], 0
.text$mn:0000496B                 jnz     short loc_497E
.text$mn:0000496D                 mov     ecx, [ebp+var_8]
.text$mn:00004970                 mov     ecx, [ecx+5D4h] ; this
.text$mn:00004976                 call    ?getCurrentBufferID@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBufferID(void)
.text$mn:0000497B                 mov     [ebp+var_C], eax
.text$mn:0000497E
.text$mn:0000497E loc_497E:                               ; CODE XREF: Notepad_plus::fileDelete(Buffer *)+13j
.text$mn:0000497E                 mov     edx, [ebp+var_C]
.text$mn:00004981                 push    edx             ; struct Buffer *
.text$mn:00004982                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00004987                 mov     ecx, eax        ; this
.text$mn:00004989                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:0000498E                 mov     [ebp+var_18], eax
.text$mn:00004991                 mov     ecx, [ebp+var_18] ; this
.text$mn:00004994                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00004999                 mov     [ebp+var_1C], eax
.text$mn:0000499C                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000049A1                 mov     ecx, eax
.text$mn:000049A3                 call    ?getWinVersion@NppParameters@@QAE?AW4winVer@@XZ ; NppParameters::getWinVersion(void)
.text$mn:000049A8                 mov     [ebp+var_10], eax
.text$mn:000049AB                 mov     [ebp+var_1], 1
.text$mn:000049AF                 cmp     [ebp+var_10], 0Ch
.text$mn:000049B3                 jge     short loc_49BB
.text$mn:000049B5                 cmp     [ebp+var_10], 0
.text$mn:000049B9                 jnz     short loc_49E2
.text$mn:000049BB
.text$mn:000049BB loc_49BB:                               ; CODE XREF: Notepad_plus::fileDelete(Buffer *)+5Bj
.text$mn:000049BB                 mov     eax, [ebp+var_1C]
.text$mn:000049BE                 push    eax             ; wchar_t *
.text$mn:000049BF                 mov     ecx, [ebp+var_8] ; this
.text$mn:000049C2                 call    ?doDeleteOrNot@Notepad_plus@@AAEHPB_W@Z ; Notepad_plus::doDeleteOrNot(wchar_t const *)
.text$mn:000049C7                 cmp     eax, 6
.text$mn:000049CA                 jnz     short loc_49D5
.text$mn:000049CC                 mov     [ebp+var_14], 1
.text$mn:000049D3                 jmp     short loc_49DC
.text$mn:000049D5 ; ---------------------------------------------------------------------------
.text$mn:000049D5
.text$mn:000049D5 loc_49D5:                               ; CODE XREF: Notepad_plus::fileDelete(Buffer *)+72j
.text$mn:000049D5                 mov     [ebp+var_14], 0
.text$mn:000049DC
.text$mn:000049DC loc_49DC:                               ; CODE XREF: Notepad_plus::fileDelete(Buffer *)+7Bj
.text$mn:000049DC                 mov     cl, byte ptr [ebp+var_14]
.text$mn:000049DF                 mov     [ebp+var_1], cl
.text$mn:000049E2
.text$mn:000049E2 loc_49E2:                               ; CODE XREF: Notepad_plus::fileDelete(Buffer *)+61j
.text$mn:000049E2                 movzx   edx, [ebp+var_1]
.text$mn:000049E6                 test    edx, edx
.text$mn:000049E8                 jz      loc_4ADE
.text$mn:000049EE                 mov     [ebp+var_70], 400h
.text$mn:000049F5                 mov     eax, [ebp+var_8]
.text$mn:000049F8                 mov     ecx, [eax+4]    ; this
.text$mn:000049FB                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00004A00                 mov     [ebp+var_78], eax
.text$mn:00004A03                 mov     ecx, [ebp+var_C]
.text$mn:00004A06                 mov     [ebp+var_74], ecx
.text$mn:00004A09                 lea     edx, [ebp+var_78]
.text$mn:00004A0C                 push    edx             ; struct SCNotification *
.text$mn:00004A0D                 mov     ecx, [ebp+var_8]
.text$mn:00004A10                 add     ecx, 54BCCh     ; this
.text$mn:00004A16                 call    ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z ; PluginsManager::notify(SCNotification const *)
.text$mn:00004A1B                 mov     eax, [ebp+var_C]
.text$mn:00004A1E                 push    eax             ; struct Buffer *
.text$mn:00004A1F                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00004A24                 mov     ecx, eax        ; this
.text$mn:00004A26                 call    ?deleteFile@FileManager@@QAE_NPAVBuffer@@@Z ; FileManager::deleteFile(Buffer *)
.text$mn:00004A2B                 movzx   ecx, al
.text$mn:00004A2E                 test    ecx, ecx
.text$mn:00004A30                 jnz     short loc_4A7E
.text$mn:00004A32                 push    0               ; wchar_t *
.text$mn:00004A34                 push    0               ; int
.text$mn:00004A36                 push    0               ; int
.text$mn:00004A38                 push    offset $SG177022 ; "Delete File"
.text$mn:00004A3D                 push    offset $SG177023 ; "Delete File failed"
.text$mn:00004A42                 mov     edx, [ebp+var_8]
.text$mn:00004A45                 mov     ecx, [edx+4]    ; this
.text$mn:00004A48                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00004A4D                 push    eax             ; HWND
.text$mn:00004A4E                 push    offset $SG177024 ; "DeleteFileFailed"
.text$mn:00004A53                 mov     ecx, [ebp+var_8]
.text$mn:00004A56                 add     ecx, 34Ch       ; this
.text$mn:00004A5C                 call    ?messageBox@NativeLangSpeaker@@QAEHPBDPAUHWND__@@PB_W2HH2@Z ; NativeLangSpeaker::messageBox(char const *,HWND__ *,wchar_t const *,wchar_t const *,int,int,wchar_t const *)
.text$mn:00004A61                 mov     [ebp+var_70], 401h
.text$mn:00004A68                 lea     eax, [ebp+var_78]
.text$mn:00004A6B                 push    eax             ; struct SCNotification *
.text$mn:00004A6C                 mov     ecx, [ebp+var_8]
.text$mn:00004A6F                 add     ecx, 54BCCh     ; this
.text$mn:00004A75                 call    ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z ; PluginsManager::notify(SCNotification const *)
.text$mn:00004A7A                 xor     al, al
.text$mn:00004A7C                 jmp     short loc_4AE0
.text$mn:00004A7E ; ---------------------------------------------------------------------------
.text$mn:00004A7E
.text$mn:00004A7E loc_4A7E:                               ; CODE XREF: Notepad_plus::fileDelete(Buffer *)+D8j
.text$mn:00004A7E                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00004A83                 mov     ecx, eax        ; this
.text$mn:00004A85                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00004A8A                 mov     ecx, eax        ; this
.text$mn:00004A8C                 call    ?isSnapshotMode@NppGUI@@QBE_NXZ ; NppGUI::isSnapshotMode(void)
.text$mn:00004A91                 mov     [ebp+var_2], al
.text$mn:00004A94                 movzx   ecx, [ebp+var_2]
.text$mn:00004A98                 push    ecx             ; bool
.text$mn:00004A99                 push    0               ; lParam
.text$mn:00004A9B                 mov     edx, [ebp+var_C]
.text$mn:00004A9E                 push    edx             ; struct Buffer *
.text$mn:00004A9F                 mov     ecx, [ebp+var_8] ; this
.text$mn:00004AA2                 call    ?doClose@Notepad_plus@@QAEXPAVBuffer@@H_N@Z ; Notepad_plus::doClose(Buffer *,int,bool)
.text$mn:00004AA7                 movzx   eax, [ebp+var_2]
.text$mn:00004AAB                 push    eax             ; bool
.text$mn:00004AAC                 push    1               ; lParam
.text$mn:00004AAE                 mov     ecx, [ebp+var_C]
.text$mn:00004AB1                 push    ecx             ; struct Buffer *
.text$mn:00004AB2                 mov     ecx, [ebp+var_8] ; this
.text$mn:00004AB5                 call    ?doClose@Notepad_plus@@QAEXPAVBuffer@@H_N@Z ; Notepad_plus::doClose(Buffer *,int,bool)
.text$mn:00004ABA                 mov     [ebp+var_70], 402h
.text$mn:00004AC1                 mov     [ebp+var_74], 0FFFFFFFFh
.text$mn:00004AC8                 lea     edx, [ebp+var_78]
.text$mn:00004ACB                 push    edx             ; struct SCNotification *
.text$mn:00004ACC                 mov     ecx, [ebp+var_8]
.text$mn:00004ACF                 add     ecx, 54BCCh     ; this
.text$mn:00004AD5                 call    ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z ; PluginsManager::notify(SCNotification const *)
.text$mn:00004ADA                 mov     al, 1
.text$mn:00004ADC                 jmp     short loc_4AE0
.text$mn:00004ADE ; ---------------------------------------------------------------------------
.text$mn:00004ADE
.text$mn:00004ADE loc_4ADE:                               ; CODE XREF: Notepad_plus::fileDelete(Buffer *)+90j
.text$mn:00004ADE                 xor     al, al
.text$mn:00004AE0
.text$mn:00004AE0 loc_4AE0:                               ; CODE XREF: Notepad_plus::fileDelete(Buffer *)+124j
.text$mn:00004AE0                                         ; Notepad_plus::fileDelete(Buffer *)+184j
.text$mn:00004AE0                 mov     esp, ebp
.text$mn:00004AE2                 pop     ebp
.text$mn:00004AE3                 retn    4
.text$mn:00004AE3 ?fileDelete@Notepad_plus@@QAE_NPAVBuffer@@@Z endp
.text$mn:00004AE3
.text$mn:00004AE3 ; ---------------------------------------------------------------------------
.text$mn:00004AE6                 align 4
.text$mn:00004AE8
.text$mn:00004AE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AE8
.text$mn:00004AE8 ; Attributes: bp-based frame
.text$mn:00004AE8
.text$mn:00004AE8 ; bool __thiscall Notepad_plus::fileRename(Notepad_plus *this, struct Buffer *)
.text$mn:00004AE8                 public ?fileRename@Notepad_plus@@QAE_NPAVBuffer@@@Z
.text$mn:00004AE8 ?fileRename@Notepad_plus@@QAE_NPAVBuffer@@@Z proc near
.text$mn:00004AE8
.text$mn:00004AE8 var_1144        = dword ptr -1144h
.text$mn:00004AE8 var_1140        = dword ptr -1140h
.text$mn:00004AE8 var_113C        = dword ptr -113Ch
.text$mn:00004AE8 var_10E8        = dword ptr -10E8h
.text$mn:00004AE8 var_10E4        = dword ptr -10E4h
.text$mn:00004AE8 var_10E0        = dword ptr -10E0h
.text$mn:00004AE8 var_10DC        = dword ptr -10DCh
.text$mn:00004AE8 var_10D5        = byte ptr -10D5h
.text$mn:00004AE8 var_10D4        = dword ptr -10D4h
.text$mn:00004AE8 var_10CD        = byte ptr -10CDh
.text$mn:00004AE8 var_10CC        = byte ptr -10CCh
.text$mn:00004AE8 var_10          = dword ptr -10h
.text$mn:00004AE8 var_C           = dword ptr -0Ch
.text$mn:00004AE8 var_4           = dword ptr -4
.text$mn:00004AE8 arg_0           = dword ptr  8
.text$mn:00004AE8
.text$mn:00004AE8                 push    ebp
.text$mn:00004AE9                 mov     ebp, esp
.text$mn:00004AEB                 push    0FFFFFFFFh
.text$mn:00004AED                 push    offset __ehhandler$?fileRename@Notepad_plus@@QAE_NPAVBuffer@@@Z
.text$mn:00004AF2                 mov     eax, large fs:0
.text$mn:00004AF8                 push    eax
.text$mn:00004AF9                 mov     eax, 1138h
.text$mn:00004AFE                 call    __chkstk
.text$mn:00004B03                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004B08                 xor     eax, ebp
.text$mn:00004B0A                 mov     [ebp+var_10], eax
.text$mn:00004B0D                 push    eax
.text$mn:00004B0E                 lea     eax, [ebp+var_C]
.text$mn:00004B11                 mov     large fs:0, eax
.text$mn:00004B17                 mov     [ebp+var_10D4], ecx
.text$mn:00004B1D                 mov     eax, [ebp+arg_0]
.text$mn:00004B20                 mov     [ebp+var_10DC], eax
.text$mn:00004B26                 cmp     [ebp+arg_0], 0
.text$mn:00004B2A                 jnz     short loc_4B43
.text$mn:00004B2C                 mov     ecx, [ebp+var_10D4]
.text$mn:00004B32                 mov     ecx, [ecx+5D4h] ; this
.text$mn:00004B38                 call    ?getCurrentBufferID@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBufferID(void)
.text$mn:00004B3D                 mov     [ebp+var_10DC], eax
.text$mn:00004B43
.text$mn:00004B43 loc_4B43:                               ; CODE XREF: Notepad_plus::fileRename(Buffer *)+42j
.text$mn:00004B43                 mov     edx, [ebp+var_10DC]
.text$mn:00004B49                 push    edx             ; struct Buffer *
.text$mn:00004B4A                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00004B4F                 mov     ecx, eax        ; this
.text$mn:00004B51                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00004B56                 mov     [ebp+var_10E8], eax
.text$mn:00004B5C                 mov     [ebp+var_113C], 3FDh
.text$mn:00004B66                 mov     eax, [ebp+var_10D4]
.text$mn:00004B6C                 mov     ecx, [eax+4]    ; this
.text$mn:00004B6F                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00004B74                 mov     [ebp+var_1144], eax
.text$mn:00004B7A                 mov     ecx, [ebp+var_10DC]
.text$mn:00004B80                 mov     [ebp+var_1140], ecx
.text$mn:00004B86                 lea     edx, [ebp+var_1144]
.text$mn:00004B8C                 push    edx             ; struct SCNotification *
.text$mn:00004B8D                 mov     ecx, [ebp+var_10D4]
.text$mn:00004B93                 add     ecx, 54BCCh     ; this
.text$mn:00004B99                 call    ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z ; PluginsManager::notify(SCNotification const *)
.text$mn:00004B9E                 mov     eax, [ebp+var_10D4]
.text$mn:00004BA4                 mov     ecx, [eax+4]    ; this
.text$mn:00004BA7                 call    ?getHinst@Window@@QBEPAUHINSTANCE__@@XZ ; Window::getHinst(void)
.text$mn:00004BAC                 push    eax
.text$mn:00004BAD                 mov     ecx, [ebp+var_10D4]
.text$mn:00004BB3                 mov     ecx, [ecx+4]    ; this
.text$mn:00004BB6                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00004BBB                 push    eax
.text$mn:00004BBC                 lea     ecx, [ebp+var_10CC]
.text$mn:00004BC2                 call    ??0FileDialog@@QAE@PAUHWND__@@PAUHINSTANCE__@@@Z ; FileDialog::FileDialog(HWND__ *,HINSTANCE__ *)
.text$mn:00004BC7                 mov     [ebp+var_4], 0
.text$mn:00004BCE                 push    0
.text$mn:00004BD0                 push    offset $SG176967 ; ".*"
.text$mn:00004BD5                 push    offset $SG176968 ; "All types"
.text$mn:00004BDA                 lea     edx, [ebp+var_10CC]
.text$mn:00004BE0                 push    edx             ; this
.text$mn:00004BE1                 call    ?setExtFilter@FileDialog@@QAAXPB_W0ZZ ; FileDialog::setExtFilter(wchar_t const *,wchar_t const *,...)
.text$mn:00004BE6                 add     esp, 10h
.text$mn:00004BE9                 push    0FFFFFFFFh      ; int
.text$mn:00004BEB                 lea     eax, [ebp+var_10CC]
.text$mn:00004BF1                 push    eax             ; struct FileDialog *
.text$mn:00004BF2                 mov     ecx, [ebp+var_10D4] ; this
.text$mn:00004BF8                 call    ?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z ; Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)
.text$mn:00004BFD                 mov     ecx, [ebp+var_10E8] ; this
.text$mn:00004C03                 call    ?getFileName@Buffer@@QBEPB_WXZ ; Buffer::getFileName(void)
.text$mn:00004C08                 push    eax             ; wchar_t *
.text$mn:00004C09                 lea     ecx, [ebp+var_10CC] ; this
.text$mn:00004C0F                 call    ?setDefFileName@FileDialog@@QAEXPB_W@Z ; FileDialog::setDefFileName(wchar_t const *)
.text$mn:00004C14                 lea     ecx, [ebp+var_10CC] ; this
.text$mn:00004C1A                 call    ?doSaveDlg@FileDialog@@QAEPA_WXZ ; FileDialog::doSaveDlg(void)
.text$mn:00004C1F                 mov     [ebp+var_10E0], eax
.text$mn:00004C25                 mov     [ebp+var_10CD], 0
.text$mn:00004C2C                 cmp     [ebp+var_10E0], 0
.text$mn:00004C33                 jz      short loc_4C55
.text$mn:00004C35                 mov     ecx, [ebp+var_10E0]
.text$mn:00004C3B                 push    ecx             ; wchar_t *
.text$mn:00004C3C                 mov     edx, [ebp+var_10DC]
.text$mn:00004C42                 push    edx             ; struct Buffer *
.text$mn:00004C43                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00004C48                 mov     ecx, eax        ; this
.text$mn:00004C4A                 call    ?moveFile@FileManager@@QAE_NPAVBuffer@@PB_W@Z ; FileManager::moveFile(Buffer *,wchar_t const *)
.text$mn:00004C4F                 mov     [ebp+var_10CD], al
.text$mn:00004C55
.text$mn:00004C55 loc_4C55:                               ; CODE XREF: Notepad_plus::fileRename(Buffer *)+14Bj
.text$mn:00004C55                 movzx   eax, [ebp+var_10CD]
.text$mn:00004C5C                 test    eax, eax
.text$mn:00004C5E                 jz      short loc_4C6C
.text$mn:00004C60                 mov     [ebp+var_10E4], 3FFh
.text$mn:00004C6A                 jmp     short loc_4C76
.text$mn:00004C6C ; ---------------------------------------------------------------------------
.text$mn:00004C6C
.text$mn:00004C6C loc_4C6C:                               ; CODE XREF: Notepad_plus::fileRename(Buffer *)+176j
.text$mn:00004C6C                 mov     [ebp+var_10E4], 3FEh
.text$mn:00004C76
.text$mn:00004C76 loc_4C76:                               ; CODE XREF: Notepad_plus::fileRename(Buffer *)+182j
.text$mn:00004C76                 mov     ecx, [ebp+var_10E4]
.text$mn:00004C7C                 mov     [ebp+var_113C], ecx
.text$mn:00004C82                 lea     edx, [ebp+var_1144]
.text$mn:00004C88                 push    edx             ; struct SCNotification *
.text$mn:00004C89                 mov     ecx, [ebp+var_10D4]
.text$mn:00004C8F                 add     ecx, 54BCCh     ; this
.text$mn:00004C95                 call    ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z ; PluginsManager::notify(SCNotification const *)
.text$mn:00004C9A                 mov     al, [ebp+var_10CD]
.text$mn:00004CA0                 mov     [ebp+var_10D5], al
.text$mn:00004CA6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004CAD                 lea     ecx, [ebp+var_10CC] ; this
.text$mn:00004CB3                 call    ??1FileDialog@@QAE@XZ ; FileDialog::~FileDialog(void)
.text$mn:00004CB8                 mov     al, [ebp+var_10D5]
.text$mn:00004CBE                 mov     ecx, [ebp+var_C]
.text$mn:00004CC1                 mov     large fs:0, ecx
.text$mn:00004CC8                 pop     ecx
.text$mn:00004CC9                 mov     ecx, [ebp+var_10]
.text$mn:00004CCC                 xor     ecx, ebp
.text$mn:00004CCE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00004CD3                 mov     esp, ebp
.text$mn:00004CD5                 pop     ebp
.text$mn:00004CD6                 retn    4
.text$mn:00004CD6 ?fileRename@Notepad_plus@@QAE_NPAVBuffer@@@Z endp
.text$mn:00004CD6
.text$mn:00004CD6 ; ---------------------------------------------------------------------------
.text$mn:00004CD9                 db 0Fh dup(0CCh)
.text$mn:00004CE8
.text$mn:00004CE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CE8
.text$mn:00004CE8 ; Attributes: bp-based frame
.text$mn:00004CE8
.text$mn:00004CE8 ; bool __thiscall Notepad_plus::isFileSession(Notepad_plus *this, const wchar_t *)
.text$mn:00004CE8                 public ?isFileSession@Notepad_plus@@QAE_NPB_W@Z
.text$mn:00004CE8 ?isFileSession@Notepad_plus@@QAE_NPB_W@Z proc near
.text$mn:00004CE8                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+28Ep
.text$mn:00004CE8                                         ; Notepad_plus::loadSession(Session &,bool)+94p ...
.text$mn:00004CE8
.text$mn:00004CE8 var_58          = dword ptr -58h
.text$mn:00004CE8 Str1            = dword ptr -54h
.text$mn:00004CE8 var_50          = dword ptr -50h
.text$mn:00004CE8 var_49          = byte ptr -49h
.text$mn:00004CE8 var_48          = byte ptr -48h
.text$mn:00004CE8 var_2C          = byte ptr -2Ch
.text$mn:00004CE8 var_10          = dword ptr -10h
.text$mn:00004CE8 var_C           = dword ptr -0Ch
.text$mn:00004CE8 var_4           = dword ptr -4
.text$mn:00004CE8 Str             = dword ptr  8
.text$mn:00004CE8
.text$mn:00004CE8                 push    ebp
.text$mn:00004CE9                 mov     ebp, esp
.text$mn:00004CEB                 push    0FFFFFFFFh
.text$mn:00004CED                 push    offset __ehhandler$?isFileSession@Notepad_plus@@QAE_NPB_W@Z
.text$mn:00004CF2                 mov     eax, large fs:0
.text$mn:00004CF8                 push    eax
.text$mn:00004CF9                 sub     esp, 4Ch
.text$mn:00004CFC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004D01                 xor     eax, ebp
.text$mn:00004D03                 mov     [ebp+var_10], eax
.text$mn:00004D06                 push    eax
.text$mn:00004D07                 lea     eax, [ebp+var_C]
.text$mn:00004D0A                 mov     large fs:0, eax
.text$mn:00004D10                 mov     [ebp+var_58], ecx
.text$mn:00004D13                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00004D18                 mov     ecx, eax        ; this
.text$mn:00004D1A                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00004D1F                 add     eax, 220h
.text$mn:00004D24                 mov     ecx, eax
.text$mn:00004D26                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00004D2B                 mov     [ebp+var_50], eax
.text$mn:00004D2E                 mov     eax, [ebp+var_50]
.text$mn:00004D31                 movzx   ecx, word ptr [eax]
.text$mn:00004D34                 test    ecx, ecx
.text$mn:00004D36                 jz      loc_4DEE
.text$mn:00004D3C                 mov     edx, [ebp+Str]
.text$mn:00004D3F                 push    edx             ; Str
.text$mn:00004D40                 lea     ecx, [ebp+var_48]
.text$mn:00004D43                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00004D48                 mov     [ebp+var_4], 0
.text$mn:00004D4F                 lea     ecx, [ebp+var_48]
.text$mn:00004D52                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00004D57                 push    eax             ; pszPath
.text$mn:00004D58                 call    dword ptr ds:__imp__PathFindExtensionW@4 ; PathFindExtensionW(x)
.text$mn:00004D5E                 mov     [ebp+Str1], eax
.text$mn:00004D61                 push    offset $SG177060 ; Str
.text$mn:00004D66                 lea     ecx, [ebp+var_2C]
.text$mn:00004D69                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00004D6E                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004D72                 mov     eax, [ebp+var_50]
.text$mn:00004D75                 movzx   ecx, word ptr [eax]
.text$mn:00004D78                 cmp     ecx, 2Eh ; '.'
.text$mn:00004D7B                 jz      short loc_4D8A
.text$mn:00004D7D                 push    offset $SG177062 ; Str
.text$mn:00004D82                 lea     ecx, [ebp+var_2C]
.text$mn:00004D85                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00004D8A
.text$mn:00004D8A loc_4D8A:                               ; CODE XREF: Notepad_plus::isFileSession(wchar_t const *)+93j
.text$mn:00004D8A                 mov     edx, [ebp+var_50]
.text$mn:00004D8D                 push    edx             ; Str
.text$mn:00004D8E                 lea     ecx, [ebp+var_2C]
.text$mn:00004D91                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00004D96                 lea     ecx, [ebp+var_2C]
.text$mn:00004D99                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00004D9E                 push    eax             ; Str2
.text$mn:00004D9F                 mov     eax, [ebp+Str1]
.text$mn:00004DA2                 push    eax             ; Str1
.text$mn:00004DA3                 call    _wcsicmp
.text$mn:00004DA8                 add     esp, 8
.text$mn:00004DAB                 test    eax, eax
.text$mn:00004DAD                 jnz     short loc_4DD3
.text$mn:00004DAF                 mov     [ebp+var_49], 1
.text$mn:00004DB3                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004DB7                 lea     ecx, [ebp+var_2C]
.text$mn:00004DBA                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00004DBF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004DC6                 lea     ecx, [ebp+var_48]
.text$mn:00004DC9                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00004DCE                 mov     al, [ebp+var_49]
.text$mn:00004DD1                 jmp     short loc_4DF0
.text$mn:00004DD3 ; ---------------------------------------------------------------------------
.text$mn:00004DD3
.text$mn:00004DD3 loc_4DD3:                               ; CODE XREF: Notepad_plus::isFileSession(wchar_t const *)+C5j
.text$mn:00004DD3                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004DD7                 lea     ecx, [ebp+var_2C]
.text$mn:00004DDA                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00004DDF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004DE6                 lea     ecx, [ebp+var_48]
.text$mn:00004DE9                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00004DEE
.text$mn:00004DEE loc_4DEE:                               ; CODE XREF: Notepad_plus::isFileSession(wchar_t const *)+4Ej
.text$mn:00004DEE                 xor     al, al
.text$mn:00004DF0
.text$mn:00004DF0 loc_4DF0:                               ; CODE XREF: Notepad_plus::isFileSession(wchar_t const *)+E9j
.text$mn:00004DF0                 mov     ecx, [ebp+var_C]
.text$mn:00004DF3                 mov     large fs:0, ecx
.text$mn:00004DFA                 pop     ecx
.text$mn:00004DFB                 mov     ecx, [ebp+var_10]
.text$mn:00004DFE                 xor     ecx, ebp
.text$mn:00004E00                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00004E05                 mov     esp, ebp
.text$mn:00004E07                 pop     ebp
.text$mn:00004E08                 retn    4
.text$mn:00004E08 ?isFileSession@Notepad_plus@@QAE_NPB_W@Z endp
.text$mn:00004E08
.text$mn:00004E08 ; ---------------------------------------------------------------------------
.text$mn:00004E0B                 db 0Dh dup(0CCh)
.text$mn:00004E18
.text$mn:00004E18 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E18
.text$mn:00004E18 ; Attributes: bp-based frame
.text$mn:00004E18
.text$mn:00004E18 ; void __thiscall Notepad_plus::saveSession(Notepad_plus *this, const struct Session *)
.text$mn:00004E18                 public ?saveSession@Notepad_plus@@QAEXABUSession@@@Z
.text$mn:00004E18 ?saveSession@Notepad_plus@@QAEXABUSession@@@Z proc near
.text$mn:00004E18
.text$mn:00004E18 var_4           = dword ptr -4
.text$mn:00004E18 arg_0           = dword ptr  8
.text$mn:00004E18
.text$mn:00004E18                 push    ebp
.text$mn:00004E19                 mov     ebp, esp
.text$mn:00004E1B                 push    ecx
.text$mn:00004E1C                 mov     [ebp+var_4], ecx
.text$mn:00004E1F                 push    0               ; wchar_t *
.text$mn:00004E21                 mov     eax, [ebp+arg_0]
.text$mn:00004E24                 push    eax             ; struct Session *
.text$mn:00004E25                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00004E2A                 mov     ecx, eax        ; this
.text$mn:00004E2C                 call    ?writeSession@NppParameters@@QAEXABUSession@@PB_W@Z ; NppParameters::writeSession(Session const &,wchar_t const *)
.text$mn:00004E31                 mov     esp, ebp
.text$mn:00004E33                 pop     ebp
.text$mn:00004E34                 retn    4
.text$mn:00004E34 ?saveSession@Notepad_plus@@QAEXABUSession@@@Z endp
.text$mn:00004E34
.text$mn:00004E34 ; ---------------------------------------------------------------------------
.text$mn:00004E37                 align 4
.text$mn:00004E38
.text$mn:00004E38 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E38
.text$mn:00004E38 ; Attributes: bp-based frame
.text$mn:00004E38
.text$mn:00004E38 ; void __thiscall Notepad_plus::saveCurrentSession(Notepad_plus *__hidden this)
.text$mn:00004E38                 public ?saveCurrentSession@Notepad_plus@@QAEXXZ
.text$mn:00004E38 ?saveCurrentSession@Notepad_plus@@QAEXXZ proc near
.text$mn:00004E38
.text$mn:00004E38 var_4           = dword ptr -4
.text$mn:00004E38
.text$mn:00004E38                 push    ebp
.text$mn:00004E39                 mov     ebp, esp
.text$mn:00004E3B                 push    ecx
.text$mn:00004E3C                 mov     [ebp+var_4], ecx
.text$mn:00004E3F                 push    0               ; lParam
.text$mn:00004E41                 push    0               ; wParam
.text$mn:00004E43                 push    427h            ; Msg
.text$mn:00004E48                 mov     eax, [ebp+var_4]
.text$mn:00004E4B                 mov     ecx, [eax+4]    ; this
.text$mn:00004E4E                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00004E53                 push    eax             ; hWnd
.text$mn:00004E54                 call    dword ptr ds:__imp__PostMessageW@16 ; PostMessageW(x,x,x,x)
.text$mn:00004E5A                 mov     esp, ebp
.text$mn:00004E5C                 pop     ebp
.text$mn:00004E5D                 retn
.text$mn:00004E5D ?saveCurrentSession@Notepad_plus@@QAEXXZ endp
.text$mn:00004E5D
.text$mn:00004E5D ; ---------------------------------------------------------------------------
.text$mn:00004E5E                 db 0Ah dup(0CCh)
.text$mn:00004E68
.text$mn:00004E68 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E68
.text$mn:00004E68 ; Attributes: bp-based frame
.text$mn:00004E68
.text$mn:00004E68 ; bool __thiscall Notepad_plus::fileLoadSession(Notepad_plus *this, const wchar_t *)
.text$mn:00004E68                 public ?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z
.text$mn:00004E68 ?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z proc near
.text$mn:00004E68                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+2B8p
.text$mn:00004E68
.text$mn:00004E68 var_135C        = byte ptr -135Ch
.text$mn:00004E68 var_1330        = dword ptr -1330h
.text$mn:00004E68 var_132C        = dword ptr -132Ch
.text$mn:00004E68 var_1328        = dword ptr -1328h
.text$mn:00004E68 var_1324        = dword ptr -1324h
.text$mn:00004E68 var_1320        = dword ptr -1320h
.text$mn:00004E68 Str             = dword ptr -131Ch
.text$mn:00004E68 var_1318        = dword ptr -1318h
.text$mn:00004E68 var_1314        = dword ptr -1314h
.text$mn:00004E68 var_130F        = byte ptr -130Fh
.text$mn:00004E68 var_130E        = byte ptr -130Eh
.text$mn:00004E68 var_130D        = byte ptr -130Dh
.text$mn:00004E68 var_130C        = byte ptr -130Ch
.text$mn:00004E68 var_250         = byte ptr -250h
.text$mn:00004E68 var_234         = byte ptr -234h
.text$mn:00004E68 Filename        = word ptr -218h
.text$mn:00004E68 var_10          = dword ptr -10h
.text$mn:00004E68 var_C           = dword ptr -0Ch
.text$mn:00004E68 var_4           = dword ptr -4
.text$mn:00004E68 pszPath         = dword ptr  8
.text$mn:00004E68
.text$mn:00004E68                 push    ebp
.text$mn:00004E69                 mov     ebp, esp
.text$mn:00004E6B                 push    0FFFFFFFFh
.text$mn:00004E6D                 push    offset __ehhandler$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z
.text$mn:00004E72                 mov     eax, large fs:0
.text$mn:00004E78                 push    eax
.text$mn:00004E79                 mov     eax, 1350h
.text$mn:00004E7E                 call    __chkstk
.text$mn:00004E83                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004E88                 xor     eax, ebp
.text$mn:00004E8A                 mov     [ebp+var_10], eax
.text$mn:00004E8D                 push    eax
.text$mn:00004E8E                 lea     eax, [ebp+var_C]
.text$mn:00004E91                 mov     large fs:0, eax
.text$mn:00004E97                 mov     [ebp+var_1314], ecx
.text$mn:00004E9D                 mov     [ebp+var_130F], 0
.text$mn:00004EA4                 mov     [ebp+var_1318], 0
.text$mn:00004EAE                 cmp     [ebp+pszPath], 0
.text$mn:00004EB2                 jnz     loc_4FC8
.text$mn:00004EB8                 mov     eax, [ebp+var_1314]
.text$mn:00004EBE                 mov     ecx, [eax+4]    ; this
.text$mn:00004EC1                 call    ?getHinst@Window@@QBEPAUHINSTANCE__@@XZ ; Window::getHinst(void)
.text$mn:00004EC6                 push    eax
.text$mn:00004EC7                 mov     ecx, [ebp+var_1314]
.text$mn:00004ECD                 mov     ecx, [ecx+4]    ; this
.text$mn:00004ED0                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00004ED5                 push    eax
.text$mn:00004ED6                 lea     ecx, [ebp+var_130C]
.text$mn:00004EDC                 call    ??0FileDialog@@QAE@PAUHWND__@@PAUHINSTANCE__@@@Z ; FileDialog::FileDialog(HWND__ *,HINSTANCE__ *)
.text$mn:00004EE1                 mov     [ebp+var_4], 0
.text$mn:00004EE8                 push    0
.text$mn:00004EEA                 push    offset $SG177511 ; ".*"
.text$mn:00004EEF                 push    offset $SG177512 ; "All types"
.text$mn:00004EF4                 lea     edx, [ebp+var_130C]
.text$mn:00004EFA                 push    edx             ; this
.text$mn:00004EFB                 call    ?setExtFilter@FileDialog@@QAAXPB_W0ZZ ; FileDialog::setExtFilter(wchar_t const *,wchar_t const *,...)
.text$mn:00004F00                 add     esp, 10h
.text$mn:00004F03                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00004F08                 mov     ecx, eax        ; this
.text$mn:00004F0A                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00004F0F                 add     eax, 220h
.text$mn:00004F14                 mov     ecx, eax
.text$mn:00004F16                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00004F1B                 mov     [ebp+Str], eax
.text$mn:00004F21                 push    offset $SG177515 ; Str
.text$mn:00004F26                 lea     ecx, [ebp+var_250]
.text$mn:00004F2C                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00004F31                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004F35                 mov     eax, [ebp+Str]
.text$mn:00004F3B                 movzx   ecx, word ptr [eax]
.text$mn:00004F3E                 test    ecx, ecx
.text$mn:00004F40                 jz      short loc_4F94
.text$mn:00004F42                 mov     edx, [ebp+Str]
.text$mn:00004F48                 movzx   eax, word ptr [edx]
.text$mn:00004F4B                 cmp     eax, 2Eh ; '.'
.text$mn:00004F4E                 jz      short loc_4F60
.text$mn:00004F50                 push    offset $SG177518 ; Str
.text$mn:00004F55                 lea     ecx, [ebp+var_250]
.text$mn:00004F5B                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00004F60
.text$mn:00004F60 loc_4F60:                               ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+E6j
.text$mn:00004F60                 mov     ecx, [ebp+Str]
.text$mn:00004F66                 push    ecx             ; Str
.text$mn:00004F67                 lea     ecx, [ebp+var_250]
.text$mn:00004F6D                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00004F72                 push    0
.text$mn:00004F74                 lea     ecx, [ebp+var_250]
.text$mn:00004F7A                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00004F7F                 push    eax             ; wchar_t *
.text$mn:00004F80                 push    offset $SG177519 ; "Session file"
.text$mn:00004F85                 lea     edx, [ebp+var_130C]
.text$mn:00004F8B                 push    edx             ; this
.text$mn:00004F8C                 call    ?setExtFilter@FileDialog@@QAAXPB_W0ZZ ; FileDialog::setExtFilter(wchar_t const *,wchar_t const *,...)
.text$mn:00004F91                 add     esp, 10h
.text$mn:00004F94
.text$mn:00004F94 loc_4F94:                               ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+D8j
.text$mn:00004F94                 lea     ecx, [ebp+var_130C] ; this
.text$mn:00004F9A                 call    ?doOpenSingleFileDlg@FileDialog@@QAEPA_WXZ ; FileDialog::doOpenSingleFileDlg(void)
.text$mn:00004F9F                 mov     [ebp+var_1318], eax
.text$mn:00004FA5                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004FA9                 lea     ecx, [ebp+var_250]
.text$mn:00004FAF                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00004FB4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004FBB                 lea     ecx, [ebp+var_130C] ; this
.text$mn:00004FC1                 call    ??1FileDialog@@QAE@XZ ; FileDialog::~FileDialog(void)
.text$mn:00004FC6                 jmp     short loc_4FDF
.text$mn:00004FC8 ; ---------------------------------------------------------------------------
.text$mn:00004FC8
.text$mn:00004FC8 loc_4FC8:                               ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+4Aj
.text$mn:00004FC8                 mov     eax, [ebp+pszPath]
.text$mn:00004FCB                 push    eax             ; pszPath
.text$mn:00004FCC                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:00004FD2                 test    eax, eax
.text$mn:00004FD4                 jz      short loc_4FDF
.text$mn:00004FD6                 mov     ecx, [ebp+pszPath]
.text$mn:00004FD9                 mov     [ebp+var_1318], ecx
.text$mn:00004FDF
.text$mn:00004FDF loc_4FDF:                               ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+15Ej
.text$mn:00004FDF                                         ; Notepad_plus::fileLoadSession(wchar_t const *)+16Cj
.text$mn:00004FDF                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00004FE4                 mov     [ebp+var_1330], eax
.text$mn:00004FEA                 mov     ecx, [ebp+var_1330] ; this
.text$mn:00004FF0                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00004FF5                 mov     [ebp+var_132C], eax
.text$mn:00004FFB                 cmp     [ebp+var_1318], 0
.text$mn:00005002                 jz      loc_5264
.text$mn:00005008                 mov     [ebp+var_130D], 0
.text$mn:0000500F                 mov     ecx, [ebp+var_1314]
.text$mn:00005015                 add     ecx, 35Ch       ; this
.text$mn:0000501B                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:00005020                 cmp     eax, 1
.text$mn:00005023                 jnz     loc_50F9
.text$mn:00005029                 mov     ecx, [ebp+var_1314]
.text$mn:0000502F                 add     ecx, 3DCh       ; this
.text$mn:00005035                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:0000503A                 cmp     eax, 1
.text$mn:0000503D                 jnz     loc_50F9
.text$mn:00005043                 push    0               ; int
.text$mn:00005045                 mov     ecx, [ebp+var_1314]
.text$mn:0000504B                 add     ecx, 35Ch       ; this
.text$mn:00005051                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00005056                 push    eax             ; struct Buffer *
.text$mn:00005057                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:0000505C                 mov     ecx, eax        ; this
.text$mn:0000505E                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00005063                 mov     [ebp+var_1328], eax
.text$mn:00005069                 push    0               ; int
.text$mn:0000506B                 mov     ecx, [ebp+var_1314]
.text$mn:00005071                 add     ecx, 3DCh       ; this
.text$mn:00005077                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:0000507C                 push    eax             ; struct Buffer *
.text$mn:0000507D                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00005082                 mov     ecx, eax        ; this
.text$mn:00005084                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00005089                 mov     [ebp+var_1320], eax
.text$mn:0000508F                 mov     ecx, [ebp+var_1328] ; this
.text$mn:00005095                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:0000509A                 movzx   edx, al
.text$mn:0000509D                 test    edx, edx
.text$mn:0000509F                 jnz     short loc_50E3
.text$mn:000050A1                 mov     ecx, [ebp+var_1328] ; this
.text$mn:000050A7                 call    ?isUntitled@Buffer@@QBE_NXZ ; Buffer::isUntitled(void)
.text$mn:000050AC                 movzx   eax, al
.text$mn:000050AF                 test    eax, eax
.text$mn:000050B1                 jz      short loc_50E3
.text$mn:000050B3                 mov     ecx, [ebp+var_1320] ; this
.text$mn:000050B9                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:000050BE                 movzx   ecx, al
.text$mn:000050C1                 test    ecx, ecx
.text$mn:000050C3                 jnz     short loc_50E3
.text$mn:000050C5                 mov     ecx, [ebp+var_1320] ; this
.text$mn:000050CB                 call    ?isUntitled@Buffer@@QBE_NXZ ; Buffer::isUntitled(void)
.text$mn:000050D0                 movzx   edx, al
.text$mn:000050D3                 test    edx, edx
.text$mn:000050D5                 jz      short loc_50E3
.text$mn:000050D7                 mov     [ebp+var_1324], 1
.text$mn:000050E1                 jmp     short loc_50ED
.text$mn:000050E3 ; ---------------------------------------------------------------------------
.text$mn:000050E3
.text$mn:000050E3 loc_50E3:                               ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+237j
.text$mn:000050E3                                         ; Notepad_plus::fileLoadSession(wchar_t const *)+249j ...
.text$mn:000050E3                 mov     [ebp+var_1324], 0
.text$mn:000050ED
.text$mn:000050ED loc_50ED:                               ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+279j
.text$mn:000050ED                 mov     al, byte ptr [ebp+var_1324]
.text$mn:000050F3                 mov     [ebp+var_130D], al
.text$mn:000050F9
.text$mn:000050F9 loc_50F9:                               ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+1BBj
.text$mn:000050F9                                         ; Notepad_plus::fileLoadSession(wchar_t const *)+1D5j
.text$mn:000050F9                 movzx   ecx, [ebp+var_130D]
.text$mn:00005100                 test    ecx, ecx
.text$mn:00005102                 jnz     loc_51D2
.text$mn:00005108                 mov     edx, [ebp+var_132C]
.text$mn:0000510E                 cmp     dword ptr [edx+690h], 1
.text$mn:00005115                 jz      short loc_512A
.text$mn:00005117                 mov     eax, [ebp+var_132C]
.text$mn:0000511D                 cmp     dword ptr [eax+690h], 2
.text$mn:00005124                 jnz     loc_51D2
.text$mn:0000512A
.text$mn:0000512A loc_512A:                               ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+2ADj
.text$mn:0000512A                 push    104h            ; nSize
.text$mn:0000512F                 lea     ecx, [ebp+Filename]
.text$mn:00005135                 push    ecx             ; lpFilename
.text$mn:00005136                 push    0               ; hModule
.text$mn:00005138                 call    dword ptr ds:__imp__GetModuleFileNameW@12 ; GetModuleFileNameW(x,x,x)
.text$mn:0000513E                 push    offset $SG177581 ; "-multiInst -nosession -openSession "
.text$mn:00005143                 lea     ecx, [ebp+var_234]
.text$mn:00005149                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000514E                 mov     [ebp+var_4], 2
.text$mn:00005155                 push    offset $SG177582 ; Str
.text$mn:0000515A                 lea     ecx, [ebp+var_234]
.text$mn:00005160                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00005165                 mov     edx, [ebp+var_1318]
.text$mn:0000516B                 push    edx             ; Str
.text$mn:0000516C                 lea     ecx, [ebp+var_234]
.text$mn:00005172                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00005177                 push    offset $SG177583 ; Str
.text$mn:0000517C                 lea     ecx, [ebp+var_234]
.text$mn:00005182                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00005187                 push    5               ; nShowCmd
.text$mn:00005189                 push    offset $SG177584 ; lpDirectory
.text$mn:0000518E                 lea     ecx, [ebp+var_234]
.text$mn:00005194                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00005199                 push    eax             ; lpParameters
.text$mn:0000519A                 lea     eax, [ebp+Filename]
.text$mn:000051A0                 push    eax             ; lpFile
.text$mn:000051A1                 push    offset $SG177585 ; "open"
.text$mn:000051A6                 mov     ecx, [ebp+var_1314]
.text$mn:000051AC                 mov     ecx, [ecx+4]    ; this
.text$mn:000051AF                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000051B4                 push    eax             ; hwnd
.text$mn:000051B5                 call    dword ptr ds:__imp__ShellExecuteW@24 ; ShellExecuteW(x,x,x,x,x,x)
.text$mn:000051BB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000051C2                 lea     ecx, [ebp+var_234]
.text$mn:000051C8                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000051CD                 jmp     loc_5264
.text$mn:000051D2 ; ---------------------------------------------------------------------------
.text$mn:000051D2
.text$mn:000051D2 loc_51D2:                               ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+29Aj
.text$mn:000051D2                                         ; Notepad_plus::fileLoadSession(wchar_t const *)+2BCj
.text$mn:000051D2                 mov     [ebp+var_130E], 1
.text$mn:000051D9                 lea     ecx, [ebp+var_135C]
.text$mn:000051DF                 call    ??0Session@@QAE@XZ ; Session::Session(void)
.text$mn:000051E4                 mov     [ebp+var_4], 3
.text$mn:000051EB                 mov     edx, [ebp+var_1318]
.text$mn:000051F1                 push    edx             ; wchar_t *
.text$mn:000051F2                 lea     eax, [ebp+var_135C]
.text$mn:000051F8                 push    eax             ; struct Session *
.text$mn:000051F9                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000051FE                 mov     ecx, eax        ; this
.text$mn:00005200                 call    ?loadSession@NppParameters@@QAE_NAAUSession@@PB_W@Z ; NppParameters::loadSession(Session &,wchar_t const *)
.text$mn:00005205                 movzx   ecx, al
.text$mn:00005208                 test    ecx, ecx
.text$mn:0000520A                 jz      short loc_522D
.text$mn:0000520C                 push    0               ; bool
.text$mn:0000520E                 lea     edx, [ebp+var_135C]
.text$mn:00005214                 push    edx             ; struct Session *
.text$mn:00005215                 mov     ecx, [ebp+var_1314] ; this
.text$mn:0000521B                 call    ?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z ; Notepad_plus::loadSession(Session &,bool)
.text$mn:00005220                 mov     [ebp+var_130E], al
.text$mn:00005226                 mov     [ebp+var_130F], 1
.text$mn:0000522D
.text$mn:0000522D loc_522D:                               ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+3A2j
.text$mn:0000522D                 movzx   eax, [ebp+var_130E]
.text$mn:00005234                 test    eax, eax
.text$mn:00005236                 jnz     short loc_5252
.text$mn:00005238                 mov     ecx, [ebp+var_1318]
.text$mn:0000523E                 push    ecx             ; wchar_t *
.text$mn:0000523F                 lea     edx, [ebp+var_135C]
.text$mn:00005245                 push    edx             ; struct Session *
.text$mn:00005246                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:0000524B                 mov     ecx, eax        ; this
.text$mn:0000524D                 call    ?writeSession@NppParameters@@QAEXABUSession@@PB_W@Z ; NppParameters::writeSession(Session const &,wchar_t const *)
.text$mn:00005252
.text$mn:00005252 loc_5252:                               ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+3CEj
.text$mn:00005252                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005259                 lea     ecx, [ebp+var_135C] ; this
.text$mn:0000525F                 call    ??1Session@@QAE@XZ ; Session::~Session(void)
.text$mn:00005264
.text$mn:00005264 loc_5264:                               ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+19Aj
.text$mn:00005264                                         ; Notepad_plus::fileLoadSession(wchar_t const *)+365j
.text$mn:00005264                 mov     al, [ebp+var_130F]
.text$mn:0000526A                 mov     ecx, [ebp+var_C]
.text$mn:0000526D                 mov     large fs:0, ecx
.text$mn:00005274                 pop     ecx
.text$mn:00005275                 mov     ecx, [ebp+var_10]
.text$mn:00005278                 xor     ecx, ebp
.text$mn:0000527A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000527F                 mov     esp, ebp
.text$mn:00005281                 pop     ebp
.text$mn:00005282                 retn    4
.text$mn:00005282 ?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z endp
.text$mn:00005282
.text$mn:00005282 ; ---------------------------------------------------------------------------
.text$mn:00005285                 align 4
.text$mn:00005288
.text$mn:00005288 ; =============== S U B R O U T I N E =======================================
.text$mn:00005288
.text$mn:00005288 ; Attributes: bp-based frame
.text$mn:00005288
.text$mn:00005288 ; const wchar_t *__thiscall Notepad_plus::fileSaveSession(Notepad_plus *this, unsigned int, wchar_t **, const wchar_t *)
.text$mn:00005288                 public ?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z
.text$mn:00005288 ?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z proc near
.text$mn:00005288                                         ; CODE XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *)+135p
.text$mn:00005288
.text$mn:00005288 var_F0          = byte ptr -0F0h
.text$mn:00005288 var_E4          = byte ptr -0E4h
.text$mn:00005288 var_C4          = dword ptr -0C4h
.text$mn:00005288 var_C0          = dword ptr -0C0h
.text$mn:00005288 var_BC          = dword ptr -0BCh
.text$mn:00005288 var_B8          = dword ptr -0B8h
.text$mn:00005288 var_B4          = dword ptr -0B4h
.text$mn:00005288 var_B0          = dword ptr -0B0h
.text$mn:00005288 var_AC          = dword ptr -0ACh
.text$mn:00005288 var_A8          = byte ptr -0A8h
.text$mn:00005288 var_10          = dword ptr -10h
.text$mn:00005288 var_C           = dword ptr -0Ch
.text$mn:00005288 var_4           = dword ptr -4
.text$mn:00005288 arg_0           = dword ptr  8
.text$mn:00005288 arg_4           = dword ptr  0Ch
.text$mn:00005288 arg_8           = dword ptr  10h
.text$mn:00005288
.text$mn:00005288                 push    ebp
.text$mn:00005289                 mov     ebp, esp
.text$mn:0000528B                 push    0FFFFFFFFh
.text$mn:0000528D                 push    offset __ehhandler$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z
.text$mn:00005292                 mov     eax, large fs:0
.text$mn:00005298                 push    eax
.text$mn:00005299                 sub     esp, 0E4h
.text$mn:0000529F                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000052A4                 xor     eax, ebp
.text$mn:000052A6                 mov     [ebp+var_10], eax
.text$mn:000052A9                 push    eax
.text$mn:000052AA                 lea     eax, [ebp+var_C]
.text$mn:000052AD                 mov     large fs:0, eax
.text$mn:000052B3                 mov     [ebp+var_B0], ecx
.text$mn:000052B9                 cmp     [ebp+arg_8], 0
.text$mn:000052BD                 jz      loc_53EC
.text$mn:000052C3                 lea     ecx, [ebp+var_F0]
.text$mn:000052C9                 call    ??0Session@@QAE@XZ ; Session::Session(void)
.text$mn:000052CE                 mov     [ebp+var_4], 0
.text$mn:000052D5                 cmp     [ebp+arg_0], 0
.text$mn:000052D9                 jz      loc_539E
.text$mn:000052DF                 cmp     [ebp+arg_4], 0
.text$mn:000052E3                 jz      loc_539E
.text$mn:000052E9                 mov     [ebp+var_AC], 0
.text$mn:000052F3                 jmp     short loc_5304
.text$mn:000052F5 ; ---------------------------------------------------------------------------
.text$mn:000052F5
.text$mn:000052F5 loc_52F5:                               ; CODE XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *):loc_5397j
.text$mn:000052F5                 mov     eax, [ebp+var_AC]
.text$mn:000052FB                 add     eax, 1
.text$mn:000052FE                 mov     [ebp+var_AC], eax
.text$mn:00005304
.text$mn:00005304 loc_5304:                               ; CODE XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *)+6Bj
.text$mn:00005304                 mov     ecx, [ebp+var_AC]
.text$mn:0000530A                 cmp     ecx, [ebp+arg_0]
.text$mn:0000530D                 jnb     loc_539C
.text$mn:00005313                 mov     edx, [ebp+var_AC]
.text$mn:00005319                 mov     eax, [ebp+arg_4]
.text$mn:0000531C                 mov     ecx, [eax+edx*4]
.text$mn:0000531F                 push    ecx             ; pszPath
.text$mn:00005320                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:00005326                 test    eax, eax
.text$mn:00005328                 jz      short loc_5397
.text$mn:0000532A                 sub     esp, 1Ch
.text$mn:0000532D                 mov     ecx, esp
.text$mn:0000532F                 mov     [ebp+var_BC], esp
.text$mn:00005335                 mov     edx, [ebp+var_AC]
.text$mn:0000533B                 mov     eax, [ebp+arg_4]
.text$mn:0000533E                 mov     edx, [eax+edx*4]
.text$mn:00005341                 push    edx             ; Str
.text$mn:00005342                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00005347                 mov     [ebp+var_B8], eax
.text$mn:0000534D                 mov     eax, [ebp+var_B8]
.text$mn:00005353                 mov     [ebp+var_C0], eax
.text$mn:00005359                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000535D                 mov     byte ptr [ebp+var_4], 0
.text$mn:00005361                 lea     ecx, [ebp+var_A8]
.text$mn:00005367                 call    ??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; sessionFileInfo::sessionFileInfo(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)
.text$mn:0000536C                 mov     [ebp+var_C4], eax
.text$mn:00005372                 mov     byte ptr [ebp+var_4], 2
.text$mn:00005376                 lea     ecx, [ebp+var_A8]
.text$mn:0000537C                 push    ecx
.text$mn:0000537D                 lea     ecx, [ebp+var_E4]
.text$mn:00005383                 call    ?push_back@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEX$$QAUsessionFileInfo@@@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::push_back(sessionFileInfo &&)
.text$mn:00005388                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000538C                 lea     ecx, [ebp+var_A8] ; this
.text$mn:00005392                 call    ??1sessionFileInfo@@QAE@XZ ; sessionFileInfo::~sessionFileInfo(void)
.text$mn:00005397
.text$mn:00005397 loc_5397:                               ; CODE XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *)+A0j
.text$mn:00005397                 jmp     loc_52F5
.text$mn:0000539C ; ---------------------------------------------------------------------------
.text$mn:0000539C
.text$mn:0000539C loc_539C:                               ; CODE XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *)+85j
.text$mn:0000539C                 jmp     short loc_53B2
.text$mn:0000539E ; ---------------------------------------------------------------------------
.text$mn:0000539E
.text$mn:0000539E loc_539E:                               ; CODE XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *)+51j
.text$mn:0000539E                                         ; Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *)+5Bj
.text$mn:0000539E                 push    0               ; bool
.text$mn:000053A0                 lea     edx, [ebp+var_F0]
.text$mn:000053A6                 push    edx             ; struct Session *
.text$mn:000053A7                 mov     ecx, [ebp+var_B0] ; this
.text$mn:000053AD                 call    ?getCurrentOpenedFiles@Notepad_plus@@QAEXAAUSession@@_N@Z ; Notepad_plus::getCurrentOpenedFiles(Session &,bool)
.text$mn:000053B2
.text$mn:000053B2 loc_53B2:                               ; CODE XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *):loc_539Cj
.text$mn:000053B2                 mov     eax, [ebp+arg_8]
.text$mn:000053B5                 push    eax             ; wchar_t *
.text$mn:000053B6                 lea     ecx, [ebp+var_F0]
.text$mn:000053BC                 push    ecx             ; struct Session *
.text$mn:000053BD                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000053C2                 mov     ecx, eax        ; this
.text$mn:000053C4                 call    ?writeSession@NppParameters@@QAEXABUSession@@PB_W@Z ; NppParameters::writeSession(Session const &,wchar_t const *)
.text$mn:000053C9                 mov     edx, [ebp+arg_8]
.text$mn:000053CC                 mov     [ebp+var_B4], edx
.text$mn:000053D2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000053D9                 lea     ecx, [ebp+var_F0] ; this
.text$mn:000053DF                 call    ??1Session@@QAE@XZ ; Session::~Session(void)
.text$mn:000053E4                 mov     eax, [ebp+var_B4]
.text$mn:000053EA                 jmp     short loc_53EE
.text$mn:000053EC ; ---------------------------------------------------------------------------
.text$mn:000053EC
.text$mn:000053EC loc_53EC:                               ; CODE XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *)+35j
.text$mn:000053EC                 xor     eax, eax
.text$mn:000053EE
.text$mn:000053EE loc_53EE:                               ; CODE XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *)+162j
.text$mn:000053EE                 mov     ecx, [ebp+var_C]
.text$mn:000053F1                 mov     large fs:0, ecx
.text$mn:000053F8                 pop     ecx
.text$mn:000053F9                 mov     ecx, [ebp+var_10]
.text$mn:000053FC                 xor     ecx, ebp
.text$mn:000053FE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00005403                 mov     esp, ebp
.text$mn:00005405                 pop     ebp
.text$mn:00005406                 retn    0Ch
.text$mn:00005406 ?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z endp
.text$mn:00005406
.text$mn:00005406 ; ---------------------------------------------------------------------------
.text$mn:00005409                 db 0Fh dup(0CCh)
.text$mn:00005418
.text$mn:00005418 ; =============== S U B R O U T I N E =======================================
.text$mn:00005418
.text$mn:00005418 ; Attributes: bp-based frame
.text$mn:00005418
.text$mn:00005418 ; const wchar_t *__thiscall Notepad_plus::fileSaveSession(Notepad_plus *this, unsigned int, wchar_t **)
.text$mn:00005418                 public ?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z
.text$mn:00005418 ?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z proc near
.text$mn:00005418
.text$mn:00005418 var_10F8        = dword ptr -10F8h
.text$mn:00005418 var_10F4        = dword ptr -10F4h
.text$mn:00005418 Str             = dword ptr -10F0h
.text$mn:00005418 var_10EC        = dword ptr -10ECh
.text$mn:00005418 var_10E8        = byte ptr -10E8h
.text$mn:00005418 var_2C          = byte ptr -2Ch
.text$mn:00005418 var_10          = dword ptr -10h
.text$mn:00005418 var_C           = dword ptr -0Ch
.text$mn:00005418 var_4           = dword ptr -4
.text$mn:00005418 arg_0           = dword ptr  8
.text$mn:00005418 arg_4           = dword ptr  0Ch
.text$mn:00005418
.text$mn:00005418                 push    ebp
.text$mn:00005419                 mov     ebp, esp
.text$mn:0000541B                 push    0FFFFFFFFh
.text$mn:0000541D                 push    offset __ehhandler$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z
.text$mn:00005422                 mov     eax, large fs:0
.text$mn:00005428                 push    eax
.text$mn:00005429                 mov     eax, 10ECh
.text$mn:0000542E                 call    __chkstk
.text$mn:00005433                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005438                 xor     eax, ebp
.text$mn:0000543A                 mov     [ebp+var_10], eax
.text$mn:0000543D                 push    eax
.text$mn:0000543E                 lea     eax, [ebp+var_C]
.text$mn:00005441                 mov     large fs:0, eax
.text$mn:00005447                 mov     [ebp+var_10EC], ecx
.text$mn:0000544D                 mov     [ebp+var_10F4], 0
.text$mn:00005457                 mov     eax, [ebp+var_10EC]
.text$mn:0000545D                 mov     ecx, [eax+4]    ; this
.text$mn:00005460                 call    ?getHinst@Window@@QBEPAUHINSTANCE__@@XZ ; Window::getHinst(void)
.text$mn:00005465                 push    eax
.text$mn:00005466                 mov     ecx, [ebp+var_10EC]
.text$mn:0000546C                 mov     ecx, [ecx+4]    ; this
.text$mn:0000546F                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00005474                 push    eax
.text$mn:00005475                 lea     ecx, [ebp+var_10E8]
.text$mn:0000547B                 call    ??0FileDialog@@QAE@PAUHWND__@@PAUHINSTANCE__@@@Z ; FileDialog::FileDialog(HWND__ *,HINSTANCE__ *)
.text$mn:00005480                 mov     [ebp+var_4], 0
.text$mn:00005487                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:0000548C                 mov     ecx, eax        ; this
.text$mn:0000548E                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00005493                 add     eax, 220h
.text$mn:00005498                 mov     ecx, eax
.text$mn:0000549A                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000549F                 mov     [ebp+Str], eax
.text$mn:000054A5                 push    0
.text$mn:000054A7                 push    offset $SG177622 ; ".*"
.text$mn:000054AC                 push    offset $SG177623 ; "All types"
.text$mn:000054B1                 lea     edx, [ebp+var_10E8]
.text$mn:000054B7                 push    edx             ; this
.text$mn:000054B8                 call    ?setExtFilter@FileDialog@@QAAXPB_W0ZZ ; FileDialog::setExtFilter(wchar_t const *,wchar_t const *,...)
.text$mn:000054BD                 add     esp, 10h
.text$mn:000054C0                 push    offset $SG177625 ; Str
.text$mn:000054C5                 lea     ecx, [ebp+var_2C]
.text$mn:000054C8                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000054CD                 mov     byte ptr [ebp+var_4], 1
.text$mn:000054D1                 mov     eax, [ebp+Str]
.text$mn:000054D7                 movzx   ecx, word ptr [eax]
.text$mn:000054DA                 test    ecx, ecx
.text$mn:000054DC                 jz      short loc_5527
.text$mn:000054DE                 mov     edx, [ebp+Str]
.text$mn:000054E4                 movzx   eax, word ptr [edx]
.text$mn:000054E7                 cmp     eax, 2Eh ; '.'
.text$mn:000054EA                 jz      short loc_54F9
.text$mn:000054EC                 push    offset $SG177628 ; Str
.text$mn:000054F1                 lea     ecx, [ebp+var_2C]
.text$mn:000054F4                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:000054F9
.text$mn:000054F9 loc_54F9:                               ; CODE XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *)+D2j
.text$mn:000054F9                 mov     ecx, [ebp+Str]
.text$mn:000054FF                 push    ecx             ; Str
.text$mn:00005500                 lea     ecx, [ebp+var_2C]
.text$mn:00005503                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00005508                 push    0
.text$mn:0000550A                 lea     ecx, [ebp+var_2C]
.text$mn:0000550D                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00005512                 push    eax             ; wchar_t *
.text$mn:00005513                 push    offset $SG177629 ; "Session file"
.text$mn:00005518                 lea     edx, [ebp+var_10E8]
.text$mn:0000551E                 push    edx             ; this
.text$mn:0000551F                 call    ?setExtFilter@FileDialog@@QAAXPB_W0ZZ ; FileDialog::setExtFilter(wchar_t const *,wchar_t const *,...)
.text$mn:00005524                 add     esp, 10h
.text$mn:00005527
.text$mn:00005527 loc_5527:                               ; CODE XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *)+C4j
.text$mn:00005527                 lea     ecx, [ebp+var_10E8] ; this
.text$mn:0000552D                 call    ?doSaveDlg@FileDialog@@QAEPA_WXZ ; FileDialog::doSaveDlg(void)
.text$mn:00005532                 mov     [ebp+var_10F4], eax
.text$mn:00005538                 mov     eax, [ebp+var_10F4]
.text$mn:0000553E                 push    eax             ; wchar_t *
.text$mn:0000553F                 mov     ecx, [ebp+arg_4]
.text$mn:00005542                 push    ecx             ; wchar_t **
.text$mn:00005543                 mov     edx, [ebp+arg_0]
.text$mn:00005546                 push    edx             ; unsigned int
.text$mn:00005547                 mov     ecx, [ebp+var_10EC] ; this
.text$mn:0000554D                 call    ?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z ; Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *)
.text$mn:00005552                 mov     [ebp+var_10F8], eax
.text$mn:00005558                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000555C                 lea     ecx, [ebp+var_2C]
.text$mn:0000555F                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00005564                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000556B                 lea     ecx, [ebp+var_10E8] ; this
.text$mn:00005571                 call    ??1FileDialog@@QAE@XZ ; FileDialog::~FileDialog(void)
.text$mn:00005576                 mov     eax, [ebp+var_10F8]
.text$mn:0000557C                 mov     ecx, [ebp+var_C]
.text$mn:0000557F                 mov     large fs:0, ecx
.text$mn:00005586                 pop     ecx
.text$mn:00005587                 mov     ecx, [ebp+var_10]
.text$mn:0000558A                 xor     ecx, ebp
.text$mn:0000558C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00005591                 mov     esp, ebp
.text$mn:00005593                 pop     ebp
.text$mn:00005594                 retn    8
.text$mn:00005594 ?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z endp
.text$mn:00005594
.text$mn:00005594 ; ---------------------------------------------------------------------------
.text$mn:00005597                 align 4
.text$mn:00005598
.text$mn:00005598 ; =============== S U B R O U T I N E =======================================
.text$mn:00005598
.text$mn:00005598 ; Attributes: bp-based frame
.text$mn:00005598
.text$mn:00005598 ; void __thiscall Notepad_plus::loadLastSession(Notepad_plus *__hidden this)
.text$mn:00005598                 public ?loadLastSession@Notepad_plus@@QAEXXZ
.text$mn:00005598 ?loadLastSession@Notepad_plus@@QAEXXZ proc near
.text$mn:00005598
.text$mn:00005598 var_48          = byte ptr -48h
.text$mn:00005598 var_1C          = dword ptr -1Ch
.text$mn:00005598 var_18          = dword ptr -18h
.text$mn:00005598 var_14          = dword ptr -14h
.text$mn:00005598 var_D           = byte ptr -0Dh
.text$mn:00005598 var_C           = dword ptr -0Ch
.text$mn:00005598 var_4           = dword ptr -4
.text$mn:00005598
.text$mn:00005598                 push    ebp
.text$mn:00005599                 mov     ebp, esp
.text$mn:0000559B                 push    0FFFFFFFFh
.text$mn:0000559D                 push    offset __ehhandler$?loadLastSession@Notepad_plus@@QAEXXZ
.text$mn:000055A2                 mov     eax, large fs:0
.text$mn:000055A8                 push    eax
.text$mn:000055A9                 sub     esp, 3Ch
.text$mn:000055AC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000055B1                 xor     eax, ebp
.text$mn:000055B3                 push    eax
.text$mn:000055B4                 lea     eax, [ebp+var_C]
.text$mn:000055B7                 mov     large fs:0, eax
.text$mn:000055BD                 mov     [ebp+var_1C], ecx
.text$mn:000055C0                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000055C5                 mov     [ebp+var_14], eax
.text$mn:000055C8                 mov     ecx, [ebp+var_14] ; this
.text$mn:000055CB                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:000055D0                 mov     [ebp+var_18], eax
.text$mn:000055D3                 mov     ecx, [ebp+var_14] ; this
.text$mn:000055D6                 call    ?getSession@NppParameters@@QBEABUSession@@XZ ; NppParameters::getSession(void)
.text$mn:000055DB                 push    eax
.text$mn:000055DC                 lea     ecx, [ebp+var_48]
.text$mn:000055DF                 call    ??0Session@@QAE@ABU0@@Z ; Session::Session(Session const &)
.text$mn:000055E4                 mov     [ebp+var_4], 0
.text$mn:000055EB                 mov     ecx, [ebp+var_18] ; this
.text$mn:000055EE                 call    ?isSnapshotMode@NppGUI@@QBE_NXZ ; NppGUI::isSnapshotMode(void)
.text$mn:000055F3                 mov     [ebp+var_D], al
.text$mn:000055F6                 movzx   eax, [ebp+var_D]
.text$mn:000055FA                 push    eax             ; bool
.text$mn:000055FB                 lea     ecx, [ebp+var_48]
.text$mn:000055FE                 push    ecx             ; struct Session *
.text$mn:000055FF                 mov     ecx, [ebp+var_1C] ; this
.text$mn:00005602                 call    ?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z ; Notepad_plus::loadSession(Session &,bool)
.text$mn:00005607                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000560E                 lea     ecx, [ebp+var_48] ; this
.text$mn:00005611                 call    ??1Session@@QAE@XZ ; Session::~Session(void)
.text$mn:00005616                 mov     ecx, [ebp+var_C]
.text$mn:00005619                 mov     large fs:0, ecx
.text$mn:00005620                 pop     ecx
.text$mn:00005621                 mov     esp, ebp
.text$mn:00005623                 pop     ebp
.text$mn:00005624                 retn
.text$mn:00005624 ?loadLastSession@Notepad_plus@@QAEXXZ endp
.text$mn:00005624
.text$mn:00005624 ; ---------------------------------------------------------------------------
.text$mn:00005625                 align 4
.text$mn:00005628
.text$mn:00005628 ; =============== S U B R O U T I N E =======================================
.text$mn:00005628
.text$mn:00005628 ; Attributes: bp-based frame
.text$mn:00005628
.text$mn:00005628 ; bool __thiscall Notepad_plus::loadSession(Notepad_plus *this, struct Session *, bool)
.text$mn:00005628                 public ?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z
.text$mn:00005628 ?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z proc near
.text$mn:00005628                                         ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+3B3p
.text$mn:00005628                                         ; Notepad_plus::loadLastSession(void)+6Ap
.text$mn:00005628
.text$mn:00005628 var_15C         = byte ptr -15Ch
.text$mn:00005628 var_150         = byte ptr -150h
.text$mn:00005628 var_144         = byte ptr -144h
.text$mn:00005628 var_138         = byte ptr -138h
.text$mn:00005628 var_12C         = byte ptr -12Ch
.text$mn:00005628 var_120         = byte ptr -120h
.text$mn:00005628 var_114         = byte ptr -114h
.text$mn:00005628 var_108         = byte ptr -108h
.text$mn:00005628 var_FC          = dword ptr -0FCh
.text$mn:00005628 var_F8          = dword ptr -0F8h
.text$mn:00005628 var_F4          = dword ptr -0F4h
.text$mn:00005628 var_F0          = dword ptr -0F0h
.text$mn:00005628 var_EC          = dword ptr -0ECh
.text$mn:00005628 var_E8          = dword ptr -0E8h
.text$mn:00005628 var_E4          = dword ptr -0E4h
.text$mn:00005628 var_E0          = dword ptr -0E0h
.text$mn:00005628 var_DC          = byte ptr -0DCh
.text$mn:00005628 var_D0          = dword ptr -0D0h
.text$mn:00005628 var_CC          = byte ptr -0CCh
.text$mn:00005628 var_C0          = dword ptr -0C0h
.text$mn:00005628 var_BC          = byte ptr -0BCh
.text$mn:00005628 var_B0          = dword ptr -0B0h
.text$mn:00005628 var_AC          = byte ptr -0ACh
.text$mn:00005628 var_A0          = dword ptr -0A0h
.text$mn:00005628 var_9C          = dword ptr -9Ch
.text$mn:00005628 var_98          = dword ptr -98h
.text$mn:00005628 var_94          = dword ptr -94h
.text$mn:00005628 var_90          = dword ptr -90h
.text$mn:00005628 var_8C          = dword ptr -8Ch
.text$mn:00005628 var_88          = dword ptr -88h
.text$mn:00005628 var_84          = dword ptr -84h
.text$mn:00005628 var_80          = dword ptr -80h
.text$mn:00005628 var_7C          = dword ptr -7Ch
.text$mn:00005628 var_78          = dword ptr -78h
.text$mn:00005628 var_74          = dword ptr -74h
.text$mn:00005628 var_70          = dword ptr -70h
.text$mn:00005628 var_6C          = dword ptr -6Ch
.text$mn:00005628 var_68          = dword ptr -68h
.text$mn:00005628 var_64          = dword ptr -64h
.text$mn:00005628 var_60          = dword ptr -60h
.text$mn:00005628 var_5C          = dword ptr -5Ch
.text$mn:00005628 var_58          = dword ptr -58h
.text$mn:00005628 var_54          = dword ptr -54h
.text$mn:00005628 var_50          = dword ptr -50h
.text$mn:00005628 var_4C          = dword ptr -4Ch
.text$mn:00005628 var_48          = dword ptr -48h
.text$mn:00005628 lpString1       = dword ptr -44h
.text$mn:00005628 var_40          = dword ptr -40h
.text$mn:00005628 var_3C          = dword ptr -3Ch
.text$mn:00005628 var_38          = dword ptr -38h
.text$mn:00005628 var_34          = dword ptr -34h
.text$mn:00005628 pszPath         = dword ptr -30h
.text$mn:00005628 lpFileName      = dword ptr -2Ch
.text$mn:00005628 var_28          = dword ptr -28h
.text$mn:00005628 var_24          = dword ptr -24h
.text$mn:00005628 var_20          = dword ptr -20h
.text$mn:00005628 var_1B          = byte ptr -1Bh
.text$mn:00005628 var_1A          = byte ptr -1Ah
.text$mn:00005628 var_19          = byte ptr -19h
.text$mn:00005628 var_18          = dword ptr -18h
.text$mn:00005628 var_14          = dword ptr -14h
.text$mn:00005628 var_10          = dword ptr -10h
.text$mn:00005628 var_C           = dword ptr -0Ch
.text$mn:00005628 var_4           = dword ptr -4
.text$mn:00005628 arg_0           = dword ptr  8
.text$mn:00005628 arg_4           = byte ptr  0Ch
.text$mn:00005628
.text$mn:00005628                 push    ebp
.text$mn:00005629                 mov     ebp, esp
.text$mn:0000562B                 push    0FFFFFFFFh
.text$mn:0000562D                 push    offset __ehhandler$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z
.text$mn:00005632                 mov     eax, large fs:0
.text$mn:00005638                 push    eax
.text$mn:00005639                 sub     esp, 150h
.text$mn:0000563F                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005644                 xor     eax, ebp
.text$mn:00005646                 push    eax             ; int
.text$mn:00005647                 lea     eax, [ebp+var_C]
.text$mn:0000564A                 mov     large fs:0, eax
.text$mn:00005650                 mov     [ebp+var_10], ecx
.text$mn:00005653                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00005658                 mov     [ebp+var_38], eax
.text$mn:0000565B                 mov     [ebp+var_19], 1
.text$mn:0000565F                 mov     [ebp+var_20], 0
.text$mn:00005666                 push    0               ; int
.text$mn:00005668                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000566B                 call    ?showView@Notepad_plus@@AAEXH@Z ; Notepad_plus::showView(int)
.text$mn:00005670                 push    0               ; int
.text$mn:00005672                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005675                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:0000567A                 mov     [ebp+var_50], 0FFFFFFFFh
.text$mn:00005681                 mov     [ebp+var_14], 0
.text$mn:00005688
.text$mn:00005688 loc_5688:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+14Ej
.text$mn:00005688                                         ; Notepad_plus::loadSession(Session &,bool):loc_5C3Fj
.text$mn:00005688                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000568B                 call    ?nbMainFiles@Session@@QBEIXZ ; Session::nbMainFiles(void)
.text$mn:00005690                 cmp     [ebp+var_14], eax
.text$mn:00005693                 jnb     loc_5C44
.text$mn:00005699                 mov     eax, [ebp+var_14]
.text$mn:0000569C                 push    eax
.text$mn:0000569D                 mov     ecx, [ebp+arg_0]
.text$mn:000056A0                 add     ecx, 0Ch
.text$mn:000056A3                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:000056A8                 add     eax, 18h
.text$mn:000056AB                 mov     ecx, eax
.text$mn:000056AD                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000056B2                 mov     [ebp+pszPath], eax
.text$mn:000056B5                 mov     ecx, [ebp+pszPath]
.text$mn:000056B8                 push    ecx             ; wchar_t *
.text$mn:000056B9                 mov     ecx, [ebp+var_10] ; this
.text$mn:000056BC                 call    ?isFileSession@Notepad_plus@@QAE_NPB_W@Z ; Notepad_plus::isFileSession(wchar_t const *)
.text$mn:000056C1                 movzx   edx, al
.text$mn:000056C4                 test    edx, edx
.text$mn:000056C6                 jz      loc_577B
.text$mn:000056CC                 mov     eax, [ebp+var_14]
.text$mn:000056CF                 push    eax
.text$mn:000056D0                 lea     ecx, [ebp+var_AC]
.text$mn:000056D6                 push    ecx
.text$mn:000056D7                 lea     edx, [ebp+var_108]
.text$mn:000056DD                 push    edx
.text$mn:000056DE                 mov     ecx, [ebp+arg_0]
.text$mn:000056E1                 add     ecx, 0Ch
.text$mn:000056E4                 call    ?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::begin(void)
.text$mn:000056E9                 mov     [ebp+var_64], eax
.text$mn:000056EC                 mov     eax, [ebp+var_64]
.text$mn:000056EF                 mov     [ebp+var_68], eax
.text$mn:000056F2                 mov     [ebp+var_4], 0
.text$mn:000056F9                 mov     ecx, [ebp+var_68]
.text$mn:000056FC                 call    ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+(int)
.text$mn:00005701                 mov     byte ptr [ebp+var_4], 2
.text$mn:00005705                 lea     ecx, [ebp+var_108]
.text$mn:0000570B                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:00005710                 sub     esp, 0Ch
.text$mn:00005713                 mov     ecx, esp
.text$mn:00005715                 mov     [ebp+var_EC], esp
.text$mn:0000571B                 lea     edx, [ebp+var_AC]
.text$mn:00005721                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005722                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>> const &)
.text$mn:00005727                 mov     [ebp+var_90], eax
.text$mn:0000572D                 mov     eax, [ebp+var_90]
.text$mn:00005733                 mov     [ebp+var_B0], eax
.text$mn:00005739                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000573D                 lea     ecx, [ebp+var_120]
.text$mn:00005743                 push    ecx
.text$mn:00005744                 mov     ecx, [ebp+arg_0]
.text$mn:00005747                 add     ecx, 0Ch
.text$mn:0000574A                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000574E                 call    ?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)
.text$mn:00005753                 mov     [ebp+var_E4], eax
.text$mn:00005759                 lea     ecx, [ebp+var_120]
.text$mn:0000575F                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:00005764                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000576B                 lea     ecx, [ebp+var_AC]
.text$mn:00005771                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:00005776                 jmp     loc_5688
.text$mn:0000577B ; ---------------------------------------------------------------------------
.text$mn:0000577B
.text$mn:0000577B loc_577B:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+9Ej
.text$mn:0000577B                 mov     [ebp+var_1A], 0
.text$mn:0000577F                 mov     edx, [ebp+pszPath]
.text$mn:00005782                 push    edx             ; pszPath
.text$mn:00005783                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:00005789                 test    eax, eax
.text$mn:0000578B                 jnz     short loc_579B
.text$mn:0000578D                 push    0               ; int
.text$mn:0000578F                 mov     ecx, [ebp+var_38] ; this
.text$mn:00005792                 call    ?safeWow64EnableWow64FsRedirection@NppParameters@@QAEXH@Z ; NppParameters::safeWow64EnableWow64FsRedirection(int)
.text$mn:00005797                 mov     [ebp+var_1A], 1
.text$mn:0000579B
.text$mn:0000579B loc_579B:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+163j
.text$mn:0000579B                 mov     eax, [ebp+pszPath]
.text$mn:0000579E                 push    eax             ; pszPath
.text$mn:0000579F                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:000057A5                 test    eax, eax
.text$mn:000057A7                 jz      loc_5870
.text$mn:000057AD                 movzx   ecx, [ebp+arg_4]
.text$mn:000057B1                 test    ecx, ecx
.text$mn:000057B3                 jz      loc_583F
.text$mn:000057B9                 push    offset $SG177281 ; Str
.text$mn:000057BE                 mov     edx, [ebp+var_14]
.text$mn:000057C1                 push    edx
.text$mn:000057C2                 mov     ecx, [ebp+arg_0]
.text$mn:000057C5                 add     ecx, 0Ch
.text$mn:000057C8                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:000057CD                 add     eax, 74h ; 't'
.text$mn:000057D0                 push    eax             ; int
.text$mn:000057D1                 call    ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:000057D6                 add     esp, 8
.text$mn:000057D9                 movzx   eax, al
.text$mn:000057DC                 test    eax, eax
.text$mn:000057DE                 jz      short loc_583F
.text$mn:000057E0                 mov     ecx, [ebp+var_14]
.text$mn:000057E3                 push    ecx
.text$mn:000057E4                 mov     ecx, [ebp+arg_0]
.text$mn:000057E7                 add     ecx, 0Ch
.text$mn:000057EA                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:000057EF                 mov     edx, [eax+94h]
.text$mn:000057F5                 push    edx
.text$mn:000057F6                 mov     eax, [eax+90h]
.text$mn:000057FC                 push    eax             ; __int64
.text$mn:000057FD                 mov     ecx, [ebp+var_14]
.text$mn:00005800                 push    ecx
.text$mn:00005801                 mov     ecx, [ebp+arg_0]
.text$mn:00005804                 add     ecx, 0Ch
.text$mn:00005807                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:0000580C                 add     eax, 74h ; 't'
.text$mn:0000580F                 mov     ecx, eax
.text$mn:00005811                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00005816                 push    eax             ; pszPath
.text$mn:00005817                 mov     edx, [ebp+var_14]
.text$mn:0000581A                 push    edx
.text$mn:0000581B                 mov     ecx, [ebp+arg_0]
.text$mn:0000581E                 add     ecx, 0Ch
.text$mn:00005821                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005826                 mov     eax, [eax+70h]
.text$mn:00005829                 push    eax             ; int
.text$mn:0000582A                 push    0               ; bool
.text$mn:0000582C                 push    0               ; bool
.text$mn:0000582E                 mov     ecx, [ebp+pszPath]
.text$mn:00005831                 push    ecx             ; lpFileName
.text$mn:00005832                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005835                 call    ?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)
.text$mn:0000583A                 mov     [ebp+var_20], eax
.text$mn:0000583D                 jmp     short loc_586B
.text$mn:0000583F ; ---------------------------------------------------------------------------
.text$mn:0000583F
.text$mn:0000583F loc_583F:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+18Bj
.text$mn:0000583F                                         ; Notepad_plus::loadSession(Session &,bool)+1B6j
.text$mn:0000583F                 push    0
.text$mn:00005841                 push    0               ; __int64
.text$mn:00005843                 push    0               ; pszPath
.text$mn:00005845                 mov     edx, [ebp+var_14]
.text$mn:00005848                 push    edx
.text$mn:00005849                 mov     ecx, [ebp+arg_0]
.text$mn:0000584C                 add     ecx, 0Ch
.text$mn:0000584F                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005854                 mov     eax, [eax+70h]
.text$mn:00005857                 push    eax             ; int
.text$mn:00005858                 push    0               ; bool
.text$mn:0000585A                 push    0               ; bool
.text$mn:0000585C                 mov     ecx, [ebp+pszPath]
.text$mn:0000585F                 push    ecx             ; lpFileName
.text$mn:00005860                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005863                 call    ?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)
.text$mn:00005868                 mov     [ebp+var_20], eax
.text$mn:0000586B
.text$mn:0000586B loc_586B:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+215j
.text$mn:0000586B                 jmp     loc_5906
.text$mn:00005870 ; ---------------------------------------------------------------------------
.text$mn:00005870
.text$mn:00005870 loc_5870:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+17Fj
.text$mn:00005870                 movzx   edx, [ebp+arg_4]
.text$mn:00005874                 test    edx, edx
.text$mn:00005876                 jz      loc_58FF
.text$mn:0000587C                 mov     eax, [ebp+var_14]
.text$mn:0000587F                 push    eax
.text$mn:00005880                 mov     ecx, [ebp+arg_0]
.text$mn:00005883                 add     ecx, 0Ch
.text$mn:00005886                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:0000588B                 add     eax, 74h ; 't'
.text$mn:0000588E                 mov     ecx, eax
.text$mn:00005890                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00005895                 push    eax             ; pszPath
.text$mn:00005896                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:0000589C                 test    eax, eax
.text$mn:0000589E                 jz      short loc_58FF
.text$mn:000058A0                 mov     ecx, [ebp+var_14]
.text$mn:000058A3                 push    ecx
.text$mn:000058A4                 mov     ecx, [ebp+arg_0]
.text$mn:000058A7                 add     ecx, 0Ch
.text$mn:000058AA                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:000058AF                 mov     edx, [eax+94h]
.text$mn:000058B5                 push    edx
.text$mn:000058B6                 mov     eax, [eax+90h]
.text$mn:000058BC                 push    eax             ; __int64
.text$mn:000058BD                 mov     ecx, [ebp+var_14]
.text$mn:000058C0                 push    ecx
.text$mn:000058C1                 mov     ecx, [ebp+arg_0]
.text$mn:000058C4                 add     ecx, 0Ch
.text$mn:000058C7                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:000058CC                 add     eax, 74h ; 't'
.text$mn:000058CF                 mov     ecx, eax
.text$mn:000058D1                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000058D6                 push    eax             ; pszPath
.text$mn:000058D7                 mov     edx, [ebp+var_14]
.text$mn:000058DA                 push    edx
.text$mn:000058DB                 mov     ecx, [ebp+arg_0]
.text$mn:000058DE                 add     ecx, 0Ch
.text$mn:000058E1                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:000058E6                 mov     eax, [eax+70h]
.text$mn:000058E9                 push    eax             ; int
.text$mn:000058EA                 push    0               ; bool
.text$mn:000058EC                 push    0               ; bool
.text$mn:000058EE                 mov     ecx, [ebp+pszPath]
.text$mn:000058F1                 push    ecx             ; lpFileName
.text$mn:000058F2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000058F5                 call    ?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)
.text$mn:000058FA                 mov     [ebp+var_20], eax
.text$mn:000058FD                 jmp     short loc_5906
.text$mn:000058FF ; ---------------------------------------------------------------------------
.text$mn:000058FF
.text$mn:000058FF loc_58FF:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+24Ej
.text$mn:000058FF                                         ; Notepad_plus::loadSession(Session &,bool)+276j
.text$mn:000058FF                 mov     [ebp+var_20], 0
.text$mn:00005906
.text$mn:00005906 loc_5906:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool):loc_586Bj
.text$mn:00005906                                         ; Notepad_plus::loadSession(Session &,bool)+2D5j
.text$mn:00005906                 movzx   edx, [ebp+var_1A]
.text$mn:0000590A                 test    edx, edx
.text$mn:0000590C                 jz      short loc_591C
.text$mn:0000590E                 push    1               ; int
.text$mn:00005910                 mov     ecx, [ebp+var_38] ; this
.text$mn:00005913                 call    ?safeWow64EnableWow64FsRedirection@NppParameters@@QAEXH@Z ; NppParameters::safeWow64EnableWow64FsRedirection(int)
.text$mn:00005918                 mov     [ebp+var_1A], 0
.text$mn:0000591C
.text$mn:0000591C loc_591C:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+2E4j
.text$mn:0000591C                 cmp     [ebp+var_20], 0
.text$mn:00005920                 jz      loc_5B91
.text$mn:00005926                 push    0               ; int
.text$mn:00005928                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000592B                 call    ?showView@Notepad_plus@@AAEXH@Z ; Notepad_plus::showView(int)
.text$mn:00005930                 mov     eax, [ebp+var_14]
.text$mn:00005933                 push    eax
.text$mn:00005934                 mov     ecx, [ebp+arg_0]
.text$mn:00005937                 add     ecx, 0Ch
.text$mn:0000593A                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:0000593F                 add     eax, 34h ; '4'
.text$mn:00005942                 mov     ecx, eax
.text$mn:00005944                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00005949                 mov     [ebp+var_5C], eax
.text$mn:0000594C                 mov     ecx, [ebp+var_5C]
.text$mn:0000594F                 push    ecx             ; wchar_t *
.text$mn:00005950                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005953                 call    ?getLangFromMenuName@Notepad_plus@@AAEHPB_W@Z ; Notepad_plus::getLangFromMenuName(wchar_t const *)
.text$mn:00005958                 mov     [ebp+var_48], eax
.text$mn:0000595B                 mov     [ebp+var_40], 0
.text$mn:00005962                 cmp     [ebp+var_48], 0
.text$mn:00005966                 jz      short loc_5980
.text$mn:00005968                 cmp     [ebp+var_48], 0B400h
.text$mn:0000596F                 jz      short loc_5980
.text$mn:00005971                 mov     edx, [ebp+var_48]
.text$mn:00005974                 push    edx
.text$mn:00005975                 mov     ecx, [ebp+var_10]
.text$mn:00005978                 call    ?menuID2LangType@Notepad_plus@@AAE?AW4LangType@@H@Z ; Notepad_plus::menuID2LangType(int)
.text$mn:0000597D                 mov     [ebp+var_40], eax
.text$mn:00005980
.text$mn:00005980 loc_5980:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+33Ej
.text$mn:00005980                                         ; Notepad_plus::loadSession(Session &,bool)+347j
.text$mn:00005980                 cmp     [ebp+var_40], 39h ; '9'
.text$mn:00005984                 jnz     short loc_5991
.text$mn:00005986                 mov     eax, [ebp+var_48]
.text$mn:00005989                 sub     eax, 0B3B8h
.text$mn:0000598E                 mov     [ebp+var_40], eax
.text$mn:00005991
.text$mn:00005991 loc_5991:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+35Cj
.text$mn:00005991                 mov     ecx, [ebp+var_20]
.text$mn:00005994                 push    ecx             ; struct Buffer *
.text$mn:00005995                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:0000599A                 mov     ecx, eax        ; this
.text$mn:0000599C                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:000059A1                 mov     [ebp+var_24], eax
.text$mn:000059A4                 mov     edx, [ebp+var_14]
.text$mn:000059A7                 push    edx
.text$mn:000059A8                 mov     ecx, [ebp+arg_0]
.text$mn:000059AB                 add     ecx, 0Ch
.text$mn:000059AE                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:000059B3                 add     eax, 60h ; '`'
.text$mn:000059B6                 mov     ecx, eax
.text$mn:000059B8                 call    ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<uint,std::allocator<uint>>::size(void)
.text$mn:000059BD                 test    eax, eax
.text$mn:000059BF                 jbe     short loc_5A01
.text$mn:000059C1                 mov     ecx, [ebp+var_10]
.text$mn:000059C4                 add     ecx, 4C0h       ; this
.text$mn:000059CA                 call    ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBuffer(void)
.text$mn:000059CF                 cmp     [ebp+var_24], eax
.text$mn:000059D2                 jnz     short loc_59DC
.text$mn:000059D4                 mov     eax, [ebp+var_14]
.text$mn:000059D7                 mov     [ebp+var_50], eax
.text$mn:000059DA                 jmp     short loc_5A01
.text$mn:000059DC ; ---------------------------------------------------------------------------
.text$mn:000059DC
.text$mn:000059DC loc_59DC:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+3AAj
.text$mn:000059DC                 mov     ecx, [ebp+var_10]
.text$mn:000059DF                 add     ecx, 4C0h
.text$mn:000059E5                 push    ecx
.text$mn:000059E6                 mov     edx, [ebp+var_14]
.text$mn:000059E9                 push    edx
.text$mn:000059EA                 mov     ecx, [ebp+arg_0]
.text$mn:000059ED                 add     ecx, 0Ch
.text$mn:000059F0                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:000059F5                 add     eax, 60h ; '`'
.text$mn:000059F8                 push    eax
.text$mn:000059F9                 mov     ecx, [ebp+var_24]
.text$mn:000059FC                 call    ?setHeaderLineState@Buffer@@QAEXABV?$vector@IV?$allocator@I@std@@@std@@PAVScintillaEditView@@@Z ; Buffer::setHeaderLineState(std::vector<uint,std::allocator<uint>> const &,ScintillaEditView *)
.text$mn:00005A01
.text$mn:00005A01 loc_5A01:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+397j
.text$mn:00005A01                                         ; Notepad_plus::loadSession(Session &,bool)+3B2j
.text$mn:00005A01                 mov     eax, [ebp+var_10]
.text$mn:00005A04                 add     eax, 4C0h
.text$mn:00005A09                 push    eax             ; struct ScintillaEditView *
.text$mn:00005A0A                 mov     ecx, [ebp+var_14]
.text$mn:00005A0D                 push    ecx
.text$mn:00005A0E                 mov     ecx, [ebp+arg_0]
.text$mn:00005A11                 add     ecx, 0Ch
.text$mn:00005A14                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005A19                 push    eax             ; struct Position *
.text$mn:00005A1A                 mov     ecx, [ebp+var_24] ; this
.text$mn:00005A1D                 call    ?setPosition@Buffer@@QAEXABUPosition@@PAVScintillaEditView@@@Z ; Buffer::setPosition(Position const &,ScintillaEditView *)
.text$mn:00005A22                 mov     edx, [ebp+var_5C]
.text$mn:00005A25                 push    edx
.text$mn:00005A26                 mov     eax, [ebp+var_40]
.text$mn:00005A29                 push    eax
.text$mn:00005A2A                 mov     ecx, [ebp+var_24]
.text$mn:00005A2D                 call    ?setLangType@Buffer@@QAEXW4LangType@@PB_W@Z ; Buffer::setLangType(LangType,wchar_t const *)
.text$mn:00005A32                 mov     ecx, [ebp+var_14]
.text$mn:00005A35                 push    ecx
.text$mn:00005A36                 mov     ecx, [ebp+arg_0]
.text$mn:00005A39                 add     ecx, 0Ch
.text$mn:00005A3C                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005A41                 cmp     dword ptr [eax+70h], 0FFFFFFFFh
.text$mn:00005A45                 jz      short loc_5A62
.text$mn:00005A47                 mov     edx, [ebp+var_14]
.text$mn:00005A4A                 push    edx
.text$mn:00005A4B                 mov     ecx, [ebp+arg_0]
.text$mn:00005A4E                 add     ecx, 0Ch
.text$mn:00005A51                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005A56                 mov     eax, [eax+70h]
.text$mn:00005A59                 push    eax             ; int
.text$mn:00005A5A                 mov     ecx, [ebp+var_24] ; this
.text$mn:00005A5D                 call    ?setEncoding@Buffer@@QAEXH@Z ; Buffer::setEncoding(int)
.text$mn:00005A62
.text$mn:00005A62 loc_5A62:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+41Dj
.text$mn:00005A62                 movzx   ecx, [ebp+arg_4]
.text$mn:00005A66                 test    ecx, ecx
.text$mn:00005A68                 jz      short loc_5ABF
.text$mn:00005A6A                 push    offset $SG177334 ; Str
.text$mn:00005A6F                 mov     edx, [ebp+var_14]
.text$mn:00005A72                 push    edx
.text$mn:00005A73                 mov     ecx, [ebp+arg_0]
.text$mn:00005A76                 add     ecx, 0Ch
.text$mn:00005A79                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005A7E                 add     eax, 74h ; 't'
.text$mn:00005A81                 push    eax             ; int
.text$mn:00005A82                 call    ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00005A87                 add     esp, 8
.text$mn:00005A8A                 movzx   eax, al
.text$mn:00005A8D                 test    eax, eax
.text$mn:00005A8F                 jz      short loc_5ABF
.text$mn:00005A91                 mov     ecx, [ebp+var_14]
.text$mn:00005A94                 push    ecx
.text$mn:00005A95                 mov     ecx, [ebp+arg_0]
.text$mn:00005A98                 add     ecx, 0Ch
.text$mn:00005A9B                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005AA0                 add     eax, 74h ; 't'
.text$mn:00005AA3                 mov     ecx, eax
.text$mn:00005AA5                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00005AAA                 push    eax             ; pszPath
.text$mn:00005AAB                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:00005AB1                 test    eax, eax
.text$mn:00005AB3                 jz      short loc_5ABF
.text$mn:00005AB5                 push    1               ; bool
.text$mn:00005AB7                 mov     ecx, [ebp+var_24] ; this
.text$mn:00005ABA                 call    ?setDirty@Buffer@@QAEX_N@Z ; Buffer::setDirty(bool)
.text$mn:00005ABF
.text$mn:00005ABF loc_5ABF:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+440j
.text$mn:00005ABF                                         ; Notepad_plus::loadSession(Session &,bool)+467j ...
.text$mn:00005ABF                 push    0               ; __int32
.text$mn:00005AC1                 push    0               ; unsigned int
.text$mn:00005AC3                 push    935h            ; unsigned int
.text$mn:00005AC8                 mov     ecx, [ebp+var_10]
.text$mn:00005ACB                 add     ecx, 4C0h       ; this
.text$mn:00005AD1                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00005AD6                 mov     [ebp+var_88], eax
.text$mn:00005ADC                 mov     ecx, [ebp+var_24] ; this
.text$mn:00005ADF                 call    ?getDocument@Buffer@@QAEJXZ ; Buffer::getDocument(void)
.text$mn:00005AE4                 push    eax             ; __int32
.text$mn:00005AE5                 push    0               ; unsigned int
.text$mn:00005AE7                 push    936h            ; unsigned int
.text$mn:00005AEC                 mov     ecx, [ebp+var_10]
.text$mn:00005AEF                 add     ecx, 4C0h       ; this
.text$mn:00005AF5                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00005AFA                 mov     [ebp+var_4C], 0
.text$mn:00005B01                 mov     edx, [ebp+var_14]
.text$mn:00005B04                 push    edx
.text$mn:00005B05                 mov     ecx, [ebp+arg_0]
.text$mn:00005B08                 add     ecx, 0Ch
.text$mn:00005B0B                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005B10                 add     eax, 50h ; 'P'
.text$mn:00005B13                 mov     ecx, eax
.text$mn:00005B15                 call    ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<uint,std::allocator<uint>>::size(void)
.text$mn:00005B1A                 mov     [ebp+var_70], eax
.text$mn:00005B1D                 jmp     short loc_5B28
.text$mn:00005B1F ; ---------------------------------------------------------------------------
.text$mn:00005B1F
.text$mn:00005B1F loc_5B1F:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+53Dj
.text$mn:00005B1F                 mov     eax, [ebp+var_4C]
.text$mn:00005B22                 add     eax, 1
.text$mn:00005B25                 mov     [ebp+var_4C], eax
.text$mn:00005B28
.text$mn:00005B28 loc_5B28:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+4F5j
.text$mn:00005B28                 mov     ecx, [ebp+var_4C]
.text$mn:00005B2B                 cmp     ecx, [ebp+var_70]
.text$mn:00005B2E                 jnb     short loc_5B67
.text$mn:00005B30                 push    18h             ; __int32
.text$mn:00005B32                 mov     edx, [ebp+var_4C]
.text$mn:00005B35                 push    edx
.text$mn:00005B36                 mov     eax, [ebp+var_14]
.text$mn:00005B39                 push    eax
.text$mn:00005B3A                 mov     ecx, [ebp+arg_0]
.text$mn:00005B3D                 add     ecx, 0Ch
.text$mn:00005B40                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005B45                 add     eax, 50h ; 'P'
.text$mn:00005B48                 mov     ecx, eax
.text$mn:00005B4A                 call    ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ; std::vector<uint,std::allocator<uint>>::operator[](uint)
.text$mn:00005B4F                 mov     ecx, [eax]
.text$mn:00005B51                 push    ecx             ; unsigned int
.text$mn:00005B52                 push    7FBh            ; unsigned int
.text$mn:00005B57                 mov     ecx, [ebp+var_10]
.text$mn:00005B5A                 add     ecx, 4C0h       ; this
.text$mn:00005B60                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00005B65                 jmp     short loc_5B1F
.text$mn:00005B67 ; ---------------------------------------------------------------------------
.text$mn:00005B67
.text$mn:00005B67 loc_5B67:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+506j
.text$mn:00005B67                 mov     edx, [ebp+var_88]
.text$mn:00005B6D                 push    edx             ; __int32
.text$mn:00005B6E                 push    0               ; unsigned int
.text$mn:00005B70                 push    936h            ; unsigned int
.text$mn:00005B75                 mov     ecx, [ebp+var_10]
.text$mn:00005B78                 add     ecx, 4C0h       ; this
.text$mn:00005B7E                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00005B83                 mov     eax, [ebp+var_14]
.text$mn:00005B86                 add     eax, 1
.text$mn:00005B89                 mov     [ebp+var_14], eax
.text$mn:00005B8C                 jmp     loc_5C3F
.text$mn:00005B91 ; ---------------------------------------------------------------------------
.text$mn:00005B91
.text$mn:00005B91 loc_5B91:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+2F8j
.text$mn:00005B91                 mov     ecx, [ebp+var_14]
.text$mn:00005B94                 push    ecx
.text$mn:00005B95                 lea     edx, [ebp+var_BC]
.text$mn:00005B9B                 push    edx
.text$mn:00005B9C                 lea     eax, [ebp+var_150]
.text$mn:00005BA2                 push    eax
.text$mn:00005BA3                 mov     ecx, [ebp+arg_0]
.text$mn:00005BA6                 add     ecx, 0Ch
.text$mn:00005BA9                 call    ?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::begin(void)
.text$mn:00005BAE                 mov     [ebp+var_78], eax
.text$mn:00005BB1                 mov     ecx, [ebp+var_78]
.text$mn:00005BB4                 mov     [ebp+var_98], ecx
.text$mn:00005BBA                 mov     [ebp+var_4], 4
.text$mn:00005BC1                 mov     ecx, [ebp+var_98]
.text$mn:00005BC7                 call    ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+(int)
.text$mn:00005BCC                 mov     byte ptr [ebp+var_4], 6
.text$mn:00005BD0                 lea     ecx, [ebp+var_150]
.text$mn:00005BD6                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:00005BDB                 sub     esp, 0Ch
.text$mn:00005BDE                 mov     ecx, esp
.text$mn:00005BE0                 mov     [ebp+var_C0], esp
.text$mn:00005BE6                 lea     edx, [ebp+var_BC]
.text$mn:00005BEC                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005BED                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>> const &)
.text$mn:00005BF2                 mov     [ebp+var_80], eax
.text$mn:00005BF5                 mov     eax, [ebp+var_80]
.text$mn:00005BF8                 mov     [ebp+var_A0], eax
.text$mn:00005BFE                 mov     byte ptr [ebp+var_4], 7
.text$mn:00005C02                 lea     ecx, [ebp+var_138]
.text$mn:00005C08                 push    ecx
.text$mn:00005C09                 mov     ecx, [ebp+arg_0]
.text$mn:00005C0C                 add     ecx, 0Ch
.text$mn:00005C0F                 mov     byte ptr [ebp+var_4], 6
.text$mn:00005C13                 call    ?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)
.text$mn:00005C18                 mov     [ebp+var_D0], eax
.text$mn:00005C1E                 lea     ecx, [ebp+var_138]
.text$mn:00005C24                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:00005C29                 mov     [ebp+var_19], 0
.text$mn:00005C2D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005C34                 lea     ecx, [ebp+var_BC]
.text$mn:00005C3A                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:00005C3F
.text$mn:00005C3F loc_5C3F:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+564j
.text$mn:00005C3F                 jmp     loc_5688
.text$mn:00005C44 ; ---------------------------------------------------------------------------
.text$mn:00005C44
.text$mn:00005C44 loc_5C44:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+6Bj
.text$mn:00005C44                 cmp     [ebp+var_50], 0FFFFFFFFh
.text$mn:00005C48                 jz      short loc_5C6B
.text$mn:00005C4A                 mov     edx, [ebp+var_50]
.text$mn:00005C4D                 push    edx
.text$mn:00005C4E                 mov     ecx, [ebp+arg_0]
.text$mn:00005C51                 add     ecx, 0Ch
.text$mn:00005C54                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005C59                 add     eax, 60h ; '`'
.text$mn:00005C5C                 push    eax
.text$mn:00005C5D                 mov     ecx, [ebp+var_10]
.text$mn:00005C60                 add     ecx, 4C0h
.text$mn:00005C66                 call    ?syncFoldStateWith@ScintillaEditView@@QAEXABV?$vector@IV?$allocator@I@std@@@std@@@Z ; ScintillaEditView::syncFoldStateWith(std::vector<uint,std::allocator<uint>> const &)
.text$mn:00005C6B
.text$mn:00005C6B loc_5C6B:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+620j
.text$mn:00005C6B                 push    1               ; int
.text$mn:00005C6D                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005C70                 call    ?showView@Notepad_plus@@AAEXH@Z ; Notepad_plus::showView(int)
.text$mn:00005C75                 push    1               ; int
.text$mn:00005C77                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005C7A                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:00005C7F                 mov     [ebp+var_54], 0FFFFFFFFh
.text$mn:00005C86                 mov     [ebp+var_18], 0
.text$mn:00005C8D
.text$mn:00005C8D loc_5C8D:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+74Dj
.text$mn:00005C8D                                         ; Notepad_plus::loadSession(Session &,bool):loc_628Ej
.text$mn:00005C8D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005C90                 call    ?nbSubFiles@Session@@QBEIXZ ; Session::nbSubFiles(void)
.text$mn:00005C95                 cmp     [ebp+var_18], eax
.text$mn:00005C98                 jnb     loc_6293
.text$mn:00005C9E                 mov     eax, [ebp+var_18]
.text$mn:00005CA1                 push    eax
.text$mn:00005CA2                 mov     ecx, [ebp+arg_0]
.text$mn:00005CA5                 add     ecx, 1Ch
.text$mn:00005CA8                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005CAD                 add     eax, 18h
.text$mn:00005CB0                 mov     ecx, eax
.text$mn:00005CB2                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00005CB7                 mov     [ebp+lpFileName], eax
.text$mn:00005CBA                 mov     ecx, [ebp+lpFileName]
.text$mn:00005CBD                 push    ecx             ; wchar_t *
.text$mn:00005CBE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005CC1                 call    ?isFileSession@Notepad_plus@@QAE_NPB_W@Z ; Notepad_plus::isFileSession(wchar_t const *)
.text$mn:00005CC6                 movzx   edx, al
.text$mn:00005CC9                 test    edx, edx
.text$mn:00005CCB                 jz      loc_5D7A
.text$mn:00005CD1                 mov     eax, [ebp+var_18]
.text$mn:00005CD4                 push    eax
.text$mn:00005CD5                 lea     ecx, [ebp+var_CC]
.text$mn:00005CDB                 push    ecx
.text$mn:00005CDC                 lea     edx, [ebp+var_114]
.text$mn:00005CE2                 push    edx
.text$mn:00005CE3                 mov     ecx, [ebp+arg_0]
.text$mn:00005CE6                 add     ecx, 1Ch
.text$mn:00005CE9                 call    ?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::begin(void)
.text$mn:00005CEE                 mov     [ebp+var_60], eax
.text$mn:00005CF1                 mov     eax, [ebp+var_60]
.text$mn:00005CF4                 mov     [ebp+var_6C], eax
.text$mn:00005CF7                 mov     [ebp+var_4], 8
.text$mn:00005CFE                 mov     ecx, [ebp+var_6C]
.text$mn:00005D01                 call    ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+(int)
.text$mn:00005D06                 mov     byte ptr [ebp+var_4], 0Ah
.text$mn:00005D0A                 lea     ecx, [ebp+var_114]
.text$mn:00005D10                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:00005D15                 sub     esp, 0Ch
.text$mn:00005D18                 mov     ecx, esp
.text$mn:00005D1A                 mov     [ebp+var_F4], esp
.text$mn:00005D20                 lea     edx, [ebp+var_CC]
.text$mn:00005D26                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005D27                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>> const &)
.text$mn:00005D2C                 mov     [ebp+var_74], eax
.text$mn:00005D2F                 mov     eax, [ebp+var_74]
.text$mn:00005D32                 mov     [ebp+var_E0], eax
.text$mn:00005D38                 mov     byte ptr [ebp+var_4], 0Bh
.text$mn:00005D3C                 lea     ecx, [ebp+var_12C]
.text$mn:00005D42                 push    ecx
.text$mn:00005D43                 mov     ecx, [ebp+arg_0]
.text$mn:00005D46                 add     ecx, 1Ch
.text$mn:00005D49                 mov     byte ptr [ebp+var_4], 0Ah
.text$mn:00005D4D                 call    ?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)
.text$mn:00005D52                 mov     [ebp+var_FC], eax
.text$mn:00005D58                 lea     ecx, [ebp+var_12C]
.text$mn:00005D5E                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:00005D63                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005D6A                 lea     ecx, [ebp+var_CC]
.text$mn:00005D70                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:00005D75                 jmp     loc_5C8D
.text$mn:00005D7A ; ---------------------------------------------------------------------------
.text$mn:00005D7A
.text$mn:00005D7A loc_5D7A:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+6A3j
.text$mn:00005D7A                 mov     [ebp+var_1B], 0
.text$mn:00005D7E                 mov     edx, [ebp+lpFileName]
.text$mn:00005D81                 push    edx             ; pszPath
.text$mn:00005D82                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:00005D88                 test    eax, eax
.text$mn:00005D8A                 jnz     short loc_5D9A
.text$mn:00005D8C                 push    0               ; int
.text$mn:00005D8E                 mov     ecx, [ebp+var_38] ; this
.text$mn:00005D91                 call    ?safeWow64EnableWow64FsRedirection@NppParameters@@QAEXH@Z ; NppParameters::safeWow64EnableWow64FsRedirection(int)
.text$mn:00005D96                 mov     [ebp+var_1B], 1
.text$mn:00005D9A
.text$mn:00005D9A loc_5D9A:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+762j
.text$mn:00005D9A                 mov     eax, [ebp+lpFileName]
.text$mn:00005D9D                 push    eax             ; pszPath
.text$mn:00005D9E                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:00005DA4                 test    eax, eax
.text$mn:00005DA6                 jz      loc_5E96
.text$mn:00005DAC                 movzx   ecx, [ebp+arg_4]
.text$mn:00005DB0                 test    ecx, ecx
.text$mn:00005DB2                 jz      loc_5E3E
.text$mn:00005DB8                 push    offset $SG177388 ; Str
.text$mn:00005DBD                 mov     edx, [ebp+var_18]
.text$mn:00005DC0                 push    edx
.text$mn:00005DC1                 mov     ecx, [ebp+arg_0]
.text$mn:00005DC4                 add     ecx, 1Ch
.text$mn:00005DC7                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005DCC                 add     eax, 74h ; 't'
.text$mn:00005DCF                 push    eax             ; int
.text$mn:00005DD0                 call    ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00005DD5                 add     esp, 8
.text$mn:00005DD8                 movzx   eax, al
.text$mn:00005DDB                 test    eax, eax
.text$mn:00005DDD                 jz      short loc_5E3E
.text$mn:00005DDF                 mov     ecx, [ebp+var_18]
.text$mn:00005DE2                 push    ecx
.text$mn:00005DE3                 mov     ecx, [ebp+arg_0]
.text$mn:00005DE6                 add     ecx, 1Ch
.text$mn:00005DE9                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005DEE                 mov     edx, [eax+94h]
.text$mn:00005DF4                 push    edx
.text$mn:00005DF5                 mov     eax, [eax+90h]
.text$mn:00005DFB                 push    eax             ; __int64
.text$mn:00005DFC                 mov     ecx, [ebp+var_18]
.text$mn:00005DFF                 push    ecx
.text$mn:00005E00                 mov     ecx, [ebp+arg_0]
.text$mn:00005E03                 add     ecx, 1Ch
.text$mn:00005E06                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005E0B                 add     eax, 74h ; 't'
.text$mn:00005E0E                 mov     ecx, eax
.text$mn:00005E10                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00005E15                 push    eax             ; pszPath
.text$mn:00005E16                 mov     edx, [ebp+var_18]
.text$mn:00005E19                 push    edx
.text$mn:00005E1A                 mov     ecx, [ebp+arg_0]
.text$mn:00005E1D                 add     ecx, 1Ch
.text$mn:00005E20                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005E25                 mov     eax, [eax+70h]
.text$mn:00005E28                 push    eax             ; int
.text$mn:00005E29                 push    0               ; bool
.text$mn:00005E2B                 push    0               ; bool
.text$mn:00005E2D                 mov     ecx, [ebp+lpFileName]
.text$mn:00005E30                 push    ecx             ; lpFileName
.text$mn:00005E31                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005E34                 call    ?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)
.text$mn:00005E39                 mov     [ebp+var_20], eax
.text$mn:00005E3C                 jmp     short loc_5E6A
.text$mn:00005E3E ; ---------------------------------------------------------------------------
.text$mn:00005E3E
.text$mn:00005E3E loc_5E3E:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+78Aj
.text$mn:00005E3E                                         ; Notepad_plus::loadSession(Session &,bool)+7B5j
.text$mn:00005E3E                 push    0
.text$mn:00005E40                 push    0               ; __int64
.text$mn:00005E42                 push    0               ; pszPath
.text$mn:00005E44                 mov     edx, [ebp+var_18]
.text$mn:00005E47                 push    edx
.text$mn:00005E48                 mov     ecx, [ebp+arg_0]
.text$mn:00005E4B                 add     ecx, 1Ch
.text$mn:00005E4E                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005E53                 mov     eax, [eax+70h]
.text$mn:00005E56                 push    eax             ; int
.text$mn:00005E57                 push    0               ; bool
.text$mn:00005E59                 push    0               ; bool
.text$mn:00005E5B                 mov     ecx, [ebp+lpFileName]
.text$mn:00005E5E                 push    ecx             ; lpFileName
.text$mn:00005E5F                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005E62                 call    ?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)
.text$mn:00005E67                 mov     [ebp+var_20], eax
.text$mn:00005E6A
.text$mn:00005E6A loc_5E6A:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+814j
.text$mn:00005E6A                 mov     edx, [ebp+var_20]
.text$mn:00005E6D                 push    edx             ; struct Buffer *
.text$mn:00005E6E                 mov     ecx, [ebp+var_10]
.text$mn:00005E71                 add     ecx, 35Ch       ; this
.text$mn:00005E77                 call    ?getIndexByBuffer@DocTabView@@QAEHPAVBuffer@@@Z ; DocTabView::getIndexByBuffer(Buffer *)
.text$mn:00005E7C                 cmp     eax, 0FFFFFFFFh
.text$mn:00005E7F                 jz      short loc_5E91
.text$mn:00005E81                 push    0               ; bool
.text$mn:00005E83                 push    1               ; int
.text$mn:00005E85                 mov     eax, [ebp+var_20]
.text$mn:00005E88                 push    eax             ; struct Buffer *
.text$mn:00005E89                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005E8C                 call    ?loadBufferIntoView@Notepad_plus@@AAEXPAVBuffer@@H_N@Z ; Notepad_plus::loadBufferIntoView(Buffer *,int,bool)
.text$mn:00005E91
.text$mn:00005E91 loc_5E91:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+857j
.text$mn:00005E91                 jmp     loc_5F2C
.text$mn:00005E96 ; ---------------------------------------------------------------------------
.text$mn:00005E96
.text$mn:00005E96 loc_5E96:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+77Ej
.text$mn:00005E96                 movzx   ecx, [ebp+arg_4]
.text$mn:00005E9A                 test    ecx, ecx
.text$mn:00005E9C                 jz      loc_5F25
.text$mn:00005EA2                 mov     edx, [ebp+var_18]
.text$mn:00005EA5                 push    edx
.text$mn:00005EA6                 mov     ecx, [ebp+arg_0]
.text$mn:00005EA9                 add     ecx, 1Ch
.text$mn:00005EAC                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005EB1                 add     eax, 74h ; 't'
.text$mn:00005EB4                 mov     ecx, eax
.text$mn:00005EB6                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00005EBB                 push    eax             ; pszPath
.text$mn:00005EBC                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:00005EC2                 test    eax, eax
.text$mn:00005EC4                 jz      short loc_5F25
.text$mn:00005EC6                 mov     eax, [ebp+var_18]
.text$mn:00005EC9                 push    eax
.text$mn:00005ECA                 mov     ecx, [ebp+arg_0]
.text$mn:00005ECD                 add     ecx, 1Ch
.text$mn:00005ED0                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005ED5                 mov     ecx, [eax+94h]
.text$mn:00005EDB                 push    ecx
.text$mn:00005EDC                 mov     edx, [eax+90h]
.text$mn:00005EE2                 push    edx             ; __int64
.text$mn:00005EE3                 mov     eax, [ebp+var_18]
.text$mn:00005EE6                 push    eax
.text$mn:00005EE7                 mov     ecx, [ebp+arg_0]
.text$mn:00005EEA                 add     ecx, 1Ch
.text$mn:00005EED                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005EF2                 add     eax, 74h ; 't'
.text$mn:00005EF5                 mov     ecx, eax
.text$mn:00005EF7                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00005EFC                 push    eax             ; pszPath
.text$mn:00005EFD                 mov     ecx, [ebp+var_18]
.text$mn:00005F00                 push    ecx
.text$mn:00005F01                 mov     ecx, [ebp+arg_0]
.text$mn:00005F04                 add     ecx, 1Ch
.text$mn:00005F07                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005F0C                 mov     edx, [eax+70h]
.text$mn:00005F0F                 push    edx             ; int
.text$mn:00005F10                 push    0               ; bool
.text$mn:00005F12                 push    0               ; bool
.text$mn:00005F14                 mov     eax, [ebp+lpFileName]
.text$mn:00005F17                 push    eax             ; lpFileName
.text$mn:00005F18                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005F1B                 call    ?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)
.text$mn:00005F20                 mov     [ebp+var_20], eax
.text$mn:00005F23                 jmp     short loc_5F2C
.text$mn:00005F25 ; ---------------------------------------------------------------------------
.text$mn:00005F25
.text$mn:00005F25 loc_5F25:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+874j
.text$mn:00005F25                                         ; Notepad_plus::loadSession(Session &,bool)+89Cj
.text$mn:00005F25                 mov     [ebp+var_20], 0
.text$mn:00005F2C
.text$mn:00005F2C loc_5F2C:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool):loc_5E91j
.text$mn:00005F2C                                         ; Notepad_plus::loadSession(Session &,bool)+8FBj
.text$mn:00005F2C                 movzx   ecx, [ebp+var_1B]
.text$mn:00005F30                 test    ecx, ecx
.text$mn:00005F32                 jz      short loc_5F42
.text$mn:00005F34                 push    1               ; int
.text$mn:00005F36                 mov     ecx, [ebp+var_38] ; this
.text$mn:00005F39                 call    ?safeWow64EnableWow64FsRedirection@NppParameters@@QAEXH@Z ; NppParameters::safeWow64EnableWow64FsRedirection(int)
.text$mn:00005F3E                 mov     [ebp+var_1B], 0
.text$mn:00005F42
.text$mn:00005F42 loc_5F42:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+90Aj
.text$mn:00005F42                 cmp     [ebp+var_20], 0
.text$mn:00005F46                 jz      loc_61D4
.text$mn:00005F4C                 push    1               ; int
.text$mn:00005F4E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005F51                 call    ?showView@Notepad_plus@@AAEXH@Z ; Notepad_plus::showView(int)
.text$mn:00005F56                 push    0               ; int
.text$mn:00005F58                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005F5B                 call    ?canHideView@Notepad_plus@@AAE_NH@Z ; Notepad_plus::canHideView(int)
.text$mn:00005F60                 movzx   edx, al
.text$mn:00005F63                 test    edx, edx
.text$mn:00005F65                 jz      short loc_5F71
.text$mn:00005F67                 push    0               ; int
.text$mn:00005F69                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005F6C                 call    ?hideView@Notepad_plus@@AAEXH@Z ; Notepad_plus::hideView(int)
.text$mn:00005F71
.text$mn:00005F71 loc_5F71:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+93Dj
.text$mn:00005F71                 mov     eax, [ebp+var_18]
.text$mn:00005F74                 push    eax
.text$mn:00005F75                 mov     ecx, [ebp+arg_0]
.text$mn:00005F78                 add     ecx, 1Ch
.text$mn:00005F7B                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005F80                 add     eax, 34h ; '4'
.text$mn:00005F83                 mov     ecx, eax
.text$mn:00005F85                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00005F8A                 mov     [ebp+lpString1], eax
.text$mn:00005F8D                 mov     ecx, [ebp+lpString1]
.text$mn:00005F90                 push    ecx             ; wchar_t *
.text$mn:00005F91                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005F94                 call    ?getLangFromMenuName@Notepad_plus@@AAEHPB_W@Z ; Notepad_plus::getLangFromMenuName(wchar_t const *)
.text$mn:00005F99                 mov     [ebp+var_58], eax
.text$mn:00005F9C                 mov     [ebp+var_34], 0
.text$mn:00005FA3                 cmp     [ebp+var_58], 0
.text$mn:00005FA7                 jz      short loc_5FB8
.text$mn:00005FA9                 mov     edx, [ebp+var_58]
.text$mn:00005FAC                 push    edx
.text$mn:00005FAD                 mov     ecx, [ebp+var_10]
.text$mn:00005FB0                 call    ?menuID2LangType@Notepad_plus@@AAE?AW4LangType@@H@Z ; Notepad_plus::menuID2LangType(int)
.text$mn:00005FB5                 mov     [ebp+var_34], eax
.text$mn:00005FB8
.text$mn:00005FB8 loc_5FB8:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+97Fj
.text$mn:00005FB8                 cmp     [ebp+var_34], 39h ; '9'
.text$mn:00005FBC                 jnz     short loc_5FC9
.text$mn:00005FBE                 mov     eax, [ebp+var_58]
.text$mn:00005FC1                 sub     eax, 0B3B8h
.text$mn:00005FC6                 mov     [ebp+var_34], eax
.text$mn:00005FC9
.text$mn:00005FC9 loc_5FC9:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+994j
.text$mn:00005FC9                 mov     ecx, [ebp+var_20]
.text$mn:00005FCC                 push    ecx             ; struct Buffer *
.text$mn:00005FCD                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00005FD2                 mov     ecx, eax        ; this
.text$mn:00005FD4                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00005FD9                 mov     [ebp+var_28], eax
.text$mn:00005FDC                 mov     edx, [ebp+var_18]
.text$mn:00005FDF                 push    edx
.text$mn:00005FE0                 mov     ecx, [ebp+arg_0]
.text$mn:00005FE3                 add     ecx, 1Ch
.text$mn:00005FE6                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00005FEB                 add     eax, 60h ; '`'
.text$mn:00005FEE                 mov     ecx, eax
.text$mn:00005FF0                 call    ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<uint,std::allocator<uint>>::size(void)
.text$mn:00005FF5                 test    eax, eax
.text$mn:00005FF7                 jbe     short loc_6039
.text$mn:00005FF9                 mov     ecx, [ebp+var_10]
.text$mn:00005FFC                 add     ecx, 464h       ; this
.text$mn:00006002                 call    ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBuffer(void)
.text$mn:00006007                 cmp     [ebp+var_28], eax
.text$mn:0000600A                 jnz     short loc_6014
.text$mn:0000600C                 mov     eax, [ebp+var_18]
.text$mn:0000600F                 mov     [ebp+var_54], eax
.text$mn:00006012                 jmp     short loc_6039
.text$mn:00006014 ; ---------------------------------------------------------------------------
.text$mn:00006014
.text$mn:00006014 loc_6014:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+9E2j
.text$mn:00006014                 mov     ecx, [ebp+var_10]
.text$mn:00006017                 add     ecx, 464h
.text$mn:0000601D                 push    ecx
.text$mn:0000601E                 mov     edx, [ebp+var_18]
.text$mn:00006021                 push    edx
.text$mn:00006022                 mov     ecx, [ebp+arg_0]
.text$mn:00006025                 add     ecx, 1Ch
.text$mn:00006028                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:0000602D                 add     eax, 60h ; '`'
.text$mn:00006030                 push    eax
.text$mn:00006031                 mov     ecx, [ebp+var_28]
.text$mn:00006034                 call    ?setHeaderLineState@Buffer@@QAEXABV?$vector@IV?$allocator@I@std@@@std@@PAVScintillaEditView@@@Z ; Buffer::setHeaderLineState(std::vector<uint,std::allocator<uint>> const &,ScintillaEditView *)
.text$mn:00006039
.text$mn:00006039 loc_6039:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+9CFj
.text$mn:00006039                                         ; Notepad_plus::loadSession(Session &,bool)+9EAj
.text$mn:00006039                 mov     eax, [ebp+var_10]
.text$mn:0000603C                 add     eax, 464h
.text$mn:00006041                 push    eax             ; struct ScintillaEditView *
.text$mn:00006042                 mov     ecx, [ebp+var_18]
.text$mn:00006045                 push    ecx
.text$mn:00006046                 mov     ecx, [ebp+arg_0]
.text$mn:00006049                 add     ecx, 1Ch
.text$mn:0000604C                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00006051                 push    eax             ; struct Position *
.text$mn:00006052                 mov     ecx, [ebp+var_28] ; this
.text$mn:00006055                 call    ?setPosition@Buffer@@QAEXABUPosition@@PAVScintillaEditView@@@Z ; Buffer::setPosition(Position const &,ScintillaEditView *)
.text$mn:0000605A                 cmp     [ebp+var_34], 0Fh
.text$mn:0000605E                 jnz     short loc_607A
.text$mn:00006060                 push    offset $SG177443 ; "User Defined"
.text$mn:00006065                 mov     edx, [ebp+lpString1]
.text$mn:00006068                 push    edx             ; lpString1
.text$mn:00006069                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:0000606F                 test    eax, eax
.text$mn:00006071                 jnz     short loc_607A
.text$mn:00006073                 mov     [ebp+lpString1], offset $SG177444
.text$mn:0000607A
.text$mn:0000607A loc_607A:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+A36j
.text$mn:0000607A                                         ; Notepad_plus::loadSession(Session &,bool)+A49j
.text$mn:0000607A                 mov     eax, [ebp+lpString1]
.text$mn:0000607D                 push    eax
.text$mn:0000607E                 mov     ecx, [ebp+var_34]
.text$mn:00006081                 push    ecx
.text$mn:00006082                 mov     ecx, [ebp+var_28]
.text$mn:00006085                 call    ?setLangType@Buffer@@QAEXW4LangType@@PB_W@Z ; Buffer::setLangType(LangType,wchar_t const *)
.text$mn:0000608A                 mov     edx, [ebp+var_18]
.text$mn:0000608D                 push    edx
.text$mn:0000608E                 mov     ecx, [ebp+arg_0]
.text$mn:00006091                 add     ecx, 1Ch
.text$mn:00006094                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00006099                 mov     eax, [eax+70h]
.text$mn:0000609C                 push    eax             ; int
.text$mn:0000609D                 mov     ecx, [ebp+var_28] ; this
.text$mn:000060A0                 call    ?setEncoding@Buffer@@QAEXH@Z ; Buffer::setEncoding(int)
.text$mn:000060A5                 movzx   ecx, [ebp+arg_4]
.text$mn:000060A9                 test    ecx, ecx
.text$mn:000060AB                 jz      short loc_6102
.text$mn:000060AD                 push    offset $SG177462 ; Str
.text$mn:000060B2                 mov     edx, [ebp+var_18]
.text$mn:000060B5                 push    edx
.text$mn:000060B6                 mov     ecx, [ebp+arg_0]
.text$mn:000060B9                 add     ecx, 1Ch
.text$mn:000060BC                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:000060C1                 add     eax, 74h ; 't'
.text$mn:000060C4                 push    eax             ; int
.text$mn:000060C5                 call    ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:000060CA                 add     esp, 8
.text$mn:000060CD                 movzx   eax, al
.text$mn:000060D0                 test    eax, eax
.text$mn:000060D2                 jz      short loc_6102
.text$mn:000060D4                 mov     ecx, [ebp+var_18]
.text$mn:000060D7                 push    ecx
.text$mn:000060D8                 mov     ecx, [ebp+arg_0]
.text$mn:000060DB                 add     ecx, 1Ch
.text$mn:000060DE                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:000060E3                 add     eax, 74h ; 't'
.text$mn:000060E6                 mov     ecx, eax
.text$mn:000060E8                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000060ED                 push    eax             ; pszPath
.text$mn:000060EE                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:000060F4                 test    eax, eax
.text$mn:000060F6                 jz      short loc_6102
.text$mn:000060F8                 push    1               ; bool
.text$mn:000060FA                 mov     ecx, [ebp+var_28] ; this
.text$mn:000060FD                 call    ?setDirty@Buffer@@QAEX_N@Z ; Buffer::setDirty(bool)
.text$mn:00006102
.text$mn:00006102 loc_6102:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+A83j
.text$mn:00006102                                         ; Notepad_plus::loadSession(Session &,bool)+AAAj ...
.text$mn:00006102                 push    0               ; __int32
.text$mn:00006104                 push    0               ; unsigned int
.text$mn:00006106                 push    935h            ; unsigned int
.text$mn:0000610B                 mov     ecx, [ebp+var_10]
.text$mn:0000610E                 add     ecx, 464h       ; this
.text$mn:00006114                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00006119                 mov     [ebp+var_84], eax
.text$mn:0000611F                 mov     ecx, [ebp+var_28] ; this
.text$mn:00006122                 call    ?getDocument@Buffer@@QAEJXZ ; Buffer::getDocument(void)
.text$mn:00006127                 push    eax             ; __int32
.text$mn:00006128                 push    0               ; unsigned int
.text$mn:0000612A                 push    936h            ; unsigned int
.text$mn:0000612F                 mov     ecx, [ebp+var_10]
.text$mn:00006132                 add     ecx, 464h       ; this
.text$mn:00006138                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000613D                 mov     [ebp+var_3C], 0
.text$mn:00006144                 mov     edx, [ebp+var_18]
.text$mn:00006147                 push    edx
.text$mn:00006148                 mov     ecx, [ebp+arg_0]
.text$mn:0000614B                 add     ecx, 1Ch
.text$mn:0000614E                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00006153                 add     eax, 50h ; 'P'
.text$mn:00006156                 mov     ecx, eax
.text$mn:00006158                 call    ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<uint,std::allocator<uint>>::size(void)
.text$mn:0000615D                 mov     [ebp+var_7C], eax
.text$mn:00006160                 jmp     short loc_616B
.text$mn:00006162 ; ---------------------------------------------------------------------------
.text$mn:00006162
.text$mn:00006162 loc_6162:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+B80j
.text$mn:00006162                 mov     eax, [ebp+var_3C]
.text$mn:00006165                 add     eax, 1
.text$mn:00006168                 mov     [ebp+var_3C], eax
.text$mn:0000616B
.text$mn:0000616B loc_616B:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+B38j
.text$mn:0000616B                 mov     ecx, [ebp+var_3C]
.text$mn:0000616E                 cmp     ecx, [ebp+var_7C]
.text$mn:00006171                 jnb     short loc_61AA
.text$mn:00006173                 push    18h             ; __int32
.text$mn:00006175                 mov     edx, [ebp+var_3C]
.text$mn:00006178                 push    edx
.text$mn:00006179                 mov     eax, [ebp+var_18]
.text$mn:0000617C                 push    eax
.text$mn:0000617D                 mov     ecx, [ebp+arg_0]
.text$mn:00006180                 add     ecx, 1Ch
.text$mn:00006183                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:00006188                 add     eax, 50h ; 'P'
.text$mn:0000618B                 mov     ecx, eax
.text$mn:0000618D                 call    ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ; std::vector<uint,std::allocator<uint>>::operator[](uint)
.text$mn:00006192                 mov     ecx, [eax]
.text$mn:00006194                 push    ecx             ; unsigned int
.text$mn:00006195                 push    7FBh            ; unsigned int
.text$mn:0000619A                 mov     ecx, [ebp+var_10]
.text$mn:0000619D                 add     ecx, 464h       ; this
.text$mn:000061A3                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000061A8                 jmp     short loc_6162
.text$mn:000061AA ; ---------------------------------------------------------------------------
.text$mn:000061AA
.text$mn:000061AA loc_61AA:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+B49j
.text$mn:000061AA                 mov     edx, [ebp+var_84]
.text$mn:000061B0                 push    edx             ; __int32
.text$mn:000061B1                 push    0               ; unsigned int
.text$mn:000061B3                 push    936h            ; unsigned int
.text$mn:000061B8                 mov     ecx, [ebp+var_10]
.text$mn:000061BB                 add     ecx, 464h       ; this
.text$mn:000061C1                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000061C6                 mov     eax, [ebp+var_18]
.text$mn:000061C9                 add     eax, 1
.text$mn:000061CC                 mov     [ebp+var_18], eax
.text$mn:000061CF                 jmp     loc_628E
.text$mn:000061D4 ; ---------------------------------------------------------------------------
.text$mn:000061D4
.text$mn:000061D4 loc_61D4:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+91Ej
.text$mn:000061D4                 mov     ecx, [ebp+var_18]
.text$mn:000061D7                 push    ecx
.text$mn:000061D8                 lea     edx, [ebp+var_DC]
.text$mn:000061DE                 push    edx
.text$mn:000061DF                 lea     eax, [ebp+var_144]
.text$mn:000061E5                 push    eax
.text$mn:000061E6                 mov     ecx, [ebp+arg_0]
.text$mn:000061E9                 add     ecx, 1Ch
.text$mn:000061EC                 call    ?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::begin(void)
.text$mn:000061F1                 mov     [ebp+var_8C], eax
.text$mn:000061F7                 mov     ecx, [ebp+var_8C]
.text$mn:000061FD                 mov     [ebp+var_94], ecx
.text$mn:00006203                 mov     [ebp+var_4], 0Ch
.text$mn:0000620A                 mov     ecx, [ebp+var_94]
.text$mn:00006210                 call    ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+(int)
.text$mn:00006215                 mov     byte ptr [ebp+var_4], 0Eh
.text$mn:00006219                 lea     ecx, [ebp+var_144]
.text$mn:0000621F                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:00006224                 sub     esp, 0Ch
.text$mn:00006227                 mov     ecx, esp
.text$mn:00006229                 mov     [ebp+var_E8], esp
.text$mn:0000622F                 lea     edx, [ebp+var_DC]
.text$mn:00006235                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00006236                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>> const &)
.text$mn:0000623B                 mov     [ebp+var_9C], eax
.text$mn:00006241                 mov     eax, [ebp+var_9C]
.text$mn:00006247                 mov     [ebp+var_F8], eax
.text$mn:0000624D                 mov     byte ptr [ebp+var_4], 0Fh
.text$mn:00006251                 lea     ecx, [ebp+var_15C]
.text$mn:00006257                 push    ecx
.text$mn:00006258                 mov     ecx, [ebp+arg_0]
.text$mn:0000625B                 add     ecx, 1Ch
.text$mn:0000625E                 mov     byte ptr [ebp+var_4], 0Eh
.text$mn:00006262                 call    ?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)
.text$mn:00006267                 mov     [ebp+var_F0], eax
.text$mn:0000626D                 lea     ecx, [ebp+var_15C]
.text$mn:00006273                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:00006278                 mov     [ebp+var_19], 0
.text$mn:0000627C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006283                 lea     ecx, [ebp+var_DC]
.text$mn:00006289                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:0000628E
.text$mn:0000628E loc_628E:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+BA7j
.text$mn:0000628E                 jmp     loc_5C8D
.text$mn:00006293 ; ---------------------------------------------------------------------------
.text$mn:00006293
.text$mn:00006293 loc_6293:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+670j
.text$mn:00006293                 cmp     [ebp+var_54], 0FFFFFFFFh
.text$mn:00006297                 jz      short loc_62BA
.text$mn:00006299                 mov     edx, [ebp+var_54]
.text$mn:0000629C                 push    edx
.text$mn:0000629D                 mov     ecx, [ebp+arg_0]
.text$mn:000062A0                 add     ecx, 1Ch
.text$mn:000062A3                 call    ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)
.text$mn:000062A8                 add     eax, 60h ; '`'
.text$mn:000062AB                 push    eax
.text$mn:000062AC                 mov     ecx, [ebp+var_10]
.text$mn:000062AF                 add     ecx, 464h
.text$mn:000062B5                 call    ?syncFoldStateWith@ScintillaEditView@@QAEXABV?$vector@IV?$allocator@I@std@@@std@@@Z ; ScintillaEditView::syncFoldStateWith(std::vector<uint,std::allocator<uint>> const &)
.text$mn:000062BA
.text$mn:000062BA loc_62BA:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+C6Fj
.text$mn:000062BA                 mov     ecx, [ebp+var_10]
.text$mn:000062BD                 add     ecx, 4C0h       ; this
.text$mn:000062C3                 call    ?restoreCurrentPos@ScintillaEditView@@QAEXXZ ; ScintillaEditView::restoreCurrentPos(void)
.text$mn:000062C8                 mov     ecx, [ebp+var_10]
.text$mn:000062CB                 add     ecx, 464h       ; this
.text$mn:000062D1                 call    ?restoreCurrentPos@ScintillaEditView@@QAEXXZ ; ScintillaEditView::restoreCurrentPos(void)
.text$mn:000062D6                 mov     ecx, [ebp+var_10]
.text$mn:000062D9                 add     ecx, 35Ch       ; this
.text$mn:000062DF                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:000062E4                 mov     ecx, [ebp+arg_0]
.text$mn:000062E7                 cmp     [ecx+4], eax
.text$mn:000062EA                 jnb     short loc_630C
.text$mn:000062EC                 push    0               ; int
.text$mn:000062EE                 mov     edx, [ebp+arg_0]
.text$mn:000062F1                 mov     eax, [edx+4]
.text$mn:000062F4                 push    eax             ; int
.text$mn:000062F5                 mov     ecx, [ebp+var_10]
.text$mn:000062F8                 add     ecx, 35Ch       ; this
.text$mn:000062FE                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00006303                 push    eax             ; struct Buffer *
.text$mn:00006304                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006307                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:0000630C
.text$mn:0000630C loc_630C:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+CC2j
.text$mn:0000630C                 mov     ecx, [ebp+var_10]
.text$mn:0000630F                 add     ecx, 3DCh       ; this
.text$mn:00006315                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:0000631A                 mov     ecx, [ebp+arg_0]
.text$mn:0000631D                 cmp     [ecx+8], eax
.text$mn:00006320                 jnb     short loc_6342
.text$mn:00006322                 push    1               ; int
.text$mn:00006324                 mov     edx, [ebp+arg_0]
.text$mn:00006327                 mov     eax, [edx+8]
.text$mn:0000632A                 push    eax             ; int
.text$mn:0000632B                 mov     ecx, [ebp+var_10]
.text$mn:0000632E                 add     ecx, 3DCh       ; this
.text$mn:00006334                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00006339                 push    eax             ; struct Buffer *
.text$mn:0000633A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000633D                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:00006342
.text$mn:00006342 loc_6342:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+CF8j
.text$mn:00006342                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006345                 call    ?nbSubFiles@Session@@QBEIXZ ; Session::nbSubFiles(void)
.text$mn:0000634A                 test    eax, eax
.text$mn:0000634C                 jbe     short loc_636E
.text$mn:0000634E                 mov     ecx, [ebp+arg_0]
.text$mn:00006351                 cmp     dword ptr [ecx], 0
.text$mn:00006354                 jz      short loc_635E
.text$mn:00006356                 mov     edx, [ebp+arg_0]
.text$mn:00006359                 cmp     dword ptr [edx], 1
.text$mn:0000635C                 jnz     short loc_636E
.text$mn:0000635E
.text$mn:0000635E loc_635E:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+D2Cj
.text$mn:0000635E                 mov     eax, [ebp+arg_0]
.text$mn:00006361                 mov     ecx, [eax]
.text$mn:00006363                 push    ecx             ; int
.text$mn:00006364                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006367                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:0000636C                 jmp     short loc_6378
.text$mn:0000636E ; ---------------------------------------------------------------------------
.text$mn:0000636E
.text$mn:0000636E loc_636E:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+D24j
.text$mn:0000636E                                         ; Notepad_plus::loadSession(Session &,bool)+D34j
.text$mn:0000636E                 push    0               ; int
.text$mn:00006370                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006373                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:00006378
.text$mn:00006378 loc_6378:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+D44j
.text$mn:00006378                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000637B                 call    ?otherView@Notepad_plus@@AAEHXZ ; Notepad_plus::otherView(void)
.text$mn:00006380                 push    eax             ; int
.text$mn:00006381                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006384                 call    ?canHideView@Notepad_plus@@AAE_NH@Z ; Notepad_plus::canHideView(int)
.text$mn:00006389                 movzx   edx, al
.text$mn:0000638C                 test    edx, edx
.text$mn:0000638E                 jz      short loc_63A3
.text$mn:00006390                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006393                 call    ?otherView@Notepad_plus@@AAEHXZ ; Notepad_plus::otherView(void)
.text$mn:00006398                 push    eax             ; int
.text$mn:00006399                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000639C                 call    ?hideView@Notepad_plus@@AAEXH@Z ; Notepad_plus::hideView(int)
.text$mn:000063A1                 jmp     short loc_63CC
.text$mn:000063A3 ; ---------------------------------------------------------------------------
.text$mn:000063A3
.text$mn:000063A3 loc_63A3:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+D66j
.text$mn:000063A3                 mov     ecx, [ebp+var_10] ; this
.text$mn:000063A6                 call    ?currentView@Notepad_plus@@AAEHXZ ; Notepad_plus::currentView(void)
.text$mn:000063AB                 push    eax             ; int
.text$mn:000063AC                 mov     ecx, [ebp+var_10] ; this
.text$mn:000063AF                 call    ?canHideView@Notepad_plus@@AAE_NH@Z ; Notepad_plus::canHideView(int)
.text$mn:000063B4                 movzx   eax, al
.text$mn:000063B7                 test    eax, eax
.text$mn:000063B9                 jz      short loc_63CC
.text$mn:000063BB                 mov     ecx, [ebp+var_10] ; this
.text$mn:000063BE                 call    ?currentView@Notepad_plus@@AAEHXZ ; Notepad_plus::currentView(void)
.text$mn:000063C3                 push    eax             ; int
.text$mn:000063C4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000063C7                 call    ?hideView@Notepad_plus@@AAEXH@Z ; Notepad_plus::hideView(int)
.text$mn:000063CC
.text$mn:000063CC loc_63CC:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+D79j
.text$mn:000063CC                                         ; Notepad_plus::loadSession(Session &,bool)+D91j
.text$mn:000063CC                 mov     ecx, [ebp+var_10]
.text$mn:000063CF                 cmp     dword ptr [ecx+551ACh], 0
.text$mn:000063D6                 jz      short loc_63E6
.text$mn:000063D8                 mov     edx, [ebp+var_10]
.text$mn:000063DB                 mov     ecx, [edx+551ACh] ; this
.text$mn:000063E1                 call    ?reload@VerticalFileSwitcher@@QAEXXZ ; VerticalFileSwitcher::reload(void)
.text$mn:000063E6
.text$mn:000063E6 loc_63E6:                               ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+DAEj
.text$mn:000063E6                 mov     al, [ebp+var_19]
.text$mn:000063E9                 mov     ecx, [ebp+var_C]
.text$mn:000063EC                 mov     large fs:0, ecx
.text$mn:000063F3                 pop     ecx
.text$mn:000063F4                 mov     esp, ebp
.text$mn:000063F6                 pop     ebp
.text$mn:000063F7                 retn    8
.text$mn:000063F7 ?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z endp ; sp-analysis failed
.text$mn:000063F7
.text$mn:000063F7 ; ---------------------------------------------------------------------------
.text$mn:000063FA                 db 0Eh dup(0CCh)
.text$mn:00006408
.text$mn:00006408 ; =============== S U B R O U T I N E =======================================
.text$mn:00006408
.text$mn:00006408 ; Attributes: bp-based frame
.text$mn:00006408
.text$mn:00006408 ; private: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall Notepad_plus::exts2Filters(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>)const
.text$mn:00006408                 public ?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z
.text$mn:00006408 ?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z proc near
.text$mn:00006408                                         ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+1E5p
.text$mn:00006408
.text$mn:00006408 var_27C         = dword ptr -27Ch
.text$mn:00006408 var_278         = dword ptr -278h
.text$mn:00006408 var_274         = dword ptr -274h
.text$mn:00006408 var_270         = dword ptr -270h
.text$mn:00006408 var_26C         = dword ptr -26Ch
.text$mn:00006408 var_268         = dword ptr -268h
.text$mn:00006408 var_264         = dword ptr -264h
.text$mn:00006408 var_260         = dword ptr -260h
.text$mn:00006408 var_25C         = dword ptr -25Ch
.text$mn:00006408 var_258         = dword ptr -258h
.text$mn:00006408 var_251         = byte ptr -251h
.text$mn:00006408 var_250         = byte ptr -250h
.text$mn:00006408 var_234         = byte ptr -234h
.text$mn:00006408 Str             = word ptr -218h
.text$mn:00006408 var_10          = dword ptr -10h
.text$mn:00006408 var_C           = dword ptr -0Ch
.text$mn:00006408 var_4           = dword ptr -4
.text$mn:00006408 arg_0           = dword ptr  8
.text$mn:00006408 arg_4           = byte ptr  0Ch
.text$mn:00006408
.text$mn:00006408                 push    ebp
.text$mn:00006409                 mov     ebp, esp
.text$mn:0000640B                 push    0FFFFFFFFh
.text$mn:0000640D                 push    offset __ehhandler$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z
.text$mn:00006412                 mov     eax, large fs:0
.text$mn:00006418                 push    eax
.text$mn:00006419                 sub     esp, 270h
.text$mn:0000641F                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006424                 xor     eax, ebp
.text$mn:00006426                 mov     [ebp+var_10], eax
.text$mn:00006429                 push    eax
.text$mn:0000642A                 lea     eax, [ebp+var_C]
.text$mn:0000642D                 mov     large fs:0, eax
.text$mn:00006433                 mov     [ebp+var_27C], ecx
.text$mn:00006439                 mov     [ebp+var_260], 0
.text$mn:00006443                 mov     [ebp+var_4], 1
.text$mn:0000644A                 lea     ecx, [ebp+arg_4]
.text$mn:0000644D                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00006452                 mov     [ebp+var_26C], eax
.text$mn:00006458                 push    offset $SG176269 ; Str
.text$mn:0000645D                 lea     ecx, [ebp+var_234]
.text$mn:00006463                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00006468                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000646C                 mov     [ebp+var_258], 0
.text$mn:00006476                 mov     [ebp+var_251], 0
.text$mn:0000647D                 mov     [ebp+var_25C], 0
.text$mn:00006487                 lea     ecx, [ebp+arg_4]
.text$mn:0000648A                 call    ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::length(void)
.text$mn:0000648F                 mov     [ebp+var_278], eax
.text$mn:00006495                 jmp     short loc_64A6
.text$mn:00006497 ; ---------------------------------------------------------------------------
.text$mn:00006497
.text$mn:00006497 loc_6497:                               ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>):loc_659Ej
.text$mn:00006497                 mov     eax, [ebp+var_25C]
.text$mn:0000649D                 add     eax, 1
.text$mn:000064A0                 mov     [ebp+var_25C], eax
.text$mn:000064A6
.text$mn:000064A6 loc_64A6:                               ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+8Dj
.text$mn:000064A6                 mov     ecx, [ebp+var_25C]
.text$mn:000064AC                 cmp     ecx, [ebp+var_278]
.text$mn:000064B2                 jnb     loc_65A3
.text$mn:000064B8                 mov     edx, [ebp+var_25C]
.text$mn:000064BE                 mov     eax, [ebp+var_26C]
.text$mn:000064C4                 movzx   ecx, word ptr [eax+edx*2]
.text$mn:000064C8                 cmp     ecx, 20h ; ' '
.text$mn:000064CB                 jnz     loc_656A
.text$mn:000064D1                 movzx   edx, [ebp+var_251]
.text$mn:000064D8                 test    edx, edx
.text$mn:000064DA                 jnz     loc_6568
.text$mn:000064E0                 mov     eax, [ebp+var_258]
.text$mn:000064E6                 shl     eax, 1
.text$mn:000064E8                 mov     [ebp+var_264], eax
.text$mn:000064EE                 cmp     [ebp+var_264], 208h
.text$mn:000064F8                 jnb     short loc_64FC
.text$mn:000064FA                 jmp     short loc_6501
.text$mn:000064FC ; ---------------------------------------------------------------------------
.text$mn:000064FC
.text$mn:000064FC loc_64FC:                               ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+F0j
.text$mn:000064FC                 call    ___report_rangecheckfailure
.text$mn:00006501
.text$mn:00006501 loc_6501:                               ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+F2j
.text$mn:00006501                 xor     ecx, ecx
.text$mn:00006503                 mov     edx, [ebp+var_264]
.text$mn:00006509                 mov     [ebp+edx+Str], cx
.text$mn:00006511                 mov     [ebp+var_251], 1
.text$mn:00006518                 mov     eax, 2
.text$mn:0000651D                 imul    ecx, eax, 0
.text$mn:00006520                 movzx   edx, [ebp+ecx+Str]
.text$mn:00006528                 test    edx, edx
.text$mn:0000652A                 jz      short loc_655E
.text$mn:0000652C                 push    offset $SG176281 ; "*."
.text$mn:00006531                 lea     ecx, [ebp+var_234]
.text$mn:00006537                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:0000653C                 lea     eax, [ebp+Str]
.text$mn:00006542                 push    eax             ; Str
.text$mn:00006543                 lea     ecx, [ebp+var_234]
.text$mn:00006549                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:0000654E                 push    offset $SG176282 ; Str
.text$mn:00006553                 lea     ecx, [ebp+var_234]
.text$mn:00006559                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:0000655E
.text$mn:0000655E loc_655E:                               ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+122j
.text$mn:0000655E                 mov     [ebp+var_258], 0
.text$mn:00006568
.text$mn:00006568 loc_6568:                               ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+D2j
.text$mn:00006568                 jmp     short loc_659E
.text$mn:0000656A ; ---------------------------------------------------------------------------
.text$mn:0000656A
.text$mn:0000656A loc_656A:                               ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+C3j
.text$mn:0000656A                 mov     ecx, [ebp+var_258]
.text$mn:00006570                 mov     edx, [ebp+var_25C]
.text$mn:00006576                 mov     eax, [ebp+var_26C]
.text$mn:0000657C                 mov     dx, [eax+edx*2]
.text$mn:00006580                 mov     [ebp+ecx*2+Str], dx
.text$mn:00006588                 mov     [ebp+var_251], 0
.text$mn:0000658F                 mov     eax, [ebp+var_258]
.text$mn:00006595                 add     eax, 1
.text$mn:00006598                 mov     [ebp+var_258], eax
.text$mn:0000659E
.text$mn:0000659E loc_659E:                               ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>):loc_6568j
.text$mn:0000659E                 jmp     loc_6497
.text$mn:000065A3 ; ---------------------------------------------------------------------------
.text$mn:000065A3
.text$mn:000065A3 loc_65A3:                               ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+AAj
.text$mn:000065A3                 cmp     [ebp+var_258], 0
.text$mn:000065AA                 jle     short loc_6623
.text$mn:000065AC                 mov     ecx, [ebp+var_258]
.text$mn:000065B2                 shl     ecx, 1
.text$mn:000065B4                 mov     [ebp+var_268], ecx
.text$mn:000065BA                 cmp     [ebp+var_268], 208h
.text$mn:000065C4                 jnb     short loc_65C8
.text$mn:000065C6                 jmp     short loc_65CD
.text$mn:000065C8 ; ---------------------------------------------------------------------------
.text$mn:000065C8
.text$mn:000065C8 loc_65C8:                               ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+1BCj
.text$mn:000065C8                 call    ___report_rangecheckfailure
.text$mn:000065CD
.text$mn:000065CD loc_65CD:                               ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+1BEj
.text$mn:000065CD                 xor     edx, edx
.text$mn:000065CF                 mov     eax, [ebp+var_268]
.text$mn:000065D5                 mov     [ebp+eax+Str], dx
.text$mn:000065DD                 mov     ecx, 2
.text$mn:000065E2                 imul    edx, ecx, 0
.text$mn:000065E5                 movzx   eax, [ebp+edx+Str]
.text$mn:000065ED                 test    eax, eax
.text$mn:000065EF                 jz      short loc_6623
.text$mn:000065F1                 push    offset $SG176287 ; "*."
.text$mn:000065F6                 lea     ecx, [ebp+var_234]
.text$mn:000065FC                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00006601                 lea     ecx, [ebp+Str]
.text$mn:00006607                 push    ecx             ; Str
.text$mn:00006608                 lea     ecx, [ebp+var_234]
.text$mn:0000660E                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00006613                 push    offset $SG176288 ; Str
.text$mn:00006618                 lea     ecx, [ebp+var_234]
.text$mn:0000661E                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00006623
.text$mn:00006623 loc_6623:                               ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+1A2j
.text$mn:00006623                                         ; Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+1E7j
.text$mn:00006623                 lea     ecx, [ebp+var_234]
.text$mn:00006629                 call    ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::length(void)
.text$mn:0000662E                 sub     eax, 1
.text$mn:00006631                 push    eax
.text$mn:00006632                 push    0
.text$mn:00006634                 lea     edx, [ebp+var_250]
.text$mn:0000663A                 push    edx
.text$mn:0000663B                 lea     ecx, [ebp+var_234]
.text$mn:00006641                 call    ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::substr(uint,uint)
.text$mn:00006646                 mov     [ebp+var_274], eax
.text$mn:0000664C                 mov     eax, [ebp+var_274]
.text$mn:00006652                 mov     [ebp+var_270], eax
.text$mn:00006658                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000665C                 mov     ecx, [ebp+var_270]
.text$mn:00006662                 push    ecx
.text$mn:00006663                 lea     ecx, [ebp+var_234]
.text$mn:00006669                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:0000666E                 mov     byte ptr [ebp+var_4], 2
.text$mn:00006672                 lea     ecx, [ebp+var_250]
.text$mn:00006678                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000667D                 lea     edx, [ebp+var_234]
.text$mn:00006683                 push    edx
.text$mn:00006684                 mov     ecx, [ebp+arg_0]
.text$mn:00006687                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:0000668C                 mov     eax, [ebp+var_260]
.text$mn:00006692                 or      eax, 1
.text$mn:00006695                 mov     [ebp+var_260], eax
.text$mn:0000669B                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000669F                 lea     ecx, [ebp+var_234]
.text$mn:000066A5                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000066AA                 mov     byte ptr [ebp+var_4], 0
.text$mn:000066AE                 lea     ecx, [ebp+arg_4]
.text$mn:000066B1                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000066B6                 mov     eax, [ebp+arg_0]
.text$mn:000066B9                 mov     ecx, [ebp+var_C]
.text$mn:000066BC                 mov     large fs:0, ecx
.text$mn:000066C3                 pop     ecx
.text$mn:000066C4                 mov     ecx, [ebp+var_10]
.text$mn:000066C7                 xor     ecx, ebp
.text$mn:000066C9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000066CE                 mov     esp, ebp
.text$mn:000066D0                 pop     ebp
.text$mn:000066D1                 retn    20h
.text$mn:000066D1 ?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z endp
.text$mn:000066D1
.text$mn:000066D1 ; ---------------------------------------------------------------------------
.text$mn:000066D4                 align 8
.text$mn:000066D8
.text$mn:000066D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000066D8
.text$mn:000066D8 ; Attributes: bp-based frame
.text$mn:000066D8
.text$mn:000066D8 ; int __thiscall Notepad_plus::setFileOpenSaveDlgFilters(Notepad_plus *this, struct FileDialog *, int)
.text$mn:000066D8                 public ?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z
.text$mn:000066D8 ?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z proc near
.text$mn:000066D8                                         ; CODE XREF: Notepad_plus::fileOpen(void)+8Fp
.text$mn:000066D8                                         ; Notepad_plus::fileSaveAs(Buffer *,bool)+D8p ...
.text$mn:000066D8
.text$mn:000066D8 var_C8          = dword ptr -0C8h
.text$mn:000066D8 var_C4          = dword ptr -0C4h
.text$mn:000066D8 var_C0          = dword ptr -0C0h
.text$mn:000066D8 var_BC          = dword ptr -0BCh
.text$mn:000066D8 var_B8          = dword ptr -0B8h
.text$mn:000066D8 var_B4          = dword ptr -0B4h
.text$mn:000066D8 var_B0          = dword ptr -0B0h
.text$mn:000066D8 var_AC          = dword ptr -0ACh
.text$mn:000066D8 var_A8          = dword ptr -0A8h
.text$mn:000066D8 var_A4          = dword ptr -0A4h
.text$mn:000066D8 var_A0          = dword ptr -0A0h
.text$mn:000066D8 var_9C          = dword ptr -9Ch
.text$mn:000066D8 var_98          = dword ptr -98h
.text$mn:000066D8 var_94          = dword ptr -94h
.text$mn:000066D8 Str             = dword ptr -90h
.text$mn:000066D8 var_8C          = dword ptr -8Ch
.text$mn:000066D8 var_88          = dword ptr -88h
.text$mn:000066D8 var_84          = dword ptr -84h
.text$mn:000066D8 var_80          = dword ptr -80h
.text$mn:000066D8 var_7C          = dword ptr -7Ch
.text$mn:000066D8 var_78          = dword ptr -78h
.text$mn:000066D8 var_74          = dword ptr -74h
.text$mn:000066D8 var_70          = dword ptr -70h
.text$mn:000066D8 var_6C          = dword ptr -6Ch
.text$mn:000066D8 var_66          = byte ptr -66h
.text$mn:000066D8 var_65          = byte ptr -65h
.text$mn:000066D8 var_64          = byte ptr -64h
.text$mn:000066D8 var_48          = byte ptr -48h
.text$mn:000066D8 var_2C          = byte ptr -2Ch
.text$mn:000066D8 var_10          = dword ptr -10h
.text$mn:000066D8 var_C           = dword ptr -0Ch
.text$mn:000066D8 var_4           = dword ptr -4
.text$mn:000066D8 arg_0           = dword ptr  8
.text$mn:000066D8 arg_4           = dword ptr  0Ch
.text$mn:000066D8
.text$mn:000066D8                 push    ebp
.text$mn:000066D9                 mov     ebp, esp
.text$mn:000066DB                 push    0FFFFFFFFh
.text$mn:000066DD                 push    offset __ehhandler$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z
.text$mn:000066E2                 mov     eax, large fs:0
.text$mn:000066E8                 push    eax
.text$mn:000066E9                 sub     esp, 0BCh
.text$mn:000066EF                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000066F4                 xor     eax, ebp
.text$mn:000066F6                 mov     [ebp+var_10], eax
.text$mn:000066F9                 push    eax
.text$mn:000066FA                 lea     eax, [ebp+var_C]
.text$mn:000066FD                 mov     large fs:0, eax
.text$mn:00006703                 mov     [ebp+var_8C], ecx
.text$mn:00006709                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:0000670E                 mov     [ebp+var_9C], eax
.text$mn:00006714                 mov     ecx, [ebp+var_9C] ; this
.text$mn:0000671A                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:0000671F                 mov     [ebp+var_84], eax
.text$mn:00006725                 mov     [ebp+var_6C], 0
.text$mn:0000672C                 mov     eax, [ebp+var_6C]
.text$mn:0000672F                 mov     [ebp+var_B4], eax
.text$mn:00006735                 mov     ecx, [ebp+var_B4]
.text$mn:0000673B                 push    ecx             ; int
.text$mn:0000673C                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00006741                 mov     ecx, eax        ; this
.text$mn:00006743                 call    ?getLangFromIndex@NppParameters@@QBEPAULang@@H@Z ; NppParameters::getLangFromIndex(int)
.text$mn:00006748                 mov     [ebp+var_70], eax
.text$mn:0000674B                 mov     edx, [ebp+var_6C]
.text$mn:0000674E                 add     edx, 1
.text$mn:00006751                 mov     [ebp+var_6C], edx
.text$mn:00006754                 mov     [ebp+var_7C], 0
.text$mn:0000675B                 mov     [ebp+var_65], 0
.text$mn:0000675F
.text$mn:0000675F loc_675F:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+2FDj
.text$mn:0000675F                 cmp     [ebp+var_70], 0
.text$mn:00006763                 jz      loc_69DA
.text$mn:00006769                 mov     ecx, [ebp+var_70]
.text$mn:0000676C                 call    ?getLangID@Lang@@QBE?AW4LangType@@XZ ; Lang::getLangID(void)
.text$mn:00006771                 mov     [ebp+var_80], eax
.text$mn:00006774                 mov     [ebp+var_66], 0
.text$mn:00006778                 mov     [ebp+var_74], 0
.text$mn:0000677F                 mov     ecx, [ebp+var_84]
.text$mn:00006785                 add     ecx, 64h ; 'd'
.text$mn:00006788                 call    ?size@?$vector@ULangMenuItem@@V?$allocator@ULangMenuItem@@@std@@@std@@QBEIXZ ; std::vector<LangMenuItem,std::allocator<LangMenuItem>>::size(void)
.text$mn:0000678D                 mov     [ebp+var_BC], eax
.text$mn:00006793                 jmp     short loc_679E
.text$mn:00006795 ; ---------------------------------------------------------------------------
.text$mn:00006795
.text$mn:00006795 loc_6795:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int):loc_67C8j
.text$mn:00006795                 mov     eax, [ebp+var_74]
.text$mn:00006798                 add     eax, 1
.text$mn:0000679B                 mov     [ebp+var_74], eax
.text$mn:0000679E
.text$mn:0000679E loc_679E:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+BBj
.text$mn:0000679E                 mov     ecx, [ebp+var_74]
.text$mn:000067A1                 cmp     ecx, [ebp+var_BC]
.text$mn:000067A7                 jnb     short loc_67CA
.text$mn:000067A9                 mov     edx, [ebp+var_74]
.text$mn:000067AC                 push    edx
.text$mn:000067AD                 mov     ecx, [ebp+var_84]
.text$mn:000067B3                 add     ecx, 64h ; 'd'
.text$mn:000067B6                 call    ??A?$vector@ULangMenuItem@@V?$allocator@ULangMenuItem@@@std@@@std@@QAEAAULangMenuItem@@I@Z ; std::vector<LangMenuItem,std::allocator<LangMenuItem>>::operator[](uint)
.text$mn:000067BB                 mov     ecx, [ebp+var_80]
.text$mn:000067BE                 cmp     ecx, [eax]
.text$mn:000067C0                 jnz     short loc_67C8
.text$mn:000067C2                 mov     [ebp+var_66], 1
.text$mn:000067C6                 jmp     short loc_67CA
.text$mn:000067C8 ; ---------------------------------------------------------------------------
.text$mn:000067C8
.text$mn:000067C8 loc_67C8:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+E8j
.text$mn:000067C8                 jmp     short loc_6795
.text$mn:000067CA ; ---------------------------------------------------------------------------
.text$mn:000067CA
.text$mn:000067CA loc_67CA:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+CFj
.text$mn:000067CA                                         ; Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+EEj
.text$mn:000067CA                 movzx   edx, [ebp+var_66]
.text$mn:000067CE                 test    edx, edx
.text$mn:000067D0                 jnz     loc_69AD
.text$mn:000067D6                 mov     ecx, [ebp+var_70] ; this
.text$mn:000067D9                 call    ?getDefaultExtList@Lang@@QBEPB_WXZ ; Lang::getDefaultExtList(void)
.text$mn:000067DE                 mov     [ebp+Str], eax
.text$mn:000067E4                 mov     [ebp+var_78], 0
.text$mn:000067EB                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000067F0                 mov     ecx, eax        ; this
.text$mn:000067F2                 call    ?getLStylerArray@NppParameters@@QAEAAULexerStylerArray@@XZ ; NppParameters::getLStylerArray(void)
.text$mn:000067F7                 mov     [ebp+var_AC], eax
.text$mn:000067FD                 mov     ecx, [ebp+var_70] ; this
.text$mn:00006800                 call    ?getLangName@Lang@@QBEPB_WXZ ; Lang::getLangName(void)
.text$mn:00006805                 mov     [ebp+var_B0], eax
.text$mn:0000680B                 mov     eax, [ebp+var_B0]
.text$mn:00006811                 push    eax             ; wchar_t *
.text$mn:00006812                 mov     ecx, [ebp+var_AC] ; this
.text$mn:00006818                 call    ?getLexerStylerByName@LexerStylerArray@@QAEPAULexerStyler@@PB_W@Z ; LexerStylerArray::getLexerStylerByName(wchar_t const *)
.text$mn:0000681D                 mov     [ebp+var_88], eax
.text$mn:00006823                 cmp     [ebp+var_88], 0
.text$mn:0000682A                 jz      short loc_683A
.text$mn:0000682C                 mov     ecx, [ebp+var_88] ; this
.text$mn:00006832                 call    ?getLexerUserExt@LexerStyler@@QBEPB_WXZ ; LexerStyler::getLexerUserExt(void)
.text$mn:00006837                 mov     [ebp+var_78], eax
.text$mn:0000683A
.text$mn:0000683A loc_683A:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+152j
.text$mn:0000683A                 push    offset $SG176353 ; Str
.text$mn:0000683F                 lea     ecx, [ebp+var_2C]
.text$mn:00006842                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00006847                 mov     [ebp+var_4], 0
.text$mn:0000684E                 cmp     [ebp+Str], 0
.text$mn:00006855                 jz      short loc_6866
.text$mn:00006857                 mov     ecx, [ebp+Str]
.text$mn:0000685D                 push    ecx             ; Str
.text$mn:0000685E                 lea     ecx, [ebp+var_2C]
.text$mn:00006861                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00006866
.text$mn:00006866 loc_6866:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+17Dj
.text$mn:00006866                 cmp     [ebp+var_78], 0
.text$mn:0000686A                 jz      short loc_6885
.text$mn:0000686C                 push    offset $SG176356 ; Str
.text$mn:00006871                 lea     ecx, [ebp+var_2C]
.text$mn:00006874                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00006879                 mov     edx, [ebp+var_78]
.text$mn:0000687C                 push    edx             ; Str
.text$mn:0000687D                 lea     ecx, [ebp+var_2C]
.text$mn:00006880                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00006885
.text$mn:00006885 loc_6885:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+192j
.text$mn:00006885                 sub     esp, 1Ch
.text$mn:00006888                 mov     ecx, esp
.text$mn:0000688A                 mov     [ebp+var_C0], esp
.text$mn:00006890                 lea     eax, [ebp+var_2C]
.text$mn:00006893                 push    eax
.text$mn:00006894                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00006899                 mov     [ebp+var_A8], eax
.text$mn:0000689F                 mov     ecx, [ebp+var_A8]
.text$mn:000068A5                 mov     [ebp+var_C8], ecx
.text$mn:000068AB                 mov     byte ptr [ebp+var_4], 1
.text$mn:000068AF                 lea     edx, [ebp+var_48]
.text$mn:000068B2                 push    edx
.text$mn:000068B3                 mov     byte ptr [ebp+var_4], 0
.text$mn:000068B7                 mov     ecx, [ebp+var_8C]
.text$mn:000068BD                 call    ?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z ; Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)
.text$mn:000068C2                 mov     [ebp+var_C4], eax
.text$mn:000068C8                 mov     byte ptr [ebp+var_4], 2
.text$mn:000068CC                 lea     ecx, [ebp+var_48]
.text$mn:000068CF                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000068D4                 mov     [ebp+var_98], eax
.text$mn:000068DA                 mov     eax, 2
.text$mn:000068DF                 imul    ecx, eax, 0
.text$mn:000068E2                 mov     edx, [ebp+var_98]
.text$mn:000068E8                 movzx   eax, word ptr [edx+ecx]
.text$mn:000068EC                 test    eax, eax
.text$mn:000068EE                 jz      loc_6992
.text$mn:000068F4                 mov     ecx, [ebp+var_98]
.text$mn:000068FA                 push    ecx             ; wchar_t *
.text$mn:000068FB                 push    0
.text$mn:000068FD                 mov     edx, [ebp+var_80]
.text$mn:00006900                 push    edx
.text$mn:00006901                 lea     eax, [ebp+var_64]
.text$mn:00006904                 push    eax
.text$mn:00006905                 mov     ecx, [ebp+var_8C]
.text$mn:0000690B                 call    ?getLangDesc@Notepad_plus@@AAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LangType@@_N@Z ; Notepad_plus::getLangDesc(LangType,bool)
.text$mn:00006910                 mov     [ebp+var_B8], eax
.text$mn:00006916                 mov     ecx, [ebp+var_B8]
.text$mn:0000691C                 mov     [ebp+var_A0], ecx
.text$mn:00006922                 mov     byte ptr [ebp+var_4], 3
.text$mn:00006926                 mov     ecx, [ebp+var_A0]
.text$mn:0000692C                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00006931                 push    eax             ; wchar_t *
.text$mn:00006932                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006935                 call    ?setExtsFilter@FileDialog@@QAEHPB_W0@Z ; FileDialog::setExtsFilter(wchar_t const *,wchar_t const *)
.text$mn:0000693A                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000693E                 lea     ecx, [ebp+var_64]
.text$mn:00006941                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00006946                 cmp     [ebp+arg_4], 0FFFFFFFFh
.text$mn:0000694A                 jz      short loc_697B
.text$mn:0000694C                 movzx   edx, [ebp+var_65]
.text$mn:00006950                 test    edx, edx
.text$mn:00006952                 jnz     short loc_697B
.text$mn:00006954                 mov     eax, [ebp+arg_4]
.text$mn:00006957                 cmp     eax, [ebp+var_80]
.text$mn:0000695A                 jnz     short loc_6968
.text$mn:0000695C                 mov     [ebp+var_94], 1
.text$mn:00006966                 jmp     short loc_6972
.text$mn:00006968 ; ---------------------------------------------------------------------------
.text$mn:00006968
.text$mn:00006968 loc_6968:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+282j
.text$mn:00006968                 mov     [ebp+var_94], 0
.text$mn:00006972
.text$mn:00006972 loc_6972:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+28Ej
.text$mn:00006972                 mov     cl, byte ptr [ebp+var_94]
.text$mn:00006978                 mov     [ebp+var_65], cl
.text$mn:0000697B
.text$mn:0000697B loc_697B:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+272j
.text$mn:0000697B                                         ; Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+27Aj
.text$mn:0000697B                 cmp     [ebp+arg_4], 0FFFFFFFFh
.text$mn:0000697F                 jz      short loc_6992
.text$mn:00006981                 movzx   edx, [ebp+var_65]
.text$mn:00006985                 test    edx, edx
.text$mn:00006987                 jnz     short loc_6992
.text$mn:00006989                 mov     eax, [ebp+var_7C]
.text$mn:0000698C                 add     eax, 1
.text$mn:0000698F                 mov     [ebp+var_7C], eax
.text$mn:00006992
.text$mn:00006992 loc_6992:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+216j
.text$mn:00006992                                         ; Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+2A7j ...
.text$mn:00006992                 mov     byte ptr [ebp+var_4], 0
.text$mn:00006996                 lea     ecx, [ebp+var_48]
.text$mn:00006999                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000699E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000069A5                 lea     ecx, [ebp+var_2C]
.text$mn:000069A8                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000069AD
.text$mn:000069AD loc_69AD:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+F8j
.text$mn:000069AD                 mov     ecx, [ebp+var_6C]
.text$mn:000069B0                 mov     [ebp+var_A4], ecx
.text$mn:000069B6                 mov     edx, [ebp+var_A4]
.text$mn:000069BC                 push    edx             ; int
.text$mn:000069BD                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000069C2                 mov     ecx, eax        ; this
.text$mn:000069C4                 call    ?getLangFromIndex@NppParameters@@QBEPAULang@@H@Z ; NppParameters::getLangFromIndex(int)
.text$mn:000069C9                 mov     [ebp+var_70], eax
.text$mn:000069CC                 mov     eax, [ebp+var_6C]
.text$mn:000069CF                 add     eax, 1
.text$mn:000069D2                 mov     [ebp+var_6C], eax
.text$mn:000069D5                 jmp     loc_675F
.text$mn:000069DA ; ---------------------------------------------------------------------------
.text$mn:000069DA
.text$mn:000069DA loc_69DA:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+8Bj
.text$mn:000069DA                 movzx   ecx, [ebp+var_65]
.text$mn:000069DE                 test    ecx, ecx
.text$mn:000069E0                 jnz     short loc_69E7
.text$mn:000069E2                 or      eax, 0FFFFFFFFh
.text$mn:000069E5                 jmp     short loc_69EA
.text$mn:000069E7 ; ---------------------------------------------------------------------------
.text$mn:000069E7
.text$mn:000069E7 loc_69E7:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+308j
.text$mn:000069E7                 mov     eax, [ebp+var_7C]
.text$mn:000069EA
.text$mn:000069EA loc_69EA:                               ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+30Dj
.text$mn:000069EA                 mov     ecx, [ebp+var_C]
.text$mn:000069ED                 mov     large fs:0, ecx
.text$mn:000069F4                 pop     ecx
.text$mn:000069F5                 mov     ecx, [ebp+var_10]
.text$mn:000069F8                 xor     ecx, ebp
.text$mn:000069FA                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000069FF                 mov     esp, ebp
.text$mn:00006A01                 pop     ebp
.text$mn:00006A02                 retn    8
.text$mn:00006A02 ?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z endp
.text$mn:00006A02
.text$mn:00006A02 ; ---------------------------------------------------------------------------
.text$mn:00006A05                 align 4
.text$mn:00006A05 _text$mn        ends
.text$mn:00006A05
.text$x:00006A08 ; ===========================================================================
.text$x:00006A08
.text$x:00006A08 ; Segment type: Pure code
.text$x:00006A08 ; Segment permissions: Read/Execute
.text$x:00006A08 _text$x         segment para public 'CODE' use32
.text$x:00006A08                 assume cs:_text$x
.text$x:00006A08                 ;org 6A08h
.text$x:00006A08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006A08
.text$x:00006A08 ; =============== S U B R O U T I N E =======================================
.text$x:00006A08
.text$x:00006A08
.text$x:00006A08 __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$0 proc near
.text$x:00006A08                                         ; DATA XREF: .xdata$x:00013960o
.text$x:00006A08                 lea     ecx, [ebp-644h]
.text$x:00006A0E                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006A0E __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$0 endp
.text$x:00006A0E
.text$x:00006A13
.text$x:00006A13 ; =============== S U B R O U T I N E =======================================
.text$x:00006A13
.text$x:00006A13
.text$x:00006A13 __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$1 proc near
.text$x:00006A13                                         ; DATA XREF: .xdata$x:00013968o
.text$x:00006A13                 lea     ecx, [ebp-660h]
.text$x:00006A19                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006A19 __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$1 endp
.text$x:00006A19
.text$x:00006A1E
.text$x:00006A1E ; =============== S U B R O U T I N E =======================================
.text$x:00006A1E
.text$x:00006A1E
.text$x:00006A1E __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$3 proc near
.text$x:00006A1E                                         ; DATA XREF: .xdata$x:00013970o
.text$x:00006A1E                 lea     ecx, [ebp-778h]
.text$x:00006A24                 jmp     ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$x:00006A24 __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$3 endp
.text$x:00006A24
.text$x:00006A29
.text$x:00006A29 ; =============== S U B R O U T I N E =======================================
.text$x:00006A29
.text$x:00006A29
.text$x:00006A29 __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$4 proc near
.text$x:00006A29                                         ; DATA XREF: .xdata$x:00013978o
.text$x:00006A29                 lea     ecx, [ebp-788h]
.text$x:00006A2F                 jmp     ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$x:00006A2F __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$4 endp
.text$x:00006A2F
.text$x:00006A34
.text$x:00006A34 ; =============== S U B R O U T I N E =======================================
.text$x:00006A34
.text$x:00006A34
.text$x:00006A34 __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$5 proc near
.text$x:00006A34                                         ; DATA XREF: .xdata$x:00013980o
.text$x:00006A34                 lea     ecx, [ebp-6ECh]
.text$x:00006A3A                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006A3A __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$5 endp
.text$x:00006A3A
.text$x:00006A3F
.text$x:00006A3F ; =============== S U B R O U T I N E =======================================
.text$x:00006A3F
.text$x:00006A3F
.text$x:00006A3F __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$6 proc near
.text$x:00006A3F                                         ; DATA XREF: .xdata$x:00013988o
.text$x:00006A3F                 lea     ecx, [ebp-6D0h]
.text$x:00006A45                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006A45 __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$6 endp
.text$x:00006A45
.text$x:00006A4A
.text$x:00006A4A ; =============== S U B R O U T I N E =======================================
.text$x:00006A4A
.text$x:00006A4A
.text$x:00006A4A __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$7 proc near
.text$x:00006A4A                                         ; DATA XREF: .xdata$x:00013990o
.text$x:00006A4A                 lea     ecx, [ebp-698h]
.text$x:00006A50                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006A50 __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$7 endp
.text$x:00006A50
.text$x:00006A55
.text$x:00006A55 ; =============== S U B R O U T I N E =======================================
.text$x:00006A55
.text$x:00006A55
.text$x:00006A55 __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$8 proc near
.text$x:00006A55                                         ; DATA XREF: .xdata$x:00013998o
.text$x:00006A55                 lea     ecx, [ebp-6B4h]
.text$x:00006A5B                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006A5B __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$8 endp
.text$x:00006A5B
.text$x:00006A60
.text$x:00006A60 ; =============== S U B R O U T I N E =======================================
.text$x:00006A60
.text$x:00006A60
.text$x:00006A60 __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$9 proc near
.text$x:00006A60                                         ; DATA XREF: .xdata$x:000139A0o
.text$x:00006A60                 lea     ecx, [ebp-67Ch]
.text$x:00006A66                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006A66 __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$9 endp
.text$x:00006A66
.text$x:00006A6B
.text$x:00006A6B ; =============== S U B R O U T I N E =======================================
.text$x:00006A6B
.text$x:00006A6B
.text$x:00006A6B __ehhandler$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z proc near
.text$x:00006A6B                                         ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+5o
.text$x:00006A6B
.text$x:00006A6B arg_4           = dword ptr  8
.text$x:00006A6B
.text$x:00006A6B                 mov     edx, [esp+arg_4]
.text$x:00006A6F                 lea     eax, [edx+0Ch]
.text$x:00006A72                 mov     ecx, [edx-83Ch]
.text$x:00006A78                 xor     ecx, eax
.text$x:00006A7A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006A7F                 mov     ecx, [edx-4]
.text$x:00006A82                 xor     ecx, eax
.text$x:00006A84                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006A89                 mov     eax, offset __ehfuncinfo$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z
.text$x:00006A8E                 jmp     ___CxxFrameHandler3
.text$x:00006A8E __ehhandler$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z endp
.text$x:00006A8E
.text$x:00006A93
.text$x:00006A93 ; =============== S U B R O U T I N E =======================================
.text$x:00006A93
.text$x:00006A93
.text$x:00006A93 __unwindfunclet$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z$0 proc near
.text$x:00006A93                                         ; DATA XREF: .xdata$x:000136B8o
.text$x:00006A93                 lea     ecx, [ebp-458h]
.text$x:00006A99                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006A99 __unwindfunclet$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z$0 endp
.text$x:00006A99
.text$x:00006A9E
.text$x:00006A9E ; =============== S U B R O U T I N E =======================================
.text$x:00006A9E
.text$x:00006A9E
.text$x:00006A9E __unwindfunclet$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z$1 proc near
.text$x:00006A9E                                         ; DATA XREF: .xdata$x:000136C0o
.text$x:00006A9E                 lea     ecx, [ebp-474h]
.text$x:00006AA4                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006AA4 __unwindfunclet$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z$1 endp
.text$x:00006AA4
.text$x:00006AA9
.text$x:00006AA9 ; =============== S U B R O U T I N E =======================================
.text$x:00006AA9
.text$x:00006AA9
.text$x:00006AA9 __unwindfunclet$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z$2 proc near
.text$x:00006AA9                                         ; DATA XREF: .xdata$x:000136C8o
.text$x:00006AA9                 lea     ecx, [ebp-490h]
.text$x:00006AAF                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006AAF __unwindfunclet$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z$2 endp
.text$x:00006AAF
.text$x:00006AB4
.text$x:00006AB4 ; =============== S U B R O U T I N E =======================================
.text$x:00006AB4
.text$x:00006AB4
.text$x:00006AB4 __unwindfunclet$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z$3 proc near
.text$x:00006AB4                                         ; DATA XREF: .xdata$x:000136D0o
.text$x:00006AB4                 lea     ecx, [ebp-43Ch]
.text$x:00006ABA                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006ABA __unwindfunclet$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z$3 endp
.text$x:00006ABA
.text$x:00006ABF
.text$x:00006ABF ; =============== S U B R O U T I N E =======================================
.text$x:00006ABF
.text$x:00006ABF
.text$x:00006ABF __ehhandler$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z proc near
.text$x:00006ABF                                         ; DATA XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+5o
.text$x:00006ABF
.text$x:00006ABF arg_4           = dword ptr  8
.text$x:00006ABF
.text$x:00006ABF                 mov     edx, [esp+arg_4]
.text$x:00006AC3                 lea     eax, [edx+0Ch]
.text$x:00006AC6                 mov     ecx, [edx-504h]
.text$x:00006ACC                 xor     ecx, eax
.text$x:00006ACE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006AD3                 mov     ecx, [edx-4]
.text$x:00006AD6                 xor     ecx, eax
.text$x:00006AD8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006ADD                 mov     eax, offset __ehfuncinfo$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z
.text$x:00006AE2                 jmp     ___CxxFrameHandler3
.text$x:00006AE2 __ehhandler$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z endp
.text$x:00006AE2
.text$x:00006AE7
.text$x:00006AE7 ; =============== S U B R O U T I N E =======================================
.text$x:00006AE7
.text$x:00006AE7
.text$x:00006AE7 __unwindfunclet$?fileOpen@Notepad_plus@@QAEXXZ$0 proc near
.text$x:00006AE7                                         ; DATA XREF: .xdata$x:000135C8o
.text$x:00006AE7                 lea     ecx, [ebp-10CCh] ; this
.text$x:00006AED                 jmp     ??1FileDialog@@QAE@XZ ; FileDialog::~FileDialog(void)
.text$x:00006AED __unwindfunclet$?fileOpen@Notepad_plus@@QAEXXZ$0 endp
.text$x:00006AED
.text$x:00006AF2
.text$x:00006AF2 ; =============== S U B R O U T I N E =======================================
.text$x:00006AF2
.text$x:00006AF2
.text$x:00006AF2 __ehhandler$?fileOpen@Notepad_plus@@QAEXXZ proc near
.text$x:00006AF2                                         ; DATA XREF: Notepad_plus::fileOpen(void)+5o
.text$x:00006AF2
.text$x:00006AF2 arg_4           = dword ptr  8
.text$x:00006AF2
.text$x:00006AF2                 mov     edx, [esp+arg_4]
.text$x:00006AF6                 lea     eax, [edx+0Ch]
.text$x:00006AF9                 mov     ecx, [edx-10DCh]
.text$x:00006AFF                 xor     ecx, eax
.text$x:00006B01                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006B06                 mov     ecx, [edx-4]
.text$x:00006B09                 xor     ecx, eax
.text$x:00006B0B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006B10                 mov     eax, offset __ehfuncinfo$?fileOpen@Notepad_plus@@QAEXXZ
.text$x:00006B15                 jmp     ___CxxFrameHandler3
.text$x:00006B15 __ehhandler$?fileOpen@Notepad_plus@@QAEXXZ endp
.text$x:00006B15
.text$x:00006B1A
.text$x:00006B1A ; =============== S U B R O U T I N E =======================================
.text$x:00006B1A
.text$x:00006B1A
.text$x:00006B1A __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$0 proc near
.text$x:00006B1A                                         ; DATA XREF: .xdata$x:00013698o
.text$x:00006B1A                 mov     eax, [ebp-0AB8h]
.text$x:00006B20                 and     eax, 1
.text$x:00006B23                 jz      locret_6B3B
.text$x:00006B29                 and     dword ptr [ebp-0AB8h], 0FFFFFFFEh
.text$x:00006B30                 lea     ecx, [ebp-0A78h]
.text$x:00006B36                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006B3B ; ---------------------------------------------------------------------------
.text$x:00006B3B
.text$x:00006B3B locret_6B3B:                            ; CODE XREF: __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$0+9j
.text$x:00006B3B                 retn
.text$x:00006B3B __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$0 endp
.text$x:00006B3B
.text$x:00006B3C
.text$x:00006B3C ; =============== S U B R O U T I N E =======================================
.text$x:00006B3C
.text$x:00006B3C
.text$x:00006B3C __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$1 proc near
.text$x:00006B3C                                         ; DATA XREF: .xdata$x:000136A0o
.text$x:00006B3C                 mov     eax, [ebp-0AB8h]
.text$x:00006B42                 and     eax, 2
.text$x:00006B45                 jz      locret_6B5D
.text$x:00006B4B                 and     dword ptr [ebp-0AB8h], 0FFFFFFFDh
.text$x:00006B52                 lea     ecx, [ebp-0A5Ch]
.text$x:00006B58                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006B5D ; ---------------------------------------------------------------------------
.text$x:00006B5D
.text$x:00006B5D locret_6B5D:                            ; CODE XREF: __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$1+9j
.text$x:00006B5D                 retn
.text$x:00006B5D __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$1 endp
.text$x:00006B5D
.text$x:00006B5E
.text$x:00006B5E ; =============== S U B R O U T I N E =======================================
.text$x:00006B5E
.text$x:00006B5E
.text$x:00006B5E __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$2 proc near
.text$x:00006B5E                                         ; DATA XREF: .xdata$x:000136A8o
.text$x:00006B5E                 mov     eax, [ebp-0AB8h]
.text$x:00006B64                 and     eax, 4
.text$x:00006B67                 jz      locret_6B7F
.text$x:00006B6D                 and     dword ptr [ebp-0AB8h], 0FFFFFFFBh
.text$x:00006B74                 lea     ecx, [ebp-0AB0h]
.text$x:00006B7A                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006B7F ; ---------------------------------------------------------------------------
.text$x:00006B7F
.text$x:00006B7F locret_6B7F:                            ; CODE XREF: __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$2+9j
.text$x:00006B7F                 retn
.text$x:00006B7F __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$2 endp
.text$x:00006B7F
.text$x:00006B80
.text$x:00006B80 ; =============== S U B R O U T I N E =======================================
.text$x:00006B80
.text$x:00006B80
.text$x:00006B80 __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$3 proc near
.text$x:00006B80                                         ; DATA XREF: .xdata$x:000136B0o
.text$x:00006B80                 mov     eax, [ebp-0AB8h]
.text$x:00006B86                 and     eax, 8
.text$x:00006B89                 jz      locret_6BA1
.text$x:00006B8F                 and     dword ptr [ebp-0AB8h], 0FFFFFFF7h
.text$x:00006B96                 lea     ecx, [ebp-0A94h]
.text$x:00006B9C                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006BA1 ; ---------------------------------------------------------------------------
.text$x:00006BA1
.text$x:00006BA1 locret_6BA1:                            ; CODE XREF: __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$3+9j
.text$x:00006BA1                 retn
.text$x:00006BA1 __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$3 endp
.text$x:00006BA1
.text$x:00006BA2
.text$x:00006BA2 ; =============== S U B R O U T I N E =======================================
.text$x:00006BA2
.text$x:00006BA2
.text$x:00006BA2 __ehhandler$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z proc near
.text$x:00006BA2                                         ; DATA XREF: Notepad_plus::fileCloseAll(bool,bool)+5o
.text$x:00006BA2
.text$x:00006BA2 arg_4           = dword ptr  8
.text$x:00006BA2
.text$x:00006BA2                 mov     edx, [esp+arg_4]
.text$x:00006BA6                 lea     eax, [edx+0Ch]
.text$x:00006BA9                 mov     ecx, [edx-0B18h]
.text$x:00006BAF                 xor     ecx, eax
.text$x:00006BB1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006BB6                 mov     ecx, [edx-4]
.text$x:00006BB9                 xor     ecx, eax
.text$x:00006BBB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006BC0                 mov     eax, offset __ehfuncinfo$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z
.text$x:00006BC5                 jmp     ___CxxFrameHandler3
.text$x:00006BC5 __ehhandler$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z endp
.text$x:00006BC5
.text$x:00006BCA
.text$x:00006BCA ; =============== S U B R O U T I N E =======================================
.text$x:00006BCA
.text$x:00006BCA
.text$x:00006BCA __unwindfunclet$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z$0 proc near
.text$x:00006BCA                                         ; DATA XREF: .xdata$x:00013620o
.text$x:00006BCA                 lea     ecx, [ebp-38h]
.text$x:00006BCD                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00006BCD __unwindfunclet$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z$0 endp
.text$x:00006BCD
.text$x:00006BD2
.text$x:00006BD2 ; =============== S U B R O U T I N E =======================================
.text$x:00006BD2
.text$x:00006BD2
.text$x:00006BD2 __unwindfunclet$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z$1 proc near
.text$x:00006BD2                                         ; DATA XREF: .xdata$x:00013628o
.text$x:00006BD2                 lea     ecx, [ebp-2Ch]
.text$x:00006BD5                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00006BD5 __unwindfunclet$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z$1 endp
.text$x:00006BD5
.text$x:00006BDA
.text$x:00006BDA ; =============== S U B R O U T I N E =======================================
.text$x:00006BDA
.text$x:00006BDA
.text$x:00006BDA __unwindfunclet$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z$2 proc near
.text$x:00006BDA                                         ; DATA XREF: .xdata$x:00013630o
.text$x:00006BDA                 lea     ecx, [ebp-44h]
.text$x:00006BDD                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00006BDD __unwindfunclet$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z$2 endp
.text$x:00006BDD
.text$x:00006BE2
.text$x:00006BE2 ; =============== S U B R O U T I N E =======================================
.text$x:00006BE2
.text$x:00006BE2
.text$x:00006BE2 __ehhandler$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z proc near
.text$x:00006BE2                                         ; DATA XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+5o
.text$x:00006BE2
.text$x:00006BE2 arg_4           = dword ptr  8
.text$x:00006BE2
.text$x:00006BE2                 mov     edx, [esp+arg_4]
.text$x:00006BE6                 lea     eax, [edx+0Ch]
.text$x:00006BE9                 mov     ecx, [edx-3Ch]
.text$x:00006BEC                 xor     ecx, eax
.text$x:00006BEE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006BF3                 mov     eax, offset __ehfuncinfo$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z
.text$x:00006BF8                 jmp     ___CxxFrameHandler3
.text$x:00006BF8 __ehhandler$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z endp
.text$x:00006BF8
.text$x:00006BFD
.text$x:00006BFD ; =============== S U B R O U T I N E =======================================
.text$x:00006BFD
.text$x:00006BFD
.text$x:00006BFD __unwindfunclet$?fileCloseAllToLeft@Notepad_plus@@QAE_NXZ$0 proc near
.text$x:00006BFD                                         ; DATA XREF: .xdata$x:000135C0o
.text$x:00006BFD                 lea     ecx, [ebp-28h]
.text$x:00006C00                 jmp     ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)
.text$x:00006C00 __unwindfunclet$?fileCloseAllToLeft@Notepad_plus@@QAE_NXZ$0 endp
.text$x:00006C00
.text$x:00006C05
.text$x:00006C05 ; =============== S U B R O U T I N E =======================================
.text$x:00006C05
.text$x:00006C05
.text$x:00006C05 __ehhandler$?fileCloseAllToLeft@Notepad_plus@@QAE_NXZ proc near
.text$x:00006C05                                         ; DATA XREF: Notepad_plus::fileCloseAllToLeft(void)+5o
.text$x:00006C05
.text$x:00006C05 arg_4           = dword ptr  8
.text$x:00006C05
.text$x:00006C05                 mov     edx, [esp+arg_4]
.text$x:00006C09                 lea     eax, [edx+0Ch]
.text$x:00006C0C                 mov     ecx, [edx-20h]
.text$x:00006C0F                 xor     ecx, eax
.text$x:00006C11                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006C16                 mov     eax, offset __ehfuncinfo$?fileCloseAllToLeft@Notepad_plus@@QAE_NXZ
.text$x:00006C1B                 jmp     ___CxxFrameHandler3
.text$x:00006C1B __ehhandler$?fileCloseAllToLeft@Notepad_plus@@QAE_NXZ endp
.text$x:00006C1B
.text$x:00006C20
.text$x:00006C20 ; =============== S U B R O U T I N E =======================================
.text$x:00006C20
.text$x:00006C20
.text$x:00006C20 __unwindfunclet$?fileCloseAllToRight@Notepad_plus@@QAE_NXZ$0 proc near
.text$x:00006C20                                         ; DATA XREF: .xdata$x:000135B8o
.text$x:00006C20                 lea     ecx, [ebp-2Ch]
.text$x:00006C23                 jmp     ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)
.text$x:00006C23 __unwindfunclet$?fileCloseAllToRight@Notepad_plus@@QAE_NXZ$0 endp
.text$x:00006C23
.text$x:00006C28
.text$x:00006C28 ; =============== S U B R O U T I N E =======================================
.text$x:00006C28
.text$x:00006C28
.text$x:00006C28 __ehhandler$?fileCloseAllToRight@Notepad_plus@@QAE_NXZ proc near
.text$x:00006C28                                         ; DATA XREF: Notepad_plus::fileCloseAllToRight(void)+5o
.text$x:00006C28
.text$x:00006C28 arg_4           = dword ptr  8
.text$x:00006C28
.text$x:00006C28                 mov     edx, [esp+arg_4]
.text$x:00006C2C                 lea     eax, [edx+0Ch]
.text$x:00006C2F                 mov     ecx, [edx-24h]
.text$x:00006C32                 xor     ecx, eax
.text$x:00006C34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006C39                 mov     eax, offset __ehfuncinfo$?fileCloseAllToRight@Notepad_plus@@QAE_NXZ
.text$x:00006C3E                 jmp     ___CxxFrameHandler3
.text$x:00006C3E __ehhandler$?fileCloseAllToRight@Notepad_plus@@QAE_NXZ endp
.text$x:00006C3E
.text$x:00006C43
.text$x:00006C43 ; =============== S U B R O U T I N E =======================================
.text$x:00006C43
.text$x:00006C43
.text$x:00006C43 __unwindfunclet$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z$0 proc near
.text$x:00006C43                                         ; DATA XREF: .xdata$x:00013608o
.text$x:00006C43                 lea     ecx, [ebp-88h]
.text$x:00006C49                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006C49 __unwindfunclet$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z$0 endp
.text$x:00006C49
.text$x:00006C4E
.text$x:00006C4E ; =============== S U B R O U T I N E =======================================
.text$x:00006C4E
.text$x:00006C4E
.text$x:00006C4E __unwindfunclet$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z$1 proc near
.text$x:00006C4E                                         ; DATA XREF: .xdata$x:00013610o
.text$x:00006C4E                 lea     ecx, [ebp-6Ch]
.text$x:00006C51                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006C51 __unwindfunclet$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z$1 endp
.text$x:00006C51
.text$x:00006C56
.text$x:00006C56 ; =============== S U B R O U T I N E =======================================
.text$x:00006C56
.text$x:00006C56
.text$x:00006C56 __unwindfunclet$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z$2 proc near
.text$x:00006C56                                         ; DATA XREF: .xdata$x:00013618o
.text$x:00006C56                 lea     ecx, [ebp-0A4h]
.text$x:00006C5C                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006C5C __unwindfunclet$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z$2 endp
.text$x:00006C5C
.text$x:00006C61
.text$x:00006C61 ; =============== S U B R O U T I N E =======================================
.text$x:00006C61
.text$x:00006C61
.text$x:00006C61 __ehhandler$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z proc near
.text$x:00006C61                                         ; DATA XREF: Notepad_plus::fileSave(Buffer *)+5o
.text$x:00006C61
.text$x:00006C61 arg_4           = dword ptr  8
.text$x:00006C61
.text$x:00006C61                 mov     edx, [esp+arg_4]
.text$x:00006C65                 lea     eax, [edx+0Ch]
.text$x:00006C68                 mov     ecx, [edx-0E8h]
.text$x:00006C6E                 xor     ecx, eax
.text$x:00006C70                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006C75                 mov     ecx, [edx-4]
.text$x:00006C78                 xor     ecx, eax
.text$x:00006C7A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006C7F                 mov     eax, offset __ehfuncinfo$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z
.text$x:00006C84                 jmp     ___CxxFrameHandler3
.text$x:00006C84 __ehhandler$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z endp
.text$x:00006C84
.text$x:00006C89
.text$x:00006C89 ; =============== S U B R O U T I N E =======================================
.text$x:00006C89
.text$x:00006C89
.text$x:00006C89 __unwindfunclet$?fileSaveAs@Notepad_plus@@QAE_NPAVBuffer@@_N@Z$0 proc near
.text$x:00006C89                                         ; DATA XREF: .xdata$x:000135B0o
.text$x:00006C89                 lea     ecx, [ebp-10CCh] ; this
.text$x:00006C8F                 jmp     ??1FileDialog@@QAE@XZ ; FileDialog::~FileDialog(void)
.text$x:00006C8F __unwindfunclet$?fileSaveAs@Notepad_plus@@QAE_NPAVBuffer@@_N@Z$0 endp
.text$x:00006C8F
.text$x:00006C94
.text$x:00006C94 ; =============== S U B R O U T I N E =======================================
.text$x:00006C94
.text$x:00006C94
.text$x:00006C94 __ehhandler$?fileSaveAs@Notepad_plus@@QAE_NPAVBuffer@@_N@Z proc near
.text$x:00006C94                                         ; DATA XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+5o
.text$x:00006C94
.text$x:00006C94 arg_4           = dword ptr  8
.text$x:00006C94
.text$x:00006C94                 mov     edx, [esp+arg_4]
.text$x:00006C98                 lea     eax, [edx+0Ch]
.text$x:00006C9B                 mov     ecx, [edx-10E8h]
.text$x:00006CA1                 xor     ecx, eax
.text$x:00006CA3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006CA8                 mov     ecx, [edx-4]
.text$x:00006CAB                 xor     ecx, eax
.text$x:00006CAD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006CB2                 mov     eax, offset __ehfuncinfo$?fileSaveAs@Notepad_plus@@QAE_NPAVBuffer@@_N@Z
.text$x:00006CB7                 jmp     ___CxxFrameHandler3
.text$x:00006CB7 __ehhandler$?fileSaveAs@Notepad_plus@@QAE_NPAVBuffer@@_N@Z endp
.text$x:00006CB7
.text$x:00006CBC
.text$x:00006CBC ; =============== S U B R O U T I N E =======================================
.text$x:00006CBC
.text$x:00006CBC
.text$x:00006CBC __unwindfunclet$?fileRename@Notepad_plus@@QAE_NPAVBuffer@@@Z$0 proc near
.text$x:00006CBC                                         ; DATA XREF: .xdata$x:000135A8o
.text$x:00006CBC                 lea     ecx, [ebp-10CCh] ; this
.text$x:00006CC2                 jmp     ??1FileDialog@@QAE@XZ ; FileDialog::~FileDialog(void)
.text$x:00006CC2 __unwindfunclet$?fileRename@Notepad_plus@@QAE_NPAVBuffer@@@Z$0 endp
.text$x:00006CC2
.text$x:00006CC7
.text$x:00006CC7 ; =============== S U B R O U T I N E =======================================
.text$x:00006CC7
.text$x:00006CC7
.text$x:00006CC7 __ehhandler$?fileRename@Notepad_plus@@QAE_NPAVBuffer@@@Z proc near
.text$x:00006CC7                                         ; DATA XREF: Notepad_plus::fileRename(Buffer *)+5o
.text$x:00006CC7
.text$x:00006CC7 arg_4           = dword ptr  8
.text$x:00006CC7
.text$x:00006CC7                 mov     edx, [esp+arg_4]
.text$x:00006CCB                 lea     eax, [edx+0Ch]
.text$x:00006CCE                 mov     ecx, [edx-113Ch]
.text$x:00006CD4                 xor     ecx, eax
.text$x:00006CD6                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006CDB                 mov     ecx, [edx-4]
.text$x:00006CDE                 xor     ecx, eax
.text$x:00006CE0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006CE5                 mov     eax, offset __ehfuncinfo$?fileRename@Notepad_plus@@QAE_NPAVBuffer@@@Z
.text$x:00006CEA                 jmp     ___CxxFrameHandler3
.text$x:00006CEA __ehhandler$?fileRename@Notepad_plus@@QAE_NPAVBuffer@@@Z endp
.text$x:00006CEA
.text$x:00006CEF
.text$x:00006CEF ; =============== S U B R O U T I N E =======================================
.text$x:00006CEF
.text$x:00006CEF
.text$x:00006CEF __unwindfunclet$?isFileSession@Notepad_plus@@QAE_NPB_W@Z$0 proc near
.text$x:00006CEF                                         ; DATA XREF: .xdata$x:000135E0o
.text$x:00006CEF                 lea     ecx, [ebp-48h]
.text$x:00006CF2                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006CF2 __unwindfunclet$?isFileSession@Notepad_plus@@QAE_NPB_W@Z$0 endp
.text$x:00006CF2
.text$x:00006CF7
.text$x:00006CF7 ; =============== S U B R O U T I N E =======================================
.text$x:00006CF7
.text$x:00006CF7
.text$x:00006CF7 __unwindfunclet$?isFileSession@Notepad_plus@@QAE_NPB_W@Z$1 proc near
.text$x:00006CF7                                         ; DATA XREF: .xdata$x:000135E8o
.text$x:00006CF7                 lea     ecx, [ebp-2Ch]
.text$x:00006CFA                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006CFA __unwindfunclet$?isFileSession@Notepad_plus@@QAE_NPB_W@Z$1 endp
.text$x:00006CFA
.text$x:00006CFF
.text$x:00006CFF ; =============== S U B R O U T I N E =======================================
.text$x:00006CFF
.text$x:00006CFF
.text$x:00006CFF __ehhandler$?isFileSession@Notepad_plus@@QAE_NPB_W@Z proc near
.text$x:00006CFF                                         ; DATA XREF: Notepad_plus::isFileSession(wchar_t const *)+5o
.text$x:00006CFF
.text$x:00006CFF arg_4           = dword ptr  8
.text$x:00006CFF
.text$x:00006CFF                 mov     edx, [esp+arg_4]
.text$x:00006D03                 lea     eax, [edx+0Ch]
.text$x:00006D06                 mov     ecx, [edx-50h]
.text$x:00006D09                 xor     ecx, eax
.text$x:00006D0B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006D10                 mov     ecx, [edx-4]
.text$x:00006D13                 xor     ecx, eax
.text$x:00006D15                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006D1A                 mov     eax, offset __ehfuncinfo$?isFileSession@Notepad_plus@@QAE_NPB_W@Z
.text$x:00006D1F                 jmp     ___CxxFrameHandler3
.text$x:00006D1F __ehhandler$?isFileSession@Notepad_plus@@QAE_NPB_W@Z endp
.text$x:00006D1F
.text$x:00006D24
.text$x:00006D24 ; =============== S U B R O U T I N E =======================================
.text$x:00006D24
.text$x:00006D24
.text$x:00006D24 __unwindfunclet$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z$0 proc near
.text$x:00006D24                                         ; DATA XREF: .xdata$x:00013678o
.text$x:00006D24                 lea     ecx, [ebp-130Ch] ; this
.text$x:00006D2A                 jmp     ??1FileDialog@@QAE@XZ ; FileDialog::~FileDialog(void)
.text$x:00006D2A __unwindfunclet$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z$0 endp
.text$x:00006D2A
.text$x:00006D2F
.text$x:00006D2F ; =============== S U B R O U T I N E =======================================
.text$x:00006D2F
.text$x:00006D2F
.text$x:00006D2F __unwindfunclet$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z$1 proc near
.text$x:00006D2F                                         ; DATA XREF: .xdata$x:00013680o
.text$x:00006D2F                 lea     ecx, [ebp-250h]
.text$x:00006D35                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006D35 __unwindfunclet$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z$1 endp
.text$x:00006D35
.text$x:00006D3A
.text$x:00006D3A ; =============== S U B R O U T I N E =======================================
.text$x:00006D3A
.text$x:00006D3A
.text$x:00006D3A __unwindfunclet$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z$2 proc near
.text$x:00006D3A                                         ; DATA XREF: .xdata$x:00013688o
.text$x:00006D3A                 lea     ecx, [ebp-234h]
.text$x:00006D40                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006D40 __unwindfunclet$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z$2 endp
.text$x:00006D40
.text$x:00006D45
.text$x:00006D45 ; =============== S U B R O U T I N E =======================================
.text$x:00006D45
.text$x:00006D45
.text$x:00006D45 __unwindfunclet$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z$3 proc near
.text$x:00006D45                                         ; DATA XREF: .xdata$x:00013690o
.text$x:00006D45                 lea     ecx, [ebp-135Ch] ; this
.text$x:00006D4B                 jmp     ??1Session@@QAE@XZ ; Session::~Session(void)
.text$x:00006D4B __unwindfunclet$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z$3 endp
.text$x:00006D4B
.text$x:00006D50
.text$x:00006D50 ; =============== S U B R O U T I N E =======================================
.text$x:00006D50
.text$x:00006D50
.text$x:00006D50 __ehhandler$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z proc near
.text$x:00006D50                                         ; DATA XREF: Notepad_plus::fileLoadSession(wchar_t const *)+5o
.text$x:00006D50
.text$x:00006D50 arg_4           = dword ptr  8
.text$x:00006D50
.text$x:00006D50                 mov     edx, [esp+arg_4]
.text$x:00006D54                 lea     eax, [edx+0Ch]
.text$x:00006D57                 mov     ecx, [edx-1354h]
.text$x:00006D5D                 xor     ecx, eax
.text$x:00006D5F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006D64                 mov     ecx, [edx-4]
.text$x:00006D67                 xor     ecx, eax
.text$x:00006D69                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006D6E                 mov     eax, offset __ehfuncinfo$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z
.text$x:00006D73                 jmp     ___CxxFrameHandler3
.text$x:00006D73 __ehhandler$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z endp
.text$x:00006D73
.text$x:00006D78
.text$x:00006D78 ; =============== S U B R O U T I N E =======================================
.text$x:00006D78
.text$x:00006D78
.text$x:00006D78 __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z$0 proc near
.text$x:00006D78                                         ; DATA XREF: .xdata$x:000135F0o
.text$x:00006D78                 lea     ecx, [ebp-0F0h] ; this
.text$x:00006D7E                 jmp     ??1Session@@QAE@XZ ; Session::~Session(void)
.text$x:00006D7E __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z$0 endp
.text$x:00006D7E
.text$x:00006D83
.text$x:00006D83 ; =============== S U B R O U T I N E =======================================
.text$x:00006D83
.text$x:00006D83
.text$x:00006D83 __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z$1 proc near
.text$x:00006D83                                         ; DATA XREF: .xdata$x:000135F8o
.text$x:00006D83                 mov     ecx, [ebp-0BCh]
.text$x:00006D89                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006D89 __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z$1 endp
.text$x:00006D89
.text$x:00006D8E
.text$x:00006D8E ; =============== S U B R O U T I N E =======================================
.text$x:00006D8E
.text$x:00006D8E
.text$x:00006D8E __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z$2 proc near
.text$x:00006D8E                                         ; DATA XREF: .xdata$x:00013600o
.text$x:00006D8E                 lea     ecx, [ebp-0A8h] ; this
.text$x:00006D94                 jmp     ??1sessionFileInfo@@QAE@XZ ; sessionFileInfo::~sessionFileInfo(void)
.text$x:00006D94 __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z$2 endp
.text$x:00006D94
.text$x:00006D99
.text$x:00006D99 ; =============== S U B R O U T I N E =======================================
.text$x:00006D99
.text$x:00006D99
.text$x:00006D99 __ehhandler$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z proc near
.text$x:00006D99                                         ; DATA XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *)+5o
.text$x:00006D99
.text$x:00006D99 arg_4           = dword ptr  8
.text$x:00006D99
.text$x:00006D99                 mov     edx, [esp+arg_4]
.text$x:00006D9D                 lea     eax, [edx+0Ch]
.text$x:00006DA0                 mov     ecx, [edx-0E8h]
.text$x:00006DA6                 xor     ecx, eax
.text$x:00006DA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006DAD                 mov     ecx, [edx-4]
.text$x:00006DB0                 xor     ecx, eax
.text$x:00006DB2                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006DB7                 mov     eax, offset __ehfuncinfo$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z
.text$x:00006DBC                 jmp     ___CxxFrameHandler3
.text$x:00006DBC __ehhandler$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z endp
.text$x:00006DBC
.text$x:00006DC1
.text$x:00006DC1 ; =============== S U B R O U T I N E =======================================
.text$x:00006DC1
.text$x:00006DC1
.text$x:00006DC1 __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z$0 proc near
.text$x:00006DC1                                         ; DATA XREF: .xdata$x:000135D0o
.text$x:00006DC1                 lea     ecx, [ebp-10E8h] ; this
.text$x:00006DC7                 jmp     ??1FileDialog@@QAE@XZ ; FileDialog::~FileDialog(void)
.text$x:00006DC7 __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z$0 endp
.text$x:00006DC7
.text$x:00006DCC
.text$x:00006DCC ; =============== S U B R O U T I N E =======================================
.text$x:00006DCC
.text$x:00006DCC
.text$x:00006DCC __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z$1 proc near
.text$x:00006DCC                                         ; DATA XREF: .xdata$x:000135D8o
.text$x:00006DCC                 lea     ecx, [ebp-2Ch]
.text$x:00006DCF                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006DCF __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z$1 endp
.text$x:00006DCF
.text$x:00006DD4
.text$x:00006DD4 ; =============== S U B R O U T I N E =======================================
.text$x:00006DD4
.text$x:00006DD4
.text$x:00006DD4 __ehhandler$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z proc near
.text$x:00006DD4                                         ; DATA XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *)+5o
.text$x:00006DD4
.text$x:00006DD4 arg_4           = dword ptr  8
.text$x:00006DD4
.text$x:00006DD4                 mov     edx, [esp+arg_4]
.text$x:00006DD8                 lea     eax, [edx+0Ch]
.text$x:00006DDB                 mov     ecx, [edx-10F0h]
.text$x:00006DE1                 xor     ecx, eax
.text$x:00006DE3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006DE8                 mov     ecx, [edx-4]
.text$x:00006DEB                 xor     ecx, eax
.text$x:00006DED                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006DF2                 mov     eax, offset __ehfuncinfo$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z
.text$x:00006DF7                 jmp     ___CxxFrameHandler3
.text$x:00006DF7 __ehhandler$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z endp
.text$x:00006DF7
.text$x:00006DFC
.text$x:00006DFC ; =============== S U B R O U T I N E =======================================
.text$x:00006DFC
.text$x:00006DFC
.text$x:00006DFC __unwindfunclet$?loadLastSession@Notepad_plus@@QAEXXZ$0 proc near
.text$x:00006DFC                                         ; DATA XREF: .xdata$x:000135A0o
.text$x:00006DFC                 lea     ecx, [ebp-48h]  ; this
.text$x:00006DFF                 jmp     ??1Session@@QAE@XZ ; Session::~Session(void)
.text$x:00006DFF __unwindfunclet$?loadLastSession@Notepad_plus@@QAEXXZ$0 endp
.text$x:00006DFF
.text$x:00006E04
.text$x:00006E04 ; =============== S U B R O U T I N E =======================================
.text$x:00006E04
.text$x:00006E04
.text$x:00006E04 __ehhandler$?loadLastSession@Notepad_plus@@QAEXXZ proc near
.text$x:00006E04                                         ; DATA XREF: Notepad_plus::loadLastSession(void)+5o
.text$x:00006E04
.text$x:00006E04 arg_4           = dword ptr  8
.text$x:00006E04
.text$x:00006E04                 mov     edx, [esp+arg_4]
.text$x:00006E08                 lea     eax, [edx+0Ch]
.text$x:00006E0B                 mov     ecx, [edx-40h]
.text$x:00006E0E                 xor     ecx, eax
.text$x:00006E10                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006E15                 mov     eax, offset __ehfuncinfo$?loadLastSession@Notepad_plus@@QAEXXZ
.text$x:00006E1A                 jmp     ___CxxFrameHandler3
.text$x:00006E1A __ehhandler$?loadLastSession@Notepad_plus@@QAEXXZ endp
.text$x:00006E1A
.text$x:00006E1F
.text$x:00006E1F ; =============== S U B R O U T I N E =======================================
.text$x:00006E1F
.text$x:00006E1F
.text$x:00006E1F __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$0 proc near
.text$x:00006E1F                                         ; DATA XREF: .xdata$x:000139A8o
.text$x:00006E1F                 lea     ecx, [ebp-108h]
.text$x:00006E25                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00006E25 __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$0 endp
.text$x:00006E25
.text$x:00006E2A
.text$x:00006E2A ; =============== S U B R O U T I N E =======================================
.text$x:00006E2A
.text$x:00006E2A
.text$x:00006E2A __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$1 proc near
.text$x:00006E2A                                         ; DATA XREF: .xdata$x:000139B0o
.text$x:00006E2A                                         ; .xdata$x:000139B8o
.text$x:00006E2A                 lea     ecx, [ebp-0ACh]
.text$x:00006E30                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00006E30 __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$1 endp
.text$x:00006E30
.text$x:00006E35
.text$x:00006E35 ; =============== S U B R O U T I N E =======================================
.text$x:00006E35
.text$x:00006E35
.text$x:00006E35 __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$2 proc near
.text$x:00006E35                                         ; DATA XREF: .xdata$x:000139C0o
.text$x:00006E35                 mov     ecx, [ebp-0ECh]
.text$x:00006E3B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00006E3B __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$2 endp
.text$x:00006E3B
.text$x:00006E40
.text$x:00006E40 ; =============== S U B R O U T I N E =======================================
.text$x:00006E40
.text$x:00006E40
.text$x:00006E40 __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$4 proc near
.text$x:00006E40                                         ; DATA XREF: .xdata$x:000139C8o
.text$x:00006E40                 lea     ecx, [ebp-150h]
.text$x:00006E46                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00006E46 __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$4 endp
.text$x:00006E46
.text$x:00006E4B
.text$x:00006E4B ; =============== S U B R O U T I N E =======================================
.text$x:00006E4B
.text$x:00006E4B
.text$x:00006E4B __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$5 proc near
.text$x:00006E4B                                         ; DATA XREF: .xdata$x:000139D0o
.text$x:00006E4B                                         ; .xdata$x:000139D8o
.text$x:00006E4B                 lea     ecx, [ebp-0BCh]
.text$x:00006E51                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00006E51 __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$5 endp
.text$x:00006E51
.text$x:00006E56
.text$x:00006E56 ; =============== S U B R O U T I N E =======================================
.text$x:00006E56
.text$x:00006E56
.text$x:00006E56 __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$6 proc near
.text$x:00006E56                                         ; DATA XREF: .xdata$x:000139E0o
.text$x:00006E56                 mov     ecx, [ebp-0C0h]
.text$x:00006E5C                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00006E5C __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$6 endp
.text$x:00006E5C
.text$x:00006E61
.text$x:00006E61 ; =============== S U B R O U T I N E =======================================
.text$x:00006E61
.text$x:00006E61
.text$x:00006E61 __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$8 proc near
.text$x:00006E61                                         ; DATA XREF: .xdata$x:000139E8o
.text$x:00006E61                 lea     ecx, [ebp-114h]
.text$x:00006E67                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00006E67 __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$8 endp
.text$x:00006E67
.text$x:00006E6C
.text$x:00006E6C ; =============== S U B R O U T I N E =======================================
.text$x:00006E6C
.text$x:00006E6C
.text$x:00006E6C __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$9 proc near
.text$x:00006E6C                                         ; DATA XREF: .xdata$x:000139F0o
.text$x:00006E6C                                         ; .xdata$x:000139F8o
.text$x:00006E6C                 lea     ecx, [ebp-0CCh]
.text$x:00006E72                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00006E72 __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$9 endp
.text$x:00006E72
.text$x:00006E77
.text$x:00006E77 ; =============== S U B R O U T I N E =======================================
.text$x:00006E77
.text$x:00006E77
.text$x:00006E77 __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$10 proc near
.text$x:00006E77                                         ; DATA XREF: .xdata$x:00013A00o
.text$x:00006E77                 mov     ecx, [ebp-0F4h]
.text$x:00006E7D                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00006E7D __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$10 endp
.text$x:00006E7D
.text$x:00006E82
.text$x:00006E82 ; =============== S U B R O U T I N E =======================================
.text$x:00006E82
.text$x:00006E82
.text$x:00006E82 __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$12 proc near
.text$x:00006E82                                         ; DATA XREF: .xdata$x:00013A08o
.text$x:00006E82                 lea     ecx, [ebp-144h]
.text$x:00006E88                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00006E88 __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$12 endp
.text$x:00006E88
.text$x:00006E8D
.text$x:00006E8D ; =============== S U B R O U T I N E =======================================
.text$x:00006E8D
.text$x:00006E8D
.text$x:00006E8D __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$13 proc near
.text$x:00006E8D                                         ; DATA XREF: .xdata$x:00013A10o
.text$x:00006E8D                                         ; .xdata$x:00013A18o
.text$x:00006E8D                 lea     ecx, [ebp-0DCh]
.text$x:00006E93                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00006E93 __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$13 endp
.text$x:00006E93
.text$x:00006E98
.text$x:00006E98 ; =============== S U B R O U T I N E =======================================
.text$x:00006E98
.text$x:00006E98
.text$x:00006E98 __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$14 proc near
.text$x:00006E98                                         ; DATA XREF: .xdata$x:00013A20o
.text$x:00006E98                 mov     ecx, [ebp-0E8h]
.text$x:00006E9E                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00006E9E __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$14 endp
.text$x:00006E9E
.text$x:00006EA3
.text$x:00006EA3 ; =============== S U B R O U T I N E =======================================
.text$x:00006EA3
.text$x:00006EA3
.text$x:00006EA3 __ehhandler$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z proc near
.text$x:00006EA3                                         ; DATA XREF: Notepad_plus::loadSession(Session &,bool)+5o
.text$x:00006EA3
.text$x:00006EA3 arg_4           = dword ptr  8
.text$x:00006EA3
.text$x:00006EA3                 mov     edx, [esp+arg_4]
.text$x:00006EA7                 lea     eax, [edx+0Ch]
.text$x:00006EAA                 mov     ecx, [edx-154h]
.text$x:00006EB0                 xor     ecx, eax
.text$x:00006EB2                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006EB7                 mov     eax, offset __ehfuncinfo$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z
.text$x:00006EBC                 jmp     ___CxxFrameHandler3
.text$x:00006EBC __ehhandler$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z endp
.text$x:00006EBC
.text$x:00006EC1
.text$x:00006EC1 ; =============== S U B R O U T I N E =======================================
.text$x:00006EC1
.text$x:00006EC1
.text$x:00006EC1 __unwindfunclet$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z$0 proc near
.text$x:00006EC1                                         ; DATA XREF: .xdata$x:00013660o
.text$x:00006EC1                 lea     ecx, [ebp+0Ch]
.text$x:00006EC4                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006EC4 __unwindfunclet$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z$0 endp
.text$x:00006EC4
.text$x:00006EC9
.text$x:00006EC9 ; =============== S U B R O U T I N E =======================================
.text$x:00006EC9
.text$x:00006EC9
.text$x:00006EC9 __unwindfunclet$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z$1 proc near
.text$x:00006EC9                                         ; DATA XREF: .xdata$x:00013668o
.text$x:00006EC9                 lea     ecx, [ebp-234h]
.text$x:00006ECF                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006ECF __unwindfunclet$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z$1 endp
.text$x:00006ECF
.text$x:00006ED4
.text$x:00006ED4 ; =============== S U B R O U T I N E =======================================
.text$x:00006ED4
.text$x:00006ED4
.text$x:00006ED4 __unwindfunclet$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z$2 proc near
.text$x:00006ED4                                         ; DATA XREF: .xdata$x:00013670o
.text$x:00006ED4                 lea     ecx, [ebp-250h]
.text$x:00006EDA                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006EDA __unwindfunclet$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z$2 endp
.text$x:00006EDA
.text$x:00006EDF
.text$x:00006EDF ; =============== S U B R O U T I N E =======================================
.text$x:00006EDF
.text$x:00006EDF
.text$x:00006EDF __unwindfunclet$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z$3 proc near
.text$x:00006EDF                                         ; DATA XREF: .xdata$x:00013658o
.text$x:00006EDF                 mov     eax, [ebp-260h]
.text$x:00006EE5                 and     eax, 1
.text$x:00006EE8                 jz      locret_6EFD
.text$x:00006EEE                 and     dword ptr [ebp-260h], 0FFFFFFFEh
.text$x:00006EF5                 mov     ecx, [ebp+8]
.text$x:00006EF8                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006EFD ; ---------------------------------------------------------------------------
.text$x:00006EFD
.text$x:00006EFD locret_6EFD:                            ; CODE XREF: __unwindfunclet$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z$3+9j
.text$x:00006EFD                 retn
.text$x:00006EFD __unwindfunclet$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z$3 endp
.text$x:00006EFD
.text$x:00006EFE
.text$x:00006EFE ; =============== S U B R O U T I N E =======================================
.text$x:00006EFE
.text$x:00006EFE
.text$x:00006EFE __ehhandler$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z proc near
.text$x:00006EFE                                         ; DATA XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+5o
.text$x:00006EFE
.text$x:00006EFE arg_4           = dword ptr  8
.text$x:00006EFE
.text$x:00006EFE                 mov     edx, [esp+arg_4]
.text$x:00006F02                 lea     eax, [edx+0Ch]
.text$x:00006F05                 mov     ecx, [edx-274h]
.text$x:00006F0B                 xor     ecx, eax
.text$x:00006F0D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006F12                 mov     ecx, [edx-4]
.text$x:00006F15                 xor     ecx, eax
.text$x:00006F17                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006F1C                 mov     eax, offset __ehfuncinfo$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z
.text$x:00006F21                 jmp     ___CxxFrameHandler3
.text$x:00006F21 __ehhandler$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z endp
.text$x:00006F21
.text$x:00006F26
.text$x:00006F26 ; =============== S U B R O U T I N E =======================================
.text$x:00006F26
.text$x:00006F26
.text$x:00006F26 __unwindfunclet$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z$0 proc near
.text$x:00006F26                                         ; DATA XREF: .xdata$x:00013638o
.text$x:00006F26                 lea     ecx, [ebp-2Ch]
.text$x:00006F29                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006F29 __unwindfunclet$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z$0 endp
.text$x:00006F29
.text$x:00006F2E
.text$x:00006F2E ; =============== S U B R O U T I N E =======================================
.text$x:00006F2E
.text$x:00006F2E
.text$x:00006F2E __unwindfunclet$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z$1 proc near
.text$x:00006F2E                                         ; DATA XREF: .xdata$x:00013640o
.text$x:00006F2E                 mov     ecx, [ebp-0C0h]
.text$x:00006F34                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006F34 __unwindfunclet$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z$1 endp
.text$x:00006F34
.text$x:00006F39
.text$x:00006F39 ; =============== S U B R O U T I N E =======================================
.text$x:00006F39
.text$x:00006F39
.text$x:00006F39 __unwindfunclet$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z$2 proc near
.text$x:00006F39                                         ; DATA XREF: .xdata$x:00013648o
.text$x:00006F39                 lea     ecx, [ebp-48h]
.text$x:00006F3C                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006F3C __unwindfunclet$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z$2 endp
.text$x:00006F3C
.text$x:00006F41
.text$x:00006F41 ; =============== S U B R O U T I N E =======================================
.text$x:00006F41
.text$x:00006F41
.text$x:00006F41 __unwindfunclet$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z$3 proc near
.text$x:00006F41                                         ; DATA XREF: .xdata$x:00013650o
.text$x:00006F41                 lea     ecx, [ebp-64h]
.text$x:00006F44                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006F44 __unwindfunclet$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z$3 endp
.text$x:00006F44
.text$x:00006F49
.text$x:00006F49 ; =============== S U B R O U T I N E =======================================
.text$x:00006F49
.text$x:00006F49
.text$x:00006F49 __ehhandler$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z proc near
.text$x:00006F49                                         ; DATA XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+5o
.text$x:00006F49
.text$x:00006F49 arg_4           = dword ptr  8
.text$x:00006F49
.text$x:00006F49                 mov     edx, [esp+arg_4]
.text$x:00006F4D                 lea     eax, [edx+0Ch]
.text$x:00006F50                 mov     ecx, [edx-0C0h]
.text$x:00006F56                 xor     ecx, eax
.text$x:00006F58                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006F5D                 mov     ecx, [edx-4]
.text$x:00006F60                 xor     ecx, eax
.text$x:00006F62                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006F67                 mov     eax, offset __ehfuncinfo$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z
.text$x:00006F6C                 jmp     ___CxxFrameHandler3
.text$x:00006F6C __ehhandler$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z endp
.text$x:00006F6C
.text$x:00006F6C ; ---------------------------------------------------------------------------
.text$x:00006F71                 align 4
.text$x:00006F71 _text$x         ends
.text$x:00006F71
.text$mn:00006F74 ; ===========================================================================
.text$mn:00006F74
.text$mn:00006F74 ; Segment type: Pure code
.text$mn:00006F74 ; Segment permissions: Read/Execute
.text$mn:00006F74 _text$mn        segment para public 'CODE' use32
.text$mn:00006F74                 assume cs:_text$mn
.text$mn:00006F74                 ;org 6F74h
.text$mn:00006F74 ; COMDAT (pick any)
.text$mn:00006F74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F74
.text$mn:00006F74 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F74
.text$mn:00006F74 ; Attributes: bp-based frame
.text$mn:00006F74
.text$mn:00006F74 ; bool __cdecl std::operator==<unsigned int, unsigned int>(class std::allocator<unsigned int> const &, class std::allocator<unsigned int> const &)
.text$mn:00006F74                 public ??$?8II@std@@YA_NABV?$allocator@I@0@0@Z
.text$mn:00006F74 ??$?8II@std@@YA_NABV?$allocator@I@0@0@Z proc near
.text$mn:00006F74                                         ; CODE XREF: std::operator==<std::allocator<uint>,std::allocator<uint>>(std::_Wrap_alloc<std::allocator<uint>> const &,std::_Wrap_alloc<std::allocator<uint>> const &)+1Ep
.text$mn:00006F74                 push    ebp
.text$mn:00006F75                 mov     ebp, esp
.text$mn:00006F77                 mov     al, 1
.text$mn:00006F79                 pop     ebp
.text$mn:00006F7A                 retn
.text$mn:00006F7A ??$?8II@std@@YA_NABV?$allocator@I@0@0@Z endp
.text$mn:00006F7A
.text$mn:00006F7A ; ---------------------------------------------------------------------------
.text$mn:00006F7B                 align 4
.text$mn:00006F7B _text$mn        ends
.text$mn:00006F7B
.text$mn:00006F7C ; ===========================================================================
.text$mn:00006F7C
.text$mn:00006F7C ; Segment type: Pure code
.text$mn:00006F7C ; Segment permissions: Read/Execute
.text$mn:00006F7C _text$mn        segment para public 'CODE' use32
.text$mn:00006F7C                 assume cs:_text$mn
.text$mn:00006F7C                 ;org 6F7Ch
.text$mn:00006F7C ; COMDAT (pick any)
.text$mn:00006F7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F7C
.text$mn:00006F7C ; =============== S U B R O U T I N E =======================================
.text$mn:00006F7C
.text$mn:00006F7C ; Attributes: bp-based frame
.text$mn:00006F7C
.text$mn:00006F7C ; bool __cdecl std::operator==<class std::allocator<unsigned int>, class std::allocator<unsigned int>>(struct std::_Wrap_alloc<class std::allocator<unsigned int>> const &, struct std::_Wrap_alloc<class std::allocator<unsigned int>> const &)
.text$mn:00006F7C                 public ??$?8V?$allocator@I@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@I@std@@@0@0@Z
.text$mn:00006F7C ??$?8V?$allocator@I@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@I@std@@@0@0@Z proc near
.text$mn:00006F7C                                         ; CODE XREF: std::operator!=<std::allocator<uint>,std::allocator<uint>>(std::_Wrap_alloc<std::allocator<uint>> const &,std::_Wrap_alloc<std::allocator<uint>> const &)+Cp
.text$mn:00006F7C
.text$mn:00006F7C var_2           = byte ptr -2
.text$mn:00006F7C var_1           = byte ptr -1
.text$mn:00006F7C arg_0           = dword ptr  8
.text$mn:00006F7C arg_4           = dword ptr  0Ch
.text$mn:00006F7C
.text$mn:00006F7C                 push    ebp
.text$mn:00006F7D                 mov     ebp, esp
.text$mn:00006F7F                 push    ecx
.text$mn:00006F80                 mov     eax, [ebp+arg_4]
.text$mn:00006F83                 push    eax
.text$mn:00006F84                 lea     ecx, [ebp+var_1]
.text$mn:00006F87                 call    ??0?$allocator@I@std@@QAE@ABV01@@Z ; std::allocator<uint>::allocator<uint>(std::allocator<uint> const &)
.text$mn:00006F8C                 push    eax
.text$mn:00006F8D                 mov     ecx, [ebp+arg_0]
.text$mn:00006F90                 push    ecx
.text$mn:00006F91                 lea     ecx, [ebp+var_2]
.text$mn:00006F94                 call    ??0?$allocator@I@std@@QAE@ABV01@@Z ; std::allocator<uint>::allocator<uint>(std::allocator<uint> const &)
.text$mn:00006F99                 push    eax
.text$mn:00006F9A                 call    ??$?8II@std@@YA_NABV?$allocator@I@0@0@Z ; std::operator==<uint,uint>(std::allocator<uint> const &,std::allocator<uint> const &)
.text$mn:00006F9F                 add     esp, 8
.text$mn:00006FA2                 mov     esp, ebp
.text$mn:00006FA4                 pop     ebp
.text$mn:00006FA5                 retn
.text$mn:00006FA5 ??$?8V?$allocator@I@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@I@std@@@0@0@Z endp
.text$mn:00006FA5
.text$mn:00006FA5 ; ---------------------------------------------------------------------------
.text$mn:00006FA6                 align 4
.text$mn:00006FA6 _text$mn        ends
.text$mn:00006FA6
.text$mn:00006FA8 ; ===========================================================================
.text$mn:00006FA8
.text$mn:00006FA8 ; Segment type: Pure code
.text$mn:00006FA8 ; Segment permissions: Read/Execute
.text$mn:00006FA8 _text$mn        segment para public 'CODE' use32
.text$mn:00006FA8                 assume cs:_text$mn
.text$mn:00006FA8                 ;org 6FA8h
.text$mn:00006FA8 ; COMDAT (pick any)
.text$mn:00006FA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006FA8
.text$mn:00006FA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006FA8
.text$mn:00006FA8 ; Attributes: bp-based frame
.text$mn:00006FA8
.text$mn:00006FA8 ; bool __cdecl std::operator==<class std::allocator<wchar_t>, class std::allocator<wchar_t>>(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &, struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:00006FA8                 public ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
.text$mn:00006FA8 ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z proc near
.text$mn:00006FA8                                         ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+Cp
.text$mn:00006FA8
.text$mn:00006FA8 var_2           = byte ptr -2
.text$mn:00006FA8 var_1           = byte ptr -1
.text$mn:00006FA8 arg_0           = dword ptr  8
.text$mn:00006FA8 arg_4           = dword ptr  0Ch
.text$mn:00006FA8
.text$mn:00006FA8                 push    ebp
.text$mn:00006FA9                 mov     ebp, esp
.text$mn:00006FAB                 push    ecx
.text$mn:00006FAC                 mov     eax, [ebp+arg_4]
.text$mn:00006FAF                 push    eax
.text$mn:00006FB0                 lea     ecx, [ebp+var_1]
.text$mn:00006FB3                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00006FB8                 push    eax
.text$mn:00006FB9                 mov     ecx, [ebp+arg_0]
.text$mn:00006FBC                 push    ecx
.text$mn:00006FBD                 lea     ecx, [ebp+var_2]
.text$mn:00006FC0                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00006FC5                 push    eax
.text$mn:00006FC6                 call    ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z ; std::operator==<wchar_t,wchar_t>(std::allocator<wchar_t> const &,std::allocator<wchar_t> const &)
.text$mn:00006FCB                 add     esp, 8
.text$mn:00006FCE                 mov     esp, ebp
.text$mn:00006FD0                 pop     ebp
.text$mn:00006FD1                 retn
.text$mn:00006FD1 ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z endp
.text$mn:00006FD1
.text$mn:00006FD1 ; ---------------------------------------------------------------------------
.text$mn:00006FD2                 align 4
.text$mn:00006FD2 _text$mn        ends
.text$mn:00006FD2
.text$mn:00006FD4 ; ===========================================================================
.text$mn:00006FD4
.text$mn:00006FD4 ; Segment type: Pure code
.text$mn:00006FD4 ; Segment permissions: Read/Execute
.text$mn:00006FD4 _text$mn        segment para public 'CODE' use32
.text$mn:00006FD4                 assume cs:_text$mn
.text$mn:00006FD4                 ;org 6FD4h
.text$mn:00006FD4 ; COMDAT (pick any)
.text$mn:00006FD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006FD4
.text$mn:00006FD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006FD4
.text$mn:00006FD4 ; Attributes: bp-based frame
.text$mn:00006FD4
.text$mn:00006FD4 ; int __cdecl std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, wchar_t *Str)
.text$mn:00006FD4                 public ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z
.text$mn:00006FD4 ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z proc near
.text$mn:00006FD4                                         ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+13Ap
.text$mn:00006FD4                                         ; Notepad_plus::fileCloseAll(bool,bool)+489p ...
.text$mn:00006FD4
.text$mn:00006FD4 var_4           = dword ptr -4
.text$mn:00006FD4 arg_0           = dword ptr  8
.text$mn:00006FD4 Str             = dword ptr  0Ch
.text$mn:00006FD4
.text$mn:00006FD4                 push    ebp
.text$mn:00006FD5                 mov     ebp, esp
.text$mn:00006FD7                 push    ecx
.text$mn:00006FD8                 mov     eax, [ebp+Str]
.text$mn:00006FDB                 push    eax             ; Str
.text$mn:00006FDC                 mov     ecx, [ebp+arg_0]
.text$mn:00006FDF                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)
.text$mn:00006FE4                 test    eax, eax
.text$mn:00006FE6                 jnz     short loc_6FF1
.text$mn:00006FE8                 mov     [ebp+var_4], 1
.text$mn:00006FEF                 jmp     short loc_6FF8
.text$mn:00006FF1 ; ---------------------------------------------------------------------------
.text$mn:00006FF1
.text$mn:00006FF1 loc_6FF1:                               ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+12j
.text$mn:00006FF1                 mov     [ebp+var_4], 0
.text$mn:00006FF8
.text$mn:00006FF8 loc_6FF8:                               ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+1Bj
.text$mn:00006FF8                 mov     al, byte ptr [ebp+var_4]
.text$mn:00006FFB                 mov     esp, ebp
.text$mn:00006FFD                 pop     ebp
.text$mn:00006FFE                 retn
.text$mn:00006FFE ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z endp
.text$mn:00006FFE
.text$mn:00006FFE ; ---------------------------------------------------------------------------
.text$mn:00006FFF                 align 10h
.text$mn:00006FFF _text$mn        ends
.text$mn:00006FFF
.text$mn:00007000 ; ===========================================================================
.text$mn:00007000
.text$mn:00007000 ; Segment type: Pure code
.text$mn:00007000 ; Segment permissions: Read/Execute
.text$mn:00007000 _text$mn        segment para public 'CODE' use32
.text$mn:00007000                 assume cs:_text$mn
.text$mn:00007000                 ;org 7000h
.text$mn:00007000 ; COMDAT (pick any)
.text$mn:00007000                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007000
.text$mn:00007000 ; =============== S U B R O U T I N E =======================================
.text$mn:00007000
.text$mn:00007000 ; Attributes: bp-based frame
.text$mn:00007000
.text$mn:00007000 ; bool __cdecl std::operator==<wchar_t, wchar_t>(class std::allocator<wchar_t> const &, class std::allocator<wchar_t> const &)
.text$mn:00007000                 public ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z
.text$mn:00007000 ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z proc near
.text$mn:00007000                                         ; CODE XREF: std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+1Ep
.text$mn:00007000                 push    ebp
.text$mn:00007001                 mov     ebp, esp
.text$mn:00007003                 mov     al, 1
.text$mn:00007005                 pop     ebp
.text$mn:00007006                 retn
.text$mn:00007006 ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z endp
.text$mn:00007006
.text$mn:00007006 ; ---------------------------------------------------------------------------
.text$mn:00007007                 align 4
.text$mn:00007007 _text$mn        ends
.text$mn:00007007
.text$mn:00007008 ; ===========================================================================
.text$mn:00007008
.text$mn:00007008 ; Segment type: Pure code
.text$mn:00007008 ; Segment permissions: Read/Execute
.text$mn:00007008 _text$mn        segment para public 'CODE' use32
.text$mn:00007008                 assume cs:_text$mn
.text$mn:00007008                 ;org 7008h
.text$mn:00007008 ; COMDAT (pick any)
.text$mn:00007008                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007008
.text$mn:00007008 ; =============== S U B R O U T I N E =======================================
.text$mn:00007008
.text$mn:00007008 ; Attributes: bp-based frame
.text$mn:00007008
.text$mn:00007008 ; bool __cdecl std::operator!=<class std::allocator<unsigned int>, class std::allocator<unsigned int>>(struct std::_Wrap_alloc<class std::allocator<unsigned int>> const &, struct std::_Wrap_alloc<class std::allocator<unsigned int>> const &)
.text$mn:00007008                 public ??$?9V?$allocator@I@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@I@std@@@0@0@Z
.text$mn:00007008 ??$?9V?$allocator@I@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@I@std@@@0@0@Z proc near
.text$mn:00007008                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+55p
.text$mn:00007008
.text$mn:00007008 var_4           = dword ptr -4
.text$mn:00007008 arg_0           = dword ptr  8
.text$mn:00007008 arg_4           = dword ptr  0Ch
.text$mn:00007008
.text$mn:00007008                 push    ebp
.text$mn:00007009                 mov     ebp, esp
.text$mn:0000700B                 push    ecx
.text$mn:0000700C                 mov     eax, [ebp+arg_4]
.text$mn:0000700F                 push    eax
.text$mn:00007010                 mov     ecx, [ebp+arg_0]
.text$mn:00007013                 push    ecx
.text$mn:00007014                 call    ??$?8V?$allocator@I@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@I@std@@@0@0@Z ; std::operator==<std::allocator<uint>,std::allocator<uint>>(std::_Wrap_alloc<std::allocator<uint>> const &,std::_Wrap_alloc<std::allocator<uint>> const &)
.text$mn:00007019                 add     esp, 8
.text$mn:0000701C                 movzx   edx, al
.text$mn:0000701F                 test    edx, edx
.text$mn:00007021                 jnz     short loc_702C
.text$mn:00007023                 mov     [ebp+var_4], 1
.text$mn:0000702A                 jmp     short loc_7033
.text$mn:0000702C ; ---------------------------------------------------------------------------
.text$mn:0000702C
.text$mn:0000702C loc_702C:                               ; CODE XREF: std::operator!=<std::allocator<uint>,std::allocator<uint>>(std::_Wrap_alloc<std::allocator<uint>> const &,std::_Wrap_alloc<std::allocator<uint>> const &)+19j
.text$mn:0000702C                 mov     [ebp+var_4], 0
.text$mn:00007033
.text$mn:00007033 loc_7033:                               ; CODE XREF: std::operator!=<std::allocator<uint>,std::allocator<uint>>(std::_Wrap_alloc<std::allocator<uint>> const &,std::_Wrap_alloc<std::allocator<uint>> const &)+22j
.text$mn:00007033                 mov     al, byte ptr [ebp+var_4]
.text$mn:00007036                 mov     esp, ebp
.text$mn:00007038                 pop     ebp
.text$mn:00007039                 retn
.text$mn:00007039 ??$?9V?$allocator@I@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@I@std@@@0@0@Z endp
.text$mn:00007039
.text$mn:00007039 ; ---------------------------------------------------------------------------
.text$mn:0000703A                 align 4
.text$mn:0000703A _text$mn        ends
.text$mn:0000703A
.text$mn:0000703C ; ===========================================================================
.text$mn:0000703C
.text$mn:0000703C ; Segment type: Pure code
.text$mn:0000703C ; Segment permissions: Read/Execute
.text$mn:0000703C _text$mn        segment para public 'CODE' use32
.text$mn:0000703C                 assume cs:_text$mn
.text$mn:0000703C                 ;org 703Ch
.text$mn:0000703C ; COMDAT (pick any)
.text$mn:0000703C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000703C
.text$mn:0000703C ; =============== S U B R O U T I N E =======================================
.text$mn:0000703C
.text$mn:0000703C ; Attributes: bp-based frame
.text$mn:0000703C
.text$mn:0000703C ; bool __cdecl std::operator!=<class std::allocator<wchar_t>, class std::allocator<wchar_t>>(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &, struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:0000703C                 public ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
.text$mn:0000703C ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z proc near
.text$mn:0000703C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+73p
.text$mn:0000703C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+2Bp
.text$mn:0000703C
.text$mn:0000703C var_4           = dword ptr -4
.text$mn:0000703C arg_0           = dword ptr  8
.text$mn:0000703C arg_4           = dword ptr  0Ch
.text$mn:0000703C
.text$mn:0000703C                 push    ebp
.text$mn:0000703D                 mov     ebp, esp
.text$mn:0000703F                 push    ecx
.text$mn:00007040                 mov     eax, [ebp+arg_4]
.text$mn:00007043                 push    eax
.text$mn:00007044                 mov     ecx, [ebp+arg_0]
.text$mn:00007047                 push    ecx
.text$mn:00007048                 call    ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:0000704D                 add     esp, 8
.text$mn:00007050                 movzx   edx, al
.text$mn:00007053                 test    edx, edx
.text$mn:00007055                 jnz     short loc_7060
.text$mn:00007057                 mov     [ebp+var_4], 1
.text$mn:0000705E                 jmp     short loc_7067
.text$mn:00007060 ; ---------------------------------------------------------------------------
.text$mn:00007060
.text$mn:00007060 loc_7060:                               ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+19j
.text$mn:00007060                 mov     [ebp+var_4], 0
.text$mn:00007067
.text$mn:00007067 loc_7067:                               ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+22j
.text$mn:00007067                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000706A                 mov     esp, ebp
.text$mn:0000706C                 pop     ebp
.text$mn:0000706D                 retn
.text$mn:0000706D ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z endp
.text$mn:0000706D
.text$mn:0000706D ; ---------------------------------------------------------------------------
.text$mn:0000706E                 align 10h
.text$mn:0000706E _text$mn        ends
.text$mn:0000706E
.text$mn:00007070 ; ===========================================================================
.text$mn:00007070
.text$mn:00007070 ; Segment type: Pure code
.text$mn:00007070 ; Segment permissions: Read/Execute
.text$mn:00007070 _text$mn        segment para public 'CODE' use32
.text$mn:00007070                 assume cs:_text$mn
.text$mn:00007070                 ;org 7070h
.text$mn:00007070 ; COMDAT (pick any)
.text$mn:00007070                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007070
.text$mn:00007070 ; =============== S U B R O U T I N E =======================================
.text$mn:00007070
.text$mn:00007070 ; Attributes: bp-based frame
.text$mn:00007070
.text$mn:00007070 ; int __cdecl std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, wchar_t *Str)
.text$mn:00007070                 public ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z
.text$mn:00007070 ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z proc near
.text$mn:00007070                                         ; CODE XREF: Notepad_plus::fileSave(Buffer *)+15Dp
.text$mn:00007070                                         ; Notepad_plus::fileSave(Buffer *)+23Ep ...
.text$mn:00007070
.text$mn:00007070 var_4           = dword ptr -4
.text$mn:00007070 arg_0           = dword ptr  8
.text$mn:00007070 Str             = dword ptr  0Ch
.text$mn:00007070
.text$mn:00007070                 push    ebp
.text$mn:00007071                 mov     ebp, esp
.text$mn:00007073                 push    ecx
.text$mn:00007074                 mov     eax, [ebp+Str]
.text$mn:00007077                 push    eax             ; Str
.text$mn:00007078                 mov     ecx, [ebp+arg_0]
.text$mn:0000707B                 push    ecx             ; int
.text$mn:0000707C                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00007081                 add     esp, 8
.text$mn:00007084                 movzx   edx, al
.text$mn:00007087                 test    edx, edx
.text$mn:00007089                 jnz     short loc_7094
.text$mn:0000708B                 mov     [ebp+var_4], 1
.text$mn:00007092                 jmp     short loc_709B
.text$mn:00007094 ; ---------------------------------------------------------------------------
.text$mn:00007094
.text$mn:00007094 loc_7094:                               ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+19j
.text$mn:00007094                 mov     [ebp+var_4], 0
.text$mn:0000709B
.text$mn:0000709B loc_709B:                               ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+22j
.text$mn:0000709B                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000709E                 mov     esp, ebp
.text$mn:000070A0                 pop     ebp
.text$mn:000070A1                 retn
.text$mn:000070A1 ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z endp
.text$mn:000070A1
.text$mn:000070A1 ; ---------------------------------------------------------------------------
.text$mn:000070A2                 align 4
.text$mn:000070A2 _text$mn        ends
.text$mn:000070A2
.text$mn:000070A4 ; ===========================================================================
.text$mn:000070A4
.text$mn:000070A4 ; Segment type: Pure code
.text$mn:000070A4 ; Segment permissions: Read/Execute
.text$mn:000070A4 _text$mn        segment para public 'CODE' use32
.text$mn:000070A4                 assume cs:_text$mn
.text$mn:000070A4                 ;org 70A4h
.text$mn:000070A4 ; COMDAT (pick any)
.text$mn:000070A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000070A4
.text$mn:000070A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000070A4
.text$mn:000070A4 ; Attributes: bp-based frame
.text$mn:000070A4
.text$mn:000070A4 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:000070A4                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:000070A4 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:000070A4                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:000070A4
.text$mn:000070A4 var_4           = dword ptr -4
.text$mn:000070A4 arg_0           = dword ptr  8
.text$mn:000070A4
.text$mn:000070A4                 push    ebp
.text$mn:000070A5                 mov     ebp, esp
.text$mn:000070A7                 push    ecx
.text$mn:000070A8                 mov     [ebp+var_4], 0
.text$mn:000070AF                 cmp     [ebp+arg_0], 0
.text$mn:000070B3                 jnz     short loc_70B7
.text$mn:000070B5                 jmp     short loc_70D7
.text$mn:000070B7 ; ---------------------------------------------------------------------------
.text$mn:000070B7
.text$mn:000070B7 loc_70B7:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:000070B7                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:000070BB                 ja      short loc_70D2
.text$mn:000070BD                 mov     eax, [ebp+arg_0]
.text$mn:000070C0                 push    eax             ; unsigned int
.text$mn:000070C1                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000070C6                 add     esp, 4
.text$mn:000070C9                 mov     [ebp+var_4], eax
.text$mn:000070CC                 cmp     [ebp+var_4], 0
.text$mn:000070D0                 jnz     short loc_70D7
.text$mn:000070D2
.text$mn:000070D2 loc_70D2:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000070D2                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000070D7
.text$mn:000070D7 loc_70D7:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000070D7                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000070D7                 mov     eax, [ebp+var_4]
.text$mn:000070DA                 mov     esp, ebp
.text$mn:000070DC                 pop     ebp
.text$mn:000070DD                 retn
.text$mn:000070DD ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000070DD
.text$mn:000070DD ; ---------------------------------------------------------------------------
.text$mn:000070DE                 align 10h
.text$mn:000070DE _text$mn        ends
.text$mn:000070DE
.text$mn:000070E0 ; ===========================================================================
.text$mn:000070E0
.text$mn:000070E0 ; Segment type: Pure code
.text$mn:000070E0 ; Segment permissions: Read/Execute
.text$mn:000070E0 _text$mn        segment para public 'CODE' use32
.text$mn:000070E0                 assume cs:_text$mn
.text$mn:000070E0                 ;org 70E0h
.text$mn:000070E0 ; COMDAT (pick any)
.text$mn:000070E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000070E0
.text$mn:000070E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000070E0
.text$mn:000070E0 ; Attributes: bp-based frame
.text$mn:000070E0
.text$mn:000070E0 ; int * __cdecl std::_Allocate<int>(unsigned int, int *)
.text$mn:000070E0                 public ??$_Allocate@H@std@@YAPAHIPAH@Z
.text$mn:000070E0 ??$_Allocate@H@std@@YAPAHIPAH@Z proc near
.text$mn:000070E0                                         ; CODE XREF: std::allocator<int>::allocate(uint)+Dp
.text$mn:000070E0
.text$mn:000070E0 var_4           = dword ptr -4
.text$mn:000070E0 arg_0           = dword ptr  8
.text$mn:000070E0
.text$mn:000070E0                 push    ebp
.text$mn:000070E1                 mov     ebp, esp
.text$mn:000070E3                 push    ecx
.text$mn:000070E4                 mov     [ebp+var_4], 0
.text$mn:000070EB                 cmp     [ebp+arg_0], 0
.text$mn:000070EF                 jnz     short loc_70F3
.text$mn:000070F1                 jmp     short loc_7119
.text$mn:000070F3 ; ---------------------------------------------------------------------------
.text$mn:000070F3
.text$mn:000070F3 loc_70F3:                               ; CODE XREF: std::_Allocate<int>(uint,int *)+Fj
.text$mn:000070F3                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:000070FA                 ja      short loc_7114
.text$mn:000070FC                 mov     eax, [ebp+arg_0]
.text$mn:000070FF                 shl     eax, 2
.text$mn:00007102                 push    eax             ; unsigned int
.text$mn:00007103                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00007108                 add     esp, 4
.text$mn:0000710B                 mov     [ebp+var_4], eax
.text$mn:0000710E                 cmp     [ebp+var_4], 0
.text$mn:00007112                 jnz     short loc_7119
.text$mn:00007114
.text$mn:00007114 loc_7114:                               ; CODE XREF: std::_Allocate<int>(uint,int *)+1Aj
.text$mn:00007114                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00007119
.text$mn:00007119 loc_7119:                               ; CODE XREF: std::_Allocate<int>(uint,int *)+11j
.text$mn:00007119                                         ; std::_Allocate<int>(uint,int *)+32j
.text$mn:00007119                 mov     eax, [ebp+var_4]
.text$mn:0000711C                 mov     esp, ebp
.text$mn:0000711E                 pop     ebp
.text$mn:0000711F                 retn
.text$mn:0000711F ??$_Allocate@H@std@@YAPAHIPAH@Z endp
.text$mn:0000711F
.text$mn:0000711F _text$mn        ends
.text$mn:0000711F
.text$mn:00007120 ; ===========================================================================
.text$mn:00007120
.text$mn:00007120 ; Segment type: Pure code
.text$mn:00007120 ; Segment permissions: Read/Execute
.text$mn:00007120 _text$mn        segment para public 'CODE' use32
.text$mn:00007120                 assume cs:_text$mn
.text$mn:00007120                 ;org 7120h
.text$mn:00007120 ; COMDAT (pick any)
.text$mn:00007120                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007120
.text$mn:00007120 ; =============== S U B R O U T I N E =======================================
.text$mn:00007120
.text$mn:00007120 ; Attributes: bp-based frame
.text$mn:00007120
.text$mn:00007120 ; unsigned int * __cdecl std::_Allocate<unsigned int>(unsigned int, unsigned int *)
.text$mn:00007120                 public ??$_Allocate@I@std@@YAPAIIPAI@Z
.text$mn:00007120 ??$_Allocate@I@std@@YAPAIIPAI@Z proc near
.text$mn:00007120                                         ; CODE XREF: std::allocator<uint>::allocate(uint)+Dp
.text$mn:00007120
.text$mn:00007120 var_4           = dword ptr -4
.text$mn:00007120 arg_0           = dword ptr  8
.text$mn:00007120
.text$mn:00007120                 push    ebp
.text$mn:00007121                 mov     ebp, esp
.text$mn:00007123                 push    ecx
.text$mn:00007124                 mov     [ebp+var_4], 0
.text$mn:0000712B                 cmp     [ebp+arg_0], 0
.text$mn:0000712F                 jnz     short loc_7133
.text$mn:00007131                 jmp     short loc_7159
.text$mn:00007133 ; ---------------------------------------------------------------------------
.text$mn:00007133
.text$mn:00007133 loc_7133:                               ; CODE XREF: std::_Allocate<uint>(uint,uint *)+Fj
.text$mn:00007133                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:0000713A                 ja      short loc_7154
.text$mn:0000713C                 mov     eax, [ebp+arg_0]
.text$mn:0000713F                 shl     eax, 2
.text$mn:00007142                 push    eax             ; unsigned int
.text$mn:00007143                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00007148                 add     esp, 4
.text$mn:0000714B                 mov     [ebp+var_4], eax
.text$mn:0000714E                 cmp     [ebp+var_4], 0
.text$mn:00007152                 jnz     short loc_7159
.text$mn:00007154
.text$mn:00007154 loc_7154:                               ; CODE XREF: std::_Allocate<uint>(uint,uint *)+1Aj
.text$mn:00007154                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00007159
.text$mn:00007159 loc_7159:                               ; CODE XREF: std::_Allocate<uint>(uint,uint *)+11j
.text$mn:00007159                                         ; std::_Allocate<uint>(uint,uint *)+32j
.text$mn:00007159                 mov     eax, [ebp+var_4]
.text$mn:0000715C                 mov     esp, ebp
.text$mn:0000715E                 pop     ebp
.text$mn:0000715F                 retn
.text$mn:0000715F ??$_Allocate@I@std@@YAPAIIPAI@Z endp
.text$mn:0000715F
.text$mn:0000715F _text$mn        ends
.text$mn:0000715F
.text$mn:00007160 ; ===========================================================================
.text$mn:00007160
.text$mn:00007160 ; Segment type: Pure code
.text$mn:00007160 ; Segment permissions: Read/Execute
.text$mn:00007160 _text$mn        segment para public 'CODE' use32
.text$mn:00007160                 assume cs:_text$mn
.text$mn:00007160                 ;org 7160h
.text$mn:00007160 ; COMDAT (pick any)
.text$mn:00007160                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007160
.text$mn:00007160 ; =============== S U B R O U T I N E =======================================
.text$mn:00007160
.text$mn:00007160 ; Attributes: bp-based frame
.text$mn:00007160
.text$mn:00007160 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00007160                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00007160 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00007160                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00007160
.text$mn:00007160 var_4           = dword ptr -4
.text$mn:00007160 arg_0           = dword ptr  8
.text$mn:00007160
.text$mn:00007160                 push    ebp
.text$mn:00007161                 mov     ebp, esp
.text$mn:00007163                 push    ecx
.text$mn:00007164                 mov     [ebp+var_4], 0
.text$mn:0000716B                 cmp     [ebp+arg_0], 0
.text$mn:0000716F                 jnz     short loc_7173
.text$mn:00007171                 jmp     short loc_7199
.text$mn:00007173 ; ---------------------------------------------------------------------------
.text$mn:00007173
.text$mn:00007173 loc_7173:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00007173                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:0000717A                 ja      short loc_7194
.text$mn:0000717C                 mov     eax, [ebp+arg_0]
.text$mn:0000717F                 shl     eax, 3
.text$mn:00007182                 push    eax             ; unsigned int
.text$mn:00007183                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00007188                 add     esp, 4
.text$mn:0000718B                 mov     [ebp+var_4], eax
.text$mn:0000718E                 cmp     [ebp+var_4], 0
.text$mn:00007192                 jnz     short loc_7199
.text$mn:00007194
.text$mn:00007194 loc_7194:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00007194                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00007199
.text$mn:00007199 loc_7199:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00007199                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00007199                 mov     eax, [ebp+var_4]
.text$mn:0000719C                 mov     esp, ebp
.text$mn:0000719E                 pop     ebp
.text$mn:0000719F                 retn
.text$mn:0000719F ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:0000719F
.text$mn:0000719F _text$mn        ends
.text$mn:0000719F
.text$mn:000071A0 ; ===========================================================================
.text$mn:000071A0
.text$mn:000071A0 ; Segment type: Pure code
.text$mn:000071A0 ; Segment permissions: Read/Execute
.text$mn:000071A0 _text$mn        segment para public 'CODE' use32
.text$mn:000071A0                 assume cs:_text$mn
.text$mn:000071A0                 ;org 71A0h
.text$mn:000071A0 ; COMDAT (pick any)
.text$mn:000071A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000071A0
.text$mn:000071A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000071A0
.text$mn:000071A0 ; Attributes: bp-based frame
.text$mn:000071A0
.text$mn:000071A0 ; struct sessionFileInfo * __cdecl std::_Allocate<struct sessionFileInfo>(unsigned int, struct sessionFileInfo *)
.text$mn:000071A0                 public ??$_Allocate@UsessionFileInfo@@@std@@YAPAUsessionFileInfo@@IPAU1@@Z
.text$mn:000071A0 ??$_Allocate@UsessionFileInfo@@@std@@YAPAUsessionFileInfo@@IPAU1@@Z proc near
.text$mn:000071A0                                         ; CODE XREF: std::allocator<sessionFileInfo>::allocate(uint)+Dp
.text$mn:000071A0
.text$mn:000071A0 var_4           = dword ptr -4
.text$mn:000071A0 arg_0           = dword ptr  8
.text$mn:000071A0
.text$mn:000071A0                 push    ebp
.text$mn:000071A1                 mov     ebp, esp
.text$mn:000071A3                 push    ecx
.text$mn:000071A4                 mov     [ebp+var_4], 0
.text$mn:000071AB                 cmp     [ebp+arg_0], 0
.text$mn:000071AF                 jnz     short loc_71B3
.text$mn:000071B1                 jmp     short loc_71DA
.text$mn:000071B3 ; ---------------------------------------------------------------------------
.text$mn:000071B3
.text$mn:000071B3 loc_71B3:                               ; CODE XREF: std::_Allocate<sessionFileInfo>(uint,sessionFileInfo *)+Fj
.text$mn:000071B3                 cmp     [ebp+arg_0], 1AF286Bh
.text$mn:000071BA                 ja      short loc_71D5
.text$mn:000071BC                 imul    eax, [ebp+arg_0], 98h
.text$mn:000071C3                 push    eax             ; unsigned int
.text$mn:000071C4                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000071C9                 add     esp, 4
.text$mn:000071CC                 mov     [ebp+var_4], eax
.text$mn:000071CF                 cmp     [ebp+var_4], 0
.text$mn:000071D3                 jnz     short loc_71DA
.text$mn:000071D5
.text$mn:000071D5 loc_71D5:                               ; CODE XREF: std::_Allocate<sessionFileInfo>(uint,sessionFileInfo *)+1Aj
.text$mn:000071D5                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000071DA
.text$mn:000071DA loc_71DA:                               ; CODE XREF: std::_Allocate<sessionFileInfo>(uint,sessionFileInfo *)+11j
.text$mn:000071DA                                         ; std::_Allocate<sessionFileInfo>(uint,sessionFileInfo *)+33j
.text$mn:000071DA                 mov     eax, [ebp+var_4]
.text$mn:000071DD                 mov     esp, ebp
.text$mn:000071DF                 pop     ebp
.text$mn:000071E0                 retn
.text$mn:000071E0 ??$_Allocate@UsessionFileInfo@@@std@@YAPAUsessionFileInfo@@IPAU1@@Z endp
.text$mn:000071E0
.text$mn:000071E0 ; ---------------------------------------------------------------------------
.text$mn:000071E1                 align 4
.text$mn:000071E1 _text$mn        ends
.text$mn:000071E1
.text$mn:000071E4 ; ===========================================================================
.text$mn:000071E4
.text$mn:000071E4 ; Segment type: Pure code
.text$mn:000071E4 ; Segment permissions: Read/Execute
.text$mn:000071E4 _text$mn        segment para public 'CODE' use32
.text$mn:000071E4                 assume cs:_text$mn
.text$mn:000071E4                 ;org 71E4h
.text$mn:000071E4 ; COMDAT (pick any)
.text$mn:000071E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000071E4
.text$mn:000071E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000071E4
.text$mn:000071E4 ; Attributes: bp-based frame
.text$mn:000071E4
.text$mn:000071E4 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __cdecl std::_Allocate<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(unsigned int, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:000071E4                 public ??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z
.text$mn:000071E4 ??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z proc near
.text$mn:000071E4                                         ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::allocate(uint)+Dp
.text$mn:000071E4
.text$mn:000071E4 var_4           = dword ptr -4
.text$mn:000071E4 arg_0           = dword ptr  8
.text$mn:000071E4
.text$mn:000071E4                 push    ebp
.text$mn:000071E5                 mov     ebp, esp
.text$mn:000071E7                 push    ecx
.text$mn:000071E8                 mov     [ebp+var_4], 0
.text$mn:000071EF                 cmp     [ebp+arg_0], 0
.text$mn:000071F3                 jnz     short loc_71F7
.text$mn:000071F5                 jmp     short loc_721B
.text$mn:000071F7 ; ---------------------------------------------------------------------------
.text$mn:000071F7
.text$mn:000071F7 loc_71F7:                               ; CODE XREF: std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+Fj
.text$mn:000071F7                 cmp     [ebp+arg_0], 9249249h
.text$mn:000071FE                 ja      short loc_7216
.text$mn:00007200                 imul    eax, [ebp+arg_0], 1Ch
.text$mn:00007204                 push    eax             ; unsigned int
.text$mn:00007205                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000720A                 add     esp, 4
.text$mn:0000720D                 mov     [ebp+var_4], eax
.text$mn:00007210                 cmp     [ebp+var_4], 0
.text$mn:00007214                 jnz     short loc_721B
.text$mn:00007216
.text$mn:00007216 loc_7216:                               ; CODE XREF: std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+1Aj
.text$mn:00007216                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:0000721B
.text$mn:0000721B loc_721B:                               ; CODE XREF: std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+11j
.text$mn:0000721B                                         ; std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+30j
.text$mn:0000721B                 mov     eax, [ebp+var_4]
.text$mn:0000721E                 mov     esp, ebp
.text$mn:00007220                 pop     ebp
.text$mn:00007221                 retn
.text$mn:00007221 ??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z endp
.text$mn:00007221
.text$mn:00007221 ; ---------------------------------------------------------------------------
.text$mn:00007222                 align 4
.text$mn:00007222 _text$mn        ends
.text$mn:00007222
.text$mn:00007224 ; ===========================================================================
.text$mn:00007224
.text$mn:00007224 ; Segment type: Pure code
.text$mn:00007224 ; Segment permissions: Read/Execute
.text$mn:00007224 _text$mn        segment para public 'CODE' use32
.text$mn:00007224                 assume cs:_text$mn
.text$mn:00007224                 ;org 7224h
.text$mn:00007224 ; COMDAT (pick any)
.text$mn:00007224                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007224
.text$mn:00007224 ; =============== S U B R O U T I N E =======================================
.text$mn:00007224
.text$mn:00007224 ; Attributes: bp-based frame
.text$mn:00007224
.text$mn:00007224 ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:00007224                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:00007224 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:00007224                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:00007224
.text$mn:00007224 var_4           = dword ptr -4
.text$mn:00007224 arg_0           = dword ptr  8
.text$mn:00007224
.text$mn:00007224                 push    ebp
.text$mn:00007225                 mov     ebp, esp
.text$mn:00007227                 push    ecx
.text$mn:00007228                 mov     [ebp+var_4], 0
.text$mn:0000722F                 cmp     [ebp+arg_0], 0
.text$mn:00007233                 jnz     short loc_7237
.text$mn:00007235                 jmp     short loc_725C
.text$mn:00007237 ; ---------------------------------------------------------------------------
.text$mn:00007237
.text$mn:00007237 loc_7237:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:00007237                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:0000723E                 ja      short loc_7257
.text$mn:00007240                 mov     eax, [ebp+arg_0]
.text$mn:00007243                 shl     eax, 1
.text$mn:00007245                 push    eax             ; unsigned int
.text$mn:00007246                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000724B                 add     esp, 4
.text$mn:0000724E                 mov     [ebp+var_4], eax
.text$mn:00007251                 cmp     [ebp+var_4], 0
.text$mn:00007255                 jnz     short loc_725C
.text$mn:00007257
.text$mn:00007257 loc_7257:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:00007257                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:0000725C
.text$mn:0000725C loc_725C:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:0000725C                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:0000725C                 mov     eax, [ebp+var_4]
.text$mn:0000725F                 mov     esp, ebp
.text$mn:00007261                 pop     ebp
.text$mn:00007262                 retn
.text$mn:00007262 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:00007262
.text$mn:00007262 ; ---------------------------------------------------------------------------
.text$mn:00007263                 align 4
.text$mn:00007263 _text$mn        ends
.text$mn:00007263
.text$mn:00007264 ; ===========================================================================
.text$mn:00007264
.text$mn:00007264 ; Segment type: Pure code
.text$mn:00007264 ; Segment permissions: Read/Execute
.text$mn:00007264 _text$mn        segment para public 'CODE' use32
.text$mn:00007264                 assume cs:_text$mn
.text$mn:00007264                 ;org 7264h
.text$mn:00007264 ; COMDAT (pick any)
.text$mn:00007264                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007264
.text$mn:00007264 ; =============== S U B R O U T I N E =======================================
.text$mn:00007264
.text$mn:00007264 ; Attributes: bp-based frame
.text$mn:00007264
.text$mn:00007264 ; int __cdecl std::_Copy_impl<unsigned int *,unsigned int *>(void *Src, int, void *Dst)
.text$mn:00007264                 public ??$_Copy_impl@PAIPAI@std@@YAPAIPAI00@Z
.text$mn:00007264 ??$_Copy_impl@PAIPAI@std@@YAPAIPAI00@Z proc near
.text$mn:00007264                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+D4p
.text$mn:00007264                                         ; std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+14Ap
.text$mn:00007264
.text$mn:00007264 var_1           = byte ptr -1
.text$mn:00007264 Src             = dword ptr  8
.text$mn:00007264 arg_4           = dword ptr  0Ch
.text$mn:00007264 Dst             = dword ptr  10h
.text$mn:00007264
.text$mn:00007264                 push    ebp
.text$mn:00007265                 mov     ebp, esp
.text$mn:00007267                 push    ecx
.text$mn:00007268                 mov     eax, [ebp+Dst]
.text$mn:0000726B                 push    eax
.text$mn:0000726C                 mov     ecx, [ebp+Src]
.text$mn:0000726F                 push    ecx
.text$mn:00007270                 call    ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAI0@Z ; std::_Ptr_cat<uint,uint>(uint *,uint *)
.text$mn:00007275                 add     esp, 8
.text$mn:00007278                 mov     [ebp+var_1], al
.text$mn:0000727B                 movzx   edx, [ebp+var_1]
.text$mn:0000727F                 push    edx
.text$mn:00007280                 mov     eax, [ebp+Dst]
.text$mn:00007283                 push    eax             ; Dst
.text$mn:00007284                 mov     ecx, [ebp+arg_4]
.text$mn:00007287                 push    ecx             ; int
.text$mn:00007288                 mov     edx, [ebp+Src]
.text$mn:0000728B                 push    edx             ; Src
.text$mn:0000728C                 call    ??$_Copy_impl@PAIPAI@std@@YAPAIPAI00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<uint *,uint *>(uint *,uint *,uint *,std::_Scalar_ptr_iterator_tag)
.text$mn:00007291                 add     esp, 10h
.text$mn:00007294                 mov     esp, ebp
.text$mn:00007296                 pop     ebp
.text$mn:00007297                 retn
.text$mn:00007297 ??$_Copy_impl@PAIPAI@std@@YAPAIPAI00@Z endp
.text$mn:00007297
.text$mn:00007297 _text$mn        ends
.text$mn:00007297
.text$mn:00007298 ; ===========================================================================
.text$mn:00007298
.text$mn:00007298 ; Segment type: Pure code
.text$mn:00007298 ; Segment permissions: Read/Execute
.text$mn:00007298 _text$mn        segment para public 'CODE' use32
.text$mn:00007298                 assume cs:_text$mn
.text$mn:00007298                 ;org 7298h
.text$mn:00007298 ; COMDAT (pick any)
.text$mn:00007298                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007298
.text$mn:00007298 ; =============== S U B R O U T I N E =======================================
.text$mn:00007298
.text$mn:00007298 ; Attributes: bp-based frame
.text$mn:00007298
.text$mn:00007298 ; int __cdecl std::_Copy_impl<unsigned int *,unsigned int *>(void *Src, int, void *Dst)
.text$mn:00007298                 public ??$_Copy_impl@PAIPAI@std@@YAPAIPAI00U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00007298 ??$_Copy_impl@PAIPAI@std@@YAPAIPAI00U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00007298                                         ; CODE XREF: std::_Copy_impl<uint *,uint *>(uint *,uint *,uint *)+28p
.text$mn:00007298
.text$mn:00007298 var_4           = dword ptr -4
.text$mn:00007298 Src             = dword ptr  8
.text$mn:00007298 arg_4           = dword ptr  0Ch
.text$mn:00007298 Dst             = dword ptr  10h
.text$mn:00007298
.text$mn:00007298                 push    ebp
.text$mn:00007299                 mov     ebp, esp
.text$mn:0000729B                 push    ecx
.text$mn:0000729C                 mov     eax, [ebp+arg_4]
.text$mn:0000729F                 sub     eax, [ebp+Src]
.text$mn:000072A2                 sar     eax, 2
.text$mn:000072A5                 mov     [ebp+var_4], eax
.text$mn:000072A8                 mov     ecx, [ebp+var_4]
.text$mn:000072AB                 shl     ecx, 2
.text$mn:000072AE                 push    ecx             ; Size
.text$mn:000072AF                 mov     edx, [ebp+Src]
.text$mn:000072B2                 push    edx             ; Src
.text$mn:000072B3                 mov     eax, [ebp+Dst]
.text$mn:000072B6                 push    eax             ; Dst
.text$mn:000072B7                 call    _memmove
.text$mn:000072BC                 add     esp, 0Ch
.text$mn:000072BF                 mov     ecx, [ebp+var_4]
.text$mn:000072C2                 mov     edx, [ebp+Dst]
.text$mn:000072C5                 lea     eax, [edx+ecx*4]
.text$mn:000072C8                 mov     esp, ebp
.text$mn:000072CA                 pop     ebp
.text$mn:000072CB                 retn
.text$mn:000072CB ??$_Copy_impl@PAIPAI@std@@YAPAIPAI00U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:000072CB
.text$mn:000072CB _text$mn        ends
.text$mn:000072CB
.text$mn:000072CC ; ===========================================================================
.text$mn:000072CC
.text$mn:000072CC ; Segment type: Pure code
.text$mn:000072CC ; Segment permissions: Read/Execute
.text$mn:000072CC _text$mn        segment para public 'CODE' use32
.text$mn:000072CC                 assume cs:_text$mn
.text$mn:000072CC                 ;org 72CCh
.text$mn:000072CC ; COMDAT (pick any)
.text$mn:000072CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000072CC
.text$mn:000072CC ; =============== S U B R O U T I N E =======================================
.text$mn:000072CC
.text$mn:000072CC ; Attributes: bp-based frame
.text$mn:000072CC
.text$mn:000072CC ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000072CC                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000072CC ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000072CC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000072CC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000072CC
.text$mn:000072CC arg_0           = dword ptr  8
.text$mn:000072CC arg_4           = dword ptr  0Ch
.text$mn:000072CC arg_8           = dword ptr  10h
.text$mn:000072CC
.text$mn:000072CC                 push    ebp
.text$mn:000072CD                 mov     ebp, esp
.text$mn:000072CF                 cmp     [ebp+arg_0], 0
.text$mn:000072D3                 jnz     short loc_72EA
.text$mn:000072D5                 mov     eax, [ebp+arg_8]
.text$mn:000072D8                 push    eax             ; unsigned int
.text$mn:000072D9                 mov     ecx, [ebp+arg_4]
.text$mn:000072DC                 push    ecx             ; wchar_t *
.text$mn:000072DD                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000072E2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000072E7                 add     esp, 0Ch
.text$mn:000072EA
.text$mn:000072EA loc_72EA:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:000072EA                 pop     ebp
.text$mn:000072EB                 retn
.text$mn:000072EB ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:000072EB
.text$mn:000072EB _text$mn        ends
.text$mn:000072EB
.text$mn:000072EC ; ===========================================================================
.text$mn:000072EC
.text$mn:000072EC ; Segment type: Pure code
.text$mn:000072EC ; Segment permissions: Read/Execute
.text$mn:000072EC _text$mn        segment para public 'CODE' use32
.text$mn:000072EC                 assume cs:_text$mn
.text$mn:000072EC                 ;org 72ECh
.text$mn:000072EC ; COMDAT (pick any)
.text$mn:000072EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000072EC
.text$mn:000072EC ; =============== S U B R O U T I N E =======================================
.text$mn:000072EC
.text$mn:000072EC ; Attributes: bp-based frame
.text$mn:000072EC
.text$mn:000072EC ; int __cdecl std::_Debug_pointer<int>(int, wchar_t *, unsigned int)
.text$mn:000072EC                 public ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z
.text$mn:000072EC ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z proc near
.text$mn:000072EC                                         ; CODE XREF: std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:000072EC                                         ; std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:000072EC
.text$mn:000072EC arg_0           = dword ptr  8
.text$mn:000072EC arg_4           = dword ptr  0Ch
.text$mn:000072EC arg_8           = dword ptr  10h
.text$mn:000072EC
.text$mn:000072EC                 push    ebp
.text$mn:000072ED                 mov     ebp, esp
.text$mn:000072EF                 cmp     [ebp+arg_0], 0
.text$mn:000072F3                 jnz     short loc_730A
.text$mn:000072F5                 mov     eax, [ebp+arg_8]
.text$mn:000072F8                 push    eax             ; unsigned int
.text$mn:000072F9                 mov     ecx, [ebp+arg_4]
.text$mn:000072FC                 push    ecx             ; wchar_t *
.text$mn:000072FD                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00007302                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007307                 add     esp, 0Ch
.text$mn:0000730A
.text$mn:0000730A loc_730A:                               ; CODE XREF: std::_Debug_pointer<int>(int *,wchar_t const *,uint)+7j
.text$mn:0000730A                 pop     ebp
.text$mn:0000730B                 retn
.text$mn:0000730B ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z endp
.text$mn:0000730B
.text$mn:0000730B _text$mn        ends
.text$mn:0000730B
.text$mn:0000730C ; ===========================================================================
.text$mn:0000730C
.text$mn:0000730C ; Segment type: Pure code
.text$mn:0000730C ; Segment permissions: Read/Execute
.text$mn:0000730C _text$mn        segment para public 'CODE' use32
.text$mn:0000730C                 assume cs:_text$mn
.text$mn:0000730C                 ;org 730Ch
.text$mn:0000730C ; COMDAT (pick any)
.text$mn:0000730C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000730C
.text$mn:0000730C ; =============== S U B R O U T I N E =======================================
.text$mn:0000730C
.text$mn:0000730C ; Attributes: bp-based frame
.text$mn:0000730C
.text$mn:0000730C ; int __cdecl std::_Debug_pointer<unsigned int>(int, wchar_t *, unsigned int)
.text$mn:0000730C                 public ??$_Debug_pointer@I@std@@YAXPAIPB_WI@Z
.text$mn:0000730C ??$_Debug_pointer@I@std@@YAXPAIPB_WI@Z proc near
.text$mn:0000730C                                         ; CODE XREF: std::_Debug_range2<uint *>(uint *,uint *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000730C                                         ; std::_Debug_range2<uint *>(uint *,uint *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:0000730C
.text$mn:0000730C arg_0           = dword ptr  8
.text$mn:0000730C arg_4           = dword ptr  0Ch
.text$mn:0000730C arg_8           = dword ptr  10h
.text$mn:0000730C
.text$mn:0000730C                 push    ebp
.text$mn:0000730D                 mov     ebp, esp
.text$mn:0000730F                 cmp     [ebp+arg_0], 0
.text$mn:00007313                 jnz     short loc_732A
.text$mn:00007315                 mov     eax, [ebp+arg_8]
.text$mn:00007318                 push    eax             ; unsigned int
.text$mn:00007319                 mov     ecx, [ebp+arg_4]
.text$mn:0000731C                 push    ecx             ; wchar_t *
.text$mn:0000731D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00007322                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007327                 add     esp, 0Ch
.text$mn:0000732A
.text$mn:0000732A loc_732A:                               ; CODE XREF: std::_Debug_pointer<uint>(uint *,wchar_t const *,uint)+7j
.text$mn:0000732A                 pop     ebp
.text$mn:0000732B                 retn
.text$mn:0000732B ??$_Debug_pointer@I@std@@YAXPAIPB_WI@Z endp
.text$mn:0000732B
.text$mn:0000732B _text$mn        ends
.text$mn:0000732B
.text$mn:0000732C ; ===========================================================================
.text$mn:0000732C
.text$mn:0000732C ; Segment type: Pure code
.text$mn:0000732C ; Segment permissions: Read/Execute
.text$mn:0000732C _text$mn        segment para public 'CODE' use32
.text$mn:0000732C                 assume cs:_text$mn
.text$mn:0000732C                 ;org 732Ch
.text$mn:0000732C ; COMDAT (pick any)
.text$mn:0000732C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000732C
.text$mn:0000732C ; =============== S U B R O U T I N E =======================================
.text$mn:0000732C
.text$mn:0000732C ; Attributes: bp-based frame
.text$mn:0000732C
.text$mn:0000732C ; int __cdecl std::_Debug_pointer<unsigned int>(int, wchar_t *, unsigned int)
.text$mn:0000732C                 public ??$_Debug_pointer@I@std@@YAXPBIPB_WI@Z
.text$mn:0000732C ??$_Debug_pointer@I@std@@YAXPBIPB_WI@Z proc near
.text$mn:0000732C                                         ; CODE XREF: std::_Debug_range2<uint const *>(uint const *,uint const *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000732C                                         ; std::_Debug_range2<uint const *>(uint const *,uint const *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp
.text$mn:0000732C
.text$mn:0000732C arg_0           = dword ptr  8
.text$mn:0000732C arg_4           = dword ptr  0Ch
.text$mn:0000732C arg_8           = dword ptr  10h
.text$mn:0000732C
.text$mn:0000732C                 push    ebp
.text$mn:0000732D                 mov     ebp, esp
.text$mn:0000732F                 cmp     [ebp+arg_0], 0
.text$mn:00007333                 jnz     short loc_734A
.text$mn:00007335                 mov     eax, [ebp+arg_8]
.text$mn:00007338                 push    eax             ; unsigned int
.text$mn:00007339                 mov     ecx, [ebp+arg_4]
.text$mn:0000733C                 push    ecx             ; wchar_t *
.text$mn:0000733D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00007342                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007347                 add     esp, 0Ch
.text$mn:0000734A
.text$mn:0000734A loc_734A:                               ; CODE XREF: std::_Debug_pointer<uint>(uint const *,wchar_t const *,uint)+7j
.text$mn:0000734A                 pop     ebp
.text$mn:0000734B                 retn
.text$mn:0000734B ??$_Debug_pointer@I@std@@YAXPBIPB_WI@Z endp
.text$mn:0000734B
.text$mn:0000734B _text$mn        ends
.text$mn:0000734B
.text$mn:0000734C ; ===========================================================================
.text$mn:0000734C
.text$mn:0000734C ; Segment type: Pure code
.text$mn:0000734C ; Segment permissions: Read/Execute
.text$mn:0000734C _text$mn        segment para public 'CODE' use32
.text$mn:0000734C                 assume cs:_text$mn
.text$mn:0000734C                 ;org 734Ch
.text$mn:0000734C ; COMDAT (pick any)
.text$mn:0000734C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000734C
.text$mn:0000734C ; =============== S U B R O U T I N E =======================================
.text$mn:0000734C
.text$mn:0000734C ; Attributes: bp-based frame
.text$mn:0000734C
.text$mn:0000734C ; int __cdecl std::_Debug_pointer<sessionFileInfo>(int, wchar_t *, unsigned int)
.text$mn:0000734C                 public ??$_Debug_pointer@UsessionFileInfo@@@std@@YAXPAUsessionFileInfo@@PB_WI@Z
.text$mn:0000734C ??$_Debug_pointer@UsessionFileInfo@@@std@@YAXPAUsessionFileInfo@@PB_WI@Z proc near
.text$mn:0000734C                                         ; CODE XREF: std::_Debug_range2<sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000734C                                         ; std::_Debug_range2<sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:0000734C
.text$mn:0000734C arg_0           = dword ptr  8
.text$mn:0000734C arg_4           = dword ptr  0Ch
.text$mn:0000734C arg_8           = dword ptr  10h
.text$mn:0000734C
.text$mn:0000734C                 push    ebp
.text$mn:0000734D                 mov     ebp, esp
.text$mn:0000734F                 cmp     [ebp+arg_0], 0
.text$mn:00007353                 jnz     short loc_736A
.text$mn:00007355                 mov     eax, [ebp+arg_8]
.text$mn:00007358                 push    eax             ; unsigned int
.text$mn:00007359                 mov     ecx, [ebp+arg_4]
.text$mn:0000735C                 push    ecx             ; wchar_t *
.text$mn:0000735D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00007362                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007367                 add     esp, 0Ch
.text$mn:0000736A
.text$mn:0000736A loc_736A:                               ; CODE XREF: std::_Debug_pointer<sessionFileInfo>(sessionFileInfo *,wchar_t const *,uint)+7j
.text$mn:0000736A                 pop     ebp
.text$mn:0000736B                 retn
.text$mn:0000736B ??$_Debug_pointer@UsessionFileInfo@@@std@@YAXPAUsessionFileInfo@@PB_WI@Z endp
.text$mn:0000736B
.text$mn:0000736B _text$mn        ends
.text$mn:0000736B
.text$mn:0000736C ; ===========================================================================
.text$mn:0000736C
.text$mn:0000736C ; Segment type: Pure code
.text$mn:0000736C ; Segment permissions: Read/Execute
.text$mn:0000736C _text$mn        segment para public 'CODE' use32
.text$mn:0000736C                 assume cs:_text$mn
.text$mn:0000736C                 ;org 736Ch
.text$mn:0000736C ; COMDAT (pick any)
.text$mn:0000736C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000736C
.text$mn:0000736C ; =============== S U B R O U T I N E =======================================
.text$mn:0000736C
.text$mn:0000736C ; Attributes: bp-based frame
.text$mn:0000736C
.text$mn:0000736C ; int __cdecl std::_Debug_pointer<sessionFileInfo>(int, wchar_t *, unsigned int)
.text$mn:0000736C                 public ??$_Debug_pointer@UsessionFileInfo@@@std@@YAXPBUsessionFileInfo@@PB_WI@Z
.text$mn:0000736C ??$_Debug_pointer@UsessionFileInfo@@@std@@YAXPBUsessionFileInfo@@PB_WI@Z proc near
.text$mn:0000736C                                         ; CODE XREF: std::_Debug_range2<sessionFileInfo const *>(sessionFileInfo const *,sessionFileInfo const *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000736C                                         ; std::_Debug_range2<sessionFileInfo const *>(sessionFileInfo const *,sessionFileInfo const *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp
.text$mn:0000736C
.text$mn:0000736C arg_0           = dword ptr  8
.text$mn:0000736C arg_4           = dword ptr  0Ch
.text$mn:0000736C arg_8           = dword ptr  10h
.text$mn:0000736C
.text$mn:0000736C                 push    ebp
.text$mn:0000736D                 mov     ebp, esp
.text$mn:0000736F                 cmp     [ebp+arg_0], 0
.text$mn:00007373                 jnz     short loc_738A
.text$mn:00007375                 mov     eax, [ebp+arg_8]
.text$mn:00007378                 push    eax             ; unsigned int
.text$mn:00007379                 mov     ecx, [ebp+arg_4]
.text$mn:0000737C                 push    ecx             ; wchar_t *
.text$mn:0000737D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00007382                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007387                 add     esp, 0Ch
.text$mn:0000738A
.text$mn:0000738A loc_738A:                               ; CODE XREF: std::_Debug_pointer<sessionFileInfo>(sessionFileInfo const *,wchar_t const *,uint)+7j
.text$mn:0000738A                 pop     ebp
.text$mn:0000738B                 retn
.text$mn:0000738B ??$_Debug_pointer@UsessionFileInfo@@@std@@YAXPBUsessionFileInfo@@PB_WI@Z endp
.text$mn:0000738B
.text$mn:0000738B _text$mn        ends
.text$mn:0000738B
.text$mn:0000738C ; ===========================================================================
.text$mn:0000738C
.text$mn:0000738C ; Segment type: Pure code
.text$mn:0000738C ; Segment permissions: Read/Execute
.text$mn:0000738C _text$mn        segment para public 'CODE' use32
.text$mn:0000738C                 assume cs:_text$mn
.text$mn:0000738C                 ;org 738Ch
.text$mn:0000738C ; COMDAT (pick any)
.text$mn:0000738C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000738C
.text$mn:0000738C ; =============== S U B R O U T I N E =======================================
.text$mn:0000738C
.text$mn:0000738C ; Attributes: bp-based frame
.text$mn:0000738C
.text$mn:0000738C ; int __cdecl std::_Debug_pointer<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(int, wchar_t *, unsigned int)
.text$mn:0000738C                 public ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z
.text$mn:0000738C ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z proc near
.text$mn:0000738C                                         ; CODE XREF: std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000738C                                         ; std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:0000738C
.text$mn:0000738C arg_0           = dword ptr  8
.text$mn:0000738C arg_4           = dword ptr  0Ch
.text$mn:0000738C arg_8           = dword ptr  10h
.text$mn:0000738C
.text$mn:0000738C                 push    ebp
.text$mn:0000738D                 mov     ebp, esp
.text$mn:0000738F                 cmp     [ebp+arg_0], 0
.text$mn:00007393                 jnz     short loc_73AA
.text$mn:00007395                 mov     eax, [ebp+arg_8]
.text$mn:00007398                 push    eax             ; unsigned int
.text$mn:00007399                 mov     ecx, [ebp+arg_4]
.text$mn:0000739C                 push    ecx             ; wchar_t *
.text$mn:0000739D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000073A2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000073A7                 add     esp, 0Ch
.text$mn:000073AA
.text$mn:000073AA loc_73AA:                               ; CODE XREF: std::_Debug_pointer<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)+7j
.text$mn:000073AA                 pop     ebp
.text$mn:000073AB                 retn
.text$mn:000073AB ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z endp
.text$mn:000073AB
.text$mn:000073AB _text$mn        ends
.text$mn:000073AB
.text$mn:000073AC ; ===========================================================================
.text$mn:000073AC
.text$mn:000073AC ; Segment type: Pure code
.text$mn:000073AC ; Segment permissions: Read/Execute
.text$mn:000073AC _text$mn        segment para public 'CODE' use32
.text$mn:000073AC                 assume cs:_text$mn
.text$mn:000073AC                 ;org 73ACh
.text$mn:000073AC ; COMDAT (pick any)
.text$mn:000073AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000073AC
.text$mn:000073AC ; =============== S U B R O U T I N E =======================================
.text$mn:000073AC
.text$mn:000073AC ; Attributes: bp-based frame
.text$mn:000073AC
.text$mn:000073AC ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:000073AC                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:000073AC ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:000073AC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+15p
.text$mn:000073AC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+1Dp ...
.text$mn:000073AC
.text$mn:000073AC arg_0           = dword ptr  8
.text$mn:000073AC arg_4           = dword ptr  0Ch
.text$mn:000073AC arg_8           = dword ptr  10h
.text$mn:000073AC
.text$mn:000073AC                 push    ebp
.text$mn:000073AD                 mov     ebp, esp
.text$mn:000073AF                 cmp     [ebp+arg_0], 0
.text$mn:000073B3                 jnz     short loc_73CA
.text$mn:000073B5                 mov     eax, [ebp+arg_8]
.text$mn:000073B8                 push    eax             ; unsigned int
.text$mn:000073B9                 mov     ecx, [ebp+arg_4]
.text$mn:000073BC                 push    ecx             ; wchar_t *
.text$mn:000073BD                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000073C2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000073C7                 add     esp, 0Ch
.text$mn:000073CA
.text$mn:000073CA loc_73CA:                               ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:000073CA                 pop     ebp
.text$mn:000073CB                 retn
.text$mn:000073CB ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:000073CB
.text$mn:000073CB _text$mn        ends
.text$mn:000073CB
.text$mn:000073CC ; ===========================================================================
.text$mn:000073CC
.text$mn:000073CC ; Segment type: Pure code
.text$mn:000073CC ; Segment permissions: Read/Execute
.text$mn:000073CC _text$mn        segment para public 'CODE' use32
.text$mn:000073CC                 assume cs:_text$mn
.text$mn:000073CC                 ;org 73CCh
.text$mn:000073CC ; COMDAT (pick any)
.text$mn:000073CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000073CC
.text$mn:000073CC ; =============== S U B R O U T I N E =======================================
.text$mn:000073CC
.text$mn:000073CC ; Attributes: bp-based frame
.text$mn:000073CC
.text$mn:000073CC ; int __cdecl std::_Debug_range2<int *>(int, int, wchar_t *, unsigned int)
.text$mn:000073CC                 public ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000073CC ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:000073CC                                         ; CODE XREF: std::_Debug_range<int *>(int *,int *,wchar_t const *,uint)+2Ap
.text$mn:000073CC
.text$mn:000073CC arg_0           = dword ptr  8
.text$mn:000073CC arg_4           = dword ptr  0Ch
.text$mn:000073CC arg_8           = dword ptr  10h
.text$mn:000073CC arg_C           = dword ptr  14h
.text$mn:000073CC
.text$mn:000073CC                 push    ebp
.text$mn:000073CD                 mov     ebp, esp
.text$mn:000073CF                 mov     eax, [ebp+arg_0]
.text$mn:000073D2                 cmp     eax, [ebp+arg_4]
.text$mn:000073D5                 jz      short loc_741C
.text$mn:000073D7                 mov     ecx, [ebp+arg_C]
.text$mn:000073DA                 push    ecx             ; unsigned int
.text$mn:000073DB                 mov     edx, [ebp+arg_8]
.text$mn:000073DE                 push    edx             ; wchar_t *
.text$mn:000073DF                 mov     eax, [ebp+arg_0]
.text$mn:000073E2                 push    eax             ; int
.text$mn:000073E3                 call    ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)
.text$mn:000073E8                 add     esp, 0Ch
.text$mn:000073EB                 mov     ecx, [ebp+arg_C]
.text$mn:000073EE                 push    ecx             ; unsigned int
.text$mn:000073EF                 mov     edx, [ebp+arg_8]
.text$mn:000073F2                 push    edx             ; wchar_t *
.text$mn:000073F3                 mov     eax, [ebp+arg_4]
.text$mn:000073F6                 push    eax             ; int
.text$mn:000073F7                 call    ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)
.text$mn:000073FC                 add     esp, 0Ch
.text$mn:000073FF                 mov     ecx, [ebp+arg_4]
.text$mn:00007402                 cmp     ecx, [ebp+arg_0]
.text$mn:00007405                 jnb     short loc_741C
.text$mn:00007407                 mov     edx, [ebp+arg_C]
.text$mn:0000740A                 push    edx             ; unsigned int
.text$mn:0000740B                 mov     eax, [ebp+arg_8]
.text$mn:0000740E                 push    eax             ; wchar_t *
.text$mn:0000740F                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00007414                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007419                 add     esp, 0Ch
.text$mn:0000741C
.text$mn:0000741C loc_741C:                               ; CODE XREF: std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:0000741C                                         ; std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:0000741C                 pop     ebp
.text$mn:0000741D                 retn
.text$mn:0000741D ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:0000741D
.text$mn:0000741D ; ---------------------------------------------------------------------------
.text$mn:0000741E                 align 10h
.text$mn:0000741E _text$mn        ends
.text$mn:0000741E
.text$mn:00007420 ; ===========================================================================
.text$mn:00007420
.text$mn:00007420 ; Segment type: Pure code
.text$mn:00007420 ; Segment permissions: Read/Execute
.text$mn:00007420 _text$mn        segment para public 'CODE' use32
.text$mn:00007420                 assume cs:_text$mn
.text$mn:00007420                 ;org 7420h
.text$mn:00007420 ; COMDAT (pick any)
.text$mn:00007420                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007420
.text$mn:00007420 ; =============== S U B R O U T I N E =======================================
.text$mn:00007420
.text$mn:00007420 ; Attributes: bp-based frame
.text$mn:00007420
.text$mn:00007420 ; int __cdecl std::_Debug_range2<unsigned int *>(int, int, wchar_t *, unsigned int)
.text$mn:00007420                 public ??$_Debug_range2@PAI@std@@YAXPAI0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00007420 ??$_Debug_range2@PAI@std@@YAXPAI0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00007420                                         ; CODE XREF: std::_Debug_range<uint *>(uint *,uint *,wchar_t const *,uint)+2Ap
.text$mn:00007420
.text$mn:00007420 arg_0           = dword ptr  8
.text$mn:00007420 arg_4           = dword ptr  0Ch
.text$mn:00007420 arg_8           = dword ptr  10h
.text$mn:00007420 arg_C           = dword ptr  14h
.text$mn:00007420
.text$mn:00007420                 push    ebp
.text$mn:00007421                 mov     ebp, esp
.text$mn:00007423                 mov     eax, [ebp+arg_0]
.text$mn:00007426                 cmp     eax, [ebp+arg_4]
.text$mn:00007429                 jz      short loc_7470
.text$mn:0000742B                 mov     ecx, [ebp+arg_C]
.text$mn:0000742E                 push    ecx             ; unsigned int
.text$mn:0000742F                 mov     edx, [ebp+arg_8]
.text$mn:00007432                 push    edx             ; wchar_t *
.text$mn:00007433                 mov     eax, [ebp+arg_0]
.text$mn:00007436                 push    eax             ; int
.text$mn:00007437                 call    ??$_Debug_pointer@I@std@@YAXPAIPB_WI@Z ; std::_Debug_pointer<uint>(uint *,wchar_t const *,uint)
.text$mn:0000743C                 add     esp, 0Ch
.text$mn:0000743F                 mov     ecx, [ebp+arg_C]
.text$mn:00007442                 push    ecx             ; unsigned int
.text$mn:00007443                 mov     edx, [ebp+arg_8]
.text$mn:00007446                 push    edx             ; wchar_t *
.text$mn:00007447                 mov     eax, [ebp+arg_4]
.text$mn:0000744A                 push    eax             ; int
.text$mn:0000744B                 call    ??$_Debug_pointer@I@std@@YAXPAIPB_WI@Z ; std::_Debug_pointer<uint>(uint *,wchar_t const *,uint)
.text$mn:00007450                 add     esp, 0Ch
.text$mn:00007453                 mov     ecx, [ebp+arg_4]
.text$mn:00007456                 cmp     ecx, [ebp+arg_0]
.text$mn:00007459                 jnb     short loc_7470
.text$mn:0000745B                 mov     edx, [ebp+arg_C]
.text$mn:0000745E                 push    edx             ; unsigned int
.text$mn:0000745F                 mov     eax, [ebp+arg_8]
.text$mn:00007462                 push    eax             ; wchar_t *
.text$mn:00007463                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00007468                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000746D                 add     esp, 0Ch
.text$mn:00007470
.text$mn:00007470 loc_7470:                               ; CODE XREF: std::_Debug_range2<uint *>(uint *,uint *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00007470                                         ; std::_Debug_range2<uint *>(uint *,uint *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00007470                 pop     ebp
.text$mn:00007471                 retn
.text$mn:00007471 ??$_Debug_range2@PAI@std@@YAXPAI0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00007471
.text$mn:00007471 ; ---------------------------------------------------------------------------
.text$mn:00007472                 align 4
.text$mn:00007472 _text$mn        ends
.text$mn:00007472
.text$mn:00007474 ; ===========================================================================
.text$mn:00007474
.text$mn:00007474 ; Segment type: Pure code
.text$mn:00007474 ; Segment permissions: Read/Execute
.text$mn:00007474 _text$mn        segment para public 'CODE' use32
.text$mn:00007474                 assume cs:_text$mn
.text$mn:00007474                 ;org 7474h
.text$mn:00007474 ; COMDAT (pick any)
.text$mn:00007474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007474
.text$mn:00007474 ; =============== S U B R O U T I N E =======================================
.text$mn:00007474
.text$mn:00007474 ; Attributes: bp-based frame
.text$mn:00007474
.text$mn:00007474 ; int __cdecl std::_Debug_range2<sessionFileInfo *>(int, int, wchar_t *, unsigned int)
.text$mn:00007474                 public ??$_Debug_range2@PAUsessionFileInfo@@@std@@YAXPAUsessionFileInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00007474 ??$_Debug_range2@PAUsessionFileInfo@@@std@@YAXPAUsessionFileInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00007474                                         ; CODE XREF: std::_Debug_range<sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,wchar_t const *,uint)+2Ap
.text$mn:00007474
.text$mn:00007474 arg_0           = dword ptr  8
.text$mn:00007474 arg_4           = dword ptr  0Ch
.text$mn:00007474 arg_8           = dword ptr  10h
.text$mn:00007474 arg_C           = dword ptr  14h
.text$mn:00007474
.text$mn:00007474                 push    ebp
.text$mn:00007475                 mov     ebp, esp
.text$mn:00007477                 mov     eax, [ebp+arg_0]
.text$mn:0000747A                 cmp     eax, [ebp+arg_4]
.text$mn:0000747D                 jz      short loc_74C4
.text$mn:0000747F                 mov     ecx, [ebp+arg_C]
.text$mn:00007482                 push    ecx             ; unsigned int
.text$mn:00007483                 mov     edx, [ebp+arg_8]
.text$mn:00007486                 push    edx             ; wchar_t *
.text$mn:00007487                 mov     eax, [ebp+arg_0]
.text$mn:0000748A                 push    eax             ; int
.text$mn:0000748B                 call    ??$_Debug_pointer@UsessionFileInfo@@@std@@YAXPAUsessionFileInfo@@PB_WI@Z ; std::_Debug_pointer<sessionFileInfo>(sessionFileInfo *,wchar_t const *,uint)
.text$mn:00007490                 add     esp, 0Ch
.text$mn:00007493                 mov     ecx, [ebp+arg_C]
.text$mn:00007496                 push    ecx             ; unsigned int
.text$mn:00007497                 mov     edx, [ebp+arg_8]
.text$mn:0000749A                 push    edx             ; wchar_t *
.text$mn:0000749B                 mov     eax, [ebp+arg_4]
.text$mn:0000749E                 push    eax             ; int
.text$mn:0000749F                 call    ??$_Debug_pointer@UsessionFileInfo@@@std@@YAXPAUsessionFileInfo@@PB_WI@Z ; std::_Debug_pointer<sessionFileInfo>(sessionFileInfo *,wchar_t const *,uint)
.text$mn:000074A4                 add     esp, 0Ch
.text$mn:000074A7                 mov     ecx, [ebp+arg_4]
.text$mn:000074AA                 cmp     ecx, [ebp+arg_0]
.text$mn:000074AD                 jnb     short loc_74C4
.text$mn:000074AF                 mov     edx, [ebp+arg_C]
.text$mn:000074B2                 push    edx             ; unsigned int
.text$mn:000074B3                 mov     eax, [ebp+arg_8]
.text$mn:000074B6                 push    eax             ; wchar_t *
.text$mn:000074B7                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:000074BC                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000074C1                 add     esp, 0Ch
.text$mn:000074C4
.text$mn:000074C4 loc_74C4:                               ; CODE XREF: std::_Debug_range2<sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:000074C4                                         ; std::_Debug_range2<sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:000074C4                 pop     ebp
.text$mn:000074C5                 retn
.text$mn:000074C5 ??$_Debug_range2@PAUsessionFileInfo@@@std@@YAXPAUsessionFileInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000074C5
.text$mn:000074C5 ; ---------------------------------------------------------------------------
.text$mn:000074C6                 align 4
.text$mn:000074C6 _text$mn        ends
.text$mn:000074C6
.text$mn:000074C8 ; ===========================================================================
.text$mn:000074C8
.text$mn:000074C8 ; Segment type: Pure code
.text$mn:000074C8 ; Segment permissions: Read/Execute
.text$mn:000074C8 _text$mn        segment para public 'CODE' use32
.text$mn:000074C8                 assume cs:_text$mn
.text$mn:000074C8                 ;org 74C8h
.text$mn:000074C8 ; COMDAT (pick any)
.text$mn:000074C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000074C8
.text$mn:000074C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000074C8
.text$mn:000074C8 ; Attributes: bp-based frame
.text$mn:000074C8
.text$mn:000074C8 ; int __cdecl std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(int, int, wchar_t *, unsigned int)
.text$mn:000074C8                 public ??$_Debug_range2@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000074C8 ??$_Debug_range2@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:000074C8                                         ; CODE XREF: std::_Debug_range<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)+2Ap
.text$mn:000074C8
.text$mn:000074C8 arg_0           = dword ptr  8
.text$mn:000074C8 arg_4           = dword ptr  0Ch
.text$mn:000074C8 arg_8           = dword ptr  10h
.text$mn:000074C8 arg_C           = dword ptr  14h
.text$mn:000074C8
.text$mn:000074C8                 push    ebp
.text$mn:000074C9                 mov     ebp, esp
.text$mn:000074CB                 mov     eax, [ebp+arg_0]
.text$mn:000074CE                 cmp     eax, [ebp+arg_4]
.text$mn:000074D1                 jz      short loc_7518
.text$mn:000074D3                 mov     ecx, [ebp+arg_C]
.text$mn:000074D6                 push    ecx             ; unsigned int
.text$mn:000074D7                 mov     edx, [ebp+arg_8]
.text$mn:000074DA                 push    edx             ; wchar_t *
.text$mn:000074DB                 mov     eax, [ebp+arg_0]
.text$mn:000074DE                 push    eax             ; int
.text$mn:000074DF                 call    ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z ; std::_Debug_pointer<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)
.text$mn:000074E4                 add     esp, 0Ch
.text$mn:000074E7                 mov     ecx, [ebp+arg_C]
.text$mn:000074EA                 push    ecx             ; unsigned int
.text$mn:000074EB                 mov     edx, [ebp+arg_8]
.text$mn:000074EE                 push    edx             ; wchar_t *
.text$mn:000074EF                 mov     eax, [ebp+arg_4]
.text$mn:000074F2                 push    eax             ; int
.text$mn:000074F3                 call    ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z ; std::_Debug_pointer<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)
.text$mn:000074F8                 add     esp, 0Ch
.text$mn:000074FB                 mov     ecx, [ebp+arg_4]
.text$mn:000074FE                 cmp     ecx, [ebp+arg_0]
.text$mn:00007501                 jnb     short loc_7518
.text$mn:00007503                 mov     edx, [ebp+arg_C]
.text$mn:00007506                 push    edx             ; unsigned int
.text$mn:00007507                 mov     eax, [ebp+arg_8]
.text$mn:0000750A                 push    eax             ; wchar_t *
.text$mn:0000750B                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00007510                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007515                 add     esp, 0Ch
.text$mn:00007518
.text$mn:00007518 loc_7518:                               ; CODE XREF: std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00007518                                         ; std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00007518                 pop     ebp
.text$mn:00007519                 retn
.text$mn:00007519 ??$_Debug_range2@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00007519
.text$mn:00007519 ; ---------------------------------------------------------------------------
.text$mn:0000751A                 align 4
.text$mn:0000751A _text$mn        ends
.text$mn:0000751A
.text$mn:0000751C ; ===========================================================================
.text$mn:0000751C
.text$mn:0000751C ; Segment type: Pure code
.text$mn:0000751C ; Segment permissions: Read/Execute
.text$mn:0000751C _text$mn        segment para public 'CODE' use32
.text$mn:0000751C                 assume cs:_text$mn
.text$mn:0000751C                 ;org 751Ch
.text$mn:0000751C ; COMDAT (pick any)
.text$mn:0000751C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000751C
.text$mn:0000751C ; =============== S U B R O U T I N E =======================================
.text$mn:0000751C
.text$mn:0000751C ; Attributes: bp-based frame
.text$mn:0000751C
.text$mn:0000751C ; int __cdecl std::_Debug_range2<unsigned int const *>(int, int, wchar_t *, unsigned int)
.text$mn:0000751C                 public ??$_Debug_range2@PBI@std@@YAXPBI0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:0000751C ??$_Debug_range2@PBI@std@@YAXPBI0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:0000751C                                         ; CODE XREF: std::_Debug_range<uint const *>(uint const *,uint const *,wchar_t const *,uint)+2Ap
.text$mn:0000751C
.text$mn:0000751C arg_0           = dword ptr  8
.text$mn:0000751C arg_4           = dword ptr  0Ch
.text$mn:0000751C arg_8           = dword ptr  10h
.text$mn:0000751C arg_C           = dword ptr  14h
.text$mn:0000751C
.text$mn:0000751C                 push    ebp
.text$mn:0000751D                 mov     ebp, esp
.text$mn:0000751F                 mov     eax, [ebp+arg_0]
.text$mn:00007522                 cmp     eax, [ebp+arg_4]
.text$mn:00007525                 jz      short loc_756C
.text$mn:00007527                 mov     ecx, [ebp+arg_C]
.text$mn:0000752A                 push    ecx             ; unsigned int
.text$mn:0000752B                 mov     edx, [ebp+arg_8]
.text$mn:0000752E                 push    edx             ; wchar_t *
.text$mn:0000752F                 mov     eax, [ebp+arg_0]
.text$mn:00007532                 push    eax             ; int
.text$mn:00007533                 call    ??$_Debug_pointer@I@std@@YAXPBIPB_WI@Z ; std::_Debug_pointer<uint>(uint const *,wchar_t const *,uint)
.text$mn:00007538                 add     esp, 0Ch
.text$mn:0000753B                 mov     ecx, [ebp+arg_C]
.text$mn:0000753E                 push    ecx             ; unsigned int
.text$mn:0000753F                 mov     edx, [ebp+arg_8]
.text$mn:00007542                 push    edx             ; wchar_t *
.text$mn:00007543                 mov     eax, [ebp+arg_4]
.text$mn:00007546                 push    eax             ; int
.text$mn:00007547                 call    ??$_Debug_pointer@I@std@@YAXPBIPB_WI@Z ; std::_Debug_pointer<uint>(uint const *,wchar_t const *,uint)
.text$mn:0000754C                 add     esp, 0Ch
.text$mn:0000754F                 mov     ecx, [ebp+arg_4]
.text$mn:00007552                 cmp     ecx, [ebp+arg_0]
.text$mn:00007555                 jnb     short loc_756C
.text$mn:00007557                 mov     edx, [ebp+arg_C]
.text$mn:0000755A                 push    edx             ; unsigned int
.text$mn:0000755B                 mov     eax, [ebp+arg_8]
.text$mn:0000755E                 push    eax             ; wchar_t *
.text$mn:0000755F                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00007564                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007569                 add     esp, 0Ch
.text$mn:0000756C
.text$mn:0000756C loc_756C:                               ; CODE XREF: std::_Debug_range2<uint const *>(uint const *,uint const *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:0000756C                                         ; std::_Debug_range2<uint const *>(uint const *,uint const *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:0000756C                 pop     ebp
.text$mn:0000756D                 retn
.text$mn:0000756D ??$_Debug_range2@PBI@std@@YAXPBI0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:0000756D
.text$mn:0000756D ; ---------------------------------------------------------------------------
.text$mn:0000756E                 align 10h
.text$mn:0000756E _text$mn        ends
.text$mn:0000756E
.text$mn:00007570 ; ===========================================================================
.text$mn:00007570
.text$mn:00007570 ; Segment type: Pure code
.text$mn:00007570 ; Segment permissions: Read/Execute
.text$mn:00007570 _text$mn        segment para public 'CODE' use32
.text$mn:00007570                 assume cs:_text$mn
.text$mn:00007570                 ;org 7570h
.text$mn:00007570 ; COMDAT (pick any)
.text$mn:00007570                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007570
.text$mn:00007570 ; =============== S U B R O U T I N E =======================================
.text$mn:00007570
.text$mn:00007570 ; Attributes: bp-based frame
.text$mn:00007570
.text$mn:00007570 ; int __cdecl std::_Debug_range2<sessionFileInfo const *>(int, int, wchar_t *, unsigned int)
.text$mn:00007570                 public ??$_Debug_range2@PBUsessionFileInfo@@@std@@YAXPBUsessionFileInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00007570 ??$_Debug_range2@PBUsessionFileInfo@@@std@@YAXPBUsessionFileInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00007570                                         ; CODE XREF: std::_Debug_range<sessionFileInfo const *>(sessionFileInfo const *,sessionFileInfo const *,wchar_t const *,uint)+2Ap
.text$mn:00007570
.text$mn:00007570 arg_0           = dword ptr  8
.text$mn:00007570 arg_4           = dword ptr  0Ch
.text$mn:00007570 arg_8           = dword ptr  10h
.text$mn:00007570 arg_C           = dword ptr  14h
.text$mn:00007570
.text$mn:00007570                 push    ebp
.text$mn:00007571                 mov     ebp, esp
.text$mn:00007573                 mov     eax, [ebp+arg_0]
.text$mn:00007576                 cmp     eax, [ebp+arg_4]
.text$mn:00007579                 jz      short loc_75C0
.text$mn:0000757B                 mov     ecx, [ebp+arg_C]
.text$mn:0000757E                 push    ecx             ; unsigned int
.text$mn:0000757F                 mov     edx, [ebp+arg_8]
.text$mn:00007582                 push    edx             ; wchar_t *
.text$mn:00007583                 mov     eax, [ebp+arg_0]
.text$mn:00007586                 push    eax             ; int
.text$mn:00007587                 call    ??$_Debug_pointer@UsessionFileInfo@@@std@@YAXPBUsessionFileInfo@@PB_WI@Z ; std::_Debug_pointer<sessionFileInfo>(sessionFileInfo const *,wchar_t const *,uint)
.text$mn:0000758C                 add     esp, 0Ch
.text$mn:0000758F                 mov     ecx, [ebp+arg_C]
.text$mn:00007592                 push    ecx             ; unsigned int
.text$mn:00007593                 mov     edx, [ebp+arg_8]
.text$mn:00007596                 push    edx             ; wchar_t *
.text$mn:00007597                 mov     eax, [ebp+arg_4]
.text$mn:0000759A                 push    eax             ; int
.text$mn:0000759B                 call    ??$_Debug_pointer@UsessionFileInfo@@@std@@YAXPBUsessionFileInfo@@PB_WI@Z ; std::_Debug_pointer<sessionFileInfo>(sessionFileInfo const *,wchar_t const *,uint)
.text$mn:000075A0                 add     esp, 0Ch
.text$mn:000075A3                 mov     ecx, [ebp+arg_4]
.text$mn:000075A6                 cmp     ecx, [ebp+arg_0]
.text$mn:000075A9                 jnb     short loc_75C0
.text$mn:000075AB                 mov     edx, [ebp+arg_C]
.text$mn:000075AE                 push    edx             ; unsigned int
.text$mn:000075AF                 mov     eax, [ebp+arg_8]
.text$mn:000075B2                 push    eax             ; wchar_t *
.text$mn:000075B3                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:000075B8                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000075BD                 add     esp, 0Ch
.text$mn:000075C0
.text$mn:000075C0 loc_75C0:                               ; CODE XREF: std::_Debug_range2<sessionFileInfo const *>(sessionFileInfo const *,sessionFileInfo const *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:000075C0                                         ; std::_Debug_range2<sessionFileInfo const *>(sessionFileInfo const *,sessionFileInfo const *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:000075C0                 pop     ebp
.text$mn:000075C1                 retn
.text$mn:000075C1 ??$_Debug_range2@PBUsessionFileInfo@@@std@@YAXPBUsessionFileInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000075C1
.text$mn:000075C1 ; ---------------------------------------------------------------------------
.text$mn:000075C2                 align 4
.text$mn:000075C2 _text$mn        ends
.text$mn:000075C2
.text$mn:000075C4 ; ===========================================================================
.text$mn:000075C4
.text$mn:000075C4 ; Segment type: Pure code
.text$mn:000075C4 ; Segment permissions: Read/Execute
.text$mn:000075C4 _text$mn        segment para public 'CODE' use32
.text$mn:000075C4                 assume cs:_text$mn
.text$mn:000075C4                 ;org 75C4h
.text$mn:000075C4 ; COMDAT (pick any)
.text$mn:000075C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000075C4
.text$mn:000075C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000075C4
.text$mn:000075C4 ; Attributes: bp-based frame
.text$mn:000075C4
.text$mn:000075C4 ; int __cdecl std::_Debug_range<int *>(int, int, wchar_t *, unsigned int)
.text$mn:000075C4                 public ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z
.text$mn:000075C4 ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z proc near
.text$mn:000075C4                                         ; CODE XREF: std::_Uninit_move<int,int,int>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:000075C4
.text$mn:000075C4 var_1           = byte ptr -1
.text$mn:000075C4 arg_0           = dword ptr  8
.text$mn:000075C4 arg_4           = dword ptr  0Ch
.text$mn:000075C4 arg_8           = dword ptr  10h
.text$mn:000075C4 arg_C           = dword ptr  14h
.text$mn:000075C4
.text$mn:000075C4                 push    ebp
.text$mn:000075C5                 mov     ebp, esp
.text$mn:000075C7                 push    ecx
.text$mn:000075C8                 lea     eax, [ebp+arg_0]
.text$mn:000075CB                 push    eax
.text$mn:000075CC                 lea     ecx, [ebp+var_1]
.text$mn:000075CF                 push    ecx
.text$mn:000075D0                 call    ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>(int * const &)
.text$mn:000075D5                 add     esp, 8
.text$mn:000075D8                 mov     dl, [eax]
.text$mn:000075DA                 movzx   eax, dl
.text$mn:000075DD                 push    eax
.text$mn:000075DE                 mov     ecx, [ebp+arg_C]
.text$mn:000075E1                 push    ecx             ; unsigned int
.text$mn:000075E2                 mov     edx, [ebp+arg_8]
.text$mn:000075E5                 push    edx             ; wchar_t *
.text$mn:000075E6                 mov     eax, [ebp+arg_4]
.text$mn:000075E9                 push    eax             ; int
.text$mn:000075EA                 mov     ecx, [ebp+arg_0]
.text$mn:000075ED                 push    ecx             ; int
.text$mn:000075EE                 call    ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:000075F3                 add     esp, 14h
.text$mn:000075F6                 mov     esp, ebp
.text$mn:000075F8                 pop     ebp
.text$mn:000075F9                 retn
.text$mn:000075F9 ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z endp
.text$mn:000075F9
.text$mn:000075F9 ; ---------------------------------------------------------------------------
.text$mn:000075FA                 align 4
.text$mn:000075FA _text$mn        ends
.text$mn:000075FA
.text$mn:000075FC ; ===========================================================================
.text$mn:000075FC
.text$mn:000075FC ; Segment type: Pure code
.text$mn:000075FC ; Segment permissions: Read/Execute
.text$mn:000075FC _text$mn        segment para public 'CODE' use32
.text$mn:000075FC                 assume cs:_text$mn
.text$mn:000075FC                 ;org 75FCh
.text$mn:000075FC ; COMDAT (pick any)
.text$mn:000075FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000075FC
.text$mn:000075FC ; =============== S U B R O U T I N E =======================================
.text$mn:000075FC
.text$mn:000075FC ; Attributes: bp-based frame
.text$mn:000075FC
.text$mn:000075FC ; int __cdecl std::_Debug_range<unsigned int *>(int, int, wchar_t *, unsigned int)
.text$mn:000075FC                 public ??$_Debug_range@PAI@std@@YAXPAI0PB_WI@Z
.text$mn:000075FC ??$_Debug_range@PAI@std@@YAXPAI0PB_WI@Z proc near
.text$mn:000075FC                                         ; CODE XREF: std::_Uninit_copy<uint,uint>(uint *,uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:000075FC
.text$mn:000075FC var_1           = byte ptr -1
.text$mn:000075FC arg_0           = dword ptr  8
.text$mn:000075FC arg_4           = dword ptr  0Ch
.text$mn:000075FC arg_8           = dword ptr  10h
.text$mn:000075FC arg_C           = dword ptr  14h
.text$mn:000075FC
.text$mn:000075FC                 push    ebp
.text$mn:000075FD                 mov     ebp, esp
.text$mn:000075FF                 push    ecx
.text$mn:00007600                 lea     eax, [ebp+arg_0]
.text$mn:00007603                 push    eax
.text$mn:00007604                 lea     ecx, [ebp+var_1]
.text$mn:00007607                 push    ecx
.text$mn:00007608                 call    ??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ; std::_Iter_cat<uint *>(uint * const &)
.text$mn:0000760D                 add     esp, 8
.text$mn:00007610                 mov     dl, [eax]
.text$mn:00007612                 movzx   eax, dl
.text$mn:00007615                 push    eax
.text$mn:00007616                 mov     ecx, [ebp+arg_C]
.text$mn:00007619                 push    ecx             ; unsigned int
.text$mn:0000761A                 mov     edx, [ebp+arg_8]
.text$mn:0000761D                 push    edx             ; wchar_t *
.text$mn:0000761E                 mov     eax, [ebp+arg_4]
.text$mn:00007621                 push    eax             ; int
.text$mn:00007622                 mov     ecx, [ebp+arg_0]
.text$mn:00007625                 push    ecx             ; int
.text$mn:00007626                 call    ??$_Debug_range2@PAI@std@@YAXPAI0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<uint *>(uint *,uint *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:0000762B                 add     esp, 14h
.text$mn:0000762E                 mov     esp, ebp
.text$mn:00007630                 pop     ebp
.text$mn:00007631                 retn
.text$mn:00007631 ??$_Debug_range@PAI@std@@YAXPAI0PB_WI@Z endp
.text$mn:00007631
.text$mn:00007631 ; ---------------------------------------------------------------------------
.text$mn:00007632                 align 4
.text$mn:00007632 _text$mn        ends
.text$mn:00007632
.text$mn:00007634 ; ===========================================================================
.text$mn:00007634
.text$mn:00007634 ; Segment type: Pure code
.text$mn:00007634 ; Segment permissions: Read/Execute
.text$mn:00007634 _text$mn        segment para public 'CODE' use32
.text$mn:00007634                 assume cs:_text$mn
.text$mn:00007634                 ;org 7634h
.text$mn:00007634 ; COMDAT (pick any)
.text$mn:00007634                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007634
.text$mn:00007634 ; =============== S U B R O U T I N E =======================================
.text$mn:00007634
.text$mn:00007634 ; Attributes: bp-based frame
.text$mn:00007634
.text$mn:00007634 ; int __cdecl std::_Debug_range<sessionFileInfo *>(int, int, wchar_t *, unsigned int)
.text$mn:00007634                 public ??$_Debug_range@PAUsessionFileInfo@@@std@@YAXPAUsessionFileInfo@@0PB_WI@Z
.text$mn:00007634 ??$_Debug_range@PAUsessionFileInfo@@@std@@YAXPAUsessionFileInfo@@0PB_WI@Z proc near
.text$mn:00007634                                         ; CODE XREF: std::_Uninit_move<sessionFileInfo *,sessionFileInfo *,std::allocator<sessionFileInfo>,sessionFileInfo>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,sessionFileInfo *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:00007634
.text$mn:00007634 var_1           = byte ptr -1
.text$mn:00007634 arg_0           = dword ptr  8
.text$mn:00007634 arg_4           = dword ptr  0Ch
.text$mn:00007634 arg_8           = dword ptr  10h
.text$mn:00007634 arg_C           = dword ptr  14h
.text$mn:00007634
.text$mn:00007634                 push    ebp
.text$mn:00007635                 mov     ebp, esp
.text$mn:00007637                 push    ecx
.text$mn:00007638                 lea     eax, [ebp+arg_0]
.text$mn:0000763B                 push    eax
.text$mn:0000763C                 lea     ecx, [ebp+var_1]
.text$mn:0000763F                 push    ecx
.text$mn:00007640                 call    ??$_Iter_cat@PAUsessionFileInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUsessionFileInfo@@@Z ; std::_Iter_cat<sessionFileInfo *>(sessionFileInfo * const &)
.text$mn:00007645                 add     esp, 8
.text$mn:00007648                 mov     dl, [eax]
.text$mn:0000764A                 movzx   eax, dl
.text$mn:0000764D                 push    eax
.text$mn:0000764E                 mov     ecx, [ebp+arg_C]
.text$mn:00007651                 push    ecx             ; unsigned int
.text$mn:00007652                 mov     edx, [ebp+arg_8]
.text$mn:00007655                 push    edx             ; wchar_t *
.text$mn:00007656                 mov     eax, [ebp+arg_4]
.text$mn:00007659                 push    eax             ; int
.text$mn:0000765A                 mov     ecx, [ebp+arg_0]
.text$mn:0000765D                 push    ecx             ; int
.text$mn:0000765E                 call    ??$_Debug_range2@PAUsessionFileInfo@@@std@@YAXPAUsessionFileInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00007663                 add     esp, 14h
.text$mn:00007666                 mov     esp, ebp
.text$mn:00007668                 pop     ebp
.text$mn:00007669                 retn
.text$mn:00007669 ??$_Debug_range@PAUsessionFileInfo@@@std@@YAXPAUsessionFileInfo@@0PB_WI@Z endp
.text$mn:00007669
.text$mn:00007669 ; ---------------------------------------------------------------------------
.text$mn:0000766A                 align 4
.text$mn:0000766A _text$mn        ends
.text$mn:0000766A
.text$mn:0000766C ; ===========================================================================
.text$mn:0000766C
.text$mn:0000766C ; Segment type: Pure code
.text$mn:0000766C ; Segment permissions: Read/Execute
.text$mn:0000766C _text$mn        segment para public 'CODE' use32
.text$mn:0000766C                 assume cs:_text$mn
.text$mn:0000766C                 ;org 766Ch
.text$mn:0000766C ; COMDAT (pick any)
.text$mn:0000766C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000766C
.text$mn:0000766C ; =============== S U B R O U T I N E =======================================
.text$mn:0000766C
.text$mn:0000766C ; Attributes: bp-based frame
.text$mn:0000766C
.text$mn:0000766C ; int __cdecl std::_Debug_range<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(int, int, wchar_t *, unsigned int)
.text$mn:0000766C                 public ??$_Debug_range@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WI@Z
.text$mn:0000766C ??$_Debug_range@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WI@Z proc near
.text$mn:0000766C                                         ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:0000766C
.text$mn:0000766C var_1           = byte ptr -1
.text$mn:0000766C arg_0           = dword ptr  8
.text$mn:0000766C arg_4           = dword ptr  0Ch
.text$mn:0000766C arg_8           = dword ptr  10h
.text$mn:0000766C arg_C           = dword ptr  14h
.text$mn:0000766C
.text$mn:0000766C                 push    ebp
.text$mn:0000766D                 mov     ebp, esp
.text$mn:0000766F                 push    ecx
.text$mn:00007670                 lea     eax, [ebp+arg_0]
.text$mn:00007673                 push    eax
.text$mn:00007674                 lea     ecx, [ebp+var_1]
.text$mn:00007677                 push    ecx
.text$mn:00007678                 call    ??$_Iter_cat@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::_Iter_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> * const &)
.text$mn:0000767D                 add     esp, 8
.text$mn:00007680                 mov     dl, [eax]
.text$mn:00007682                 movzx   eax, dl
.text$mn:00007685                 push    eax
.text$mn:00007686                 mov     ecx, [ebp+arg_C]
.text$mn:00007689                 push    ecx             ; unsigned int
.text$mn:0000768A                 mov     edx, [ebp+arg_8]
.text$mn:0000768D                 push    edx             ; wchar_t *
.text$mn:0000768E                 mov     eax, [ebp+arg_4]
.text$mn:00007691                 push    eax             ; int
.text$mn:00007692                 mov     ecx, [ebp+arg_0]
.text$mn:00007695                 push    ecx             ; int
.text$mn:00007696                 call    ??$_Debug_range2@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:0000769B                 add     esp, 14h
.text$mn:0000769E                 mov     esp, ebp
.text$mn:000076A0                 pop     ebp
.text$mn:000076A1                 retn
.text$mn:000076A1 ??$_Debug_range@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WI@Z endp
.text$mn:000076A1
.text$mn:000076A1 ; ---------------------------------------------------------------------------
.text$mn:000076A2                 align 4
.text$mn:000076A2 _text$mn        ends
.text$mn:000076A2
.text$mn:000076A4 ; ===========================================================================
.text$mn:000076A4
.text$mn:000076A4 ; Segment type: Pure code
.text$mn:000076A4 ; Segment permissions: Read/Execute
.text$mn:000076A4 _text$mn        segment para public 'CODE' use32
.text$mn:000076A4                 assume cs:_text$mn
.text$mn:000076A4                 ;org 76A4h
.text$mn:000076A4 ; COMDAT (pick any)
.text$mn:000076A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000076A4
.text$mn:000076A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000076A4
.text$mn:000076A4 ; Attributes: bp-based frame
.text$mn:000076A4
.text$mn:000076A4 ; int __cdecl std::_Debug_range<unsigned int const *>(int, int, wchar_t *, unsigned int)
.text$mn:000076A4                 public ??$_Debug_range@PBI@std@@YAXPBI0PB_WI@Z
.text$mn:000076A4 ??$_Debug_range@PBI@std@@YAXPBI0PB_WI@Z proc near
.text$mn:000076A4                                         ; CODE XREF: std::_Uninit_copy<uint const,uint>(uint const *,uint const *,uint *,std::_Wrap_alloc<std::allocator<uint>> &,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:000076A4
.text$mn:000076A4 var_1           = byte ptr -1
.text$mn:000076A4 arg_0           = dword ptr  8
.text$mn:000076A4 arg_4           = dword ptr  0Ch
.text$mn:000076A4 arg_8           = dword ptr  10h
.text$mn:000076A4 arg_C           = dword ptr  14h
.text$mn:000076A4
.text$mn:000076A4                 push    ebp
.text$mn:000076A5                 mov     ebp, esp
.text$mn:000076A7                 push    ecx
.text$mn:000076A8                 lea     eax, [ebp+arg_0]
.text$mn:000076AB                 push    eax
.text$mn:000076AC                 lea     ecx, [ebp+var_1]
.text$mn:000076AF                 push    ecx
.text$mn:000076B0                 call    ??$_Iter_cat@PBI@std@@YA?AUrandom_access_iterator_tag@0@ABQBI@Z ; std::_Iter_cat<uint const *>(uint const * const &)
.text$mn:000076B5                 add     esp, 8
.text$mn:000076B8                 mov     dl, [eax]
.text$mn:000076BA                 movzx   eax, dl
.text$mn:000076BD                 push    eax
.text$mn:000076BE                 mov     ecx, [ebp+arg_C]
.text$mn:000076C1                 push    ecx             ; unsigned int
.text$mn:000076C2                 mov     edx, [ebp+arg_8]
.text$mn:000076C5                 push    edx             ; wchar_t *
.text$mn:000076C6                 mov     eax, [ebp+arg_4]
.text$mn:000076C9                 push    eax             ; int
.text$mn:000076CA                 mov     ecx, [ebp+arg_0]
.text$mn:000076CD                 push    ecx             ; int
.text$mn:000076CE                 call    ??$_Debug_range2@PBI@std@@YAXPBI0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<uint const *>(uint const *,uint const *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:000076D3                 add     esp, 14h
.text$mn:000076D6                 mov     esp, ebp
.text$mn:000076D8                 pop     ebp
.text$mn:000076D9                 retn
.text$mn:000076D9 ??$_Debug_range@PBI@std@@YAXPBI0PB_WI@Z endp
.text$mn:000076D9
.text$mn:000076D9 ; ---------------------------------------------------------------------------
.text$mn:000076DA                 align 4
.text$mn:000076DA _text$mn        ends
.text$mn:000076DA
.text$mn:000076DC ; ===========================================================================
.text$mn:000076DC
.text$mn:000076DC ; Segment type: Pure code
.text$mn:000076DC ; Segment permissions: Read/Execute
.text$mn:000076DC _text$mn        segment para public 'CODE' use32
.text$mn:000076DC                 assume cs:_text$mn
.text$mn:000076DC                 ;org 76DCh
.text$mn:000076DC ; COMDAT (pick any)
.text$mn:000076DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000076DC
.text$mn:000076DC ; =============== S U B R O U T I N E =======================================
.text$mn:000076DC
.text$mn:000076DC ; Attributes: bp-based frame
.text$mn:000076DC
.text$mn:000076DC ; int __cdecl std::_Debug_range<sessionFileInfo const *>(int, int, wchar_t *, unsigned int)
.text$mn:000076DC                 public ??$_Debug_range@PBUsessionFileInfo@@@std@@YAXPBUsessionFileInfo@@0PB_WI@Z
.text$mn:000076DC ??$_Debug_range@PBUsessionFileInfo@@@std@@YAXPBUsessionFileInfo@@0PB_WI@Z proc near
.text$mn:000076DC                                         ; CODE XREF: std::_Uninit_copy<sessionFileInfo const *,sessionFileInfo *,std::allocator<sessionFileInfo>>(sessionFileInfo const *,sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:000076DC
.text$mn:000076DC var_1           = byte ptr -1
.text$mn:000076DC arg_0           = dword ptr  8
.text$mn:000076DC arg_4           = dword ptr  0Ch
.text$mn:000076DC arg_8           = dword ptr  10h
.text$mn:000076DC arg_C           = dword ptr  14h
.text$mn:000076DC
.text$mn:000076DC                 push    ebp
.text$mn:000076DD                 mov     ebp, esp
.text$mn:000076DF                 push    ecx
.text$mn:000076E0                 lea     eax, [ebp+arg_0]
.text$mn:000076E3                 push    eax
.text$mn:000076E4                 lea     ecx, [ebp+var_1]
.text$mn:000076E7                 push    ecx
.text$mn:000076E8                 call    ??$_Iter_cat@PBUsessionFileInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUsessionFileInfo@@@Z ; std::_Iter_cat<sessionFileInfo const *>(sessionFileInfo const * const &)
.text$mn:000076ED                 add     esp, 8
.text$mn:000076F0                 mov     dl, [eax]
.text$mn:000076F2                 movzx   eax, dl
.text$mn:000076F5                 push    eax
.text$mn:000076F6                 mov     ecx, [ebp+arg_C]
.text$mn:000076F9                 push    ecx             ; unsigned int
.text$mn:000076FA                 mov     edx, [ebp+arg_8]
.text$mn:000076FD                 push    edx             ; wchar_t *
.text$mn:000076FE                 mov     eax, [ebp+arg_4]
.text$mn:00007701                 push    eax             ; int
.text$mn:00007702                 mov     ecx, [ebp+arg_0]
.text$mn:00007705                 push    ecx             ; int
.text$mn:00007706                 call    ??$_Debug_range2@PBUsessionFileInfo@@@std@@YAXPBUsessionFileInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<sessionFileInfo const *>(sessionFileInfo const *,sessionFileInfo const *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:0000770B                 add     esp, 14h
.text$mn:0000770E                 mov     esp, ebp
.text$mn:00007710                 pop     ebp
.text$mn:00007711                 retn
.text$mn:00007711 ??$_Debug_range@PBUsessionFileInfo@@@std@@YAXPBUsessionFileInfo@@0PB_WI@Z endp
.text$mn:00007711
.text$mn:00007711 ; ---------------------------------------------------------------------------
.text$mn:00007712                 align 4
.text$mn:00007712 _text$mn        ends
.text$mn:00007712
.text$mn:00007714 ; ===========================================================================
.text$mn:00007714
.text$mn:00007714 ; Segment type: Pure code
.text$mn:00007714 ; Segment permissions: Read/Execute
.text$mn:00007714 _text$mn        segment para public 'CODE' use32
.text$mn:00007714                 assume cs:_text$mn
.text$mn:00007714                 ;org 7714h
.text$mn:00007714 ; COMDAT (pick any)
.text$mn:00007714                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007714
.text$mn:00007714 ; =============== S U B R O U T I N E =======================================
.text$mn:00007714
.text$mn:00007714 ; Attributes: bp-based frame
.text$mn:00007714
.text$mn:00007714 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<int>>>(int *, int *, struct std::_Wrap_alloc<class std::allocator<int>> &)
.text$mn:00007714                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
.text$mn:00007714 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z proc near
.text$mn:00007714                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Destroy(int *,int *)+21p
.text$mn:00007714
.text$mn:00007714 var_1           = byte ptr -1
.text$mn:00007714 arg_0           = dword ptr  8
.text$mn:00007714 arg_4           = dword ptr  0Ch
.text$mn:00007714 arg_8           = dword ptr  10h
.text$mn:00007714
.text$mn:00007714                 push    ebp
.text$mn:00007715                 mov     ebp, esp
.text$mn:00007717                 push    ecx
.text$mn:00007718                 mov     eax, [ebp+arg_4]
.text$mn:0000771B                 push    eax
.text$mn:0000771C                 mov     ecx, [ebp+arg_0]
.text$mn:0000771F                 push    ecx
.text$mn:00007720                 call    ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>(int *,int *)
.text$mn:00007725                 add     esp, 8
.text$mn:00007728                 mov     [ebp+var_1], al
.text$mn:0000772B                 movzx   edx, [ebp+var_1]
.text$mn:0000772F                 push    edx
.text$mn:00007730                 mov     eax, [ebp+arg_8]
.text$mn:00007733                 push    eax
.text$mn:00007734                 mov     ecx, [ebp+arg_4]
.text$mn:00007737                 push    ecx
.text$mn:00007738                 mov     edx, [ebp+arg_0]
.text$mn:0000773B                 push    edx
.text$mn:0000773C                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00007741                 add     esp, 10h
.text$mn:00007744                 mov     esp, ebp
.text$mn:00007746                 pop     ebp
.text$mn:00007747                 retn
.text$mn:00007747 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z endp
.text$mn:00007747
.text$mn:00007747 _text$mn        ends
.text$mn:00007747
.text$mn:00007748 ; ===========================================================================
.text$mn:00007748
.text$mn:00007748 ; Segment type: Pure code
.text$mn:00007748 ; Segment permissions: Read/Execute
.text$mn:00007748 _text$mn        segment para public 'CODE' use32
.text$mn:00007748                 assume cs:_text$mn
.text$mn:00007748                 ;org 7748h
.text$mn:00007748 ; COMDAT (pick any)
.text$mn:00007748                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007748
.text$mn:00007748 ; =============== S U B R O U T I N E =======================================
.text$mn:00007748
.text$mn:00007748 ; Attributes: bp-based frame
.text$mn:00007748
.text$mn:00007748 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<int>>>(int *, int *, struct std::_Wrap_alloc<class std::allocator<int>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00007748                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00007748 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00007748                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+28p
.text$mn:00007748                 push    ebp
.text$mn:00007749                 mov     ebp, esp
.text$mn:0000774B                 pop     ebp
.text$mn:0000774C                 retn
.text$mn:0000774C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000774C
.text$mn:0000774C ; ---------------------------------------------------------------------------
.text$mn:0000774D                 align 10h
.text$mn:0000774D _text$mn        ends
.text$mn:0000774D
.text$mn:00007750 ; ===========================================================================
.text$mn:00007750
.text$mn:00007750 ; Segment type: Pure code
.text$mn:00007750 ; Segment permissions: Read/Execute
.text$mn:00007750 _text$mn        segment para public 'CODE' use32
.text$mn:00007750                 assume cs:_text$mn
.text$mn:00007750                 ;org 7750h
.text$mn:00007750 ; COMDAT (pick any)
.text$mn:00007750                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007750
.text$mn:00007750 ; =============== S U B R O U T I N E =======================================
.text$mn:00007750
.text$mn:00007750 ; Attributes: bp-based frame
.text$mn:00007750
.text$mn:00007750 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<unsigned int>>>(unsigned int *, unsigned int *, struct std::_Wrap_alloc<class std::allocator<unsigned int>> &)
.text$mn:00007750                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
.text$mn:00007750 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z proc near
.text$mn:00007750                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Destroy(uint *,uint *)+21p
.text$mn:00007750
.text$mn:00007750 var_1           = byte ptr -1
.text$mn:00007750 arg_0           = dword ptr  8
.text$mn:00007750 arg_4           = dword ptr  0Ch
.text$mn:00007750 arg_8           = dword ptr  10h
.text$mn:00007750
.text$mn:00007750                 push    ebp
.text$mn:00007751                 mov     ebp, esp
.text$mn:00007753                 push    ecx
.text$mn:00007754                 mov     eax, [ebp+arg_4]
.text$mn:00007757                 push    eax
.text$mn:00007758                 mov     ecx, [ebp+arg_0]
.text$mn:0000775B                 push    ecx
.text$mn:0000775C                 call    ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAI0@Z ; std::_Ptr_cat<uint,uint>(uint *,uint *)
.text$mn:00007761                 add     esp, 8
.text$mn:00007764                 mov     [ebp+var_1], al
.text$mn:00007767                 movzx   edx, [ebp+var_1]
.text$mn:0000776B                 push    edx
.text$mn:0000776C                 mov     eax, [ebp+arg_8]
.text$mn:0000776F                 push    eax
.text$mn:00007770                 mov     ecx, [ebp+arg_4]
.text$mn:00007773                 push    ecx
.text$mn:00007774                 mov     edx, [ebp+arg_0]
.text$mn:00007777                 push    edx
.text$mn:00007778                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<uint>>>(uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:0000777D                 add     esp, 10h
.text$mn:00007780                 mov     esp, ebp
.text$mn:00007782                 pop     ebp
.text$mn:00007783                 retn
.text$mn:00007783 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z endp
.text$mn:00007783
.text$mn:00007783 _text$mn        ends
.text$mn:00007783
.text$mn:00007784 ; ===========================================================================
.text$mn:00007784
.text$mn:00007784 ; Segment type: Pure code
.text$mn:00007784 ; Segment permissions: Read/Execute
.text$mn:00007784 _text$mn        segment para public 'CODE' use32
.text$mn:00007784                 assume cs:_text$mn
.text$mn:00007784                 ;org 7784h
.text$mn:00007784 ; COMDAT (pick any)
.text$mn:00007784                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007784
.text$mn:00007784 ; =============== S U B R O U T I N E =======================================
.text$mn:00007784
.text$mn:00007784 ; Attributes: bp-based frame
.text$mn:00007784
.text$mn:00007784 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<unsigned int>>>(unsigned int *, unsigned int *, struct std::_Wrap_alloc<class std::allocator<unsigned int>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00007784                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00007784 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00007784                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<uint>>>(uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+28p
.text$mn:00007784                 push    ebp
.text$mn:00007785                 mov     ebp, esp
.text$mn:00007787                 pop     ebp
.text$mn:00007788                 retn
.text$mn:00007788 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00007788
.text$mn:00007788 ; ---------------------------------------------------------------------------
.text$mn:00007789                 align 4
.text$mn:00007789 _text$mn        ends
.text$mn:00007789
.text$mn:0000778C ; ===========================================================================
.text$mn:0000778C
.text$mn:0000778C ; Segment type: Pure code
.text$mn:0000778C ; Segment permissions: Read/Execute
.text$mn:0000778C _text$mn        segment para public 'CODE' use32
.text$mn:0000778C                 assume cs:_text$mn
.text$mn:0000778C                 ;org 778Ch
.text$mn:0000778C ; COMDAT (pick any)
.text$mn:0000778C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000778C
.text$mn:0000778C ; =============== S U B R O U T I N E =======================================
.text$mn:0000778C
.text$mn:0000778C ; Attributes: bp-based frame
.text$mn:0000778C
.text$mn:0000778C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>>>(struct sessionFileInfo *, struct sessionFileInfo *, struct std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>> &)
.text$mn:0000778C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAXPAUsessionFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z
.text$mn:0000778C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAXPAUsessionFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z proc near
.text$mn:0000778C                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Destroy(sessionFileInfo *,sessionFileInfo *)+21p
.text$mn:0000778C
.text$mn:0000778C var_1           = byte ptr -1
.text$mn:0000778C arg_0           = dword ptr  8
.text$mn:0000778C arg_4           = dword ptr  0Ch
.text$mn:0000778C arg_8           = dword ptr  10h
.text$mn:0000778C
.text$mn:0000778C                 push    ebp
.text$mn:0000778D                 mov     ebp, esp
.text$mn:0000778F                 push    ecx
.text$mn:00007790                 mov     eax, [ebp+arg_4]
.text$mn:00007793                 push    eax
.text$mn:00007794                 mov     ecx, [ebp+arg_0]
.text$mn:00007797                 push    ecx
.text$mn:00007798                 call    ??$_Ptr_cat@UsessionFileInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUsessionFileInfo@@0@Z ; std::_Ptr_cat<sessionFileInfo,sessionFileInfo>(sessionFileInfo *,sessionFileInfo *)
.text$mn:0000779D                 add     esp, 8
.text$mn:000077A0                 mov     [ebp+var_1], al
.text$mn:000077A3                 movzx   edx, [ebp+var_1]
.text$mn:000077A7                 push    edx
.text$mn:000077A8                 mov     eax, [ebp+arg_8]
.text$mn:000077AB                 push    eax
.text$mn:000077AC                 mov     ecx, [ebp+arg_4]
.text$mn:000077AF                 push    ecx
.text$mn:000077B0                 mov     edx, [ebp+arg_0]
.text$mn:000077B3                 push    edx
.text$mn:000077B4                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAXPAUsessionFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:000077B9                 add     esp, 10h
.text$mn:000077BC                 mov     esp, ebp
.text$mn:000077BE                 pop     ebp
.text$mn:000077BF                 retn
.text$mn:000077BF ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAXPAUsessionFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z endp
.text$mn:000077BF
.text$mn:000077BF _text$mn        ends
.text$mn:000077BF
.text$mn:000077C0 ; ===========================================================================
.text$mn:000077C0
.text$mn:000077C0 ; Segment type: Pure code
.text$mn:000077C0 ; Segment permissions: Read/Execute
.text$mn:000077C0 _text$mn        segment para public 'CODE' use32
.text$mn:000077C0                 assume cs:_text$mn
.text$mn:000077C0                 ;org 77C0h
.text$mn:000077C0 ; COMDAT (pick any)
.text$mn:000077C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000077C0
.text$mn:000077C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000077C0
.text$mn:000077C0 ; Attributes: bp-based frame
.text$mn:000077C0
.text$mn:000077C0 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>>>(struct sessionFileInfo *, struct sessionFileInfo *, struct std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:000077C0                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAXPAUsessionFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000077C0 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAXPAUsessionFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000077C0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)+28p
.text$mn:000077C0
.text$mn:000077C0 arg_0           = dword ptr  8
.text$mn:000077C0 arg_4           = dword ptr  0Ch
.text$mn:000077C0 arg_8           = dword ptr  10h
.text$mn:000077C0
.text$mn:000077C0                 push    ebp
.text$mn:000077C1                 mov     ebp, esp
.text$mn:000077C3                 jmp     short loc_77D0
.text$mn:000077C5 ; ---------------------------------------------------------------------------
.text$mn:000077C5
.text$mn:000077C5 loc_77C5:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)+24j
.text$mn:000077C5                 mov     eax, [ebp+arg_0]
.text$mn:000077C8                 add     eax, 98h ; 'ÿ'
.text$mn:000077CD                 mov     [ebp+arg_0], eax
.text$mn:000077D0
.text$mn:000077D0 loc_77D0:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:000077D0                 mov     ecx, [ebp+arg_0]
.text$mn:000077D3                 cmp     ecx, [ebp+arg_4]
.text$mn:000077D6                 jz      short loc_77E6
.text$mn:000077D8                 mov     edx, [ebp+arg_0]
.text$mn:000077DB                 push    edx
.text$mn:000077DC                 mov     ecx, [ebp+arg_8]
.text$mn:000077DF                 call    ??$destroy@UsessionFileInfo@@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@@Z ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::destroy<sessionFileInfo>(sessionFileInfo *)
.text$mn:000077E4                 jmp     short loc_77C5
.text$mn:000077E6 ; ---------------------------------------------------------------------------
.text$mn:000077E6
.text$mn:000077E6 loc_77E6:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)+16j
.text$mn:000077E6                 pop     ebp
.text$mn:000077E7                 retn
.text$mn:000077E7 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAXPAUsessionFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000077E7
.text$mn:000077E7 _text$mn        ends
.text$mn:000077E7
.text$mn:000077E8 ; ===========================================================================
.text$mn:000077E8
.text$mn:000077E8 ; Segment type: Pure code
.text$mn:000077E8 ; Segment permissions: Read/Execute
.text$mn:000077E8 _text$mn        segment para public 'CODE' use32
.text$mn:000077E8                 assume cs:_text$mn
.text$mn:000077E8                 ;org 77E8h
.text$mn:000077E8 ; COMDAT (pick any)
.text$mn:000077E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000077E8
.text$mn:000077E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000077E8
.text$mn:000077E8 ; Attributes: bp-based frame
.text$mn:000077E8
.text$mn:000077E8 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> &)
.text$mn:000077E8                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z
.text$mn:000077E8 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z proc near
.text$mn:000077E8                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Destroy(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+21p
.text$mn:000077E8
.text$mn:000077E8 var_1           = byte ptr -1
.text$mn:000077E8 arg_0           = dword ptr  8
.text$mn:000077E8 arg_4           = dword ptr  0Ch
.text$mn:000077E8 arg_8           = dword ptr  10h
.text$mn:000077E8
.text$mn:000077E8                 push    ebp
.text$mn:000077E9                 mov     ebp, esp
.text$mn:000077EB                 push    ecx
.text$mn:000077EC                 mov     eax, [ebp+arg_4]
.text$mn:000077EF                 push    eax
.text$mn:000077F0                 mov     ecx, [ebp+arg_0]
.text$mn:000077F3                 push    ecx
.text$mn:000077F4                 call    ??$_Ptr_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:000077F9                 add     esp, 8
.text$mn:000077FC                 mov     [ebp+var_1], al
.text$mn:000077FF                 movzx   edx, [ebp+var_1]
.text$mn:00007803                 push    edx
.text$mn:00007804                 mov     eax, [ebp+arg_8]
.text$mn:00007807                 push    eax
.text$mn:00007808                 mov     ecx, [ebp+arg_4]
.text$mn:0000780B                 push    ecx
.text$mn:0000780C                 mov     edx, [ebp+arg_0]
.text$mn:0000780F                 push    edx
.text$mn:00007810                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00007815                 add     esp, 10h
.text$mn:00007818                 mov     esp, ebp
.text$mn:0000781A                 pop     ebp
.text$mn:0000781B                 retn
.text$mn:0000781B ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z endp
.text$mn:0000781B
.text$mn:0000781B _text$mn        ends
.text$mn:0000781B
.text$mn:0000781C ; ===========================================================================
.text$mn:0000781C
.text$mn:0000781C ; Segment type: Pure code
.text$mn:0000781C ; Segment permissions: Read/Execute
.text$mn:0000781C _text$mn        segment para public 'CODE' use32
.text$mn:0000781C                 assume cs:_text$mn
.text$mn:0000781C                 ;org 781Ch
.text$mn:0000781C ; COMDAT (pick any)
.text$mn:0000781C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000781C
.text$mn:0000781C ; =============== S U B R O U T I N E =======================================
.text$mn:0000781C
.text$mn:0000781C ; Attributes: bp-based frame
.text$mn:0000781C
.text$mn:0000781C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000781C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000781C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:0000781C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+28p
.text$mn:0000781C
.text$mn:0000781C arg_0           = dword ptr  8
.text$mn:0000781C arg_4           = dword ptr  0Ch
.text$mn:0000781C arg_8           = dword ptr  10h
.text$mn:0000781C
.text$mn:0000781C                 push    ebp
.text$mn:0000781D                 mov     ebp, esp
.text$mn:0000781F                 jmp     short loc_782A
.text$mn:00007821 ; ---------------------------------------------------------------------------
.text$mn:00007821
.text$mn:00007821 loc_7821:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00007821                 mov     eax, [ebp+arg_0]
.text$mn:00007824                 add     eax, 1Ch
.text$mn:00007827                 mov     [ebp+arg_0], eax
.text$mn:0000782A
.text$mn:0000782A loc_782A:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:0000782A                 mov     ecx, [ebp+arg_0]
.text$mn:0000782D                 cmp     ecx, [ebp+arg_4]
.text$mn:00007830                 jz      short loc_7840
.text$mn:00007832                 mov     edx, [ebp+arg_0]
.text$mn:00007835                 push    edx
.text$mn:00007836                 mov     ecx, [ebp+arg_8]
.text$mn:00007839                 call    ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000783E                 jmp     short loc_7821
.text$mn:00007840 ; ---------------------------------------------------------------------------
.text$mn:00007840
.text$mn:00007840 loc_7840:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:00007840                 pop     ebp
.text$mn:00007841                 retn
.text$mn:00007841 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00007841
.text$mn:00007841 ; ---------------------------------------------------------------------------
.text$mn:00007842                 align 4
.text$mn:00007842 _text$mn        ends
.text$mn:00007842
.text$mn:00007844 ; ===========================================================================
.text$mn:00007844
.text$mn:00007844 ; Segment type: Pure code
.text$mn:00007844 ; Segment permissions: Read/Execute
.text$mn:00007844 _text$mn        segment para public 'CODE' use32
.text$mn:00007844                 assume cs:_text$mn
.text$mn:00007844                 ;org 7844h
.text$mn:00007844 ; COMDAT (pick any)
.text$mn:00007844                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007844
.text$mn:00007844 ; =============== S U B R O U T I N E =======================================
.text$mn:00007844
.text$mn:00007844 ; Attributes: bp-based frame
.text$mn:00007844
.text$mn:00007844 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<int *>(int * const &)
.text$mn:00007844                 public ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
.text$mn:00007844 ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z proc near
.text$mn:00007844                                         ; CODE XREF: std::_Debug_range<int *>(int *,int *,wchar_t const *,uint)+Cp
.text$mn:00007844
.text$mn:00007844 var_1           = byte ptr -1
.text$mn:00007844 arg_0           = dword ptr  8
.text$mn:00007844
.text$mn:00007844                 push    ebp
.text$mn:00007845                 mov     ebp, esp
.text$mn:00007847                 push    ecx
.text$mn:00007848                 mov     eax, [ebp+arg_0]
.text$mn:0000784B                 mov     cl, [ebp+var_1]
.text$mn:0000784E                 mov     [eax], cl
.text$mn:00007850                 mov     eax, [ebp+arg_0]
.text$mn:00007853                 mov     esp, ebp
.text$mn:00007855                 pop     ebp
.text$mn:00007856                 retn
.text$mn:00007856 ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z endp
.text$mn:00007856
.text$mn:00007856 ; ---------------------------------------------------------------------------
.text$mn:00007857                 align 4
.text$mn:00007857 _text$mn        ends
.text$mn:00007857
.text$mn:00007858 ; ===========================================================================
.text$mn:00007858
.text$mn:00007858 ; Segment type: Pure code
.text$mn:00007858 ; Segment permissions: Read/Execute
.text$mn:00007858 _text$mn        segment para public 'CODE' use32
.text$mn:00007858                 assume cs:_text$mn
.text$mn:00007858                 ;org 7858h
.text$mn:00007858 ; COMDAT (pick any)
.text$mn:00007858                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007858
.text$mn:00007858 ; =============== S U B R O U T I N E =======================================
.text$mn:00007858
.text$mn:00007858 ; Attributes: bp-based frame
.text$mn:00007858
.text$mn:00007858 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<unsigned int *>(unsigned int * const &)
.text$mn:00007858                 public ??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z
.text$mn:00007858 ??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z proc near
.text$mn:00007858                                         ; CODE XREF: std::_Debug_range<uint *>(uint *,uint *,wchar_t const *,uint)+Cp
.text$mn:00007858
.text$mn:00007858 var_1           = byte ptr -1
.text$mn:00007858 arg_0           = dword ptr  8
.text$mn:00007858
.text$mn:00007858                 push    ebp
.text$mn:00007859                 mov     ebp, esp
.text$mn:0000785B                 push    ecx
.text$mn:0000785C                 mov     eax, [ebp+arg_0]
.text$mn:0000785F                 mov     cl, [ebp+var_1]
.text$mn:00007862                 mov     [eax], cl
.text$mn:00007864                 mov     eax, [ebp+arg_0]
.text$mn:00007867                 mov     esp, ebp
.text$mn:00007869                 pop     ebp
.text$mn:0000786A                 retn
.text$mn:0000786A ??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z endp
.text$mn:0000786A
.text$mn:0000786A ; ---------------------------------------------------------------------------
.text$mn:0000786B                 align 4
.text$mn:0000786B _text$mn        ends
.text$mn:0000786B
.text$mn:0000786C ; ===========================================================================
.text$mn:0000786C
.text$mn:0000786C ; Segment type: Pure code
.text$mn:0000786C ; Segment permissions: Read/Execute
.text$mn:0000786C _text$mn        segment para public 'CODE' use32
.text$mn:0000786C                 assume cs:_text$mn
.text$mn:0000786C                 ;org 786Ch
.text$mn:0000786C ; COMDAT (pick any)
.text$mn:0000786C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000786C
.text$mn:0000786C ; =============== S U B R O U T I N E =======================================
.text$mn:0000786C
.text$mn:0000786C ; Attributes: bp-based frame
.text$mn:0000786C
.text$mn:0000786C ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct sessionFileInfo *>(struct sessionFileInfo * const &)
.text$mn:0000786C                 public ??$_Iter_cat@PAUsessionFileInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUsessionFileInfo@@@Z
.text$mn:0000786C ??$_Iter_cat@PAUsessionFileInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUsessionFileInfo@@@Z proc near
.text$mn:0000786C                                         ; CODE XREF: std::_Debug_range<sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,wchar_t const *,uint)+Cp
.text$mn:0000786C
.text$mn:0000786C var_1           = byte ptr -1
.text$mn:0000786C arg_0           = dword ptr  8
.text$mn:0000786C
.text$mn:0000786C                 push    ebp
.text$mn:0000786D                 mov     ebp, esp
.text$mn:0000786F                 push    ecx
.text$mn:00007870                 mov     eax, [ebp+arg_0]
.text$mn:00007873                 mov     cl, [ebp+var_1]
.text$mn:00007876                 mov     [eax], cl
.text$mn:00007878                 mov     eax, [ebp+arg_0]
.text$mn:0000787B                 mov     esp, ebp
.text$mn:0000787D                 pop     ebp
.text$mn:0000787E                 retn
.text$mn:0000787E ??$_Iter_cat@PAUsessionFileInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUsessionFileInfo@@@Z endp
.text$mn:0000787E
.text$mn:0000787E ; ---------------------------------------------------------------------------
.text$mn:0000787F                 align 10h
.text$mn:0000787F _text$mn        ends
.text$mn:0000787F
.text$mn:00007880 ; ===========================================================================
.text$mn:00007880
.text$mn:00007880 ; Segment type: Pure code
.text$mn:00007880 ; Segment permissions: Read/Execute
.text$mn:00007880 _text$mn        segment para public 'CODE' use32
.text$mn:00007880                 assume cs:_text$mn
.text$mn:00007880                 ;org 7880h
.text$mn:00007880 ; COMDAT (pick any)
.text$mn:00007880                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007880
.text$mn:00007880 ; =============== S U B R O U T I N E =======================================
.text$mn:00007880
.text$mn:00007880 ; Attributes: bp-based frame
.text$mn:00007880
.text$mn:00007880 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * const &)
.text$mn:00007880                 public ??$_Iter_cat@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
.text$mn:00007880 ??$_Iter_cat@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z proc near
.text$mn:00007880                                         ; CODE XREF: std::_Debug_range<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)+Cp
.text$mn:00007880
.text$mn:00007880 var_1           = byte ptr -1
.text$mn:00007880 arg_0           = dword ptr  8
.text$mn:00007880
.text$mn:00007880                 push    ebp
.text$mn:00007881                 mov     ebp, esp
.text$mn:00007883                 push    ecx
.text$mn:00007884                 mov     eax, [ebp+arg_0]
.text$mn:00007887                 mov     cl, [ebp+var_1]
.text$mn:0000788A                 mov     [eax], cl
.text$mn:0000788C                 mov     eax, [ebp+arg_0]
.text$mn:0000788F                 mov     esp, ebp
.text$mn:00007891                 pop     ebp
.text$mn:00007892                 retn
.text$mn:00007892 ??$_Iter_cat@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z endp
.text$mn:00007892
.text$mn:00007892 ; ---------------------------------------------------------------------------
.text$mn:00007893                 align 4
.text$mn:00007893 _text$mn        ends
.text$mn:00007893
.text$mn:00007894 ; ===========================================================================
.text$mn:00007894
.text$mn:00007894 ; Segment type: Pure code
.text$mn:00007894 ; Segment permissions: Read/Execute
.text$mn:00007894 _text$mn        segment para public 'CODE' use32
.text$mn:00007894                 assume cs:_text$mn
.text$mn:00007894                 ;org 7894h
.text$mn:00007894 ; COMDAT (pick any)
.text$mn:00007894                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007894
.text$mn:00007894 ; =============== S U B R O U T I N E =======================================
.text$mn:00007894
.text$mn:00007894 ; Attributes: bp-based frame
.text$mn:00007894
.text$mn:00007894 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<unsigned int const *>(unsigned int const * const &)
.text$mn:00007894                 public ??$_Iter_cat@PBI@std@@YA?AUrandom_access_iterator_tag@0@ABQBI@Z
.text$mn:00007894 ??$_Iter_cat@PBI@std@@YA?AUrandom_access_iterator_tag@0@ABQBI@Z proc near
.text$mn:00007894                                         ; CODE XREF: std::_Debug_range<uint const *>(uint const *,uint const *,wchar_t const *,uint)+Cp
.text$mn:00007894
.text$mn:00007894 var_1           = byte ptr -1
.text$mn:00007894 arg_0           = dword ptr  8
.text$mn:00007894
.text$mn:00007894                 push    ebp
.text$mn:00007895                 mov     ebp, esp
.text$mn:00007897                 push    ecx
.text$mn:00007898                 mov     eax, [ebp+arg_0]
.text$mn:0000789B                 mov     cl, [ebp+var_1]
.text$mn:0000789E                 mov     [eax], cl
.text$mn:000078A0                 mov     eax, [ebp+arg_0]
.text$mn:000078A3                 mov     esp, ebp
.text$mn:000078A5                 pop     ebp
.text$mn:000078A6                 retn
.text$mn:000078A6 ??$_Iter_cat@PBI@std@@YA?AUrandom_access_iterator_tag@0@ABQBI@Z endp
.text$mn:000078A6
.text$mn:000078A6 ; ---------------------------------------------------------------------------
.text$mn:000078A7                 align 4
.text$mn:000078A7 _text$mn        ends
.text$mn:000078A7
.text$mn:000078A8 ; ===========================================================================
.text$mn:000078A8
.text$mn:000078A8 ; Segment type: Pure code
.text$mn:000078A8 ; Segment permissions: Read/Execute
.text$mn:000078A8 _text$mn        segment para public 'CODE' use32
.text$mn:000078A8                 assume cs:_text$mn
.text$mn:000078A8                 ;org 78A8h
.text$mn:000078A8 ; COMDAT (pick any)
.text$mn:000078A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000078A8
.text$mn:000078A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000078A8
.text$mn:000078A8 ; Attributes: bp-based frame
.text$mn:000078A8
.text$mn:000078A8 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct sessionFileInfo const *>(struct sessionFileInfo const * const &)
.text$mn:000078A8                 public ??$_Iter_cat@PBUsessionFileInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUsessionFileInfo@@@Z
.text$mn:000078A8 ??$_Iter_cat@PBUsessionFileInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUsessionFileInfo@@@Z proc near
.text$mn:000078A8                                         ; CODE XREF: std::_Debug_range<sessionFileInfo const *>(sessionFileInfo const *,sessionFileInfo const *,wchar_t const *,uint)+Cp
.text$mn:000078A8
.text$mn:000078A8 var_1           = byte ptr -1
.text$mn:000078A8 arg_0           = dword ptr  8
.text$mn:000078A8
.text$mn:000078A8                 push    ebp
.text$mn:000078A9                 mov     ebp, esp
.text$mn:000078AB                 push    ecx
.text$mn:000078AC                 mov     eax, [ebp+arg_0]
.text$mn:000078AF                 mov     cl, [ebp+var_1]
.text$mn:000078B2                 mov     [eax], cl
.text$mn:000078B4                 mov     eax, [ebp+arg_0]
.text$mn:000078B7                 mov     esp, ebp
.text$mn:000078B9                 pop     ebp
.text$mn:000078BA                 retn
.text$mn:000078BA ??$_Iter_cat@PBUsessionFileInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUsessionFileInfo@@@Z endp
.text$mn:000078BA
.text$mn:000078BA ; ---------------------------------------------------------------------------
.text$mn:000078BB                 align 4
.text$mn:000078BB _text$mn        ends
.text$mn:000078BB
.text$mn:000078BC ; ===========================================================================
.text$mn:000078BC
.text$mn:000078BC ; Segment type: Pure code
.text$mn:000078BC ; Segment permissions: Read/Execute
.text$mn:000078BC _text$mn        segment para public 'CODE' use32
.text$mn:000078BC                 assume cs:_text$mn
.text$mn:000078BC                 ;org 78BCh
.text$mn:000078BC ; COMDAT (pick any)
.text$mn:000078BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000078BC
.text$mn:000078BC ; =============== S U B R O U T I N E =======================================
.text$mn:000078BC
.text$mn:000078BC ; Attributes: bp-based frame
.text$mn:000078BC
.text$mn:000078BC ; struct sessionFileInfo * __cdecl std::_Move<struct sessionFileInfo *, struct sessionFileInfo *>(struct sessionFileInfo *, struct sessionFileInfo *, struct sessionFileInfo *)
.text$mn:000078BC                 public ??$_Move@PAUsessionFileInfo@@PAU1@@std@@YAPAUsessionFileInfo@@PAU1@00@Z
.text$mn:000078BC ??$_Move@PAUsessionFileInfo@@PAU1@@std@@YAPAUsessionFileInfo@@PAU1@00@Z proc near
.text$mn:000078BC                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)+85p
.text$mn:000078BC
.text$mn:000078BC var_1           = byte ptr -1
.text$mn:000078BC arg_0           = dword ptr  8
.text$mn:000078BC arg_4           = dword ptr  0Ch
.text$mn:000078BC arg_8           = dword ptr  10h
.text$mn:000078BC
.text$mn:000078BC                 push    ebp
.text$mn:000078BD                 mov     ebp, esp
.text$mn:000078BF                 push    ecx
.text$mn:000078C0                 mov     eax, [ebp+arg_8]
.text$mn:000078C3                 push    eax
.text$mn:000078C4                 mov     ecx, [ebp+arg_0]
.text$mn:000078C7                 push    ecx
.text$mn:000078C8                 call    ??$_Ptr_cat@UsessionFileInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUsessionFileInfo@@0@Z ; std::_Ptr_cat<sessionFileInfo,sessionFileInfo>(sessionFileInfo *,sessionFileInfo *)
.text$mn:000078CD                 add     esp, 8
.text$mn:000078D0                 mov     [ebp+var_1], al
.text$mn:000078D3                 movzx   edx, [ebp+var_1]
.text$mn:000078D7                 push    edx
.text$mn:000078D8                 mov     eax, [ebp+arg_8]
.text$mn:000078DB                 push    eax
.text$mn:000078DC                 mov     ecx, [ebp+arg_4]
.text$mn:000078DF                 push    ecx
.text$mn:000078E0                 mov     edx, [ebp+arg_0]
.text$mn:000078E3                 push    edx
.text$mn:000078E4                 call    ??$_Move@PAUsessionFileInfo@@PAU1@@std@@YAPAUsessionFileInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<sessionFileInfo *,sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:000078E9                 add     esp, 10h
.text$mn:000078EC                 mov     esp, ebp
.text$mn:000078EE                 pop     ebp
.text$mn:000078EF                 retn
.text$mn:000078EF ??$_Move@PAUsessionFileInfo@@PAU1@@std@@YAPAUsessionFileInfo@@PAU1@00@Z endp
.text$mn:000078EF
.text$mn:000078EF _text$mn        ends
.text$mn:000078EF
.text$mn:000078F0 ; ===========================================================================
.text$mn:000078F0
.text$mn:000078F0 ; Segment type: Pure code
.text$mn:000078F0 ; Segment permissions: Read/Execute
.text$mn:000078F0 _text$mn        segment para public 'CODE' use32
.text$mn:000078F0                 assume cs:_text$mn
.text$mn:000078F0                 ;org 78F0h
.text$mn:000078F0 ; COMDAT (pick any)
.text$mn:000078F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000078F0
.text$mn:000078F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000078F0
.text$mn:000078F0 ; Attributes: bp-based frame
.text$mn:000078F0
.text$mn:000078F0 ; struct sessionFileInfo * __cdecl std::_Move<struct sessionFileInfo *, struct sessionFileInfo *>(struct sessionFileInfo *, struct sessionFileInfo *, struct sessionFileInfo *, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:000078F0                 public ??$_Move@PAUsessionFileInfo@@PAU1@@std@@YAPAUsessionFileInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000078F0 ??$_Move@PAUsessionFileInfo@@PAU1@@std@@YAPAUsessionFileInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000078F0                                         ; CODE XREF: std::_Move<sessionFileInfo *,sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *)+28p
.text$mn:000078F0
.text$mn:000078F0 arg_0           = dword ptr  8
.text$mn:000078F0 arg_4           = dword ptr  0Ch
.text$mn:000078F0 arg_8           = dword ptr  10h
.text$mn:000078F0
.text$mn:000078F0                 push    ebp
.text$mn:000078F1                 mov     ebp, esp
.text$mn:000078F3                 jmp     short loc_790C
.text$mn:000078F5 ; ---------------------------------------------------------------------------
.text$mn:000078F5
.text$mn:000078F5 loc_78F5:                               ; CODE XREF: std::_Move<sessionFileInfo *,sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Nonscalar_ptr_iterator_tag)+39j
.text$mn:000078F5                 mov     eax, [ebp+arg_8]
.text$mn:000078F8                 add     eax, 98h ; 'ÿ'
.text$mn:000078FD                 mov     [ebp+arg_8], eax
.text$mn:00007900                 mov     ecx, [ebp+arg_0]
.text$mn:00007903                 add     ecx, 98h ; 'ÿ'
.text$mn:00007909                 mov     [ebp+arg_0], ecx
.text$mn:0000790C
.text$mn:0000790C loc_790C:                               ; CODE XREF: std::_Move<sessionFileInfo *,sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:0000790C                 mov     edx, [ebp+arg_0]
.text$mn:0000790F                 cmp     edx, [ebp+arg_4]
.text$mn:00007912                 jz      short loc_792B
.text$mn:00007914                 mov     eax, [ebp+arg_0]
.text$mn:00007917                 push    eax
.text$mn:00007918                 call    ??$move@AAUsessionFileInfo@@@std@@YA$$QAUsessionFileInfo@@AAU1@@Z ; std::move<sessionFileInfo &>(sessionFileInfo &)
.text$mn:0000791D                 add     esp, 4
.text$mn:00007920                 push    eax
.text$mn:00007921                 mov     ecx, [ebp+arg_8]
.text$mn:00007924                 call    ??4sessionFileInfo@@QAEAAU0@ABU0@@Z ; sessionFileInfo::operator=(sessionFileInfo const &)
.text$mn:00007929                 jmp     short loc_78F5
.text$mn:0000792B ; ---------------------------------------------------------------------------
.text$mn:0000792B
.text$mn:0000792B loc_792B:                               ; CODE XREF: std::_Move<sessionFileInfo *,sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:0000792B                 mov     eax, [ebp+arg_8]
.text$mn:0000792E                 pop     ebp
.text$mn:0000792F                 retn
.text$mn:0000792F ??$_Move@PAUsessionFileInfo@@PAU1@@std@@YAPAUsessionFileInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000792F
.text$mn:0000792F _text$mn        ends
.text$mn:0000792F
.text$mn:00007930 ; ===========================================================================
.text$mn:00007930
.text$mn:00007930 ; Segment type: Pure code
.text$mn:00007930 ; Segment permissions: Read/Execute
.text$mn:00007930 _text$mn        segment para public 'CODE' use32
.text$mn:00007930                 assume cs:_text$mn
.text$mn:00007930                 ;org 7930h
.text$mn:00007930 ; COMDAT (pick any)
.text$mn:00007930                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007930
.text$mn:00007930 ; =============== S U B R O U T I N E =======================================
.text$mn:00007930
.text$mn:00007930 ; Attributes: bp-based frame
.text$mn:00007930
.text$mn:00007930 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<int, int>(int *, int *)
.text$mn:00007930                 public ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z
.text$mn:00007930 ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z proc near
.text$mn:00007930                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+Cp
.text$mn:00007930                                         ; std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+Cp
.text$mn:00007930
.text$mn:00007930 var_1           = byte ptr -1
.text$mn:00007930
.text$mn:00007930                 push    ebp
.text$mn:00007931                 mov     ebp, esp
.text$mn:00007933                 push    ecx
.text$mn:00007934                 mov     al, [ebp+var_1]
.text$mn:00007937                 mov     esp, ebp
.text$mn:00007939                 pop     ebp
.text$mn:0000793A                 retn
.text$mn:0000793A ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z endp
.text$mn:0000793A
.text$mn:0000793A ; ---------------------------------------------------------------------------
.text$mn:0000793B                 align 4
.text$mn:0000793B _text$mn        ends
.text$mn:0000793B
.text$mn:0000793C ; ===========================================================================
.text$mn:0000793C
.text$mn:0000793C ; Segment type: Pure code
.text$mn:0000793C ; Segment permissions: Read/Execute
.text$mn:0000793C _text$mn        segment para public 'CODE' use32
.text$mn:0000793C                 assume cs:_text$mn
.text$mn:0000793C                 ;org 793Ch
.text$mn:0000793C ; COMDAT (pick any)
.text$mn:0000793C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000793C
.text$mn:0000793C ; =============== S U B R O U T I N E =======================================
.text$mn:0000793C
.text$mn:0000793C ; Attributes: bp-based frame
.text$mn:0000793C
.text$mn:0000793C ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<unsigned int, unsigned int>(unsigned int *, unsigned int *)
.text$mn:0000793C                 public ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAI0@Z
.text$mn:0000793C ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAI0@Z proc near
.text$mn:0000793C                                         ; CODE XREF: std::_Copy_impl<uint *,uint *>(uint *,uint *,uint *)+Cp
.text$mn:0000793C                                         ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<uint>>>(uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+Cp ...
.text$mn:0000793C
.text$mn:0000793C var_1           = byte ptr -1
.text$mn:0000793C
.text$mn:0000793C                 push    ebp
.text$mn:0000793D                 mov     ebp, esp
.text$mn:0000793F                 push    ecx
.text$mn:00007940                 mov     al, [ebp+var_1]
.text$mn:00007943                 mov     esp, ebp
.text$mn:00007945                 pop     ebp
.text$mn:00007946                 retn
.text$mn:00007946 ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAI0@Z endp
.text$mn:00007946
.text$mn:00007946 ; ---------------------------------------------------------------------------
.text$mn:00007947                 align 4
.text$mn:00007947 _text$mn        ends
.text$mn:00007947
.text$mn:00007948 ; ===========================================================================
.text$mn:00007948
.text$mn:00007948 ; Segment type: Pure code
.text$mn:00007948 ; Segment permissions: Read/Execute
.text$mn:00007948 _text$mn        segment para public 'CODE' use32
.text$mn:00007948                 assume cs:_text$mn
.text$mn:00007948                 ;org 7948h
.text$mn:00007948 ; COMDAT (pick any)
.text$mn:00007948                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007948
.text$mn:00007948 ; =============== S U B R O U T I N E =======================================
.text$mn:00007948
.text$mn:00007948 ; Attributes: bp-based frame
.text$mn:00007948
.text$mn:00007948 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<unsigned int, unsigned int>(unsigned int const *, unsigned int *)
.text$mn:00007948                 public ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBIPAI@Z
.text$mn:00007948 ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBIPAI@Z proc near
.text$mn:00007948                                         ; CODE XREF: std::_Uninit_copy<uint const *,uint *,std::_Wrap_alloc<std::allocator<uint>>>(uint const *,uint const *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+Cp
.text$mn:00007948
.text$mn:00007948 var_1           = byte ptr -1
.text$mn:00007948
.text$mn:00007948                 push    ebp
.text$mn:00007949                 mov     ebp, esp
.text$mn:0000794B                 push    ecx
.text$mn:0000794C                 mov     al, [ebp+var_1]
.text$mn:0000794F                 mov     esp, ebp
.text$mn:00007951                 pop     ebp
.text$mn:00007952                 retn
.text$mn:00007952 ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBIPAI@Z endp
.text$mn:00007952
.text$mn:00007952 ; ---------------------------------------------------------------------------
.text$mn:00007953                 align 4
.text$mn:00007953 _text$mn        ends
.text$mn:00007953
.text$mn:00007954 ; ===========================================================================
.text$mn:00007954
.text$mn:00007954 ; Segment type: Pure code
.text$mn:00007954 ; Segment permissions: Read/Execute
.text$mn:00007954 _text$mn        segment para public 'CODE' use32
.text$mn:00007954                 assume cs:_text$mn
.text$mn:00007954                 ;org 7954h
.text$mn:00007954 ; COMDAT (pick any)
.text$mn:00007954                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007954
.text$mn:00007954 ; =============== S U B R O U T I N E =======================================
.text$mn:00007954
.text$mn:00007954 ; Attributes: bp-based frame
.text$mn:00007954
.text$mn:00007954 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct sessionFileInfo, struct sessionFileInfo>(struct sessionFileInfo *, struct sessionFileInfo *)
.text$mn:00007954                 public ??$_Ptr_cat@UsessionFileInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUsessionFileInfo@@0@Z
.text$mn:00007954 ??$_Ptr_cat@UsessionFileInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUsessionFileInfo@@0@Z proc near
.text$mn:00007954                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)+Cp
.text$mn:00007954                                         ; std::_Move<sessionFileInfo *,sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *)+Cp ...
.text$mn:00007954
.text$mn:00007954 var_1           = byte ptr -1
.text$mn:00007954
.text$mn:00007954                 push    ebp
.text$mn:00007955                 mov     ebp, esp
.text$mn:00007957                 push    ecx
.text$mn:00007958                 mov     al, [ebp+var_1]
.text$mn:0000795B                 mov     esp, ebp
.text$mn:0000795D                 pop     ebp
.text$mn:0000795E                 retn
.text$mn:0000795E ??$_Ptr_cat@UsessionFileInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUsessionFileInfo@@0@Z endp
.text$mn:0000795E
.text$mn:0000795E ; ---------------------------------------------------------------------------
.text$mn:0000795F                 align 10h
.text$mn:0000795F _text$mn        ends
.text$mn:0000795F
.text$mn:00007960 ; ===========================================================================
.text$mn:00007960
.text$mn:00007960 ; Segment type: Pure code
.text$mn:00007960 ; Segment permissions: Read/Execute
.text$mn:00007960 _text$mn        segment para public 'CODE' use32
.text$mn:00007960                 assume cs:_text$mn
.text$mn:00007960                 ;org 7960h
.text$mn:00007960 ; COMDAT (pick any)
.text$mn:00007960                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007960
.text$mn:00007960 ; =============== S U B R O U T I N E =======================================
.text$mn:00007960
.text$mn:00007960 ; Attributes: bp-based frame
.text$mn:00007960
.text$mn:00007960 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct sessionFileInfo, struct sessionFileInfo>(struct sessionFileInfo const *, struct sessionFileInfo *)
.text$mn:00007960                 public ??$_Ptr_cat@UsessionFileInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUsessionFileInfo@@PAU2@@Z
.text$mn:00007960 ??$_Ptr_cat@UsessionFileInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUsessionFileInfo@@PAU2@@Z proc near
.text$mn:00007960                                         ; CODE XREF: std::_Uninit_copy<sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo const *,sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)+Cp
.text$mn:00007960
.text$mn:00007960 var_1           = byte ptr -1
.text$mn:00007960
.text$mn:00007960                 push    ebp
.text$mn:00007961                 mov     ebp, esp
.text$mn:00007963                 push    ecx
.text$mn:00007964                 mov     al, [ebp+var_1]
.text$mn:00007967                 mov     esp, ebp
.text$mn:00007969                 pop     ebp
.text$mn:0000796A                 retn
.text$mn:0000796A ??$_Ptr_cat@UsessionFileInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUsessionFileInfo@@PAU2@@Z endp
.text$mn:0000796A
.text$mn:0000796A ; ---------------------------------------------------------------------------
.text$mn:0000796B                 align 4
.text$mn:0000796B _text$mn        ends
.text$mn:0000796B
.text$mn:0000796C ; ===========================================================================
.text$mn:0000796C
.text$mn:0000796C ; Segment type: Pure code
.text$mn:0000796C ; Segment permissions: Read/Execute
.text$mn:0000796C _text$mn        segment para public 'CODE' use32
.text$mn:0000796C                 assume cs:_text$mn
.text$mn:0000796C                 ;org 796Ch
.text$mn:0000796C ; COMDAT (pick any)
.text$mn:0000796C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000796C
.text$mn:0000796C ; =============== S U B R O U T I N E =======================================
.text$mn:0000796C
.text$mn:0000796C ; Attributes: bp-based frame
.text$mn:0000796C
.text$mn:0000796C ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:0000796C                 public ??$_Ptr_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
.text$mn:0000796C ??$_Ptr_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z proc near
.text$mn:0000796C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+Cp
.text$mn:0000796C                                         ; std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+Cp
.text$mn:0000796C
.text$mn:0000796C var_1           = byte ptr -1
.text$mn:0000796C
.text$mn:0000796C                 push    ebp
.text$mn:0000796D                 mov     ebp, esp
.text$mn:0000796F                 push    ecx
.text$mn:00007970                 mov     al, [ebp+var_1]
.text$mn:00007973                 mov     esp, ebp
.text$mn:00007975                 pop     ebp
.text$mn:00007976                 retn
.text$mn:00007976 ??$_Ptr_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z endp
.text$mn:00007976
.text$mn:00007976 ; ---------------------------------------------------------------------------
.text$mn:00007977                 align 4
.text$mn:00007977 _text$mn        ends
.text$mn:00007977
.text$mn:00007978 ; ===========================================================================
.text$mn:00007978
.text$mn:00007978 ; Segment type: Pure code
.text$mn:00007978 ; Segment permissions: Read/Execute
.text$mn:00007978 _text$mn        segment para public 'CODE' use32
.text$mn:00007978                 assume cs:_text$mn
.text$mn:00007978                 ;org 7978h
.text$mn:00007978 ; COMDAT (pick any)
.text$mn:00007978                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007978
.text$mn:00007978 ; =============== S U B R O U T I N E =======================================
.text$mn:00007978
.text$mn:00007978 ; Attributes: bp-based frame
.text$mn:00007978
.text$mn:00007978 ; int * & __cdecl std::_Rechecked<int *, int *>(int * &, int *)
.text$mn:00007978                 public ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z
.text$mn:00007978 ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z proc near
.text$mn:00007978                                         ; CODE XREF: std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+3Bp
.text$mn:00007978
.text$mn:00007978 arg_0           = dword ptr  8
.text$mn:00007978 arg_4           = dword ptr  0Ch
.text$mn:00007978
.text$mn:00007978                 push    ebp
.text$mn:00007979                 mov     ebp, esp
.text$mn:0000797B                 mov     eax, [ebp+arg_0]
.text$mn:0000797E                 mov     ecx, [ebp+arg_4]
.text$mn:00007981                 mov     [eax], ecx
.text$mn:00007983                 mov     eax, [ebp+arg_0]
.text$mn:00007986                 pop     ebp
.text$mn:00007987                 retn
.text$mn:00007987 ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z endp
.text$mn:00007987
.text$mn:00007987 _text$mn        ends
.text$mn:00007987
.text$mn:00007988 ; ===========================================================================
.text$mn:00007988
.text$mn:00007988 ; Segment type: Pure code
.text$mn:00007988 ; Segment permissions: Read/Execute
.text$mn:00007988 _text$mn        segment para public 'CODE' use32
.text$mn:00007988                 assume cs:_text$mn
.text$mn:00007988                 ;org 7988h
.text$mn:00007988 ; COMDAT (pick any)
.text$mn:00007988                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007988
.text$mn:00007988 ; =============== S U B R O U T I N E =======================================
.text$mn:00007988
.text$mn:00007988 ; Attributes: bp-based frame
.text$mn:00007988
.text$mn:00007988 ; unsigned int * & __cdecl std::_Rechecked<unsigned int *, unsigned int *>(unsigned int * &, unsigned int *)
.text$mn:00007988                 public ??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z
.text$mn:00007988 ??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z proc near
.text$mn:00007988                                         ; CODE XREF: std::_Uninitialized_copy<uint *,uint *,std::_Wrap_alloc<std::allocator<uint>>>(uint *,uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+3Bp
.text$mn:00007988                                         ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *,std::_Wrap_alloc<std::allocator<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+B2p
.text$mn:00007988
.text$mn:00007988 arg_0           = dword ptr  8
.text$mn:00007988 arg_4           = dword ptr  0Ch
.text$mn:00007988
.text$mn:00007988                 push    ebp
.text$mn:00007989                 mov     ebp, esp
.text$mn:0000798B                 mov     eax, [ebp+arg_0]
.text$mn:0000798E                 mov     ecx, [ebp+arg_4]
.text$mn:00007991                 mov     [eax], ecx
.text$mn:00007993                 mov     eax, [ebp+arg_0]
.text$mn:00007996                 pop     ebp
.text$mn:00007997                 retn
.text$mn:00007997 ??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z endp
.text$mn:00007997
.text$mn:00007997 _text$mn        ends
.text$mn:00007997
.text$mn:00007998 ; ===========================================================================
.text$mn:00007998
.text$mn:00007998 ; Segment type: Pure code
.text$mn:00007998 ; Segment permissions: Read/Execute
.text$mn:00007998 _text$mn        segment para public 'CODE' use32
.text$mn:00007998                 assume cs:_text$mn
.text$mn:00007998                 ;org 7998h
.text$mn:00007998 ; COMDAT (pick any)
.text$mn:00007998                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007998
.text$mn:00007998 ; =============== S U B R O U T I N E =======================================
.text$mn:00007998
.text$mn:00007998 ; Attributes: bp-based frame
.text$mn:00007998
.text$mn:00007998 ; struct sessionFileInfo * & __cdecl std::_Rechecked<struct sessionFileInfo *, struct sessionFileInfo *>(struct sessionFileInfo * &, struct sessionFileInfo *)
.text$mn:00007998                 public ??$_Rechecked@PAUsessionFileInfo@@PAU1@@std@@YAAAPAUsessionFileInfo@@AAPAU1@PAU1@@Z
.text$mn:00007998 ??$_Rechecked@PAUsessionFileInfo@@PAU1@@std@@YAAAPAUsessionFileInfo@@AAPAU1@PAU1@@Z proc near
.text$mn:00007998                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)+B2p
.text$mn:00007998                                         ; std::_Uninitialized_move<sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)+3Bp
.text$mn:00007998
.text$mn:00007998 arg_0           = dword ptr  8
.text$mn:00007998 arg_4           = dword ptr  0Ch
.text$mn:00007998
.text$mn:00007998                 push    ebp
.text$mn:00007999                 mov     ebp, esp
.text$mn:0000799B                 mov     eax, [ebp+arg_0]
.text$mn:0000799E                 mov     ecx, [ebp+arg_4]
.text$mn:000079A1                 mov     [eax], ecx
.text$mn:000079A3                 mov     eax, [ebp+arg_0]
.text$mn:000079A6                 pop     ebp
.text$mn:000079A7                 retn
.text$mn:000079A7 ??$_Rechecked@PAUsessionFileInfo@@PAU1@@std@@YAAAPAUsessionFileInfo@@AAPAU1@PAU1@@Z endp
.text$mn:000079A7
.text$mn:000079A7 _text$mn        ends
.text$mn:000079A7
.text$mn:000079A8 ; ===========================================================================
.text$mn:000079A8
.text$mn:000079A8 ; Segment type: Pure code
.text$mn:000079A8 ; Segment permissions: Read/Execute
.text$mn:000079A8 _text$mn        segment para public 'CODE' use32
.text$mn:000079A8                 assume cs:_text$mn
.text$mn:000079A8                 ;org 79A8h
.text$mn:000079A8 ; COMDAT (pick any)
.text$mn:000079A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000079A8
.text$mn:000079A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000079A8
.text$mn:000079A8 ; Attributes: bp-based frame
.text$mn:000079A8
.text$mn:000079A8 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * & __cdecl std::_Rechecked<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * &, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:000079A8                 public ??$_Rechecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAV10@PAV10@@Z
.text$mn:000079A8 ??$_Rechecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAV10@PAV10@@Z proc near
.text$mn:000079A8                                         ; CODE XREF: std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+3Bp
.text$mn:000079A8
.text$mn:000079A8 arg_0           = dword ptr  8
.text$mn:000079A8 arg_4           = dword ptr  0Ch
.text$mn:000079A8
.text$mn:000079A8                 push    ebp
.text$mn:000079A9                 mov     ebp, esp
.text$mn:000079AB                 mov     eax, [ebp+arg_0]
.text$mn:000079AE                 mov     ecx, [ebp+arg_4]
.text$mn:000079B1                 mov     [eax], ecx
.text$mn:000079B3                 mov     eax, [ebp+arg_0]
.text$mn:000079B6                 pop     ebp
.text$mn:000079B7                 retn
.text$mn:000079B7 ??$_Rechecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAV10@PAV10@@Z endp
.text$mn:000079B7
.text$mn:000079B7 _text$mn        ends
.text$mn:000079B7
.text$mn:000079B8 ; ===========================================================================
.text$mn:000079B8
.text$mn:000079B8 ; Segment type: Pure code
.text$mn:000079B8 ; Segment permissions: Read/Execute
.text$mn:000079B8 _text$mn        segment para public 'CODE' use32
.text$mn:000079B8                 assume cs:_text$mn
.text$mn:000079B8                 ;org 79B8h
.text$mn:000079B8 ; COMDAT (pick any)
.text$mn:000079B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000079B8
.text$mn:000079B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000079B8
.text$mn:000079B8 ; Attributes: bp-based frame
.text$mn:000079B8
.text$mn:000079B8 ; protected: unsigned int * __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::_Ucopy<unsigned int *>(unsigned int *, unsigned int *, unsigned int *)
.text$mn:000079B8                 public ??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z
.text$mn:000079B8 ??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z proc near
.text$mn:000079B8                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+167p
.text$mn:000079B8                                         ; std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+1F7p
.text$mn:000079B8
.text$mn:000079B8 var_8           = dword ptr -8
.text$mn:000079B8 var_1           = byte ptr -1
.text$mn:000079B8 arg_0           = dword ptr  8
.text$mn:000079B8 arg_4           = dword ptr  0Ch
.text$mn:000079B8 arg_8           = dword ptr  10h
.text$mn:000079B8
.text$mn:000079B8                 push    ebp
.text$mn:000079B9                 mov     ebp, esp
.text$mn:000079BB                 sub     esp, 8
.text$mn:000079BE                 mov     [ebp+var_8], ecx
.text$mn:000079C1                 lea     eax, [ebp+var_1]
.text$mn:000079C4                 push    eax
.text$mn:000079C5                 mov     ecx, [ebp+var_8]
.text$mn:000079C8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:000079CD                 lea     ecx, [ebp+var_1]
.text$mn:000079D0                 push    ecx
.text$mn:000079D1                 mov     edx, [ebp+arg_8]
.text$mn:000079D4                 push    edx
.text$mn:000079D5                 mov     eax, [ebp+arg_4]
.text$mn:000079D8                 push    eax
.text$mn:000079D9                 mov     ecx, [ebp+arg_0]
.text$mn:000079DC                 push    ecx
.text$mn:000079DD                 call    ??$_Uninitialized_copy@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Uninitialized_copy<uint *,uint *,std::_Wrap_alloc<std::allocator<uint>>>(uint *,uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)
.text$mn:000079E2                 add     esp, 10h
.text$mn:000079E5                 mov     esp, ebp
.text$mn:000079E7                 pop     ebp
.text$mn:000079E8                 retn    0Ch
.text$mn:000079E8 ??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z endp
.text$mn:000079E8
.text$mn:000079E8 ; ---------------------------------------------------------------------------
.text$mn:000079EB                 align 4
.text$mn:000079EB _text$mn        ends
.text$mn:000079EB
.text$mn:000079EC ; ===========================================================================
.text$mn:000079EC
.text$mn:000079EC ; Segment type: Pure code
.text$mn:000079EC ; Segment permissions: Read/Execute
.text$mn:000079EC _text$mn        segment para public 'CODE' use32
.text$mn:000079EC                 assume cs:_text$mn
.text$mn:000079EC                 ;org 79ECh
.text$mn:000079EC ; COMDAT (pick any)
.text$mn:000079EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000079EC
.text$mn:000079EC ; =============== S U B R O U T I N E =======================================
.text$mn:000079EC
.text$mn:000079EC ; Attributes: bp-based frame
.text$mn:000079EC
.text$mn:000079EC ; protected: unsigned int * __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::_Ucopy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned int>>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned int>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned int>>>, unsigned int *)
.text$mn:000079EC                 public ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z
.text$mn:000079EC ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z proc near
.text$mn:000079EC                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(std::vector<uint,std::allocator<uint>> const &)+C0p
.text$mn:000079EC
.text$mn:000079EC var_34          = dword ptr -34h
.text$mn:000079EC var_30          = dword ptr -30h
.text$mn:000079EC var_2C          = dword ptr -2Ch
.text$mn:000079EC var_28          = dword ptr -28h
.text$mn:000079EC var_24          = dword ptr -24h
.text$mn:000079EC var_20          = dword ptr -20h
.text$mn:000079EC var_1C          = dword ptr -1Ch
.text$mn:000079EC var_18          = dword ptr -18h
.text$mn:000079EC var_14          = dword ptr -14h
.text$mn:000079EC var_D           = byte ptr -0Dh
.text$mn:000079EC var_C           = dword ptr -0Ch
.text$mn:000079EC var_4           = dword ptr -4
.text$mn:000079EC arg_0           = byte ptr  8
.text$mn:000079EC arg_C           = byte ptr  14h
.text$mn:000079EC arg_18          = dword ptr  20h
.text$mn:000079EC
.text$mn:000079EC                 push    ebp
.text$mn:000079ED                 mov     ebp, esp
.text$mn:000079EF                 push    0FFFFFFFFh
.text$mn:000079F1                 push    offset __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z
.text$mn:000079F6                 mov     eax, large fs:0
.text$mn:000079FC                 push    eax
.text$mn:000079FD                 sub     esp, 28h
.text$mn:00007A00                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007A05                 xor     eax, ebp
.text$mn:00007A07                 push    eax
.text$mn:00007A08                 lea     eax, [ebp+var_C]
.text$mn:00007A0B                 mov     large fs:0, eax
.text$mn:00007A11                 mov     [ebp+var_14], ecx
.text$mn:00007A14                 mov     [ebp+var_4], 1
.text$mn:00007A1B                 lea     eax, [ebp+var_D]
.text$mn:00007A1E                 push    eax
.text$mn:00007A1F                 mov     ecx, [ebp+var_14]
.text$mn:00007A22                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:00007A27                 lea     ecx, [ebp+var_D]
.text$mn:00007A2A                 push    ecx
.text$mn:00007A2B                 mov     edx, [ebp+arg_18]
.text$mn:00007A2E                 push    edx
.text$mn:00007A2F                 sub     esp, 0Ch
.text$mn:00007A32                 mov     ecx, esp
.text$mn:00007A34                 mov     [ebp+var_28], esp
.text$mn:00007A37                 lea     eax, [ebp+arg_C]
.text$mn:00007A3A                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00007A3B                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>> const &)
.text$mn:00007A40                 mov     [ebp+var_18], eax
.text$mn:00007A43                 mov     ecx, [ebp+var_18]
.text$mn:00007A46                 mov     [ebp+var_2C], ecx
.text$mn:00007A49                 mov     byte ptr [ebp+var_4], 2
.text$mn:00007A4D                 sub     esp, 0Ch
.text$mn:00007A50                 mov     ecx, esp
.text$mn:00007A52                 mov     [ebp+var_30], esp
.text$mn:00007A55                 lea     edx, [ebp+arg_0]
.text$mn:00007A58                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00007A59                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>> const &)
.text$mn:00007A5E                 mov     [ebp+var_1C], eax
.text$mn:00007A61                 mov     eax, [ebp+var_1C]
.text$mn:00007A64                 mov     [ebp+var_34], eax
.text$mn:00007A67                 mov     byte ptr [ebp+var_4], 3
.text$mn:00007A6B                 mov     byte ptr [ebp+var_4], 1
.text$mn:00007A6F                 call    ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *,std::_Wrap_alloc<std::allocator<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *,std::_Wrap_alloc<std::allocator<uint>> &)
.text$mn:00007A74                 add     esp, 20h
.text$mn:00007A77                 mov     [ebp+var_20], eax
.text$mn:00007A7A                 mov     ecx, [ebp+var_20]
.text$mn:00007A7D                 mov     [ebp+var_24], ecx
.text$mn:00007A80                 mov     byte ptr [ebp+var_4], 0
.text$mn:00007A84                 lea     ecx, [ebp+arg_0]
.text$mn:00007A87                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$mn:00007A8C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007A93                 lea     ecx, [ebp+arg_C]
.text$mn:00007A96                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$mn:00007A9B                 mov     eax, [ebp+var_24]
.text$mn:00007A9E                 mov     ecx, [ebp+var_C]
.text$mn:00007AA1                 mov     large fs:0, ecx
.text$mn:00007AA8                 pop     ecx
.text$mn:00007AA9                 mov     esp, ebp
.text$mn:00007AAB                 pop     ebp
.text$mn:00007AAC                 retn    1Ch
.text$mn:00007AAC ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z endp
.text$mn:00007AAC
.text$mn:00007AAC ; ---------------------------------------------------------------------------
.text$mn:00007AAF                 align 10h
.text$mn:00007AAF _text$mn        ends
.text$mn:00007AAF
.text$x:00007AB0 ; ===========================================================================
.text$x:00007AB0
.text$x:00007AB0 ; Segment type: Pure code
.text$x:00007AB0 ; Segment permissions: Read/Execute
.text$x:00007AB0 _text$x         segment para public 'CODE' use32
.text$x:00007AB0                 assume cs:_text$x
.text$x:00007AB0                 ;org 7AB0h
.text$x:00007AB0 ; COMDAT (pick associative to section at 79EC)
.text$x:00007AB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007AB0
.text$x:00007AB0 ; =============== S U B R O U T I N E =======================================
.text$x:00007AB0
.text$x:00007AB0
.text$x:00007AB0 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z$0 proc near
.text$x:00007AB0                                         ; DATA XREF: .xdata$x:00014290o
.text$x:00007AB0                 lea     ecx, [ebp+14h]
.text$x:00007AB3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$x:00007AB3 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z$0 endp
.text$x:00007AB3
.text$x:00007AB8
.text$x:00007AB8 ; =============== S U B R O U T I N E =======================================
.text$x:00007AB8
.text$x:00007AB8
.text$x:00007AB8 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z$1 proc near
.text$x:00007AB8                                         ; DATA XREF: .xdata$x:00014298o
.text$x:00007AB8                 lea     ecx, [ebp+8]
.text$x:00007ABB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$x:00007ABB __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z$1 endp
.text$x:00007ABB
.text$x:00007AC0
.text$x:00007AC0 ; =============== S U B R O U T I N E =======================================
.text$x:00007AC0
.text$x:00007AC0
.text$x:00007AC0 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z$2 proc near
.text$x:00007AC0                                         ; DATA XREF: .xdata$x:000142A0o
.text$x:00007AC0                 mov     ecx, [ebp-28h]
.text$x:00007AC3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$x:00007AC3 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z$2 endp
.text$x:00007AC3
.text$x:00007AC8
.text$x:00007AC8 ; =============== S U B R O U T I N E =======================================
.text$x:00007AC8
.text$x:00007AC8
.text$x:00007AC8 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z$3 proc near
.text$x:00007AC8                                         ; DATA XREF: .xdata$x:000142A8o
.text$x:00007AC8                 mov     ecx, [ebp-30h]
.text$x:00007ACB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$x:00007ACB __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z$3 endp
.text$x:00007ACB
.text$x:00007AD0
.text$x:00007AD0 ; =============== S U B R O U T I N E =======================================
.text$x:00007AD0
.text$x:00007AD0
.text$x:00007AD0 __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z proc near
.text$x:00007AD0                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *)+5o
.text$x:00007AD0
.text$x:00007AD0 arg_4           = dword ptr  8
.text$x:00007AD0
.text$x:00007AD0                 mov     edx, [esp+arg_4]
.text$x:00007AD4                 lea     eax, [edx+0Ch]
.text$x:00007AD7                 mov     ecx, [edx-2Ch]
.text$x:00007ADA                 xor     ecx, eax
.text$x:00007ADC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007AE1                 mov     eax, offset __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z
.text$x:00007AE6                 jmp     ___CxxFrameHandler3
.text$x:00007AE6 __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z endp
.text$x:00007AE6
.text$x:00007AE6 ; ---------------------------------------------------------------------------
.text$x:00007AEB                 align 4
.text$x:00007AEB _text$x         ends
.text$x:00007AEB
.text$mn:00007AEC ; ===========================================================================
.text$mn:00007AEC
.text$mn:00007AEC ; Segment type: Pure code
.text$mn:00007AEC ; Segment permissions: Read/Execute
.text$mn:00007AEC _text$mn        segment para public 'CODE' use32
.text$mn:00007AEC                 assume cs:_text$mn
.text$mn:00007AEC                 ;org 7AECh
.text$mn:00007AEC ; COMDAT (pick any)
.text$mn:00007AEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007AEC
.text$mn:00007AEC ; =============== S U B R O U T I N E =======================================
.text$mn:00007AEC
.text$mn:00007AEC ; Attributes: bp-based frame
.text$mn:00007AEC
.text$mn:00007AEC ; protected: struct sessionFileInfo * __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::_Ucopy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>, struct sessionFileInfo *)
.text$mn:00007AEC                 public ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z
.text$mn:00007AEC ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z proc near
.text$mn:00007AEC                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(std::vector<sessionFileInfo,std::allocator<sessionFileInfo>> const &)+C0p
.text$mn:00007AEC
.text$mn:00007AEC var_34          = dword ptr -34h
.text$mn:00007AEC var_30          = dword ptr -30h
.text$mn:00007AEC var_2C          = dword ptr -2Ch
.text$mn:00007AEC var_28          = dword ptr -28h
.text$mn:00007AEC var_24          = dword ptr -24h
.text$mn:00007AEC var_20          = dword ptr -20h
.text$mn:00007AEC var_1C          = dword ptr -1Ch
.text$mn:00007AEC var_18          = dword ptr -18h
.text$mn:00007AEC var_14          = dword ptr -14h
.text$mn:00007AEC var_D           = byte ptr -0Dh
.text$mn:00007AEC var_C           = dword ptr -0Ch
.text$mn:00007AEC var_4           = dword ptr -4
.text$mn:00007AEC arg_0           = byte ptr  8
.text$mn:00007AEC arg_C           = byte ptr  14h
.text$mn:00007AEC arg_18          = dword ptr  20h
.text$mn:00007AEC
.text$mn:00007AEC                 push    ebp
.text$mn:00007AED                 mov     ebp, esp
.text$mn:00007AEF                 push    0FFFFFFFFh
.text$mn:00007AF1                 push    offset __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z
.text$mn:00007AF6                 mov     eax, large fs:0
.text$mn:00007AFC                 push    eax
.text$mn:00007AFD                 sub     esp, 28h
.text$mn:00007B00                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007B05                 xor     eax, ebp
.text$mn:00007B07                 push    eax
.text$mn:00007B08                 lea     eax, [ebp+var_C]
.text$mn:00007B0B                 mov     large fs:0, eax
.text$mn:00007B11                 mov     [ebp+var_14], ecx
.text$mn:00007B14                 mov     [ebp+var_4], 1
.text$mn:00007B1B                 lea     eax, [ebp+var_D]
.text$mn:00007B1E                 push    eax
.text$mn:00007B1F                 mov     ecx, [ebp+var_14]
.text$mn:00007B22                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Getal(void)
.text$mn:00007B27                 lea     ecx, [ebp+var_D]
.text$mn:00007B2A                 push    ecx
.text$mn:00007B2B                 mov     edx, [ebp+arg_18]
.text$mn:00007B2E                 push    edx
.text$mn:00007B2F                 sub     esp, 0Ch
.text$mn:00007B32                 mov     ecx, esp
.text$mn:00007B34                 mov     [ebp+var_28], esp
.text$mn:00007B37                 lea     eax, [ebp+arg_C]
.text$mn:00007B3A                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00007B3B                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>> const &)
.text$mn:00007B40                 mov     [ebp+var_18], eax
.text$mn:00007B43                 mov     ecx, [ebp+var_18]
.text$mn:00007B46                 mov     [ebp+var_2C], ecx
.text$mn:00007B49                 mov     byte ptr [ebp+var_4], 2
.text$mn:00007B4D                 sub     esp, 0Ch
.text$mn:00007B50                 mov     ecx, esp
.text$mn:00007B52                 mov     [ebp+var_30], esp
.text$mn:00007B55                 lea     edx, [ebp+arg_0]
.text$mn:00007B58                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00007B59                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>> const &)
.text$mn:00007B5E                 mov     [ebp+var_1C], eax
.text$mn:00007B61                 mov     eax, [ebp+var_1C]
.text$mn:00007B64                 mov     [ebp+var_34], eax
.text$mn:00007B67                 mov     byte ptr [ebp+var_4], 3
.text$mn:00007B6B                 mov     byte ptr [ebp+var_4], 1
.text$mn:00007B6F                 call    ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)
.text$mn:00007B74                 add     esp, 20h
.text$mn:00007B77                 mov     [ebp+var_20], eax
.text$mn:00007B7A                 mov     ecx, [ebp+var_20]
.text$mn:00007B7D                 mov     [ebp+var_24], ecx
.text$mn:00007B80                 mov     byte ptr [ebp+var_4], 0
.text$mn:00007B84                 lea     ecx, [ebp+arg_0]
.text$mn:00007B87                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:00007B8C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007B93                 lea     ecx, [ebp+arg_C]
.text$mn:00007B96                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:00007B9B                 mov     eax, [ebp+var_24]
.text$mn:00007B9E                 mov     ecx, [ebp+var_C]
.text$mn:00007BA1                 mov     large fs:0, ecx
.text$mn:00007BA8                 pop     ecx
.text$mn:00007BA9                 mov     esp, ebp
.text$mn:00007BAB                 pop     ebp
.text$mn:00007BAC                 retn    1Ch
.text$mn:00007BAC ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z endp
.text$mn:00007BAC
.text$mn:00007BAC ; ---------------------------------------------------------------------------
.text$mn:00007BAF                 align 10h
.text$mn:00007BAF _text$mn        ends
.text$mn:00007BAF
.text$x:00007BB0 ; ===========================================================================
.text$x:00007BB0
.text$x:00007BB0 ; Segment type: Pure code
.text$x:00007BB0 ; Segment permissions: Read/Execute
.text$x:00007BB0 _text$x         segment para public 'CODE' use32
.text$x:00007BB0                 assume cs:_text$x
.text$x:00007BB0                 ;org 7BB0h
.text$x:00007BB0 ; COMDAT (pick associative to section at 7AEC)
.text$x:00007BB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007BB0
.text$x:00007BB0 ; =============== S U B R O U T I N E =======================================
.text$x:00007BB0
.text$x:00007BB0
.text$x:00007BB0 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z$0 proc near
.text$x:00007BB0                                         ; DATA XREF: .xdata$x:00013EC4o
.text$x:00007BB0                 lea     ecx, [ebp+14h]
.text$x:00007BB3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00007BB3 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z$0 endp
.text$x:00007BB3
.text$x:00007BB8
.text$x:00007BB8 ; =============== S U B R O U T I N E =======================================
.text$x:00007BB8
.text$x:00007BB8
.text$x:00007BB8 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z$1 proc near
.text$x:00007BB8                                         ; DATA XREF: .xdata$x:00013ECCo
.text$x:00007BB8                 lea     ecx, [ebp+8]
.text$x:00007BBB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00007BBB __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z$1 endp
.text$x:00007BBB
.text$x:00007BC0
.text$x:00007BC0 ; =============== S U B R O U T I N E =======================================
.text$x:00007BC0
.text$x:00007BC0
.text$x:00007BC0 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z$2 proc near
.text$x:00007BC0                                         ; DATA XREF: .xdata$x:00013ED4o
.text$x:00007BC0                 mov     ecx, [ebp-28h]
.text$x:00007BC3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00007BC3 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z$2 endp
.text$x:00007BC3
.text$x:00007BC8
.text$x:00007BC8 ; =============== S U B R O U T I N E =======================================
.text$x:00007BC8
.text$x:00007BC8
.text$x:00007BC8 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z$3 proc near
.text$x:00007BC8                                         ; DATA XREF: .xdata$x:00013EDCo
.text$x:00007BC8                 mov     ecx, [ebp-30h]
.text$x:00007BCB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00007BCB __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z$3 endp
.text$x:00007BCB
.text$x:00007BD0
.text$x:00007BD0 ; =============== S U B R O U T I N E =======================================
.text$x:00007BD0
.text$x:00007BD0
.text$x:00007BD0 __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z proc near
.text$x:00007BD0                                         ; DATA XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *)+5o
.text$x:00007BD0
.text$x:00007BD0 arg_4           = dword ptr  8
.text$x:00007BD0
.text$x:00007BD0                 mov     edx, [esp+arg_4]
.text$x:00007BD4                 lea     eax, [edx+0Ch]
.text$x:00007BD7                 mov     ecx, [edx-2Ch]
.text$x:00007BDA                 xor     ecx, eax
.text$x:00007BDC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007BE1                 mov     eax, offset __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z
.text$x:00007BE6                 jmp     ___CxxFrameHandler3
.text$x:00007BE6 __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z endp
.text$x:00007BE6
.text$x:00007BE6 ; ---------------------------------------------------------------------------
.text$x:00007BEB                 align 4
.text$x:00007BEB _text$x         ends
.text$x:00007BEB
.text$mn:00007BEC ; ===========================================================================
.text$mn:00007BEC
.text$mn:00007BEC ; Segment type: Pure code
.text$mn:00007BEC ; Segment permissions: Read/Execute
.text$mn:00007BEC _text$mn        segment para public 'CODE' use32
.text$mn:00007BEC                 assume cs:_text$mn
.text$mn:00007BEC                 ;org 7BECh
.text$mn:00007BEC ; COMDAT (pick any)
.text$mn:00007BEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007BEC
.text$mn:00007BEC ; =============== S U B R O U T I N E =======================================
.text$mn:00007BEC
.text$mn:00007BEC ; Attributes: bp-based frame
.text$mn:00007BEC
.text$mn:00007BEC ; protected: int * __thiscall std::vector<int, class std::allocator<int>>::_Umove<int *>(int *, int *, int *)
.text$mn:00007BEC                 public ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
.text$mn:00007BEC ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z proc near
.text$mn:00007BEC                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+65p
.text$mn:00007BEC
.text$mn:00007BEC var_8           = dword ptr -8
.text$mn:00007BEC var_1           = byte ptr -1
.text$mn:00007BEC arg_0           = dword ptr  8
.text$mn:00007BEC arg_4           = dword ptr  0Ch
.text$mn:00007BEC arg_8           = dword ptr  10h
.text$mn:00007BEC
.text$mn:00007BEC                 push    ebp
.text$mn:00007BED                 mov     ebp, esp
.text$mn:00007BEF                 sub     esp, 8
.text$mn:00007BF2                 mov     [ebp+var_8], ecx
.text$mn:00007BF5                 lea     eax, [ebp+var_1]
.text$mn:00007BF8                 push    eax
.text$mn:00007BF9                 mov     ecx, [ebp+var_8]
.text$mn:00007BFC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00007C01                 lea     ecx, [ebp+var_1]
.text$mn:00007C04                 push    ecx
.text$mn:00007C05                 mov     edx, [ebp+arg_8]
.text$mn:00007C08                 push    edx
.text$mn:00007C09                 mov     eax, [ebp+arg_4]
.text$mn:00007C0C                 push    eax
.text$mn:00007C0D                 mov     ecx, [ebp+arg_0]
.text$mn:00007C10                 push    ecx
.text$mn:00007C11                 call    ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)
.text$mn:00007C16                 add     esp, 10h
.text$mn:00007C19                 mov     esp, ebp
.text$mn:00007C1B                 pop     ebp
.text$mn:00007C1C                 retn    0Ch
.text$mn:00007C1C ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z endp
.text$mn:00007C1C
.text$mn:00007C1C ; ---------------------------------------------------------------------------
.text$mn:00007C1F                 align 10h
.text$mn:00007C1F _text$mn        ends
.text$mn:00007C1F
.text$mn:00007C20 ; ===========================================================================
.text$mn:00007C20
.text$mn:00007C20 ; Segment type: Pure code
.text$mn:00007C20 ; Segment permissions: Read/Execute
.text$mn:00007C20 _text$mn        segment para public 'CODE' use32
.text$mn:00007C20                 assume cs:_text$mn
.text$mn:00007C20                 ;org 7C20h
.text$mn:00007C20 ; COMDAT (pick any)
.text$mn:00007C20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C20
.text$mn:00007C20 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C20
.text$mn:00007C20 ; Attributes: bp-based frame
.text$mn:00007C20
.text$mn:00007C20 ; protected: struct sessionFileInfo * __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::_Umove<struct sessionFileInfo *>(struct sessionFileInfo *, struct sessionFileInfo *, struct sessionFileInfo *)
.text$mn:00007C20                 public ??$_Umove@PAUsessionFileInfo@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@PAU2@00@Z
.text$mn:00007C20 ??$_Umove@PAUsessionFileInfo@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@PAU2@00@Z proc near
.text$mn:00007C20                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reallocate(uint)+65p
.text$mn:00007C20
.text$mn:00007C20 var_8           = dword ptr -8
.text$mn:00007C20 var_1           = byte ptr -1
.text$mn:00007C20 arg_0           = dword ptr  8
.text$mn:00007C20 arg_4           = dword ptr  0Ch
.text$mn:00007C20 arg_8           = dword ptr  10h
.text$mn:00007C20
.text$mn:00007C20                 push    ebp
.text$mn:00007C21                 mov     ebp, esp
.text$mn:00007C23                 sub     esp, 8
.text$mn:00007C26                 mov     [ebp+var_8], ecx
.text$mn:00007C29                 lea     eax, [ebp+var_1]
.text$mn:00007C2C                 push    eax
.text$mn:00007C2D                 mov     ecx, [ebp+var_8]
.text$mn:00007C30                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Getal(void)
.text$mn:00007C35                 lea     ecx, [ebp+var_1]
.text$mn:00007C38                 push    ecx
.text$mn:00007C39                 mov     edx, [ebp+arg_8]
.text$mn:00007C3C                 push    edx
.text$mn:00007C3D                 mov     eax, [ebp+arg_4]
.text$mn:00007C40                 push    eax
.text$mn:00007C41                 mov     ecx, [ebp+arg_0]
.text$mn:00007C44                 push    ecx
.text$mn:00007C45                 call    ??$_Uninitialized_move@PAUsessionFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z ; std::_Uninitialized_move<sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)
.text$mn:00007C4A                 add     esp, 10h
.text$mn:00007C4D                 mov     esp, ebp
.text$mn:00007C4F                 pop     ebp
.text$mn:00007C50                 retn    0Ch
.text$mn:00007C50 ??$_Umove@PAUsessionFileInfo@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@PAU2@00@Z endp
.text$mn:00007C50
.text$mn:00007C50 ; ---------------------------------------------------------------------------
.text$mn:00007C53                 align 4
.text$mn:00007C53 _text$mn        ends
.text$mn:00007C53
.text$mn:00007C54 ; ===========================================================================
.text$mn:00007C54
.text$mn:00007C54 ; Segment type: Pure code
.text$mn:00007C54 ; Segment permissions: Read/Execute
.text$mn:00007C54 _text$mn        segment para public 'CODE' use32
.text$mn:00007C54                 assume cs:_text$mn
.text$mn:00007C54                 ;org 7C54h
.text$mn:00007C54 ; COMDAT (pick any)
.text$mn:00007C54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C54
.text$mn:00007C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C54
.text$mn:00007C54 ; Attributes: bp-based frame
.text$mn:00007C54
.text$mn:00007C54 ; protected: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Umove<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00007C54                 public ??$_Umove@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PAV21@00@Z
.text$mn:00007C54 ??$_Umove@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PAV21@00@Z proc near
.text$mn:00007C54                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+65p
.text$mn:00007C54
.text$mn:00007C54 var_8           = dword ptr -8
.text$mn:00007C54 var_1           = byte ptr -1
.text$mn:00007C54 arg_0           = dword ptr  8
.text$mn:00007C54 arg_4           = dword ptr  0Ch
.text$mn:00007C54 arg_8           = dword ptr  10h
.text$mn:00007C54
.text$mn:00007C54                 push    ebp
.text$mn:00007C55                 mov     ebp, esp
.text$mn:00007C57                 sub     esp, 8
.text$mn:00007C5A                 mov     [ebp+var_8], ecx
.text$mn:00007C5D                 lea     eax, [ebp+var_1]
.text$mn:00007C60                 push    eax
.text$mn:00007C61                 mov     ecx, [ebp+var_8]
.text$mn:00007C64                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:00007C69                 lea     ecx, [ebp+var_1]
.text$mn:00007C6C                 push    ecx
.text$mn:00007C6D                 mov     edx, [ebp+arg_8]
.text$mn:00007C70                 push    edx
.text$mn:00007C71                 mov     eax, [ebp+arg_4]
.text$mn:00007C74                 push    eax
.text$mn:00007C75                 mov     ecx, [ebp+arg_0]
.text$mn:00007C78                 push    ecx
.text$mn:00007C79                 call    ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)
.text$mn:00007C7E                 add     esp, 10h
.text$mn:00007C81                 mov     esp, ebp
.text$mn:00007C83                 pop     ebp
.text$mn:00007C84                 retn    0Ch
.text$mn:00007C84 ??$_Umove@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PAV21@00@Z endp
.text$mn:00007C84
.text$mn:00007C84 ; ---------------------------------------------------------------------------
.text$mn:00007C87                 align 4
.text$mn:00007C87 _text$mn        ends
.text$mn:00007C87
.text$mn:00007C88 ; ===========================================================================
.text$mn:00007C88
.text$mn:00007C88 ; Segment type: Pure code
.text$mn:00007C88 ; Segment permissions: Read/Execute
.text$mn:00007C88 _text$mn        segment para public 'CODE' use32
.text$mn:00007C88                 assume cs:_text$mn
.text$mn:00007C88                 ;org 7C88h
.text$mn:00007C88 ; COMDAT (pick any)
.text$mn:00007C88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C88
.text$mn:00007C88 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C88
.text$mn:00007C88 ; Attributes: bp-based frame
.text$mn:00007C88
.text$mn:00007C88 ; int * __cdecl std::_Unchecked<int *>(int *)
.text$mn:00007C88                 public ??$_Unchecked@PAH@std@@YAPAHPAH@Z
.text$mn:00007C88 ??$_Unchecked@PAH@std@@YAPAHPAH@Z proc near
.text$mn:00007C88                                         ; CODE XREF: std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+Bp
.text$mn:00007C88                                         ; std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+18p ...
.text$mn:00007C88
.text$mn:00007C88 arg_0           = dword ptr  8
.text$mn:00007C88
.text$mn:00007C88                 push    ebp
.text$mn:00007C89                 mov     ebp, esp
.text$mn:00007C8B                 mov     eax, [ebp+arg_0]
.text$mn:00007C8E                 pop     ebp
.text$mn:00007C8F                 retn
.text$mn:00007C8F ??$_Unchecked@PAH@std@@YAPAHPAH@Z endp
.text$mn:00007C8F
.text$mn:00007C8F _text$mn        ends
.text$mn:00007C8F
.text$mn:00007C90 ; ===========================================================================
.text$mn:00007C90
.text$mn:00007C90 ; Segment type: Pure code
.text$mn:00007C90 ; Segment permissions: Read/Execute
.text$mn:00007C90 _text$mn        segment para public 'CODE' use32
.text$mn:00007C90                 assume cs:_text$mn
.text$mn:00007C90                 ;org 7C90h
.text$mn:00007C90 ; COMDAT (pick any)
.text$mn:00007C90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C90
.text$mn:00007C90 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C90
.text$mn:00007C90 ; Attributes: bp-based frame
.text$mn:00007C90
.text$mn:00007C90 ; unsigned int * __cdecl std::_Unchecked<unsigned int *>(unsigned int *)
.text$mn:00007C90                 public ??$_Unchecked@PAI@std@@YAPAIPAI@Z
.text$mn:00007C90 ??$_Unchecked@PAI@std@@YAPAIPAI@Z proc near
.text$mn:00007C90                                         ; CODE XREF: std::_Uninitialized_copy<uint *,uint *,std::_Wrap_alloc<std::allocator<uint>>>(uint *,uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+Bp
.text$mn:00007C90                                         ; std::_Uninitialized_copy<uint *,uint *,std::_Wrap_alloc<std::allocator<uint>>>(uint *,uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+18p ...
.text$mn:00007C90
.text$mn:00007C90 arg_0           = dword ptr  8
.text$mn:00007C90
.text$mn:00007C90                 push    ebp
.text$mn:00007C91                 mov     ebp, esp
.text$mn:00007C93                 mov     eax, [ebp+arg_0]
.text$mn:00007C96                 pop     ebp
.text$mn:00007C97                 retn
.text$mn:00007C97 ??$_Unchecked@PAI@std@@YAPAIPAI@Z endp
.text$mn:00007C97
.text$mn:00007C97 _text$mn        ends
.text$mn:00007C97
.text$mn:00007C98 ; ===========================================================================
.text$mn:00007C98
.text$mn:00007C98 ; Segment type: Pure code
.text$mn:00007C98 ; Segment permissions: Read/Execute
.text$mn:00007C98 _text$mn        segment para public 'CODE' use32
.text$mn:00007C98                 assume cs:_text$mn
.text$mn:00007C98                 ;org 7C98h
.text$mn:00007C98 ; COMDAT (pick any)
.text$mn:00007C98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C98
.text$mn:00007C98 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C98
.text$mn:00007C98 ; Attributes: bp-based frame
.text$mn:00007C98
.text$mn:00007C98 ; struct sessionFileInfo * __cdecl std::_Unchecked<struct sessionFileInfo *>(struct sessionFileInfo *)
.text$mn:00007C98                 public ??$_Unchecked@PAUsessionFileInfo@@@std@@YAPAUsessionFileInfo@@PAU1@@Z
.text$mn:00007C98 ??$_Unchecked@PAUsessionFileInfo@@@std@@YAPAUsessionFileInfo@@PAU1@@Z proc near
.text$mn:00007C98                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)+34p
.text$mn:00007C98                                         ; std::_Uninitialized_move<sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)+Bp ...
.text$mn:00007C98
.text$mn:00007C98 arg_0           = dword ptr  8
.text$mn:00007C98
.text$mn:00007C98                 push    ebp
.text$mn:00007C99                 mov     ebp, esp
.text$mn:00007C9B                 mov     eax, [ebp+arg_0]
.text$mn:00007C9E                 pop     ebp
.text$mn:00007C9F                 retn
.text$mn:00007C9F ??$_Unchecked@PAUsessionFileInfo@@@std@@YAPAUsessionFileInfo@@PAU1@@Z endp
.text$mn:00007C9F
.text$mn:00007C9F _text$mn        ends
.text$mn:00007C9F
.text$mn:00007CA0 ; ===========================================================================
.text$mn:00007CA0
.text$mn:00007CA0 ; Segment type: Pure code
.text$mn:00007CA0 ; Segment permissions: Read/Execute
.text$mn:00007CA0 _text$mn        segment para public 'CODE' use32
.text$mn:00007CA0                 assume cs:_text$mn
.text$mn:00007CA0                 ;org 7CA0h
.text$mn:00007CA0 ; COMDAT (pick any)
.text$mn:00007CA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007CA0
.text$mn:00007CA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CA0
.text$mn:00007CA0 ; Attributes: bp-based frame
.text$mn:00007CA0
.text$mn:00007CA0 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __cdecl std::_Unchecked<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00007CA0                 public ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z
.text$mn:00007CA0 ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z proc near
.text$mn:00007CA0                                         ; CODE XREF: std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+Bp
.text$mn:00007CA0                                         ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+18p ...
.text$mn:00007CA0
.text$mn:00007CA0 arg_0           = dword ptr  8
.text$mn:00007CA0
.text$mn:00007CA0                 push    ebp
.text$mn:00007CA1                 mov     ebp, esp
.text$mn:00007CA3                 mov     eax, [ebp+arg_0]
.text$mn:00007CA6                 pop     ebp
.text$mn:00007CA7                 retn
.text$mn:00007CA7 ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z endp
.text$mn:00007CA7
.text$mn:00007CA7 _text$mn        ends
.text$mn:00007CA7
.text$mn:00007CA8 ; ===========================================================================
.text$mn:00007CA8
.text$mn:00007CA8 ; Segment type: Pure code
.text$mn:00007CA8 ; Segment permissions: Read/Execute
.text$mn:00007CA8 _text$mn        segment para public 'CODE' use32
.text$mn:00007CA8                 assume cs:_text$mn
.text$mn:00007CA8                 ;org 7CA8h
.text$mn:00007CA8 ; COMDAT (pick any)
.text$mn:00007CA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007CA8
.text$mn:00007CA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CA8
.text$mn:00007CA8 ; Attributes: bp-based frame
.text$mn:00007CA8
.text$mn:00007CA8 ; unsigned int const * __cdecl std::_Unchecked<class std::_Vector_val<struct std::_Simple_types<unsigned int>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned int>>>)
.text$mn:00007CA8                 public ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z
.text$mn:00007CA8 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z proc near
.text$mn:00007CA8                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *,std::_Wrap_alloc<std::allocator<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+5Fp
.text$mn:00007CA8                                         ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *,std::_Wrap_alloc<std::allocator<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+90p
.text$mn:00007CA8
.text$mn:00007CA8 var_10          = dword ptr -10h
.text$mn:00007CA8 var_C           = dword ptr -0Ch
.text$mn:00007CA8 var_4           = dword ptr -4
.text$mn:00007CA8 arg_0           = byte ptr  8
.text$mn:00007CA8
.text$mn:00007CA8                 push    ebp
.text$mn:00007CA9                 mov     ebp, esp
.text$mn:00007CAB                 push    0FFFFFFFFh
.text$mn:00007CAD                 push    offset __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z
.text$mn:00007CB2                 mov     eax, large fs:0
.text$mn:00007CB8                 push    eax
.text$mn:00007CB9                 push    ecx
.text$mn:00007CBA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007CBF                 xor     eax, ebp
.text$mn:00007CC1                 push    eax
.text$mn:00007CC2                 lea     eax, [ebp+var_C]
.text$mn:00007CC5                 mov     large fs:0, eax
.text$mn:00007CCB                 mov     [ebp+var_4], 0
.text$mn:00007CD2                 lea     ecx, [ebp+arg_0]
.text$mn:00007CD5                 call    ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEPBIXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::_Unchecked(void)
.text$mn:00007CDA                 mov     [ebp+var_10], eax
.text$mn:00007CDD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007CE4                 lea     ecx, [ebp+arg_0]
.text$mn:00007CE7                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$mn:00007CEC                 mov     eax, [ebp+var_10]
.text$mn:00007CEF                 mov     ecx, [ebp+var_C]
.text$mn:00007CF2                 mov     large fs:0, ecx
.text$mn:00007CF9                 pop     ecx
.text$mn:00007CFA                 mov     esp, ebp
.text$mn:00007CFC                 pop     ebp
.text$mn:00007CFD                 retn
.text$mn:00007CFD ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z endp
.text$mn:00007CFD
.text$mn:00007CFD ; ---------------------------------------------------------------------------
.text$mn:00007CFE                 align 10h
.text$mn:00007CFE _text$mn        ends
.text$mn:00007CFE
.text$x:00007D00 ; ===========================================================================
.text$x:00007D00
.text$x:00007D00 ; Segment type: Pure code
.text$x:00007D00 ; Segment permissions: Read/Execute
.text$x:00007D00 _text$x         segment para public 'CODE' use32
.text$x:00007D00                 assume cs:_text$x
.text$x:00007D00                 ;org 7D00h
.text$x:00007D00 ; COMDAT (pick associative to section at 7CA8)
.text$x:00007D00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007D00
.text$x:00007D00 ; =============== S U B R O U T I N E =======================================
.text$x:00007D00
.text$x:00007D00
.text$x:00007D00 __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z$0 proc near
.text$x:00007D00                                         ; DATA XREF: .xdata$x:00014318o
.text$x:00007D00                 lea     ecx, [ebp+8]
.text$x:00007D03                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$x:00007D03 __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z$0 endp
.text$x:00007D03
.text$x:00007D08
.text$x:00007D08 ; =============== S U B R O U T I N E =======================================
.text$x:00007D08
.text$x:00007D08
.text$x:00007D08 __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z proc near
.text$x:00007D08                                         ; DATA XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>)+5o
.text$x:00007D08
.text$x:00007D08 arg_4           = dword ptr  8
.text$x:00007D08
.text$x:00007D08                 mov     edx, [esp+arg_4]
.text$x:00007D0C                 lea     eax, [edx+0Ch]
.text$x:00007D0F                 mov     ecx, [edx-8]
.text$x:00007D12                 xor     ecx, eax
.text$x:00007D14                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007D19                 mov     eax, offset __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z
.text$x:00007D1E                 jmp     ___CxxFrameHandler3
.text$x:00007D1E __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z endp
.text$x:00007D1E
.text$x:00007D1E ; ---------------------------------------------------------------------------
.text$x:00007D23                 align 4
.text$x:00007D23 _text$x         ends
.text$x:00007D23
.text$mn:00007D24 ; ===========================================================================
.text$mn:00007D24
.text$mn:00007D24 ; Segment type: Pure code
.text$mn:00007D24 ; Segment permissions: Read/Execute
.text$mn:00007D24 _text$mn        segment para public 'CODE' use32
.text$mn:00007D24                 assume cs:_text$mn
.text$mn:00007D24                 ;org 7D24h
.text$mn:00007D24 ; COMDAT (pick any)
.text$mn:00007D24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D24
.text$mn:00007D24 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D24
.text$mn:00007D24 ; Attributes: bp-based frame
.text$mn:00007D24
.text$mn:00007D24 ; struct sessionFileInfo const * __cdecl std::_Unchecked<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>)
.text$mn:00007D24                 public ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z
.text$mn:00007D24 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z proc near
.text$mn:00007D24                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)+5Fp
.text$mn:00007D24                                         ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)+90p
.text$mn:00007D24
.text$mn:00007D24 var_10          = dword ptr -10h
.text$mn:00007D24 var_C           = dword ptr -0Ch
.text$mn:00007D24 var_4           = dword ptr -4
.text$mn:00007D24 arg_0           = byte ptr  8
.text$mn:00007D24
.text$mn:00007D24                 push    ebp
.text$mn:00007D25                 mov     ebp, esp
.text$mn:00007D27                 push    0FFFFFFFFh
.text$mn:00007D29                 push    offset __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z
.text$mn:00007D2E                 mov     eax, large fs:0
.text$mn:00007D34                 push    eax
.text$mn:00007D35                 push    ecx
.text$mn:00007D36                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007D3B                 xor     eax, ebp
.text$mn:00007D3D                 push    eax
.text$mn:00007D3E                 lea     eax, [ebp+var_C]
.text$mn:00007D41                 mov     large fs:0, eax
.text$mn:00007D47                 mov     [ebp+var_4], 0
.text$mn:00007D4E                 lea     ecx, [ebp+arg_0]
.text$mn:00007D51                 call    ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBEPBUsessionFileInfo@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Unchecked(void)
.text$mn:00007D56                 mov     [ebp+var_10], eax
.text$mn:00007D59                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007D60                 lea     ecx, [ebp+arg_0]
.text$mn:00007D63                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:00007D68                 mov     eax, [ebp+var_10]
.text$mn:00007D6B                 mov     ecx, [ebp+var_C]
.text$mn:00007D6E                 mov     large fs:0, ecx
.text$mn:00007D75                 pop     ecx
.text$mn:00007D76                 mov     esp, ebp
.text$mn:00007D78                 pop     ebp
.text$mn:00007D79                 retn
.text$mn:00007D79 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z endp
.text$mn:00007D79
.text$mn:00007D79 ; ---------------------------------------------------------------------------
.text$mn:00007D7A                 align 4
.text$mn:00007D7A _text$mn        ends
.text$mn:00007D7A
.text$x:00007D7C ; ===========================================================================
.text$x:00007D7C
.text$x:00007D7C ; Segment type: Pure code
.text$x:00007D7C ; Segment permissions: Read/Execute
.text$x:00007D7C _text$x         segment para public 'CODE' use32
.text$x:00007D7C                 assume cs:_text$x
.text$x:00007D7C                 ;org 7D7Ch
.text$x:00007D7C ; COMDAT (pick associative to section at 7D24)
.text$x:00007D7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007D7C
.text$x:00007D7C ; =============== S U B R O U T I N E =======================================
.text$x:00007D7C
.text$x:00007D7C
.text$x:00007D7C __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z$0 proc near
.text$x:00007D7C                                         ; DATA XREF: .xdata$x:00013FA4o
.text$x:00007D7C                 lea     ecx, [ebp+8]
.text$x:00007D7F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00007D7F __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z$0 endp
.text$x:00007D7F
.text$x:00007D84
.text$x:00007D84 ; =============== S U B R O U T I N E =======================================
.text$x:00007D84
.text$x:00007D84
.text$x:00007D84 __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z proc near
.text$x:00007D84                                         ; DATA XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)+5o
.text$x:00007D84
.text$x:00007D84 arg_4           = dword ptr  8
.text$x:00007D84
.text$x:00007D84                 mov     edx, [esp+arg_4]
.text$x:00007D88                 lea     eax, [edx+0Ch]
.text$x:00007D8B                 mov     ecx, [edx-8]
.text$x:00007D8E                 xor     ecx, eax
.text$x:00007D90                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007D95                 mov     eax, offset __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z
.text$x:00007D9A                 jmp     ___CxxFrameHandler3
.text$x:00007D9A __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z endp
.text$x:00007D9A
.text$x:00007D9A ; ---------------------------------------------------------------------------
.text$x:00007D9F                 align 10h
.text$x:00007D9F _text$x         ends
.text$x:00007D9F
.text$mn:00007DA0 ; ===========================================================================
.text$mn:00007DA0
.text$mn:00007DA0 ; Segment type: Pure code
.text$mn:00007DA0 ; Segment permissions: Read/Execute
.text$mn:00007DA0 _text$mn        segment para public 'CODE' use32
.text$mn:00007DA0                 assume cs:_text$mn
.text$mn:00007DA0                 ;org 7DA0h
.text$mn:00007DA0 ; COMDAT (pick any)
.text$mn:00007DA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007DA0
.text$mn:00007DA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007DA0
.text$mn:00007DA0 ; Attributes: bp-based frame
.text$mn:00007DA0
.text$mn:00007DA0 ; int __cdecl std::_Uninit_copy<unsigned int const,unsigned int>(void *Src, int, void *Dst)
.text$mn:00007DA0                 public ??$_Uninit_copy@$$CBII@std@@YAPAIPBI0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00007DA0 ??$_Uninit_copy@$$CBII@std@@YAPAIPBI0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00007DA0                                         ; CODE XREF: std::_Uninit_copy<uint const *,uint *,std::_Wrap_alloc<std::allocator<uint>>>(uint const *,uint const *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+2Cp
.text$mn:00007DA0
.text$mn:00007DA0 var_4           = dword ptr -4
.text$mn:00007DA0 Src             = dword ptr  8
.text$mn:00007DA0 arg_4           = dword ptr  0Ch
.text$mn:00007DA0 Dst             = dword ptr  10h
.text$mn:00007DA0
.text$mn:00007DA0                 push    ebp
.text$mn:00007DA1                 mov     ebp, esp
.text$mn:00007DA3                 push    ecx
.text$mn:00007DA4                 push    192h            ; unsigned int
.text$mn:00007DA9                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007DAE                 mov     eax, [ebp+arg_4]
.text$mn:00007DB1                 push    eax             ; int
.text$mn:00007DB2                 mov     ecx, [ebp+Src]
.text$mn:00007DB5                 push    ecx             ; int
.text$mn:00007DB6                 call    ??$_Debug_range@PBI@std@@YAXPBI0PB_WI@Z ; std::_Debug_range<uint const *>(uint const *,uint const *,wchar_t const *,uint)
.text$mn:00007DBB                 add     esp, 10h
.text$mn:00007DBE                 push    193h            ; unsigned int
.text$mn:00007DC3                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007DC8                 mov     edx, [ebp+Dst]
.text$mn:00007DCB                 push    edx             ; int
.text$mn:00007DCC                 call    ??$_Debug_pointer@I@std@@YAXPAIPB_WI@Z ; std::_Debug_pointer<uint>(uint *,wchar_t const *,uint)
.text$mn:00007DD1                 add     esp, 0Ch
.text$mn:00007DD4                 mov     eax, [ebp+arg_4]
.text$mn:00007DD7                 sub     eax, [ebp+Src]
.text$mn:00007DDA                 sar     eax, 2
.text$mn:00007DDD                 mov     [ebp+var_4], eax
.text$mn:00007DE0                 mov     ecx, [ebp+var_4]
.text$mn:00007DE3                 shl     ecx, 2
.text$mn:00007DE6                 push    ecx             ; Size
.text$mn:00007DE7                 mov     edx, [ebp+Src]
.text$mn:00007DEA                 push    edx             ; Src
.text$mn:00007DEB                 mov     eax, [ebp+Dst]
.text$mn:00007DEE                 push    eax             ; Dst
.text$mn:00007DEF                 call    _memmove
.text$mn:00007DF4                 add     esp, 0Ch
.text$mn:00007DF7                 mov     ecx, [ebp+var_4]
.text$mn:00007DFA                 lea     eax, [eax+ecx*4]
.text$mn:00007DFD                 mov     esp, ebp
.text$mn:00007DFF                 pop     ebp
.text$mn:00007E00                 retn
.text$mn:00007E00 ??$_Uninit_copy@$$CBII@std@@YAPAIPBI0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00007E00
.text$mn:00007E00 ; ---------------------------------------------------------------------------
.text$mn:00007E01                 align 4
.text$mn:00007E01 _text$mn        ends
.text$mn:00007E01
.text$mn:00007E04 ; ===========================================================================
.text$mn:00007E04
.text$mn:00007E04 ; Segment type: Pure code
.text$mn:00007E04 ; Segment permissions: Read/Execute
.text$mn:00007E04 _text$mn        segment para public 'CODE' use32
.text$mn:00007E04                 assume cs:_text$mn
.text$mn:00007E04                 ;org 7E04h
.text$mn:00007E04 ; COMDAT (pick any)
.text$mn:00007E04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007E04
.text$mn:00007E04 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E04
.text$mn:00007E04 ; Attributes: bp-based frame
.text$mn:00007E04
.text$mn:00007E04 ; int __cdecl std::_Uninit_copy<unsigned int,unsigned int>(void *Src, int, void *Dst)
.text$mn:00007E04                 public ??$_Uninit_copy@II@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00007E04 ??$_Uninit_copy@II@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00007E04                                         ; CODE XREF: std::_Uninit_copy<uint *,uint *,std::_Wrap_alloc<std::allocator<uint>>>(uint *,uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+2Cp
.text$mn:00007E04
.text$mn:00007E04 var_4           = dword ptr -4
.text$mn:00007E04 Src             = dword ptr  8
.text$mn:00007E04 arg_4           = dword ptr  0Ch
.text$mn:00007E04 Dst             = dword ptr  10h
.text$mn:00007E04
.text$mn:00007E04                 push    ebp
.text$mn:00007E05                 mov     ebp, esp
.text$mn:00007E07                 push    ecx
.text$mn:00007E08                 push    192h            ; unsigned int
.text$mn:00007E0D                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007E12                 mov     eax, [ebp+arg_4]
.text$mn:00007E15                 push    eax             ; int
.text$mn:00007E16                 mov     ecx, [ebp+Src]
.text$mn:00007E19                 push    ecx             ; int
.text$mn:00007E1A                 call    ??$_Debug_range@PAI@std@@YAXPAI0PB_WI@Z ; std::_Debug_range<uint *>(uint *,uint *,wchar_t const *,uint)
.text$mn:00007E1F                 add     esp, 10h
.text$mn:00007E22                 push    193h            ; unsigned int
.text$mn:00007E27                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007E2C                 mov     edx, [ebp+Dst]
.text$mn:00007E2F                 push    edx             ; int
.text$mn:00007E30                 call    ??$_Debug_pointer@I@std@@YAXPAIPB_WI@Z ; std::_Debug_pointer<uint>(uint *,wchar_t const *,uint)
.text$mn:00007E35                 add     esp, 0Ch
.text$mn:00007E38                 mov     eax, [ebp+arg_4]
.text$mn:00007E3B                 sub     eax, [ebp+Src]
.text$mn:00007E3E                 sar     eax, 2
.text$mn:00007E41                 mov     [ebp+var_4], eax
.text$mn:00007E44                 mov     ecx, [ebp+var_4]
.text$mn:00007E47                 shl     ecx, 2
.text$mn:00007E4A                 push    ecx             ; Size
.text$mn:00007E4B                 mov     edx, [ebp+Src]
.text$mn:00007E4E                 push    edx             ; Src
.text$mn:00007E4F                 mov     eax, [ebp+Dst]
.text$mn:00007E52                 push    eax             ; Dst
.text$mn:00007E53                 call    _memmove
.text$mn:00007E58                 add     esp, 0Ch
.text$mn:00007E5B                 mov     ecx, [ebp+var_4]
.text$mn:00007E5E                 lea     eax, [eax+ecx*4]
.text$mn:00007E61                 mov     esp, ebp
.text$mn:00007E63                 pop     ebp
.text$mn:00007E64                 retn
.text$mn:00007E64 ??$_Uninit_copy@II@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00007E64
.text$mn:00007E64 ; ---------------------------------------------------------------------------
.text$mn:00007E65                 align 4
.text$mn:00007E65 _text$mn        ends
.text$mn:00007E65
.text$mn:00007E68 ; ===========================================================================
.text$mn:00007E68
.text$mn:00007E68 ; Segment type: Pure code
.text$mn:00007E68 ; Segment permissions: Read/Execute
.text$mn:00007E68 _text$mn        segment para public 'CODE' use32
.text$mn:00007E68                 assume cs:_text$mn
.text$mn:00007E68                 ;org 7E68h
.text$mn:00007E68 ; COMDAT (pick any)
.text$mn:00007E68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007E68
.text$mn:00007E68 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E68
.text$mn:00007E68 ; Attributes: bp-based frame
.text$mn:00007E68
.text$mn:00007E68 ; int __cdecl std::_Uninit_copy<unsigned int *,unsigned int *,std::_Wrap_alloc<std::allocator<unsigned int>>>(void *Src, int, void *Dst, int)
.text$mn:00007E68                 public ??$_Uninit_copy@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
.text$mn:00007E68 ??$_Uninit_copy@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z proc near
.text$mn:00007E68                                         ; CODE XREF: std::_Uninitialized_copy<uint *,uint *,std::_Wrap_alloc<std::allocator<uint>>>(uint *,uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+2Ep
.text$mn:00007E68
.text$mn:00007E68 var_1           = byte ptr -1
.text$mn:00007E68 Src             = dword ptr  8
.text$mn:00007E68 arg_4           = dword ptr  0Ch
.text$mn:00007E68 Dst             = dword ptr  10h
.text$mn:00007E68 arg_C           = dword ptr  14h
.text$mn:00007E68
.text$mn:00007E68                 push    ebp
.text$mn:00007E69                 mov     ebp, esp
.text$mn:00007E6B                 push    ecx
.text$mn:00007E6C                 mov     eax, [ebp+Dst]
.text$mn:00007E6F                 push    eax
.text$mn:00007E70                 mov     ecx, [ebp+Src]
.text$mn:00007E73                 push    ecx
.text$mn:00007E74                 call    ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAI0@Z ; std::_Ptr_cat<uint,uint>(uint *,uint *)
.text$mn:00007E79                 add     esp, 8
.text$mn:00007E7C                 mov     [ebp+var_1], al
.text$mn:00007E7F                 movzx   edx, [ebp+var_1]
.text$mn:00007E83                 push    edx
.text$mn:00007E84                 mov     eax, [ebp+arg_C]
.text$mn:00007E87                 push    eax
.text$mn:00007E88                 mov     ecx, [ebp+Dst]
.text$mn:00007E8B                 push    ecx             ; Dst
.text$mn:00007E8C                 mov     edx, [ebp+arg_4]
.text$mn:00007E8F                 push    edx             ; int
.text$mn:00007E90                 mov     eax, [ebp+Src]
.text$mn:00007E93                 push    eax             ; Src
.text$mn:00007E94                 call    ??$_Uninit_copy@II@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<uint,uint>(uint *,uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00007E99                 add     esp, 14h
.text$mn:00007E9C                 mov     esp, ebp
.text$mn:00007E9E                 pop     ebp
.text$mn:00007E9F                 retn
.text$mn:00007E9F ??$_Uninit_copy@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z endp
.text$mn:00007E9F
.text$mn:00007E9F _text$mn        ends
.text$mn:00007E9F
.text$mn:00007EA0 ; ===========================================================================
.text$mn:00007EA0
.text$mn:00007EA0 ; Segment type: Pure code
.text$mn:00007EA0 ; Segment permissions: Read/Execute
.text$mn:00007EA0 _text$mn        segment para public 'CODE' use32
.text$mn:00007EA0                 assume cs:_text$mn
.text$mn:00007EA0                 ;org 7EA0h
.text$mn:00007EA0 ; COMDAT (pick any)
.text$mn:00007EA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007EA0
.text$mn:00007EA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007EA0
.text$mn:00007EA0 ; Attributes: bp-based frame
.text$mn:00007EA0
.text$mn:00007EA0 ; int __cdecl std::_Uninit_copy<unsigned int const *,unsigned int *,std::_Wrap_alloc<std::allocator<unsigned int>>>(void *Src, int, void *Dst, int)
.text$mn:00007EA0                 public ??$_Uninit_copy@PBIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPBI0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
.text$mn:00007EA0 ??$_Uninit_copy@PBIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPBI0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z proc near
.text$mn:00007EA0                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *,std::_Wrap_alloc<std::allocator<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+9Fp
.text$mn:00007EA0
.text$mn:00007EA0 var_1           = byte ptr -1
.text$mn:00007EA0 Src             = dword ptr  8
.text$mn:00007EA0 arg_4           = dword ptr  0Ch
.text$mn:00007EA0 Dst             = dword ptr  10h
.text$mn:00007EA0 arg_C           = dword ptr  14h
.text$mn:00007EA0
.text$mn:00007EA0                 push    ebp
.text$mn:00007EA1                 mov     ebp, esp
.text$mn:00007EA3                 push    ecx
.text$mn:00007EA4                 mov     eax, [ebp+Dst]
.text$mn:00007EA7                 push    eax
.text$mn:00007EA8                 mov     ecx, [ebp+Src]
.text$mn:00007EAB                 push    ecx
.text$mn:00007EAC                 call    ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBIPAI@Z ; std::_Ptr_cat<uint,uint>(uint const *,uint *)
.text$mn:00007EB1                 add     esp, 8
.text$mn:00007EB4                 mov     [ebp+var_1], al
.text$mn:00007EB7                 movzx   edx, [ebp+var_1]
.text$mn:00007EBB                 push    edx
.text$mn:00007EBC                 mov     eax, [ebp+arg_C]
.text$mn:00007EBF                 push    eax
.text$mn:00007EC0                 mov     ecx, [ebp+Dst]
.text$mn:00007EC3                 push    ecx             ; Dst
.text$mn:00007EC4                 mov     edx, [ebp+arg_4]
.text$mn:00007EC7                 push    edx             ; int
.text$mn:00007EC8                 mov     eax, [ebp+Src]
.text$mn:00007ECB                 push    eax             ; Src
.text$mn:00007ECC                 call    ??$_Uninit_copy@$$CBII@std@@YAPAIPBI0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<uint const,uint>(uint const *,uint const *,uint *,std::_Wrap_alloc<std::allocator<uint>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00007ED1                 add     esp, 14h
.text$mn:00007ED4                 mov     esp, ebp
.text$mn:00007ED6                 pop     ebp
.text$mn:00007ED7                 retn
.text$mn:00007ED7 ??$_Uninit_copy@PBIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPBI0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z endp
.text$mn:00007ED7
.text$mn:00007ED7 _text$mn        ends
.text$mn:00007ED7
.text$mn:00007ED8 ; ===========================================================================
.text$mn:00007ED8
.text$mn:00007ED8 ; Segment type: Pure code
.text$mn:00007ED8 ; Segment permissions: Read/Execute
.text$mn:00007ED8 _text$mn        segment para public 'CODE' use32
.text$mn:00007ED8                 assume cs:_text$mn
.text$mn:00007ED8                 ;org 7ED8h
.text$mn:00007ED8 ; COMDAT (pick any)
.text$mn:00007ED8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007ED8
.text$mn:00007ED8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007ED8
.text$mn:00007ED8 ; Attributes: bp-based frame
.text$mn:00007ED8
.text$mn:00007ED8 ; int __cdecl std::_Uninit_copy<sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(int, int, void *, int)
.text$mn:00007ED8                 public ??$_Uninit_copy@PBUsessionFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z
.text$mn:00007ED8 ??$_Uninit_copy@PBUsessionFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z proc near
.text$mn:00007ED8                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)+9Fp
.text$mn:00007ED8
.text$mn:00007ED8 var_1           = byte ptr -1
.text$mn:00007ED8 arg_0           = dword ptr  8
.text$mn:00007ED8 arg_4           = dword ptr  0Ch
.text$mn:00007ED8 arg_8           = dword ptr  10h
.text$mn:00007ED8 arg_C           = dword ptr  14h
.text$mn:00007ED8
.text$mn:00007ED8                 push    ebp
.text$mn:00007ED9                 mov     ebp, esp
.text$mn:00007EDB                 push    ecx
.text$mn:00007EDC                 mov     eax, [ebp+arg_8]
.text$mn:00007EDF                 push    eax
.text$mn:00007EE0                 mov     ecx, [ebp+arg_0]
.text$mn:00007EE3                 push    ecx
.text$mn:00007EE4                 call    ??$_Ptr_cat@UsessionFileInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUsessionFileInfo@@PAU2@@Z ; std::_Ptr_cat<sessionFileInfo,sessionFileInfo>(sessionFileInfo const *,sessionFileInfo *)
.text$mn:00007EE9                 add     esp, 8
.text$mn:00007EEC                 mov     [ebp+var_1], al
.text$mn:00007EEF                 movzx   edx, [ebp+var_1]
.text$mn:00007EF3                 push    edx
.text$mn:00007EF4                 mov     eax, [ebp+arg_C]
.text$mn:00007EF7                 push    eax             ; int
.text$mn:00007EF8                 mov     ecx, [ebp+arg_8]
.text$mn:00007EFB                 push    ecx             ; void *
.text$mn:00007EFC                 mov     edx, [ebp+arg_4]
.text$mn:00007EFF                 push    edx             ; int
.text$mn:00007F00                 mov     eax, [ebp+arg_0]
.text$mn:00007F03                 push    eax             ; int
.text$mn:00007F04                 call    ??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<sessionFileInfo const *,sessionFileInfo *,std::allocator<sessionFileInfo>>(sessionFileInfo const *,sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00007F09                 add     esp, 14h
.text$mn:00007F0C                 mov     esp, ebp
.text$mn:00007F0E                 pop     ebp
.text$mn:00007F0F                 retn
.text$mn:00007F0F ??$_Uninit_copy@PBUsessionFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z endp
.text$mn:00007F0F
.text$mn:00007F0F _text$mn        ends
.text$mn:00007F0F
.text$mn:00007F10 ; ===========================================================================
.text$mn:00007F10
.text$mn:00007F10 ; Segment type: Pure code
.text$mn:00007F10 ; Segment permissions: Read/Execute
.text$mn:00007F10 _text$mn        segment para public 'CODE' use32
.text$mn:00007F10                 assume cs:_text$mn
.text$mn:00007F10                 ;org 7F10h
.text$mn:00007F10 ; COMDAT (pick any)
.text$mn:00007F10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007F10
.text$mn:00007F10 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F10
.text$mn:00007F10 ; Attributes: bp-based frame
.text$mn:00007F10
.text$mn:00007F10 ; int __cdecl std::_Uninit_copy<sessionFileInfo const *,sessionFileInfo *,std::allocator<sessionFileInfo>>(int, int, void *, int)
.text$mn:00007F10                 public ??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00007F10 ??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00007F10                                         ; CODE XREF: std::_Uninit_copy<sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo const *,sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)+2Cp
.text$mn:00007F10
.text$mn:00007F10 var_14          = dword ptr -14h
.text$mn:00007F10 var_10          = dword ptr -10h
.text$mn:00007F10 var_C           = dword ptr -0Ch
.text$mn:00007F10 var_4           = dword ptr -4
.text$mn:00007F10 arg_0           = dword ptr  8
.text$mn:00007F10 arg_4           = dword ptr  0Ch
.text$mn:00007F10 arg_8           = dword ptr  10h
.text$mn:00007F10 arg_C           = dword ptr  14h
.text$mn:00007F10
.text$mn:00007F10 ; FUNCTION CHUNK AT .text$mn:00007FDF SIZE 00000009 BYTES
.text$mn:00007F10 ; FUNCTION CHUNK AT .text$mn:00007FEF SIZE 00000015 BYTES
.text$mn:00007F10
.text$mn:00007F10                 push    ebp
.text$mn:00007F11                 mov     ebp, esp
.text$mn:00007F13                 push    0FFFFFFFFh
.text$mn:00007F15                 push    offset __ehhandler$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00007F1A                 mov     eax, large fs:0
.text$mn:00007F20                 push    eax
.text$mn:00007F21                 push    ecx
.text$mn:00007F22                 push    ecx
.text$mn:00007F23                 push    ebx
.text$mn:00007F24                 push    esi
.text$mn:00007F25                 push    edi
.text$mn:00007F26                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007F2B                 xor     eax, ebp
.text$mn:00007F2D                 push    eax
.text$mn:00007F2E                 lea     eax, [ebp+var_C]
.text$mn:00007F31                 mov     large fs:0, eax
.text$mn:00007F37                 mov     [ebp+var_10], esp
.text$mn:00007F3A                 push    174h            ; unsigned int
.text$mn:00007F3F                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007F44                 mov     eax, [ebp+arg_4]
.text$mn:00007F47                 push    eax             ; int
.text$mn:00007F48                 mov     ecx, [ebp+arg_0]
.text$mn:00007F4B                 push    ecx             ; int
.text$mn:00007F4C                 call    ??$_Debug_range@PBUsessionFileInfo@@@std@@YAXPBUsessionFileInfo@@0PB_WI@Z ; std::_Debug_range<sessionFileInfo const *>(sessionFileInfo const *,sessionFileInfo const *,wchar_t const *,uint)
.text$mn:00007F51                 add     esp, 10h
.text$mn:00007F54                 push    175h            ; unsigned int
.text$mn:00007F59                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007F5E                 mov     edx, [ebp+arg_8]
.text$mn:00007F61                 push    edx             ; int
.text$mn:00007F62                 call    ??$_Debug_pointer@UsessionFileInfo@@@std@@YAXPAUsessionFileInfo@@PB_WI@Z ; std::_Debug_pointer<sessionFileInfo>(sessionFileInfo *,wchar_t const *,uint)
.text$mn:00007F67                 add     esp, 0Ch
.text$mn:00007F6A                 mov     eax, [ebp+arg_8]
.text$mn:00007F6D                 mov     [ebp+var_14], eax
.text$mn:00007F70                 mov     [ebp+var_4], 0
.text$mn:00007F77                 jmp     short loc_7F91
.text$mn:00007F79 ; ---------------------------------------------------------------------------
.text$mn:00007F79
.text$mn:00007F79 loc_7F79:                               ; CODE XREF: std::_Uninit_copy<sessionFileInfo const *,sessionFileInfo *,std::allocator<sessionFileInfo>>(sessionFileInfo const *,sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)+99j
.text$mn:00007F79                 mov     ecx, [ebp+arg_8]
.text$mn:00007F7C                 add     ecx, 98h ; 'ÿ'
.text$mn:00007F82                 mov     [ebp+arg_8], ecx
.text$mn:00007F85                 mov     edx, [ebp+arg_0]
.text$mn:00007F88                 add     edx, 98h ; 'ÿ'
.text$mn:00007F8E                 mov     [ebp+arg_0], edx
.text$mn:00007F91
.text$mn:00007F91 loc_7F91:                               ; CODE XREF: std::_Uninit_copy<sessionFileInfo const *,sessionFileInfo *,std::allocator<sessionFileInfo>>(sessionFileInfo const *,sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:00007F91                 mov     eax, [ebp+arg_0]
.text$mn:00007F94                 cmp     eax, [ebp+arg_4]
.text$mn:00007F97                 jz      short loc_7FAB
.text$mn:00007F99                 mov     ecx, [ebp+arg_0]
.text$mn:00007F9C                 push    ecx             ; int
.text$mn:00007F9D                 mov     edx, [ebp+arg_8]
.text$mn:00007FA0                 push    edx             ; void *
.text$mn:00007FA1                 mov     ecx, [ebp+arg_C]
.text$mn:00007FA4                 call    ??$construct@UsessionFileInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo const &>(sessionFileInfo *,sessionFileInfo const &)
.text$mn:00007FA9                 jmp     short loc_7F79
.text$mn:00007FAB ; ---------------------------------------------------------------------------
.text$mn:00007FAB
.text$mn:00007FAB loc_7FAB:                               ; CODE XREF: std::_Uninit_copy<sessionFileInfo const *,sessionFileInfo *,std::allocator<sessionFileInfo>>(sessionFileInfo const *,sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)+87j
.text$mn:00007FAB                 jmp     short loc_7FDF
.text$mn:00007FAB ??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00007FAB
.text$mn:00007FAD
.text$mn:00007FAD ; =============== S U B R O U T I N E =======================================
.text$mn:00007FAD
.text$mn:00007FAD ; Attributes: noreturn
.text$mn:00007FAD
.text$mn:00007FAD __catch$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00007FAD                                         ; DATA XREF: .xdata$x:00014088o
.text$mn:00007FAD                 jmp     short loc_7FBA
.text$mn:00007FAF ; ---------------------------------------------------------------------------
.text$mn:00007FAF
.text$mn:00007FAF loc_7FAF:                               ; CODE XREF: __catch$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+21j
.text$mn:00007FAF                 mov     eax, [ebp-14h]
.text$mn:00007FB2                 add     eax, 98h ; 'ÿ'
.text$mn:00007FB7                 mov     [ebp-14h], eax
.text$mn:00007FBA
.text$mn:00007FBA loc_7FBA:                               ; CODE XREF: __catch$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:00007FBA                 mov     ecx, [ebp-14h]
.text$mn:00007FBD                 cmp     ecx, [ebp+10h]
.text$mn:00007FC0                 jz      short loc_7FD0
.text$mn:00007FC2                 mov     edx, [ebp-14h]
.text$mn:00007FC5                 push    edx
.text$mn:00007FC6                 mov     ecx, [ebp+14h]
.text$mn:00007FC9                 call    ??$destroy@UsessionFileInfo@@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@@Z ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::destroy<sessionFileInfo>(sessionFileInfo *)
.text$mn:00007FCE                 jmp     short loc_7FAF
.text$mn:00007FD0 ; ---------------------------------------------------------------------------
.text$mn:00007FD0
.text$mn:00007FD0 loc_7FD0:                               ; CODE XREF: __catch$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+13j
.text$mn:00007FD0                 push    0
.text$mn:00007FD2                 push    0
.text$mn:00007FD4                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00007FD4 __catch$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00007FD4
.text$mn:00007FD9 ; ---------------------------------------------------------------------------
.text$mn:00007FD9                 mov     eax, offset $LN13
.text$mn:00007FDE                 retn
.text$mn:00007FDF ; ---------------------------------------------------------------------------
.text$mn:00007FDF ; START OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00007FDF
.text$mn:00007FDF loc_7FDF:                               ; CODE XREF: std::_Uninit_copy<sessionFileInfo const *,sessionFileInfo *,std::allocator<sessionFileInfo>>(sessionFileInfo const *,sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,std::_Nonscalar_ptr_iterator_tag):loc_7FABj
.text$mn:00007FDF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007FE6                 jmp     short loc_7FEF
.text$mn:00007FE6 ; END OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00007FE8
.text$mn:00007FE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007FE8
.text$mn:00007FE8
.text$mn:00007FE8 $LN13           proc near               ; DATA XREF: .text$mn:00007FD9o
.text$mn:00007FE8                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00007FE8 $LN13           endp ; sp-analysis failed
.text$mn:00007FE8
.text$mn:00007FEF ; START OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00007FEF
.text$mn:00007FEF loc_7FEF:                               ; CODE XREF: std::_Uninit_copy<sessionFileInfo const *,sessionFileInfo *,std::allocator<sessionFileInfo>>(sessionFileInfo const *,sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)+D6j
.text$mn:00007FEF                 mov     eax, [ebp+arg_8]
.text$mn:00007FF2                 mov     ecx, [ebp+var_C]
.text$mn:00007FF5                 mov     large fs:0, ecx
.text$mn:00007FFC                 pop     ecx
.text$mn:00007FFD                 pop     edi
.text$mn:00007FFE                 pop     esi
.text$mn:00007FFF                 pop     ebx
.text$mn:00008000                 mov     esp, ebp
.text$mn:00008002                 pop     ebp
.text$mn:00008003                 retn
.text$mn:00008003 ; END OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00008003 _text$mn        ends
.text$mn:00008003
.text$x:00008004 ; ===========================================================================
.text$x:00008004
.text$x:00008004 ; Segment type: Pure code
.text$x:00008004 ; Segment permissions: Read/Execute
.text$x:00008004 _text$x         segment para public 'CODE' use32
.text$x:00008004                 assume cs:_text$x
.text$x:00008004                 ;org 8004h
.text$x:00008004 ; COMDAT (pick associative to section at 7F10)
.text$x:00008004                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008004
.text$x:00008004 ; =============== S U B R O U T I N E =======================================
.text$x:00008004
.text$x:00008004
.text$x:00008004 __ehhandler$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00008004                                         ; DATA XREF: std::_Uninit_copy<sessionFileInfo const *,sessionFileInfo *,std::allocator<sessionFileInfo>>(sessionFileInfo const *,sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00008004
.text$x:00008004 arg_4           = dword ptr  8
.text$x:00008004
.text$x:00008004                 mov     edx, [esp+arg_4]
.text$x:00008008                 lea     eax, [edx+0Ch]
.text$x:0000800B                 mov     ecx, [edx-18h]
.text$x:0000800E                 xor     ecx, eax
.text$x:00008010                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008015                 mov     eax, offset __ehfuncinfo$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:0000801A                 jmp     ___CxxFrameHandler3
.text$x:0000801A __ehhandler$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:0000801A
.text$x:0000801A ; ---------------------------------------------------------------------------
.text$x:0000801F                 align 10h
.text$x:0000801F _text$x         ends
.text$x:0000801F
.text$mn:00008020 ; ===========================================================================
.text$mn:00008020
.text$mn:00008020 ; Segment type: Pure code
.text$mn:00008020 ; Segment permissions: Read/Execute
.text$mn:00008020 _text$mn        segment para public 'CODE' use32
.text$mn:00008020                 assume cs:_text$mn
.text$mn:00008020                 ;org 8020h
.text$mn:00008020 ; COMDAT (pick any)
.text$mn:00008020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008020
.text$mn:00008020 ; =============== S U B R O U T I N E =======================================
.text$mn:00008020
.text$mn:00008020 ; Attributes: bp-based frame
.text$mn:00008020
.text$mn:00008020 ; int __cdecl std::_Uninit_move<int,int,int>(void *Src, int, void *Dst)
.text$mn:00008020                 public ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00008020 ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00008020                                         ; CODE XREF: std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+39p
.text$mn:00008020
.text$mn:00008020 var_4           = dword ptr -4
.text$mn:00008020 Src             = dword ptr  8
.text$mn:00008020 arg_4           = dword ptr  0Ch
.text$mn:00008020 Dst             = dword ptr  10h
.text$mn:00008020
.text$mn:00008020                 push    ebp
.text$mn:00008021                 mov     ebp, esp
.text$mn:00008023                 push    ecx
.text$mn:00008024                 push    1D6h            ; unsigned int
.text$mn:00008029                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000802E                 mov     eax, [ebp+arg_4]
.text$mn:00008031                 push    eax             ; int
.text$mn:00008032                 mov     ecx, [ebp+Src]
.text$mn:00008035                 push    ecx             ; int
.text$mn:00008036                 call    ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z ; std::_Debug_range<int *>(int *,int *,wchar_t const *,uint)
.text$mn:0000803B                 add     esp, 10h
.text$mn:0000803E                 push    1D7h            ; unsigned int
.text$mn:00008043                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008048                 mov     edx, [ebp+Dst]
.text$mn:0000804B                 push    edx             ; int
.text$mn:0000804C                 call    ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)
.text$mn:00008051                 add     esp, 0Ch
.text$mn:00008054                 mov     eax, [ebp+arg_4]
.text$mn:00008057                 sub     eax, [ebp+Src]
.text$mn:0000805A                 sar     eax, 2
.text$mn:0000805D                 mov     [ebp+var_4], eax
.text$mn:00008060                 mov     ecx, [ebp+var_4]
.text$mn:00008063                 shl     ecx, 2
.text$mn:00008066                 push    ecx             ; Size
.text$mn:00008067                 mov     edx, [ebp+Src]
.text$mn:0000806A                 push    edx             ; Src
.text$mn:0000806B                 mov     eax, [ebp+Dst]
.text$mn:0000806E                 push    eax             ; Dst
.text$mn:0000806F                 call    _memmove
.text$mn:00008074                 add     esp, 0Ch
.text$mn:00008077                 mov     ecx, [ebp+var_4]
.text$mn:0000807A                 lea     eax, [eax+ecx*4]
.text$mn:0000807D                 mov     esp, ebp
.text$mn:0000807F                 pop     ebp
.text$mn:00008080                 retn
.text$mn:00008080 ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00008080
.text$mn:00008080 ; ---------------------------------------------------------------------------
.text$mn:00008081                 align 4
.text$mn:00008081 _text$mn        ends
.text$mn:00008081
.text$mn:00008084 ; ===========================================================================
.text$mn:00008084
.text$mn:00008084 ; Segment type: Pure code
.text$mn:00008084 ; Segment permissions: Read/Execute
.text$mn:00008084 _text$mn        segment para public 'CODE' use32
.text$mn:00008084                 assume cs:_text$mn
.text$mn:00008084                 ;org 8084h
.text$mn:00008084 ; COMDAT (pick any)
.text$mn:00008084                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008084
.text$mn:00008084 ; =============== S U B R O U T I N E =======================================
.text$mn:00008084
.text$mn:00008084 ; Attributes: bp-based frame
.text$mn:00008084
.text$mn:00008084 ; int __cdecl std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(void *Src, int, void *Dst, int)
.text$mn:00008084                 public ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
.text$mn:00008084 ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z proc near
.text$mn:00008084                                         ; CODE XREF: std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+2Ep
.text$mn:00008084
.text$mn:00008084 var_1           = byte ptr -1
.text$mn:00008084 Src             = dword ptr  8
.text$mn:00008084 arg_4           = dword ptr  0Ch
.text$mn:00008084 Dst             = dword ptr  10h
.text$mn:00008084 arg_C           = dword ptr  14h
.text$mn:00008084
.text$mn:00008084                 push    ebp
.text$mn:00008085                 mov     ebp, esp
.text$mn:00008087                 push    ecx
.text$mn:00008088                 mov     eax, [ebp+Dst]
.text$mn:0000808B                 push    eax
.text$mn:0000808C                 mov     ecx, [ebp+Src]
.text$mn:0000808F                 push    ecx
.text$mn:00008090                 call    ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>(int *,int *)
.text$mn:00008095                 add     esp, 8
.text$mn:00008098                 mov     [ebp+var_1], al
.text$mn:0000809B                 movzx   edx, [ebp+var_1]
.text$mn:0000809F                 push    edx
.text$mn:000080A0                 mov     eax, [ebp+Src]
.text$mn:000080A3                 push    eax
.text$mn:000080A4                 call    ??$_Val_type@PAH@std@@YAPAHPAH@Z ; std::_Val_type<int *>(int *)
.text$mn:000080A9                 add     esp, 4
.text$mn:000080AC                 push    eax
.text$mn:000080AD                 mov     ecx, [ebp+arg_C]
.text$mn:000080B0                 push    ecx
.text$mn:000080B1                 mov     edx, [ebp+Dst]
.text$mn:000080B4                 push    edx             ; Dst
.text$mn:000080B5                 mov     eax, [ebp+arg_4]
.text$mn:000080B8                 push    eax             ; int
.text$mn:000080B9                 mov     ecx, [ebp+Src]
.text$mn:000080BC                 push    ecx             ; Src
.text$mn:000080BD                 call    ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<int,int,int>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)
.text$mn:000080C2                 add     esp, 18h
.text$mn:000080C5                 mov     esp, ebp
.text$mn:000080C7                 pop     ebp
.text$mn:000080C8                 retn
.text$mn:000080C8 ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z endp
.text$mn:000080C8
.text$mn:000080C8 ; ---------------------------------------------------------------------------
.text$mn:000080C9                 align 4
.text$mn:000080C9 _text$mn        ends
.text$mn:000080C9
.text$mn:000080CC ; ===========================================================================
.text$mn:000080CC
.text$mn:000080CC ; Segment type: Pure code
.text$mn:000080CC ; Segment permissions: Read/Execute
.text$mn:000080CC _text$mn        segment para public 'CODE' use32
.text$mn:000080CC                 assume cs:_text$mn
.text$mn:000080CC                 ;org 80CCh
.text$mn:000080CC ; COMDAT (pick any)
.text$mn:000080CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000080CC
.text$mn:000080CC ; =============== S U B R O U T I N E =======================================
.text$mn:000080CC
.text$mn:000080CC ; Attributes: bp-based frame
.text$mn:000080CC
.text$mn:000080CC ; int __cdecl std::_Uninit_move<sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(int, int, void *, int)
.text$mn:000080CC                 public ??$_Uninit_move@PAUsessionFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z
.text$mn:000080CC ??$_Uninit_move@PAUsessionFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z proc near
.text$mn:000080CC                                         ; CODE XREF: std::_Uninitialized_move<sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)+2Ep
.text$mn:000080CC
.text$mn:000080CC var_1           = byte ptr -1
.text$mn:000080CC arg_0           = dword ptr  8
.text$mn:000080CC arg_4           = dword ptr  0Ch
.text$mn:000080CC arg_8           = dword ptr  10h
.text$mn:000080CC arg_C           = dword ptr  14h
.text$mn:000080CC
.text$mn:000080CC                 push    ebp
.text$mn:000080CD                 mov     ebp, esp
.text$mn:000080CF                 push    ecx
.text$mn:000080D0                 mov     eax, [ebp+arg_8]
.text$mn:000080D3                 push    eax
.text$mn:000080D4                 mov     ecx, [ebp+arg_0]
.text$mn:000080D7                 push    ecx
.text$mn:000080D8                 call    ??$_Ptr_cat@UsessionFileInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUsessionFileInfo@@0@Z ; std::_Ptr_cat<sessionFileInfo,sessionFileInfo>(sessionFileInfo *,sessionFileInfo *)
.text$mn:000080DD                 add     esp, 8
.text$mn:000080E0                 mov     [ebp+var_1], al
.text$mn:000080E3                 movzx   edx, [ebp+var_1]
.text$mn:000080E7                 push    edx
.text$mn:000080E8                 mov     eax, [ebp+arg_0]
.text$mn:000080EB                 push    eax
.text$mn:000080EC                 call    ??$_Val_type@PAUsessionFileInfo@@@std@@YAPAUsessionFileInfo@@PAU1@@Z ; std::_Val_type<sessionFileInfo *>(sessionFileInfo *)
.text$mn:000080F1                 add     esp, 4
.text$mn:000080F4                 push    eax
.text$mn:000080F5                 mov     ecx, [ebp+arg_C]
.text$mn:000080F8                 push    ecx             ; int
.text$mn:000080F9                 mov     edx, [ebp+arg_8]
.text$mn:000080FC                 push    edx             ; void *
.text$mn:000080FD                 mov     eax, [ebp+arg_4]
.text$mn:00008100                 push    eax             ; int
.text$mn:00008101                 mov     ecx, [ebp+arg_0]
.text$mn:00008104                 push    ecx             ; int
.text$mn:00008105                 call    ??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<sessionFileInfo *,sessionFileInfo *,std::allocator<sessionFileInfo>,sessionFileInfo>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,sessionFileInfo *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000810A                 add     esp, 18h
.text$mn:0000810D                 mov     esp, ebp
.text$mn:0000810F                 pop     ebp
.text$mn:00008110                 retn
.text$mn:00008110 ??$_Uninit_move@PAUsessionFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z endp
.text$mn:00008110
.text$mn:00008110 ; ---------------------------------------------------------------------------
.text$mn:00008111                 align 4
.text$mn:00008111 _text$mn        ends
.text$mn:00008111
.text$mn:00008114 ; ===========================================================================
.text$mn:00008114
.text$mn:00008114 ; Segment type: Pure code
.text$mn:00008114 ; Segment permissions: Read/Execute
.text$mn:00008114 _text$mn        segment para public 'CODE' use32
.text$mn:00008114                 assume cs:_text$mn
.text$mn:00008114                 ;org 8114h
.text$mn:00008114 ; COMDAT (pick any)
.text$mn:00008114                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008114
.text$mn:00008114 ; =============== S U B R O U T I N E =======================================
.text$mn:00008114
.text$mn:00008114 ; Attributes: bp-based frame
.text$mn:00008114
.text$mn:00008114 ; int __cdecl std::_Uninit_move<sessionFileInfo *,sessionFileInfo *,std::allocator<sessionFileInfo>,sessionFileInfo>(int, int, void *, int)
.text$mn:00008114                 public ??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00008114 ??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00008114                                         ; CODE XREF: std::_Uninit_move<sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)+39p
.text$mn:00008114
.text$mn:00008114 var_14          = dword ptr -14h
.text$mn:00008114 var_10          = dword ptr -10h
.text$mn:00008114 var_C           = dword ptr -0Ch
.text$mn:00008114 var_4           = dword ptr -4
.text$mn:00008114 arg_0           = dword ptr  8
.text$mn:00008114 arg_4           = dword ptr  0Ch
.text$mn:00008114 arg_8           = dword ptr  10h
.text$mn:00008114 arg_C           = dword ptr  14h
.text$mn:00008114
.text$mn:00008114 ; FUNCTION CHUNK AT .text$mn:000081E3 SIZE 00000009 BYTES
.text$mn:00008114 ; FUNCTION CHUNK AT .text$mn:000081F3 SIZE 00000015 BYTES
.text$mn:00008114
.text$mn:00008114                 push    ebp
.text$mn:00008115                 mov     ebp, esp
.text$mn:00008117                 push    0FFFFFFFFh
.text$mn:00008119                 push    offset __ehhandler$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000811E                 mov     eax, large fs:0
.text$mn:00008124                 push    eax
.text$mn:00008125                 push    ecx
.text$mn:00008126                 push    ecx
.text$mn:00008127                 push    ebx
.text$mn:00008128                 push    esi
.text$mn:00008129                 push    edi
.text$mn:0000812A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000812F                 xor     eax, ebp
.text$mn:00008131                 push    eax
.text$mn:00008132                 lea     eax, [ebp+var_C]
.text$mn:00008135                 mov     large fs:0, eax
.text$mn:0000813B                 mov     [ebp+var_10], esp
.text$mn:0000813E                 push    1B6h            ; unsigned int
.text$mn:00008143                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008148                 mov     eax, [ebp+arg_4]
.text$mn:0000814B                 push    eax             ; int
.text$mn:0000814C                 mov     ecx, [ebp+arg_0]
.text$mn:0000814F                 push    ecx             ; int
.text$mn:00008150                 call    ??$_Debug_range@PAUsessionFileInfo@@@std@@YAXPAUsessionFileInfo@@0PB_WI@Z ; std::_Debug_range<sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,wchar_t const *,uint)
.text$mn:00008155                 add     esp, 10h
.text$mn:00008158                 push    1B7h            ; unsigned int
.text$mn:0000815D                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008162                 mov     edx, [ebp+arg_8]
.text$mn:00008165                 push    edx             ; int
.text$mn:00008166                 call    ??$_Debug_pointer@UsessionFileInfo@@@std@@YAXPAUsessionFileInfo@@PB_WI@Z ; std::_Debug_pointer<sessionFileInfo>(sessionFileInfo *,wchar_t const *,uint)
.text$mn:0000816B                 add     esp, 0Ch
.text$mn:0000816E                 mov     eax, [ebp+arg_8]
.text$mn:00008171                 mov     [ebp+var_14], eax
.text$mn:00008174                 mov     [ebp+var_4], 0
.text$mn:0000817B                 jmp     short loc_8195
.text$mn:0000817D ; ---------------------------------------------------------------------------
.text$mn:0000817D
.text$mn:0000817D loc_817D:                               ; CODE XREF: std::_Uninit_move<sessionFileInfo *,sessionFileInfo *,std::allocator<sessionFileInfo>,sessionFileInfo>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,sessionFileInfo *,std::_Nonscalar_ptr_iterator_tag)+99j
.text$mn:0000817D                 mov     ecx, [ebp+arg_8]
.text$mn:00008180                 add     ecx, 98h ; 'ÿ'
.text$mn:00008186                 mov     [ebp+arg_8], ecx
.text$mn:00008189                 mov     edx, [ebp+arg_0]
.text$mn:0000818C                 add     edx, 98h ; 'ÿ'
.text$mn:00008192                 mov     [ebp+arg_0], edx
.text$mn:00008195
.text$mn:00008195 loc_8195:                               ; CODE XREF: std::_Uninit_move<sessionFileInfo *,sessionFileInfo *,std::allocator<sessionFileInfo>,sessionFileInfo>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,sessionFileInfo *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:00008195                 mov     eax, [ebp+arg_0]
.text$mn:00008198                 cmp     eax, [ebp+arg_4]
.text$mn:0000819B                 jz      short loc_81AF
.text$mn:0000819D                 mov     ecx, [ebp+arg_0]
.text$mn:000081A0                 push    ecx             ; int
.text$mn:000081A1                 mov     edx, [ebp+arg_8]
.text$mn:000081A4                 push    edx             ; void *
.text$mn:000081A5                 mov     ecx, [ebp+arg_C]
.text$mn:000081A8                 call    ??$construct@UsessionFileInfo@@U1@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo>(sessionFileInfo *,sessionFileInfo &&)
.text$mn:000081AD                 jmp     short loc_817D
.text$mn:000081AF ; ---------------------------------------------------------------------------
.text$mn:000081AF
.text$mn:000081AF loc_81AF:                               ; CODE XREF: std::_Uninit_move<sessionFileInfo *,sessionFileInfo *,std::allocator<sessionFileInfo>,sessionFileInfo>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,sessionFileInfo *,std::_Nonscalar_ptr_iterator_tag)+87j
.text$mn:000081AF                 jmp     short loc_81E3
.text$mn:000081AF ??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000081AF
.text$mn:000081B1
.text$mn:000081B1 ; =============== S U B R O U T I N E =======================================
.text$mn:000081B1
.text$mn:000081B1 ; Attributes: noreturn
.text$mn:000081B1
.text$mn:000081B1 __catch$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:000081B1                                         ; DATA XREF: .xdata$x:000140E0o
.text$mn:000081B1                 jmp     short loc_81BE
.text$mn:000081B3 ; ---------------------------------------------------------------------------
.text$mn:000081B3
.text$mn:000081B3 loc_81B3:                               ; CODE XREF: __catch$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+21j
.text$mn:000081B3                 mov     eax, [ebp-14h]
.text$mn:000081B6                 add     eax, 98h ; 'ÿ'
.text$mn:000081BB                 mov     [ebp-14h], eax
.text$mn:000081BE
.text$mn:000081BE loc_81BE:                               ; CODE XREF: __catch$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:000081BE                 mov     ecx, [ebp-14h]
.text$mn:000081C1                 cmp     ecx, [ebp+10h]
.text$mn:000081C4                 jz      short loc_81D4
.text$mn:000081C6                 mov     edx, [ebp-14h]
.text$mn:000081C9                 push    edx
.text$mn:000081CA                 mov     ecx, [ebp+14h]
.text$mn:000081CD                 call    ??$destroy@UsessionFileInfo@@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@@Z ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::destroy<sessionFileInfo>(sessionFileInfo *)
.text$mn:000081D2                 jmp     short loc_81B3
.text$mn:000081D4 ; ---------------------------------------------------------------------------
.text$mn:000081D4
.text$mn:000081D4 loc_81D4:                               ; CODE XREF: __catch$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+13j
.text$mn:000081D4                 push    0
.text$mn:000081D6                 push    0
.text$mn:000081D8                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000081D8 __catch$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:000081D8
.text$mn:000081DD ; ---------------------------------------------------------------------------
.text$mn:000081DD                 mov     eax, offset $LN13_0
.text$mn:000081E2                 retn
.text$mn:000081E3 ; ---------------------------------------------------------------------------
.text$mn:000081E3 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000081E3
.text$mn:000081E3 loc_81E3:                               ; CODE XREF: std::_Uninit_move<sessionFileInfo *,sessionFileInfo *,std::allocator<sessionFileInfo>,sessionFileInfo>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,sessionFileInfo *,std::_Nonscalar_ptr_iterator_tag):loc_81AFj
.text$mn:000081E3                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000081EA                 jmp     short loc_81F3
.text$mn:000081EA ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000081EC
.text$mn:000081EC ; =============== S U B R O U T I N E =======================================
.text$mn:000081EC
.text$mn:000081EC
.text$mn:000081EC $LN13_0         proc near               ; DATA XREF: .text$mn:000081DDo
.text$mn:000081EC                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000081EC $LN13_0         endp ; sp-analysis failed
.text$mn:000081EC
.text$mn:000081F3 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000081F3
.text$mn:000081F3 loc_81F3:                               ; CODE XREF: std::_Uninit_move<sessionFileInfo *,sessionFileInfo *,std::allocator<sessionFileInfo>,sessionFileInfo>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,sessionFileInfo *,std::_Nonscalar_ptr_iterator_tag)+D6j
.text$mn:000081F3                 mov     eax, [ebp+arg_8]
.text$mn:000081F6                 mov     ecx, [ebp+var_C]
.text$mn:000081F9                 mov     large fs:0, ecx
.text$mn:00008200                 pop     ecx
.text$mn:00008201                 pop     edi
.text$mn:00008202                 pop     esi
.text$mn:00008203                 pop     ebx
.text$mn:00008204                 mov     esp, ebp
.text$mn:00008206                 pop     ebp
.text$mn:00008207                 retn
.text$mn:00008207 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00008207 _text$mn        ends
.text$mn:00008207
.text$x:00008208 ; ===========================================================================
.text$x:00008208
.text$x:00008208 ; Segment type: Pure code
.text$x:00008208 ; Segment permissions: Read/Execute
.text$x:00008208 _text$x         segment para public 'CODE' use32
.text$x:00008208                 assume cs:_text$x
.text$x:00008208                 ;org 8208h
.text$x:00008208 ; COMDAT (pick associative to section at 8114)
.text$x:00008208                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008208
.text$x:00008208 ; =============== S U B R O U T I N E =======================================
.text$x:00008208
.text$x:00008208
.text$x:00008208 __ehhandler$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00008208                                         ; DATA XREF: std::_Uninit_move<sessionFileInfo *,sessionFileInfo *,std::allocator<sessionFileInfo>,sessionFileInfo>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,sessionFileInfo *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00008208
.text$x:00008208 arg_4           = dword ptr  8
.text$x:00008208
.text$x:00008208                 mov     edx, [esp+arg_4]
.text$x:0000820C                 lea     eax, [edx+0Ch]
.text$x:0000820F                 mov     ecx, [edx-18h]
.text$x:00008212                 xor     ecx, eax
.text$x:00008214                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008219                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:0000821E                 jmp     ___CxxFrameHandler3
.text$x:0000821E __ehhandler$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:0000821E
.text$x:0000821E ; ---------------------------------------------------------------------------
.text$x:00008223                 align 4
.text$x:00008223 _text$x         ends
.text$x:00008223
.text$mn:00008224 ; ===========================================================================
.text$mn:00008224
.text$mn:00008224 ; Segment type: Pure code
.text$mn:00008224 ; Segment permissions: Read/Execute
.text$mn:00008224 _text$mn        segment para public 'CODE' use32
.text$mn:00008224                 assume cs:_text$mn
.text$mn:00008224                 ;org 8224h
.text$mn:00008224 ; COMDAT (pick any)
.text$mn:00008224                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008224
.text$mn:00008224 ; =============== S U B R O U T I N E =======================================
.text$mn:00008224
.text$mn:00008224 ; Attributes: bp-based frame
.text$mn:00008224
.text$mn:00008224 ; int __cdecl std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(int, int, void *, int)
.text$mn:00008224                 public ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z
.text$mn:00008224 ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z proc near
.text$mn:00008224                                         ; CODE XREF: std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+2Ep
.text$mn:00008224
.text$mn:00008224 var_1           = byte ptr -1
.text$mn:00008224 arg_0           = dword ptr  8
.text$mn:00008224 arg_4           = dword ptr  0Ch
.text$mn:00008224 arg_8           = dword ptr  10h
.text$mn:00008224 arg_C           = dword ptr  14h
.text$mn:00008224
.text$mn:00008224                 push    ebp
.text$mn:00008225                 mov     ebp, esp
.text$mn:00008227                 push    ecx
.text$mn:00008228                 mov     eax, [ebp+arg_8]
.text$mn:0000822B                 push    eax
.text$mn:0000822C                 mov     ecx, [ebp+arg_0]
.text$mn:0000822F                 push    ecx
.text$mn:00008230                 call    ??$_Ptr_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00008235                 add     esp, 8
.text$mn:00008238                 mov     [ebp+var_1], al
.text$mn:0000823B                 movzx   edx, [ebp+var_1]
.text$mn:0000823F                 push    edx
.text$mn:00008240                 mov     eax, [ebp+arg_0]
.text$mn:00008243                 push    eax
.text$mn:00008244                 call    ??$_Val_type@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z ; std::_Val_type<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00008249                 add     esp, 4
.text$mn:0000824C                 push    eax
.text$mn:0000824D                 mov     ecx, [ebp+arg_C]
.text$mn:00008250                 push    ecx             ; int
.text$mn:00008251                 mov     edx, [ebp+arg_8]
.text$mn:00008254                 push    edx             ; void *
.text$mn:00008255                 mov     eax, [ebp+arg_4]
.text$mn:00008258                 push    eax             ; int
.text$mn:00008259                 mov     ecx, [ebp+arg_0]
.text$mn:0000825C                 push    ecx             ; int
.text$mn:0000825D                 call    ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00008262                 add     esp, 18h
.text$mn:00008265                 mov     esp, ebp
.text$mn:00008267                 pop     ebp
.text$mn:00008268                 retn
.text$mn:00008268 ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z endp
.text$mn:00008268
.text$mn:00008268 ; ---------------------------------------------------------------------------
.text$mn:00008269                 align 4
.text$mn:00008269 _text$mn        ends
.text$mn:00008269
.text$mn:0000826C ; ===========================================================================
.text$mn:0000826C
.text$mn:0000826C ; Segment type: Pure code
.text$mn:0000826C ; Segment permissions: Read/Execute
.text$mn:0000826C _text$mn        segment para public 'CODE' use32
.text$mn:0000826C                 assume cs:_text$mn
.text$mn:0000826C                 ;org 826Ch
.text$mn:0000826C ; COMDAT (pick any)
.text$mn:0000826C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000826C
.text$mn:0000826C ; =============== S U B R O U T I N E =======================================
.text$mn:0000826C
.text$mn:0000826C ; Attributes: bp-based frame
.text$mn:0000826C
.text$mn:0000826C ; int __cdecl std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(int, int, void *, int)
.text$mn:0000826C                 public ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000826C ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:0000826C                                         ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+39p
.text$mn:0000826C
.text$mn:0000826C var_14          = dword ptr -14h
.text$mn:0000826C var_10          = dword ptr -10h
.text$mn:0000826C var_C           = dword ptr -0Ch
.text$mn:0000826C var_4           = dword ptr -4
.text$mn:0000826C arg_0           = dword ptr  8
.text$mn:0000826C arg_4           = dword ptr  0Ch
.text$mn:0000826C arg_8           = dword ptr  10h
.text$mn:0000826C arg_C           = dword ptr  14h
.text$mn:0000826C
.text$mn:0000826C ; FUNCTION CHUNK AT .text$mn:00008333 SIZE 00000009 BYTES
.text$mn:0000826C ; FUNCTION CHUNK AT .text$mn:00008343 SIZE 00000015 BYTES
.text$mn:0000826C
.text$mn:0000826C                 push    ebp
.text$mn:0000826D                 mov     ebp, esp
.text$mn:0000826F                 push    0FFFFFFFFh
.text$mn:00008271                 push    offset __ehhandler$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00008276                 mov     eax, large fs:0
.text$mn:0000827C                 push    eax
.text$mn:0000827D                 push    ecx
.text$mn:0000827E                 push    ecx
.text$mn:0000827F                 push    ebx
.text$mn:00008280                 push    esi
.text$mn:00008281                 push    edi
.text$mn:00008282                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008287                 xor     eax, ebp
.text$mn:00008289                 push    eax
.text$mn:0000828A                 lea     eax, [ebp+var_C]
.text$mn:0000828D                 mov     large fs:0, eax
.text$mn:00008293                 mov     [ebp+var_10], esp
.text$mn:00008296                 push    1B6h            ; unsigned int
.text$mn:0000829B                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000082A0                 mov     eax, [ebp+arg_4]
.text$mn:000082A3                 push    eax             ; int
.text$mn:000082A4                 mov     ecx, [ebp+arg_0]
.text$mn:000082A7                 push    ecx             ; int
.text$mn:000082A8                 call    ??$_Debug_range@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WI@Z ; std::_Debug_range<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)
.text$mn:000082AD                 add     esp, 10h
.text$mn:000082B0                 push    1B7h            ; unsigned int
.text$mn:000082B5                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000082BA                 mov     edx, [ebp+arg_8]
.text$mn:000082BD                 push    edx             ; int
.text$mn:000082BE                 call    ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z ; std::_Debug_pointer<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)
.text$mn:000082C3                 add     esp, 0Ch
.text$mn:000082C6                 mov     eax, [ebp+arg_8]
.text$mn:000082C9                 mov     [ebp+var_14], eax
.text$mn:000082CC                 mov     [ebp+var_4], 0
.text$mn:000082D3                 jmp     short loc_82E7
.text$mn:000082D5 ; ---------------------------------------------------------------------------
.text$mn:000082D5
.text$mn:000082D5 loc_82D5:                               ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:000082D5                 mov     ecx, [ebp+arg_8]
.text$mn:000082D8                 add     ecx, 1Ch
.text$mn:000082DB                 mov     [ebp+arg_8], ecx
.text$mn:000082DE                 mov     edx, [ebp+arg_0]
.text$mn:000082E1                 add     edx, 1Ch
.text$mn:000082E4                 mov     [ebp+arg_0], edx
.text$mn:000082E7
.text$mn:000082E7 loc_82E7:                               ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:000082E7                 mov     eax, [ebp+arg_0]
.text$mn:000082EA                 cmp     eax, [ebp+arg_4]
.text$mn:000082ED                 jz      short loc_8301
.text$mn:000082EF                 mov     ecx, [ebp+arg_0]
.text$mn:000082F2                 push    ecx             ; int
.text$mn:000082F3                 mov     edx, [ebp+arg_8]
.text$mn:000082F6                 push    edx             ; void *
.text$mn:000082F7                 mov     ecx, [ebp+arg_C]
.text$mn:000082FA                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:000082FF                 jmp     short loc_82D5
.text$mn:00008301 ; ---------------------------------------------------------------------------
.text$mn:00008301
.text$mn:00008301 loc_8301:                               ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00008301                 jmp     short loc_8333
.text$mn:00008301 ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00008301
.text$mn:00008303
.text$mn:00008303 ; =============== S U B R O U T I N E =======================================
.text$mn:00008303
.text$mn:00008303 ; Attributes: noreturn
.text$mn:00008303
.text$mn:00008303 __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00008303                                         ; DATA XREF: .xdata$x:00014138o
.text$mn:00008303                 jmp     short loc_830E
.text$mn:00008305 ; ---------------------------------------------------------------------------
.text$mn:00008305
.text$mn:00008305 loc_8305:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00008305                 mov     eax, [ebp-14h]
.text$mn:00008308                 add     eax, 1Ch
.text$mn:0000830B                 mov     [ebp-14h], eax
.text$mn:0000830E
.text$mn:0000830E loc_830E:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:0000830E                 mov     ecx, [ebp-14h]
.text$mn:00008311                 cmp     ecx, [ebp+10h]
.text$mn:00008314                 jz      short loc_8324
.text$mn:00008316                 mov     edx, [ebp-14h]
.text$mn:00008319                 push    edx
.text$mn:0000831A                 mov     ecx, [ebp+14h]
.text$mn:0000831D                 call    ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00008322                 jmp     short loc_8305
.text$mn:00008324 ; ---------------------------------------------------------------------------
.text$mn:00008324
.text$mn:00008324 loc_8324:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00008324                 push    0
.text$mn:00008326                 push    0
.text$mn:00008328                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00008328 __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00008328
.text$mn:0000832D ; ---------------------------------------------------------------------------
.text$mn:0000832D                 mov     eax, offset $LN13_1
.text$mn:00008332                 retn
.text$mn:00008333 ; ---------------------------------------------------------------------------
.text$mn:00008333 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00008333
.text$mn:00008333 loc_8333:                               ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag):loc_8301j
.text$mn:00008333                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000833A                 jmp     short loc_8343
.text$mn:0000833A ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000833C
.text$mn:0000833C ; =============== S U B R O U T I N E =======================================
.text$mn:0000833C
.text$mn:0000833C
.text$mn:0000833C $LN13_1         proc near               ; DATA XREF: .text$mn:0000832Do
.text$mn:0000833C                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000833C $LN13_1         endp ; sp-analysis failed
.text$mn:0000833C
.text$mn:00008343 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00008343
.text$mn:00008343 loc_8343:                               ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:00008343                 mov     eax, [ebp+arg_8]
.text$mn:00008346                 mov     ecx, [ebp+var_C]
.text$mn:00008349                 mov     large fs:0, ecx
.text$mn:00008350                 pop     ecx
.text$mn:00008351                 pop     edi
.text$mn:00008352                 pop     esi
.text$mn:00008353                 pop     ebx
.text$mn:00008354                 mov     esp, ebp
.text$mn:00008356                 pop     ebp
.text$mn:00008357                 retn
.text$mn:00008357 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00008357 _text$mn        ends
.text$mn:00008357
.text$x:00008358 ; ===========================================================================
.text$x:00008358
.text$x:00008358 ; Segment type: Pure code
.text$x:00008358 ; Segment permissions: Read/Execute
.text$x:00008358 _text$x         segment para public 'CODE' use32
.text$x:00008358                 assume cs:_text$x
.text$x:00008358                 ;org 8358h
.text$x:00008358 ; COMDAT (pick associative to section at 826C)
.text$x:00008358                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008358
.text$x:00008358 ; =============== S U B R O U T I N E =======================================
.text$x:00008358
.text$x:00008358
.text$x:00008358 __ehhandler$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00008358                                         ; DATA XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00008358
.text$x:00008358 arg_4           = dword ptr  8
.text$x:00008358
.text$x:00008358                 mov     edx, [esp+arg_4]
.text$x:0000835C                 lea     eax, [edx+0Ch]
.text$x:0000835F                 mov     ecx, [edx-18h]
.text$x:00008362                 xor     ecx, eax
.text$x:00008364                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008369                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:0000836E                 jmp     ___CxxFrameHandler3
.text$x:0000836E __ehhandler$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:0000836E
.text$x:0000836E ; ---------------------------------------------------------------------------
.text$x:00008373                 align 4
.text$x:00008373 _text$x         ends
.text$x:00008373
.text$mn:00008374 ; ===========================================================================
.text$mn:00008374
.text$mn:00008374 ; Segment type: Pure code
.text$mn:00008374 ; Segment permissions: Read/Execute
.text$mn:00008374 _text$mn        segment para public 'CODE' use32
.text$mn:00008374                 assume cs:_text$mn
.text$mn:00008374                 ;org 8374h
.text$mn:00008374 ; COMDAT (pick any)
.text$mn:00008374                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008374
.text$mn:00008374 ; =============== S U B R O U T I N E =======================================
.text$mn:00008374
.text$mn:00008374 ; Attributes: bp-based frame
.text$mn:00008374
.text$mn:00008374 ; unsigned int * __cdecl std::_Uninitialized_copy<unsigned int *, unsigned int *, struct std::_Wrap_alloc<class std::allocator<unsigned int>>>(unsigned int *, unsigned int *, unsigned int *, struct std::_Wrap_alloc<class std::allocator<unsigned int>> &)
.text$mn:00008374                 public ??$_Uninitialized_copy@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
.text$mn:00008374 ??$_Uninitialized_copy@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z proc near
.text$mn:00008374                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Ucopy<uint *>(uint *,uint *,uint *)+25p
.text$mn:00008374
.text$mn:00008374 arg_0           = dword ptr  8
.text$mn:00008374 arg_4           = dword ptr  0Ch
.text$mn:00008374 arg_8           = dword ptr  10h
.text$mn:00008374 arg_C           = dword ptr  14h
.text$mn:00008374
.text$mn:00008374                 push    ebp
.text$mn:00008375                 mov     ebp, esp
.text$mn:00008377                 mov     eax, [ebp+arg_C]
.text$mn:0000837A                 push    eax             ; int
.text$mn:0000837B                 mov     ecx, [ebp+arg_8]
.text$mn:0000837E                 push    ecx
.text$mn:0000837F                 call    ??$_Unchecked@PAI@std@@YAPAIPAI@Z ; std::_Unchecked<uint *>(uint *)
.text$mn:00008384                 add     esp, 4
.text$mn:00008387                 push    eax             ; Dst
.text$mn:00008388                 mov     edx, [ebp+arg_4]
.text$mn:0000838B                 push    edx
.text$mn:0000838C                 call    ??$_Unchecked@PAI@std@@YAPAIPAI@Z ; std::_Unchecked<uint *>(uint *)
.text$mn:00008391                 add     esp, 4
.text$mn:00008394                 push    eax             ; int
.text$mn:00008395                 mov     eax, [ebp+arg_0]
.text$mn:00008398                 push    eax
.text$mn:00008399                 call    ??$_Unchecked@PAI@std@@YAPAIPAI@Z ; std::_Unchecked<uint *>(uint *)
.text$mn:0000839E                 add     esp, 4
.text$mn:000083A1                 push    eax             ; Src
.text$mn:000083A2                 call    ??$_Uninit_copy@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Uninit_copy<uint *,uint *,std::_Wrap_alloc<std::allocator<uint>>>(uint *,uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)
.text$mn:000083A7                 add     esp, 10h
.text$mn:000083AA                 push    eax
.text$mn:000083AB                 lea     ecx, [ebp+arg_8]
.text$mn:000083AE                 push    ecx
.text$mn:000083AF                 call    ??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z ; std::_Rechecked<uint *,uint *>(uint * &,uint *)
.text$mn:000083B4                 add     esp, 8
.text$mn:000083B7                 mov     eax, [eax]
.text$mn:000083B9                 pop     ebp
.text$mn:000083BA                 retn
.text$mn:000083BA ??$_Uninitialized_copy@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z endp
.text$mn:000083BA
.text$mn:000083BA ; ---------------------------------------------------------------------------
.text$mn:000083BB                 align 4
.text$mn:000083BB _text$mn        ends
.text$mn:000083BB
.text$mn:000083BC ; ===========================================================================
.text$mn:000083BC
.text$mn:000083BC ; Segment type: Pure code
.text$mn:000083BC ; Segment permissions: Read/Execute
.text$mn:000083BC _text$mn        segment para public 'CODE' use32
.text$mn:000083BC                 assume cs:_text$mn
.text$mn:000083BC                 ;org 83BCh
.text$mn:000083BC ; COMDAT (pick any)
.text$mn:000083BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000083BC
.text$mn:000083BC ; =============== S U B R O U T I N E =======================================
.text$mn:000083BC
.text$mn:000083BC ; Attributes: bp-based frame
.text$mn:000083BC
.text$mn:000083BC ; unsigned int * __cdecl std::_Uninitialized_copy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned int>>>, unsigned int *, struct std::_Wrap_alloc<class std::allocator<unsigned int>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned int>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned int>>>, unsigned int *, struct std::_Wrap_alloc<class std::allocator<unsigned int>> &)
.text$mn:000083BC                 public ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
.text$mn:000083BC ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z proc near
.text$mn:000083BC                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *)+83p
.text$mn:000083BC
.text$mn:000083BC var_34          = dword ptr -34h
.text$mn:000083BC var_30          = dword ptr -30h
.text$mn:000083BC var_2C          = dword ptr -2Ch
.text$mn:000083BC var_28          = dword ptr -28h
.text$mn:000083BC var_24          = dword ptr -24h
.text$mn:000083BC var_20          = dword ptr -20h
.text$mn:000083BC Src             = dword ptr -1Ch
.text$mn:000083BC var_18          = dword ptr -18h
.text$mn:000083BC var_14          = dword ptr -14h
.text$mn:000083BC var_10          = dword ptr -10h
.text$mn:000083BC var_C           = dword ptr -0Ch
.text$mn:000083BC var_4           = dword ptr -4
.text$mn:000083BC arg_0           = byte ptr  8
.text$mn:000083BC arg_C           = byte ptr  14h
.text$mn:000083BC arg_18          = dword ptr  20h
.text$mn:000083BC arg_1C          = dword ptr  24h
.text$mn:000083BC
.text$mn:000083BC                 push    ebp
.text$mn:000083BD                 mov     ebp, esp
.text$mn:000083BF                 push    0FFFFFFFFh
.text$mn:000083C1                 push    offset __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
.text$mn:000083C6                 mov     eax, large fs:0
.text$mn:000083CC                 push    eax
.text$mn:000083CD                 sub     esp, 28h
.text$mn:000083D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000083D5                 xor     eax, ebp
.text$mn:000083D7                 push    eax
.text$mn:000083D8                 lea     eax, [ebp+var_C]
.text$mn:000083DB                 mov     large fs:0, eax
.text$mn:000083E1                 mov     [ebp+var_4], 1
.text$mn:000083E8                 mov     eax, [ebp+arg_1C]
.text$mn:000083EB                 push    eax             ; int
.text$mn:000083EC                 mov     ecx, [ebp+arg_18]
.text$mn:000083EF                 push    ecx
.text$mn:000083F0                 call    ??$_Unchecked@PAI@std@@YAPAIPAI@Z ; std::_Unchecked<uint *>(uint *)
.text$mn:000083F5                 add     esp, 4
.text$mn:000083F8                 push    eax             ; Dst
.text$mn:000083F9                 sub     esp, 0Ch
.text$mn:000083FC                 mov     ecx, esp
.text$mn:000083FE                 mov     [ebp+var_28], esp
.text$mn:00008401                 lea     edx, [ebp+arg_C]
.text$mn:00008404                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00008405                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>> const &)
.text$mn:0000840A                 mov     [ebp+var_10], eax
.text$mn:0000840D                 mov     eax, [ebp+var_10]
.text$mn:00008410                 mov     [ebp+var_2C], eax
.text$mn:00008413                 mov     byte ptr [ebp+var_4], 2
.text$mn:00008417                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000841B                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>)
.text$mn:00008420                 add     esp, 0Ch
.text$mn:00008423                 mov     [ebp+var_14], eax
.text$mn:00008426                 mov     ecx, [ebp+var_14]
.text$mn:00008429                 push    ecx             ; int
.text$mn:0000842A                 sub     esp, 0Ch
.text$mn:0000842D                 mov     ecx, esp
.text$mn:0000842F                 mov     [ebp+var_30], esp
.text$mn:00008432                 lea     edx, [ebp+arg_0]
.text$mn:00008435                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00008436                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>> const &)
.text$mn:0000843B                 mov     [ebp+var_18], eax
.text$mn:0000843E                 mov     eax, [ebp+var_18]
.text$mn:00008441                 mov     [ebp+var_34], eax
.text$mn:00008444                 mov     byte ptr [ebp+var_4], 3
.text$mn:00008448                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000844C                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>)
.text$mn:00008451                 add     esp, 0Ch
.text$mn:00008454                 mov     [ebp+Src], eax
.text$mn:00008457                 mov     ecx, [ebp+Src]
.text$mn:0000845A                 push    ecx             ; Src
.text$mn:0000845B                 call    ??$_Uninit_copy@PBIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPBI0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Uninit_copy<uint const *,uint *,std::_Wrap_alloc<std::allocator<uint>>>(uint const *,uint const *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)
.text$mn:00008460                 add     esp, 10h
.text$mn:00008463                 mov     [ebp+var_20], eax
.text$mn:00008466                 mov     edx, [ebp+var_20]
.text$mn:00008469                 push    edx
.text$mn:0000846A                 lea     eax, [ebp+arg_18]
.text$mn:0000846D                 push    eax
.text$mn:0000846E                 call    ??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z ; std::_Rechecked<uint *,uint *>(uint * &,uint *)
.text$mn:00008473                 add     esp, 8
.text$mn:00008476                 mov     ecx, [eax]
.text$mn:00008478                 mov     [ebp+var_24], ecx
.text$mn:0000847B                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000847F                 lea     ecx, [ebp+arg_0]
.text$mn:00008482                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$mn:00008487                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000848E                 lea     ecx, [ebp+arg_C]
.text$mn:00008491                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$mn:00008496                 mov     eax, [ebp+var_24]
.text$mn:00008499                 mov     ecx, [ebp+var_C]
.text$mn:0000849C                 mov     large fs:0, ecx
.text$mn:000084A3                 pop     ecx
.text$mn:000084A4                 mov     esp, ebp
.text$mn:000084A6                 pop     ebp
.text$mn:000084A7                 retn
.text$mn:000084A7 ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z endp
.text$mn:000084A7
.text$mn:000084A7 _text$mn        ends
.text$mn:000084A7
.text$x:000084A8 ; ===========================================================================
.text$x:000084A8
.text$x:000084A8 ; Segment type: Pure code
.text$x:000084A8 ; Segment permissions: Read/Execute
.text$x:000084A8 _text$x         segment para public 'CODE' use32
.text$x:000084A8                 assume cs:_text$x
.text$x:000084A8                 ;org 84A8h
.text$x:000084A8 ; COMDAT (pick associative to section at 83BC)
.text$x:000084A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000084A8
.text$x:000084A8 ; =============== S U B R O U T I N E =======================================
.text$x:000084A8
.text$x:000084A8
.text$x:000084A8 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z$0 proc near
.text$x:000084A8                                         ; DATA XREF: .xdata$x:000142D4o
.text$x:000084A8                 lea     ecx, [ebp+14h]
.text$x:000084AB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$x:000084AB __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z$0 endp
.text$x:000084AB
.text$x:000084B0
.text$x:000084B0 ; =============== S U B R O U T I N E =======================================
.text$x:000084B0
.text$x:000084B0
.text$x:000084B0 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z$1 proc near
.text$x:000084B0                                         ; DATA XREF: .xdata$x:000142DCo
.text$x:000084B0                 lea     ecx, [ebp+8]
.text$x:000084B3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$x:000084B3 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z$1 endp
.text$x:000084B3
.text$x:000084B8
.text$x:000084B8 ; =============== S U B R O U T I N E =======================================
.text$x:000084B8
.text$x:000084B8
.text$x:000084B8 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z$2 proc near
.text$x:000084B8                                         ; DATA XREF: .xdata$x:000142E4o
.text$x:000084B8                 mov     ecx, [ebp-28h]
.text$x:000084BB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$x:000084BB __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z$2 endp
.text$x:000084BB
.text$x:000084C0
.text$x:000084C0 ; =============== S U B R O U T I N E =======================================
.text$x:000084C0
.text$x:000084C0
.text$x:000084C0 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z$3 proc near
.text$x:000084C0                                         ; DATA XREF: .xdata$x:000142ECo
.text$x:000084C0                 mov     ecx, [ebp-30h]
.text$x:000084C3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$x:000084C3 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z$3 endp
.text$x:000084C3
.text$x:000084C8
.text$x:000084C8 ; =============== S U B R O U T I N E =======================================
.text$x:000084C8
.text$x:000084C8
.text$x:000084C8 __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z proc near
.text$x:000084C8                                         ; DATA XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *,std::_Wrap_alloc<std::allocator<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+5o
.text$x:000084C8
.text$x:000084C8 arg_4           = dword ptr  8
.text$x:000084C8
.text$x:000084C8                 mov     edx, [esp+arg_4]
.text$x:000084CC                 lea     eax, [edx+0Ch]
.text$x:000084CF                 mov     ecx, [edx-2Ch]
.text$x:000084D2                 xor     ecx, eax
.text$x:000084D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000084D9                 mov     eax, offset __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
.text$x:000084DE                 jmp     ___CxxFrameHandler3
.text$x:000084DE __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z endp
.text$x:000084DE
.text$x:000084DE ; ---------------------------------------------------------------------------
.text$x:000084E3                 align 4
.text$x:000084E3 _text$x         ends
.text$x:000084E3
.text$mn:000084E4 ; ===========================================================================
.text$mn:000084E4
.text$mn:000084E4 ; Segment type: Pure code
.text$mn:000084E4 ; Segment permissions: Read/Execute
.text$mn:000084E4 _text$mn        segment para public 'CODE' use32
.text$mn:000084E4                 assume cs:_text$mn
.text$mn:000084E4                 ;org 84E4h
.text$mn:000084E4 ; COMDAT (pick any)
.text$mn:000084E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000084E4
.text$mn:000084E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000084E4
.text$mn:000084E4 ; Attributes: bp-based frame
.text$mn:000084E4
.text$mn:000084E4 ; struct sessionFileInfo * __cdecl std::_Uninitialized_copy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>, struct sessionFileInfo *, struct std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>, struct sessionFileInfo *, struct std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>> &)
.text$mn:000084E4                 public ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z
.text$mn:000084E4 ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z proc near
.text$mn:000084E4                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *)+83p
.text$mn:000084E4
.text$mn:000084E4 var_34          = dword ptr -34h
.text$mn:000084E4 var_30          = dword ptr -30h
.text$mn:000084E4 var_2C          = dword ptr -2Ch
.text$mn:000084E4 var_28          = dword ptr -28h
.text$mn:000084E4 var_24          = dword ptr -24h
.text$mn:000084E4 var_20          = dword ptr -20h
.text$mn:000084E4 var_1C          = dword ptr -1Ch
.text$mn:000084E4 var_18          = dword ptr -18h
.text$mn:000084E4 var_14          = dword ptr -14h
.text$mn:000084E4 var_10          = dword ptr -10h
.text$mn:000084E4 var_C           = dword ptr -0Ch
.text$mn:000084E4 var_4           = dword ptr -4
.text$mn:000084E4 arg_0           = byte ptr  8
.text$mn:000084E4 arg_C           = byte ptr  14h
.text$mn:000084E4 arg_18          = dword ptr  20h
.text$mn:000084E4 arg_1C          = dword ptr  24h
.text$mn:000084E4
.text$mn:000084E4                 push    ebp
.text$mn:000084E5                 mov     ebp, esp
.text$mn:000084E7                 push    0FFFFFFFFh
.text$mn:000084E9                 push    offset __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z
.text$mn:000084EE                 mov     eax, large fs:0
.text$mn:000084F4                 push    eax
.text$mn:000084F5                 sub     esp, 28h
.text$mn:000084F8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000084FD                 xor     eax, ebp
.text$mn:000084FF                 push    eax
.text$mn:00008500                 lea     eax, [ebp+var_C]
.text$mn:00008503                 mov     large fs:0, eax
.text$mn:00008509                 mov     [ebp+var_4], 1
.text$mn:00008510                 mov     eax, [ebp+arg_1C]
.text$mn:00008513                 push    eax             ; int
.text$mn:00008514                 mov     ecx, [ebp+arg_18]
.text$mn:00008517                 push    ecx
.text$mn:00008518                 call    ??$_Unchecked@PAUsessionFileInfo@@@std@@YAPAUsessionFileInfo@@PAU1@@Z ; std::_Unchecked<sessionFileInfo *>(sessionFileInfo *)
.text$mn:0000851D                 add     esp, 4
.text$mn:00008520                 push    eax             ; void *
.text$mn:00008521                 sub     esp, 0Ch
.text$mn:00008524                 mov     ecx, esp
.text$mn:00008526                 mov     [ebp+var_28], esp
.text$mn:00008529                 lea     edx, [ebp+arg_C]
.text$mn:0000852C                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000852D                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>> const &)
.text$mn:00008532                 mov     [ebp+var_10], eax
.text$mn:00008535                 mov     eax, [ebp+var_10]
.text$mn:00008538                 mov     [ebp+var_2C], eax
.text$mn:0000853B                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000853F                 mov     byte ptr [ebp+var_4], 1
.text$mn:00008543                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)
.text$mn:00008548                 add     esp, 0Ch
.text$mn:0000854B                 mov     [ebp+var_14], eax
.text$mn:0000854E                 mov     ecx, [ebp+var_14]
.text$mn:00008551                 push    ecx             ; int
.text$mn:00008552                 sub     esp, 0Ch
.text$mn:00008555                 mov     ecx, esp
.text$mn:00008557                 mov     [ebp+var_30], esp
.text$mn:0000855A                 lea     edx, [ebp+arg_0]
.text$mn:0000855D                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000855E                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>> const &)
.text$mn:00008563                 mov     [ebp+var_18], eax
.text$mn:00008566                 mov     eax, [ebp+var_18]
.text$mn:00008569                 mov     [ebp+var_34], eax
.text$mn:0000856C                 mov     byte ptr [ebp+var_4], 3
.text$mn:00008570                 mov     byte ptr [ebp+var_4], 1
.text$mn:00008574                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)
.text$mn:00008579                 add     esp, 0Ch
.text$mn:0000857C                 mov     [ebp+var_1C], eax
.text$mn:0000857F                 mov     ecx, [ebp+var_1C]
.text$mn:00008582                 push    ecx             ; int
.text$mn:00008583                 call    ??$_Uninit_copy@PBUsessionFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z ; std::_Uninit_copy<sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo const *,sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)
.text$mn:00008588                 add     esp, 10h
.text$mn:0000858B                 mov     [ebp+var_20], eax
.text$mn:0000858E                 mov     edx, [ebp+var_20]
.text$mn:00008591                 push    edx
.text$mn:00008592                 lea     eax, [ebp+arg_18]
.text$mn:00008595                 push    eax
.text$mn:00008596                 call    ??$_Rechecked@PAUsessionFileInfo@@PAU1@@std@@YAAAPAUsessionFileInfo@@AAPAU1@PAU1@@Z ; std::_Rechecked<sessionFileInfo *,sessionFileInfo *>(sessionFileInfo * &,sessionFileInfo *)
.text$mn:0000859B                 add     esp, 8
.text$mn:0000859E                 mov     ecx, [eax]
.text$mn:000085A0                 mov     [ebp+var_24], ecx
.text$mn:000085A3                 mov     byte ptr [ebp+var_4], 0
.text$mn:000085A7                 lea     ecx, [ebp+arg_0]
.text$mn:000085AA                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:000085AF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000085B6                 lea     ecx, [ebp+arg_C]
.text$mn:000085B9                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:000085BE                 mov     eax, [ebp+var_24]
.text$mn:000085C1                 mov     ecx, [ebp+var_C]
.text$mn:000085C4                 mov     large fs:0, ecx
.text$mn:000085CB                 pop     ecx
.text$mn:000085CC                 mov     esp, ebp
.text$mn:000085CE                 pop     ebp
.text$mn:000085CF                 retn
.text$mn:000085CF ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z endp
.text$mn:000085CF
.text$mn:000085CF _text$mn        ends
.text$mn:000085CF
.text$x:000085D0 ; ===========================================================================
.text$x:000085D0
.text$x:000085D0 ; Segment type: Pure code
.text$x:000085D0 ; Segment permissions: Read/Execute
.text$x:000085D0 _text$x         segment para public 'CODE' use32
.text$x:000085D0                 assume cs:_text$x
.text$x:000085D0                 ;org 85D0h
.text$x:000085D0 ; COMDAT (pick associative to section at 84E4)
.text$x:000085D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000085D0
.text$x:000085D0 ; =============== S U B R O U T I N E =======================================
.text$x:000085D0
.text$x:000085D0
.text$x:000085D0 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z$0 proc near
.text$x:000085D0                                         ; DATA XREF: .xdata$x:00013F34o
.text$x:000085D0                 lea     ecx, [ebp+14h]
.text$x:000085D3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:000085D3 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z$0 endp
.text$x:000085D3
.text$x:000085D8
.text$x:000085D8 ; =============== S U B R O U T I N E =======================================
.text$x:000085D8
.text$x:000085D8
.text$x:000085D8 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z$1 proc near
.text$x:000085D8                                         ; DATA XREF: .xdata$x:00013F3Co
.text$x:000085D8                 lea     ecx, [ebp+8]
.text$x:000085DB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:000085DB __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z$1 endp
.text$x:000085DB
.text$x:000085E0
.text$x:000085E0 ; =============== S U B R O U T I N E =======================================
.text$x:000085E0
.text$x:000085E0
.text$x:000085E0 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z$2 proc near
.text$x:000085E0                                         ; DATA XREF: .xdata$x:00013F44o
.text$x:000085E0                 mov     ecx, [ebp-28h]
.text$x:000085E3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:000085E3 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z$2 endp
.text$x:000085E3
.text$x:000085E8
.text$x:000085E8 ; =============== S U B R O U T I N E =======================================
.text$x:000085E8
.text$x:000085E8
.text$x:000085E8 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z$3 proc near
.text$x:000085E8                                         ; DATA XREF: .xdata$x:00013F4Co
.text$x:000085E8                 mov     ecx, [ebp-30h]
.text$x:000085EB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:000085EB __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z$3 endp
.text$x:000085EB
.text$x:000085F0
.text$x:000085F0 ; =============== S U B R O U T I N E =======================================
.text$x:000085F0
.text$x:000085F0
.text$x:000085F0 __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z proc near
.text$x:000085F0                                         ; DATA XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)+5o
.text$x:000085F0
.text$x:000085F0 arg_4           = dword ptr  8
.text$x:000085F0
.text$x:000085F0                 mov     edx, [esp+arg_4]
.text$x:000085F4                 lea     eax, [edx+0Ch]
.text$x:000085F7                 mov     ecx, [edx-2Ch]
.text$x:000085FA                 xor     ecx, eax
.text$x:000085FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008601                 mov     eax, offset __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z
.text$x:00008606                 jmp     ___CxxFrameHandler3
.text$x:00008606 __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z endp
.text$x:00008606
.text$x:00008606 ; ---------------------------------------------------------------------------
.text$x:0000860B                 align 4
.text$x:0000860B _text$x         ends
.text$x:0000860B
.text$mn:0000860C ; ===========================================================================
.text$mn:0000860C
.text$mn:0000860C ; Segment type: Pure code
.text$mn:0000860C ; Segment permissions: Read/Execute
.text$mn:0000860C _text$mn        segment para public 'CODE' use32
.text$mn:0000860C                 assume cs:_text$mn
.text$mn:0000860C                 ;org 860Ch
.text$mn:0000860C ; COMDAT (pick any)
.text$mn:0000860C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000860C
.text$mn:0000860C ; =============== S U B R O U T I N E =======================================
.text$mn:0000860C
.text$mn:0000860C ; Attributes: bp-based frame
.text$mn:0000860C
.text$mn:0000860C ; int * __cdecl std::_Uninitialized_move<int *, int *, struct std::_Wrap_alloc<class std::allocator<int>>>(int *, int *, int *, struct std::_Wrap_alloc<class std::allocator<int>> &)
.text$mn:0000860C                 public ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
.text$mn:0000860C ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z proc near
.text$mn:0000860C                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Umove<int *>(int *,int *,int *)+25p
.text$mn:0000860C
.text$mn:0000860C arg_0           = dword ptr  8
.text$mn:0000860C arg_4           = dword ptr  0Ch
.text$mn:0000860C arg_8           = dword ptr  10h
.text$mn:0000860C arg_C           = dword ptr  14h
.text$mn:0000860C
.text$mn:0000860C                 push    ebp
.text$mn:0000860D                 mov     ebp, esp
.text$mn:0000860F                 mov     eax, [ebp+arg_C]
.text$mn:00008612                 push    eax             ; int
.text$mn:00008613                 mov     ecx, [ebp+arg_8]
.text$mn:00008616                 push    ecx
.text$mn:00008617                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:0000861C                 add     esp, 4
.text$mn:0000861F                 push    eax             ; Dst
.text$mn:00008620                 mov     edx, [ebp+arg_4]
.text$mn:00008623                 push    edx
.text$mn:00008624                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:00008629                 add     esp, 4
.text$mn:0000862C                 push    eax             ; int
.text$mn:0000862D                 mov     eax, [ebp+arg_0]
.text$mn:00008630                 push    eax
.text$mn:00008631                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:00008636                 add     esp, 4
.text$mn:00008639                 push    eax             ; Src
.text$mn:0000863A                 call    ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)
.text$mn:0000863F                 add     esp, 10h
.text$mn:00008642                 push    eax
.text$mn:00008643                 lea     ecx, [ebp+arg_8]
.text$mn:00008646                 push    ecx
.text$mn:00008647                 call    ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z ; std::_Rechecked<int *,int *>(int * &,int *)
.text$mn:0000864C                 add     esp, 8
.text$mn:0000864F                 mov     eax, [eax]
.text$mn:00008651                 pop     ebp
.text$mn:00008652                 retn
.text$mn:00008652 ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z endp
.text$mn:00008652
.text$mn:00008652 ; ---------------------------------------------------------------------------
.text$mn:00008653                 align 4
.text$mn:00008653 _text$mn        ends
.text$mn:00008653
.text$mn:00008654 ; ===========================================================================
.text$mn:00008654
.text$mn:00008654 ; Segment type: Pure code
.text$mn:00008654 ; Segment permissions: Read/Execute
.text$mn:00008654 _text$mn        segment para public 'CODE' use32
.text$mn:00008654                 assume cs:_text$mn
.text$mn:00008654                 ;org 8654h
.text$mn:00008654 ; COMDAT (pick any)
.text$mn:00008654                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008654
.text$mn:00008654 ; =============== S U B R O U T I N E =======================================
.text$mn:00008654
.text$mn:00008654 ; Attributes: bp-based frame
.text$mn:00008654
.text$mn:00008654 ; struct sessionFileInfo * __cdecl std::_Uninitialized_move<struct sessionFileInfo *, struct sessionFileInfo *, struct std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>>>(struct sessionFileInfo *, struct sessionFileInfo *, struct sessionFileInfo *, struct std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>> &)
.text$mn:00008654                 public ??$_Uninitialized_move@PAUsessionFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z
.text$mn:00008654 ??$_Uninitialized_move@PAUsessionFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z proc near
.text$mn:00008654                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Umove<sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *)+25p
.text$mn:00008654
.text$mn:00008654 arg_0           = dword ptr  8
.text$mn:00008654 arg_4           = dword ptr  0Ch
.text$mn:00008654 arg_8           = dword ptr  10h
.text$mn:00008654 arg_C           = dword ptr  14h
.text$mn:00008654
.text$mn:00008654                 push    ebp
.text$mn:00008655                 mov     ebp, esp
.text$mn:00008657                 mov     eax, [ebp+arg_C]
.text$mn:0000865A                 push    eax             ; int
.text$mn:0000865B                 mov     ecx, [ebp+arg_8]
.text$mn:0000865E                 push    ecx
.text$mn:0000865F                 call    ??$_Unchecked@PAUsessionFileInfo@@@std@@YAPAUsessionFileInfo@@PAU1@@Z ; std::_Unchecked<sessionFileInfo *>(sessionFileInfo *)
.text$mn:00008664                 add     esp, 4
.text$mn:00008667                 push    eax             ; void *
.text$mn:00008668                 mov     edx, [ebp+arg_4]
.text$mn:0000866B                 push    edx
.text$mn:0000866C                 call    ??$_Unchecked@PAUsessionFileInfo@@@std@@YAPAUsessionFileInfo@@PAU1@@Z ; std::_Unchecked<sessionFileInfo *>(sessionFileInfo *)
.text$mn:00008671                 add     esp, 4
.text$mn:00008674                 push    eax             ; int
.text$mn:00008675                 mov     eax, [ebp+arg_0]
.text$mn:00008678                 push    eax
.text$mn:00008679                 call    ??$_Unchecked@PAUsessionFileInfo@@@std@@YAPAUsessionFileInfo@@PAU1@@Z ; std::_Unchecked<sessionFileInfo *>(sessionFileInfo *)
.text$mn:0000867E                 add     esp, 4
.text$mn:00008681                 push    eax             ; int
.text$mn:00008682                 call    ??$_Uninit_move@PAUsessionFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z ; std::_Uninit_move<sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)
.text$mn:00008687                 add     esp, 10h
.text$mn:0000868A                 push    eax
.text$mn:0000868B                 lea     ecx, [ebp+arg_8]
.text$mn:0000868E                 push    ecx
.text$mn:0000868F                 call    ??$_Rechecked@PAUsessionFileInfo@@PAU1@@std@@YAAAPAUsessionFileInfo@@AAPAU1@PAU1@@Z ; std::_Rechecked<sessionFileInfo *,sessionFileInfo *>(sessionFileInfo * &,sessionFileInfo *)
.text$mn:00008694                 add     esp, 8
.text$mn:00008697                 mov     eax, [eax]
.text$mn:00008699                 pop     ebp
.text$mn:0000869A                 retn
.text$mn:0000869A ??$_Uninitialized_move@PAUsessionFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z endp
.text$mn:0000869A
.text$mn:0000869A ; ---------------------------------------------------------------------------
.text$mn:0000869B                 align 4
.text$mn:0000869B _text$mn        ends
.text$mn:0000869B
.text$mn:0000869C ; ===========================================================================
.text$mn:0000869C
.text$mn:0000869C ; Segment type: Pure code
.text$mn:0000869C ; Segment permissions: Read/Execute
.text$mn:0000869C _text$mn        segment para public 'CODE' use32
.text$mn:0000869C                 assume cs:_text$mn
.text$mn:0000869C                 ;org 869Ch
.text$mn:0000869C ; COMDAT (pick any)
.text$mn:0000869C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000869C
.text$mn:0000869C ; =============== S U B R O U T I N E =======================================
.text$mn:0000869C
.text$mn:0000869C ; Attributes: bp-based frame
.text$mn:0000869C
.text$mn:0000869C ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __cdecl std::_Uninitialized_move<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> &)
.text$mn:0000869C                 public ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z
.text$mn:0000869C ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z proc near
.text$mn:0000869C                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Umove<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+25p
.text$mn:0000869C
.text$mn:0000869C arg_0           = dword ptr  8
.text$mn:0000869C arg_4           = dword ptr  0Ch
.text$mn:0000869C arg_8           = dword ptr  10h
.text$mn:0000869C arg_C           = dword ptr  14h
.text$mn:0000869C
.text$mn:0000869C                 push    ebp
.text$mn:0000869D                 mov     ebp, esp
.text$mn:0000869F                 mov     eax, [ebp+arg_C]
.text$mn:000086A2                 push    eax             ; int
.text$mn:000086A3                 mov     ecx, [ebp+arg_8]
.text$mn:000086A6                 push    ecx
.text$mn:000086A7                 call    ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z ; std::_Unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:000086AC                 add     esp, 4
.text$mn:000086AF                 push    eax             ; void *
.text$mn:000086B0                 mov     edx, [ebp+arg_4]
.text$mn:000086B3                 push    edx
.text$mn:000086B4                 call    ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z ; std::_Unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:000086B9                 add     esp, 4
.text$mn:000086BC                 push    eax             ; int
.text$mn:000086BD                 mov     eax, [ebp+arg_0]
.text$mn:000086C0                 push    eax
.text$mn:000086C1                 call    ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z ; std::_Unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:000086C6                 add     esp, 4
.text$mn:000086C9                 push    eax             ; int
.text$mn:000086CA                 call    ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z ; std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)
.text$mn:000086CF                 add     esp, 10h
.text$mn:000086D2                 push    eax
.text$mn:000086D3                 lea     ecx, [ebp+arg_8]
.text$mn:000086D6                 push    ecx
.text$mn:000086D7                 call    ??$_Rechecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAV10@PAV10@@Z ; std::_Rechecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> * &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:000086DC                 add     esp, 8
.text$mn:000086DF                 mov     eax, [eax]
.text$mn:000086E1                 pop     ebp
.text$mn:000086E2                 retn
.text$mn:000086E2 ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z endp
.text$mn:000086E2
.text$mn:000086E2 ; ---------------------------------------------------------------------------
.text$mn:000086E3                 align 4
.text$mn:000086E3 _text$mn        ends
.text$mn:000086E3
.text$mn:000086E4 ; ===========================================================================
.text$mn:000086E4
.text$mn:000086E4 ; Segment type: Pure code
.text$mn:000086E4 ; Segment permissions: Read/Execute
.text$mn:000086E4 _text$mn        segment para public 'CODE' use32
.text$mn:000086E4                 assume cs:_text$mn
.text$mn:000086E4                 ;org 86E4h
.text$mn:000086E4 ; COMDAT (pick any)
.text$mn:000086E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000086E4
.text$mn:000086E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000086E4
.text$mn:000086E4 ; Attributes: bp-based frame
.text$mn:000086E4
.text$mn:000086E4 ; int * __cdecl std::_Val_type<int *>(int *)
.text$mn:000086E4                 public ??$_Val_type@PAH@std@@YAPAHPAH@Z
.text$mn:000086E4 ??$_Val_type@PAH@std@@YAPAHPAH@Z proc near
.text$mn:000086E4                                         ; CODE XREF: std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+20p
.text$mn:000086E4                 push    ebp
.text$mn:000086E5                 mov     ebp, esp
.text$mn:000086E7                 xor     eax, eax
.text$mn:000086E9                 pop     ebp
.text$mn:000086EA                 retn
.text$mn:000086EA ??$_Val_type@PAH@std@@YAPAHPAH@Z endp
.text$mn:000086EA
.text$mn:000086EA ; ---------------------------------------------------------------------------
.text$mn:000086EB                 align 4
.text$mn:000086EB _text$mn        ends
.text$mn:000086EB
.text$mn:000086EC ; ===========================================================================
.text$mn:000086EC
.text$mn:000086EC ; Segment type: Pure code
.text$mn:000086EC ; Segment permissions: Read/Execute
.text$mn:000086EC _text$mn        segment para public 'CODE' use32
.text$mn:000086EC                 assume cs:_text$mn
.text$mn:000086EC                 ;org 86ECh
.text$mn:000086EC ; COMDAT (pick any)
.text$mn:000086EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000086EC
.text$mn:000086EC ; =============== S U B R O U T I N E =======================================
.text$mn:000086EC
.text$mn:000086EC ; Attributes: bp-based frame
.text$mn:000086EC
.text$mn:000086EC ; struct sessionFileInfo * __cdecl std::_Val_type<struct sessionFileInfo *>(struct sessionFileInfo *)
.text$mn:000086EC                 public ??$_Val_type@PAUsessionFileInfo@@@std@@YAPAUsessionFileInfo@@PAU1@@Z
.text$mn:000086EC ??$_Val_type@PAUsessionFileInfo@@@std@@YAPAUsessionFileInfo@@PAU1@@Z proc near
.text$mn:000086EC                                         ; CODE XREF: std::_Uninit_move<sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)+20p
.text$mn:000086EC                 push    ebp
.text$mn:000086ED                 mov     ebp, esp
.text$mn:000086EF                 xor     eax, eax
.text$mn:000086F1                 pop     ebp
.text$mn:000086F2                 retn
.text$mn:000086F2 ??$_Val_type@PAUsessionFileInfo@@@std@@YAPAUsessionFileInfo@@PAU1@@Z endp
.text$mn:000086F2
.text$mn:000086F2 ; ---------------------------------------------------------------------------
.text$mn:000086F3                 align 4
.text$mn:000086F3 _text$mn        ends
.text$mn:000086F3
.text$mn:000086F4 ; ===========================================================================
.text$mn:000086F4
.text$mn:000086F4 ; Segment type: Pure code
.text$mn:000086F4 ; Segment permissions: Read/Execute
.text$mn:000086F4 _text$mn        segment para public 'CODE' use32
.text$mn:000086F4                 assume cs:_text$mn
.text$mn:000086F4                 ;org 86F4h
.text$mn:000086F4 ; COMDAT (pick any)
.text$mn:000086F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000086F4
.text$mn:000086F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000086F4
.text$mn:000086F4 ; Attributes: bp-based frame
.text$mn:000086F4
.text$mn:000086F4 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __cdecl std::_Val_type<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:000086F4                 public ??$_Val_type@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z
.text$mn:000086F4 ??$_Val_type@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z proc near
.text$mn:000086F4                                         ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+20p
.text$mn:000086F4                 push    ebp
.text$mn:000086F5                 mov     ebp, esp
.text$mn:000086F7                 xor     eax, eax
.text$mn:000086F9                 pop     ebp
.text$mn:000086FA                 retn
.text$mn:000086FA ??$_Val_type@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z endp
.text$mn:000086FA
.text$mn:000086FA ; ---------------------------------------------------------------------------
.text$mn:000086FB                 align 4
.text$mn:000086FB _text$mn        ends
.text$mn:000086FB
.text$mn:000086FC ; ===========================================================================
.text$mn:000086FC
.text$mn:000086FC ; Segment type: Pure code
.text$mn:000086FC ; Segment permissions: Read/Execute
.text$mn:000086FC _text$mn        segment para public 'CODE' use32
.text$mn:000086FC                 assume cs:_text$mn
.text$mn:000086FC                 ;org 86FCh
.text$mn:000086FC ; COMDAT (pick any)
.text$mn:000086FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000086FC
.text$mn:000086FC ; =============== S U B R O U T I N E =======================================
.text$mn:000086FC
.text$mn:000086FC ; Attributes: bp-based frame
.text$mn:000086FC
.text$mn:000086FC ; int const * __cdecl std::addressof<int const>(int const &)
.text$mn:000086FC                 public ??$addressof@$$CBH@std@@YAPBHABH@Z
.text$mn:000086FC ??$addressof@$$CBH@std@@YAPBHABH@Z proc near
.text$mn:000086FC                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+Dp
.text$mn:000086FC                                         ; std::vector<int,std::allocator<int>>::push_back(int const &)+29p
.text$mn:000086FC
.text$mn:000086FC arg_0           = dword ptr  8
.text$mn:000086FC
.text$mn:000086FC                 push    ebp
.text$mn:000086FD                 mov     ebp, esp
.text$mn:000086FF                 mov     eax, [ebp+arg_0]
.text$mn:00008702                 pop     ebp
.text$mn:00008703                 retn
.text$mn:00008703 ??$addressof@$$CBH@std@@YAPBHABH@Z endp
.text$mn:00008703
.text$mn:00008703 _text$mn        ends
.text$mn:00008703
.text$mn:00008704 ; ===========================================================================
.text$mn:00008704
.text$mn:00008704 ; Segment type: Pure code
.text$mn:00008704 ; Segment permissions: Read/Execute
.text$mn:00008704 _text$mn        segment para public 'CODE' use32
.text$mn:00008704                 assume cs:_text$mn
.text$mn:00008704                 ;org 8704h
.text$mn:00008704 ; COMDAT (pick any)
.text$mn:00008704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008704
.text$mn:00008704 ; =============== S U B R O U T I N E =======================================
.text$mn:00008704
.text$mn:00008704 ; Attributes: bp-based frame
.text$mn:00008704
.text$mn:00008704 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00008704                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00008704 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00008704                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00008704                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00008704
.text$mn:00008704 arg_0           = dword ptr  8
.text$mn:00008704
.text$mn:00008704                 push    ebp
.text$mn:00008705                 mov     ebp, esp
.text$mn:00008707                 mov     eax, [ebp+arg_0]
.text$mn:0000870A                 pop     ebp
.text$mn:0000870B                 retn
.text$mn:0000870B ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:0000870B
.text$mn:0000870B _text$mn        ends
.text$mn:0000870B
.text$mn:0000870C ; ===========================================================================
.text$mn:0000870C
.text$mn:0000870C ; Segment type: Pure code
.text$mn:0000870C ; Segment permissions: Read/Execute
.text$mn:0000870C _text$mn        segment para public 'CODE' use32
.text$mn:0000870C                 assume cs:_text$mn
.text$mn:0000870C                 ;org 870Ch
.text$mn:0000870C ; COMDAT (pick any)
.text$mn:0000870C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000870C
.text$mn:0000870C ; =============== S U B R O U T I N E =======================================
.text$mn:0000870C
.text$mn:0000870C ; Attributes: bp-based frame
.text$mn:0000870C
.text$mn:0000870C ; struct sessionFileInfo * __cdecl std::addressof<struct sessionFileInfo>(struct sessionFileInfo &)
.text$mn:0000870C                 public ??$addressof@UsessionFileInfo@@@std@@YAPAUsessionFileInfo@@AAU1@@Z
.text$mn:0000870C ??$addressof@UsessionFileInfo@@@std@@YAPAUsessionFileInfo@@AAU1@@Z proc near
.text$mn:0000870C                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::push_back(sessionFileInfo &&)+Dp
.text$mn:0000870C                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::push_back(sessionFileInfo &&)+2Dp
.text$mn:0000870C
.text$mn:0000870C arg_0           = dword ptr  8
.text$mn:0000870C
.text$mn:0000870C                 push    ebp
.text$mn:0000870D                 mov     ebp, esp
.text$mn:0000870F                 mov     eax, [ebp+arg_0]
.text$mn:00008712                 pop     ebp
.text$mn:00008713                 retn
.text$mn:00008713 ??$addressof@UsessionFileInfo@@@std@@YAPAUsessionFileInfo@@AAU1@@Z endp
.text$mn:00008713
.text$mn:00008713 _text$mn        ends
.text$mn:00008713
.text$mn:00008714 ; ===========================================================================
.text$mn:00008714
.text$mn:00008714 ; Segment type: Pure code
.text$mn:00008714 ; Segment permissions: Read/Execute
.text$mn:00008714 _text$mn        segment para public 'CODE' use32
.text$mn:00008714                 assume cs:_text$mn
.text$mn:00008714                 ;org 8714h
.text$mn:00008714 ; COMDAT (pick any)
.text$mn:00008714                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008714
.text$mn:00008714 ; =============== S U B R O U T I N E =======================================
.text$mn:00008714
.text$mn:00008714 ; Attributes: bp-based frame
.text$mn:00008714
.text$mn:00008714 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __cdecl std::addressof<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &)
.text$mn:00008714                 public ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
.text$mn:00008714 ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z proc near
.text$mn:00008714                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+Dp
.text$mn:00008714                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+2Dp
.text$mn:00008714
.text$mn:00008714 arg_0           = dword ptr  8
.text$mn:00008714
.text$mn:00008714                 push    ebp
.text$mn:00008715                 mov     ebp, esp
.text$mn:00008717                 mov     eax, [ebp+arg_0]
.text$mn:0000871A                 pop     ebp
.text$mn:0000871B                 retn
.text$mn:0000871B ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z endp
.text$mn:0000871B
.text$mn:0000871B _text$mn        ends
.text$mn:0000871B
.text$mn:0000871C ; ===========================================================================
.text$mn:0000871C
.text$mn:0000871C ; Segment type: Pure code
.text$mn:0000871C ; Segment permissions: Read/Execute
.text$mn:0000871C _text$mn        segment para public 'CODE' use32
.text$mn:0000871C                 assume cs:_text$mn
.text$mn:0000871C                 ;org 871Ch
.text$mn:0000871C ; COMDAT (pick any)
.text$mn:0000871C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000871C
.text$mn:0000871C ; =============== S U B R O U T I N E =======================================
.text$mn:0000871C
.text$mn:0000871C ; Attributes: bp-based frame
.text$mn:0000871C
.text$mn:0000871C ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:0000871C                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:0000871C ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:0000871C                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:0000871C                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:0000871C
.text$mn:0000871C arg_0           = dword ptr  8
.text$mn:0000871C
.text$mn:0000871C                 push    ebp
.text$mn:0000871D                 mov     ebp, esp
.text$mn:0000871F                 mov     eax, [ebp+arg_0]
.text$mn:00008722                 pop     ebp
.text$mn:00008723                 retn
.text$mn:00008723 ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:00008723
.text$mn:00008723 _text$mn        ends
.text$mn:00008723
.text$mn:00008724 ; ===========================================================================
.text$mn:00008724
.text$mn:00008724 ; Segment type: Pure code
.text$mn:00008724 ; Segment permissions: Read/Execute
.text$mn:00008724 _text$mn        segment para public 'CODE' use32
.text$mn:00008724                 assume cs:_text$mn
.text$mn:00008724                 ;org 8724h
.text$mn:00008724 ; COMDAT (pick any)
.text$mn:00008724                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008724
.text$mn:00008724 ; =============== S U B R O U T I N E =======================================
.text$mn:00008724
.text$mn:00008724 ; Attributes: bp-based frame
.text$mn:00008724
.text$mn:00008724 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign<class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:00008724                 public ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$mn:00008724 ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z proc near
.text$mn:00008724                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+CBp
.text$mn:00008724
.text$mn:00008724 var_70          = byte ptr -70h
.text$mn:00008724 var_64          = byte ptr -64h
.text$mn:00008724 var_58          = dword ptr -58h
.text$mn:00008724 var_54          = dword ptr -54h
.text$mn:00008724 var_50          = dword ptr -50h
.text$mn:00008724 var_4C          = dword ptr -4Ch
.text$mn:00008724 var_48          = dword ptr -48h
.text$mn:00008724 var_44          = dword ptr -44h
.text$mn:00008724 var_40          = dword ptr -40h
.text$mn:00008724 var_3C          = dword ptr -3Ch
.text$mn:00008724 var_38          = dword ptr -38h
.text$mn:00008724 var_34          = dword ptr -34h
.text$mn:00008724 var_30          = dword ptr -30h
.text$mn:00008724 var_2C          = dword ptr -2Ch
.text$mn:00008724 var_28          = dword ptr -28h
.text$mn:00008724 var_24          = dword ptr -24h
.text$mn:00008724 var_20          = dword ptr -20h
.text$mn:00008724 var_1C          = dword ptr -1Ch
.text$mn:00008724 var_18          = dword ptr -18h
.text$mn:00008724 var_14          = dword ptr -14h
.text$mn:00008724 var_10          = dword ptr -10h
.text$mn:00008724 var_C           = dword ptr -0Ch
.text$mn:00008724 var_4           = dword ptr -4
.text$mn:00008724 arg_0           = byte ptr  8
.text$mn:00008724 arg_C           = byte ptr  14h
.text$mn:00008724
.text$mn:00008724                 push    ebp
.text$mn:00008725                 mov     ebp, esp
.text$mn:00008727                 push    0FFFFFFFFh
.text$mn:00008729                 push    offset __ehhandler$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$mn:0000872E                 mov     eax, large fs:0
.text$mn:00008734                 push    eax
.text$mn:00008735                 sub     esp, 64h
.text$mn:00008738                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000873D                 xor     eax, ebp
.text$mn:0000873F                 push    eax
.text$mn:00008740                 lea     eax, [ebp+var_C]
.text$mn:00008743                 mov     large fs:0, eax
.text$mn:00008749                 mov     [ebp+var_10], ecx
.text$mn:0000874C                 mov     [ebp+var_4], 1
.text$mn:00008753                 sub     esp, 0Ch
.text$mn:00008756                 mov     ecx, esp
.text$mn:00008758                 mov     [ebp+var_3C], esp
.text$mn:0000875B                 lea     eax, [ebp+arg_C]
.text$mn:0000875E                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000875F                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00008764                 mov     [ebp+var_14], eax
.text$mn:00008767                 mov     ecx, [ebp+var_14]
.text$mn:0000876A                 mov     [ebp+var_40], ecx
.text$mn:0000876D                 mov     byte ptr [ebp+var_4], 2
.text$mn:00008771                 sub     esp, 0Ch
.text$mn:00008774                 mov     ecx, esp
.text$mn:00008776                 mov     [ebp+var_44], esp
.text$mn:00008779                 lea     edx, [ebp+arg_0]
.text$mn:0000877C                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000877D                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00008782                 mov     [ebp+var_18], eax
.text$mn:00008785                 mov     eax, [ebp+var_18]
.text$mn:00008788                 mov     [ebp+var_48], eax
.text$mn:0000878B                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000878F                 lea     ecx, [ebp+var_70]
.text$mn:00008792                 push    ecx
.text$mn:00008793                 mov     ecx, [ebp+var_10]
.text$mn:00008796                 call    ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)
.text$mn:0000879B                 mov     [ebp+var_1C], eax
.text$mn:0000879E                 mov     edx, [ebp+var_1C]
.text$mn:000087A1                 mov     [ebp+var_20], edx
.text$mn:000087A4                 mov     byte ptr [ebp+var_4], 4
.text$mn:000087A8                 sub     esp, 0Ch
.text$mn:000087AB                 mov     ecx, esp
.text$mn:000087AD                 mov     [ebp+var_4C], esp
.text$mn:000087B0                 mov     eax, [ebp+var_20]
.text$mn:000087B3                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000087B4                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000087B9                 mov     [ebp+var_24], eax
.text$mn:000087BC                 mov     ecx, [ebp+var_24]
.text$mn:000087BF                 mov     [ebp+var_50], ecx
.text$mn:000087C2                 mov     byte ptr [ebp+var_4], 5
.text$mn:000087C6                 lea     edx, [ebp+var_64]
.text$mn:000087C9                 push    edx
.text$mn:000087CA                 mov     ecx, [ebp+var_10]
.text$mn:000087CD                 call    ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)
.text$mn:000087D2                 mov     [ebp+var_28], eax
.text$mn:000087D5                 mov     eax, [ebp+var_28]
.text$mn:000087D8                 mov     [ebp+var_2C], eax
.text$mn:000087DB                 mov     byte ptr [ebp+var_4], 6
.text$mn:000087DF                 sub     esp, 0Ch
.text$mn:000087E2                 mov     ecx, esp
.text$mn:000087E4                 mov     [ebp+var_54], esp
.text$mn:000087E7                 mov     edx, [ebp+var_2C]
.text$mn:000087EA                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000087EB                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000087F0                 mov     [ebp+var_30], eax
.text$mn:000087F3                 mov     eax, [ebp+var_30]
.text$mn:000087F6                 mov     [ebp+var_58], eax
.text$mn:000087F9                 mov     byte ptr [ebp+var_4], 7
.text$mn:000087FD                 mov     byte ptr [ebp+var_4], 9
.text$mn:00008801                 mov     ecx, [ebp+var_10]
.text$mn:00008804                 call    ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00008809                 mov     [ebp+var_34], eax
.text$mn:0000880C                 mov     ecx, [ebp+var_34]
.text$mn:0000880F                 mov     [ebp+var_38], ecx
.text$mn:00008812                 mov     byte ptr [ebp+var_4], 8
.text$mn:00008816                 lea     ecx, [ebp+var_64]
.text$mn:00008819                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000881E                 mov     byte ptr [ebp+var_4], 1
.text$mn:00008822                 lea     ecx, [ebp+var_70]
.text$mn:00008825                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000882A                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000882E                 lea     ecx, [ebp+arg_0]
.text$mn:00008831                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00008836                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000883D                 lea     ecx, [ebp+arg_C]
.text$mn:00008840                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00008845                 mov     eax, [ebp+var_38]
.text$mn:00008848                 mov     ecx, [ebp+var_C]
.text$mn:0000884B                 mov     large fs:0, ecx
.text$mn:00008852                 pop     ecx
.text$mn:00008853                 mov     esp, ebp
.text$mn:00008855                 pop     ebp
.text$mn:00008856                 retn    18h
.text$mn:00008856 ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z endp
.text$mn:00008856
.text$mn:00008856 ; ---------------------------------------------------------------------------
.text$mn:00008859                 align 4
.text$mn:00008859 _text$mn        ends
.text$mn:00008859
.text$x:0000885C ; ===========================================================================
.text$x:0000885C
.text$x:0000885C ; Segment type: Pure code
.text$x:0000885C ; Segment permissions: Read/Execute
.text$x:0000885C _text$x         segment para public 'CODE' use32
.text$x:0000885C                 assume cs:_text$x
.text$x:0000885C                 ;org 885Ch
.text$x:0000885C ; COMDAT (pick associative to section at 8724)
.text$x:0000885C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000885C
.text$x:0000885C ; =============== S U B R O U T I N E =======================================
.text$x:0000885C
.text$x:0000885C
.text$x:0000885C __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0 proc near
.text$x:0000885C                                         ; DATA XREF: .xdata$x:00013E74o
.text$x:0000885C                 lea     ecx, [ebp+14h]
.text$x:0000885F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000885F __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0 endp
.text$x:0000885F
.text$x:00008864
.text$x:00008864 ; =============== S U B R O U T I N E =======================================
.text$x:00008864
.text$x:00008864
.text$x:00008864 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1 proc near
.text$x:00008864                                         ; DATA XREF: .xdata$x:00013E7Co
.text$x:00008864                 lea     ecx, [ebp+8]
.text$x:00008867                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00008867 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1 endp
.text$x:00008867
.text$x:0000886C
.text$x:0000886C ; =============== S U B R O U T I N E =======================================
.text$x:0000886C
.text$x:0000886C
.text$x:0000886C __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2 proc near
.text$x:0000886C                                         ; DATA XREF: .xdata$x:00013E84o
.text$x:0000886C                 mov     ecx, [ebp-3Ch]
.text$x:0000886F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000886F __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2 endp
.text$x:0000886F
.text$x:00008874
.text$x:00008874 ; =============== S U B R O U T I N E =======================================
.text$x:00008874
.text$x:00008874
.text$x:00008874 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3 proc near
.text$x:00008874                                         ; DATA XREF: .xdata$x:00013E8Co
.text$x:00008874                 mov     ecx, [ebp-44h]
.text$x:00008877                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00008877 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3 endp
.text$x:00008877
.text$x:0000887C
.text$x:0000887C ; =============== S U B R O U T I N E =======================================
.text$x:0000887C
.text$x:0000887C
.text$x:0000887C __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4 proc near
.text$x:0000887C                                         ; DATA XREF: .xdata$x:00013E94o
.text$x:0000887C                                         ; .xdata$x:00013EB4o
.text$x:0000887C                 lea     ecx, [ebp-70h]
.text$x:0000887F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000887F __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4 endp
.text$x:0000887F
.text$x:00008884
.text$x:00008884 ; =============== S U B R O U T I N E =======================================
.text$x:00008884
.text$x:00008884
.text$x:00008884 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$5 proc near
.text$x:00008884                                         ; DATA XREF: .xdata$x:00013E9Co
.text$x:00008884                 mov     ecx, [ebp-4Ch]
.text$x:00008887                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00008887 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$5 endp
.text$x:00008887
.text$x:0000888C
.text$x:0000888C ; =============== S U B R O U T I N E =======================================
.text$x:0000888C
.text$x:0000888C
.text$x:0000888C __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$6 proc near
.text$x:0000888C                                         ; DATA XREF: .xdata$x:00013EA4o
.text$x:0000888C                                         ; .xdata$x:00013EBCo
.text$x:0000888C                 lea     ecx, [ebp-64h]
.text$x:0000888F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000888F __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$6 endp
.text$x:0000888F
.text$x:00008894
.text$x:00008894 ; =============== S U B R O U T I N E =======================================
.text$x:00008894
.text$x:00008894
.text$x:00008894 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$7 proc near
.text$x:00008894                                         ; DATA XREF: .xdata$x:00013EACo
.text$x:00008894                 mov     ecx, [ebp-54h]
.text$x:00008897                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00008897 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$7 endp
.text$x:00008897
.text$x:0000889C
.text$x:0000889C ; =============== S U B R O U T I N E =======================================
.text$x:0000889C
.text$x:0000889C
.text$x:0000889C __ehhandler$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z proc near
.text$x:0000889C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:0000889C
.text$x:0000889C arg_4           = dword ptr  8
.text$x:0000889C
.text$x:0000889C                 mov     edx, [esp+arg_4]
.text$x:000088A0                 lea     eax, [edx+0Ch]
.text$x:000088A3                 mov     ecx, [edx-68h]
.text$x:000088A6                 xor     ecx, eax
.text$x:000088A8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000088AD                 mov     eax, offset __ehfuncinfo$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$x:000088B2                 jmp     ___CxxFrameHandler3
.text$x:000088B2 __ehhandler$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z endp
.text$x:000088B2
.text$x:000088B2 ; ---------------------------------------------------------------------------
.text$x:000088B7                 align 4
.text$x:000088B7 _text$x         ends
.text$x:000088B7
.text$mn:000088B8 ; ===========================================================================
.text$mn:000088B8
.text$mn:000088B8 ; Segment type: Pure code
.text$mn:000088B8 ; Segment permissions: Read/Execute
.text$mn:000088B8 _text$mn        segment para public 'CODE' use32
.text$mn:000088B8                 assume cs:_text$mn
.text$mn:000088B8                 ;org 88B8h
.text$mn:000088B8 ; COMDAT (pick any)
.text$mn:000088B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000088B8
.text$mn:000088B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000088B8
.text$mn:000088B8 ; Attributes: bp-based frame
.text$mn:000088B8
.text$mn:000088B8 ; int __stdcall std::_Wrap_alloc<std::allocator<int>>::construct<int,int &>(void *, int)
.text$mn:000088B8                 public ??$construct@HAAH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHAAH@Z
.text$mn:000088B8 ??$construct@HAAH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHAAH@Z proc near
.text$mn:000088B8                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+8Dp
.text$mn:000088B8
.text$mn:000088B8 var_4           = dword ptr -4
.text$mn:000088B8 arg_0           = dword ptr  8
.text$mn:000088B8 arg_4           = dword ptr  0Ch
.text$mn:000088B8
.text$mn:000088B8                 push    ebp
.text$mn:000088B9                 mov     ebp, esp
.text$mn:000088BB                 push    ecx
.text$mn:000088BC                 mov     [ebp+var_4], ecx
.text$mn:000088BF                 mov     eax, [ebp+arg_4]
.text$mn:000088C2                 push    eax
.text$mn:000088C3                 call    ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>(int &)
.text$mn:000088C8                 add     esp, 4
.text$mn:000088CB                 push    eax             ; int
.text$mn:000088CC                 mov     ecx, [ebp+arg_0]
.text$mn:000088CF                 push    ecx             ; void *
.text$mn:000088D0                 mov     edx, [ebp+var_4]
.text$mn:000088D3                 push    edx             ; int
.text$mn:000088D4                 call    ??$construct@HAAH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHAAH@Z ; std::allocator_traits<std::allocator<int>>::construct<int,int &>(std::allocator<int> &,int *,int &)
.text$mn:000088D9                 add     esp, 0Ch
.text$mn:000088DC                 mov     esp, ebp
.text$mn:000088DE                 pop     ebp
.text$mn:000088DF                 retn    8
.text$mn:000088DF ??$construct@HAAH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHAAH@Z endp
.text$mn:000088DF
.text$mn:000088DF ; ---------------------------------------------------------------------------
.text$mn:000088E2                 align 4
.text$mn:000088E2 _text$mn        ends
.text$mn:000088E2
.text$mn:000088E4 ; ===========================================================================
.text$mn:000088E4
.text$mn:000088E4 ; Segment type: Pure code
.text$mn:000088E4 ; Segment permissions: Read/Execute
.text$mn:000088E4 _text$mn        segment para public 'CODE' use32
.text$mn:000088E4                 assume cs:_text$mn
.text$mn:000088E4                 ;org 88E4h
.text$mn:000088E4 ; COMDAT (pick any)
.text$mn:000088E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000088E4
.text$mn:000088E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000088E4
.text$mn:000088E4 ; Attributes: bp-based frame
.text$mn:000088E4
.text$mn:000088E4 ; int __stdcall std::allocator<int>::construct<int,int &>(void *, int)
.text$mn:000088E4                 public ??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z
.text$mn:000088E4 ??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z proc near
.text$mn:000088E4                                         ; CODE XREF: std::allocator_traits<std::allocator<int>>::construct<int,int &>(std::allocator<int> &,int *,int &)+17p
.text$mn:000088E4
.text$mn:000088E4 var_1C          = dword ptr -1Ch
.text$mn:000088E4 var_18          = dword ptr -18h
.text$mn:000088E4 var_14          = dword ptr -14h
.text$mn:000088E4 var_10          = dword ptr -10h
.text$mn:000088E4 var_C           = dword ptr -0Ch
.text$mn:000088E4 var_4           = dword ptr -4
.text$mn:000088E4 arg_0           = dword ptr  8
.text$mn:000088E4 arg_4           = dword ptr  0Ch
.text$mn:000088E4
.text$mn:000088E4                 push    ebp
.text$mn:000088E5                 mov     ebp, esp
.text$mn:000088E7                 push    0FFFFFFFFh
.text$mn:000088E9                 push    offset __ehhandler$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z
.text$mn:000088EE                 mov     eax, large fs:0
.text$mn:000088F4                 push    eax
.text$mn:000088F5                 sub     esp, 10h
.text$mn:000088F8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000088FD                 xor     eax, ebp
.text$mn:000088FF                 push    eax
.text$mn:00008900                 lea     eax, [ebp+var_C]
.text$mn:00008903                 mov     large fs:0, eax
.text$mn:00008909                 mov     [ebp+var_18], ecx
.text$mn:0000890C                 mov     eax, [ebp+arg_0]
.text$mn:0000890F                 push    eax             ; void *
.text$mn:00008910                 push    4               ; unsigned int
.text$mn:00008912                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00008917                 add     esp, 8
.text$mn:0000891A                 mov     [ebp+var_10], eax
.text$mn:0000891D                 mov     [ebp+var_4], 0
.text$mn:00008924                 cmp     [ebp+var_10], 0
.text$mn:00008928                 jz      short loc_8945
.text$mn:0000892A                 mov     ecx, [ebp+arg_4]
.text$mn:0000892D                 push    ecx
.text$mn:0000892E                 call    ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>(int &)
.text$mn:00008933                 add     esp, 4
.text$mn:00008936                 mov     edx, [ebp+var_10]
.text$mn:00008939                 mov     eax, [eax]
.text$mn:0000893B                 mov     [edx], eax
.text$mn:0000893D                 mov     ecx, [ebp+var_10]
.text$mn:00008940                 mov     [ebp+var_14], ecx
.text$mn:00008943                 jmp     short loc_894C
.text$mn:00008945 ; ---------------------------------------------------------------------------
.text$mn:00008945
.text$mn:00008945 loc_8945:                               ; CODE XREF: std::allocator<int>::construct<int,int &>(int *,int &)+44j
.text$mn:00008945                 mov     [ebp+var_14], 0
.text$mn:0000894C
.text$mn:0000894C loc_894C:                               ; CODE XREF: std::allocator<int>::construct<int,int &>(int *,int &)+5Fj
.text$mn:0000894C                 mov     edx, [ebp+var_14]
.text$mn:0000894F                 mov     [ebp+var_1C], edx
.text$mn:00008952                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008959                 mov     ecx, [ebp+var_C]
.text$mn:0000895C                 mov     large fs:0, ecx
.text$mn:00008963                 pop     ecx
.text$mn:00008964                 mov     esp, ebp
.text$mn:00008966                 pop     ebp
.text$mn:00008967                 retn    8
.text$mn:00008967 ??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z endp
.text$mn:00008967
.text$mn:00008967 ; ---------------------------------------------------------------------------
.text$mn:0000896A                 align 4
.text$mn:0000896A _text$mn        ends
.text$mn:0000896A
.text$x:0000896C ; ===========================================================================
.text$x:0000896C
.text$x:0000896C ; Segment type: Pure code
.text$x:0000896C ; Segment permissions: Read/Execute
.text$x:0000896C _text$x         segment para public 'CODE' use32
.text$x:0000896C                 assume cs:_text$x
.text$x:0000896C                 ;org 896Ch
.text$x:0000896C ; COMDAT (pick associative to section at 88E4)
.text$x:0000896C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000896C
.text$x:0000896C ; =============== S U B R O U T I N E =======================================
.text$x:0000896C
.text$x:0000896C
.text$x:0000896C __unwindfunclet$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z$0 proc near
.text$x:0000896C                                         ; DATA XREF: .xdata$x:00013F78o
.text$x:0000896C                 mov     eax, [ebp+8]
.text$x:0000896F                 push    eax
.text$x:00008970                 mov     eax, [ebp-10h]
.text$x:00008973                 push    eax             ; void *
.text$x:00008974                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00008979                 add     esp, 8
.text$x:0000897C                 retn
.text$x:0000897C __unwindfunclet$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z$0 endp
.text$x:0000897C
.text$x:0000897D
.text$x:0000897D ; =============== S U B R O U T I N E =======================================
.text$x:0000897D
.text$x:0000897D
.text$x:0000897D __ehhandler$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z proc near
.text$x:0000897D                                         ; DATA XREF: std::allocator<int>::construct<int,int &>(int *,int &)+5o
.text$x:0000897D
.text$x:0000897D arg_4           = dword ptr  8
.text$x:0000897D
.text$x:0000897D                 mov     edx, [esp+arg_4]
.text$x:00008981                 lea     eax, [edx+0Ch]
.text$x:00008984                 mov     ecx, [edx-14h]
.text$x:00008987                 xor     ecx, eax
.text$x:00008989                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000898E                 mov     eax, offset __ehfuncinfo$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z
.text$x:00008993                 jmp     ___CxxFrameHandler3
.text$x:00008993 __ehhandler$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z endp
.text$x:00008993
.text$x:00008993 _text$x         ends
.text$x:00008993
.text$mn:00008998 ; ===========================================================================
.text$mn:00008998
.text$mn:00008998 ; Segment type: Pure code
.text$mn:00008998 ; Segment permissions: Read/Execute
.text$mn:00008998 _text$mn        segment para public 'CODE' use32
.text$mn:00008998                 assume cs:_text$mn
.text$mn:00008998                 ;org 8998h
.text$mn:00008998 ; COMDAT (pick any)
.text$mn:00008998                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008998
.text$mn:00008998 ; =============== S U B R O U T I N E =======================================
.text$mn:00008998
.text$mn:00008998 ; Attributes: bp-based frame
.text$mn:00008998
.text$mn:00008998 ; int __cdecl std::allocator_traits<std::allocator<int>>::construct<int,int &>(int, void *, int)
.text$mn:00008998                 public ??$construct@HAAH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHAAH@Z
.text$mn:00008998 ??$construct@HAAH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHAAH@Z proc near
.text$mn:00008998                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::construct<int,int &>(int *,int &)+1Cp
.text$mn:00008998
.text$mn:00008998 arg_0           = dword ptr  8
.text$mn:00008998 arg_4           = dword ptr  0Ch
.text$mn:00008998 arg_8           = dword ptr  10h
.text$mn:00008998
.text$mn:00008998                 push    ebp
.text$mn:00008999                 mov     ebp, esp
.text$mn:0000899B                 mov     eax, [ebp+arg_8]
.text$mn:0000899E                 push    eax
.text$mn:0000899F                 call    ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>(int &)
.text$mn:000089A4                 add     esp, 4
.text$mn:000089A7                 push    eax             ; int
.text$mn:000089A8                 mov     ecx, [ebp+arg_4]
.text$mn:000089AB                 push    ecx             ; void *
.text$mn:000089AC                 mov     ecx, [ebp+arg_0]
.text$mn:000089AF                 call    ??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z ; std::allocator<int>::construct<int,int &>(int *,int &)
.text$mn:000089B4                 pop     ebp
.text$mn:000089B5                 retn
.text$mn:000089B5 ??$construct@HAAH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHAAH@Z endp
.text$mn:000089B5
.text$mn:000089B5 ; ---------------------------------------------------------------------------
.text$mn:000089B6                 align 4
.text$mn:000089B6 _text$mn        ends
.text$mn:000089B6
.text$mn:000089B8 ; ===========================================================================
.text$mn:000089B8
.text$mn:000089B8 ; Segment type: Pure code
.text$mn:000089B8 ; Segment permissions: Read/Execute
.text$mn:000089B8 _text$mn        segment para public 'CODE' use32
.text$mn:000089B8                 assume cs:_text$mn
.text$mn:000089B8                 ;org 89B8h
.text$mn:000089B8 ; COMDAT (pick any)
.text$mn:000089B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000089B8
.text$mn:000089B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000089B8
.text$mn:000089B8 ; Attributes: bp-based frame
.text$mn:000089B8
.text$mn:000089B8 ; int __stdcall std::_Wrap_alloc<std::allocator<int>>::construct<int,int const &>(void *, int)
.text$mn:000089B8                 public ??$construct@HABH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHABH@Z
.text$mn:000089B8 ??$construct@HABH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHABH@Z proc near
.text$mn:000089B8                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+EAp
.text$mn:000089B8
.text$mn:000089B8 var_4           = dword ptr -4
.text$mn:000089B8 arg_0           = dword ptr  8
.text$mn:000089B8 arg_4           = dword ptr  0Ch
.text$mn:000089B8
.text$mn:000089B8                 push    ebp
.text$mn:000089B9                 mov     ebp, esp
.text$mn:000089BB                 push    ecx
.text$mn:000089BC                 mov     [ebp+var_4], ecx
.text$mn:000089BF                 mov     eax, [ebp+arg_4]
.text$mn:000089C2                 push    eax
.text$mn:000089C3                 call    ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>(int const &)
.text$mn:000089C8                 add     esp, 4
.text$mn:000089CB                 push    eax             ; int
.text$mn:000089CC                 mov     ecx, [ebp+arg_0]
.text$mn:000089CF                 push    ecx             ; void *
.text$mn:000089D0                 mov     edx, [ebp+var_4]
.text$mn:000089D3                 push    edx             ; int
.text$mn:000089D4                 call    ??$construct@HABH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHABH@Z ; std::allocator_traits<std::allocator<int>>::construct<int,int const &>(std::allocator<int> &,int *,int const &)
.text$mn:000089D9                 add     esp, 0Ch
.text$mn:000089DC                 mov     esp, ebp
.text$mn:000089DE                 pop     ebp
.text$mn:000089DF                 retn    8
.text$mn:000089DF ??$construct@HABH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHABH@Z endp
.text$mn:000089DF
.text$mn:000089DF ; ---------------------------------------------------------------------------
.text$mn:000089E2                 align 4
.text$mn:000089E2 _text$mn        ends
.text$mn:000089E2
.text$mn:000089E4 ; ===========================================================================
.text$mn:000089E4
.text$mn:000089E4 ; Segment type: Pure code
.text$mn:000089E4 ; Segment permissions: Read/Execute
.text$mn:000089E4 _text$mn        segment para public 'CODE' use32
.text$mn:000089E4                 assume cs:_text$mn
.text$mn:000089E4                 ;org 89E4h
.text$mn:000089E4 ; COMDAT (pick any)
.text$mn:000089E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000089E4
.text$mn:000089E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000089E4
.text$mn:000089E4 ; Attributes: bp-based frame
.text$mn:000089E4
.text$mn:000089E4 ; int __cdecl std::allocator_traits<std::allocator<int>>::construct<int,int const &>(int, void *, int)
.text$mn:000089E4                 public ??$construct@HABH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHABH@Z
.text$mn:000089E4 ??$construct@HABH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHABH@Z proc near
.text$mn:000089E4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::construct<int,int const &>(int *,int const &)+1Cp
.text$mn:000089E4
.text$mn:000089E4 arg_0           = dword ptr  8
.text$mn:000089E4 arg_4           = dword ptr  0Ch
.text$mn:000089E4 arg_8           = dword ptr  10h
.text$mn:000089E4
.text$mn:000089E4                 push    ebp
.text$mn:000089E5                 mov     ebp, esp
.text$mn:000089E7                 mov     eax, [ebp+arg_8]
.text$mn:000089EA                 push    eax
.text$mn:000089EB                 call    ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>(int const &)
.text$mn:000089F0                 add     esp, 4
.text$mn:000089F3                 push    eax             ; int
.text$mn:000089F4                 mov     ecx, [ebp+arg_4]
.text$mn:000089F7                 push    ecx             ; void *
.text$mn:000089F8                 mov     ecx, [ebp+arg_0]
.text$mn:000089FB                 call    ?construct@?$allocator@H@std@@QAEXPAHABH@Z ; std::allocator<int>::construct(int *,int const &)
.text$mn:00008A00                 pop     ebp
.text$mn:00008A01                 retn
.text$mn:00008A01 ??$construct@HABH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHABH@Z endp
.text$mn:00008A01
.text$mn:00008A01 ; ---------------------------------------------------------------------------
.text$mn:00008A02                 align 4
.text$mn:00008A02 _text$mn        ends
.text$mn:00008A02
.text$mn:00008A04 ; ===========================================================================
.text$mn:00008A04
.text$mn:00008A04 ; Segment type: Pure code
.text$mn:00008A04 ; Segment permissions: Read/Execute
.text$mn:00008A04 _text$mn        segment para public 'CODE' use32
.text$mn:00008A04                 assume cs:_text$mn
.text$mn:00008A04                 ;org 8A04h
.text$mn:00008A04 ; COMDAT (pick any)
.text$mn:00008A04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008A04
.text$mn:00008A04 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A04
.text$mn:00008A04 ; Attributes: bp-based frame
.text$mn:00008A04
.text$mn:00008A04 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00008A04                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00008A04 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00008A04                                         ; CODE XREF: $LN19+4Bp
.text$mn:00008A04
.text$mn:00008A04 var_4           = dword ptr -4
.text$mn:00008A04 arg_0           = dword ptr  8
.text$mn:00008A04 arg_4           = dword ptr  0Ch
.text$mn:00008A04
.text$mn:00008A04                 push    ebp
.text$mn:00008A05                 mov     ebp, esp
.text$mn:00008A07                 push    ecx
.text$mn:00008A08                 mov     [ebp+var_4], ecx
.text$mn:00008A0B                 mov     eax, [ebp+arg_4]
.text$mn:00008A0E                 push    eax
.text$mn:00008A0F                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00008A14                 add     esp, 4
.text$mn:00008A17                 push    eax             ; int
.text$mn:00008A18                 mov     ecx, [ebp+arg_0]
.text$mn:00008A1B                 push    ecx             ; void *
.text$mn:00008A1C                 mov     edx, [ebp+var_4]
.text$mn:00008A1F                 push    edx             ; int
.text$mn:00008A20                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00008A25                 add     esp, 0Ch
.text$mn:00008A28                 mov     esp, ebp
.text$mn:00008A2A                 pop     ebp
.text$mn:00008A2B                 retn    8
.text$mn:00008A2B ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00008A2B
.text$mn:00008A2B ; ---------------------------------------------------------------------------
.text$mn:00008A2E                 align 10h
.text$mn:00008A2E _text$mn        ends
.text$mn:00008A2E
.text$mn:00008A30 ; ===========================================================================
.text$mn:00008A30
.text$mn:00008A30 ; Segment type: Pure code
.text$mn:00008A30 ; Segment permissions: Read/Execute
.text$mn:00008A30 _text$mn        segment para public 'CODE' use32
.text$mn:00008A30                 assume cs:_text$mn
.text$mn:00008A30                 ;org 8A30h
.text$mn:00008A30 ; COMDAT (pick any)
.text$mn:00008A30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008A30
.text$mn:00008A30 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A30
.text$mn:00008A30 ; Attributes: bp-based frame
.text$mn:00008A30
.text$mn:00008A30 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00008A30                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00008A30 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00008A30                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00008A30
.text$mn:00008A30 var_1C          = dword ptr -1Ch
.text$mn:00008A30 var_18          = dword ptr -18h
.text$mn:00008A30 var_14          = dword ptr -14h
.text$mn:00008A30 var_10          = dword ptr -10h
.text$mn:00008A30 var_C           = dword ptr -0Ch
.text$mn:00008A30 var_4           = dword ptr -4
.text$mn:00008A30 arg_0           = dword ptr  8
.text$mn:00008A30 arg_4           = dword ptr  0Ch
.text$mn:00008A30
.text$mn:00008A30                 push    ebp
.text$mn:00008A31                 mov     ebp, esp
.text$mn:00008A33                 push    0FFFFFFFFh
.text$mn:00008A35                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00008A3A                 mov     eax, large fs:0
.text$mn:00008A40                 push    eax
.text$mn:00008A41                 sub     esp, 10h
.text$mn:00008A44                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008A49                 xor     eax, ebp
.text$mn:00008A4B                 push    eax
.text$mn:00008A4C                 lea     eax, [ebp+var_C]
.text$mn:00008A4F                 mov     large fs:0, eax
.text$mn:00008A55                 mov     [ebp+var_18], ecx
.text$mn:00008A58                 mov     eax, [ebp+arg_0]
.text$mn:00008A5B                 push    eax             ; void *
.text$mn:00008A5C                 push    4               ; unsigned int
.text$mn:00008A5E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00008A63                 add     esp, 8
.text$mn:00008A66                 mov     [ebp+var_10], eax
.text$mn:00008A69                 mov     [ebp+var_4], 0
.text$mn:00008A70                 cmp     [ebp+var_10], 0
.text$mn:00008A74                 jz      short loc_8A91
.text$mn:00008A76                 mov     ecx, [ebp+arg_4]
.text$mn:00008A79                 push    ecx
.text$mn:00008A7A                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00008A7F                 add     esp, 4
.text$mn:00008A82                 mov     edx, [ebp+var_10]
.text$mn:00008A85                 mov     eax, [eax]
.text$mn:00008A87                 mov     [edx], eax
.text$mn:00008A89                 mov     ecx, [ebp+var_10]
.text$mn:00008A8C                 mov     [ebp+var_14], ecx
.text$mn:00008A8F                 jmp     short loc_8A98
.text$mn:00008A91 ; ---------------------------------------------------------------------------
.text$mn:00008A91
.text$mn:00008A91 loc_8A91:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00008A91                 mov     [ebp+var_14], 0
.text$mn:00008A98
.text$mn:00008A98 loc_8A98:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00008A98                 mov     edx, [ebp+var_14]
.text$mn:00008A9B                 mov     [ebp+var_1C], edx
.text$mn:00008A9E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008AA5                 mov     ecx, [ebp+var_C]
.text$mn:00008AA8                 mov     large fs:0, ecx
.text$mn:00008AAF                 pop     ecx
.text$mn:00008AB0                 mov     esp, ebp
.text$mn:00008AB2                 pop     ebp
.text$mn:00008AB3                 retn    8
.text$mn:00008AB3 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00008AB3
.text$mn:00008AB3 ; ---------------------------------------------------------------------------
.text$mn:00008AB6                 align 4
.text$mn:00008AB6 _text$mn        ends
.text$mn:00008AB6
.text$x:00008AB8 ; ===========================================================================
.text$x:00008AB8
.text$x:00008AB8 ; Segment type: Pure code
.text$x:00008AB8 ; Segment permissions: Read/Execute
.text$x:00008AB8 _text$x         segment para public 'CODE' use32
.text$x:00008AB8                 assume cs:_text$x
.text$x:00008AB8                 ;org 8AB8h
.text$x:00008AB8 ; COMDAT (pick associative to section at 8A30)
.text$x:00008AB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008AB8
.text$x:00008AB8 ; =============== S U B R O U T I N E =======================================
.text$x:00008AB8
.text$x:00008AB8
.text$x:00008AB8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00008AB8                                         ; DATA XREF: .xdata$x:00014028o
.text$x:00008AB8                 mov     eax, [ebp+8]
.text$x:00008ABB                 push    eax
.text$x:00008ABC                 mov     eax, [ebp-10h]
.text$x:00008ABF                 push    eax             ; void *
.text$x:00008AC0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00008AC5                 add     esp, 8
.text$x:00008AC8                 retn
.text$x:00008AC8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00008AC8
.text$x:00008AC9
.text$x:00008AC9 ; =============== S U B R O U T I N E =======================================
.text$x:00008AC9
.text$x:00008AC9
.text$x:00008AC9 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00008AC9                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00008AC9
.text$x:00008AC9 arg_4           = dword ptr  8
.text$x:00008AC9
.text$x:00008AC9                 mov     edx, [esp+arg_4]
.text$x:00008ACD                 lea     eax, [edx+0Ch]
.text$x:00008AD0                 mov     ecx, [edx-14h]
.text$x:00008AD3                 xor     ecx, eax
.text$x:00008AD5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008ADA                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00008ADF                 jmp     ___CxxFrameHandler3
.text$x:00008ADF __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00008ADF
.text$x:00008ADF _text$x         ends
.text$x:00008ADF
.text$mn:00008AE4 ; ===========================================================================
.text$mn:00008AE4
.text$mn:00008AE4 ; Segment type: Pure code
.text$mn:00008AE4 ; Segment permissions: Read/Execute
.text$mn:00008AE4 _text$mn        segment para public 'CODE' use32
.text$mn:00008AE4                 assume cs:_text$mn
.text$mn:00008AE4                 ;org 8AE4h
.text$mn:00008AE4 ; COMDAT (pick any)
.text$mn:00008AE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008AE4
.text$mn:00008AE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008AE4
.text$mn:00008AE4 ; Attributes: bp-based frame
.text$mn:00008AE4
.text$mn:00008AE4 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00008AE4                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00008AE4 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00008AE4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00008AE4
.text$mn:00008AE4 arg_0           = dword ptr  8
.text$mn:00008AE4 arg_4           = dword ptr  0Ch
.text$mn:00008AE4 arg_8           = dword ptr  10h
.text$mn:00008AE4
.text$mn:00008AE4                 push    ebp
.text$mn:00008AE5                 mov     ebp, esp
.text$mn:00008AE7                 mov     eax, [ebp+arg_8]
.text$mn:00008AEA                 push    eax
.text$mn:00008AEB                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00008AF0                 add     esp, 4
.text$mn:00008AF3                 push    eax             ; int
.text$mn:00008AF4                 mov     ecx, [ebp+arg_4]
.text$mn:00008AF7                 push    ecx             ; void *
.text$mn:00008AF8                 mov     ecx, [ebp+arg_0]
.text$mn:00008AFB                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00008B00                 pop     ebp
.text$mn:00008B01                 retn
.text$mn:00008B01 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00008B01
.text$mn:00008B01 ; ---------------------------------------------------------------------------
.text$mn:00008B02                 align 4
.text$mn:00008B02 _text$mn        ends
.text$mn:00008B02
.text$mn:00008B04 ; ===========================================================================
.text$mn:00008B04
.text$mn:00008B04 ; Segment type: Pure code
.text$mn:00008B04 ; Segment permissions: Read/Execute
.text$mn:00008B04 _text$mn        segment para public 'CODE' use32
.text$mn:00008B04                 assume cs:_text$mn
.text$mn:00008B04                 ;org 8B04h
.text$mn:00008B04 ; COMDAT (pick any)
.text$mn:00008B04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008B04
.text$mn:00008B04 ; =============== S U B R O U T I N E =======================================
.text$mn:00008B04
.text$mn:00008B04 ; Attributes: bp-based frame
.text$mn:00008B04
.text$mn:00008B04 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00008B04                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00008B04 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00008B04                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+50p
.text$mn:00008B04                                         ; $LN19_0+4Bp
.text$mn:00008B04
.text$mn:00008B04 var_4           = dword ptr -4
.text$mn:00008B04 arg_0           = dword ptr  8
.text$mn:00008B04 arg_4           = dword ptr  0Ch
.text$mn:00008B04
.text$mn:00008B04                 push    ebp
.text$mn:00008B05                 mov     ebp, esp
.text$mn:00008B07                 push    ecx
.text$mn:00008B08                 mov     [ebp+var_4], ecx
.text$mn:00008B0B                 mov     eax, [ebp+arg_4]
.text$mn:00008B0E                 push    eax
.text$mn:00008B0F                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00008B14                 add     esp, 4
.text$mn:00008B17                 push    eax             ; int
.text$mn:00008B18                 mov     ecx, [ebp+arg_0]
.text$mn:00008B1B                 push    ecx             ; void *
.text$mn:00008B1C                 mov     edx, [ebp+var_4]
.text$mn:00008B1F                 push    edx             ; int
.text$mn:00008B20                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:00008B25                 add     esp, 0Ch
.text$mn:00008B28                 mov     esp, ebp
.text$mn:00008B2A                 pop     ebp
.text$mn:00008B2B                 retn    8
.text$mn:00008B2B ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00008B2B
.text$mn:00008B2B ; ---------------------------------------------------------------------------
.text$mn:00008B2E                 align 10h
.text$mn:00008B2E _text$mn        ends
.text$mn:00008B2E
.text$mn:00008B30 ; ===========================================================================
.text$mn:00008B30
.text$mn:00008B30 ; Segment type: Pure code
.text$mn:00008B30 ; Segment permissions: Read/Execute
.text$mn:00008B30 _text$mn        segment para public 'CODE' use32
.text$mn:00008B30                 assume cs:_text$mn
.text$mn:00008B30                 ;org 8B30h
.text$mn:00008B30 ; COMDAT (pick any)
.text$mn:00008B30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008B30
.text$mn:00008B30 ; =============== S U B R O U T I N E =======================================
.text$mn:00008B30
.text$mn:00008B30 ; Attributes: bp-based frame
.text$mn:00008B30
.text$mn:00008B30 ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00008B30                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00008B30 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00008B30                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:00008B30
.text$mn:00008B30 var_1C          = dword ptr -1Ch
.text$mn:00008B30 var_18          = dword ptr -18h
.text$mn:00008B30 var_14          = dword ptr -14h
.text$mn:00008B30 var_10          = dword ptr -10h
.text$mn:00008B30 var_C           = dword ptr -0Ch
.text$mn:00008B30 var_4           = dword ptr -4
.text$mn:00008B30 arg_0           = dword ptr  8
.text$mn:00008B30 arg_4           = dword ptr  0Ch
.text$mn:00008B30
.text$mn:00008B30                 push    ebp
.text$mn:00008B31                 mov     ebp, esp
.text$mn:00008B33                 push    0FFFFFFFFh
.text$mn:00008B35                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00008B3A                 mov     eax, large fs:0
.text$mn:00008B40                 push    eax
.text$mn:00008B41                 sub     esp, 10h
.text$mn:00008B44                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008B49                 xor     eax, ebp
.text$mn:00008B4B                 push    eax
.text$mn:00008B4C                 lea     eax, [ebp+var_C]
.text$mn:00008B4F                 mov     large fs:0, eax
.text$mn:00008B55                 mov     [ebp+var_18], ecx
.text$mn:00008B58                 mov     eax, [ebp+arg_0]
.text$mn:00008B5B                 push    eax             ; void *
.text$mn:00008B5C                 push    4               ; unsigned int
.text$mn:00008B5E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00008B63                 add     esp, 8
.text$mn:00008B66                 mov     [ebp+var_10], eax
.text$mn:00008B69                 mov     [ebp+var_4], 0
.text$mn:00008B70                 cmp     [ebp+var_10], 0
.text$mn:00008B74                 jz      short loc_8B91
.text$mn:00008B76                 mov     ecx, [ebp+arg_4]
.text$mn:00008B79                 push    ecx
.text$mn:00008B7A                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00008B7F                 add     esp, 4
.text$mn:00008B82                 mov     edx, [ebp+var_10]
.text$mn:00008B85                 mov     eax, [eax]
.text$mn:00008B87                 mov     [edx], eax
.text$mn:00008B89                 mov     ecx, [ebp+var_10]
.text$mn:00008B8C                 mov     [ebp+var_14], ecx
.text$mn:00008B8F                 jmp     short loc_8B98
.text$mn:00008B91 ; ---------------------------------------------------------------------------
.text$mn:00008B91
.text$mn:00008B91 loc_8B91:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:00008B91                 mov     [ebp+var_14], 0
.text$mn:00008B98
.text$mn:00008B98 loc_8B98:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:00008B98                 mov     edx, [ebp+var_14]
.text$mn:00008B9B                 mov     [ebp+var_1C], edx
.text$mn:00008B9E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008BA5                 mov     ecx, [ebp+var_C]
.text$mn:00008BA8                 mov     large fs:0, ecx
.text$mn:00008BAF                 pop     ecx
.text$mn:00008BB0                 mov     esp, ebp
.text$mn:00008BB2                 pop     ebp
.text$mn:00008BB3                 retn    8
.text$mn:00008BB3 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00008BB3
.text$mn:00008BB3 ; ---------------------------------------------------------------------------
.text$mn:00008BB6                 align 4
.text$mn:00008BB6 _text$mn        ends
.text$mn:00008BB6
.text$x:00008BB8 ; ===========================================================================
.text$x:00008BB8
.text$x:00008BB8 ; Segment type: Pure code
.text$x:00008BB8 ; Segment permissions: Read/Execute
.text$x:00008BB8 _text$x         segment para public 'CODE' use32
.text$x:00008BB8                 assume cs:_text$x
.text$x:00008BB8                 ;org 8BB8h
.text$x:00008BB8 ; COMDAT (pick associative to section at 8B30)
.text$x:00008BB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008BB8
.text$x:00008BB8 ; =============== S U B R O U T I N E =======================================
.text$x:00008BB8
.text$x:00008BB8
.text$x:00008BB8 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:00008BB8                                         ; DATA XREF: .xdata$x:00014054o
.text$x:00008BB8                 mov     eax, [ebp+8]
.text$x:00008BBB                 push    eax
.text$x:00008BBC                 mov     eax, [ebp-10h]
.text$x:00008BBF                 push    eax             ; void *
.text$x:00008BC0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00008BC5                 add     esp, 8
.text$x:00008BC8                 retn
.text$x:00008BC8 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:00008BC8
.text$x:00008BC9
.text$x:00008BC9 ; =============== S U B R O U T I N E =======================================
.text$x:00008BC9
.text$x:00008BC9
.text$x:00008BC9 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:00008BC9                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:00008BC9
.text$x:00008BC9 arg_4           = dword ptr  8
.text$x:00008BC9
.text$x:00008BC9                 mov     edx, [esp+arg_4]
.text$x:00008BCD                 lea     eax, [edx+0Ch]
.text$x:00008BD0                 mov     ecx, [edx-14h]
.text$x:00008BD3                 xor     ecx, eax
.text$x:00008BD5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008BDA                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:00008BDF                 jmp     ___CxxFrameHandler3
.text$x:00008BDF __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:00008BDF
.text$x:00008BDF _text$x         ends
.text$x:00008BDF
.text$mn:00008BE4 ; ===========================================================================
.text$mn:00008BE4
.text$mn:00008BE4 ; Segment type: Pure code
.text$mn:00008BE4 ; Segment permissions: Read/Execute
.text$mn:00008BE4 _text$mn        segment para public 'CODE' use32
.text$mn:00008BE4                 assume cs:_text$mn
.text$mn:00008BE4                 ;org 8BE4h
.text$mn:00008BE4 ; COMDAT (pick any)
.text$mn:00008BE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008BE4
.text$mn:00008BE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008BE4
.text$mn:00008BE4 ; Attributes: bp-based frame
.text$mn:00008BE4
.text$mn:00008BE4 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:00008BE4                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:00008BE4 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:00008BE4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:00008BE4
.text$mn:00008BE4 arg_0           = dword ptr  8
.text$mn:00008BE4 arg_4           = dword ptr  0Ch
.text$mn:00008BE4 arg_8           = dword ptr  10h
.text$mn:00008BE4
.text$mn:00008BE4                 push    ebp
.text$mn:00008BE5                 mov     ebp, esp
.text$mn:00008BE7                 mov     eax, [ebp+arg_8]
.text$mn:00008BEA                 push    eax
.text$mn:00008BEB                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00008BF0                 add     esp, 4
.text$mn:00008BF3                 push    eax             ; int
.text$mn:00008BF4                 mov     ecx, [ebp+arg_4]
.text$mn:00008BF7                 push    ecx             ; void *
.text$mn:00008BF8                 mov     ecx, [ebp+arg_0]
.text$mn:00008BFB                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00008C00                 pop     ebp
.text$mn:00008C01                 retn
.text$mn:00008C01 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:00008C01
.text$mn:00008C01 ; ---------------------------------------------------------------------------
.text$mn:00008C02                 align 4
.text$mn:00008C02 _text$mn        ends
.text$mn:00008C02
.text$mn:00008C04 ; ===========================================================================
.text$mn:00008C04
.text$mn:00008C04 ; Segment type: Pure code
.text$mn:00008C04 ; Segment permissions: Read/Execute
.text$mn:00008C04 _text$mn        segment para public 'CODE' use32
.text$mn:00008C04                 assume cs:_text$mn
.text$mn:00008C04                 ;org 8C04h
.text$mn:00008C04 ; COMDAT (pick any)
.text$mn:00008C04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008C04
.text$mn:00008C04 ; =============== S U B R O U T I N E =======================================
.text$mn:00008C04
.text$mn:00008C04 ; Attributes: bp-based frame
.text$mn:00008C04
.text$mn:00008C04 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00008C04                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00008C04 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00008C04                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Alloc_proxy(void)+32p
.text$mn:00008C04                                         ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Alloc_proxy(void)+32p ...
.text$mn:00008C04
.text$mn:00008C04 var_4           = dword ptr -4
.text$mn:00008C04 arg_0           = dword ptr  8
.text$mn:00008C04 arg_4           = dword ptr  0Ch
.text$mn:00008C04
.text$mn:00008C04                 push    ebp
.text$mn:00008C05                 mov     ebp, esp
.text$mn:00008C07                 push    ecx
.text$mn:00008C08                 mov     [ebp+var_4], ecx
.text$mn:00008C0B                 mov     eax, [ebp+arg_4]
.text$mn:00008C0E                 push    eax
.text$mn:00008C0F                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00008C14                 add     esp, 4
.text$mn:00008C17                 push    eax             ; int
.text$mn:00008C18                 mov     ecx, [ebp+arg_0]
.text$mn:00008C1B                 push    ecx             ; void *
.text$mn:00008C1C                 mov     edx, [ebp+var_4]
.text$mn:00008C1F                 push    edx             ; int
.text$mn:00008C20                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00008C25                 add     esp, 0Ch
.text$mn:00008C28                 mov     esp, ebp
.text$mn:00008C2A                 pop     ebp
.text$mn:00008C2B                 retn    8
.text$mn:00008C2B ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00008C2B
.text$mn:00008C2B ; ---------------------------------------------------------------------------
.text$mn:00008C2E                 align 10h
.text$mn:00008C2E _text$mn        ends
.text$mn:00008C2E
.text$mn:00008C30 ; ===========================================================================
.text$mn:00008C30
.text$mn:00008C30 ; Segment type: Pure code
.text$mn:00008C30 ; Segment permissions: Read/Execute
.text$mn:00008C30 _text$mn        segment para public 'CODE' use32
.text$mn:00008C30                 assume cs:_text$mn
.text$mn:00008C30                 ;org 8C30h
.text$mn:00008C30 ; COMDAT (pick any)
.text$mn:00008C30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008C30
.text$mn:00008C30 ; =============== S U B R O U T I N E =======================================
.text$mn:00008C30
.text$mn:00008C30 ; Attributes: bp-based frame
.text$mn:00008C30
.text$mn:00008C30 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00008C30                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00008C30 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00008C30                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:00008C30                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p ...
.text$mn:00008C30
.text$mn:00008C30 var_1C          = dword ptr -1Ch
.text$mn:00008C30 var_18          = dword ptr -18h
.text$mn:00008C30 var_14          = dword ptr -14h
.text$mn:00008C30 var_10          = dword ptr -10h
.text$mn:00008C30 var_C           = dword ptr -0Ch
.text$mn:00008C30 var_4           = dword ptr -4
.text$mn:00008C30 arg_0           = dword ptr  8
.text$mn:00008C30 arg_4           = dword ptr  0Ch
.text$mn:00008C30
.text$mn:00008C30                 push    ebp
.text$mn:00008C31                 mov     ebp, esp
.text$mn:00008C33                 push    0FFFFFFFFh
.text$mn:00008C35                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00008C3A                 mov     eax, large fs:0
.text$mn:00008C40                 push    eax
.text$mn:00008C41                 sub     esp, 10h
.text$mn:00008C44                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008C49                 xor     eax, ebp
.text$mn:00008C4B                 push    eax
.text$mn:00008C4C                 lea     eax, [ebp+var_C]
.text$mn:00008C4F                 mov     large fs:0, eax
.text$mn:00008C55                 mov     [ebp+var_18], ecx
.text$mn:00008C58                 mov     eax, [ebp+arg_0]
.text$mn:00008C5B                 push    eax             ; void *
.text$mn:00008C5C                 push    8               ; unsigned int
.text$mn:00008C5E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00008C63                 add     esp, 8
.text$mn:00008C66                 mov     [ebp+var_10], eax
.text$mn:00008C69                 mov     [ebp+var_4], 0
.text$mn:00008C70                 cmp     [ebp+var_10], 0
.text$mn:00008C74                 jz      short loc_8C97
.text$mn:00008C76                 mov     ecx, [ebp+arg_4]
.text$mn:00008C79                 push    ecx
.text$mn:00008C7A                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00008C7F                 add     esp, 4
.text$mn:00008C82                 mov     edx, [eax]
.text$mn:00008C84                 mov     eax, [eax+4]
.text$mn:00008C87                 mov     ecx, [ebp+var_10]
.text$mn:00008C8A                 mov     [ecx], edx
.text$mn:00008C8C                 mov     [ecx+4], eax
.text$mn:00008C8F                 mov     edx, [ebp+var_10]
.text$mn:00008C92                 mov     [ebp+var_14], edx
.text$mn:00008C95                 jmp     short loc_8C9E
.text$mn:00008C97 ; ---------------------------------------------------------------------------
.text$mn:00008C97
.text$mn:00008C97 loc_8C97:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00008C97                 mov     [ebp+var_14], 0
.text$mn:00008C9E
.text$mn:00008C9E loc_8C9E:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00008C9E                 mov     eax, [ebp+var_14]
.text$mn:00008CA1                 mov     [ebp+var_1C], eax
.text$mn:00008CA4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008CAB                 mov     ecx, [ebp+var_C]
.text$mn:00008CAE                 mov     large fs:0, ecx
.text$mn:00008CB5                 pop     ecx
.text$mn:00008CB6                 mov     esp, ebp
.text$mn:00008CB8                 pop     ebp
.text$mn:00008CB9                 retn    8
.text$mn:00008CB9 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00008CB9
.text$mn:00008CB9 _text$mn        ends
.text$mn:00008CB9
.text$x:00008CBC ; ===========================================================================
.text$x:00008CBC
.text$x:00008CBC ; Segment type: Pure code
.text$x:00008CBC ; Segment permissions: Read/Execute
.text$x:00008CBC _text$x         segment para public 'CODE' use32
.text$x:00008CBC                 assume cs:_text$x
.text$x:00008CBC                 ;org 8CBCh
.text$x:00008CBC ; COMDAT (pick associative to section at 8C30)
.text$x:00008CBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008CBC
.text$x:00008CBC ; =============== S U B R O U T I N E =======================================
.text$x:00008CBC
.text$x:00008CBC
.text$x:00008CBC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00008CBC                                         ; DATA XREF: .xdata$x:00013F08o
.text$x:00008CBC                 mov     eax, [ebp+8]
.text$x:00008CBF                 push    eax
.text$x:00008CC0                 mov     eax, [ebp-10h]
.text$x:00008CC3                 push    eax             ; void *
.text$x:00008CC4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00008CC9                 add     esp, 8
.text$x:00008CCC                 retn
.text$x:00008CCC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00008CCC
.text$x:00008CCD
.text$x:00008CCD ; =============== S U B R O U T I N E =======================================
.text$x:00008CCD
.text$x:00008CCD
.text$x:00008CCD __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00008CCD                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00008CCD
.text$x:00008CCD arg_4           = dword ptr  8
.text$x:00008CCD
.text$x:00008CCD                 mov     edx, [esp+arg_4]
.text$x:00008CD1                 lea     eax, [edx+0Ch]
.text$x:00008CD4                 mov     ecx, [edx-14h]
.text$x:00008CD7                 xor     ecx, eax
.text$x:00008CD9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008CDE                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00008CE3                 jmp     ___CxxFrameHandler3
.text$x:00008CE3 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00008CE3
.text$x:00008CE3 _text$x         ends
.text$x:00008CE3
.text$mn:00008CE8 ; ===========================================================================
.text$mn:00008CE8
.text$mn:00008CE8 ; Segment type: Pure code
.text$mn:00008CE8 ; Segment permissions: Read/Execute
.text$mn:00008CE8 _text$mn        segment para public 'CODE' use32
.text$mn:00008CE8                 assume cs:_text$mn
.text$mn:00008CE8                 ;org 8CE8h
.text$mn:00008CE8 ; COMDAT (pick any)
.text$mn:00008CE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008CE8
.text$mn:00008CE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00008CE8
.text$mn:00008CE8 ; Attributes: bp-based frame
.text$mn:00008CE8
.text$mn:00008CE8 ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:00008CE8                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00008CE8 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00008CE8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:00008CE8
.text$mn:00008CE8 arg_0           = dword ptr  8
.text$mn:00008CE8 arg_4           = dword ptr  0Ch
.text$mn:00008CE8 arg_8           = dword ptr  10h
.text$mn:00008CE8
.text$mn:00008CE8                 push    ebp
.text$mn:00008CE9                 mov     ebp, esp
.text$mn:00008CEB                 mov     eax, [ebp+arg_8]
.text$mn:00008CEE                 push    eax
.text$mn:00008CEF                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00008CF4                 add     esp, 4
.text$mn:00008CF7                 push    eax             ; int
.text$mn:00008CF8                 mov     ecx, [ebp+arg_4]
.text$mn:00008CFB                 push    ecx             ; void *
.text$mn:00008CFC                 mov     ecx, [ebp+arg_0]
.text$mn:00008CFF                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00008D04                 pop     ebp
.text$mn:00008D05                 retn
.text$mn:00008D05 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:00008D05
.text$mn:00008D05 ; ---------------------------------------------------------------------------
.text$mn:00008D06                 align 4
.text$mn:00008D06 _text$mn        ends
.text$mn:00008D06
.text$mn:00008D08 ; ===========================================================================
.text$mn:00008D08
.text$mn:00008D08 ; Segment type: Pure code
.text$mn:00008D08 ; Segment permissions: Read/Execute
.text$mn:00008D08 _text$mn        segment para public 'CODE' use32
.text$mn:00008D08                 assume cs:_text$mn
.text$mn:00008D08                 ;org 8D08h
.text$mn:00008D08 ; COMDAT (pick any)
.text$mn:00008D08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008D08
.text$mn:00008D08 ; =============== S U B R O U T I N E =======================================
.text$mn:00008D08
.text$mn:00008D08 ; Attributes: bp-based frame
.text$mn:00008D08
.text$mn:00008D08 ; int __stdcall std::_Wrap_alloc<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo const &>(void *, int)
.text$mn:00008D08                 public ??$construct@UsessionFileInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@ABU2@@Z
.text$mn:00008D08 ??$construct@UsessionFileInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@ABU2@@Z proc near
.text$mn:00008D08                                         ; CODE XREF: std::_Uninit_copy<sessionFileInfo const *,sessionFileInfo *,std::allocator<sessionFileInfo>>(sessionFileInfo const *,sessionFileInfo const *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)+94p
.text$mn:00008D08
.text$mn:00008D08 var_4           = dword ptr -4
.text$mn:00008D08 arg_0           = dword ptr  8
.text$mn:00008D08 arg_4           = dword ptr  0Ch
.text$mn:00008D08
.text$mn:00008D08                 push    ebp
.text$mn:00008D09                 mov     ebp, esp
.text$mn:00008D0B                 push    ecx
.text$mn:00008D0C                 mov     [ebp+var_4], ecx
.text$mn:00008D0F                 mov     eax, [ebp+arg_4]
.text$mn:00008D12                 push    eax
.text$mn:00008D13                 call    ??$forward@ABUsessionFileInfo@@@std@@YAABUsessionFileInfo@@ABU1@@Z ; std::forward<sessionFileInfo const &>(sessionFileInfo const &)
.text$mn:00008D18                 add     esp, 4
.text$mn:00008D1B                 push    eax             ; int
.text$mn:00008D1C                 mov     ecx, [ebp+arg_0]
.text$mn:00008D1F                 push    ecx             ; void *
.text$mn:00008D20                 mov     edx, [ebp+var_4]
.text$mn:00008D23                 push    edx             ; int
.text$mn:00008D24                 call    ??$construct@UsessionFileInfo@@ABU1@@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAXAAV?$allocator@UsessionFileInfo@@@1@PAUsessionFileInfo@@ABU3@@Z ; std::allocator_traits<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo const &>(std::allocator<sessionFileInfo> &,sessionFileInfo *,sessionFileInfo const &)
.text$mn:00008D29                 add     esp, 0Ch
.text$mn:00008D2C                 mov     esp, ebp
.text$mn:00008D2E                 pop     ebp
.text$mn:00008D2F                 retn    8
.text$mn:00008D2F ??$construct@UsessionFileInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@ABU2@@Z endp
.text$mn:00008D2F
.text$mn:00008D2F ; ---------------------------------------------------------------------------
.text$mn:00008D32                 align 4
.text$mn:00008D32 _text$mn        ends
.text$mn:00008D32
.text$mn:00008D34 ; ===========================================================================
.text$mn:00008D34
.text$mn:00008D34 ; Segment type: Pure code
.text$mn:00008D34 ; Segment permissions: Read/Execute
.text$mn:00008D34 _text$mn        segment para public 'CODE' use32
.text$mn:00008D34                 assume cs:_text$mn
.text$mn:00008D34                 ;org 8D34h
.text$mn:00008D34 ; COMDAT (pick any)
.text$mn:00008D34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008D34
.text$mn:00008D34 ; =============== S U B R O U T I N E =======================================
.text$mn:00008D34
.text$mn:00008D34 ; Attributes: bp-based frame
.text$mn:00008D34
.text$mn:00008D34 ; int __cdecl std::allocator_traits<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo const &>(int, void *, int)
.text$mn:00008D34                 public ??$construct@UsessionFileInfo@@ABU1@@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAXAAV?$allocator@UsessionFileInfo@@@1@PAUsessionFileInfo@@ABU3@@Z
.text$mn:00008D34 ??$construct@UsessionFileInfo@@ABU1@@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAXAAV?$allocator@UsessionFileInfo@@@1@PAUsessionFileInfo@@ABU3@@Z proc near
.text$mn:00008D34                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo const &>(sessionFileInfo *,sessionFileInfo const &)+1Cp
.text$mn:00008D34
.text$mn:00008D34 arg_0           = dword ptr  8
.text$mn:00008D34 arg_4           = dword ptr  0Ch
.text$mn:00008D34 arg_8           = dword ptr  10h
.text$mn:00008D34
.text$mn:00008D34                 push    ebp
.text$mn:00008D35                 mov     ebp, esp
.text$mn:00008D37                 mov     eax, [ebp+arg_8]
.text$mn:00008D3A                 push    eax
.text$mn:00008D3B                 call    ??$forward@ABUsessionFileInfo@@@std@@YAABUsessionFileInfo@@ABU1@@Z ; std::forward<sessionFileInfo const &>(sessionFileInfo const &)
.text$mn:00008D40                 add     esp, 4
.text$mn:00008D43                 push    eax             ; int
.text$mn:00008D44                 mov     ecx, [ebp+arg_4]
.text$mn:00008D47                 push    ecx             ; void *
.text$mn:00008D48                 mov     ecx, [ebp+arg_0]
.text$mn:00008D4B                 call    ?construct@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@ABU3@@Z ; std::allocator<sessionFileInfo>::construct(sessionFileInfo *,sessionFileInfo const &)
.text$mn:00008D50                 pop     ebp
.text$mn:00008D51                 retn
.text$mn:00008D51 ??$construct@UsessionFileInfo@@ABU1@@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAXAAV?$allocator@UsessionFileInfo@@@1@PAUsessionFileInfo@@ABU3@@Z endp
.text$mn:00008D51
.text$mn:00008D51 ; ---------------------------------------------------------------------------
.text$mn:00008D52                 align 4
.text$mn:00008D52 _text$mn        ends
.text$mn:00008D52
.text$mn:00008D54 ; ===========================================================================
.text$mn:00008D54
.text$mn:00008D54 ; Segment type: Pure code
.text$mn:00008D54 ; Segment permissions: Read/Execute
.text$mn:00008D54 _text$mn        segment para public 'CODE' use32
.text$mn:00008D54                 assume cs:_text$mn
.text$mn:00008D54                 ;org 8D54h
.text$mn:00008D54 ; COMDAT (pick any)
.text$mn:00008D54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008D54
.text$mn:00008D54 ; =============== S U B R O U T I N E =======================================
.text$mn:00008D54
.text$mn:00008D54 ; Attributes: bp-based frame
.text$mn:00008D54
.text$mn:00008D54 ; int __stdcall std::_Wrap_alloc<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo>(void *, int)
.text$mn:00008D54                 public ??$construct@UsessionFileInfo@@U1@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z
.text$mn:00008D54 ??$construct@UsessionFileInfo@@U1@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z proc near
.text$mn:00008D54                                         ; CODE XREF: std::_Uninit_move<sessionFileInfo *,sessionFileInfo *,std::allocator<sessionFileInfo>,sessionFileInfo>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,sessionFileInfo *,std::_Nonscalar_ptr_iterator_tag)+94p
.text$mn:00008D54                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::push_back(sessionFileInfo &&)+A0p ...
.text$mn:00008D54
.text$mn:00008D54 var_4           = dword ptr -4
.text$mn:00008D54 arg_0           = dword ptr  8
.text$mn:00008D54 arg_4           = dword ptr  0Ch
.text$mn:00008D54
.text$mn:00008D54                 push    ebp
.text$mn:00008D55                 mov     ebp, esp
.text$mn:00008D57                 push    ecx
.text$mn:00008D58                 mov     [ebp+var_4], ecx
.text$mn:00008D5B                 mov     eax, [ebp+arg_4]
.text$mn:00008D5E                 push    eax
.text$mn:00008D5F                 call    ??$forward@UsessionFileInfo@@@std@@YA$$QAUsessionFileInfo@@AAU1@@Z ; std::forward<sessionFileInfo>(sessionFileInfo &)
.text$mn:00008D64                 add     esp, 4
.text$mn:00008D67                 push    eax             ; int
.text$mn:00008D68                 mov     ecx, [ebp+arg_0]
.text$mn:00008D6B                 push    ecx             ; void *
.text$mn:00008D6C                 mov     edx, [ebp+var_4]
.text$mn:00008D6F                 push    edx             ; int
.text$mn:00008D70                 call    ??$construct@UsessionFileInfo@@U1@@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAXAAV?$allocator@UsessionFileInfo@@@1@PAUsessionFileInfo@@$$QAU3@@Z ; std::allocator_traits<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo>(std::allocator<sessionFileInfo> &,sessionFileInfo *,sessionFileInfo &&)
.text$mn:00008D75                 add     esp, 0Ch
.text$mn:00008D78                 mov     esp, ebp
.text$mn:00008D7A                 pop     ebp
.text$mn:00008D7B                 retn    8
.text$mn:00008D7B ??$construct@UsessionFileInfo@@U1@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z endp
.text$mn:00008D7B
.text$mn:00008D7B ; ---------------------------------------------------------------------------
.text$mn:00008D7E                 align 10h
.text$mn:00008D7E _text$mn        ends
.text$mn:00008D7E
.text$mn:00008D80 ; ===========================================================================
.text$mn:00008D80
.text$mn:00008D80 ; Segment type: Pure code
.text$mn:00008D80 ; Segment permissions: Read/Execute
.text$mn:00008D80 _text$mn        segment para public 'CODE' use32
.text$mn:00008D80                 assume cs:_text$mn
.text$mn:00008D80                 ;org 8D80h
.text$mn:00008D80 ; COMDAT (pick any)
.text$mn:00008D80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008D80
.text$mn:00008D80 ; =============== S U B R O U T I N E =======================================
.text$mn:00008D80
.text$mn:00008D80 ; Attributes: bp-based frame
.text$mn:00008D80
.text$mn:00008D80 ; int __stdcall std::allocator<sessionFileInfo>::construct<sessionFileInfo,sessionFileInfo>(void *, int)
.text$mn:00008D80                 public ??$construct@UsessionFileInfo@@U1@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z
.text$mn:00008D80 ??$construct@UsessionFileInfo@@U1@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z proc near
.text$mn:00008D80                                         ; CODE XREF: std::allocator_traits<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo>(std::allocator<sessionFileInfo> &,sessionFileInfo *,sessionFileInfo &&)+17p
.text$mn:00008D80
.text$mn:00008D80 var_1C          = dword ptr -1Ch
.text$mn:00008D80 var_18          = dword ptr -18h
.text$mn:00008D80 var_14          = dword ptr -14h
.text$mn:00008D80 var_10          = dword ptr -10h
.text$mn:00008D80 var_C           = dword ptr -0Ch
.text$mn:00008D80 var_4           = dword ptr -4
.text$mn:00008D80 arg_0           = dword ptr  8
.text$mn:00008D80 arg_4           = dword ptr  0Ch
.text$mn:00008D80
.text$mn:00008D80                 push    ebp
.text$mn:00008D81                 mov     ebp, esp
.text$mn:00008D83                 push    0FFFFFFFFh
.text$mn:00008D85                 push    offset __ehhandler$??$construct@UsessionFileInfo@@U1@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z
.text$mn:00008D8A                 mov     eax, large fs:0
.text$mn:00008D90                 push    eax
.text$mn:00008D91                 sub     esp, 10h
.text$mn:00008D94                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008D99                 xor     eax, ebp
.text$mn:00008D9B                 push    eax
.text$mn:00008D9C                 lea     eax, [ebp+var_C]
.text$mn:00008D9F                 mov     large fs:0, eax
.text$mn:00008DA5                 mov     [ebp+var_18], ecx
.text$mn:00008DA8                 mov     eax, [ebp+arg_0]
.text$mn:00008DAB                 push    eax             ; void *
.text$mn:00008DAC                 push    98h ; 'ÿ'       ; unsigned int
.text$mn:00008DB1                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00008DB6                 add     esp, 8
.text$mn:00008DB9                 mov     [ebp+var_10], eax
.text$mn:00008DBC                 mov     [ebp+var_4], 0
.text$mn:00008DC3                 cmp     [ebp+var_10], 0
.text$mn:00008DC7                 jz      short loc_8DE3
.text$mn:00008DC9                 mov     ecx, [ebp+arg_4]
.text$mn:00008DCC                 push    ecx
.text$mn:00008DCD                 call    ??$forward@UsessionFileInfo@@@std@@YA$$QAUsessionFileInfo@@AAU1@@Z ; std::forward<sessionFileInfo>(sessionFileInfo &)
.text$mn:00008DD2                 add     esp, 4
.text$mn:00008DD5                 push    eax
.text$mn:00008DD6                 mov     ecx, [ebp+var_10]
.text$mn:00008DD9                 call    ??0sessionFileInfo@@QAE@ABU0@@Z ; sessionFileInfo::sessionFileInfo(sessionFileInfo const &)
.text$mn:00008DDE                 mov     [ebp+var_14], eax
.text$mn:00008DE1                 jmp     short loc_8DEA
.text$mn:00008DE3 ; ---------------------------------------------------------------------------
.text$mn:00008DE3
.text$mn:00008DE3 loc_8DE3:                               ; CODE XREF: std::allocator<sessionFileInfo>::construct<sessionFileInfo,sessionFileInfo>(sessionFileInfo *,sessionFileInfo &&)+47j
.text$mn:00008DE3                 mov     [ebp+var_14], 0
.text$mn:00008DEA
.text$mn:00008DEA loc_8DEA:                               ; CODE XREF: std::allocator<sessionFileInfo>::construct<sessionFileInfo,sessionFileInfo>(sessionFileInfo *,sessionFileInfo &&)+61j
.text$mn:00008DEA                 mov     edx, [ebp+var_14]
.text$mn:00008DED                 mov     [ebp+var_1C], edx
.text$mn:00008DF0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008DF7                 mov     ecx, [ebp+var_C]
.text$mn:00008DFA                 mov     large fs:0, ecx
.text$mn:00008E01                 pop     ecx
.text$mn:00008E02                 mov     esp, ebp
.text$mn:00008E04                 pop     ebp
.text$mn:00008E05                 retn    8
.text$mn:00008E05 ??$construct@UsessionFileInfo@@U1@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z endp
.text$mn:00008E05
.text$mn:00008E05 _text$mn        ends
.text$mn:00008E05
.text$x:00008E08 ; ===========================================================================
.text$x:00008E08
.text$x:00008E08 ; Segment type: Pure code
.text$x:00008E08 ; Segment permissions: Read/Execute
.text$x:00008E08 _text$x         segment para public 'CODE' use32
.text$x:00008E08                 assume cs:_text$x
.text$x:00008E08                 ;org 8E08h
.text$x:00008E08 ; COMDAT (pick associative to section at 8D80)
.text$x:00008E08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008E08
.text$x:00008E08 ; =============== S U B R O U T I N E =======================================
.text$x:00008E08
.text$x:00008E08
.text$x:00008E08 __unwindfunclet$??$construct@UsessionFileInfo@@U1@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z$0 proc near
.text$x:00008E08                                         ; DATA XREF: .xdata$x:00013FD0o
.text$x:00008E08                 mov     eax, [ebp+8]
.text$x:00008E0B                 push    eax
.text$x:00008E0C                 mov     eax, [ebp-10h]
.text$x:00008E0F                 push    eax             ; void *
.text$x:00008E10                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00008E15                 add     esp, 8
.text$x:00008E18                 retn
.text$x:00008E18 __unwindfunclet$??$construct@UsessionFileInfo@@U1@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z$0 endp
.text$x:00008E18
.text$x:00008E19
.text$x:00008E19 ; =============== S U B R O U T I N E =======================================
.text$x:00008E19
.text$x:00008E19
.text$x:00008E19 __ehhandler$??$construct@UsessionFileInfo@@U1@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z proc near
.text$x:00008E19                                         ; DATA XREF: std::allocator<sessionFileInfo>::construct<sessionFileInfo,sessionFileInfo>(sessionFileInfo *,sessionFileInfo &&)+5o
.text$x:00008E19
.text$x:00008E19 arg_4           = dword ptr  8
.text$x:00008E19
.text$x:00008E19                 mov     edx, [esp+arg_4]
.text$x:00008E1D                 lea     eax, [edx+0Ch]
.text$x:00008E20                 mov     ecx, [edx-14h]
.text$x:00008E23                 xor     ecx, eax
.text$x:00008E25                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008E2A                 mov     eax, offset __ehfuncinfo$??$construct@UsessionFileInfo@@U1@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z
.text$x:00008E2F                 jmp     ___CxxFrameHandler3
.text$x:00008E2F __ehhandler$??$construct@UsessionFileInfo@@U1@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z endp
.text$x:00008E2F
.text$x:00008E2F _text$x         ends
.text$x:00008E2F
.text$mn:00008E34 ; ===========================================================================
.text$mn:00008E34
.text$mn:00008E34 ; Segment type: Pure code
.text$mn:00008E34 ; Segment permissions: Read/Execute
.text$mn:00008E34 _text$mn        segment para public 'CODE' use32
.text$mn:00008E34                 assume cs:_text$mn
.text$mn:00008E34                 ;org 8E34h
.text$mn:00008E34 ; COMDAT (pick any)
.text$mn:00008E34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E34
.text$mn:00008E34 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E34
.text$mn:00008E34 ; Attributes: bp-based frame
.text$mn:00008E34
.text$mn:00008E34 ; int __cdecl std::allocator_traits<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo>(int, void *, int)
.text$mn:00008E34                 public ??$construct@UsessionFileInfo@@U1@@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAXAAV?$allocator@UsessionFileInfo@@@1@PAUsessionFileInfo@@$$QAU3@@Z
.text$mn:00008E34 ??$construct@UsessionFileInfo@@U1@@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAXAAV?$allocator@UsessionFileInfo@@@1@PAUsessionFileInfo@@$$QAU3@@Z proc near
.text$mn:00008E34                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo>(sessionFileInfo *,sessionFileInfo &&)+1Cp
.text$mn:00008E34
.text$mn:00008E34 arg_0           = dword ptr  8
.text$mn:00008E34 arg_4           = dword ptr  0Ch
.text$mn:00008E34 arg_8           = dword ptr  10h
.text$mn:00008E34
.text$mn:00008E34                 push    ebp
.text$mn:00008E35                 mov     ebp, esp
.text$mn:00008E37                 mov     eax, [ebp+arg_8]
.text$mn:00008E3A                 push    eax
.text$mn:00008E3B                 call    ??$forward@UsessionFileInfo@@@std@@YA$$QAUsessionFileInfo@@AAU1@@Z ; std::forward<sessionFileInfo>(sessionFileInfo &)
.text$mn:00008E40                 add     esp, 4
.text$mn:00008E43                 push    eax             ; int
.text$mn:00008E44                 mov     ecx, [ebp+arg_4]
.text$mn:00008E47                 push    ecx             ; void *
.text$mn:00008E48                 mov     ecx, [ebp+arg_0]
.text$mn:00008E4B                 call    ??$construct@UsessionFileInfo@@U1@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z ; std::allocator<sessionFileInfo>::construct<sessionFileInfo,sessionFileInfo>(sessionFileInfo *,sessionFileInfo &&)
.text$mn:00008E50                 pop     ebp
.text$mn:00008E51                 retn
.text$mn:00008E51 ??$construct@UsessionFileInfo@@U1@@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAXAAV?$allocator@UsessionFileInfo@@@1@PAUsessionFileInfo@@$$QAU3@@Z endp
.text$mn:00008E51
.text$mn:00008E51 ; ---------------------------------------------------------------------------
.text$mn:00008E52                 align 4
.text$mn:00008E52 _text$mn        ends
.text$mn:00008E52
.text$mn:00008E54 ; ===========================================================================
.text$mn:00008E54
.text$mn:00008E54 ; Segment type: Pure code
.text$mn:00008E54 ; Segment permissions: Read/Execute
.text$mn:00008E54 _text$mn        segment para public 'CODE' use32
.text$mn:00008E54                 assume cs:_text$mn
.text$mn:00008E54                 ;org 8E54h
.text$mn:00008E54 ; COMDAT (pick any)
.text$mn:00008E54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E54
.text$mn:00008E54 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E54
.text$mn:00008E54 ; Attributes: bp-based frame
.text$mn:00008E54
.text$mn:00008E54 ; int __stdcall std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(void *, int)
.text$mn:00008E54                 public ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z
.text$mn:00008E54 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z proc near
.text$mn:00008E54                                         ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:00008E54                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+9Dp ...
.text$mn:00008E54
.text$mn:00008E54 var_4           = dword ptr -4
.text$mn:00008E54 arg_0           = dword ptr  8
.text$mn:00008E54 arg_4           = dword ptr  0Ch
.text$mn:00008E54
.text$mn:00008E54                 push    ebp
.text$mn:00008E55                 mov     ebp, esp
.text$mn:00008E57                 push    ecx
.text$mn:00008E58                 mov     [ebp+var_4], ecx
.text$mn:00008E5B                 mov     eax, [ebp+arg_4]
.text$mn:00008E5E                 push    eax
.text$mn:00008E5F                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00008E64                 add     esp, 4
.text$mn:00008E67                 push    eax             ; int
.text$mn:00008E68                 mov     ecx, [ebp+arg_0]
.text$mn:00008E6B                 push    ecx             ; void *
.text$mn:00008E6C                 mov     edx, [ebp+var_4]
.text$mn:00008E6F                 push    edx             ; int
.text$mn:00008E70                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV31@@Z ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00008E75                 add     esp, 0Ch
.text$mn:00008E78                 mov     esp, ebp
.text$mn:00008E7A                 pop     ebp
.text$mn:00008E7B                 retn    8
.text$mn:00008E7B ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z endp
.text$mn:00008E7B
.text$mn:00008E7B ; ---------------------------------------------------------------------------
.text$mn:00008E7E                 align 10h
.text$mn:00008E7E _text$mn        ends
.text$mn:00008E7E
.text$mn:00008E80 ; ===========================================================================
.text$mn:00008E80
.text$mn:00008E80 ; Segment type: Pure code
.text$mn:00008E80 ; Segment permissions: Read/Execute
.text$mn:00008E80 _text$mn        segment para public 'CODE' use32
.text$mn:00008E80                 assume cs:_text$mn
.text$mn:00008E80                 ;org 8E80h
.text$mn:00008E80 ; COMDAT (pick any)
.text$mn:00008E80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E80
.text$mn:00008E80 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E80
.text$mn:00008E80 ; Attributes: bp-based frame
.text$mn:00008E80
.text$mn:00008E80 ; int __stdcall std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(void *, int)
.text$mn:00008E80                 public ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z
.text$mn:00008E80 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z proc near
.text$mn:00008E80                                         ; CODE XREF: std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+17p
.text$mn:00008E80
.text$mn:00008E80 var_1C          = dword ptr -1Ch
.text$mn:00008E80 var_18          = dword ptr -18h
.text$mn:00008E80 var_14          = dword ptr -14h
.text$mn:00008E80 var_10          = dword ptr -10h
.text$mn:00008E80 var_C           = dword ptr -0Ch
.text$mn:00008E80 var_4           = dword ptr -4
.text$mn:00008E80 arg_0           = dword ptr  8
.text$mn:00008E80 arg_4           = dword ptr  0Ch
.text$mn:00008E80
.text$mn:00008E80                 push    ebp
.text$mn:00008E81                 mov     ebp, esp
.text$mn:00008E83                 push    0FFFFFFFFh
.text$mn:00008E85                 push    offset __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z
.text$mn:00008E8A                 mov     eax, large fs:0
.text$mn:00008E90                 push    eax
.text$mn:00008E91                 sub     esp, 10h
.text$mn:00008E94                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008E99                 xor     eax, ebp
.text$mn:00008E9B                 push    eax
.text$mn:00008E9C                 lea     eax, [ebp+var_C]
.text$mn:00008E9F                 mov     large fs:0, eax
.text$mn:00008EA5                 mov     [ebp+var_18], ecx
.text$mn:00008EA8                 mov     eax, [ebp+arg_0]
.text$mn:00008EAB                 push    eax             ; void *
.text$mn:00008EAC                 push    1Ch             ; unsigned int
.text$mn:00008EAE                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00008EB3                 add     esp, 8
.text$mn:00008EB6                 mov     [ebp+var_10], eax
.text$mn:00008EB9                 mov     [ebp+var_4], 0
.text$mn:00008EC0                 cmp     [ebp+var_10], 0
.text$mn:00008EC4                 jz      short loc_8EE0
.text$mn:00008EC6                 mov     ecx, [ebp+arg_4]
.text$mn:00008EC9                 push    ecx
.text$mn:00008ECA                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00008ECF                 add     esp, 4
.text$mn:00008ED2                 push    eax
.text$mn:00008ED3                 mov     ecx, [ebp+var_10]
.text$mn:00008ED6                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00008EDB                 mov     [ebp+var_14], eax
.text$mn:00008EDE                 jmp     short loc_8EE7
.text$mn:00008EE0 ; ---------------------------------------------------------------------------
.text$mn:00008EE0
.text$mn:00008EE0 loc_8EE0:                               ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+44j
.text$mn:00008EE0                 mov     [ebp+var_14], 0
.text$mn:00008EE7
.text$mn:00008EE7 loc_8EE7:                               ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+5Ej
.text$mn:00008EE7                 mov     edx, [ebp+var_14]
.text$mn:00008EEA                 mov     [ebp+var_1C], edx
.text$mn:00008EED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008EF4                 mov     ecx, [ebp+var_C]
.text$mn:00008EF7                 mov     large fs:0, ecx
.text$mn:00008EFE                 pop     ecx
.text$mn:00008EFF                 mov     esp, ebp
.text$mn:00008F01                 pop     ebp
.text$mn:00008F02                 retn    8
.text$mn:00008F02 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z endp
.text$mn:00008F02
.text$mn:00008F02 ; ---------------------------------------------------------------------------
.text$mn:00008F05                 align 4
.text$mn:00008F05 _text$mn        ends
.text$mn:00008F05
.text$x:00008F08 ; ===========================================================================
.text$x:00008F08
.text$x:00008F08 ; Segment type: Pure code
.text$x:00008F08 ; Segment permissions: Read/Execute
.text$x:00008F08 _text$x         segment para public 'CODE' use32
.text$x:00008F08                 assume cs:_text$x
.text$x:00008F08                 ;org 8F08h
.text$x:00008F08 ; COMDAT (pick associative to section at 8E80)
.text$x:00008F08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008F08
.text$x:00008F08 ; =============== S U B R O U T I N E =======================================
.text$x:00008F08
.text$x:00008F08
.text$x:00008F08 __unwindfunclet$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z$0 proc near
.text$x:00008F08                                         ; DATA XREF: .xdata$x:00013FFCo
.text$x:00008F08                 mov     eax, [ebp+8]
.text$x:00008F0B                 push    eax
.text$x:00008F0C                 mov     eax, [ebp-10h]
.text$x:00008F0F                 push    eax             ; void *
.text$x:00008F10                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00008F15                 add     esp, 8
.text$x:00008F18                 retn
.text$x:00008F18 __unwindfunclet$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z$0 endp
.text$x:00008F18
.text$x:00008F19
.text$x:00008F19 ; =============== S U B R O U T I N E =======================================
.text$x:00008F19
.text$x:00008F19
.text$x:00008F19 __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z proc near
.text$x:00008F19                                         ; DATA XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+5o
.text$x:00008F19
.text$x:00008F19 arg_4           = dword ptr  8
.text$x:00008F19
.text$x:00008F19                 mov     edx, [esp+arg_4]
.text$x:00008F1D                 lea     eax, [edx+0Ch]
.text$x:00008F20                 mov     ecx, [edx-14h]
.text$x:00008F23                 xor     ecx, eax
.text$x:00008F25                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008F2A                 mov     eax, offset __ehfuncinfo$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z
.text$x:00008F2F                 jmp     ___CxxFrameHandler3
.text$x:00008F2F __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z endp
.text$x:00008F2F
.text$x:00008F2F _text$x         ends
.text$x:00008F2F
.text$mn:00008F34 ; ===========================================================================
.text$mn:00008F34
.text$mn:00008F34 ; Segment type: Pure code
.text$mn:00008F34 ; Segment permissions: Read/Execute
.text$mn:00008F34 _text$mn        segment para public 'CODE' use32
.text$mn:00008F34                 assume cs:_text$mn
.text$mn:00008F34                 ;org 8F34h
.text$mn:00008F34 ; COMDAT (pick any)
.text$mn:00008F34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F34
.text$mn:00008F34 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F34
.text$mn:00008F34 ; Attributes: bp-based frame
.text$mn:00008F34
.text$mn:00008F34 ; int __cdecl std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(int, void *, int)
.text$mn:00008F34                 public ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV31@@Z
.text$mn:00008F34 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV31@@Z proc near
.text$mn:00008F34                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+1Cp
.text$mn:00008F34
.text$mn:00008F34 arg_0           = dword ptr  8
.text$mn:00008F34 arg_4           = dword ptr  0Ch
.text$mn:00008F34 arg_8           = dword ptr  10h
.text$mn:00008F34
.text$mn:00008F34                 push    ebp
.text$mn:00008F35                 mov     ebp, esp
.text$mn:00008F37                 mov     eax, [ebp+arg_8]
.text$mn:00008F3A                 push    eax
.text$mn:00008F3B                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00008F40                 add     esp, 4
.text$mn:00008F43                 push    eax             ; int
.text$mn:00008F44                 mov     ecx, [ebp+arg_4]
.text$mn:00008F47                 push    ecx             ; void *
.text$mn:00008F48                 mov     ecx, [ebp+arg_0]
.text$mn:00008F4B                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00008F50                 pop     ebp
.text$mn:00008F51                 retn
.text$mn:00008F51 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV31@@Z endp
.text$mn:00008F51
.text$mn:00008F51 ; ---------------------------------------------------------------------------
.text$mn:00008F52                 align 4
.text$mn:00008F52 _text$mn        ends
.text$mn:00008F52
.text$mn:00008F54 ; ===========================================================================
.text$mn:00008F54
.text$mn:00008F54 ; Segment type: Pure code
.text$mn:00008F54 ; Segment permissions: Read/Execute
.text$mn:00008F54 _text$mn        segment para public 'CODE' use32
.text$mn:00008F54                 assume cs:_text$mn
.text$mn:00008F54                 ;org 8F54h
.text$mn:00008F54 ; COMDAT (pick any)
.text$mn:00008F54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F54
.text$mn:00008F54 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F54
.text$mn:00008F54 ; Attributes: bp-based frame
.text$mn:00008F54
.text$mn:00008F54 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00008F54                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00008F54 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00008F54                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00008F54
.text$mn:00008F54 var_4           = dword ptr -4
.text$mn:00008F54 arg_0           = dword ptr  8
.text$mn:00008F54
.text$mn:00008F54                 push    ebp
.text$mn:00008F55                 mov     ebp, esp
.text$mn:00008F57                 push    ecx
.text$mn:00008F58                 mov     [ebp+var_4], ecx
.text$mn:00008F5B                 mov     eax, [ebp+arg_0]
.text$mn:00008F5E                 push    eax
.text$mn:00008F5F                 mov     ecx, [ebp+var_4]
.text$mn:00008F62                 push    ecx
.text$mn:00008F63                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00008F68                 add     esp, 8
.text$mn:00008F6B                 mov     esp, ebp
.text$mn:00008F6D                 pop     ebp
.text$mn:00008F6E                 retn    4
.text$mn:00008F6E ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00008F6E
.text$mn:00008F6E ; ---------------------------------------------------------------------------
.text$mn:00008F71                 align 4
.text$mn:00008F71 _text$mn        ends
.text$mn:00008F71
.text$mn:00008F74 ; ===========================================================================
.text$mn:00008F74
.text$mn:00008F74 ; Segment type: Pure code
.text$mn:00008F74 ; Segment permissions: Read/Execute
.text$mn:00008F74 _text$mn        segment para public 'CODE' use32
.text$mn:00008F74                 assume cs:_text$mn
.text$mn:00008F74                 ;org 8F74h
.text$mn:00008F74 ; COMDAT (pick any)
.text$mn:00008F74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F74
.text$mn:00008F74 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F74
.text$mn:00008F74 ; Attributes: bp-based frame
.text$mn:00008F74
.text$mn:00008F74 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00008F74                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00008F74 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00008F74                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00008F74
.text$mn:00008F74 var_4           = dword ptr -4
.text$mn:00008F74
.text$mn:00008F74                 push    ebp
.text$mn:00008F75                 mov     ebp, esp
.text$mn:00008F77                 push    ecx
.text$mn:00008F78                 mov     [ebp+var_4], ecx
.text$mn:00008F7B                 mov     esp, ebp
.text$mn:00008F7D                 pop     ebp
.text$mn:00008F7E                 retn    4
.text$mn:00008F7E ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00008F7E
.text$mn:00008F7E ; ---------------------------------------------------------------------------
.text$mn:00008F81                 align 4
.text$mn:00008F81 _text$mn        ends
.text$mn:00008F81
.text$mn:00008F84 ; ===========================================================================
.text$mn:00008F84
.text$mn:00008F84 ; Segment type: Pure code
.text$mn:00008F84 ; Segment permissions: Read/Execute
.text$mn:00008F84 _text$mn        segment para public 'CODE' use32
.text$mn:00008F84                 assume cs:_text$mn
.text$mn:00008F84                 ;org 8F84h
.text$mn:00008F84 ; COMDAT (pick any)
.text$mn:00008F84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F84
.text$mn:00008F84 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F84
.text$mn:00008F84 ; Attributes: bp-based frame
.text$mn:00008F84
.text$mn:00008F84 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00008F84                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00008F84 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00008F84                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00008F84
.text$mn:00008F84 arg_0           = dword ptr  8
.text$mn:00008F84 arg_4           = dword ptr  0Ch
.text$mn:00008F84
.text$mn:00008F84                 push    ebp
.text$mn:00008F85                 mov     ebp, esp
.text$mn:00008F87                 mov     eax, [ebp+arg_4]
.text$mn:00008F8A                 push    eax
.text$mn:00008F8B                 mov     ecx, [ebp+arg_0]
.text$mn:00008F8E                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00008F93                 pop     ebp
.text$mn:00008F94                 retn
.text$mn:00008F94 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00008F94
.text$mn:00008F94 ; ---------------------------------------------------------------------------
.text$mn:00008F95                 align 4
.text$mn:00008F95 _text$mn        ends
.text$mn:00008F95
.text$mn:00008F98 ; ===========================================================================
.text$mn:00008F98
.text$mn:00008F98 ; Segment type: Pure code
.text$mn:00008F98 ; Segment permissions: Read/Execute
.text$mn:00008F98 _text$mn        segment para public 'CODE' use32
.text$mn:00008F98                 assume cs:_text$mn
.text$mn:00008F98                 ;org 8F98h
.text$mn:00008F98 ; COMDAT (pick any)
.text$mn:00008F98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F98
.text$mn:00008F98 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F98
.text$mn:00008F98 ; Attributes: bp-based frame
.text$mn:00008F98
.text$mn:00008F98 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00008F98                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:00008F98 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:00008F98                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:00008F98
.text$mn:00008F98 var_4           = dword ptr -4
.text$mn:00008F98 arg_0           = dword ptr  8
.text$mn:00008F98
.text$mn:00008F98                 push    ebp
.text$mn:00008F99                 mov     ebp, esp
.text$mn:00008F9B                 push    ecx
.text$mn:00008F9C                 mov     [ebp+var_4], ecx
.text$mn:00008F9F                 mov     eax, [ebp+arg_0]
.text$mn:00008FA2                 push    eax
.text$mn:00008FA3                 mov     ecx, [ebp+var_4]
.text$mn:00008FA6                 push    ecx
.text$mn:00008FA7                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00008FAC                 add     esp, 8
.text$mn:00008FAF                 mov     esp, ebp
.text$mn:00008FB1                 pop     ebp
.text$mn:00008FB2                 retn    4
.text$mn:00008FB2 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:00008FB2
.text$mn:00008FB2 ; ---------------------------------------------------------------------------
.text$mn:00008FB5                 align 4
.text$mn:00008FB5 _text$mn        ends
.text$mn:00008FB5
.text$mn:00008FB8 ; ===========================================================================
.text$mn:00008FB8
.text$mn:00008FB8 ; Segment type: Pure code
.text$mn:00008FB8 ; Segment permissions: Read/Execute
.text$mn:00008FB8 _text$mn        segment para public 'CODE' use32
.text$mn:00008FB8                 assume cs:_text$mn
.text$mn:00008FB8                 ;org 8FB8h
.text$mn:00008FB8 ; COMDAT (pick any)
.text$mn:00008FB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008FB8
.text$mn:00008FB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00008FB8
.text$mn:00008FB8 ; Attributes: bp-based frame
.text$mn:00008FB8
.text$mn:00008FB8 ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00008FB8                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:00008FB8 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:00008FB8                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:00008FB8
.text$mn:00008FB8 var_4           = dword ptr -4
.text$mn:00008FB8
.text$mn:00008FB8                 push    ebp
.text$mn:00008FB9                 mov     ebp, esp
.text$mn:00008FBB                 push    ecx
.text$mn:00008FBC                 mov     [ebp+var_4], ecx
.text$mn:00008FBF                 mov     esp, ebp
.text$mn:00008FC1                 pop     ebp
.text$mn:00008FC2                 retn    4
.text$mn:00008FC2 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:00008FC2
.text$mn:00008FC2 ; ---------------------------------------------------------------------------
.text$mn:00008FC5                 align 4
.text$mn:00008FC5 _text$mn        ends
.text$mn:00008FC5
.text$mn:00008FC8 ; ===========================================================================
.text$mn:00008FC8
.text$mn:00008FC8 ; Segment type: Pure code
.text$mn:00008FC8 ; Segment permissions: Read/Execute
.text$mn:00008FC8 _text$mn        segment para public 'CODE' use32
.text$mn:00008FC8                 assume cs:_text$mn
.text$mn:00008FC8                 ;org 8FC8h
.text$mn:00008FC8 ; COMDAT (pick any)
.text$mn:00008FC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008FC8
.text$mn:00008FC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00008FC8
.text$mn:00008FC8 ; Attributes: bp-based frame
.text$mn:00008FC8
.text$mn:00008FC8 ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00008FC8                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00008FC8 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00008FC8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00008FC8
.text$mn:00008FC8 arg_0           = dword ptr  8
.text$mn:00008FC8 arg_4           = dword ptr  0Ch
.text$mn:00008FC8
.text$mn:00008FC8                 push    ebp
.text$mn:00008FC9                 mov     ebp, esp
.text$mn:00008FCB                 mov     eax, [ebp+arg_4]
.text$mn:00008FCE                 push    eax
.text$mn:00008FCF                 mov     ecx, [ebp+arg_0]
.text$mn:00008FD2                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00008FD7                 pop     ebp
.text$mn:00008FD8                 retn
.text$mn:00008FD8 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:00008FD8
.text$mn:00008FD8 ; ---------------------------------------------------------------------------
.text$mn:00008FD9                 align 4
.text$mn:00008FD9 _text$mn        ends
.text$mn:00008FD9
.text$mn:00008FDC ; ===========================================================================
.text$mn:00008FDC
.text$mn:00008FDC ; Segment type: Pure code
.text$mn:00008FDC ; Segment permissions: Read/Execute
.text$mn:00008FDC _text$mn        segment para public 'CODE' use32
.text$mn:00008FDC                 assume cs:_text$mn
.text$mn:00008FDC                 ;org 8FDCh
.text$mn:00008FDC ; COMDAT (pick any)
.text$mn:00008FDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008FDC
.text$mn:00008FDC ; =============== S U B R O U T I N E =======================================
.text$mn:00008FDC
.text$mn:00008FDC ; Attributes: bp-based frame
.text$mn:00008FDC
.text$mn:00008FDC ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00008FDC                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00008FDC ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00008FDC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Free_proxy(void)+22p
.text$mn:00008FDC                                         ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Free_proxy(void)+22p ...
.text$mn:00008FDC
.text$mn:00008FDC var_4           = dword ptr -4
.text$mn:00008FDC arg_0           = dword ptr  8
.text$mn:00008FDC
.text$mn:00008FDC                 push    ebp
.text$mn:00008FDD                 mov     ebp, esp
.text$mn:00008FDF                 push    ecx
.text$mn:00008FE0                 mov     [ebp+var_4], ecx
.text$mn:00008FE3                 mov     eax, [ebp+arg_0]
.text$mn:00008FE6                 push    eax
.text$mn:00008FE7                 mov     ecx, [ebp+var_4]
.text$mn:00008FEA                 push    ecx
.text$mn:00008FEB                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:00008FF0                 add     esp, 8
.text$mn:00008FF3                 mov     esp, ebp
.text$mn:00008FF5                 pop     ebp
.text$mn:00008FF6                 retn    4
.text$mn:00008FF6 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00008FF6
.text$mn:00008FF6 ; ---------------------------------------------------------------------------
.text$mn:00008FF9                 align 4
.text$mn:00008FF9 _text$mn        ends
.text$mn:00008FF9
.text$mn:00008FFC ; ===========================================================================
.text$mn:00008FFC
.text$mn:00008FFC ; Segment type: Pure code
.text$mn:00008FFC ; Segment permissions: Read/Execute
.text$mn:00008FFC _text$mn        segment para public 'CODE' use32
.text$mn:00008FFC                 assume cs:_text$mn
.text$mn:00008FFC                 ;org 8FFCh
.text$mn:00008FFC ; COMDAT (pick any)
.text$mn:00008FFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008FFC
.text$mn:00008FFC ; =============== S U B R O U T I N E =======================================
.text$mn:00008FFC
.text$mn:00008FFC ; Attributes: bp-based frame
.text$mn:00008FFC
.text$mn:00008FFC ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00008FFC                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00008FFC ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00008FFC                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:00008FFC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p ...
.text$mn:00008FFC
.text$mn:00008FFC var_4           = dword ptr -4
.text$mn:00008FFC
.text$mn:00008FFC                 push    ebp
.text$mn:00008FFD                 mov     ebp, esp
.text$mn:00008FFF                 push    ecx
.text$mn:00009000                 mov     [ebp+var_4], ecx
.text$mn:00009003                 mov     esp, ebp
.text$mn:00009005                 pop     ebp
.text$mn:00009006                 retn    4
.text$mn:00009006 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00009006
.text$mn:00009006 ; ---------------------------------------------------------------------------
.text$mn:00009009                 align 4
.text$mn:00009009 _text$mn        ends
.text$mn:00009009
.text$mn:0000900C ; ===========================================================================
.text$mn:0000900C
.text$mn:0000900C ; Segment type: Pure code
.text$mn:0000900C ; Segment permissions: Read/Execute
.text$mn:0000900C _text$mn        segment para public 'CODE' use32
.text$mn:0000900C                 assume cs:_text$mn
.text$mn:0000900C                 ;org 900Ch
.text$mn:0000900C ; COMDAT (pick any)
.text$mn:0000900C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000900C
.text$mn:0000900C ; =============== S U B R O U T I N E =======================================
.text$mn:0000900C
.text$mn:0000900C ; Attributes: bp-based frame
.text$mn:0000900C
.text$mn:0000900C ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:0000900C                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:0000900C ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:0000900C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:0000900C
.text$mn:0000900C arg_0           = dword ptr  8
.text$mn:0000900C arg_4           = dword ptr  0Ch
.text$mn:0000900C
.text$mn:0000900C                 push    ebp
.text$mn:0000900D                 mov     ebp, esp
.text$mn:0000900F                 mov     eax, [ebp+arg_4]
.text$mn:00009012                 push    eax
.text$mn:00009013                 mov     ecx, [ebp+arg_0]
.text$mn:00009016                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000901B                 pop     ebp
.text$mn:0000901C                 retn
.text$mn:0000901C ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:0000901C
.text$mn:0000901C ; ---------------------------------------------------------------------------
.text$mn:0000901D                 align 10h
.text$mn:0000901D _text$mn        ends
.text$mn:0000901D
.text$mn:00009020 ; ===========================================================================
.text$mn:00009020
.text$mn:00009020 ; Segment type: Pure code
.text$mn:00009020 ; Segment permissions: Read/Execute
.text$mn:00009020 _text$mn        segment para public 'CODE' use32
.text$mn:00009020                 assume cs:_text$mn
.text$mn:00009020                 ;org 9020h
.text$mn:00009020 ; COMDAT (pick any)
.text$mn:00009020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009020
.text$mn:00009020 ; =============== S U B R O U T I N E =======================================
.text$mn:00009020
.text$mn:00009020 ; Attributes: bp-based frame
.text$mn:00009020
.text$mn:00009020 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>>::destroy<struct sessionFileInfo>(struct sessionFileInfo *)
.text$mn:00009020                 public ??$destroy@UsessionFileInfo@@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@@Z
.text$mn:00009020 ??$destroy@UsessionFileInfo@@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@@Z proc near
.text$mn:00009020                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)+1Fp
.text$mn:00009020                                         ; __catch$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Cp ...
.text$mn:00009020
.text$mn:00009020 var_4           = dword ptr -4
.text$mn:00009020 arg_0           = dword ptr  8
.text$mn:00009020
.text$mn:00009020                 push    ebp
.text$mn:00009021                 mov     ebp, esp
.text$mn:00009023                 push    ecx
.text$mn:00009024                 mov     [ebp+var_4], ecx
.text$mn:00009027                 mov     eax, [ebp+arg_0]
.text$mn:0000902A                 push    eax
.text$mn:0000902B                 mov     ecx, [ebp+var_4]
.text$mn:0000902E                 push    ecx
.text$mn:0000902F                 call    ??$destroy@UsessionFileInfo@@@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAXAAV?$allocator@UsessionFileInfo@@@1@PAUsessionFileInfo@@@Z ; std::allocator_traits<std::allocator<sessionFileInfo>>::destroy<sessionFileInfo>(std::allocator<sessionFileInfo> &,sessionFileInfo *)
.text$mn:00009034                 add     esp, 8
.text$mn:00009037                 mov     esp, ebp
.text$mn:00009039                 pop     ebp
.text$mn:0000903A                 retn    4
.text$mn:0000903A ??$destroy@UsessionFileInfo@@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@@Z endp
.text$mn:0000903A
.text$mn:0000903A ; ---------------------------------------------------------------------------
.text$mn:0000903D                 align 10h
.text$mn:0000903D _text$mn        ends
.text$mn:0000903D
.text$mn:00009040 ; ===========================================================================
.text$mn:00009040
.text$mn:00009040 ; Segment type: Pure code
.text$mn:00009040 ; Segment permissions: Read/Execute
.text$mn:00009040 _text$mn        segment para public 'CODE' use32
.text$mn:00009040                 assume cs:_text$mn
.text$mn:00009040                 ;org 9040h
.text$mn:00009040 ; COMDAT (pick any)
.text$mn:00009040                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009040
.text$mn:00009040 ; =============== S U B R O U T I N E =======================================
.text$mn:00009040
.text$mn:00009040 ; Attributes: bp-based frame
.text$mn:00009040
.text$mn:00009040 ; public: void __thiscall std::allocator<struct sessionFileInfo>::destroy<struct sessionFileInfo>(struct sessionFileInfo *)
.text$mn:00009040                 public ??$destroy@UsessionFileInfo@@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@@Z
.text$mn:00009040 ??$destroy@UsessionFileInfo@@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@@Z proc near
.text$mn:00009040                                         ; CODE XREF: std::allocator_traits<std::allocator<sessionFileInfo>>::destroy<sessionFileInfo>(std::allocator<sessionFileInfo> &,sessionFileInfo *)+Ap
.text$mn:00009040
.text$mn:00009040 var_4           = dword ptr -4
.text$mn:00009040 arg_0           = dword ptr  8
.text$mn:00009040
.text$mn:00009040                 push    ebp
.text$mn:00009041                 mov     ebp, esp
.text$mn:00009043                 push    ecx
.text$mn:00009044                 mov     [ebp+var_4], ecx
.text$mn:00009047                 push    0
.text$mn:00009049                 mov     ecx, [ebp+arg_0]
.text$mn:0000904C                 call    ??_GsessionFileInfo@@QAEPAXI@Z ; sessionFileInfo::`scalar deleting destructor'(uint)
.text$mn:00009051                 mov     esp, ebp
.text$mn:00009053                 pop     ebp
.text$mn:00009054                 retn    4
.text$mn:00009054 ??$destroy@UsessionFileInfo@@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@@Z endp
.text$mn:00009054
.text$mn:00009054 ; ---------------------------------------------------------------------------
.text$mn:00009057                 align 4
.text$mn:00009057 _text$mn        ends
.text$mn:00009057
.text$mn:00009058 ; ===========================================================================
.text$mn:00009058
.text$mn:00009058 ; Segment type: Pure code
.text$mn:00009058 ; Segment permissions: Read/Execute
.text$mn:00009058 _text$mn        segment para public 'CODE' use32
.text$mn:00009058                 assume cs:_text$mn
.text$mn:00009058                 ;org 9058h
.text$mn:00009058 ; COMDAT (pick any)
.text$mn:00009058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009058
.text$mn:00009058 ; =============== S U B R O U T I N E =======================================
.text$mn:00009058
.text$mn:00009058 ; Attributes: bp-based frame
.text$mn:00009058
.text$mn:00009058 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct sessionFileInfo>>::destroy<struct sessionFileInfo>(class std::allocator<struct sessionFileInfo> &, struct sessionFileInfo *)
.text$mn:00009058                 public ??$destroy@UsessionFileInfo@@@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAXAAV?$allocator@UsessionFileInfo@@@1@PAUsessionFileInfo@@@Z
.text$mn:00009058 ??$destroy@UsessionFileInfo@@@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAXAAV?$allocator@UsessionFileInfo@@@1@PAUsessionFileInfo@@@Z proc near
.text$mn:00009058                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<sessionFileInfo>>::destroy<sessionFileInfo>(sessionFileInfo *)+Fp
.text$mn:00009058
.text$mn:00009058 arg_0           = dword ptr  8
.text$mn:00009058 arg_4           = dword ptr  0Ch
.text$mn:00009058
.text$mn:00009058                 push    ebp
.text$mn:00009059                 mov     ebp, esp
.text$mn:0000905B                 mov     eax, [ebp+arg_4]
.text$mn:0000905E                 push    eax
.text$mn:0000905F                 mov     ecx, [ebp+arg_0]
.text$mn:00009062                 call    ??$destroy@UsessionFileInfo@@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@@Z ; std::allocator<sessionFileInfo>::destroy<sessionFileInfo>(sessionFileInfo *)
.text$mn:00009067                 pop     ebp
.text$mn:00009068                 retn
.text$mn:00009068 ??$destroy@UsessionFileInfo@@@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAXAAV?$allocator@UsessionFileInfo@@@1@PAUsessionFileInfo@@@Z endp
.text$mn:00009068
.text$mn:00009068 ; ---------------------------------------------------------------------------
.text$mn:00009069                 align 4
.text$mn:00009069 _text$mn        ends
.text$mn:00009069
.text$mn:0000906C ; ===========================================================================
.text$mn:0000906C
.text$mn:0000906C ; Segment type: Pure code
.text$mn:0000906C ; Segment permissions: Read/Execute
.text$mn:0000906C _text$mn        segment para public 'CODE' use32
.text$mn:0000906C                 assume cs:_text$mn
.text$mn:0000906C                 ;org 906Ch
.text$mn:0000906C ; COMDAT (pick any)
.text$mn:0000906C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000906C
.text$mn:0000906C ; =============== S U B R O U T I N E =======================================
.text$mn:0000906C
.text$mn:0000906C ; Attributes: bp-based frame
.text$mn:0000906C
.text$mn:0000906C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::destroy<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:0000906C                 public ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
.text$mn:0000906C ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z proc near
.text$mn:0000906C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:0000906C                                         ; __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap
.text$mn:0000906C
.text$mn:0000906C var_4           = dword ptr -4
.text$mn:0000906C arg_0           = dword ptr  8
.text$mn:0000906C
.text$mn:0000906C                 push    ebp
.text$mn:0000906D                 mov     ebp, esp
.text$mn:0000906F                 push    ecx
.text$mn:00009070                 mov     [ebp+var_4], ecx
.text$mn:00009073                 mov     eax, [ebp+arg_0]
.text$mn:00009076                 push    eax
.text$mn:00009077                 mov     ecx, [ebp+var_4]
.text$mn:0000907A                 push    ecx
.text$mn:0000907B                 call    ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00009080                 add     esp, 8
.text$mn:00009083                 mov     esp, ebp
.text$mn:00009085                 pop     ebp
.text$mn:00009086                 retn    4
.text$mn:00009086 ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z endp
.text$mn:00009086
.text$mn:00009086 ; ---------------------------------------------------------------------------
.text$mn:00009089                 align 4
.text$mn:00009089 _text$mn        ends
.text$mn:00009089
.text$mn:0000908C ; ===========================================================================
.text$mn:0000908C
.text$mn:0000908C ; Segment type: Pure code
.text$mn:0000908C ; Segment permissions: Read/Execute
.text$mn:0000908C _text$mn        segment para public 'CODE' use32
.text$mn:0000908C                 assume cs:_text$mn
.text$mn:0000908C                 ;org 908Ch
.text$mn:0000908C ; COMDAT (pick any)
.text$mn:0000908C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000908C
.text$mn:0000908C ; =============== S U B R O U T I N E =======================================
.text$mn:0000908C
.text$mn:0000908C ; Attributes: bp-based frame
.text$mn:0000908C
.text$mn:0000908C ; public: void __thiscall std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>::destroy<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:0000908C                 public ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
.text$mn:0000908C ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z proc near
.text$mn:0000908C                                         ; CODE XREF: std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+Ap
.text$mn:0000908C
.text$mn:0000908C var_4           = dword ptr -4
.text$mn:0000908C arg_0           = dword ptr  8
.text$mn:0000908C
.text$mn:0000908C                 push    ebp
.text$mn:0000908D                 mov     ebp, esp
.text$mn:0000908F                 push    ecx
.text$mn:00009090                 mov     [ebp+var_4], ecx
.text$mn:00009093                 push    0
.text$mn:00009095                 mov     ecx, [ebp+arg_0]
.text$mn:00009098                 call    ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`scalar deleting destructor'(uint)
.text$mn:0000909D                 mov     esp, ebp
.text$mn:0000909F                 pop     ebp
.text$mn:000090A0                 retn    4
.text$mn:000090A0 ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z endp
.text$mn:000090A0
.text$mn:000090A0 ; ---------------------------------------------------------------------------
.text$mn:000090A3                 align 4
.text$mn:000090A3 _text$mn        ends
.text$mn:000090A3
.text$mn:000090A4 ; ===========================================================================
.text$mn:000090A4
.text$mn:000090A4 ; Segment type: Pure code
.text$mn:000090A4 ; Segment permissions: Read/Execute
.text$mn:000090A4 _text$mn        segment para public 'CODE' use32
.text$mn:000090A4                 assume cs:_text$mn
.text$mn:000090A4                 ;org 90A4h
.text$mn:000090A4 ; COMDAT (pick any)
.text$mn:000090A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000090A4
.text$mn:000090A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000090A4
.text$mn:000090A4 ; Attributes: bp-based frame
.text$mn:000090A4
.text$mn:000090A4 ; public: static void __cdecl std::allocator_traits<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::destroy<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>> &, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:000090A4                 public ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
.text$mn:000090A4 ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z proc near
.text$mn:000090A4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+Fp
.text$mn:000090A4
.text$mn:000090A4 arg_0           = dword ptr  8
.text$mn:000090A4 arg_4           = dword ptr  0Ch
.text$mn:000090A4
.text$mn:000090A4                 push    ebp
.text$mn:000090A5                 mov     ebp, esp
.text$mn:000090A7                 mov     eax, [ebp+arg_4]
.text$mn:000090AA                 push    eax
.text$mn:000090AB                 mov     ecx, [ebp+arg_0]
.text$mn:000090AE                 call    ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:000090B3                 pop     ebp
.text$mn:000090B4                 retn
.text$mn:000090B4 ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z endp
.text$mn:000090B4
.text$mn:000090B4 ; ---------------------------------------------------------------------------
.text$mn:000090B5                 align 4
.text$mn:000090B5 _text$mn        ends
.text$mn:000090B5
.text$mn:000090B8 ; ===========================================================================
.text$mn:000090B8
.text$mn:000090B8 ; Segment type: Pure code
.text$mn:000090B8 ; Segment permissions: Read/Execute
.text$mn:000090B8 _text$mn        segment para public 'CODE' use32
.text$mn:000090B8                 assume cs:_text$mn
.text$mn:000090B8                 ;org 90B8h
.text$mn:000090B8 ; COMDAT (pick any)
.text$mn:000090B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000090B8
.text$mn:000090B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000090B8
.text$mn:000090B8 ; Attributes: bp-based frame
.text$mn:000090B8
.text$mn:000090B8 ; int & __cdecl std::forward<int &>(int &)
.text$mn:000090B8                 public ??$forward@AAH@std@@YAAAHAAH@Z
.text$mn:000090B8 ??$forward@AAH@std@@YAAAHAAH@Z proc near
.text$mn:000090B8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::construct<int,int &>(int *,int &)+Bp
.text$mn:000090B8                                         ; std::allocator<int>::construct<int,int &>(int *,int &)+4Ap ...
.text$mn:000090B8
.text$mn:000090B8 arg_0           = dword ptr  8
.text$mn:000090B8
.text$mn:000090B8                 push    ebp
.text$mn:000090B9                 mov     ebp, esp
.text$mn:000090BB                 mov     eax, [ebp+arg_0]
.text$mn:000090BE                 pop     ebp
.text$mn:000090BF                 retn
.text$mn:000090BF ??$forward@AAH@std@@YAAAHAAH@Z endp
.text$mn:000090BF
.text$mn:000090BF _text$mn        ends
.text$mn:000090BF
.text$mn:000090C0 ; ===========================================================================
.text$mn:000090C0
.text$mn:000090C0 ; Segment type: Pure code
.text$mn:000090C0 ; Segment permissions: Read/Execute
.text$mn:000090C0 _text$mn        segment para public 'CODE' use32
.text$mn:000090C0                 assume cs:_text$mn
.text$mn:000090C0                 ;org 90C0h
.text$mn:000090C0 ; COMDAT (pick any)
.text$mn:000090C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000090C0
.text$mn:000090C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000090C0
.text$mn:000090C0 ; Attributes: bp-based frame
.text$mn:000090C0
.text$mn:000090C0 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:000090C0                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:000090C0 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:000090C0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:000090C0                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:000090C0
.text$mn:000090C0 arg_0           = dword ptr  8
.text$mn:000090C0
.text$mn:000090C0                 push    ebp
.text$mn:000090C1                 mov     ebp, esp
.text$mn:000090C3                 mov     eax, [ebp+arg_0]
.text$mn:000090C6                 pop     ebp
.text$mn:000090C7                 retn
.text$mn:000090C7 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:000090C7
.text$mn:000090C7 _text$mn        ends
.text$mn:000090C7
.text$mn:000090C8 ; ===========================================================================
.text$mn:000090C8
.text$mn:000090C8 ; Segment type: Pure code
.text$mn:000090C8 ; Segment permissions: Read/Execute
.text$mn:000090C8 _text$mn        segment para public 'CODE' use32
.text$mn:000090C8                 assume cs:_text$mn
.text$mn:000090C8                 ;org 90C8h
.text$mn:000090C8 ; COMDAT (pick any)
.text$mn:000090C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000090C8
.text$mn:000090C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000090C8
.text$mn:000090C8 ; Attributes: bp-based frame
.text$mn:000090C8
.text$mn:000090C8 ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000090C8                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:000090C8 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:000090C8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:000090C8                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:000090C8
.text$mn:000090C8 arg_0           = dword ptr  8
.text$mn:000090C8
.text$mn:000090C8                 push    ebp
.text$mn:000090C9                 mov     ebp, esp
.text$mn:000090CB                 mov     eax, [ebp+arg_0]
.text$mn:000090CE                 pop     ebp
.text$mn:000090CF                 retn
.text$mn:000090CF ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:000090CF
.text$mn:000090CF _text$mn        ends
.text$mn:000090CF
.text$mn:000090D0 ; ===========================================================================
.text$mn:000090D0
.text$mn:000090D0 ; Segment type: Pure code
.text$mn:000090D0 ; Segment permissions: Read/Execute
.text$mn:000090D0 _text$mn        segment para public 'CODE' use32
.text$mn:000090D0                 assume cs:_text$mn
.text$mn:000090D0                 ;org 90D0h
.text$mn:000090D0 ; COMDAT (pick any)
.text$mn:000090D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000090D0
.text$mn:000090D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000090D0
.text$mn:000090D0 ; Attributes: bp-based frame
.text$mn:000090D0
.text$mn:000090D0 ; int const & __cdecl std::forward<int const &>(int const &)
.text$mn:000090D0                 public ??$forward@ABH@std@@YAABHABH@Z
.text$mn:000090D0 ??$forward@ABH@std@@YAABHABH@Z proc near
.text$mn:000090D0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::construct<int,int const &>(int *,int const &)+Bp
.text$mn:000090D0                                         ; std::allocator_traits<std::allocator<int>>::construct<int,int const &>(std::allocator<int> &,int *,int const &)+7p
.text$mn:000090D0
.text$mn:000090D0 arg_0           = dword ptr  8
.text$mn:000090D0
.text$mn:000090D0                 push    ebp
.text$mn:000090D1                 mov     ebp, esp
.text$mn:000090D3                 mov     eax, [ebp+arg_0]
.text$mn:000090D6                 pop     ebp
.text$mn:000090D7                 retn
.text$mn:000090D7 ??$forward@ABH@std@@YAABHABH@Z endp
.text$mn:000090D7
.text$mn:000090D7 _text$mn        ends
.text$mn:000090D7
.text$mn:000090D8 ; ===========================================================================
.text$mn:000090D8
.text$mn:000090D8 ; Segment type: Pure code
.text$mn:000090D8 ; Segment permissions: Read/Execute
.text$mn:000090D8 _text$mn        segment para public 'CODE' use32
.text$mn:000090D8                 assume cs:_text$mn
.text$mn:000090D8                 ;org 90D8h
.text$mn:000090D8 ; COMDAT (pick any)
.text$mn:000090D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000090D8
.text$mn:000090D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000090D8
.text$mn:000090D8 ; Attributes: bp-based frame
.text$mn:000090D8
.text$mn:000090D8 ; struct sessionFileInfo const & __cdecl std::forward<struct sessionFileInfo const &>(struct sessionFileInfo const &)
.text$mn:000090D8                 public ??$forward@ABUsessionFileInfo@@@std@@YAABUsessionFileInfo@@ABU1@@Z
.text$mn:000090D8 ??$forward@ABUsessionFileInfo@@@std@@YAABUsessionFileInfo@@ABU1@@Z proc near
.text$mn:000090D8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo const &>(sessionFileInfo *,sessionFileInfo const &)+Bp
.text$mn:000090D8                                         ; std::allocator_traits<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo const &>(std::allocator<sessionFileInfo> &,sessionFileInfo *,sessionFileInfo const &)+7p
.text$mn:000090D8
.text$mn:000090D8 arg_0           = dword ptr  8
.text$mn:000090D8
.text$mn:000090D8                 push    ebp
.text$mn:000090D9                 mov     ebp, esp
.text$mn:000090DB                 mov     eax, [ebp+arg_0]
.text$mn:000090DE                 pop     ebp
.text$mn:000090DF                 retn
.text$mn:000090DF ??$forward@ABUsessionFileInfo@@@std@@YAABUsessionFileInfo@@ABU1@@Z endp
.text$mn:000090DF
.text$mn:000090DF _text$mn        ends
.text$mn:000090DF
.text$mn:000090E0 ; ===========================================================================
.text$mn:000090E0
.text$mn:000090E0 ; Segment type: Pure code
.text$mn:000090E0 ; Segment permissions: Read/Execute
.text$mn:000090E0 _text$mn        segment para public 'CODE' use32
.text$mn:000090E0                 assume cs:_text$mn
.text$mn:000090E0                 ;org 90E0h
.text$mn:000090E0 ; COMDAT (pick any)
.text$mn:000090E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000090E0
.text$mn:000090E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000090E0
.text$mn:000090E0 ; Attributes: bp-based frame
.text$mn:000090E0
.text$mn:000090E0 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:000090E0                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:000090E0 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:000090E0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp
.text$mn:000090E0                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap ...
.text$mn:000090E0
.text$mn:000090E0 arg_0           = dword ptr  8
.text$mn:000090E0
.text$mn:000090E0                 push    ebp
.text$mn:000090E1                 mov     ebp, esp
.text$mn:000090E3                 mov     eax, [ebp+arg_0]
.text$mn:000090E6                 pop     ebp
.text$mn:000090E7                 retn
.text$mn:000090E7 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:000090E7
.text$mn:000090E7 _text$mn        ends
.text$mn:000090E7
.text$mn:000090E8 ; ===========================================================================
.text$mn:000090E8
.text$mn:000090E8 ; Segment type: Pure code
.text$mn:000090E8 ; Segment permissions: Read/Execute
.text$mn:000090E8 _text$mn        segment para public 'CODE' use32
.text$mn:000090E8                 assume cs:_text$mn
.text$mn:000090E8                 ;org 90E8h
.text$mn:000090E8 ; COMDAT (pick any)
.text$mn:000090E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000090E8
.text$mn:000090E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000090E8
.text$mn:000090E8 ; Attributes: bp-based frame
.text$mn:000090E8
.text$mn:000090E8 ; struct sessionFileInfo && __cdecl std::forward<struct sessionFileInfo>(struct sessionFileInfo &)
.text$mn:000090E8                 public ??$forward@UsessionFileInfo@@@std@@YA$$QAUsessionFileInfo@@AAU1@@Z
.text$mn:000090E8 ??$forward@UsessionFileInfo@@@std@@YA$$QAUsessionFileInfo@@AAU1@@Z proc near
.text$mn:000090E8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo>(sessionFileInfo *,sessionFileInfo &&)+Bp
.text$mn:000090E8                                         ; std::allocator<sessionFileInfo>::construct<sessionFileInfo,sessionFileInfo>(sessionFileInfo *,sessionFileInfo &&)+4Dp ...
.text$mn:000090E8
.text$mn:000090E8 arg_0           = dword ptr  8
.text$mn:000090E8
.text$mn:000090E8                 push    ebp
.text$mn:000090E9                 mov     ebp, esp
.text$mn:000090EB                 mov     eax, [ebp+arg_0]
.text$mn:000090EE                 pop     ebp
.text$mn:000090EF                 retn
.text$mn:000090EF ??$forward@UsessionFileInfo@@@std@@YA$$QAUsessionFileInfo@@AAU1@@Z endp
.text$mn:000090EF
.text$mn:000090EF _text$mn        ends
.text$mn:000090EF
.text$mn:000090F0 ; ===========================================================================
.text$mn:000090F0
.text$mn:000090F0 ; Segment type: Pure code
.text$mn:000090F0 ; Segment permissions: Read/Execute
.text$mn:000090F0 _text$mn        segment para public 'CODE' use32
.text$mn:000090F0                 assume cs:_text$mn
.text$mn:000090F0                 ;org 90F0h
.text$mn:000090F0 ; COMDAT (pick any)
.text$mn:000090F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000090F0
.text$mn:000090F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000090F0
.text$mn:000090F0 ; Attributes: bp-based frame
.text$mn:000090F0
.text$mn:000090F0 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> && __cdecl std::forward<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &)
.text$mn:000090F0                 public ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
.text$mn:000090F0 ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z proc near
.text$mn:000090F0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+Bp
.text$mn:000090F0                                         ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+4Ap ...
.text$mn:000090F0
.text$mn:000090F0 arg_0           = dword ptr  8
.text$mn:000090F0
.text$mn:000090F0                 push    ebp
.text$mn:000090F1                 mov     ebp, esp
.text$mn:000090F3                 mov     eax, [ebp+arg_0]
.text$mn:000090F6                 pop     ebp
.text$mn:000090F7                 retn
.text$mn:000090F7 ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z endp
.text$mn:000090F7
.text$mn:000090F7 _text$mn        ends
.text$mn:000090F7
.text$mn:000090F8 ; ===========================================================================
.text$mn:000090F8
.text$mn:000090F8 ; Segment type: Pure code
.text$mn:000090F8 ; Segment permissions: Read/Execute
.text$mn:000090F8 _text$mn        segment para public 'CODE' use32
.text$mn:000090F8                 assume cs:_text$mn
.text$mn:000090F8                 ;org 90F8h
.text$mn:000090F8 ; COMDAT (pick any)
.text$mn:000090F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000090F8
.text$mn:000090F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000090F8
.text$mn:000090F8 ; Attributes: bp-based frame
.text$mn:000090F8
.text$mn:000090F8 ; struct sessionFileInfo && __cdecl std::move<struct sessionFileInfo &>(struct sessionFileInfo &)
.text$mn:000090F8                 public ??$move@AAUsessionFileInfo@@@std@@YA$$QAUsessionFileInfo@@AAU1@@Z
.text$mn:000090F8 ??$move@AAUsessionFileInfo@@@std@@YA$$QAUsessionFileInfo@@AAU1@@Z proc near
.text$mn:000090F8                                         ; CODE XREF: std::_Move<sessionFileInfo *,sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Nonscalar_ptr_iterator_tag)+28p
.text$mn:000090F8
.text$mn:000090F8 arg_0           = dword ptr  8
.text$mn:000090F8
.text$mn:000090F8                 push    ebp
.text$mn:000090F9                 mov     ebp, esp
.text$mn:000090FB                 mov     eax, [ebp+arg_0]
.text$mn:000090FE                 pop     ebp
.text$mn:000090FF                 retn
.text$mn:000090FF ??$move@AAUsessionFileInfo@@@std@@YA$$QAUsessionFileInfo@@AAU1@@Z endp
.text$mn:000090FF
.text$mn:000090FF _text$mn        ends
.text$mn:000090FF
.text$mn:00009100 ; ===========================================================================
.text$mn:00009100
.text$mn:00009100 ; Segment type: Pure code
.text$mn:00009100 ; Segment permissions: Read/Execute
.text$mn:00009100 _text$mn        segment para public 'CODE' use32
.text$mn:00009100                 assume cs:_text$mn
.text$mn:00009100                 ;org 9100h
.text$mn:00009100 ; COMDAT (pick any)
.text$mn:00009100                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009100
.text$mn:00009100 ; =============== S U B R O U T I N E =======================================
.text$mn:00009100
.text$mn:00009100 ; Attributes: bp-based frame
.text$mn:00009100
.text$mn:00009100 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>(void)
.text$mn:00009100                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00009100 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00009100                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+29p
.text$mn:00009100
.text$mn:00009100 var_10          = dword ptr -10h
.text$mn:00009100 var_C           = dword ptr -0Ch
.text$mn:00009100 var_4           = dword ptr -4
.text$mn:00009100
.text$mn:00009100                 push    ebp
.text$mn:00009101                 mov     ebp, esp
.text$mn:00009103                 push    0FFFFFFFFh
.text$mn:00009105                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000910A                 mov     eax, large fs:0
.text$mn:00009110                 push    eax
.text$mn:00009111                 push    ecx
.text$mn:00009112                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009117                 xor     eax, ebp
.text$mn:00009119                 push    eax
.text$mn:0000911A                 lea     eax, [ebp+var_C]
.text$mn:0000911D                 mov     large fs:0, eax
.text$mn:00009123                 mov     [ebp+var_10], ecx
.text$mn:00009126                 mov     ecx, [ebp+var_10] ; this
.text$mn:00009129                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:0000912E                 mov     [ebp+var_4], 0
.text$mn:00009135                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000913C                 mov     eax, [ebp+var_10]
.text$mn:0000913F                 mov     ecx, [ebp+var_C]
.text$mn:00009142                 mov     large fs:0, ecx
.text$mn:00009149                 pop     ecx
.text$mn:0000914A                 mov     esp, ebp
.text$mn:0000914C                 pop     ebp
.text$mn:0000914D                 retn
.text$mn:0000914D ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:0000914D
.text$mn:0000914D ; ---------------------------------------------------------------------------
.text$mn:0000914E                 align 10h
.text$mn:0000914E _text$mn        ends
.text$mn:0000914E
.text$x:00009150 ; ===========================================================================
.text$x:00009150
.text$x:00009150 ; Segment type: Pure code
.text$x:00009150 ; Segment permissions: Read/Execute
.text$x:00009150 _text$x         segment para public 'CODE' use32
.text$x:00009150                 assume cs:_text$x
.text$x:00009150                 ;org 9150h
.text$x:00009150 ; COMDAT (pick associative to section at 9100)
.text$x:00009150                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009150
.text$x:00009150 ; =============== S U B R O U T I N E =======================================
.text$x:00009150
.text$x:00009150
.text$x:00009150 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00009150                                         ; DATA XREF: .xdata$x:00013B30o
.text$x:00009150                 mov     ecx, [ebp-10h]  ; this
.text$x:00009153                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00009153 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00009153
.text$x:00009158
.text$x:00009158 ; =============== S U B R O U T I N E =======================================
.text$x:00009158
.text$x:00009158
.text$x:00009158 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00009158                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)+5o
.text$x:00009158
.text$x:00009158 arg_4           = dword ptr  8
.text$x:00009158
.text$x:00009158                 mov     edx, [esp+arg_4]
.text$x:0000915C                 lea     eax, [edx+0Ch]
.text$x:0000915F                 mov     ecx, [edx-8]
.text$x:00009162                 xor     ecx, eax
.text$x:00009164                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009169                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000916E                 jmp     ___CxxFrameHandler3
.text$x:0000916E __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000916E
.text$x:0000916E ; ---------------------------------------------------------------------------
.text$x:00009173                 align 4
.text$x:00009173 _text$x         ends
.text$x:00009173
.text$mn:00009174 ; ===========================================================================
.text$mn:00009174
.text$mn:00009174 ; Segment type: Pure code
.text$mn:00009174 ; Segment permissions: Read/Execute
.text$mn:00009174 _text$mn        segment para public 'CODE' use32
.text$mn:00009174                 assume cs:_text$mn
.text$mn:00009174                 ;org 9174h
.text$mn:00009174 ; COMDAT (pick any)
.text$mn:00009174                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009174
.text$mn:00009174 ; =============== S U B R O U T I N E =======================================
.text$mn:00009174
.text$mn:00009174 ; Attributes: bp-based frame
.text$mn:00009174
.text$mn:00009174 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00009174                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00009174 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00009174                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>> const &)+2Dp
.text$mn:00009174
.text$mn:00009174 var_10          = dword ptr -10h
.text$mn:00009174 var_C           = dword ptr -0Ch
.text$mn:00009174 var_4           = dword ptr -4
.text$mn:00009174 arg_0           = dword ptr  8
.text$mn:00009174
.text$mn:00009174                 push    ebp
.text$mn:00009175                 mov     ebp, esp
.text$mn:00009177                 push    0FFFFFFFFh
.text$mn:00009179                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:0000917E                 mov     eax, large fs:0
.text$mn:00009184                 push    eax
.text$mn:00009185                 push    ecx
.text$mn:00009186                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000918B                 xor     eax, ebp
.text$mn:0000918D                 push    eax
.text$mn:0000918E                 lea     eax, [ebp+var_C]
.text$mn:00009191                 mov     large fs:0, eax
.text$mn:00009197                 mov     [ebp+var_10], ecx
.text$mn:0000919A                 mov     eax, [ebp+arg_0]
.text$mn:0000919D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000919E                 mov     ecx, [ebp+var_10] ; this
.text$mn:000091A1                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:000091A6                 mov     [ebp+var_4], 0
.text$mn:000091AD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000091B4                 mov     eax, [ebp+var_10]
.text$mn:000091B7                 mov     ecx, [ebp+var_C]
.text$mn:000091BA                 mov     large fs:0, ecx
.text$mn:000091C1                 pop     ecx
.text$mn:000091C2                 mov     esp, ebp
.text$mn:000091C4                 pop     ebp
.text$mn:000091C5                 retn    4
.text$mn:000091C5 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:000091C5
.text$mn:000091C5 _text$mn        ends
.text$mn:000091C5
.text$x:000091C8 ; ===========================================================================
.text$x:000091C8
.text$x:000091C8 ; Segment type: Pure code
.text$x:000091C8 ; Segment permissions: Read/Execute
.text$x:000091C8 _text$x         segment para public 'CODE' use32
.text$x:000091C8                 assume cs:_text$x
.text$x:000091C8                 ;org 91C8h
.text$x:000091C8 ; COMDAT (pick associative to section at 9174)
.text$x:000091C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000091C8
.text$x:000091C8 ; =============== S U B R O U T I N E =======================================
.text$x:000091C8
.text$x:000091C8
.text$x:000091C8 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:000091C8                                         ; DATA XREF: .xdata$x:000141E0o
.text$x:000091C8                 mov     ecx, [ebp-10h]  ; this
.text$x:000091CB                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000091CB __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:000091CB
.text$x:000091D0
.text$x:000091D0 ; =============== S U B R O U T I N E =======================================
.text$x:000091D0
.text$x:000091D0
.text$x:000091D0 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:000091D0                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12> const &)+5o
.text$x:000091D0
.text$x:000091D0 arg_4           = dword ptr  8
.text$x:000091D0
.text$x:000091D0                 mov     edx, [esp+arg_4]
.text$x:000091D4                 lea     eax, [edx+0Ch]
.text$x:000091D7                 mov     ecx, [edx-8]
.text$x:000091DA                 xor     ecx, eax
.text$x:000091DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000091E1                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:000091E6                 jmp     ___CxxFrameHandler3
.text$x:000091E6 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:000091E6
.text$x:000091E6 ; ---------------------------------------------------------------------------
.text$x:000091EB                 align 4
.text$x:000091EB _text$x         ends
.text$x:000091EB
.text$mn:000091EC ; ===========================================================================
.text$mn:000091EC
.text$mn:000091EC ; Segment type: Pure code
.text$mn:000091EC ; Segment permissions: Read/Execute
.text$mn:000091EC _text$mn        segment para public 'CODE' use32
.text$mn:000091EC                 assume cs:_text$mn
.text$mn:000091EC                 ;org 91ECh
.text$mn:000091EC ; COMDAT (pick any)
.text$mn:000091EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000091EC
.text$mn:000091EC ; =============== S U B R O U T I N E =======================================
.text$mn:000091EC
.text$mn:000091EC ; Attributes: bp-based frame
.text$mn:000091EC
.text$mn:000091EC ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, unsigned int, int, unsigned int const *, unsigned int const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, unsigned int, int, unsigned int const *, unsigned int const &, struct std::_Iterator_base12>(void)
.text$mn:000091EC                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000091EC ??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:000091EC                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(uint *,std::_Container_base12 const *)+29p
.text$mn:000091EC
.text$mn:000091EC var_10          = dword ptr -10h
.text$mn:000091EC var_C           = dword ptr -0Ch
.text$mn:000091EC var_4           = dword ptr -4
.text$mn:000091EC
.text$mn:000091EC                 push    ebp
.text$mn:000091ED                 mov     ebp, esp
.text$mn:000091EF                 push    0FFFFFFFFh
.text$mn:000091F1                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000091F6                 mov     eax, large fs:0
.text$mn:000091FC                 push    eax
.text$mn:000091FD                 push    ecx
.text$mn:000091FE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009203                 xor     eax, ebp
.text$mn:00009205                 push    eax
.text$mn:00009206                 lea     eax, [ebp+var_C]
.text$mn:00009209                 mov     large fs:0, eax
.text$mn:0000920F                 mov     [ebp+var_10], ecx
.text$mn:00009212                 mov     ecx, [ebp+var_10] ; this
.text$mn:00009215                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:0000921A                 mov     [ebp+var_4], 0
.text$mn:00009221                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009228                 mov     eax, [ebp+var_10]
.text$mn:0000922B                 mov     ecx, [ebp+var_C]
.text$mn:0000922E                 mov     large fs:0, ecx
.text$mn:00009235                 pop     ecx
.text$mn:00009236                 mov     esp, ebp
.text$mn:00009238                 pop     ebp
.text$mn:00009239                 retn
.text$mn:00009239 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00009239
.text$mn:00009239 ; ---------------------------------------------------------------------------
.text$mn:0000923A                 align 4
.text$mn:0000923A _text$mn        ends
.text$mn:0000923A
.text$x:0000923C ; ===========================================================================
.text$x:0000923C
.text$x:0000923C ; Segment type: Pure code
.text$x:0000923C ; Segment permissions: Read/Execute
.text$x:0000923C _text$x         segment para public 'CODE' use32
.text$x:0000923C                 assume cs:_text$x
.text$x:0000923C                 ;org 923Ch
.text$x:0000923C ; COMDAT (pick associative to section at 91EC)
.text$x:0000923C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000923C
.text$x:0000923C ; =============== S U B R O U T I N E =======================================
.text$x:0000923C
.text$x:0000923C
.text$x:0000923C __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:0000923C                                         ; DATA XREF: .xdata$x:00014188o
.text$x:0000923C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000923F                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:0000923F __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:0000923F
.text$x:00009244
.text$x:00009244 ; =============== S U B R O U T I N E =======================================
.text$x:00009244
.text$x:00009244
.text$x:00009244 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00009244                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>(void)+5o
.text$x:00009244
.text$x:00009244 arg_4           = dword ptr  8
.text$x:00009244
.text$x:00009244                 mov     edx, [esp+arg_4]
.text$x:00009248                 lea     eax, [edx+0Ch]
.text$x:0000924B                 mov     ecx, [edx-8]
.text$x:0000924E                 xor     ecx, eax
.text$x:00009250                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009255                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000925A                 jmp     ___CxxFrameHandler3
.text$x:0000925A __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000925A
.text$x:0000925A ; ---------------------------------------------------------------------------
.text$x:0000925F                 align 10h
.text$x:0000925F _text$x         ends
.text$x:0000925F
.text$mn:00009260 ; ===========================================================================
.text$mn:00009260
.text$mn:00009260 ; Segment type: Pure code
.text$mn:00009260 ; Segment permissions: Read/Execute
.text$mn:00009260 _text$mn        segment para public 'CODE' use32
.text$mn:00009260                 assume cs:_text$mn
.text$mn:00009260                 ;org 9260h
.text$mn:00009260 ; COMDAT (pick any)
.text$mn:00009260                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009260
.text$mn:00009260 ; =============== S U B R O U T I N E =======================================
.text$mn:00009260
.text$mn:00009260 ; Attributes: bp-based frame
.text$mn:00009260
.text$mn:00009260 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00009260                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00009260 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00009260                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>> const &)+2Dp
.text$mn:00009260
.text$mn:00009260 var_10          = dword ptr -10h
.text$mn:00009260 var_C           = dword ptr -0Ch
.text$mn:00009260 var_4           = dword ptr -4
.text$mn:00009260 arg_0           = dword ptr  8
.text$mn:00009260
.text$mn:00009260                 push    ebp
.text$mn:00009261                 mov     ebp, esp
.text$mn:00009263                 push    0FFFFFFFFh
.text$mn:00009265                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:0000926A                 mov     eax, large fs:0
.text$mn:00009270                 push    eax
.text$mn:00009271                 push    ecx
.text$mn:00009272                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009277                 xor     eax, ebp
.text$mn:00009279                 push    eax
.text$mn:0000927A                 lea     eax, [ebp+var_C]
.text$mn:0000927D                 mov     large fs:0, eax
.text$mn:00009283                 mov     [ebp+var_10], ecx
.text$mn:00009286                 mov     eax, [ebp+arg_0]
.text$mn:00009289                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000928A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000928D                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:00009292                 mov     [ebp+var_4], 0
.text$mn:00009299                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000092A0                 mov     eax, [ebp+var_10]
.text$mn:000092A3                 mov     ecx, [ebp+var_C]
.text$mn:000092A6                 mov     large fs:0, ecx
.text$mn:000092AD                 pop     ecx
.text$mn:000092AE                 mov     esp, ebp
.text$mn:000092B0                 pop     ebp
.text$mn:000092B1                 retn    4
.text$mn:000092B1 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:000092B1
.text$mn:000092B1 _text$mn        ends
.text$mn:000092B1
.text$x:000092B4 ; ===========================================================================
.text$x:000092B4
.text$x:000092B4 ; Segment type: Pure code
.text$x:000092B4 ; Segment permissions: Read/Execute
.text$x:000092B4 _text$x         segment para public 'CODE' use32
.text$x:000092B4                 assume cs:_text$x
.text$x:000092B4                 ;org 92B4h
.text$x:000092B4 ; COMDAT (pick associative to section at 9260)
.text$x:000092B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000092B4
.text$x:000092B4 ; =============== S U B R O U T I N E =======================================
.text$x:000092B4
.text$x:000092B4
.text$x:000092B4 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:000092B4                                         ; DATA XREF: .xdata$x:00013C38o
.text$x:000092B4                 mov     ecx, [ebp-10h]  ; this
.text$x:000092B7                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000092B7 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:000092B7
.text$x:000092BC
.text$x:000092BC ; =============== S U B R O U T I N E =======================================
.text$x:000092BC
.text$x:000092BC
.text$x:000092BC __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:000092BC                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12> const &)+5o
.text$x:000092BC
.text$x:000092BC arg_4           = dword ptr  8
.text$x:000092BC
.text$x:000092BC                 mov     edx, [esp+arg_4]
.text$x:000092C0                 lea     eax, [edx+0Ch]
.text$x:000092C3                 mov     ecx, [edx-8]
.text$x:000092C6                 xor     ecx, eax
.text$x:000092C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000092CD                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:000092D2                 jmp     ___CxxFrameHandler3
.text$x:000092D2 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:000092D2
.text$x:000092D2 ; ---------------------------------------------------------------------------
.text$x:000092D7                 align 4
.text$x:000092D7 _text$x         ends
.text$x:000092D7
.text$mn:000092D8 ; ===========================================================================
.text$mn:000092D8
.text$mn:000092D8 ; Segment type: Pure code
.text$mn:000092D8 ; Segment permissions: Read/Execute
.text$mn:000092D8 _text$mn        segment para public 'CODE' use32
.text$mn:000092D8                 assume cs:_text$mn
.text$mn:000092D8                 ;org 92D8h
.text$mn:000092D8 ; COMDAT (pick any)
.text$mn:000092D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000092D8
.text$mn:000092D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000092D8
.text$mn:000092D8 ; Attributes: bp-based frame
.text$mn:000092D8
.text$mn:000092D8 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct sessionFileInfo, int, struct sessionFileInfo const *, struct sessionFileInfo const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, struct sessionFileInfo, int, struct sessionFileInfo const *, struct sessionFileInfo const &, struct std::_Iterator_base12>(void)
.text$mn:000092D8                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000092D8 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:000092D8                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(sessionFileInfo *,std::_Container_base12 const *)+29p
.text$mn:000092D8
.text$mn:000092D8 var_10          = dword ptr -10h
.text$mn:000092D8 var_C           = dword ptr -0Ch
.text$mn:000092D8 var_4           = dword ptr -4
.text$mn:000092D8
.text$mn:000092D8                 push    ebp
.text$mn:000092D9                 mov     ebp, esp
.text$mn:000092DB                 push    0FFFFFFFFh
.text$mn:000092DD                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000092E2                 mov     eax, large fs:0
.text$mn:000092E8                 push    eax
.text$mn:000092E9                 push    ecx
.text$mn:000092EA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000092EF                 xor     eax, ebp
.text$mn:000092F1                 push    eax
.text$mn:000092F2                 lea     eax, [ebp+var_C]
.text$mn:000092F5                 mov     large fs:0, eax
.text$mn:000092FB                 mov     [ebp+var_10], ecx
.text$mn:000092FE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00009301                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00009306                 mov     [ebp+var_4], 0
.text$mn:0000930D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009314                 mov     eax, [ebp+var_10]
.text$mn:00009317                 mov     ecx, [ebp+var_C]
.text$mn:0000931A                 mov     large fs:0, ecx
.text$mn:00009321                 pop     ecx
.text$mn:00009322                 mov     esp, ebp
.text$mn:00009324                 pop     ebp
.text$mn:00009325                 retn
.text$mn:00009325 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00009325
.text$mn:00009325 ; ---------------------------------------------------------------------------
.text$mn:00009326                 align 4
.text$mn:00009326 _text$mn        ends
.text$mn:00009326
.text$x:00009328 ; ===========================================================================
.text$x:00009328
.text$x:00009328 ; Segment type: Pure code
.text$x:00009328 ; Segment permissions: Read/Execute
.text$x:00009328 _text$x         segment para public 'CODE' use32
.text$x:00009328                 assume cs:_text$x
.text$x:00009328                 ;org 9328h
.text$x:00009328 ; COMDAT (pick associative to section at 92D8)
.text$x:00009328                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009328
.text$x:00009328 ; =============== S U B R O U T I N E =======================================
.text$x:00009328
.text$x:00009328
.text$x:00009328 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00009328                                         ; DATA XREF: .xdata$x:00013BE0o
.text$x:00009328                 mov     ecx, [ebp-10h]  ; this
.text$x:0000932B                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:0000932B __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:0000932B
.text$x:00009330
.text$x:00009330 ; =============== S U B R O U T I N E =======================================
.text$x:00009330
.text$x:00009330
.text$x:00009330 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00009330                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>(void)+5o
.text$x:00009330
.text$x:00009330 arg_4           = dword ptr  8
.text$x:00009330
.text$x:00009330                 mov     edx, [esp+arg_4]
.text$x:00009334                 lea     eax, [edx+0Ch]
.text$x:00009337                 mov     ecx, [edx-8]
.text$x:0000933A                 xor     ecx, eax
.text$x:0000933C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009341                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00009346                 jmp     ___CxxFrameHandler3
.text$x:00009346 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00009346
.text$x:00009346 ; ---------------------------------------------------------------------------
.text$x:0000934B                 align 4
.text$x:0000934B _text$x         ends
.text$x:0000934B
.text$mn:0000934C ; ===========================================================================
.text$mn:0000934C
.text$mn:0000934C ; Segment type: Pure code
.text$mn:0000934C ; Segment permissions: Read/Execute
.text$mn:0000934C _text$mn        segment para public 'CODE' use32
.text$mn:0000934C                 assume cs:_text$mn
.text$mn:0000934C                 ;org 934Ch
.text$mn:0000934C ; COMDAT (pick any)
.text$mn:0000934C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000934C
.text$mn:0000934C ; =============== S U B R O U T I N E =======================================
.text$mn:0000934C
.text$mn:0000934C ; Attributes: bp-based frame
.text$mn:0000934C
.text$mn:0000934C ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:0000934C                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:0000934C ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:0000934C                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+2Dp
.text$mn:0000934C
.text$mn:0000934C var_10          = dword ptr -10h
.text$mn:0000934C var_C           = dword ptr -0Ch
.text$mn:0000934C var_4           = dword ptr -4
.text$mn:0000934C arg_0           = dword ptr  8
.text$mn:0000934C
.text$mn:0000934C                 push    ebp
.text$mn:0000934D                 mov     ebp, esp
.text$mn:0000934F                 push    0FFFFFFFFh
.text$mn:00009351                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00009356                 mov     eax, large fs:0
.text$mn:0000935C                 push    eax
.text$mn:0000935D                 push    ecx
.text$mn:0000935E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009363                 xor     eax, ebp
.text$mn:00009365                 push    eax
.text$mn:00009366                 lea     eax, [ebp+var_C]
.text$mn:00009369                 mov     large fs:0, eax
.text$mn:0000936F                 mov     [ebp+var_10], ecx
.text$mn:00009372                 mov     eax, [ebp+arg_0]
.text$mn:00009375                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00009376                 mov     ecx, [ebp+var_10] ; this
.text$mn:00009379                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:0000937E                 mov     [ebp+var_4], 0
.text$mn:00009385                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000938C                 mov     eax, [ebp+var_10]
.text$mn:0000938F                 mov     ecx, [ebp+var_C]
.text$mn:00009392                 mov     large fs:0, ecx
.text$mn:00009399                 pop     ecx
.text$mn:0000939A                 mov     esp, ebp
.text$mn:0000939C                 pop     ebp
.text$mn:0000939D                 retn    4
.text$mn:0000939D ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:0000939D
.text$mn:0000939D _text$mn        ends
.text$mn:0000939D
.text$x:000093A0 ; ===========================================================================
.text$x:000093A0
.text$x:000093A0 ; Segment type: Pure code
.text$x:000093A0 ; Segment permissions: Read/Execute
.text$x:000093A0 _text$x         segment para public 'CODE' use32
.text$x:000093A0                 assume cs:_text$x
.text$x:000093A0                 ;org 93A0h
.text$x:000093A0 ; COMDAT (pick associative to section at 934C)
.text$x:000093A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000093A0
.text$x:000093A0 ; =============== S U B R O U T I N E =======================================
.text$x:000093A0
.text$x:000093A0
.text$x:000093A0 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:000093A0                                         ; DATA XREF: .xdata$x:00013A80o
.text$x:000093A0                 mov     ecx, [ebp-10h]  ; this
.text$x:000093A3                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000093A3 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:000093A3
.text$x:000093A8
.text$x:000093A8 ; =============== S U B R O U T I N E =======================================
.text$x:000093A8
.text$x:000093A8
.text$x:000093A8 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:000093A8                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12> const &)+5o
.text$x:000093A8
.text$x:000093A8 arg_4           = dword ptr  8
.text$x:000093A8
.text$x:000093A8                 mov     edx, [esp+arg_4]
.text$x:000093AC                 lea     eax, [edx+0Ch]
.text$x:000093AF                 mov     ecx, [edx-8]
.text$x:000093B2                 xor     ecx, eax
.text$x:000093B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000093B9                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:000093BE                 jmp     ___CxxFrameHandler3
.text$x:000093BE __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:000093BE
.text$x:000093BE ; ---------------------------------------------------------------------------
.text$x:000093C3                 align 4
.text$x:000093C3 _text$x         ends
.text$x:000093C3
.text$mn:000093C4 ; ===========================================================================
.text$mn:000093C4
.text$mn:000093C4 ; Segment type: Pure code
.text$mn:000093C4 ; Segment permissions: Read/Execute
.text$mn:000093C4 _text$mn        segment para public 'CODE' use32
.text$mn:000093C4                 assume cs:_text$mn
.text$mn:000093C4                 ;org 93C4h
.text$mn:000093C4 ; COMDAT (pick any)
.text$mn:000093C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000093C4
.text$mn:000093C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000093C4
.text$mn:000093C4 ; Attributes: bp-based frame
.text$mn:000093C4
.text$mn:000093C4 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>(void)
.text$mn:000093C4                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000093C4 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:000093C4                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)+29p
.text$mn:000093C4
.text$mn:000093C4 var_10          = dword ptr -10h
.text$mn:000093C4 var_C           = dword ptr -0Ch
.text$mn:000093C4 var_4           = dword ptr -4
.text$mn:000093C4
.text$mn:000093C4                 push    ebp
.text$mn:000093C5                 mov     ebp, esp
.text$mn:000093C7                 push    0FFFFFFFFh
.text$mn:000093C9                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000093CE                 mov     eax, large fs:0
.text$mn:000093D4                 push    eax
.text$mn:000093D5                 push    ecx
.text$mn:000093D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000093DB                 xor     eax, ebp
.text$mn:000093DD                 push    eax
.text$mn:000093DE                 lea     eax, [ebp+var_C]
.text$mn:000093E1                 mov     large fs:0, eax
.text$mn:000093E7                 mov     [ebp+var_10], ecx
.text$mn:000093EA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000093ED                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:000093F2                 mov     [ebp+var_4], 0
.text$mn:000093F9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009400                 mov     eax, [ebp+var_10]
.text$mn:00009403                 mov     ecx, [ebp+var_C]
.text$mn:00009406                 mov     large fs:0, ecx
.text$mn:0000940D                 pop     ecx
.text$mn:0000940E                 mov     esp, ebp
.text$mn:00009410                 pop     ebp
.text$mn:00009411                 retn
.text$mn:00009411 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00009411
.text$mn:00009411 ; ---------------------------------------------------------------------------
.text$mn:00009412                 align 4
.text$mn:00009412 _text$mn        ends
.text$mn:00009412
.text$x:00009414 ; ===========================================================================
.text$x:00009414
.text$x:00009414 ; Segment type: Pure code
.text$x:00009414 ; Segment permissions: Read/Execute
.text$x:00009414 _text$x         segment para public 'CODE' use32
.text$x:00009414                 assume cs:_text$x
.text$x:00009414                 ;org 9414h
.text$x:00009414 ; COMDAT (pick associative to section at 93C4)
.text$x:00009414                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009414
.text$x:00009414 ; =============== S U B R O U T I N E =======================================
.text$x:00009414
.text$x:00009414
.text$x:00009414 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00009414                                         ; DATA XREF: .xdata$x:00013A28o
.text$x:00009414                 mov     ecx, [ebp-10h]  ; this
.text$x:00009417                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00009417 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00009417
.text$x:0000941C
.text$x:0000941C ; =============== S U B R O U T I N E =======================================
.text$x:0000941C
.text$x:0000941C
.text$x:0000941C __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:0000941C                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)+5o
.text$x:0000941C
.text$x:0000941C arg_4           = dword ptr  8
.text$x:0000941C
.text$x:0000941C                 mov     edx, [esp+arg_4]
.text$x:00009420                 lea     eax, [edx+0Ch]
.text$x:00009423                 mov     ecx, [edx-8]
.text$x:00009426                 xor     ecx, eax
.text$x:00009428                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000942D                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$x:00009432                 jmp     ___CxxFrameHandler3
.text$x:00009432 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00009432
.text$x:00009432 ; ---------------------------------------------------------------------------
.text$x:00009437                 align 4
.text$x:00009437 _text$x         ends
.text$x:00009437
.text$mn:00009438 ; ===========================================================================
.text$mn:00009438
.text$mn:00009438 ; Segment type: Pure code
.text$mn:00009438 ; Segment permissions: Read/Execute
.text$mn:00009438 _text$mn        segment para public 'CODE' use32
.text$mn:00009438                 assume cs:_text$mn
.text$mn:00009438                 ;org 9438h
.text$mn:00009438 ; COMDAT (pick any)
.text$mn:00009438                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009438
.text$mn:00009438 ; =============== S U B R O U T I N E =======================================
.text$mn:00009438
.text$mn:00009438 ; Attributes: bp-based frame
.text$mn:00009438
.text$mn:00009438 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00009438                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00009438 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00009438                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00009438
.text$mn:00009438 var_10          = dword ptr -10h
.text$mn:00009438 var_C           = dword ptr -0Ch
.text$mn:00009438 var_4           = dword ptr -4
.text$mn:00009438
.text$mn:00009438                 push    ebp
.text$mn:00009439                 mov     ebp, esp
.text$mn:0000943B                 push    0FFFFFFFFh
.text$mn:0000943D                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00009442                 mov     eax, large fs:0
.text$mn:00009448                 push    eax
.text$mn:00009449                 push    ecx
.text$mn:0000944A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000944F                 xor     eax, ebp
.text$mn:00009451                 push    eax
.text$mn:00009452                 lea     eax, [ebp+var_C]
.text$mn:00009455                 mov     large fs:0, eax
.text$mn:0000945B                 mov     [ebp+var_10], ecx
.text$mn:0000945E                 mov     ecx, [ebp+var_10]
.text$mn:00009461                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00009466                 mov     [ebp+var_4], 0
.text$mn:0000946D                 mov     ecx, [ebp+var_10]
.text$mn:00009470                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00009475                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000947C                 mov     eax, [ebp+var_10]
.text$mn:0000947F                 mov     ecx, [ebp+var_C]
.text$mn:00009482                 mov     large fs:0, ecx
.text$mn:00009489                 pop     ecx
.text$mn:0000948A                 mov     esp, ebp
.text$mn:0000948C                 pop     ebp
.text$mn:0000948D                 retn    4
.text$mn:0000948D ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:0000948D
.text$mn:0000948D _text$mn        ends
.text$mn:0000948D
.text$x:00009490 ; ===========================================================================
.text$x:00009490
.text$x:00009490 ; Segment type: Pure code
.text$x:00009490 ; Segment permissions: Read/Execute
.text$x:00009490 _text$x         segment para public 'CODE' use32
.text$x:00009490                 assume cs:_text$x
.text$x:00009490                 ;org 9490h
.text$x:00009490 ; COMDAT (pick associative to section at 9438)
.text$x:00009490                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009490
.text$x:00009490 ; =============== S U B R O U T I N E =======================================
.text$x:00009490
.text$x:00009490
.text$x:00009490 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00009490                                         ; DATA XREF: .xdata$x:00012480o
.text$x:00009490                 mov     ecx, [ebp-10h]
.text$x:00009493                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00009493 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00009493
.text$x:00009498
.text$x:00009498 ; =============== S U B R O U T I N E =======================================
.text$x:00009498
.text$x:00009498
.text$x:00009498 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00009498                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00009498
.text$x:00009498 arg_4           = dword ptr  8
.text$x:00009498
.text$x:00009498                 mov     edx, [esp+arg_4]
.text$x:0000949C                 lea     eax, [edx+0Ch]
.text$x:0000949F                 mov     ecx, [edx-8]
.text$x:000094A2                 xor     ecx, eax
.text$x:000094A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000094A9                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000094AE                 jmp     ___CxxFrameHandler3
.text$x:000094AE __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000094AE
.text$x:000094AE ; ---------------------------------------------------------------------------
.text$x:000094B3                 align 4
.text$x:000094B3 _text$x         ends
.text$x:000094B3
.text$mn:000094B4 ; ===========================================================================
.text$mn:000094B4
.text$mn:000094B4 ; Segment type: Pure code
.text$mn:000094B4 ; Segment permissions: Read/Execute
.text$mn:000094B4 _text$mn        segment para public 'CODE' use32
.text$mn:000094B4                 assume cs:_text$mn
.text$mn:000094B4                 ;org 94B4h
.text$mn:000094B4 ; COMDAT (pick any)
.text$mn:000094B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000094B4
.text$mn:000094B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000094B4
.text$mn:000094B4 ; Attributes: bp-based frame
.text$mn:000094B4
.text$mn:000094B4 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:000094B4                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:000094B4 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:000094B4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+38p
.text$mn:000094B4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+43p ...
.text$mn:000094B4
.text$mn:000094B4 var_10          = dword ptr -10h
.text$mn:000094B4 var_C           = dword ptr -0Ch
.text$mn:000094B4 var_4           = dword ptr -4
.text$mn:000094B4
.text$mn:000094B4                 push    ebp
.text$mn:000094B5                 mov     ebp, esp
.text$mn:000094B7                 push    0FFFFFFFFh
.text$mn:000094B9                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:000094BE                 mov     eax, large fs:0
.text$mn:000094C4                 push    eax
.text$mn:000094C5                 push    ecx
.text$mn:000094C6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000094CB                 xor     eax, ebp
.text$mn:000094CD                 push    eax
.text$mn:000094CE                 lea     eax, [ebp+var_C]
.text$mn:000094D1                 mov     large fs:0, eax
.text$mn:000094D7                 mov     [ebp+var_10], ecx
.text$mn:000094DA                 mov     ecx, [ebp+var_10]
.text$mn:000094DD                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:000094E2                 mov     [ebp+var_4], 0
.text$mn:000094E9                 mov     ecx, [ebp+var_10]
.text$mn:000094EC                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:000094F1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000094F8                 mov     eax, [ebp+var_10]
.text$mn:000094FB                 mov     ecx, [ebp+var_C]
.text$mn:000094FE                 mov     large fs:0, ecx
.text$mn:00009505                 pop     ecx
.text$mn:00009506                 mov     esp, ebp
.text$mn:00009508                 pop     ebp
.text$mn:00009509                 retn    4
.text$mn:00009509 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00009509
.text$mn:00009509 _text$mn        ends
.text$mn:00009509
.text$x:0000950C ; ===========================================================================
.text$x:0000950C
.text$x:0000950C ; Segment type: Pure code
.text$x:0000950C ; Segment permissions: Read/Execute
.text$x:0000950C _text$x         segment para public 'CODE' use32
.text$x:0000950C                 assume cs:_text$x
.text$x:0000950C                 ;org 950Ch
.text$x:0000950C ; COMDAT (pick associative to section at 94B4)
.text$x:0000950C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000950C
.text$x:0000950C ; =============== S U B R O U T I N E =======================================
.text$x:0000950C
.text$x:0000950C
.text$x:0000950C __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:0000950C                                         ; DATA XREF: .xdata$x:000127A0o
.text$x:0000950C                 mov     ecx, [ebp-10h]
.text$x:0000950F                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:0000950F __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:0000950F
.text$x:00009514
.text$x:00009514 ; =============== S U B R O U T I N E =======================================
.text$x:00009514
.text$x:00009514
.text$x:00009514 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:00009514                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:00009514
.text$x:00009514 arg_4           = dword ptr  8
.text$x:00009514
.text$x:00009514                 mov     edx, [esp+arg_4]
.text$x:00009518                 lea     eax, [edx+0Ch]
.text$x:0000951B                 mov     ecx, [edx-8]
.text$x:0000951E                 xor     ecx, eax
.text$x:00009520                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009525                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:0000952A                 jmp     ___CxxFrameHandler3
.text$x:0000952A __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:0000952A
.text$x:0000952A ; ---------------------------------------------------------------------------
.text$x:0000952F                 align 10h
.text$x:0000952F _text$x         ends
.text$x:0000952F
.text$mn:00009530 ; ===========================================================================
.text$mn:00009530
.text$mn:00009530 ; Segment type: Pure code
.text$mn:00009530 ; Segment permissions: Read/Execute
.text$mn:00009530 _text$mn        segment para public 'CODE' use32
.text$mn:00009530                 assume cs:_text$mn
.text$mn:00009530                 ;org 9530h
.text$mn:00009530 ; COMDAT (pick any)
.text$mn:00009530                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009530
.text$mn:00009530 ; =============== S U B R O U T I N E =======================================
.text$mn:00009530
.text$mn:00009530 ; Attributes: bp-based frame
.text$mn:00009530
.text$mn:00009530 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(struct std::_Iterator_base12 *)
.text$mn:00009530                 public ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00009530 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00009530                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+90p
.text$mn:00009530                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+C7p ...
.text$mn:00009530
.text$mn:00009530 var_10          = dword ptr -10h
.text$mn:00009530 var_C           = dword ptr -0Ch
.text$mn:00009530 var_4           = dword ptr -4
.text$mn:00009530 arg_0           = dword ptr  8
.text$mn:00009530
.text$mn:00009530                 push    ebp
.text$mn:00009531                 mov     ebp, esp
.text$mn:00009533                 push    0FFFFFFFFh
.text$mn:00009535                 push    offset __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000953A                 mov     eax, large fs:0
.text$mn:00009540                 push    eax
.text$mn:00009541                 push    ecx
.text$mn:00009542                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009547                 xor     eax, ebp
.text$mn:00009549                 push    eax
.text$mn:0000954A                 lea     eax, [ebp+var_C]
.text$mn:0000954D                 mov     large fs:0, eax
.text$mn:00009553                 mov     [ebp+var_10], ecx
.text$mn:00009556                 mov     eax, [ebp+arg_0]
.text$mn:00009559                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000955A                 mov     ecx, [ebp+var_10]
.text$mn:0000955D                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12> const &)
.text$mn:00009562                 mov     [ebp+var_4], 0
.text$mn:00009569                 mov     ecx, [ebp+var_10]
.text$mn:0000956C                 mov     edx, [ebp+arg_0]
.text$mn:0000956F                 mov     eax, [edx+8]
.text$mn:00009572                 mov     [ecx+8], eax
.text$mn:00009575                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000957C                 mov     eax, [ebp+var_10]
.text$mn:0000957F                 mov     ecx, [ebp+var_C]
.text$mn:00009582                 mov     large fs:0, ecx
.text$mn:00009589                 pop     ecx
.text$mn:0000958A                 mov     esp, ebp
.text$mn:0000958C                 pop     ebp
.text$mn:0000958D                 retn    4
.text$mn:0000958D ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:0000958D
.text$mn:0000958D _text$mn        ends
.text$mn:0000958D
.text$x:00009590 ; ===========================================================================
.text$x:00009590
.text$x:00009590 ; Segment type: Pure code
.text$x:00009590 ; Segment permissions: Read/Execute
.text$x:00009590 _text$x         segment para public 'CODE' use32
.text$x:00009590                 assume cs:_text$x
.text$x:00009590                 ;org 9590h
.text$x:00009590 ; COMDAT (pick associative to section at 9530)
.text$x:00009590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009590
.text$x:00009590 ; =============== S U B R O U T I N E =======================================
.text$x:00009590
.text$x:00009590
.text$x:00009590 __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00009590                                         ; DATA XREF: .xdata$x:00013B04o
.text$x:00009590                 mov     ecx, [ebp-10h]
.text$x:00009593                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$x:00009593 __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00009593
.text$x:00009598
.text$x:00009598 ; =============== S U B R O U T I N E =======================================
.text$x:00009598
.text$x:00009598
.text$x:00009598 __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00009598                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+5o
.text$x:00009598
.text$x:00009598 arg_4           = dword ptr  8
.text$x:00009598
.text$x:00009598                 mov     edx, [esp+arg_4]
.text$x:0000959C                 lea     eax, [edx+0Ch]
.text$x:0000959F                 mov     ecx, [edx-8]
.text$x:000095A2                 xor     ecx, eax
.text$x:000095A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000095A9                 mov     eax, offset __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:000095AE                 jmp     ___CxxFrameHandler3
.text$x:000095AE __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:000095AE
.text$x:000095AE ; ---------------------------------------------------------------------------
.text$x:000095B3                 align 4
.text$x:000095B3 _text$x         ends
.text$x:000095B3
.text$mn:000095B4 ; ===========================================================================
.text$mn:000095B4
.text$mn:000095B4 ; Segment type: Pure code
.text$mn:000095B4 ; Segment permissions: Read/Execute
.text$mn:000095B4 _text$mn        segment para public 'CODE' use32
.text$mn:000095B4                 assume cs:_text$mn
.text$mn:000095B4                 ;org 95B4h
.text$mn:000095B4 ; COMDAT (pick any)
.text$mn:000095B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000095B4
.text$mn:000095B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000095B4
.text$mn:000095B4 ; Attributes: bp-based frame
.text$mn:000095B4
.text$mn:000095B4 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(int, struct std::_Container_base12 *)
.text$mn:000095B4                 public ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.text$mn:000095B4 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z proc near
.text$mn:000095B4                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)+31p
.text$mn:000095B4
.text$mn:000095B4 var_10          = dword ptr -10h
.text$mn:000095B4 var_C           = dword ptr -0Ch
.text$mn:000095B4 var_4           = dword ptr -4
.text$mn:000095B4 arg_0           = dword ptr  8
.text$mn:000095B4 arg_4           = dword ptr  0Ch
.text$mn:000095B4
.text$mn:000095B4                 push    ebp
.text$mn:000095B5                 mov     ebp, esp
.text$mn:000095B7                 push    0FFFFFFFFh
.text$mn:000095B9                 push    offset __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.text$mn:000095BE                 mov     eax, large fs:0
.text$mn:000095C4                 push    eax
.text$mn:000095C5                 push    ecx
.text$mn:000095C6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000095CB                 xor     eax, ebp
.text$mn:000095CD                 push    eax
.text$mn:000095CE                 lea     eax, [ebp+var_C]
.text$mn:000095D1                 mov     large fs:0, eax
.text$mn:000095D7                 mov     [ebp+var_10], ecx
.text$mn:000095DA                 mov     ecx, [ebp+var_10]
.text$mn:000095DD                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$mn:000095E2                 mov     [ebp+var_4], 0
.text$mn:000095E9                 mov     eax, [ebp+arg_4]
.text$mn:000095EC                 push    eax             ; struct std::_Container_base12 *
.text$mn:000095ED                 mov     ecx, [ebp+var_10] ; this
.text$mn:000095F0                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:000095F5                 mov     ecx, [ebp+var_10]
.text$mn:000095F8                 mov     edx, [ebp+arg_0]
.text$mn:000095FB                 mov     [ecx+8], edx
.text$mn:000095FE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009605                 mov     eax, [ebp+var_10]
.text$mn:00009608                 mov     ecx, [ebp+var_C]
.text$mn:0000960B                 mov     large fs:0, ecx
.text$mn:00009612                 pop     ecx
.text$mn:00009613                 mov     esp, ebp
.text$mn:00009615                 pop     ebp
.text$mn:00009616                 retn    8
.text$mn:00009616 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z endp
.text$mn:00009616
.text$mn:00009616 ; ---------------------------------------------------------------------------
.text$mn:00009619                 align 4
.text$mn:00009619 _text$mn        ends
.text$mn:00009619
.text$x:0000961C ; ===========================================================================
.text$x:0000961C
.text$x:0000961C ; Segment type: Pure code
.text$x:0000961C ; Segment permissions: Read/Execute
.text$x:0000961C _text$x         segment para public 'CODE' use32
.text$x:0000961C                 assume cs:_text$x
.text$x:0000961C                 ;org 961Ch
.text$x:0000961C ; COMDAT (pick associative to section at 95B4)
.text$x:0000961C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000961C
.text$x:0000961C ; =============== S U B R O U T I N E =======================================
.text$x:0000961C
.text$x:0000961C
.text$x:0000961C __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0 proc near
.text$x:0000961C                                         ; DATA XREF: .xdata$x:00013AACo
.text$x:0000961C                 mov     ecx, [ebp-10h]
.text$x:0000961F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$x:0000961F __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0 endp
.text$x:0000961F
.text$x:00009624
.text$x:00009624 ; =============== S U B R O U T I N E =======================================
.text$x:00009624
.text$x:00009624
.text$x:00009624 __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z proc near
.text$x:00009624                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)+5o
.text$x:00009624
.text$x:00009624 arg_4           = dword ptr  8
.text$x:00009624
.text$x:00009624                 mov     edx, [esp+arg_4]
.text$x:00009628                 lea     eax, [edx+0Ch]
.text$x:0000962B                 mov     ecx, [edx-8]
.text$x:0000962E                 xor     ecx, eax
.text$x:00009630                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009635                 mov     eax, offset __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.text$x:0000963A                 jmp     ___CxxFrameHandler3
.text$x:0000963A __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z endp
.text$x:0000963A
.text$x:0000963A ; ---------------------------------------------------------------------------
.text$x:0000963F                 align 10h
.text$x:0000963F _text$x         ends
.text$x:0000963F
.text$mn:00009640 ; ===========================================================================
.text$mn:00009640
.text$mn:00009640 ; Segment type: Pure code
.text$mn:00009640 ; Segment permissions: Read/Execute
.text$mn:00009640 _text$mn        segment para public 'CODE' use32
.text$mn:00009640                 assume cs:_text$mn
.text$mn:00009640                 ;org 9640h
.text$mn:00009640 ; COMDAT (pick any)
.text$mn:00009640                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009640
.text$mn:00009640 ; =============== S U B R O U T I N E =======================================
.text$mn:00009640
.text$mn:00009640 ; Attributes: bp-based frame
.text$mn:00009640
.text$mn:00009640 ; int __stdcall std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(struct std::_Iterator_base12 *)
.text$mn:00009640                 public ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00009640 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00009640                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+3Bp
.text$mn:00009640                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+59p
.text$mn:00009640
.text$mn:00009640 var_10          = dword ptr -10h
.text$mn:00009640 var_C           = dword ptr -0Ch
.text$mn:00009640 var_4           = dword ptr -4
.text$mn:00009640 arg_0           = dword ptr  8
.text$mn:00009640
.text$mn:00009640                 push    ebp
.text$mn:00009641                 mov     ebp, esp
.text$mn:00009643                 push    0FFFFFFFFh
.text$mn:00009645                 push    offset __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000964A                 mov     eax, large fs:0
.text$mn:00009650                 push    eax
.text$mn:00009651                 push    ecx
.text$mn:00009652                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009657                 xor     eax, ebp
.text$mn:00009659                 push    eax
.text$mn:0000965A                 lea     eax, [ebp+var_C]
.text$mn:0000965D                 mov     large fs:0, eax
.text$mn:00009663                 mov     [ebp+var_10], ecx
.text$mn:00009666                 mov     eax, [ebp+arg_0]
.text$mn:00009669                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000966A                 mov     ecx, [ebp+var_10]
.text$mn:0000966D                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00009672                 mov     [ebp+var_4], 0
.text$mn:00009679                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009680                 mov     eax, [ebp+var_10]
.text$mn:00009683                 mov     ecx, [ebp+var_C]
.text$mn:00009686                 mov     large fs:0, ecx
.text$mn:0000968D                 pop     ecx
.text$mn:0000968E                 mov     esp, ebp
.text$mn:00009690                 pop     ebp
.text$mn:00009691                 retn    4
.text$mn:00009691 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00009691
.text$mn:00009691 _text$mn        ends
.text$mn:00009691
.text$x:00009694 ; ===========================================================================
.text$x:00009694
.text$x:00009694 ; Segment type: Pure code
.text$x:00009694 ; Segment permissions: Read/Execute
.text$x:00009694 _text$x         segment para public 'CODE' use32
.text$x:00009694                 assume cs:_text$x
.text$x:00009694                 ;org 9694h
.text$x:00009694 ; COMDAT (pick associative to section at 9640)
.text$x:00009694                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009694
.text$x:00009694 ; =============== S U B R O U T I N E =======================================
.text$x:00009694
.text$x:00009694
.text$x:00009694 __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00009694                                         ; DATA XREF: .xdata$x:00013E24o
.text$x:00009694                 mov     ecx, [ebp-10h]
.text$x:00009697                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00009697 __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00009697
.text$x:0000969C
.text$x:0000969C ; =============== S U B R O U T I N E =======================================
.text$x:0000969C
.text$x:0000969C
.text$x:0000969C __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:0000969C                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+5o
.text$x:0000969C
.text$x:0000969C arg_4           = dword ptr  8
.text$x:0000969C
.text$x:0000969C                 mov     edx, [esp+arg_4]
.text$x:000096A0                 lea     eax, [edx+0Ch]
.text$x:000096A3                 mov     ecx, [edx-8]
.text$x:000096A6                 xor     ecx, eax
.text$x:000096A8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000096AD                 mov     eax, offset __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:000096B2                 jmp     ___CxxFrameHandler3
.text$x:000096B2 __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:000096B2
.text$x:000096B2 ; ---------------------------------------------------------------------------
.text$x:000096B7                 align 4
.text$x:000096B7 _text$x         ends
.text$x:000096B7
.text$mn:000096B8 ; ===========================================================================
.text$mn:000096B8
.text$mn:000096B8 ; Segment type: Pure code
.text$mn:000096B8 ; Segment permissions: Read/Execute
.text$mn:000096B8 _text$mn        segment para public 'CODE' use32
.text$mn:000096B8                 assume cs:_text$mn
.text$mn:000096B8                 ;org 96B8h
.text$mn:000096B8 ; COMDAT (pick any)
.text$mn:000096B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000096B8
.text$mn:000096B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000096B8
.text$mn:000096B8 ; Attributes: bp-based frame
.text$mn:000096B8
.text$mn:000096B8 ; int __stdcall std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(int, struct std::_Container_base12 *)
.text$mn:000096B8                 public ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$mn:000096B8 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z proc near
.text$mn:000096B8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)+3Fp
.text$mn:000096B8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)+48p
.text$mn:000096B8
.text$mn:000096B8 var_10          = dword ptr -10h
.text$mn:000096B8 var_C           = dword ptr -0Ch
.text$mn:000096B8 var_4           = dword ptr -4
.text$mn:000096B8 arg_0           = dword ptr  8
.text$mn:000096B8 arg_4           = dword ptr  0Ch
.text$mn:000096B8
.text$mn:000096B8                 push    ebp
.text$mn:000096B9                 mov     ebp, esp
.text$mn:000096BB                 push    0FFFFFFFFh
.text$mn:000096BD                 push    offset __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$mn:000096C2                 mov     eax, large fs:0
.text$mn:000096C8                 push    eax
.text$mn:000096C9                 push    ecx
.text$mn:000096CA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000096CF                 xor     eax, ebp
.text$mn:000096D1                 push    eax
.text$mn:000096D2                 lea     eax, [ebp+var_C]
.text$mn:000096D5                 mov     large fs:0, eax
.text$mn:000096DB                 mov     [ebp+var_10], ecx
.text$mn:000096DE                 mov     eax, [ebp+arg_4]
.text$mn:000096E1                 push    eax             ; struct std::_Container_base12 *
.text$mn:000096E2                 mov     ecx, [ebp+arg_0]
.text$mn:000096E5                 push    ecx             ; int
.text$mn:000096E6                 mov     ecx, [ebp+var_10]
.text$mn:000096E9                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)
.text$mn:000096EE                 mov     [ebp+var_4], 0
.text$mn:000096F5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000096FC                 mov     eax, [ebp+var_10]
.text$mn:000096FF                 mov     ecx, [ebp+var_C]
.text$mn:00009702                 mov     large fs:0, ecx
.text$mn:00009709                 pop     ecx
.text$mn:0000970A                 mov     esp, ebp
.text$mn:0000970C                 pop     ebp
.text$mn:0000970D                 retn    8
.text$mn:0000970D ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z endp
.text$mn:0000970D
.text$mn:0000970D _text$mn        ends
.text$mn:0000970D
.text$x:00009710 ; ===========================================================================
.text$x:00009710
.text$x:00009710 ; Segment type: Pure code
.text$x:00009710 ; Segment permissions: Read/Execute
.text$x:00009710 _text$x         segment para public 'CODE' use32
.text$x:00009710                 assume cs:_text$x
.text$x:00009710                 ;org 9710h
.text$x:00009710 ; COMDAT (pick associative to section at 96B8)
.text$x:00009710                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009710
.text$x:00009710 ; =============== S U B R O U T I N E =======================================
.text$x:00009710
.text$x:00009710
.text$x:00009710 __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0 proc near
.text$x:00009710                                         ; DATA XREF: .xdata$x:00013DA0o
.text$x:00009710                 mov     ecx, [ebp-10h]
.text$x:00009713                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00009713 __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0 endp
.text$x:00009713
.text$x:00009718
.text$x:00009718 ; =============== S U B R O U T I N E =======================================
.text$x:00009718
.text$x:00009718
.text$x:00009718 __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z proc near
.text$x:00009718                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)+5o
.text$x:00009718
.text$x:00009718 arg_4           = dword ptr  8
.text$x:00009718
.text$x:00009718                 mov     edx, [esp+arg_4]
.text$x:0000971C                 lea     eax, [edx+0Ch]
.text$x:0000971F                 mov     ecx, [edx-8]
.text$x:00009722                 xor     ecx, eax
.text$x:00009724                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009729                 mov     eax, offset __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$x:0000972E                 jmp     ___CxxFrameHandler3
.text$x:0000972E __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z endp
.text$x:0000972E
.text$x:0000972E ; ---------------------------------------------------------------------------
.text$x:00009733                 align 4
.text$x:00009733 _text$x         ends
.text$x:00009733
.text$mn:00009734 ; ===========================================================================
.text$mn:00009734
.text$mn:00009734 ; Segment type: Pure code
.text$mn:00009734 ; Segment permissions: Read/Execute
.text$mn:00009734 _text$mn        segment para public 'CODE' use32
.text$mn:00009734                 assume cs:_text$mn
.text$mn:00009734                 ;org 9734h
.text$mn:00009734 ; COMDAT (pick any)
.text$mn:00009734                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009734
.text$mn:00009734 ; =============== S U B R O U T I N E =======================================
.text$mn:00009734
.text$mn:00009734 ; Attributes: bp-based frame
.text$mn:00009734
.text$mn:00009734 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00009734                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00009734 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00009734                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00009734
.text$mn:00009734 var_10          = dword ptr -10h
.text$mn:00009734 var_C           = dword ptr -0Ch
.text$mn:00009734 var_4           = dword ptr -4
.text$mn:00009734
.text$mn:00009734                 push    ebp
.text$mn:00009735                 mov     ebp, esp
.text$mn:00009737                 push    0FFFFFFFFh
.text$mn:00009739                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000973E                 mov     eax, large fs:0
.text$mn:00009744                 push    eax
.text$mn:00009745                 push    ecx
.text$mn:00009746                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000974B                 xor     eax, ebp
.text$mn:0000974D                 push    eax
.text$mn:0000974E                 lea     eax, [ebp+var_C]
.text$mn:00009751                 mov     large fs:0, eax
.text$mn:00009757                 mov     [ebp+var_10], ecx
.text$mn:0000975A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000975D                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00009762                 mov     [ebp+var_4], 0
.text$mn:00009769                 mov     eax, [ebp+var_10]
.text$mn:0000976C                 mov     dword ptr [eax+14h], 0
.text$mn:00009773                 mov     ecx, [ebp+var_10]
.text$mn:00009776                 mov     dword ptr [ecx+18h], 0
.text$mn:0000977D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009784                 mov     eax, [ebp+var_10]
.text$mn:00009787                 mov     ecx, [ebp+var_C]
.text$mn:0000978A                 mov     large fs:0, ecx
.text$mn:00009791                 pop     ecx
.text$mn:00009792                 mov     esp, ebp
.text$mn:00009794                 pop     ebp
.text$mn:00009795                 retn
.text$mn:00009795 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00009795
.text$mn:00009795 ; ---------------------------------------------------------------------------
.text$mn:00009796                 align 4
.text$mn:00009796 _text$mn        ends
.text$mn:00009796
.text$x:00009798 ; ===========================================================================
.text$x:00009798
.text$x:00009798 ; Segment type: Pure code
.text$x:00009798 ; Segment permissions: Read/Execute
.text$x:00009798 _text$x         segment para public 'CODE' use32
.text$x:00009798                 assume cs:_text$x
.text$x:00009798                 ;org 9798h
.text$x:00009798 ; COMDAT (pick associative to section at 9734)
.text$x:00009798                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009798
.text$x:00009798 ; =============== S U B R O U T I N E =======================================
.text$x:00009798
.text$x:00009798
.text$x:00009798 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00009798                                         ; DATA XREF: .xdata$x:00012428o
.text$x:00009798                 mov     ecx, [ebp-10h]  ; this
.text$x:0000979B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000979B __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000979B
.text$x:000097A0
.text$x:000097A0 ; =============== S U B R O U T I N E =======================================
.text$x:000097A0
.text$x:000097A0
.text$x:000097A0 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000097A0                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000097A0
.text$x:000097A0 arg_4           = dword ptr  8
.text$x:000097A0
.text$x:000097A0                 mov     edx, [esp+arg_4]
.text$x:000097A4                 lea     eax, [edx+0Ch]
.text$x:000097A7                 mov     ecx, [edx-8]
.text$x:000097AA                 xor     ecx, eax
.text$x:000097AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000097B1                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000097B6                 jmp     ___CxxFrameHandler3
.text$x:000097B6 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000097B6
.text$x:000097B6 ; ---------------------------------------------------------------------------
.text$x:000097BB                 align 4
.text$x:000097BB _text$x         ends
.text$x:000097BB
.text$mn:000097BC ; ===========================================================================
.text$mn:000097BC
.text$mn:000097BC ; Segment type: Pure code
.text$mn:000097BC ; Segment permissions: Read/Execute
.text$mn:000097BC _text$mn        segment para public 'CODE' use32
.text$mn:000097BC                 assume cs:_text$mn
.text$mn:000097BC                 ;org 97BCh
.text$mn:000097BC ; COMDAT (pick any)
.text$mn:000097BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000097BC
.text$mn:000097BC ; =============== S U B R O U T I N E =======================================
.text$mn:000097BC
.text$mn:000097BC ; Attributes: bp-based frame
.text$mn:000097BC
.text$mn:000097BC ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:000097BC                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000097BC ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:000097BC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:000097BC
.text$mn:000097BC var_10          = dword ptr -10h
.text$mn:000097BC var_C           = dword ptr -0Ch
.text$mn:000097BC var_4           = dword ptr -4
.text$mn:000097BC
.text$mn:000097BC                 push    ebp
.text$mn:000097BD                 mov     ebp, esp
.text$mn:000097BF                 push    0FFFFFFFFh
.text$mn:000097C1                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000097C6                 mov     eax, large fs:0
.text$mn:000097CC                 push    eax
.text$mn:000097CD                 push    ecx
.text$mn:000097CE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000097D3                 xor     eax, ebp
.text$mn:000097D5                 push    eax
.text$mn:000097D6                 lea     eax, [ebp+var_C]
.text$mn:000097D9                 mov     large fs:0, eax
.text$mn:000097DF                 mov     [ebp+var_10], ecx
.text$mn:000097E2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000097E5                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000097EA                 mov     [ebp+var_4], 0
.text$mn:000097F1                 mov     eax, [ebp+var_10]
.text$mn:000097F4                 mov     dword ptr [eax+14h], 0
.text$mn:000097FB                 mov     ecx, [ebp+var_10]
.text$mn:000097FE                 mov     dword ptr [ecx+18h], 0
.text$mn:00009805                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000980C                 mov     eax, [ebp+var_10]
.text$mn:0000980F                 mov     ecx, [ebp+var_C]
.text$mn:00009812                 mov     large fs:0, ecx
.text$mn:00009819                 pop     ecx
.text$mn:0000981A                 mov     esp, ebp
.text$mn:0000981C                 pop     ebp
.text$mn:0000981D                 retn
.text$mn:0000981D ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:0000981D
.text$mn:0000981D ; ---------------------------------------------------------------------------
.text$mn:0000981E                 align 10h
.text$mn:0000981E _text$mn        ends
.text$mn:0000981E
.text$x:00009820 ; ===========================================================================
.text$x:00009820
.text$x:00009820 ; Segment type: Pure code
.text$x:00009820 ; Segment permissions: Read/Execute
.text$x:00009820 _text$x         segment para public 'CODE' use32
.text$x:00009820                 assume cs:_text$x
.text$x:00009820                 ;org 9820h
.text$x:00009820 ; COMDAT (pick associative to section at 97BC)
.text$x:00009820                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009820
.text$x:00009820 ; =============== S U B R O U T I N E =======================================
.text$x:00009820
.text$x:00009820
.text$x:00009820 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00009820                                         ; DATA XREF: .xdata$x:00012748o
.text$x:00009820                 mov     ecx, [ebp-10h]  ; this
.text$x:00009823                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00009823 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00009823
.text$x:00009828
.text$x:00009828 ; =============== S U B R O U T I N E =======================================
.text$x:00009828
.text$x:00009828
.text$x:00009828 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00009828                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00009828
.text$x:00009828 arg_4           = dword ptr  8
.text$x:00009828
.text$x:00009828                 mov     edx, [esp+arg_4]
.text$x:0000982C                 lea     eax, [edx+0Ch]
.text$x:0000982F                 mov     ecx, [edx-8]
.text$x:00009832                 xor     ecx, eax
.text$x:00009834                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009839                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:0000983E                 jmp     ___CxxFrameHandler3
.text$x:0000983E __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:0000983E
.text$x:0000983E ; ---------------------------------------------------------------------------
.text$x:00009843                 align 4
.text$x:00009843 _text$x         ends
.text$x:00009843
.text$mn:00009844 ; ===========================================================================
.text$mn:00009844
.text$mn:00009844 ; Segment type: Pure code
.text$mn:00009844 ; Segment permissions: Read/Execute
.text$mn:00009844 _text$mn        segment para public 'CODE' use32
.text$mn:00009844                 assume cs:_text$mn
.text$mn:00009844                 ;org 9844h
.text$mn:00009844 ; COMDAT (pick any)
.text$mn:00009844                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009844
.text$mn:00009844 ; =============== S U B R O U T I N E =======================================
.text$mn:00009844
.text$mn:00009844 ; Attributes: bp-based frame
.text$mn:00009844
.text$mn:00009844 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>(class std::allocator<int> const &)
.text$mn:00009844                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.text$mn:00009844 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z proc near
.text$mn:00009844                                         ; CODE XREF: std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)+34p
.text$mn:00009844
.text$mn:00009844 var_10          = dword ptr -10h
.text$mn:00009844 var_C           = dword ptr -0Ch
.text$mn:00009844 var_4           = dword ptr -4
.text$mn:00009844
.text$mn:00009844                 push    ebp
.text$mn:00009845                 mov     ebp, esp
.text$mn:00009847                 push    0FFFFFFFFh
.text$mn:00009849                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.text$mn:0000984E                 mov     eax, large fs:0
.text$mn:00009854                 push    eax
.text$mn:00009855                 push    ecx
.text$mn:00009856                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000985B                 xor     eax, ebp
.text$mn:0000985D                 push    eax
.text$mn:0000985E                 lea     eax, [ebp+var_C]
.text$mn:00009861                 mov     large fs:0, eax
.text$mn:00009867                 mov     [ebp+var_10], ecx
.text$mn:0000986A                 mov     ecx, [ebp+var_10]
.text$mn:0000986D                 call    ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int>>::_Vector_val<std::_Simple_types<int>>(void)
.text$mn:00009872                 mov     [ebp+var_4], 0
.text$mn:00009879                 mov     ecx, [ebp+var_10]
.text$mn:0000987C                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Alloc_proxy(void)
.text$mn:00009881                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009888                 mov     eax, [ebp+var_10]
.text$mn:0000988B                 mov     ecx, [ebp+var_C]
.text$mn:0000988E                 mov     large fs:0, ecx
.text$mn:00009895                 pop     ecx
.text$mn:00009896                 mov     esp, ebp
.text$mn:00009898                 pop     ebp
.text$mn:00009899                 retn    4
.text$mn:00009899 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z endp
.text$mn:00009899
.text$mn:00009899 _text$mn        ends
.text$mn:00009899
.text$x:0000989C ; ===========================================================================
.text$x:0000989C
.text$x:0000989C ; Segment type: Pure code
.text$x:0000989C ; Segment permissions: Read/Execute
.text$x:0000989C _text$x         segment para public 'CODE' use32
.text$x:0000989C                 assume cs:_text$x
.text$x:0000989C                 ;org 989Ch
.text$x:0000989C ; COMDAT (pick associative to section at 9844)
.text$x:0000989C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000989C
.text$x:0000989C ; =============== S U B R O U T I N E =======================================
.text$x:0000989C
.text$x:0000989C
.text$x:0000989C __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z$0 proc near
.text$x:0000989C                                         ; DATA XREF: .xdata$x:00012B90o
.text$x:0000989C                 mov     ecx, [ebp-10h]
.text$x:0000989F                 jmp     ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int>>::~_Vector_val<std::_Simple_types<int>>(void)
.text$x:0000989F __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z$0 endp
.text$x:0000989F
.text$x:000098A4
.text$x:000098A4 ; =============== S U B R O U T I N E =======================================
.text$x:000098A4
.text$x:000098A4
.text$x:000098A4 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z proc near
.text$x:000098A4                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(std::allocator<int> const &)+5o
.text$x:000098A4
.text$x:000098A4 arg_4           = dword ptr  8
.text$x:000098A4
.text$x:000098A4                 mov     edx, [esp+arg_4]
.text$x:000098A8                 lea     eax, [edx+0Ch]
.text$x:000098AB                 mov     ecx, [edx-8]
.text$x:000098AE                 xor     ecx, eax
.text$x:000098B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000098B5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.text$x:000098BA                 jmp     ___CxxFrameHandler3
.text$x:000098BA __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z endp
.text$x:000098BA
.text$x:000098BA ; ---------------------------------------------------------------------------
.text$x:000098BF                 align 10h
.text$x:000098BF _text$x         ends
.text$x:000098BF
.text$mn:000098C0 ; ===========================================================================
.text$mn:000098C0
.text$mn:000098C0 ; Segment type: Pure code
.text$mn:000098C0 ; Segment permissions: Read/Execute
.text$mn:000098C0 _text$mn        segment para public 'CODE' use32
.text$mn:000098C0                 assume cs:_text$mn
.text$mn:000098C0                 ;org 98C0h
.text$mn:000098C0 ; COMDAT (pick any)
.text$mn:000098C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000098C0
.text$mn:000098C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000098C0
.text$mn:000098C0 ; Attributes: bp-based frame
.text$mn:000098C0
.text$mn:000098C0 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned int, class std::allocator<unsigned int>>>::_Vector_alloc<0, struct std::_Vec_base_types<unsigned int, class std::allocator<unsigned int>>>(class std::allocator<unsigned int> const &)
.text$mn:000098C0                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
.text$mn:000098C0 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z proc near
.text$mn:000098C0                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(std::vector<uint,std::allocator<uint>> const &)+4Ap
.text$mn:000098C0                                         ; std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(void)+34p
.text$mn:000098C0
.text$mn:000098C0 var_10          = dword ptr -10h
.text$mn:000098C0 var_C           = dword ptr -0Ch
.text$mn:000098C0 var_4           = dword ptr -4
.text$mn:000098C0
.text$mn:000098C0                 push    ebp
.text$mn:000098C1                 mov     ebp, esp
.text$mn:000098C3                 push    0FFFFFFFFh
.text$mn:000098C5                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
.text$mn:000098CA                 mov     eax, large fs:0
.text$mn:000098D0                 push    eax
.text$mn:000098D1                 push    ecx
.text$mn:000098D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000098D7                 xor     eax, ebp
.text$mn:000098D9                 push    eax
.text$mn:000098DA                 lea     eax, [ebp+var_C]
.text$mn:000098DD                 mov     large fs:0, eax
.text$mn:000098E3                 mov     [ebp+var_10], ecx
.text$mn:000098E6                 mov     ecx, [ebp+var_10]
.text$mn:000098E9                 call    ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<uint>>::_Vector_val<std::_Simple_types<uint>>(void)
.text$mn:000098EE                 mov     [ebp+var_4], 0
.text$mn:000098F5                 mov     ecx, [ebp+var_10]
.text$mn:000098F8                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Alloc_proxy(void)
.text$mn:000098FD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009904                 mov     eax, [ebp+var_10]
.text$mn:00009907                 mov     ecx, [ebp+var_C]
.text$mn:0000990A                 mov     large fs:0, ecx
.text$mn:00009911                 pop     ecx
.text$mn:00009912                 mov     esp, ebp
.text$mn:00009914                 pop     ebp
.text$mn:00009915                 retn    4
.text$mn:00009915 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z endp
.text$mn:00009915
.text$mn:00009915 _text$mn        ends
.text$mn:00009915
.text$x:00009918 ; ===========================================================================
.text$x:00009918
.text$x:00009918 ; Segment type: Pure code
.text$x:00009918 ; Segment permissions: Read/Execute
.text$x:00009918 _text$x         segment para public 'CODE' use32
.text$x:00009918                 assume cs:_text$x
.text$x:00009918                 ;org 9918h
.text$x:00009918 ; COMDAT (pick associative to section at 98C0)
.text$x:00009918                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009918
.text$x:00009918 ; =============== S U B R O U T I N E =======================================
.text$x:00009918
.text$x:00009918
.text$x:00009918 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z$0 proc near
.text$x:00009918                                         ; DATA XREF: .xdata$x:00012DC8o
.text$x:00009918                 mov     ecx, [ebp-10h]
.text$x:0000991B                 jmp     ??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<uint>>::~_Vector_val<std::_Simple_types<uint>>(void)
.text$x:0000991B __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z$0 endp
.text$x:0000991B
.text$x:00009920
.text$x:00009920 ; =============== S U B R O U T I N E =======================================
.text$x:00009920
.text$x:00009920
.text$x:00009920 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z proc near
.text$x:00009920                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(std::allocator<uint> const &)+5o
.text$x:00009920
.text$x:00009920 arg_4           = dword ptr  8
.text$x:00009920
.text$x:00009920                 mov     edx, [esp+arg_4]
.text$x:00009924                 lea     eax, [edx+0Ch]
.text$x:00009927                 mov     ecx, [edx-8]
.text$x:0000992A                 xor     ecx, eax
.text$x:0000992C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009931                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
.text$x:00009936                 jmp     ___CxxFrameHandler3
.text$x:00009936 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z endp
.text$x:00009936
.text$x:00009936 ; ---------------------------------------------------------------------------
.text$x:0000993B                 align 4
.text$x:0000993B _text$x         ends
.text$x:0000993B
.text$mn:0000993C ; ===========================================================================
.text$mn:0000993C
.text$mn:0000993C ; Segment type: Pure code
.text$mn:0000993C ; Segment permissions: Read/Execute
.text$mn:0000993C _text$mn        segment para public 'CODE' use32
.text$mn:0000993C                 assume cs:_text$mn
.text$mn:0000993C                 ;org 993Ch
.text$mn:0000993C ; COMDAT (pick any)
.text$mn:0000993C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000993C
.text$mn:0000993C ; =============== S U B R O U T I N E =======================================
.text$mn:0000993C
.text$mn:0000993C ; Attributes: bp-based frame
.text$mn:0000993C
.text$mn:0000993C ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>>::_Vector_alloc<0, struct std::_Vec_base_types<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>>(class std::allocator<struct sessionFileInfo> const &)
.text$mn:0000993C                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z
.text$mn:0000993C ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z proc near
.text$mn:0000993C                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(std::vector<sessionFileInfo,std::allocator<sessionFileInfo>> const &)+4Ap
.text$mn:0000993C                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(void)+34p
.text$mn:0000993C
.text$mn:0000993C var_10          = dword ptr -10h
.text$mn:0000993C var_C           = dword ptr -0Ch
.text$mn:0000993C var_4           = dword ptr -4
.text$mn:0000993C
.text$mn:0000993C                 push    ebp
.text$mn:0000993D                 mov     ebp, esp
.text$mn:0000993F                 push    0FFFFFFFFh
.text$mn:00009941                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z
.text$mn:00009946                 mov     eax, large fs:0
.text$mn:0000994C                 push    eax
.text$mn:0000994D                 push    ecx
.text$mn:0000994E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009953                 xor     eax, ebp
.text$mn:00009955                 push    eax
.text$mn:00009956                 lea     eax, [ebp+var_C]
.text$mn:00009959                 mov     large fs:0, eax
.text$mn:0000995F                 mov     [ebp+var_10], ecx
.text$mn:00009962                 mov     ecx, [ebp+var_10]
.text$mn:00009965                 call    ??0?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<sessionFileInfo>>::_Vector_val<std::_Simple_types<sessionFileInfo>>(void)
.text$mn:0000996A                 mov     [ebp+var_4], 0
.text$mn:00009971                 mov     ecx, [ebp+var_10]
.text$mn:00009974                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Alloc_proxy(void)
.text$mn:00009979                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009980                 mov     eax, [ebp+var_10]
.text$mn:00009983                 mov     ecx, [ebp+var_C]
.text$mn:00009986                 mov     large fs:0, ecx
.text$mn:0000998D                 pop     ecx
.text$mn:0000998E                 mov     esp, ebp
.text$mn:00009990                 pop     ebp
.text$mn:00009991                 retn    4
.text$mn:00009991 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z endp
.text$mn:00009991
.text$mn:00009991 _text$mn        ends
.text$mn:00009991
.text$x:00009994 ; ===========================================================================
.text$x:00009994
.text$x:00009994 ; Segment type: Pure code
.text$x:00009994 ; Segment permissions: Read/Execute
.text$x:00009994 _text$x         segment para public 'CODE' use32
.text$x:00009994                 assume cs:_text$x
.text$x:00009994                 ;org 9994h
.text$x:00009994 ; COMDAT (pick associative to section at 993C)
.text$x:00009994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009994
.text$x:00009994 ; =============== S U B R O U T I N E =======================================
.text$x:00009994
.text$x:00009994
.text$x:00009994 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z$0 proc near
.text$x:00009994                                         ; DATA XREF: .xdata$x:000130B4o
.text$x:00009994                 mov     ecx, [ebp-10h]
.text$x:00009997                 jmp     ??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<sessionFileInfo>>::~_Vector_val<std::_Simple_types<sessionFileInfo>>(void)
.text$x:00009997 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z$0 endp
.text$x:00009997
.text$x:0000999C
.text$x:0000999C ; =============== S U B R O U T I N E =======================================
.text$x:0000999C
.text$x:0000999C
.text$x:0000999C __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z proc near
.text$x:0000999C                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>(std::allocator<sessionFileInfo> const &)+5o
.text$x:0000999C
.text$x:0000999C arg_4           = dword ptr  8
.text$x:0000999C
.text$x:0000999C                 mov     edx, [esp+arg_4]
.text$x:000099A0                 lea     eax, [edx+0Ch]
.text$x:000099A3                 mov     ecx, [edx-8]
.text$x:000099A6                 xor     ecx, eax
.text$x:000099A8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000099AD                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z
.text$x:000099B2                 jmp     ___CxxFrameHandler3
.text$x:000099B2 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z endp
.text$x:000099B2
.text$x:000099B2 ; ---------------------------------------------------------------------------
.text$x:000099B7                 align 4
.text$x:000099B7 _text$x         ends
.text$x:000099B7
.text$mn:000099B8 ; ===========================================================================
.text$mn:000099B8
.text$mn:000099B8 ; Segment type: Pure code
.text$mn:000099B8 ; Segment permissions: Read/Execute
.text$mn:000099B8 _text$mn        segment para public 'CODE' use32
.text$mn:000099B8                 assume cs:_text$mn
.text$mn:000099B8                 ;org 99B8h
.text$mn:000099B8 ; COMDAT (pick any)
.text$mn:000099B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000099B8
.text$mn:000099B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000099B8
.text$mn:000099B8 ; Attributes: bp-based frame
.text$mn:000099B8
.text$mn:000099B8 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>> const &)
.text$mn:000099B8                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
.text$mn:000099B8 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z proc near
.text$mn:000099B8                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+34p
.text$mn:000099B8
.text$mn:000099B8 var_10          = dword ptr -10h
.text$mn:000099B8 var_C           = dword ptr -0Ch
.text$mn:000099B8 var_4           = dword ptr -4
.text$mn:000099B8
.text$mn:000099B8                 push    ebp
.text$mn:000099B9                 mov     ebp, esp
.text$mn:000099BB                 push    0FFFFFFFFh
.text$mn:000099BD                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
.text$mn:000099C2                 mov     eax, large fs:0
.text$mn:000099C8                 push    eax
.text$mn:000099C9                 push    ecx
.text$mn:000099CA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000099CF                 xor     eax, ebp
.text$mn:000099D1                 push    eax
.text$mn:000099D2                 lea     eax, [ebp+var_C]
.text$mn:000099D5                 mov     large fs:0, eax
.text$mn:000099DB                 mov     [ebp+var_10], ecx
.text$mn:000099DE                 mov     ecx, [ebp+var_10]
.text$mn:000099E1                 call    ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:000099E6                 mov     [ebp+var_4], 0
.text$mn:000099ED                 mov     ecx, [ebp+var_10]
.text$mn:000099F0                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Alloc_proxy(void)
.text$mn:000099F5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000099FC                 mov     eax, [ebp+var_10]
.text$mn:000099FF                 mov     ecx, [ebp+var_C]
.text$mn:00009A02                 mov     large fs:0, ecx
.text$mn:00009A09                 pop     ecx
.text$mn:00009A0A                 mov     esp, ebp
.text$mn:00009A0C                 pop     ebp
.text$mn:00009A0D                 retn    4
.text$mn:00009A0D ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z endp
.text$mn:00009A0D
.text$mn:00009A0D _text$mn        ends
.text$mn:00009A0D
.text$x:00009A10 ; ===========================================================================
.text$x:00009A10
.text$x:00009A10 ; Segment type: Pure code
.text$x:00009A10 ; Segment permissions: Read/Execute
.text$x:00009A10 _text$x         segment para public 'CODE' use32
.text$x:00009A10                 assume cs:_text$x
.text$x:00009A10                 ;org 9A10h
.text$x:00009A10 ; COMDAT (pick associative to section at 99B8)
.text$x:00009A10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009A10
.text$x:00009A10 ; =============== S U B R O U T I N E =======================================
.text$x:00009A10
.text$x:00009A10
.text$x:00009A10 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$0 proc near
.text$x:00009A10                                         ; DATA XREF: .xdata$x:00013440o
.text$x:00009A10                 mov     ecx, [ebp-10h]
.text$x:00009A13                 jmp     ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$x:00009A13 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$0 endp
.text$x:00009A13
.text$x:00009A18
.text$x:00009A18 ; =============== S U B R O U T I N E =======================================
.text$x:00009A18
.text$x:00009A18
.text$x:00009A18 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z proc near
.text$x:00009A18                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)+5o
.text$x:00009A18
.text$x:00009A18 arg_4           = dword ptr  8
.text$x:00009A18
.text$x:00009A18                 mov     edx, [esp+arg_4]
.text$x:00009A1C                 lea     eax, [edx+0Ch]
.text$x:00009A1F                 mov     ecx, [edx-8]
.text$x:00009A22                 xor     ecx, eax
.text$x:00009A24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009A29                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
.text$x:00009A2E                 jmp     ___CxxFrameHandler3
.text$x:00009A2E __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z endp
.text$x:00009A2E
.text$x:00009A2E ; ---------------------------------------------------------------------------
.text$x:00009A33                 align 4
.text$x:00009A33 _text$x         ends
.text$x:00009A33
.text$mn:00009A34 ; ===========================================================================
.text$mn:00009A34
.text$mn:00009A34 ; Segment type: Pure code
.text$mn:00009A34 ; Segment permissions: Read/Execute
.text$mn:00009A34 _text$mn        segment para public 'CODE' use32
.text$mn:00009A34                 assume cs:_text$mn
.text$mn:00009A34                 ;org 9A34h
.text$mn:00009A34 ; COMDAT (pick any)
.text$mn:00009A34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009A34
.text$mn:00009A34 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A34
.text$mn:00009A34 ; Attributes: bp-based frame
.text$mn:00009A34
.text$mn:00009A34 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int, struct std::_Container_base12 *)
.text$mn:00009A34                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$mn:00009A34 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z proc near
.text$mn:00009A34                                         ; CODE XREF: std::vector<int,std::allocator<int>>::begin(void)+3Dp
.text$mn:00009A34                                         ; std::vector<int,std::allocator<int>>::end(void)+3Dp
.text$mn:00009A34
.text$mn:00009A34 var_10          = dword ptr -10h
.text$mn:00009A34 var_C           = dword ptr -0Ch
.text$mn:00009A34 var_4           = dword ptr -4
.text$mn:00009A34 arg_0           = dword ptr  8
.text$mn:00009A34 arg_4           = dword ptr  0Ch
.text$mn:00009A34
.text$mn:00009A34                 push    ebp
.text$mn:00009A35                 mov     ebp, esp
.text$mn:00009A37                 push    0FFFFFFFFh
.text$mn:00009A39                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$mn:00009A3E                 mov     eax, large fs:0
.text$mn:00009A44                 push    eax
.text$mn:00009A45                 push    ecx
.text$mn:00009A46                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009A4B                 xor     eax, ebp
.text$mn:00009A4D                 push    eax
.text$mn:00009A4E                 lea     eax, [ebp+var_C]
.text$mn:00009A51                 mov     large fs:0, eax
.text$mn:00009A57                 mov     [ebp+var_10], ecx
.text$mn:00009A5A                 mov     ecx, [ebp+var_10]
.text$mn:00009A5D                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$mn:00009A62                 mov     [ebp+var_4], 0
.text$mn:00009A69                 mov     eax, [ebp+var_10]
.text$mn:00009A6C                 mov     ecx, [ebp+arg_0]
.text$mn:00009A6F                 mov     [eax+8], ecx
.text$mn:00009A72                 mov     edx, [ebp+arg_4]
.text$mn:00009A75                 push    edx             ; struct std::_Container_base12 *
.text$mn:00009A76                 mov     ecx, [ebp+var_10] ; this
.text$mn:00009A79                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00009A7E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009A85                 mov     eax, [ebp+var_10]
.text$mn:00009A88                 mov     ecx, [ebp+var_C]
.text$mn:00009A8B                 mov     large fs:0, ecx
.text$mn:00009A92                 pop     ecx
.text$mn:00009A93                 mov     esp, ebp
.text$mn:00009A95                 pop     ebp
.text$mn:00009A96                 retn    8
.text$mn:00009A96 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z endp
.text$mn:00009A96
.text$mn:00009A96 ; ---------------------------------------------------------------------------
.text$mn:00009A99                 align 4
.text$mn:00009A99 _text$mn        ends
.text$mn:00009A99
.text$x:00009A9C ; ===========================================================================
.text$x:00009A9C
.text$x:00009A9C ; Segment type: Pure code
.text$x:00009A9C ; Segment permissions: Read/Execute
.text$x:00009A9C _text$x         segment para public 'CODE' use32
.text$x:00009A9C                 assume cs:_text$x
.text$x:00009A9C                 ;org 9A9Ch
.text$x:00009A9C ; COMDAT (pick associative to section at 9A34)
.text$x:00009A9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009A9C
.text$x:00009A9C ; =============== S U B R O U T I N E =======================================
.text$x:00009A9C
.text$x:00009A9C
.text$x:00009A9C __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0 proc near
.text$x:00009A9C                                         ; DATA XREF: .xdata$x:00013B88o
.text$x:00009A9C                 mov     ecx, [ebp-10h]
.text$x:00009A9F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$x:00009A9F __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0 endp
.text$x:00009A9F
.text$x:00009AA4
.text$x:00009AA4 ; =============== S U B R O U T I N E =======================================
.text$x:00009AA4
.text$x:00009AA4
.text$x:00009AA4 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z proc near
.text$x:00009AA4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+5o
.text$x:00009AA4
.text$x:00009AA4 arg_4           = dword ptr  8
.text$x:00009AA4
.text$x:00009AA4                 mov     edx, [esp+arg_4]
.text$x:00009AA8                 lea     eax, [edx+0Ch]
.text$x:00009AAB                 mov     ecx, [edx-8]
.text$x:00009AAE                 xor     ecx, eax
.text$x:00009AB0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009AB5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$x:00009ABA                 jmp     ___CxxFrameHandler3
.text$x:00009ABA __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z endp
.text$x:00009ABA
.text$x:00009ABA ; ---------------------------------------------------------------------------
.text$x:00009ABF                 align 10h
.text$x:00009ABF _text$x         ends
.text$x:00009ABF
.text$mn:00009AC0 ; ===========================================================================
.text$mn:00009AC0
.text$mn:00009AC0 ; Segment type: Pure code
.text$mn:00009AC0 ; Segment permissions: Read/Execute
.text$mn:00009AC0 _text$mn        segment para public 'CODE' use32
.text$mn:00009AC0                 assume cs:_text$mn
.text$mn:00009AC0                 ;org 9AC0h
.text$mn:00009AC0 ; COMDAT (pick any)
.text$mn:00009AC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009AC0
.text$mn:00009AC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00009AC0
.text$mn:00009AC0 ; Attributes: bp-based frame
.text$mn:00009AC0
.text$mn:00009AC0 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int>>>(struct std::_Iterator_base12 *)
.text$mn:00009AC0                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00009AC0 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00009AC0                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *)+4Fp
.text$mn:00009AC0                                         ; std::vector<uint,std::allocator<uint>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *)+6Dp ...
.text$mn:00009AC0
.text$mn:00009AC0 var_10          = dword ptr -10h
.text$mn:00009AC0 var_C           = dword ptr -0Ch
.text$mn:00009AC0 var_4           = dword ptr -4
.text$mn:00009AC0 arg_0           = dword ptr  8
.text$mn:00009AC0
.text$mn:00009AC0                 push    ebp
.text$mn:00009AC1                 mov     ebp, esp
.text$mn:00009AC3                 push    0FFFFFFFFh
.text$mn:00009AC5                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00009ACA                 mov     eax, large fs:0
.text$mn:00009AD0                 push    eax
.text$mn:00009AD1                 push    ecx
.text$mn:00009AD2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009AD7                 xor     eax, ebp
.text$mn:00009AD9                 push    eax
.text$mn:00009ADA                 lea     eax, [ebp+var_C]
.text$mn:00009ADD                 mov     large fs:0, eax
.text$mn:00009AE3                 mov     [ebp+var_10], ecx
.text$mn:00009AE6                 mov     eax, [ebp+arg_0]
.text$mn:00009AE9                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00009AEA                 mov     ecx, [ebp+var_10]
.text$mn:00009AED                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12> const &)
.text$mn:00009AF2                 mov     [ebp+var_4], 0
.text$mn:00009AF9                 mov     ecx, [ebp+var_10]
.text$mn:00009AFC                 mov     edx, [ebp+arg_0]
.text$mn:00009AFF                 mov     eax, [edx+8]
.text$mn:00009B02                 mov     [ecx+8], eax
.text$mn:00009B05                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009B0C                 mov     eax, [ebp+var_10]
.text$mn:00009B0F                 mov     ecx, [ebp+var_C]
.text$mn:00009B12                 mov     large fs:0, ecx
.text$mn:00009B19                 pop     ecx
.text$mn:00009B1A                 mov     esp, ebp
.text$mn:00009B1C                 pop     ebp
.text$mn:00009B1D                 retn    4
.text$mn:00009B1D ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00009B1D
.text$mn:00009B1D _text$mn        ends
.text$mn:00009B1D
.text$x:00009B20 ; ===========================================================================
.text$x:00009B20
.text$x:00009B20 ; Segment type: Pure code
.text$x:00009B20 ; Segment permissions: Read/Execute
.text$x:00009B20 _text$x         segment para public 'CODE' use32
.text$x:00009B20                 assume cs:_text$x
.text$x:00009B20                 ;org 9B20h
.text$x:00009B20 ; COMDAT (pick associative to section at 9AC0)
.text$x:00009B20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009B20
.text$x:00009B20 ; =============== S U B R O U T I N E =======================================
.text$x:00009B20
.text$x:00009B20
.text$x:00009B20 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00009B20                                         ; DATA XREF: .xdata$x:00014264o
.text$x:00009B20                 mov     ecx, [ebp-10h]
.text$x:00009B23                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>(void)
.text$x:00009B23 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00009B23
.text$x:00009B28
.text$x:00009B28 ; =============== S U B R O U T I N E =======================================
.text$x:00009B28
.text$x:00009B28
.text$x:00009B28 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00009B28                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>> const &)+5o
.text$x:00009B28
.text$x:00009B28 arg_4           = dword ptr  8
.text$x:00009B28
.text$x:00009B28                 mov     edx, [esp+arg_4]
.text$x:00009B2C                 lea     eax, [edx+0Ch]
.text$x:00009B2F                 mov     ecx, [edx-8]
.text$x:00009B32                 xor     ecx, eax
.text$x:00009B34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009B39                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00009B3E                 jmp     ___CxxFrameHandler3
.text$x:00009B3E __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00009B3E
.text$x:00009B3E ; ---------------------------------------------------------------------------
.text$x:00009B43                 align 4
.text$x:00009B43 _text$x         ends
.text$x:00009B43
.text$mn:00009B44 ; ===========================================================================
.text$mn:00009B44
.text$mn:00009B44 ; Segment type: Pure code
.text$mn:00009B44 ; Segment permissions: Read/Execute
.text$mn:00009B44 _text$mn        segment para public 'CODE' use32
.text$mn:00009B44                 assume cs:_text$mn
.text$mn:00009B44                 ;org 9B44h
.text$mn:00009B44 ; COMDAT (pick any)
.text$mn:00009B44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009B44
.text$mn:00009B44 ; =============== S U B R O U T I N E =======================================
.text$mn:00009B44
.text$mn:00009B44 ; Attributes: bp-based frame
.text$mn:00009B44
.text$mn:00009B44 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int>>>(int, struct std::_Container_base12 *)
.text$mn:00009B44                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z
.text$mn:00009B44 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z proc near
.text$mn:00009B44                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::begin(void)+3Dp
.text$mn:00009B44                                         ; std::vector<uint,std::allocator<uint>>::end(void)+3Dp
.text$mn:00009B44
.text$mn:00009B44 var_10          = dword ptr -10h
.text$mn:00009B44 var_C           = dword ptr -0Ch
.text$mn:00009B44 var_4           = dword ptr -4
.text$mn:00009B44 arg_0           = dword ptr  8
.text$mn:00009B44 arg_4           = dword ptr  0Ch
.text$mn:00009B44
.text$mn:00009B44                 push    ebp
.text$mn:00009B45                 mov     ebp, esp
.text$mn:00009B47                 push    0FFFFFFFFh
.text$mn:00009B49                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z
.text$mn:00009B4E                 mov     eax, large fs:0
.text$mn:00009B54                 push    eax
.text$mn:00009B55                 push    ecx
.text$mn:00009B56                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009B5B                 xor     eax, ebp
.text$mn:00009B5D                 push    eax
.text$mn:00009B5E                 lea     eax, [ebp+var_C]
.text$mn:00009B61                 mov     large fs:0, eax
.text$mn:00009B67                 mov     [ebp+var_10], ecx
.text$mn:00009B6A                 mov     ecx, [ebp+var_10]
.text$mn:00009B6D                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>(void)
.text$mn:00009B72                 mov     [ebp+var_4], 0
.text$mn:00009B79                 mov     eax, [ebp+var_10]
.text$mn:00009B7C                 mov     ecx, [ebp+arg_0]
.text$mn:00009B7F                 mov     [eax+8], ecx
.text$mn:00009B82                 mov     edx, [ebp+arg_4]
.text$mn:00009B85                 push    edx             ; struct std::_Container_base12 *
.text$mn:00009B86                 mov     ecx, [ebp+var_10] ; this
.text$mn:00009B89                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00009B8E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009B95                 mov     eax, [ebp+var_10]
.text$mn:00009B98                 mov     ecx, [ebp+var_C]
.text$mn:00009B9B                 mov     large fs:0, ecx
.text$mn:00009BA2                 pop     ecx
.text$mn:00009BA3                 mov     esp, ebp
.text$mn:00009BA5                 pop     ebp
.text$mn:00009BA6                 retn    8
.text$mn:00009BA6 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z endp
.text$mn:00009BA6
.text$mn:00009BA6 ; ---------------------------------------------------------------------------
.text$mn:00009BA9                 align 4
.text$mn:00009BA9 _text$mn        ends
.text$mn:00009BA9
.text$x:00009BAC ; ===========================================================================
.text$x:00009BAC
.text$x:00009BAC ; Segment type: Pure code
.text$x:00009BAC ; Segment permissions: Read/Execute
.text$x:00009BAC _text$x         segment para public 'CODE' use32
.text$x:00009BAC                 assume cs:_text$x
.text$x:00009BAC                 ;org 9BACh
.text$x:00009BAC ; COMDAT (pick associative to section at 9B44)
.text$x:00009BAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009BAC
.text$x:00009BAC ; =============== S U B R O U T I N E =======================================
.text$x:00009BAC
.text$x:00009BAC
.text$x:00009BAC __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z$0 proc near
.text$x:00009BAC                                         ; DATA XREF: .xdata$x:0001420Co
.text$x:00009BAC                 mov     ecx, [ebp-10h]
.text$x:00009BAF                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>(void)
.text$x:00009BAF __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z$0 endp
.text$x:00009BAF
.text$x:00009BB4
.text$x:00009BB4 ; =============== S U B R O U T I N E =======================================
.text$x:00009BB4
.text$x:00009BB4
.text$x:00009BB4 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z proc near
.text$x:00009BB4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(uint *,std::_Container_base12 const *)+5o
.text$x:00009BB4
.text$x:00009BB4 arg_4           = dword ptr  8
.text$x:00009BB4
.text$x:00009BB4                 mov     edx, [esp+arg_4]
.text$x:00009BB8                 lea     eax, [edx+0Ch]
.text$x:00009BBB                 mov     ecx, [edx-8]
.text$x:00009BBE                 xor     ecx, eax
.text$x:00009BC0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009BC5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z
.text$x:00009BCA                 jmp     ___CxxFrameHandler3
.text$x:00009BCA __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z endp
.text$x:00009BCA
.text$x:00009BCA ; ---------------------------------------------------------------------------
.text$x:00009BCF                 align 10h
.text$x:00009BCF _text$x         ends
.text$x:00009BCF
.text$mn:00009BD0 ; ===========================================================================
.text$mn:00009BD0
.text$mn:00009BD0 ; Segment type: Pure code
.text$mn:00009BD0 ; Segment permissions: Read/Execute
.text$mn:00009BD0 _text$mn        segment para public 'CODE' use32
.text$mn:00009BD0                 assume cs:_text$mn
.text$mn:00009BD0                 ;org 9BD0h
.text$mn:00009BD0 ; COMDAT (pick any)
.text$mn:00009BD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009BD0
.text$mn:00009BD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00009BD0
.text$mn:00009BD0 ; Attributes: bp-based frame
.text$mn:00009BD0
.text$mn:00009BD0 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(struct std::_Iterator_base12 *)
.text$mn:00009BD0                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00009BD0 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00009BD0                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+FAp
.text$mn:00009BD0                                         ; Notepad_plus::loadSession(Session &,bool)+5C5p ...
.text$mn:00009BD0
.text$mn:00009BD0 var_10          = dword ptr -10h
.text$mn:00009BD0 var_C           = dword ptr -0Ch
.text$mn:00009BD0 var_4           = dword ptr -4
.text$mn:00009BD0 arg_0           = dword ptr  8
.text$mn:00009BD0
.text$mn:00009BD0                 push    ebp
.text$mn:00009BD1                 mov     ebp, esp
.text$mn:00009BD3                 push    0FFFFFFFFh
.text$mn:00009BD5                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00009BDA                 mov     eax, large fs:0
.text$mn:00009BE0                 push    eax
.text$mn:00009BE1                 push    ecx
.text$mn:00009BE2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009BE7                 xor     eax, ebp
.text$mn:00009BE9                 push    eax
.text$mn:00009BEA                 lea     eax, [ebp+var_C]
.text$mn:00009BED                 mov     large fs:0, eax
.text$mn:00009BF3                 mov     [ebp+var_10], ecx
.text$mn:00009BF6                 mov     eax, [ebp+arg_0]
.text$mn:00009BF9                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00009BFA                 mov     ecx, [ebp+var_10]
.text$mn:00009BFD                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12> const &)
.text$mn:00009C02                 mov     [ebp+var_4], 0
.text$mn:00009C09                 mov     ecx, [ebp+var_10]
.text$mn:00009C0C                 mov     edx, [ebp+arg_0]
.text$mn:00009C0F                 mov     eax, [edx+8]
.text$mn:00009C12                 mov     [ecx+8], eax
.text$mn:00009C15                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009C1C                 mov     eax, [ebp+var_10]
.text$mn:00009C1F                 mov     ecx, [ebp+var_C]
.text$mn:00009C22                 mov     large fs:0, ecx
.text$mn:00009C29                 pop     ecx
.text$mn:00009C2A                 mov     esp, ebp
.text$mn:00009C2C                 pop     ebp
.text$mn:00009C2D                 retn    4
.text$mn:00009C2D ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00009C2D
.text$mn:00009C2D _text$mn        ends
.text$mn:00009C2D
.text$x:00009C30 ; ===========================================================================
.text$x:00009C30
.text$x:00009C30 ; Segment type: Pure code
.text$x:00009C30 ; Segment permissions: Read/Execute
.text$x:00009C30 _text$x         segment para public 'CODE' use32
.text$x:00009C30                 assume cs:_text$x
.text$x:00009C30                 ;org 9C30h
.text$x:00009C30 ; COMDAT (pick associative to section at 9BD0)
.text$x:00009C30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009C30
.text$x:00009C30 ; =============== S U B R O U T I N E =======================================
.text$x:00009C30
.text$x:00009C30
.text$x:00009C30 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00009C30                                         ; DATA XREF: .xdata$x:00013CBCo
.text$x:00009C30                 mov     ecx, [ebp-10h]
.text$x:00009C33                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>(void)
.text$x:00009C33 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00009C33
.text$x:00009C38
.text$x:00009C38 ; =============== S U B R O U T I N E =======================================
.text$x:00009C38
.text$x:00009C38
.text$x:00009C38 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00009C38                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>> const &)+5o
.text$x:00009C38
.text$x:00009C38 arg_4           = dword ptr  8
.text$x:00009C38
.text$x:00009C38                 mov     edx, [esp+arg_4]
.text$x:00009C3C                 lea     eax, [edx+0Ch]
.text$x:00009C3F                 mov     ecx, [edx-8]
.text$x:00009C42                 xor     ecx, eax
.text$x:00009C44                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009C49                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00009C4E                 jmp     ___CxxFrameHandler3
.text$x:00009C4E __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00009C4E
.text$x:00009C4E ; ---------------------------------------------------------------------------
.text$x:00009C53                 align 4
.text$x:00009C53 _text$x         ends
.text$x:00009C53
.text$mn:00009C54 ; ===========================================================================
.text$mn:00009C54
.text$mn:00009C54 ; Segment type: Pure code
.text$mn:00009C54 ; Segment permissions: Read/Execute
.text$mn:00009C54 _text$mn        segment para public 'CODE' use32
.text$mn:00009C54                 assume cs:_text$mn
.text$mn:00009C54                 ;org 9C54h
.text$mn:00009C54 ; COMDAT (pick any)
.text$mn:00009C54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009C54
.text$mn:00009C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00009C54
.text$mn:00009C54 ; Attributes: bp-based frame
.text$mn:00009C54
.text$mn:00009C54 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(int, struct std::_Container_base12 *)
.text$mn:00009C54                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z
.text$mn:00009C54 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z proc near
.text$mn:00009C54                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(sessionFileInfo *,std::_Container_base12 const *)+31p
.text$mn:00009C54                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::begin(void)+3Dp ...
.text$mn:00009C54
.text$mn:00009C54 var_10          = dword ptr -10h
.text$mn:00009C54 var_C           = dword ptr -0Ch
.text$mn:00009C54 var_4           = dword ptr -4
.text$mn:00009C54 arg_0           = dword ptr  8
.text$mn:00009C54 arg_4           = dword ptr  0Ch
.text$mn:00009C54
.text$mn:00009C54                 push    ebp
.text$mn:00009C55                 mov     ebp, esp
.text$mn:00009C57                 push    0FFFFFFFFh
.text$mn:00009C59                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z
.text$mn:00009C5E                 mov     eax, large fs:0
.text$mn:00009C64                 push    eax
.text$mn:00009C65                 push    ecx
.text$mn:00009C66                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009C6B                 xor     eax, ebp
.text$mn:00009C6D                 push    eax
.text$mn:00009C6E                 lea     eax, [ebp+var_C]
.text$mn:00009C71                 mov     large fs:0, eax
.text$mn:00009C77                 mov     [ebp+var_10], ecx
.text$mn:00009C7A                 mov     ecx, [ebp+var_10]
.text$mn:00009C7D                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>(void)
.text$mn:00009C82                 mov     [ebp+var_4], 0
.text$mn:00009C89                 mov     eax, [ebp+var_10]
.text$mn:00009C8C                 mov     ecx, [ebp+arg_0]
.text$mn:00009C8F                 mov     [eax+8], ecx
.text$mn:00009C92                 mov     edx, [ebp+arg_4]
.text$mn:00009C95                 push    edx             ; struct std::_Container_base12 *
.text$mn:00009C96                 mov     ecx, [ebp+var_10] ; this
.text$mn:00009C99                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00009C9E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009CA5                 mov     eax, [ebp+var_10]
.text$mn:00009CA8                 mov     ecx, [ebp+var_C]
.text$mn:00009CAB                 mov     large fs:0, ecx
.text$mn:00009CB2                 pop     ecx
.text$mn:00009CB3                 mov     esp, ebp
.text$mn:00009CB5                 pop     ebp
.text$mn:00009CB6                 retn    8
.text$mn:00009CB6 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z endp
.text$mn:00009CB6
.text$mn:00009CB6 ; ---------------------------------------------------------------------------
.text$mn:00009CB9                 align 4
.text$mn:00009CB9 _text$mn        ends
.text$mn:00009CB9
.text$x:00009CBC ; ===========================================================================
.text$x:00009CBC
.text$x:00009CBC ; Segment type: Pure code
.text$x:00009CBC ; Segment permissions: Read/Execute
.text$x:00009CBC _text$x         segment para public 'CODE' use32
.text$x:00009CBC                 assume cs:_text$x
.text$x:00009CBC                 ;org 9CBCh
.text$x:00009CBC ; COMDAT (pick associative to section at 9C54)
.text$x:00009CBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009CBC
.text$x:00009CBC ; =============== S U B R O U T I N E =======================================
.text$x:00009CBC
.text$x:00009CBC
.text$x:00009CBC __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z$0 proc near
.text$x:00009CBC                                         ; DATA XREF: .xdata$x:00013C64o
.text$x:00009CBC                 mov     ecx, [ebp-10h]
.text$x:00009CBF                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>(void)
.text$x:00009CBF __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z$0 endp
.text$x:00009CBF
.text$x:00009CC4
.text$x:00009CC4 ; =============== S U B R O U T I N E =======================================
.text$x:00009CC4
.text$x:00009CC4
.text$x:00009CC4 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z proc near
.text$x:00009CC4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(sessionFileInfo *,std::_Container_base12 const *)+5o
.text$x:00009CC4
.text$x:00009CC4 arg_4           = dword ptr  8
.text$x:00009CC4
.text$x:00009CC4                 mov     edx, [esp+arg_4]
.text$x:00009CC8                 lea     eax, [edx+0Ch]
.text$x:00009CCB                 mov     ecx, [edx-8]
.text$x:00009CCE                 xor     ecx, eax
.text$x:00009CD0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009CD5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z
.text$x:00009CDA                 jmp     ___CxxFrameHandler3
.text$x:00009CDA __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z endp
.text$x:00009CDA
.text$x:00009CDA ; ---------------------------------------------------------------------------
.text$x:00009CDF                 align 10h
.text$x:00009CDF _text$x         ends
.text$x:00009CDF
.text$mn:00009CE0 ; ===========================================================================
.text$mn:00009CE0
.text$mn:00009CE0 ; Segment type: Pure code
.text$mn:00009CE0 ; Segment permissions: Read/Execute
.text$mn:00009CE0 _text$mn        segment para public 'CODE' use32
.text$mn:00009CE0                 assume cs:_text$mn
.text$mn:00009CE0                 ;org 9CE0h
.text$mn:00009CE0 ; COMDAT (pick any)
.text$mn:00009CE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009CE0
.text$mn:00009CE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00009CE0
.text$mn:00009CE0 ; Attributes: bp-based frame
.text$mn:00009CE0
.text$mn:00009CE0 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(struct std::_Iterator_base12 *)
.text$mn:00009CE0                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00009CE0 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00009CE0                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+(int)+36p
.text$mn:00009CE0                                         ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+(int)+52p
.text$mn:00009CE0
.text$mn:00009CE0 var_10          = dword ptr -10h
.text$mn:00009CE0 var_C           = dword ptr -0Ch
.text$mn:00009CE0 var_4           = dword ptr -4
.text$mn:00009CE0 arg_0           = dword ptr  8
.text$mn:00009CE0
.text$mn:00009CE0                 push    ebp
.text$mn:00009CE1                 mov     ebp, esp
.text$mn:00009CE3                 push    0FFFFFFFFh
.text$mn:00009CE5                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00009CEA                 mov     eax, large fs:0
.text$mn:00009CF0                 push    eax
.text$mn:00009CF1                 push    ecx
.text$mn:00009CF2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009CF7                 xor     eax, ebp
.text$mn:00009CF9                 push    eax
.text$mn:00009CFA                 lea     eax, [ebp+var_C]
.text$mn:00009CFD                 mov     large fs:0, eax
.text$mn:00009D03                 mov     [ebp+var_10], ecx
.text$mn:00009D06                 mov     eax, [ebp+arg_0]
.text$mn:00009D09                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00009D0A                 mov     ecx, [ebp+var_10]
.text$mn:00009D0D                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>> const &)
.text$mn:00009D12                 mov     [ebp+var_4], 0
.text$mn:00009D19                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009D20                 mov     eax, [ebp+var_10]
.text$mn:00009D23                 mov     ecx, [ebp+var_C]
.text$mn:00009D26                 mov     large fs:0, ecx
.text$mn:00009D2D                 pop     ecx
.text$mn:00009D2E                 mov     esp, ebp
.text$mn:00009D30                 pop     ebp
.text$mn:00009D31                 retn    4
.text$mn:00009D31 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00009D31
.text$mn:00009D31 _text$mn        ends
.text$mn:00009D31
.text$x:00009D34 ; ===========================================================================
.text$x:00009D34
.text$x:00009D34 ; Segment type: Pure code
.text$x:00009D34 ; Segment permissions: Read/Execute
.text$x:00009D34 _text$x         segment para public 'CODE' use32
.text$x:00009D34                 assume cs:_text$x
.text$x:00009D34                 ;org 9D34h
.text$x:00009D34 ; COMDAT (pick associative to section at 9CE0)
.text$x:00009D34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009D34
.text$x:00009D34 ; =============== S U B R O U T I N E =======================================
.text$x:00009D34
.text$x:00009D34
.text$x:00009D34 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00009D34                                         ; DATA XREF: .xdata$x:00013D74o
.text$x:00009D34                 mov     ecx, [ebp-10h]
.text$x:00009D37                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00009D37 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00009D37
.text$x:00009D3C
.text$x:00009D3C ; =============== S U B R O U T I N E =======================================
.text$x:00009D3C
.text$x:00009D3C
.text$x:00009D3C __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00009D3C                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>> const &)+5o
.text$x:00009D3C
.text$x:00009D3C arg_4           = dword ptr  8
.text$x:00009D3C
.text$x:00009D3C                 mov     edx, [esp+arg_4]
.text$x:00009D40                 lea     eax, [edx+0Ch]
.text$x:00009D43                 mov     ecx, [edx-8]
.text$x:00009D46                 xor     ecx, eax
.text$x:00009D48                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009D4D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00009D52                 jmp     ___CxxFrameHandler3
.text$x:00009D52 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00009D52
.text$x:00009D52 ; ---------------------------------------------------------------------------
.text$x:00009D57                 align 4
.text$x:00009D57 _text$x         ends
.text$x:00009D57
.text$mn:00009D58 ; ===========================================================================
.text$mn:00009D58
.text$mn:00009D58 ; Segment type: Pure code
.text$mn:00009D58 ; Segment permissions: Read/Execute
.text$mn:00009D58 _text$mn        segment para public 'CODE' use32
.text$mn:00009D58                 assume cs:_text$mn
.text$mn:00009D58                 ;org 9D58h
.text$mn:00009D58 ; COMDAT (pick any)
.text$mn:00009D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009D58
.text$mn:00009D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D58
.text$mn:00009D58 ; Attributes: bp-based frame
.text$mn:00009D58
.text$mn:00009D58 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(int, struct std::_Container_base12 *)
.text$mn:00009D58                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z
.text$mn:00009D58 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z proc near
.text$mn:00009D58                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)+41p
.text$mn:00009D58                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::begin(void)+3Dp
.text$mn:00009D58
.text$mn:00009D58 var_10          = dword ptr -10h
.text$mn:00009D58 var_C           = dword ptr -0Ch
.text$mn:00009D58 var_4           = dword ptr -4
.text$mn:00009D58 arg_0           = dword ptr  8
.text$mn:00009D58 arg_4           = dword ptr  0Ch
.text$mn:00009D58
.text$mn:00009D58                 push    ebp
.text$mn:00009D59                 mov     ebp, esp
.text$mn:00009D5B                 push    0FFFFFFFFh
.text$mn:00009D5D                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z
.text$mn:00009D62                 mov     eax, large fs:0
.text$mn:00009D68                 push    eax
.text$mn:00009D69                 push    ecx
.text$mn:00009D6A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009D6F                 xor     eax, ebp
.text$mn:00009D71                 push    eax
.text$mn:00009D72                 lea     eax, [ebp+var_C]
.text$mn:00009D75                 mov     large fs:0, eax
.text$mn:00009D7B                 mov     [ebp+var_10], ecx
.text$mn:00009D7E                 mov     eax, [ebp+arg_4]
.text$mn:00009D81                 push    eax             ; struct std::_Container_base12 *
.text$mn:00009D82                 mov     ecx, [ebp+arg_0]
.text$mn:00009D85                 push    ecx             ; int
.text$mn:00009D86                 mov     ecx, [ebp+var_10]
.text$mn:00009D89                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(sessionFileInfo *,std::_Container_base12 const *)
.text$mn:00009D8E                 mov     [ebp+var_4], 0
.text$mn:00009D95                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009D9C                 mov     eax, [ebp+var_10]
.text$mn:00009D9F                 mov     ecx, [ebp+var_C]
.text$mn:00009DA2                 mov     large fs:0, ecx
.text$mn:00009DA9                 pop     ecx
.text$mn:00009DAA                 mov     esp, ebp
.text$mn:00009DAC                 pop     ebp
.text$mn:00009DAD                 retn    8
.text$mn:00009DAD ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z endp
.text$mn:00009DAD
.text$mn:00009DAD _text$mn        ends
.text$mn:00009DAD
.text$x:00009DB0 ; ===========================================================================
.text$x:00009DB0
.text$x:00009DB0 ; Segment type: Pure code
.text$x:00009DB0 ; Segment permissions: Read/Execute
.text$x:00009DB0 _text$x         segment para public 'CODE' use32
.text$x:00009DB0                 assume cs:_text$x
.text$x:00009DB0                 ;org 9DB0h
.text$x:00009DB0 ; COMDAT (pick associative to section at 9D58)
.text$x:00009DB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009DB0
.text$x:00009DB0 ; =============== S U B R O U T I N E =======================================
.text$x:00009DB0
.text$x:00009DB0
.text$x:00009DB0 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z$0 proc near
.text$x:00009DB0                                         ; DATA XREF: .xdata$x:00013CE8o
.text$x:00009DB0                 mov     ecx, [ebp-10h]
.text$x:00009DB3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00009DB3 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z$0 endp
.text$x:00009DB3
.text$x:00009DB8
.text$x:00009DB8 ; =============== S U B R O U T I N E =======================================
.text$x:00009DB8
.text$x:00009DB8
.text$x:00009DB8 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z proc near
.text$x:00009DB8                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(sessionFileInfo *,std::_Container_base12 const *)+5o
.text$x:00009DB8
.text$x:00009DB8 arg_4           = dword ptr  8
.text$x:00009DB8
.text$x:00009DB8                 mov     edx, [esp+arg_4]
.text$x:00009DBC                 lea     eax, [edx+0Ch]
.text$x:00009DBF                 mov     ecx, [edx-8]
.text$x:00009DC2                 xor     ecx, eax
.text$x:00009DC4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009DC9                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z
.text$x:00009DCE                 jmp     ___CxxFrameHandler3
.text$x:00009DCE __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z endp
.text$x:00009DCE
.text$x:00009DCE ; ---------------------------------------------------------------------------
.text$x:00009DD3                 align 4
.text$x:00009DD3 _text$x         ends
.text$x:00009DD3
.text$mn:00009DD4 ; ===========================================================================
.text$mn:00009DD4
.text$mn:00009DD4 ; Segment type: Pure code
.text$mn:00009DD4 ; Segment permissions: Read/Execute
.text$mn:00009DD4 _text$mn        segment para public 'CODE' use32
.text$mn:00009DD4                 assume cs:_text$mn
.text$mn:00009DD4                 ;org 9DD4h
.text$mn:00009DD4 ; COMDAT (pick any)
.text$mn:00009DD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009DD4
.text$mn:00009DD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00009DD4
.text$mn:00009DD4 ; Attributes: bp-based frame
.text$mn:00009DD4
.text$mn:00009DD4 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<int>>::_Vector_val<struct std::_Simple_types<int>>(void)
.text$mn:00009DD4                 public ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$mn:00009DD4 ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ proc near
.text$mn:00009DD4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(std::allocator<int> const &)+29p
.text$mn:00009DD4
.text$mn:00009DD4 var_10          = dword ptr -10h
.text$mn:00009DD4 var_C           = dword ptr -0Ch
.text$mn:00009DD4 var_4           = dword ptr -4
.text$mn:00009DD4
.text$mn:00009DD4                 push    ebp
.text$mn:00009DD5                 mov     ebp, esp
.text$mn:00009DD7                 push    0FFFFFFFFh
.text$mn:00009DD9                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$mn:00009DDE                 mov     eax, large fs:0
.text$mn:00009DE4                 push    eax
.text$mn:00009DE5                 push    ecx
.text$mn:00009DE6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009DEB                 xor     eax, ebp
.text$mn:00009DED                 push    eax
.text$mn:00009DEE                 lea     eax, [ebp+var_C]
.text$mn:00009DF1                 mov     large fs:0, eax
.text$mn:00009DF7                 mov     [ebp+var_10], ecx
.text$mn:00009DFA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00009DFD                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00009E02                 mov     [ebp+var_4], 0
.text$mn:00009E09                 mov     eax, [ebp+var_10]
.text$mn:00009E0C                 mov     dword ptr [eax+4], 0
.text$mn:00009E13                 mov     ecx, [ebp+var_10]
.text$mn:00009E16                 mov     dword ptr [ecx+8], 0
.text$mn:00009E1D                 mov     edx, [ebp+var_10]
.text$mn:00009E20                 mov     dword ptr [edx+0Ch], 0
.text$mn:00009E27                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009E2E                 mov     eax, [ebp+var_10]
.text$mn:00009E31                 mov     ecx, [ebp+var_C]
.text$mn:00009E34                 mov     large fs:0, ecx
.text$mn:00009E3B                 pop     ecx
.text$mn:00009E3C                 mov     esp, ebp
.text$mn:00009E3E                 pop     ebp
.text$mn:00009E3F                 retn
.text$mn:00009E3F ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ endp
.text$mn:00009E3F
.text$mn:00009E3F _text$mn        ends
.text$mn:00009E3F
.text$x:00009E40 ; ===========================================================================
.text$x:00009E40
.text$x:00009E40 ; Segment type: Pure code
.text$x:00009E40 ; Segment permissions: Read/Execute
.text$x:00009E40 _text$x         segment para public 'CODE' use32
.text$x:00009E40                 assume cs:_text$x
.text$x:00009E40                 ;org 9E40h
.text$x:00009E40 ; COMDAT (pick associative to section at 9DD4)
.text$x:00009E40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009E40
.text$x:00009E40 ; =============== S U B R O U T I N E =======================================
.text$x:00009E40
.text$x:00009E40
.text$x:00009E40 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0 proc near
.text$x:00009E40                                         ; DATA XREF: .xdata$x:00012B38o
.text$x:00009E40                 mov     ecx, [ebp-10h]  ; this
.text$x:00009E43                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00009E43 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0 endp
.text$x:00009E43
.text$x:00009E48
.text$x:00009E48 ; =============== S U B R O U T I N E =======================================
.text$x:00009E48
.text$x:00009E48
.text$x:00009E48 __ehhandler$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ proc near
.text$x:00009E48                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<int>>::_Vector_val<std::_Simple_types<int>>(void)+5o
.text$x:00009E48
.text$x:00009E48 arg_4           = dword ptr  8
.text$x:00009E48
.text$x:00009E48                 mov     edx, [esp+arg_4]
.text$x:00009E4C                 lea     eax, [edx+0Ch]
.text$x:00009E4F                 mov     ecx, [edx-8]
.text$x:00009E52                 xor     ecx, eax
.text$x:00009E54                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009E59                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$x:00009E5E                 jmp     ___CxxFrameHandler3
.text$x:00009E5E __ehhandler$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ endp
.text$x:00009E5E
.text$x:00009E5E ; ---------------------------------------------------------------------------
.text$x:00009E63                 align 4
.text$x:00009E63 _text$x         ends
.text$x:00009E63
.text$mn:00009E64 ; ===========================================================================
.text$mn:00009E64
.text$mn:00009E64 ; Segment type: Pure code
.text$mn:00009E64 ; Segment permissions: Read/Execute
.text$mn:00009E64 _text$mn        segment para public 'CODE' use32
.text$mn:00009E64                 assume cs:_text$mn
.text$mn:00009E64                 ;org 9E64h
.text$mn:00009E64 ; COMDAT (pick any)
.text$mn:00009E64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009E64
.text$mn:00009E64 ; =============== S U B R O U T I N E =======================================
.text$mn:00009E64
.text$mn:00009E64 ; Attributes: bp-based frame
.text$mn:00009E64
.text$mn:00009E64 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<unsigned int>>::_Vector_val<struct std::_Simple_types<unsigned int>>(void)
.text$mn:00009E64                 public ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.text$mn:00009E64 ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ proc near
.text$mn:00009E64                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(std::allocator<uint> const &)+29p
.text$mn:00009E64
.text$mn:00009E64 var_10          = dword ptr -10h
.text$mn:00009E64 var_C           = dword ptr -0Ch
.text$mn:00009E64 var_4           = dword ptr -4
.text$mn:00009E64
.text$mn:00009E64                 push    ebp
.text$mn:00009E65                 mov     ebp, esp
.text$mn:00009E67                 push    0FFFFFFFFh
.text$mn:00009E69                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.text$mn:00009E6E                 mov     eax, large fs:0
.text$mn:00009E74                 push    eax
.text$mn:00009E75                 push    ecx
.text$mn:00009E76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009E7B                 xor     eax, ebp
.text$mn:00009E7D                 push    eax
.text$mn:00009E7E                 lea     eax, [ebp+var_C]
.text$mn:00009E81                 mov     large fs:0, eax
.text$mn:00009E87                 mov     [ebp+var_10], ecx
.text$mn:00009E8A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00009E8D                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00009E92                 mov     [ebp+var_4], 0
.text$mn:00009E99                 mov     eax, [ebp+var_10]
.text$mn:00009E9C                 mov     dword ptr [eax+4], 0
.text$mn:00009EA3                 mov     ecx, [ebp+var_10]
.text$mn:00009EA6                 mov     dword ptr [ecx+8], 0
.text$mn:00009EAD                 mov     edx, [ebp+var_10]
.text$mn:00009EB0                 mov     dword ptr [edx+0Ch], 0
.text$mn:00009EB7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009EBE                 mov     eax, [ebp+var_10]
.text$mn:00009EC1                 mov     ecx, [ebp+var_C]
.text$mn:00009EC4                 mov     large fs:0, ecx
.text$mn:00009ECB                 pop     ecx
.text$mn:00009ECC                 mov     esp, ebp
.text$mn:00009ECE                 pop     ebp
.text$mn:00009ECF                 retn
.text$mn:00009ECF ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ endp
.text$mn:00009ECF
.text$mn:00009ECF _text$mn        ends
.text$mn:00009ECF
.text$x:00009ED0 ; ===========================================================================
.text$x:00009ED0
.text$x:00009ED0 ; Segment type: Pure code
.text$x:00009ED0 ; Segment permissions: Read/Execute
.text$x:00009ED0 _text$x         segment para public 'CODE' use32
.text$x:00009ED0                 assume cs:_text$x
.text$x:00009ED0                 ;org 9ED0h
.text$x:00009ED0 ; COMDAT (pick associative to section at 9E64)
.text$x:00009ED0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009ED0
.text$x:00009ED0 ; =============== S U B R O U T I N E =======================================
.text$x:00009ED0
.text$x:00009ED0
.text$x:00009ED0 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ$0 proc near
.text$x:00009ED0                                         ; DATA XREF: .xdata$x:00012D70o
.text$x:00009ED0                 mov     ecx, [ebp-10h]  ; this
.text$x:00009ED3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00009ED3 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ$0 endp
.text$x:00009ED3
.text$x:00009ED8
.text$x:00009ED8 ; =============== S U B R O U T I N E =======================================
.text$x:00009ED8
.text$x:00009ED8
.text$x:00009ED8 __ehhandler$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ proc near
.text$x:00009ED8                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<uint>>::_Vector_val<std::_Simple_types<uint>>(void)+5o
.text$x:00009ED8
.text$x:00009ED8 arg_4           = dword ptr  8
.text$x:00009ED8
.text$x:00009ED8                 mov     edx, [esp+arg_4]
.text$x:00009EDC                 lea     eax, [edx+0Ch]
.text$x:00009EDF                 mov     ecx, [edx-8]
.text$x:00009EE2                 xor     ecx, eax
.text$x:00009EE4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009EE9                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.text$x:00009EEE                 jmp     ___CxxFrameHandler3
.text$x:00009EEE __ehhandler$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ endp
.text$x:00009EEE
.text$x:00009EEE ; ---------------------------------------------------------------------------
.text$x:00009EF3                 align 4
.text$x:00009EF3 _text$x         ends
.text$x:00009EF3
.text$mn:00009EF4 ; ===========================================================================
.text$mn:00009EF4
.text$mn:00009EF4 ; Segment type: Pure code
.text$mn:00009EF4 ; Segment permissions: Read/Execute
.text$mn:00009EF4 _text$mn        segment para public 'CODE' use32
.text$mn:00009EF4                 assume cs:_text$mn
.text$mn:00009EF4                 ;org 9EF4h
.text$mn:00009EF4 ; COMDAT (pick any)
.text$mn:00009EF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009EF4
.text$mn:00009EF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00009EF4
.text$mn:00009EF4 ; Attributes: bp-based frame
.text$mn:00009EF4
.text$mn:00009EF4 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>(void)
.text$mn:00009EF4                 public ??0?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ
.text$mn:00009EF4 ??0?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ proc near
.text$mn:00009EF4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>(std::allocator<sessionFileInfo> const &)+29p
.text$mn:00009EF4
.text$mn:00009EF4 var_10          = dword ptr -10h
.text$mn:00009EF4 var_C           = dword ptr -0Ch
.text$mn:00009EF4 var_4           = dword ptr -4
.text$mn:00009EF4
.text$mn:00009EF4                 push    ebp
.text$mn:00009EF5                 mov     ebp, esp
.text$mn:00009EF7                 push    0FFFFFFFFh
.text$mn:00009EF9                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ
.text$mn:00009EFE                 mov     eax, large fs:0
.text$mn:00009F04                 push    eax
.text$mn:00009F05                 push    ecx
.text$mn:00009F06                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009F0B                 xor     eax, ebp
.text$mn:00009F0D                 push    eax
.text$mn:00009F0E                 lea     eax, [ebp+var_C]
.text$mn:00009F11                 mov     large fs:0, eax
.text$mn:00009F17                 mov     [ebp+var_10], ecx
.text$mn:00009F1A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00009F1D                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00009F22                 mov     [ebp+var_4], 0
.text$mn:00009F29                 mov     eax, [ebp+var_10]
.text$mn:00009F2C                 mov     dword ptr [eax+4], 0
.text$mn:00009F33                 mov     ecx, [ebp+var_10]
.text$mn:00009F36                 mov     dword ptr [ecx+8], 0
.text$mn:00009F3D                 mov     edx, [ebp+var_10]
.text$mn:00009F40                 mov     dword ptr [edx+0Ch], 0
.text$mn:00009F47                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009F4E                 mov     eax, [ebp+var_10]
.text$mn:00009F51                 mov     ecx, [ebp+var_C]
.text$mn:00009F54                 mov     large fs:0, ecx
.text$mn:00009F5B                 pop     ecx
.text$mn:00009F5C                 mov     esp, ebp
.text$mn:00009F5E                 pop     ebp
.text$mn:00009F5F                 retn
.text$mn:00009F5F ??0?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ endp
.text$mn:00009F5F
.text$mn:00009F5F _text$mn        ends
.text$mn:00009F5F
.text$x:00009F60 ; ===========================================================================
.text$x:00009F60
.text$x:00009F60 ; Segment type: Pure code
.text$x:00009F60 ; Segment permissions: Read/Execute
.text$x:00009F60 _text$x         segment para public 'CODE' use32
.text$x:00009F60                 assume cs:_text$x
.text$x:00009F60                 ;org 9F60h
.text$x:00009F60 ; COMDAT (pick associative to section at 9EF4)
.text$x:00009F60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009F60
.text$x:00009F60 ; =============== S U B R O U T I N E =======================================
.text$x:00009F60
.text$x:00009F60
.text$x:00009F60 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00009F60                                         ; DATA XREF: .xdata$x:0001305Co
.text$x:00009F60                 mov     ecx, [ebp-10h]  ; this
.text$x:00009F63                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00009F63 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ$0 endp
.text$x:00009F63
.text$x:00009F68
.text$x:00009F68 ; =============== S U B R O U T I N E =======================================
.text$x:00009F68
.text$x:00009F68
.text$x:00009F68 __ehhandler$??0?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ proc near
.text$x:00009F68                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<sessionFileInfo>>::_Vector_val<std::_Simple_types<sessionFileInfo>>(void)+5o
.text$x:00009F68
.text$x:00009F68 arg_4           = dword ptr  8
.text$x:00009F68
.text$x:00009F68                 mov     edx, [esp+arg_4]
.text$x:00009F6C                 lea     eax, [edx+0Ch]
.text$x:00009F6F                 mov     ecx, [edx-8]
.text$x:00009F72                 xor     ecx, eax
.text$x:00009F74                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009F79                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ
.text$x:00009F7E                 jmp     ___CxxFrameHandler3
.text$x:00009F7E __ehhandler$??0?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ endp
.text$x:00009F7E
.text$x:00009F7E ; ---------------------------------------------------------------------------
.text$x:00009F83                 align 4
.text$x:00009F83 _text$x         ends
.text$x:00009F83
.text$mn:00009F84 ; ===========================================================================
.text$mn:00009F84
.text$mn:00009F84 ; Segment type: Pure code
.text$mn:00009F84 ; Segment permissions: Read/Execute
.text$mn:00009F84 _text$mn        segment para public 'CODE' use32
.text$mn:00009F84                 assume cs:_text$mn
.text$mn:00009F84                 ;org 9F84h
.text$mn:00009F84 ; COMDAT (pick any)
.text$mn:00009F84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009F84
.text$mn:00009F84 ; =============== S U B R O U T I N E =======================================
.text$mn:00009F84
.text$mn:00009F84 ; Attributes: bp-based frame
.text$mn:00009F84
.text$mn:00009F84 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Vector_val<struct std::_Simple_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(void)
.text$mn:00009F84                 public ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$mn:00009F84 ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00009F84                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)+29p
.text$mn:00009F84
.text$mn:00009F84 var_10          = dword ptr -10h
.text$mn:00009F84 var_C           = dword ptr -0Ch
.text$mn:00009F84 var_4           = dword ptr -4
.text$mn:00009F84
.text$mn:00009F84                 push    ebp
.text$mn:00009F85                 mov     ebp, esp
.text$mn:00009F87                 push    0FFFFFFFFh
.text$mn:00009F89                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$mn:00009F8E                 mov     eax, large fs:0
.text$mn:00009F94                 push    eax
.text$mn:00009F95                 push    ecx
.text$mn:00009F96                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009F9B                 xor     eax, ebp
.text$mn:00009F9D                 push    eax
.text$mn:00009F9E                 lea     eax, [ebp+var_C]
.text$mn:00009FA1                 mov     large fs:0, eax
.text$mn:00009FA7                 mov     [ebp+var_10], ecx
.text$mn:00009FAA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00009FAD                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00009FB2                 mov     [ebp+var_4], 0
.text$mn:00009FB9                 mov     eax, [ebp+var_10]
.text$mn:00009FBC                 mov     dword ptr [eax+4], 0
.text$mn:00009FC3                 mov     ecx, [ebp+var_10]
.text$mn:00009FC6                 mov     dword ptr [ecx+8], 0
.text$mn:00009FCD                 mov     edx, [ebp+var_10]
.text$mn:00009FD0                 mov     dword ptr [edx+0Ch], 0
.text$mn:00009FD7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009FDE                 mov     eax, [ebp+var_10]
.text$mn:00009FE1                 mov     ecx, [ebp+var_C]
.text$mn:00009FE4                 mov     large fs:0, ecx
.text$mn:00009FEB                 pop     ecx
.text$mn:00009FEC                 mov     esp, ebp
.text$mn:00009FEE                 pop     ebp
.text$mn:00009FEF                 retn
.text$mn:00009FEF ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00009FEF
.text$mn:00009FEF _text$mn        ends
.text$mn:00009FEF
.text$x:00009FF0 ; ===========================================================================
.text$x:00009FF0
.text$x:00009FF0 ; Segment type: Pure code
.text$x:00009FF0 ; Segment permissions: Read/Execute
.text$x:00009FF0 _text$x         segment para public 'CODE' use32
.text$x:00009FF0                 assume cs:_text$x
.text$x:00009FF0                 ;org 9FF0h
.text$x:00009FF0 ; COMDAT (pick associative to section at 9F84)
.text$x:00009FF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009FF0
.text$x:00009FF0 ; =============== S U B R O U T I N E =======================================
.text$x:00009FF0
.text$x:00009FF0
.text$x:00009FF0 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00009FF0                                         ; DATA XREF: .xdata$x:000133E8o
.text$x:00009FF0                 mov     ecx, [ebp-10h]  ; this
.text$x:00009FF3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00009FF3 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00009FF3
.text$x:00009FF8
.text$x:00009FF8 ; =============== S U B R O U T I N E =======================================
.text$x:00009FF8
.text$x:00009FF8
.text$x:00009FF8 __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00009FF8                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+5o
.text$x:00009FF8
.text$x:00009FF8 arg_4           = dword ptr  8
.text$x:00009FF8
.text$x:00009FF8                 mov     edx, [esp+arg_4]
.text$x:00009FFC                 lea     eax, [edx+0Ch]
.text$x:00009FFF                 mov     ecx, [edx-8]
.text$x:0000A002                 xor     ecx, eax
.text$x:0000A004                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A009                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$x:0000A00E                 jmp     ___CxxFrameHandler3
.text$x:0000A00E __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000A00E
.text$x:0000A00E ; ---------------------------------------------------------------------------
.text$x:0000A013                 align 4
.text$x:0000A013 _text$x         ends
.text$x:0000A013
.text$mn:0000A014 ; ===========================================================================
.text$mn:0000A014
.text$mn:0000A014 ; Segment type: Pure code
.text$mn:0000A014 ; Segment permissions: Read/Execute
.text$mn:0000A014 _text$mn        segment para public 'CODE' use32
.text$mn:0000A014                 assume cs:_text$mn
.text$mn:0000A014                 ;org 0A014h
.text$mn:0000A014 ; COMDAT (pick any)
.text$mn:0000A014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A014
.text$mn:0000A014 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A014
.text$mn:0000A014 ; Attributes: bp-based frame
.text$mn:0000A014
.text$mn:0000A014 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:0000A014                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:0000A014 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:0000A014                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:0000A014
.text$mn:0000A014 var_4           = dword ptr -4
.text$mn:0000A014
.text$mn:0000A014                 push    ebp
.text$mn:0000A015                 mov     ebp, esp
.text$mn:0000A017                 push    ecx
.text$mn:0000A018                 mov     [ebp+var_4], ecx
.text$mn:0000A01B                 mov     ecx, [ebp+var_4]
.text$mn:0000A01E                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000A023                 mov     eax, [ebp+var_4]
.text$mn:0000A026                 mov     esp, ebp
.text$mn:0000A028                 pop     ebp
.text$mn:0000A029                 retn
.text$mn:0000A029 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:0000A029
.text$mn:0000A029 ; ---------------------------------------------------------------------------
.text$mn:0000A02A                 align 4
.text$mn:0000A02A _text$mn        ends
.text$mn:0000A02A
.text$mn:0000A02C ; ===========================================================================
.text$mn:0000A02C
.text$mn:0000A02C ; Segment type: Pure code
.text$mn:0000A02C ; Segment permissions: Read/Execute
.text$mn:0000A02C _text$mn        segment para public 'CODE' use32
.text$mn:0000A02C                 assume cs:_text$mn
.text$mn:0000A02C                 ;org 0A02Ch
.text$mn:0000A02C ; COMDAT (pick any)
.text$mn:0000A02C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A02C
.text$mn:0000A02C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A02C
.text$mn:0000A02C ; Attributes: bp-based frame
.text$mn:0000A02C
.text$mn:0000A02C ; public: __thiscall std::_Wrap_alloc<class std::allocator<int>>::_Wrap_alloc<class std::allocator<int>>(void)
.text$mn:0000A02C                 public ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ
.text$mn:0000A02C ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ proc near
.text$mn:0000A02C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)+Ap
.text$mn:0000A02C
.text$mn:0000A02C var_4           = dword ptr -4
.text$mn:0000A02C
.text$mn:0000A02C                 push    ebp
.text$mn:0000A02D                 mov     ebp, esp
.text$mn:0000A02F                 push    ecx
.text$mn:0000A030                 mov     [ebp+var_4], ecx
.text$mn:0000A033                 mov     ecx, [ebp+var_4]
.text$mn:0000A036                 call    ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>(void)
.text$mn:0000A03B                 mov     eax, [ebp+var_4]
.text$mn:0000A03E                 mov     esp, ebp
.text$mn:0000A040                 pop     ebp
.text$mn:0000A041                 retn
.text$mn:0000A041 ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ endp
.text$mn:0000A041
.text$mn:0000A041 ; ---------------------------------------------------------------------------
.text$mn:0000A042                 align 4
.text$mn:0000A042 _text$mn        ends
.text$mn:0000A042
.text$mn:0000A044 ; ===========================================================================
.text$mn:0000A044
.text$mn:0000A044 ; Segment type: Pure code
.text$mn:0000A044 ; Segment permissions: Read/Execute
.text$mn:0000A044 _text$mn        segment para public 'CODE' use32
.text$mn:0000A044                 assume cs:_text$mn
.text$mn:0000A044                 ;org 0A044h
.text$mn:0000A044 ; COMDAT (pick any)
.text$mn:0000A044                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A044
.text$mn:0000A044 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A044
.text$mn:0000A044 ; Attributes: bp-based frame
.text$mn:0000A044
.text$mn:0000A044 ; public: __thiscall std::_Wrap_alloc<class std::allocator<unsigned int>>::_Wrap_alloc<class std::allocator<unsigned int>>(class std::allocator<unsigned int> const &)
.text$mn:0000A044                 public ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@ABV?$allocator@I@1@@Z
.text$mn:0000A044 ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@ABV?$allocator@I@1@@Z proc near
.text$mn:0000A044                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::select_on_container_copy_construction(void)+1Dp
.text$mn:0000A044
.text$mn:0000A044 var_4           = dword ptr -4
.text$mn:0000A044 arg_0           = dword ptr  8
.text$mn:0000A044
.text$mn:0000A044                 push    ebp
.text$mn:0000A045                 mov     ebp, esp
.text$mn:0000A047                 push    ecx
.text$mn:0000A048                 mov     [ebp+var_4], ecx
.text$mn:0000A04B                 mov     eax, [ebp+arg_0]
.text$mn:0000A04E                 push    eax
.text$mn:0000A04F                 mov     ecx, [ebp+var_4]
.text$mn:0000A052                 call    ??0?$allocator@I@std@@QAE@ABV01@@Z ; std::allocator<uint>::allocator<uint>(std::allocator<uint> const &)
.text$mn:0000A057                 mov     eax, [ebp+var_4]
.text$mn:0000A05A                 mov     esp, ebp
.text$mn:0000A05C                 pop     ebp
.text$mn:0000A05D                 retn    4
.text$mn:0000A05D ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@ABV?$allocator@I@1@@Z endp
.text$mn:0000A05D
.text$mn:0000A05D _text$mn        ends
.text$mn:0000A05D
.text$mn:0000A060 ; ===========================================================================
.text$mn:0000A060
.text$mn:0000A060 ; Segment type: Pure code
.text$mn:0000A060 ; Segment permissions: Read/Execute
.text$mn:0000A060 _text$mn        segment para public 'CODE' use32
.text$mn:0000A060                 assume cs:_text$mn
.text$mn:0000A060                 ;org 0A060h
.text$mn:0000A060 ; COMDAT (pick any)
.text$mn:0000A060                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A060
.text$mn:0000A060 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A060
.text$mn:0000A060 ; Attributes: bp-based frame
.text$mn:0000A060
.text$mn:0000A060 ; public: __thiscall std::_Wrap_alloc<class std::allocator<unsigned int>>::_Wrap_alloc<class std::allocator<unsigned int>>(void)
.text$mn:0000A060                 public ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@XZ
.text$mn:0000A060 ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@XZ proc near
.text$mn:0000A060                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Getal(void)+Ap
.text$mn:0000A060
.text$mn:0000A060 var_4           = dword ptr -4
.text$mn:0000A060
.text$mn:0000A060                 push    ebp
.text$mn:0000A061                 mov     ebp, esp
.text$mn:0000A063                 push    ecx
.text$mn:0000A064                 mov     [ebp+var_4], ecx
.text$mn:0000A067                 mov     ecx, [ebp+var_4]
.text$mn:0000A06A                 call    ??0?$allocator@I@std@@QAE@XZ ; std::allocator<uint>::allocator<uint>(void)
.text$mn:0000A06F                 mov     eax, [ebp+var_4]
.text$mn:0000A072                 mov     esp, ebp
.text$mn:0000A074                 pop     ebp
.text$mn:0000A075                 retn
.text$mn:0000A075 ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@XZ endp
.text$mn:0000A075
.text$mn:0000A075 ; ---------------------------------------------------------------------------
.text$mn:0000A076                 align 4
.text$mn:0000A076 _text$mn        ends
.text$mn:0000A076
.text$mn:0000A078 ; ===========================================================================
.text$mn:0000A078
.text$mn:0000A078 ; Segment type: Pure code
.text$mn:0000A078 ; Segment permissions: Read/Execute
.text$mn:0000A078 _text$mn        segment para public 'CODE' use32
.text$mn:0000A078                 assume cs:_text$mn
.text$mn:0000A078                 ;org 0A078h
.text$mn:0000A078 ; COMDAT (pick any)
.text$mn:0000A078                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A078
.text$mn:0000A078 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A078
.text$mn:0000A078 ; Attributes: bp-based frame
.text$mn:0000A078
.text$mn:0000A078 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:0000A078                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:0000A078 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000A078                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Alloc_proxy(void)+Cp
.text$mn:0000A078                                         ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Alloc_proxy(void)+Cp ...
.text$mn:0000A078
.text$mn:0000A078 var_4           = dword ptr -4
.text$mn:0000A078
.text$mn:0000A078                 push    ebp
.text$mn:0000A079                 mov     ebp, esp
.text$mn:0000A07B                 push    ecx
.text$mn:0000A07C                 mov     [ebp+var_4], ecx
.text$mn:0000A07F                 mov     ecx, [ebp+var_4]
.text$mn:0000A082                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000A087                 mov     eax, [ebp+var_4]
.text$mn:0000A08A                 mov     esp, ebp
.text$mn:0000A08C                 pop     ebp
.text$mn:0000A08D                 retn
.text$mn:0000A08D ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000A08D
.text$mn:0000A08D ; ---------------------------------------------------------------------------
.text$mn:0000A08E                 align 10h
.text$mn:0000A08E _text$mn        ends
.text$mn:0000A08E
.text$mn:0000A090 ; ===========================================================================
.text$mn:0000A090
.text$mn:0000A090 ; Segment type: Pure code
.text$mn:0000A090 ; Segment permissions: Read/Execute
.text$mn:0000A090 _text$mn        segment para public 'CODE' use32
.text$mn:0000A090                 assume cs:_text$mn
.text$mn:0000A090                 ;org 0A090h
.text$mn:0000A090 ; COMDAT (pick any)
.text$mn:0000A090                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A090
.text$mn:0000A090 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A090
.text$mn:0000A090 ; Attributes: bp-based frame
.text$mn:0000A090
.text$mn:0000A090 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>>::_Wrap_alloc<class std::allocator<struct sessionFileInfo>>(class std::allocator<struct sessionFileInfo> const &)
.text$mn:0000A090                 public ??0?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z
.text$mn:0000A090 ??0?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z proc near
.text$mn:0000A090                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<sessionFileInfo>>::select_on_container_copy_construction(void)+1Dp
.text$mn:0000A090
.text$mn:0000A090 var_4           = dword ptr -4
.text$mn:0000A090 arg_0           = dword ptr  8
.text$mn:0000A090
.text$mn:0000A090                 push    ebp
.text$mn:0000A091                 mov     ebp, esp
.text$mn:0000A093                 push    ecx
.text$mn:0000A094                 mov     [ebp+var_4], ecx
.text$mn:0000A097                 mov     eax, [ebp+arg_0]
.text$mn:0000A09A                 push    eax
.text$mn:0000A09B                 mov     ecx, [ebp+var_4]
.text$mn:0000A09E                 call    ??0?$allocator@UsessionFileInfo@@@std@@QAE@ABV01@@Z ; std::allocator<sessionFileInfo>::allocator<sessionFileInfo>(std::allocator<sessionFileInfo> const &)
.text$mn:0000A0A3                 mov     eax, [ebp+var_4]
.text$mn:0000A0A6                 mov     esp, ebp
.text$mn:0000A0A8                 pop     ebp
.text$mn:0000A0A9                 retn    4
.text$mn:0000A0A9 ??0?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z endp
.text$mn:0000A0A9
.text$mn:0000A0A9 _text$mn        ends
.text$mn:0000A0A9
.text$mn:0000A0AC ; ===========================================================================
.text$mn:0000A0AC
.text$mn:0000A0AC ; Segment type: Pure code
.text$mn:0000A0AC ; Segment permissions: Read/Execute
.text$mn:0000A0AC _text$mn        segment para public 'CODE' use32
.text$mn:0000A0AC                 assume cs:_text$mn
.text$mn:0000A0AC                 ;org 0A0ACh
.text$mn:0000A0AC ; COMDAT (pick any)
.text$mn:0000A0AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A0AC
.text$mn:0000A0AC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A0AC
.text$mn:0000A0AC ; Attributes: bp-based frame
.text$mn:0000A0AC
.text$mn:0000A0AC ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>>::_Wrap_alloc<class std::allocator<struct sessionFileInfo>>(void)
.text$mn:0000A0AC                 public ??0?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ
.text$mn:0000A0AC ??0?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ proc near
.text$mn:0000A0AC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Getal(void)+Ap
.text$mn:0000A0AC
.text$mn:0000A0AC var_4           = dword ptr -4
.text$mn:0000A0AC
.text$mn:0000A0AC                 push    ebp
.text$mn:0000A0AD                 mov     ebp, esp
.text$mn:0000A0AF                 push    ecx
.text$mn:0000A0B0                 mov     [ebp+var_4], ecx
.text$mn:0000A0B3                 mov     ecx, [ebp+var_4]
.text$mn:0000A0B6                 call    ??0?$allocator@UsessionFileInfo@@@std@@QAE@XZ ; std::allocator<sessionFileInfo>::allocator<sessionFileInfo>(void)
.text$mn:0000A0BB                 mov     eax, [ebp+var_4]
.text$mn:0000A0BE                 mov     esp, ebp
.text$mn:0000A0C0                 pop     ebp
.text$mn:0000A0C1                 retn
.text$mn:0000A0C1 ??0?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ endp
.text$mn:0000A0C1
.text$mn:0000A0C1 ; ---------------------------------------------------------------------------
.text$mn:0000A0C2                 align 4
.text$mn:0000A0C2 _text$mn        ends
.text$mn:0000A0C2
.text$mn:0000A0C4 ; ===========================================================================
.text$mn:0000A0C4
.text$mn:0000A0C4 ; Segment type: Pure code
.text$mn:0000A0C4 ; Segment permissions: Read/Execute
.text$mn:0000A0C4 _text$mn        segment para public 'CODE' use32
.text$mn:0000A0C4                 assume cs:_text$mn
.text$mn:0000A0C4                 ;org 0A0C4h
.text$mn:0000A0C4 ; COMDAT (pick any)
.text$mn:0000A0C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A0C4
.text$mn:0000A0C4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A0C4
.text$mn:0000A0C4 ; Attributes: bp-based frame
.text$mn:0000A0C4
.text$mn:0000A0C4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(void)
.text$mn:0000A0C4                 public ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$mn:0000A0C4 ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000A0C4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)+Ap
.text$mn:0000A0C4
.text$mn:0000A0C4 var_4           = dword ptr -4
.text$mn:0000A0C4
.text$mn:0000A0C4                 push    ebp
.text$mn:0000A0C5                 mov     ebp, esp
.text$mn:0000A0C7                 push    ecx
.text$mn:0000A0C8                 mov     [ebp+var_4], ecx
.text$mn:0000A0CB                 mov     ecx, [ebp+var_4]
.text$mn:0000A0CE                 call    ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(void)
.text$mn:0000A0D3                 mov     eax, [ebp+var_4]
.text$mn:0000A0D6                 mov     esp, ebp
.text$mn:0000A0D8                 pop     ebp
.text$mn:0000A0D9                 retn
.text$mn:0000A0D9 ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000A0D9
.text$mn:0000A0D9 ; ---------------------------------------------------------------------------
.text$mn:0000A0DA                 align 4
.text$mn:0000A0DA _text$mn        ends
.text$mn:0000A0DA
.text$mn:0000A0DC ; ===========================================================================
.text$mn:0000A0DC
.text$mn:0000A0DC ; Segment type: Pure code
.text$mn:0000A0DC ; Segment permissions: Read/Execute
.text$mn:0000A0DC _text$mn        segment para public 'CODE' use32
.text$mn:0000A0DC                 assume cs:_text$mn
.text$mn:0000A0DC                 ;org 0A0DCh
.text$mn:0000A0DC ; COMDAT (pick any)
.text$mn:0000A0DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A0DC
.text$mn:0000A0DC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A0DC
.text$mn:0000A0DC ; Attributes: bp-based frame
.text$mn:0000A0DC
.text$mn:0000A0DC ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(class std::allocator<wchar_t> const &)
.text$mn:0000A0DC                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:0000A0DC ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:0000A0DC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+1Dp
.text$mn:0000A0DC
.text$mn:0000A0DC var_4           = dword ptr -4
.text$mn:0000A0DC arg_0           = dword ptr  8
.text$mn:0000A0DC
.text$mn:0000A0DC                 push    ebp
.text$mn:0000A0DD                 mov     ebp, esp
.text$mn:0000A0DF                 push    ecx
.text$mn:0000A0E0                 mov     [ebp+var_4], ecx
.text$mn:0000A0E3                 mov     eax, [ebp+arg_0]
.text$mn:0000A0E6                 push    eax
.text$mn:0000A0E7                 mov     ecx, [ebp+var_4]
.text$mn:0000A0EA                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:0000A0EF                 mov     eax, [ebp+var_4]
.text$mn:0000A0F2                 mov     esp, ebp
.text$mn:0000A0F4                 pop     ebp
.text$mn:0000A0F5                 retn    4
.text$mn:0000A0F5 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:0000A0F5
.text$mn:0000A0F5 _text$mn        ends
.text$mn:0000A0F5
.text$mn:0000A0F8 ; ===========================================================================
.text$mn:0000A0F8
.text$mn:0000A0F8 ; Segment type: Pure code
.text$mn:0000A0F8 ; Segment permissions: Read/Execute
.text$mn:0000A0F8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A0F8                 assume cs:_text$mn
.text$mn:0000A0F8                 ;org 0A0F8h
.text$mn:0000A0F8 ; COMDAT (pick any)
.text$mn:0000A0F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A0F8
.text$mn:0000A0F8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A0F8
.text$mn:0000A0F8 ; Attributes: bp-based frame
.text$mn:0000A0F8
.text$mn:0000A0F8 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:0000A0F8                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:0000A0F8 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:0000A0F8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:0000A0F8
.text$mn:0000A0F8 var_4           = dword ptr -4
.text$mn:0000A0F8
.text$mn:0000A0F8                 push    ebp
.text$mn:0000A0F9                 mov     ebp, esp
.text$mn:0000A0FB                 push    ecx
.text$mn:0000A0FC                 mov     [ebp+var_4], ecx
.text$mn:0000A0FF                 mov     ecx, [ebp+var_4]
.text$mn:0000A102                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:0000A107                 mov     eax, [ebp+var_4]
.text$mn:0000A10A                 mov     esp, ebp
.text$mn:0000A10C                 pop     ebp
.text$mn:0000A10D                 retn
.text$mn:0000A10D ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:0000A10D
.text$mn:0000A10D ; ---------------------------------------------------------------------------
.text$mn:0000A10E                 align 10h
.text$mn:0000A10E _text$mn        ends
.text$mn:0000A10E
.text$mn:0000A110 ; ===========================================================================
.text$mn:0000A110
.text$mn:0000A110 ; Segment type: Pure code
.text$mn:0000A110 ; Segment permissions: Read/Execute
.text$mn:0000A110 _text$mn        segment para public 'CODE' use32
.text$mn:0000A110                 assume cs:_text$mn
.text$mn:0000A110                 ;org 0A110h
.text$mn:0000A110 ; COMDAT (pick any)
.text$mn:0000A110                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A110
.text$mn:0000A110 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A110
.text$mn:0000A110 ; Attributes: bp-based frame
.text$mn:0000A110
.text$mn:0000A110 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:0000A110                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:0000A110 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:0000A110                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:0000A110
.text$mn:0000A110 var_4           = dword ptr -4
.text$mn:0000A110
.text$mn:0000A110                 push    ebp
.text$mn:0000A111                 mov     ebp, esp
.text$mn:0000A113                 push    ecx
.text$mn:0000A114                 mov     [ebp+var_4], ecx
.text$mn:0000A117                 mov     eax, [ebp+var_4]
.text$mn:0000A11A                 mov     esp, ebp
.text$mn:0000A11C                 pop     ebp
.text$mn:0000A11D                 retn
.text$mn:0000A11D ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:0000A11D
.text$mn:0000A11D ; ---------------------------------------------------------------------------
.text$mn:0000A11E                 align 10h
.text$mn:0000A11E _text$mn        ends
.text$mn:0000A11E
.text$mn:0000A120 ; ===========================================================================
.text$mn:0000A120
.text$mn:0000A120 ; Segment type: Pure code
.text$mn:0000A120 ; Segment permissions: Read/Execute
.text$mn:0000A120 _text$mn        segment para public 'CODE' use32
.text$mn:0000A120                 assume cs:_text$mn
.text$mn:0000A120                 ;org 0A120h
.text$mn:0000A120 ; COMDAT (pick any)
.text$mn:0000A120                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A120
.text$mn:0000A120 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A120
.text$mn:0000A120 ; Attributes: bp-based frame
.text$mn:0000A120
.text$mn:0000A120 ; public: __thiscall std::allocator<int>::allocator<int>(void)
.text$mn:0000A120                 public ??0?$allocator@H@std@@QAE@XZ
.text$mn:0000A120 ??0?$allocator@H@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::_Wrap_alloc<std::allocator<int>>(void)+Ap
.text$mn:0000A120                                         ; std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)+2Bp
.text$mn:0000A120
.text$mn:0000A120 var_4           = dword ptr -4
.text$mn:0000A120
.text$mn:0000A120                 push    ebp
.text$mn:0000A121                 mov     ebp, esp
.text$mn:0000A123                 push    ecx
.text$mn:0000A124                 mov     [ebp+var_4], ecx
.text$mn:0000A127                 mov     eax, [ebp+var_4]
.text$mn:0000A12A                 mov     esp, ebp
.text$mn:0000A12C                 pop     ebp
.text$mn:0000A12D                 retn
.text$mn:0000A12D ??0?$allocator@H@std@@QAE@XZ endp
.text$mn:0000A12D
.text$mn:0000A12D ; ---------------------------------------------------------------------------
.text$mn:0000A12E                 align 10h
.text$mn:0000A12E _text$mn        ends
.text$mn:0000A12E
.text$mn:0000A130 ; ===========================================================================
.text$mn:0000A130
.text$mn:0000A130 ; Segment type: Pure code
.text$mn:0000A130 ; Segment permissions: Read/Execute
.text$mn:0000A130 _text$mn        segment para public 'CODE' use32
.text$mn:0000A130                 assume cs:_text$mn
.text$mn:0000A130                 ;org 0A130h
.text$mn:0000A130 ; COMDAT (pick any)
.text$mn:0000A130                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A130
.text$mn:0000A130 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A130
.text$mn:0000A130 ; Attributes: bp-based frame
.text$mn:0000A130
.text$mn:0000A130 ; public: __thiscall std::allocator<unsigned int>::allocator<unsigned int>(class std::allocator<unsigned int> const &)
.text$mn:0000A130                 public ??0?$allocator@I@std@@QAE@ABV01@@Z
.text$mn:0000A130 ??0?$allocator@I@std@@QAE@ABV01@@Z proc near
.text$mn:0000A130                                         ; CODE XREF: std::operator==<std::allocator<uint>,std::allocator<uint>>(std::_Wrap_alloc<std::allocator<uint>> const &,std::_Wrap_alloc<std::allocator<uint>> const &)+Bp
.text$mn:0000A130                                         ; std::operator==<std::allocator<uint>,std::allocator<uint>>(std::_Wrap_alloc<std::allocator<uint>> const &,std::_Wrap_alloc<std::allocator<uint>> const &)+18p ...
.text$mn:0000A130
.text$mn:0000A130 var_4           = dword ptr -4
.text$mn:0000A130
.text$mn:0000A130                 push    ebp
.text$mn:0000A131                 mov     ebp, esp
.text$mn:0000A133                 push    ecx
.text$mn:0000A134                 mov     [ebp+var_4], ecx
.text$mn:0000A137                 mov     eax, [ebp+var_4]
.text$mn:0000A13A                 mov     esp, ebp
.text$mn:0000A13C                 pop     ebp
.text$mn:0000A13D                 retn    4
.text$mn:0000A13D ??0?$allocator@I@std@@QAE@ABV01@@Z endp
.text$mn:0000A13D
.text$mn:0000A13D _text$mn        ends
.text$mn:0000A13D
.text$mn:0000A140 ; ===========================================================================
.text$mn:0000A140
.text$mn:0000A140 ; Segment type: Pure code
.text$mn:0000A140 ; Segment permissions: Read/Execute
.text$mn:0000A140 _text$mn        segment para public 'CODE' use32
.text$mn:0000A140                 assume cs:_text$mn
.text$mn:0000A140                 ;org 0A140h
.text$mn:0000A140 ; COMDAT (pick any)
.text$mn:0000A140                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A140
.text$mn:0000A140 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A140
.text$mn:0000A140 ; Attributes: bp-based frame
.text$mn:0000A140
.text$mn:0000A140 ; public: __thiscall std::allocator<unsigned int>::allocator<unsigned int>(void)
.text$mn:0000A140                 public ??0?$allocator@I@std@@QAE@XZ
.text$mn:0000A140 ??0?$allocator@I@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::_Wrap_alloc<std::allocator<uint>>(void)+Ap
.text$mn:0000A140                                         ; std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(void)+2Bp
.text$mn:0000A140
.text$mn:0000A140 var_4           = dword ptr -4
.text$mn:0000A140
.text$mn:0000A140                 push    ebp
.text$mn:0000A141                 mov     ebp, esp
.text$mn:0000A143                 push    ecx
.text$mn:0000A144                 mov     [ebp+var_4], ecx
.text$mn:0000A147                 mov     eax, [ebp+var_4]
.text$mn:0000A14A                 mov     esp, ebp
.text$mn:0000A14C                 pop     ebp
.text$mn:0000A14D                 retn
.text$mn:0000A14D ??0?$allocator@I@std@@QAE@XZ endp
.text$mn:0000A14D
.text$mn:0000A14D ; ---------------------------------------------------------------------------
.text$mn:0000A14E                 align 10h
.text$mn:0000A14E _text$mn        ends
.text$mn:0000A14E
.text$mn:0000A150 ; ===========================================================================
.text$mn:0000A150
.text$mn:0000A150 ; Segment type: Pure code
.text$mn:0000A150 ; Segment permissions: Read/Execute
.text$mn:0000A150 _text$mn        segment para public 'CODE' use32
.text$mn:0000A150                 assume cs:_text$mn
.text$mn:0000A150                 ;org 0A150h
.text$mn:0000A150 ; COMDAT (pick any)
.text$mn:0000A150                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A150
.text$mn:0000A150 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A150
.text$mn:0000A150 ; Attributes: bp-based frame
.text$mn:0000A150
.text$mn:0000A150 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:0000A150                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:0000A150 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:0000A150                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:0000A150                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:0000A150
.text$mn:0000A150 var_4           = dword ptr -4
.text$mn:0000A150
.text$mn:0000A150                 push    ebp
.text$mn:0000A151                 mov     ebp, esp
.text$mn:0000A153                 push    ecx
.text$mn:0000A154                 mov     [ebp+var_4], ecx
.text$mn:0000A157                 mov     eax, [ebp+var_4]
.text$mn:0000A15A                 mov     esp, ebp
.text$mn:0000A15C                 pop     ebp
.text$mn:0000A15D                 retn
.text$mn:0000A15D ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:0000A15D
.text$mn:0000A15D ; ---------------------------------------------------------------------------
.text$mn:0000A15E                 align 10h
.text$mn:0000A15E _text$mn        ends
.text$mn:0000A15E
.text$mn:0000A160 ; ===========================================================================
.text$mn:0000A160
.text$mn:0000A160 ; Segment type: Pure code
.text$mn:0000A160 ; Segment permissions: Read/Execute
.text$mn:0000A160 _text$mn        segment para public 'CODE' use32
.text$mn:0000A160                 assume cs:_text$mn
.text$mn:0000A160                 ;org 0A160h
.text$mn:0000A160 ; COMDAT (pick any)
.text$mn:0000A160                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A160
.text$mn:0000A160 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A160
.text$mn:0000A160 ; Attributes: bp-based frame
.text$mn:0000A160
.text$mn:0000A160 ; public: __thiscall std::allocator<struct sessionFileInfo>::allocator<struct sessionFileInfo>(class std::allocator<struct sessionFileInfo> const &)
.text$mn:0000A160                 public ??0?$allocator@UsessionFileInfo@@@std@@QAE@ABV01@@Z
.text$mn:0000A160 ??0?$allocator@UsessionFileInfo@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000A160                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<sessionFileInfo>>::_Wrap_alloc<std::allocator<sessionFileInfo>>(std::allocator<sessionFileInfo> const &)+Ep
.text$mn:0000A160                                         ; std::allocator<sessionFileInfo>::select_on_container_copy_construction(void)+Ep
.text$mn:0000A160
.text$mn:0000A160 var_4           = dword ptr -4
.text$mn:0000A160
.text$mn:0000A160                 push    ebp
.text$mn:0000A161                 mov     ebp, esp
.text$mn:0000A163                 push    ecx
.text$mn:0000A164                 mov     [ebp+var_4], ecx
.text$mn:0000A167                 mov     eax, [ebp+var_4]
.text$mn:0000A16A                 mov     esp, ebp
.text$mn:0000A16C                 pop     ebp
.text$mn:0000A16D                 retn    4
.text$mn:0000A16D ??0?$allocator@UsessionFileInfo@@@std@@QAE@ABV01@@Z endp
.text$mn:0000A16D
.text$mn:0000A16D _text$mn        ends
.text$mn:0000A16D
.text$mn:0000A170 ; ===========================================================================
.text$mn:0000A170
.text$mn:0000A170 ; Segment type: Pure code
.text$mn:0000A170 ; Segment permissions: Read/Execute
.text$mn:0000A170 _text$mn        segment para public 'CODE' use32
.text$mn:0000A170                 assume cs:_text$mn
.text$mn:0000A170                 ;org 0A170h
.text$mn:0000A170 ; COMDAT (pick any)
.text$mn:0000A170                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A170
.text$mn:0000A170 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A170
.text$mn:0000A170 ; Attributes: bp-based frame
.text$mn:0000A170
.text$mn:0000A170 ; public: __thiscall std::allocator<struct sessionFileInfo>::allocator<struct sessionFileInfo>(void)
.text$mn:0000A170                 public ??0?$allocator@UsessionFileInfo@@@std@@QAE@XZ
.text$mn:0000A170 ??0?$allocator@UsessionFileInfo@@@std@@QAE@XZ proc near
.text$mn:0000A170                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<sessionFileInfo>>::_Wrap_alloc<std::allocator<sessionFileInfo>>(void)+Ap
.text$mn:0000A170                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(void)+2Bp
.text$mn:0000A170
.text$mn:0000A170 var_4           = dword ptr -4
.text$mn:0000A170
.text$mn:0000A170                 push    ebp
.text$mn:0000A171                 mov     ebp, esp
.text$mn:0000A173                 push    ecx
.text$mn:0000A174                 mov     [ebp+var_4], ecx
.text$mn:0000A177                 mov     eax, [ebp+var_4]
.text$mn:0000A17A                 mov     esp, ebp
.text$mn:0000A17C                 pop     ebp
.text$mn:0000A17D                 retn
.text$mn:0000A17D ??0?$allocator@UsessionFileInfo@@@std@@QAE@XZ endp
.text$mn:0000A17D
.text$mn:0000A17D ; ---------------------------------------------------------------------------
.text$mn:0000A17E                 align 10h
.text$mn:0000A17E _text$mn        ends
.text$mn:0000A17E
.text$mn:0000A180 ; ===========================================================================
.text$mn:0000A180
.text$mn:0000A180 ; Segment type: Pure code
.text$mn:0000A180 ; Segment permissions: Read/Execute
.text$mn:0000A180 _text$mn        segment para public 'CODE' use32
.text$mn:0000A180                 assume cs:_text$mn
.text$mn:0000A180                 ;org 0A180h
.text$mn:0000A180 ; COMDAT (pick any)
.text$mn:0000A180                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A180
.text$mn:0000A180 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A180
.text$mn:0000A180 ; Attributes: bp-based frame
.text$mn:0000A180
.text$mn:0000A180 ; public: __thiscall std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(void)
.text$mn:0000A180                 public ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ
.text$mn:0000A180 ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ proc near
.text$mn:0000A180                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+Ap
.text$mn:0000A180                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+2Bp
.text$mn:0000A180
.text$mn:0000A180 var_4           = dword ptr -4
.text$mn:0000A180
.text$mn:0000A180                 push    ebp
.text$mn:0000A181                 mov     ebp, esp
.text$mn:0000A183                 push    ecx
.text$mn:0000A184                 mov     [ebp+var_4], ecx
.text$mn:0000A187                 mov     eax, [ebp+var_4]
.text$mn:0000A18A                 mov     esp, ebp
.text$mn:0000A18C                 pop     ebp
.text$mn:0000A18D                 retn
.text$mn:0000A18D ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ endp
.text$mn:0000A18D
.text$mn:0000A18D ; ---------------------------------------------------------------------------
.text$mn:0000A18E                 align 10h
.text$mn:0000A18E _text$mn        ends
.text$mn:0000A18E
.text$mn:0000A190 ; ===========================================================================
.text$mn:0000A190
.text$mn:0000A190 ; Segment type: Pure code
.text$mn:0000A190 ; Segment permissions: Read/Execute
.text$mn:0000A190 _text$mn        segment para public 'CODE' use32
.text$mn:0000A190                 assume cs:_text$mn
.text$mn:0000A190                 ;org 0A190h
.text$mn:0000A190 ; COMDAT (pick any)
.text$mn:0000A190                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A190
.text$mn:0000A190 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A190
.text$mn:0000A190 ; Attributes: bp-based frame
.text$mn:0000A190
.text$mn:0000A190 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(class std::allocator<wchar_t> const &)
.text$mn:0000A190                 public ??0?$allocator@_W@std@@QAE@ABV01@@Z
.text$mn:0000A190 ??0?$allocator@_W@std@@QAE@ABV01@@Z proc near
.text$mn:0000A190                                         ; CODE XREF: std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+Bp
.text$mn:0000A190                                         ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+18p ...
.text$mn:0000A190
.text$mn:0000A190 var_4           = dword ptr -4
.text$mn:0000A190
.text$mn:0000A190                 push    ebp
.text$mn:0000A191                 mov     ebp, esp
.text$mn:0000A193                 push    ecx
.text$mn:0000A194                 mov     [ebp+var_4], ecx
.text$mn:0000A197                 mov     eax, [ebp+var_4]
.text$mn:0000A19A                 mov     esp, ebp
.text$mn:0000A19C                 pop     ebp
.text$mn:0000A19D                 retn    4
.text$mn:0000A19D ??0?$allocator@_W@std@@QAE@ABV01@@Z endp
.text$mn:0000A19D
.text$mn:0000A19D _text$mn        ends
.text$mn:0000A19D
.text$mn:0000A1A0 ; ===========================================================================
.text$mn:0000A1A0
.text$mn:0000A1A0 ; Segment type: Pure code
.text$mn:0000A1A0 ; Segment permissions: Read/Execute
.text$mn:0000A1A0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A1A0                 assume cs:_text$mn
.text$mn:0000A1A0                 ;org 0A1A0h
.text$mn:0000A1A0 ; COMDAT (pick any)
.text$mn:0000A1A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A1A0
.text$mn:0000A1A0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A1A0
.text$mn:0000A1A0 ; Attributes: bp-based frame
.text$mn:0000A1A0
.text$mn:0000A1A0 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:0000A1A0                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:0000A1A0 ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:0000A1A0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+2Bp ...
.text$mn:0000A1A0
.text$mn:0000A1A0 var_4           = dword ptr -4
.text$mn:0000A1A0
.text$mn:0000A1A0                 push    ebp
.text$mn:0000A1A1                 mov     ebp, esp
.text$mn:0000A1A3                 push    ecx
.text$mn:0000A1A4                 mov     [ebp+var_4], ecx
.text$mn:0000A1A7                 mov     eax, [ebp+var_4]
.text$mn:0000A1AA                 mov     esp, ebp
.text$mn:0000A1AC                 pop     ebp
.text$mn:0000A1AD                 retn
.text$mn:0000A1AD ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:0000A1AD
.text$mn:0000A1AD ; ---------------------------------------------------------------------------
.text$mn:0000A1AE                 align 10h
.text$mn:0000A1AE _text$mn        ends
.text$mn:0000A1AE
.text$mn:0000A1B0 ; ===========================================================================
.text$mn:0000A1B0
.text$mn:0000A1B0 ; Segment type: Pure code
.text$mn:0000A1B0 ; Segment permissions: Read/Execute
.text$mn:0000A1B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A1B0                 assume cs:_text$mn
.text$mn:0000A1B0                 ;org 0A1B0h
.text$mn:0000A1B0 ; COMDAT (pick any)
.text$mn:0000A1B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A1B0
.text$mn:0000A1B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A1B0
.text$mn:0000A1B0 ; Attributes: bp-based frame
.text$mn:0000A1B0
.text$mn:0000A1B0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:0000A1B0                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:0000A1B0 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:0000A1B0                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:0000A1B0                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:0000A1B0
.text$mn:0000A1B0 var_14          = dword ptr -14h
.text$mn:0000A1B0 var_D           = byte ptr -0Dh
.text$mn:0000A1B0 var_C           = dword ptr -0Ch
.text$mn:0000A1B0 var_4           = dword ptr -4
.text$mn:0000A1B0 Str             = dword ptr  8
.text$mn:0000A1B0
.text$mn:0000A1B0                 push    ebp
.text$mn:0000A1B1                 mov     ebp, esp
.text$mn:0000A1B3                 push    0FFFFFFFFh
.text$mn:0000A1B5                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:0000A1BA                 mov     eax, large fs:0
.text$mn:0000A1C0                 push    eax
.text$mn:0000A1C1                 sub     esp, 8
.text$mn:0000A1C4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A1C9                 xor     eax, ebp
.text$mn:0000A1CB                 push    eax
.text$mn:0000A1CC                 lea     eax, [ebp+var_C]
.text$mn:0000A1CF                 mov     large fs:0, eax
.text$mn:0000A1D5                 mov     [ebp+var_14], ecx
.text$mn:0000A1D8                 lea     ecx, [ebp+var_D]
.text$mn:0000A1DB                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000A1E0                 push    eax
.text$mn:0000A1E1                 mov     ecx, [ebp+var_14]
.text$mn:0000A1E4                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:0000A1E9                 mov     [ebp+var_4], 0
.text$mn:0000A1F0                 push    0               ; Size
.text$mn:0000A1F2                 push    0               ; char
.text$mn:0000A1F4                 mov     ecx, [ebp+var_14]
.text$mn:0000A1F7                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000A1FC                 mov     eax, [ebp+Str]
.text$mn:0000A1FF                 push    eax             ; Str
.text$mn:0000A200                 mov     ecx, [ebp+var_14]
.text$mn:0000A203                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:0000A208                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A20F                 mov     eax, [ebp+var_14]
.text$mn:0000A212                 mov     ecx, [ebp+var_C]
.text$mn:0000A215                 mov     large fs:0, ecx
.text$mn:0000A21C                 pop     ecx
.text$mn:0000A21D                 mov     esp, ebp
.text$mn:0000A21F                 pop     ebp
.text$mn:0000A220                 retn    4
.text$mn:0000A220 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:0000A220
.text$mn:0000A220 ; ---------------------------------------------------------------------------
.text$mn:0000A223                 align 4
.text$mn:0000A223 _text$mn        ends
.text$mn:0000A223
.text$x:0000A224 ; ===========================================================================
.text$x:0000A224
.text$x:0000A224 ; Segment type: Pure code
.text$x:0000A224 ; Segment permissions: Read/Execute
.text$x:0000A224 _text$x         segment para public 'CODE' use32
.text$x:0000A224                 assume cs:_text$x
.text$x:0000A224                 ;org 0A224h
.text$x:0000A224 ; COMDAT (pick associative to section at A1B0)
.text$x:0000A224                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A224
.text$x:0000A224 ; =============== S U B R O U T I N E =======================================
.text$x:0000A224
.text$x:0000A224
.text$x:0000A224 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:0000A224                                         ; DATA XREF: .xdata$x:000124D8o
.text$x:0000A224                 mov     ecx, [ebp-14h]
.text$x:0000A227                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000A227 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:0000A227
.text$x:0000A22C
.text$x:0000A22C ; =============== S U B R O U T I N E =======================================
.text$x:0000A22C
.text$x:0000A22C
.text$x:0000A22C __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:0000A22C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:0000A22C
.text$x:0000A22C arg_4           = dword ptr  8
.text$x:0000A22C
.text$x:0000A22C                 mov     edx, [esp+arg_4]
.text$x:0000A230                 lea     eax, [edx+0Ch]
.text$x:0000A233                 mov     ecx, [edx-0Ch]
.text$x:0000A236                 xor     ecx, eax
.text$x:0000A238                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A23D                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:0000A242                 jmp     ___CxxFrameHandler3
.text$x:0000A242 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:0000A242
.text$x:0000A242 ; ---------------------------------------------------------------------------
.text$x:0000A247                 align 4
.text$x:0000A247 _text$x         ends
.text$x:0000A247
.text$mn:0000A248 ; ===========================================================================
.text$mn:0000A248
.text$mn:0000A248 ; Segment type: Pure code
.text$mn:0000A248 ; Segment permissions: Read/Execute
.text$mn:0000A248 _text$mn        segment para public 'CODE' use32
.text$mn:0000A248                 assume cs:_text$mn
.text$mn:0000A248                 ;org 0A248h
.text$mn:0000A248 ; COMDAT (pick any)
.text$mn:0000A248                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A248
.text$mn:0000A248 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A248
.text$mn:0000A248 ; Attributes: bp-based frame
.text$mn:0000A248
.text$mn:0000A248 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &&)
.text$mn:0000A248                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.text$mn:0000A248 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z proc near
.text$mn:0000A248                                         ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+27Fp
.text$mn:0000A248                                         ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+56p
.text$mn:0000A248
.text$mn:0000A248 var_14          = dword ptr -14h
.text$mn:0000A248 var_D           = byte ptr -0Dh
.text$mn:0000A248 var_C           = dword ptr -0Ch
.text$mn:0000A248 var_4           = dword ptr -4
.text$mn:0000A248 arg_0           = dword ptr  8
.text$mn:0000A248
.text$mn:0000A248                 push    ebp
.text$mn:0000A249                 mov     ebp, esp
.text$mn:0000A24B                 push    0FFFFFFFFh
.text$mn:0000A24D                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.text$mn:0000A252                 mov     eax, large fs:0
.text$mn:0000A258                 push    eax
.text$mn:0000A259                 sub     esp, 8
.text$mn:0000A25C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A261                 xor     eax, ebp
.text$mn:0000A263                 push    eax
.text$mn:0000A264                 lea     eax, [ebp+var_C]
.text$mn:0000A267                 mov     large fs:0, eax
.text$mn:0000A26D                 mov     [ebp+var_14], ecx
.text$mn:0000A270                 lea     eax, [ebp+var_D]
.text$mn:0000A273                 push    eax
.text$mn:0000A274                 mov     ecx, [ebp+arg_0]
.text$mn:0000A277                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000A27C                 push    eax
.text$mn:0000A27D                 mov     ecx, [ebp+var_14]
.text$mn:0000A280                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:0000A285                 mov     [ebp+var_4], 0
.text$mn:0000A28C                 push    0
.text$mn:0000A28E                 push    0
.text$mn:0000A290                 mov     ecx, [ebp+var_14]
.text$mn:0000A293                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000A298                 mov     ecx, [ebp+arg_0]
.text$mn:0000A29B                 push    ecx
.text$mn:0000A29C                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:0000A2A1                 add     esp, 4
.text$mn:0000A2A4                 push    eax
.text$mn:0000A2A5                 mov     ecx, [ebp+var_14]
.text$mn:0000A2A8                 call    ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:0000A2AD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A2B4                 mov     eax, [ebp+var_14]
.text$mn:0000A2B7                 mov     ecx, [ebp+var_C]
.text$mn:0000A2BA                 mov     large fs:0, ecx
.text$mn:0000A2C1                 pop     ecx
.text$mn:0000A2C2                 mov     esp, ebp
.text$mn:0000A2C4                 pop     ebp
.text$mn:0000A2C5                 retn    4
.text$mn:0000A2C5 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z endp
.text$mn:0000A2C5
.text$mn:0000A2C5 _text$mn        ends
.text$mn:0000A2C5
.text$x:0000A2C8 ; ===========================================================================
.text$x:0000A2C8
.text$x:0000A2C8 ; Segment type: Pure code
.text$x:0000A2C8 ; Segment permissions: Read/Execute
.text$x:0000A2C8 _text$x         segment para public 'CODE' use32
.text$x:0000A2C8                 assume cs:_text$x
.text$x:0000A2C8                 ;org 0A2C8h
.text$x:0000A2C8 ; COMDAT (pick associative to section at A248)
.text$x:0000A2C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A2C8
.text$x:0000A2C8 ; =============== S U B R O U T I N E =======================================
.text$x:0000A2C8
.text$x:0000A2C8
.text$x:0000A2C8 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0 proc near
.text$x:0000A2C8                                         ; DATA XREF: .xdata$x:000128D4o
.text$x:0000A2C8                 mov     ecx, [ebp-14h]
.text$x:0000A2CB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000A2CB __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0 endp
.text$x:0000A2CB
.text$x:0000A2D0
.text$x:0000A2D0 ; =============== S U B R O U T I N E =======================================
.text$x:0000A2D0
.text$x:0000A2D0
.text$x:0000A2D0 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z proc near
.text$x:0000A2D0                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+5o
.text$x:0000A2D0
.text$x:0000A2D0 arg_4           = dword ptr  8
.text$x:0000A2D0
.text$x:0000A2D0                 mov     edx, [esp+arg_4]
.text$x:0000A2D4                 lea     eax, [edx+0Ch]
.text$x:0000A2D7                 mov     ecx, [edx-0Ch]
.text$x:0000A2DA                 xor     ecx, eax
.text$x:0000A2DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A2E1                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.text$x:0000A2E6                 jmp     ___CxxFrameHandler3
.text$x:0000A2E6 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z endp
.text$x:0000A2E6
.text$x:0000A2E6 ; ---------------------------------------------------------------------------
.text$x:0000A2EB                 align 4
.text$x:0000A2EB _text$x         ends
.text$x:0000A2EB
.text$mn:0000A2EC ; ===========================================================================
.text$mn:0000A2EC
.text$mn:0000A2EC ; Segment type: Pure code
.text$mn:0000A2EC ; Segment permissions: Read/Execute
.text$mn:0000A2EC _text$mn        segment para public 'CODE' use32
.text$mn:0000A2EC                 assume cs:_text$mn
.text$mn:0000A2EC                 ;org 0A2ECh
.text$mn:0000A2EC ; COMDAT (pick any)
.text$mn:0000A2EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A2EC
.text$mn:0000A2EC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A2EC
.text$mn:0000A2EC ; Attributes: bp-based frame
.text$mn:0000A2EC
.text$mn:0000A2EC ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:0000A2EC                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:0000A2EC ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$mn:0000A2EC                                         ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+1BCp
.text$mn:0000A2EC                                         ; sessionFileInfo::sessionFileInfo(sessionFileInfo const &)+5Bp ...
.text$mn:0000A2EC
.text$mn:0000A2EC var_14          = dword ptr -14h
.text$mn:0000A2EC var_E           = byte ptr -0Eh
.text$mn:0000A2EC var_D           = byte ptr -0Dh
.text$mn:0000A2EC var_C           = dword ptr -0Ch
.text$mn:0000A2EC var_4           = dword ptr -4
.text$mn:0000A2EC arg_0           = dword ptr  8
.text$mn:0000A2EC
.text$mn:0000A2EC                 push    ebp
.text$mn:0000A2ED                 mov     ebp, esp
.text$mn:0000A2EF                 push    0FFFFFFFFh
.text$mn:0000A2F1                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:0000A2F6                 mov     eax, large fs:0
.text$mn:0000A2FC                 push    eax
.text$mn:0000A2FD                 sub     esp, 8
.text$mn:0000A300                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A305                 xor     eax, ebp
.text$mn:0000A307                 push    eax
.text$mn:0000A308                 lea     eax, [ebp+var_C]
.text$mn:0000A30B                 mov     large fs:0, eax
.text$mn:0000A311                 mov     [ebp+var_14], ecx
.text$mn:0000A314                 lea     eax, [ebp+var_D]
.text$mn:0000A317                 push    eax
.text$mn:0000A318                 lea     ecx, [ebp+var_E]
.text$mn:0000A31B                 push    ecx
.text$mn:0000A31C                 mov     ecx, [ebp+arg_0]
.text$mn:0000A31F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000A324                 mov     ecx, eax
.text$mn:0000A326                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)
.text$mn:0000A32B                 push    eax
.text$mn:0000A32C                 mov     ecx, [ebp+var_14]
.text$mn:0000A32F                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:0000A334                 mov     [ebp+var_4], 0
.text$mn:0000A33B                 push    0
.text$mn:0000A33D                 push    0
.text$mn:0000A33F                 mov     ecx, [ebp+var_14]
.text$mn:0000A342                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000A347                 mov     edx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000A34D                 push    edx
.text$mn:0000A34E                 push    0
.text$mn:0000A350                 mov     eax, [ebp+arg_0]
.text$mn:0000A353                 push    eax
.text$mn:0000A354                 mov     ecx, [ebp+var_14]
.text$mn:0000A357                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000A35C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A363                 mov     eax, [ebp+var_14]
.text$mn:0000A366                 mov     ecx, [ebp+var_C]
.text$mn:0000A369                 mov     large fs:0, ecx
.text$mn:0000A370                 pop     ecx
.text$mn:0000A371                 mov     esp, ebp
.text$mn:0000A373                 pop     ebp
.text$mn:0000A374                 retn    4
.text$mn:0000A374 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$mn:0000A374
.text$mn:0000A374 ; ---------------------------------------------------------------------------
.text$mn:0000A377                 align 4
.text$mn:0000A377 _text$mn        ends
.text$mn:0000A377
.text$x:0000A378 ; ===========================================================================
.text$x:0000A378
.text$x:0000A378 ; Segment type: Pure code
.text$x:0000A378 ; Segment permissions: Read/Execute
.text$x:0000A378 _text$x         segment para public 'CODE' use32
.text$x:0000A378                 assume cs:_text$x
.text$x:0000A378                 ;org 0A378h
.text$x:0000A378 ; COMDAT (pick associative to section at A2EC)
.text$x:0000A378                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A378
.text$x:0000A378 ; =============== S U B R O U T I N E =======================================
.text$x:0000A378
.text$x:0000A378
.text$x:0000A378 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 proc near
.text$x:0000A378                                         ; DATA XREF: .xdata$x:000127F8o
.text$x:0000A378                 mov     ecx, [ebp-14h]
.text$x:0000A37B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000A37B __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000A37B
.text$x:0000A380
.text$x:0000A380 ; =============== S U B R O U T I N E =======================================
.text$x:0000A380
.text$x:0000A380
.text$x:0000A380 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$x:0000A380                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:0000A380
.text$x:0000A380 arg_4           = dword ptr  8
.text$x:0000A380
.text$x:0000A380                 mov     edx, [esp+arg_4]
.text$x:0000A384                 lea     eax, [edx+0Ch]
.text$x:0000A387                 mov     ecx, [edx-0Ch]
.text$x:0000A38A                 xor     ecx, eax
.text$x:0000A38C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A391                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$x:0000A396                 jmp     ___CxxFrameHandler3
.text$x:0000A396 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$x:0000A396
.text$x:0000A396 ; ---------------------------------------------------------------------------
.text$x:0000A39B                 align 4
.text$x:0000A39B _text$x         ends
.text$x:0000A39B
.text$mn:0000A39C ; ===========================================================================
.text$mn:0000A39C
.text$mn:0000A39C ; Segment type: Pure code
.text$mn:0000A39C ; Segment permissions: Read/Execute
.text$mn:0000A39C _text$mn        segment para public 'CODE' use32
.text$mn:0000A39C                 assume cs:_text$mn
.text$mn:0000A39C                 ;org 0A39Ch
.text$mn:0000A39C ; COMDAT (pick any)
.text$mn:0000A39C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A39C
.text$mn:0000A39C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A39C
.text$mn:0000A39C ; Attributes: bp-based frame
.text$mn:0000A39C
.text$mn:0000A39C ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int, class std::allocator<wchar_t> const &)
.text$mn:0000A39C                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z
.text$mn:0000A39C ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z proc near
.text$mn:0000A39C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::substr(uint,uint)+4Bp
.text$mn:0000A39C
.text$mn:0000A39C var_10          = dword ptr -10h
.text$mn:0000A39C var_C           = dword ptr -0Ch
.text$mn:0000A39C var_4           = dword ptr -4
.text$mn:0000A39C arg_0           = dword ptr  8
.text$mn:0000A39C arg_4           = dword ptr  0Ch
.text$mn:0000A39C arg_8           = dword ptr  10h
.text$mn:0000A39C arg_C           = dword ptr  14h
.text$mn:0000A39C
.text$mn:0000A39C                 push    ebp
.text$mn:0000A39D                 mov     ebp, esp
.text$mn:0000A39F                 push    0FFFFFFFFh
.text$mn:0000A3A1                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z
.text$mn:0000A3A6                 mov     eax, large fs:0
.text$mn:0000A3AC                 push    eax
.text$mn:0000A3AD                 push    ecx
.text$mn:0000A3AE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A3B3                 xor     eax, ebp
.text$mn:0000A3B5                 push    eax
.text$mn:0000A3B6                 lea     eax, [ebp+var_C]
.text$mn:0000A3B9                 mov     large fs:0, eax
.text$mn:0000A3BF                 mov     [ebp+var_10], ecx
.text$mn:0000A3C2                 mov     eax, [ebp+arg_C]
.text$mn:0000A3C5                 push    eax
.text$mn:0000A3C6                 mov     ecx, [ebp+var_10]
.text$mn:0000A3C9                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:0000A3CE                 mov     [ebp+var_4], 0
.text$mn:0000A3D5                 push    0
.text$mn:0000A3D7                 push    0
.text$mn:0000A3D9                 mov     ecx, [ebp+var_10]
.text$mn:0000A3DC                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000A3E1                 mov     ecx, [ebp+arg_8]
.text$mn:0000A3E4                 push    ecx
.text$mn:0000A3E5                 mov     edx, [ebp+arg_4]
.text$mn:0000A3E8                 push    edx
.text$mn:0000A3E9                 mov     eax, [ebp+arg_0]
.text$mn:0000A3EC                 push    eax
.text$mn:0000A3ED                 mov     ecx, [ebp+var_10]
.text$mn:0000A3F0                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000A3F5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A3FC                 mov     eax, [ebp+var_10]
.text$mn:0000A3FF                 mov     ecx, [ebp+var_C]
.text$mn:0000A402                 mov     large fs:0, ecx
.text$mn:0000A409                 pop     ecx
.text$mn:0000A40A                 mov     esp, ebp
.text$mn:0000A40C                 pop     ebp
.text$mn:0000A40D                 retn    10h
.text$mn:0000A40D ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z endp
.text$mn:0000A40D
.text$mn:0000A40D _text$mn        ends
.text$mn:0000A40D
.text$x:0000A410 ; ===========================================================================
.text$x:0000A410
.text$x:0000A410 ; Segment type: Pure code
.text$x:0000A410 ; Segment permissions: Read/Execute
.text$x:0000A410 _text$x         segment para public 'CODE' use32
.text$x:0000A410                 assume cs:_text$x
.text$x:0000A410                 ;org 0A410h
.text$x:0000A410 ; COMDAT (pick associative to section at A39C)
.text$x:0000A410                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A410
.text$x:0000A410 ; =============== S U B R O U T I N E =======================================
.text$x:0000A410
.text$x:0000A410
.text$x:0000A410 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z$0 proc near
.text$x:0000A410                                         ; DATA XREF: .xdata$x:00012850o
.text$x:0000A410                 mov     ecx, [ebp-10h]
.text$x:0000A413                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000A413 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z$0 endp
.text$x:0000A413
.text$x:0000A418
.text$x:0000A418 ; =============== S U B R O U T I N E =======================================
.text$x:0000A418
.text$x:0000A418
.text$x:0000A418 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z proc near
.text$x:0000A418                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint,std::allocator<wchar_t> const &)+5o
.text$x:0000A418
.text$x:0000A418 arg_4           = dword ptr  8
.text$x:0000A418
.text$x:0000A418                 mov     edx, [esp+arg_4]
.text$x:0000A41C                 lea     eax, [edx+0Ch]
.text$x:0000A41F                 mov     ecx, [edx-8]
.text$x:0000A422                 xor     ecx, eax
.text$x:0000A424                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A429                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z
.text$x:0000A42E                 jmp     ___CxxFrameHandler3
.text$x:0000A42E __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z endp
.text$x:0000A42E
.text$x:0000A42E ; ---------------------------------------------------------------------------
.text$x:0000A433                 align 4
.text$x:0000A433 _text$x         ends
.text$x:0000A433
.text$mn:0000A434 ; ===========================================================================
.text$mn:0000A434
.text$mn:0000A434 ; Segment type: Pure code
.text$mn:0000A434 ; Segment permissions: Read/Execute
.text$mn:0000A434 _text$mn        segment para public 'CODE' use32
.text$mn:0000A434                 assume cs:_text$mn
.text$mn:0000A434                 ;org 0A434h
.text$mn:0000A434 ; COMDAT (pick any)
.text$mn:0000A434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A434
.text$mn:0000A434 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A434
.text$mn:0000A434 ; Attributes: bp-based frame
.text$mn:0000A434
.text$mn:0000A434 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t *Str)
.text$mn:0000A434                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:0000A434 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$mn:0000A434                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+150p
.text$mn:0000A434                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+3A3p ...
.text$mn:0000A434
.text$mn:0000A434 var_14          = dword ptr -14h
.text$mn:0000A434 var_D           = byte ptr -0Dh
.text$mn:0000A434 var_C           = dword ptr -0Ch
.text$mn:0000A434 var_4           = dword ptr -4
.text$mn:0000A434 Str             = dword ptr  8
.text$mn:0000A434
.text$mn:0000A434                 push    ebp
.text$mn:0000A435                 mov     ebp, esp
.text$mn:0000A437                 push    0FFFFFFFFh
.text$mn:0000A439                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:0000A43E                 mov     eax, large fs:0
.text$mn:0000A444                 push    eax
.text$mn:0000A445                 sub     esp, 8
.text$mn:0000A448                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A44D                 xor     eax, ebp
.text$mn:0000A44F                 push    eax
.text$mn:0000A450                 lea     eax, [ebp+var_C]
.text$mn:0000A453                 mov     large fs:0, eax
.text$mn:0000A459                 mov     [ebp+var_14], ecx
.text$mn:0000A45C                 lea     ecx, [ebp+var_D]
.text$mn:0000A45F                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:0000A464                 push    eax
.text$mn:0000A465                 mov     ecx, [ebp+var_14]
.text$mn:0000A468                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:0000A46D                 mov     [ebp+var_4], 0
.text$mn:0000A474                 push    0
.text$mn:0000A476                 push    0
.text$mn:0000A478                 mov     ecx, [ebp+var_14]
.text$mn:0000A47B                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000A480                 mov     eax, [ebp+Str]
.text$mn:0000A483                 push    eax             ; Str
.text$mn:0000A484                 mov     ecx, [ebp+var_14]
.text$mn:0000A487                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:0000A48C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A493                 mov     eax, [ebp+var_14]
.text$mn:0000A496                 mov     ecx, [ebp+var_C]
.text$mn:0000A499                 mov     large fs:0, ecx
.text$mn:0000A4A0                 pop     ecx
.text$mn:0000A4A1                 mov     esp, ebp
.text$mn:0000A4A3                 pop     ebp
.text$mn:0000A4A4                 retn    4
.text$mn:0000A4A4 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$mn:0000A4A4
.text$mn:0000A4A4 ; ---------------------------------------------------------------------------
.text$mn:0000A4A7                 align 4
.text$mn:0000A4A7 _text$mn        ends
.text$mn:0000A4A7
.text$x:0000A4A8 ; ===========================================================================
.text$x:0000A4A8
.text$x:0000A4A8 ; Segment type: Pure code
.text$x:0000A4A8 ; Segment permissions: Read/Execute
.text$x:0000A4A8 _text$x         segment para public 'CODE' use32
.text$x:0000A4A8                 assume cs:_text$x
.text$x:0000A4A8                 ;org 0A4A8h
.text$x:0000A4A8 ; COMDAT (pick associative to section at A434)
.text$x:0000A4A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A4A8
.text$x:0000A4A8 ; =============== S U B R O U T I N E =======================================
.text$x:0000A4A8
.text$x:0000A4A8
.text$x:0000A4A8 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 proc near
.text$x:0000A4A8                                         ; DATA XREF: .xdata$x:000128A8o
.text$x:0000A4A8                 mov     ecx, [ebp-14h]
.text$x:0000A4AB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000A4AB __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 endp
.text$x:0000A4AB
.text$x:0000A4B0
.text$x:0000A4B0 ; =============== S U B R O U T I N E =======================================
.text$x:0000A4B0
.text$x:0000A4B0
.text$x:0000A4B0 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$x:0000A4B0                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+5o
.text$x:0000A4B0
.text$x:0000A4B0 arg_4           = dword ptr  8
.text$x:0000A4B0
.text$x:0000A4B0                 mov     edx, [esp+arg_4]
.text$x:0000A4B4                 lea     eax, [edx+0Ch]
.text$x:0000A4B7                 mov     ecx, [edx-0Ch]
.text$x:0000A4BA                 xor     ecx, eax
.text$x:0000A4BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A4C1                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$x:0000A4C6                 jmp     ___CxxFrameHandler3
.text$x:0000A4C6 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$x:0000A4C6
.text$x:0000A4C6 ; ---------------------------------------------------------------------------
.text$x:0000A4CB                 align 4
.text$x:0000A4CB _text$x         ends
.text$x:0000A4CB
.text$mn:0000A4CC ; ===========================================================================
.text$mn:0000A4CC
.text$mn:0000A4CC ; Segment type: Pure code
.text$mn:0000A4CC ; Segment permissions: Read/Execute
.text$mn:0000A4CC _text$mn        segment para public 'CODE' use32
.text$mn:0000A4CC                 assume cs:_text$mn
.text$mn:0000A4CC                 ;org 0A4CCh
.text$mn:0000A4CC ; COMDAT (pick any)
.text$mn:0000A4CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A4CC
.text$mn:0000A4CC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A4CC
.text$mn:0000A4CC ; Attributes: bp-based frame
.text$mn:0000A4CC
.text$mn:0000A4CC ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void *Src, int)
.text$mn:0000A4CC                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z
.text$mn:0000A4CC ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z proc near
.text$mn:0000A4CC                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+934p
.text$mn:0000A4CC
.text$mn:0000A4CC var_14          = dword ptr -14h
.text$mn:0000A4CC var_D           = byte ptr -0Dh
.text$mn:0000A4CC var_C           = dword ptr -0Ch
.text$mn:0000A4CC var_4           = dword ptr -4
.text$mn:0000A4CC Src             = dword ptr  8
.text$mn:0000A4CC arg_4           = dword ptr  0Ch
.text$mn:0000A4CC
.text$mn:0000A4CC                 push    ebp
.text$mn:0000A4CD                 mov     ebp, esp
.text$mn:0000A4CF                 push    0FFFFFFFFh
.text$mn:0000A4D1                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z
.text$mn:0000A4D6                 mov     eax, large fs:0
.text$mn:0000A4DC                 push    eax
.text$mn:0000A4DD                 sub     esp, 8
.text$mn:0000A4E0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A4E5                 xor     eax, ebp
.text$mn:0000A4E7                 push    eax
.text$mn:0000A4E8                 lea     eax, [ebp+var_C]
.text$mn:0000A4EB                 mov     large fs:0, eax
.text$mn:0000A4F1                 mov     [ebp+var_14], ecx
.text$mn:0000A4F4                 lea     ecx, [ebp+var_D]
.text$mn:0000A4F7                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:0000A4FC                 push    eax
.text$mn:0000A4FD                 mov     ecx, [ebp+var_14]
.text$mn:0000A500                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:0000A505                 mov     [ebp+var_4], 0
.text$mn:0000A50C                 push    0
.text$mn:0000A50E                 push    0
.text$mn:0000A510                 mov     ecx, [ebp+var_14]
.text$mn:0000A513                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000A518                 mov     eax, [ebp+arg_4]
.text$mn:0000A51B                 push    eax             ; int
.text$mn:0000A51C                 mov     ecx, [ebp+Src]
.text$mn:0000A51F                 push    ecx             ; Src
.text$mn:0000A520                 mov     ecx, [ebp+var_14]
.text$mn:0000A523                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:0000A528                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A52F                 mov     eax, [ebp+var_14]
.text$mn:0000A532                 mov     ecx, [ebp+var_C]
.text$mn:0000A535                 mov     large fs:0, ecx
.text$mn:0000A53C                 pop     ecx
.text$mn:0000A53D                 mov     esp, ebp
.text$mn:0000A53F                 pop     ebp
.text$mn:0000A540                 retn    8
.text$mn:0000A540 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z endp
.text$mn:0000A540
.text$mn:0000A540 ; ---------------------------------------------------------------------------
.text$mn:0000A543                 align 4
.text$mn:0000A543 _text$mn        ends
.text$mn:0000A543
.text$x:0000A544 ; ===========================================================================
.text$x:0000A544
.text$x:0000A544 ; Segment type: Pure code
.text$x:0000A544 ; Segment permissions: Read/Execute
.text$x:0000A544 _text$x         segment para public 'CODE' use32
.text$x:0000A544                 assume cs:_text$x
.text$x:0000A544                 ;org 0A544h
.text$x:0000A544 ; COMDAT (pick associative to section at A4CC)
.text$x:0000A544                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A544
.text$x:0000A544 ; =============== S U B R O U T I N E =======================================
.text$x:0000A544
.text$x:0000A544
.text$x:0000A544 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z$0 proc near
.text$x:0000A544                                         ; DATA XREF: .xdata$x:0001287Co
.text$x:0000A544                 mov     ecx, [ebp-14h]
.text$x:0000A547                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000A547 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z$0 endp
.text$x:0000A547
.text$x:0000A54C
.text$x:0000A54C ; =============== S U B R O U T I N E =======================================
.text$x:0000A54C
.text$x:0000A54C
.text$x:0000A54C __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z proc near
.text$x:0000A54C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *,uint)+5o
.text$x:0000A54C
.text$x:0000A54C arg_4           = dword ptr  8
.text$x:0000A54C
.text$x:0000A54C                 mov     edx, [esp+arg_4]
.text$x:0000A550                 lea     eax, [edx+0Ch]
.text$x:0000A553                 mov     ecx, [edx-0Ch]
.text$x:0000A556                 xor     ecx, eax
.text$x:0000A558                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A55D                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z
.text$x:0000A562                 jmp     ___CxxFrameHandler3
.text$x:0000A562 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z endp
.text$x:0000A562
.text$x:0000A562 ; ---------------------------------------------------------------------------
.text$x:0000A567                 align 4
.text$x:0000A567 _text$x         ends
.text$x:0000A567
.text$mn:0000A568 ; ===========================================================================
.text$mn:0000A568
.text$mn:0000A568 ; Segment type: Pure code
.text$mn:0000A568 ; Segment permissions: Read/Execute
.text$mn:0000A568 _text$mn        segment para public 'CODE' use32
.text$mn:0000A568                 assume cs:_text$mn
.text$mn:0000A568                 ;org 0A568h
.text$mn:0000A568 ; COMDAT (pick any)
.text$mn:0000A568                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A568
.text$mn:0000A568 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A568
.text$mn:0000A568 ; Attributes: bp-based frame
.text$mn:0000A568
.text$mn:0000A568 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:0000A568                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000A568 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:0000A568                                         ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+7Ep
.text$mn:0000A568                                         ; sessionFileInfo::sessionFileInfo(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+4Ep ...
.text$mn:0000A568
.text$mn:0000A568 var_14          = dword ptr -14h
.text$mn:0000A568 var_D           = byte ptr -0Dh
.text$mn:0000A568 var_C           = dword ptr -0Ch
.text$mn:0000A568 var_4           = dword ptr -4
.text$mn:0000A568
.text$mn:0000A568                 push    ebp
.text$mn:0000A569                 mov     ebp, esp
.text$mn:0000A56B                 push    0FFFFFFFFh
.text$mn:0000A56D                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000A572                 mov     eax, large fs:0
.text$mn:0000A578                 push    eax
.text$mn:0000A579                 sub     esp, 8
.text$mn:0000A57C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A581                 xor     eax, ebp
.text$mn:0000A583                 push    eax
.text$mn:0000A584                 lea     eax, [ebp+var_C]
.text$mn:0000A587                 mov     large fs:0, eax
.text$mn:0000A58D                 mov     [ebp+var_14], ecx
.text$mn:0000A590                 lea     ecx, [ebp+var_D]
.text$mn:0000A593                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:0000A598                 push    eax
.text$mn:0000A599                 mov     ecx, [ebp+var_14]
.text$mn:0000A59C                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:0000A5A1                 mov     [ebp+var_4], 0
.text$mn:0000A5A8                 push    0
.text$mn:0000A5AA                 push    0
.text$mn:0000A5AC                 mov     ecx, [ebp+var_14]
.text$mn:0000A5AF                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000A5B4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A5BB                 mov     eax, [ebp+var_14]
.text$mn:0000A5BE                 mov     ecx, [ebp+var_C]
.text$mn:0000A5C1                 mov     large fs:0, ecx
.text$mn:0000A5C8                 pop     ecx
.text$mn:0000A5C9                 mov     esp, ebp
.text$mn:0000A5CB                 pop     ebp
.text$mn:0000A5CC                 retn
.text$mn:0000A5CC ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:0000A5CC
.text$mn:0000A5CC ; ---------------------------------------------------------------------------
.text$mn:0000A5CD                 align 10h
.text$mn:0000A5CD _text$mn        ends
.text$mn:0000A5CD
.text$x:0000A5D0 ; ===========================================================================
.text$x:0000A5D0
.text$x:0000A5D0 ; Segment type: Pure code
.text$x:0000A5D0 ; Segment permissions: Read/Execute
.text$x:0000A5D0 _text$x         segment para public 'CODE' use32
.text$x:0000A5D0                 assume cs:_text$x
.text$x:0000A5D0                 ;org 0A5D0h
.text$x:0000A5D0 ; COMDAT (pick associative to section at A568)
.text$x:0000A5D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A5D0
.text$x:0000A5D0 ; =============== S U B R O U T I N E =======================================
.text$x:0000A5D0
.text$x:0000A5D0
.text$x:0000A5D0 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:0000A5D0                                         ; DATA XREF: .xdata$x:00012824o
.text$x:0000A5D0                 mov     ecx, [ebp-14h]
.text$x:0000A5D3                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000A5D3 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:0000A5D3
.text$x:0000A5D8
.text$x:0000A5D8 ; =============== S U B R O U T I N E =======================================
.text$x:0000A5D8
.text$x:0000A5D8
.text$x:0000A5D8 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:0000A5D8                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:0000A5D8
.text$x:0000A5D8 arg_4           = dword ptr  8
.text$x:0000A5D8
.text$x:0000A5D8                 mov     edx, [esp+arg_4]
.text$x:0000A5DC                 lea     eax, [edx+0Ch]
.text$x:0000A5DF                 mov     ecx, [edx-0Ch]
.text$x:0000A5E2                 xor     ecx, eax
.text$x:0000A5E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A5E9                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:0000A5EE                 jmp     ___CxxFrameHandler3
.text$x:0000A5EE __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:0000A5EE
.text$x:0000A5EE ; ---------------------------------------------------------------------------
.text$x:0000A5F3                 align 4
.text$x:0000A5F3 _text$x         ends
.text$x:0000A5F3
.text$mn:0000A5F4 ; ===========================================================================
.text$mn:0000A5F4
.text$mn:0000A5F4 ; Segment type: Pure code
.text$mn:0000A5F4 ; Segment permissions: Read/Execute
.text$mn:0000A5F4 _text$mn        segment para public 'CODE' use32
.text$mn:0000A5F4                 assume cs:_text$mn
.text$mn:0000A5F4                 ;org 0A5F4h
.text$mn:0000A5F4 ; COMDAT (pick any)
.text$mn:0000A5F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A5F4
.text$mn:0000A5F4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A5F4
.text$mn:0000A5F4 ; Attributes: bp-based frame
.text$mn:0000A5F4
.text$mn:0000A5F4 ; public: __thiscall std::vector<int, class std::allocator<int>>::vector<int, class std::allocator<int>>(void)
.text$mn:0000A5F4                 public ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$mn:0000A5F4 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ proc near
.text$mn:0000A5F4                                         ; CODE XREF: Notepad_plus::fileCloseAllToLeft(void)+2Bp
.text$mn:0000A5F4                                         ; Notepad_plus::fileCloseAllToRight(void)+3Cp
.text$mn:0000A5F4
.text$mn:0000A5F4 var_14          = dword ptr -14h
.text$mn:0000A5F4 var_D           = byte ptr -0Dh
.text$mn:0000A5F4 var_C           = dword ptr -0Ch
.text$mn:0000A5F4 var_4           = dword ptr -4
.text$mn:0000A5F4
.text$mn:0000A5F4                 push    ebp
.text$mn:0000A5F5                 mov     ebp, esp
.text$mn:0000A5F7                 push    0FFFFFFFFh
.text$mn:0000A5F9                 push    offset __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$mn:0000A5FE                 mov     eax, large fs:0
.text$mn:0000A604                 push    eax
.text$mn:0000A605                 sub     esp, 8
.text$mn:0000A608                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A60D                 xor     eax, ebp
.text$mn:0000A60F                 push    eax
.text$mn:0000A610                 lea     eax, [ebp+var_C]
.text$mn:0000A613                 mov     large fs:0, eax
.text$mn:0000A619                 mov     [ebp+var_14], ecx
.text$mn:0000A61C                 lea     ecx, [ebp+var_D]
.text$mn:0000A61F                 call    ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>(void)
.text$mn:0000A624                 push    eax
.text$mn:0000A625                 mov     ecx, [ebp+var_14]
.text$mn:0000A628                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(std::allocator<int> const &)
.text$mn:0000A62D                 mov     [ebp+var_4], 0
.text$mn:0000A634                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A63B                 mov     eax, [ebp+var_14]
.text$mn:0000A63E                 mov     ecx, [ebp+var_C]
.text$mn:0000A641                 mov     large fs:0, ecx
.text$mn:0000A648                 pop     ecx
.text$mn:0000A649                 mov     esp, ebp
.text$mn:0000A64B                 pop     ebp
.text$mn:0000A64C                 retn
.text$mn:0000A64C ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ endp
.text$mn:0000A64C
.text$mn:0000A64C ; ---------------------------------------------------------------------------
.text$mn:0000A64D                 align 10h
.text$mn:0000A64D _text$mn        ends
.text$mn:0000A64D
.text$x:0000A650 ; ===========================================================================
.text$x:0000A650
.text$x:0000A650 ; Segment type: Pure code
.text$x:0000A650 ; Segment permissions: Read/Execute
.text$x:0000A650 _text$x         segment para public 'CODE' use32
.text$x:0000A650                 assume cs:_text$x
.text$x:0000A650                 ;org 0A650h
.text$x:0000A650 ; COMDAT (pick associative to section at A5F4)
.text$x:0000A650                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A650
.text$x:0000A650 ; =============== S U B R O U T I N E =======================================
.text$x:0000A650
.text$x:0000A650
.text$x:0000A650 __unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0 proc near
.text$x:0000A650                                         ; DATA XREF: .xdata$x:00012BE8o
.text$x:0000A650                 mov     ecx, [ebp-14h]
.text$x:0000A653                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)
.text$x:0000A653 __unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0 endp
.text$x:0000A653
.text$x:0000A658
.text$x:0000A658 ; =============== S U B R O U T I N E =======================================
.text$x:0000A658
.text$x:0000A658
.text$x:0000A658 __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ proc near
.text$x:0000A658                                         ; DATA XREF: std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)+5o
.text$x:0000A658
.text$x:0000A658 arg_4           = dword ptr  8
.text$x:0000A658
.text$x:0000A658                 mov     edx, [esp+arg_4]
.text$x:0000A65C                 lea     eax, [edx+0Ch]
.text$x:0000A65F                 mov     ecx, [edx-0Ch]
.text$x:0000A662                 xor     ecx, eax
.text$x:0000A664                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A669                 mov     eax, offset __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$x:0000A66E                 jmp     ___CxxFrameHandler3
.text$x:0000A66E __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ endp
.text$x:0000A66E
.text$x:0000A66E ; ---------------------------------------------------------------------------
.text$x:0000A673                 align 4
.text$x:0000A673 _text$x         ends
.text$x:0000A673
.text$mn:0000A674 ; ===========================================================================
.text$mn:0000A674
.text$mn:0000A674 ; Segment type: Pure code
.text$mn:0000A674 ; Segment permissions: Read/Execute
.text$mn:0000A674 _text$mn        segment para public 'CODE' use32
.text$mn:0000A674                 assume cs:_text$mn
.text$mn:0000A674                 ;org 0A674h
.text$mn:0000A674 ; COMDAT (pick any)
.text$mn:0000A674                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A674
.text$mn:0000A674 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A674
.text$mn:0000A674 ; Attributes: bp-based frame
.text$mn:0000A674
.text$mn:0000A674 ; public: __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::vector<unsigned int, class std::allocator<unsigned int>>(class std::vector<unsigned int, class std::allocator<unsigned int>> const &)
.text$mn:0000A674                 public ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
.text$mn:0000A674 ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000A674                                         ; CODE XREF: sessionFileInfo::sessionFileInfo(sessionFileInfo const &)+8Ap
.text$mn:0000A674                                         ; sessionFileInfo::sessionFileInfo(sessionFileInfo const &)+A0p
.text$mn:0000A674
.text$mn:0000A674 var_34          = dword ptr -34h
.text$mn:0000A674 var_30          = dword ptr -30h
.text$mn:0000A674 var_2C          = dword ptr -2Ch
.text$mn:0000A674 var_28          = dword ptr -28h
.text$mn:0000A674 var_24          = dword ptr -24h
.text$mn:0000A674 var_20          = dword ptr -20h
.text$mn:0000A674 var_1C          = dword ptr -1Ch
.text$mn:0000A674 var_18          = dword ptr -18h
.text$mn:0000A674 var_12          = byte ptr -12h
.text$mn:0000A674 var_11          = byte ptr -11h
.text$mn:0000A674 var_10          = dword ptr -10h
.text$mn:0000A674 var_C           = dword ptr -0Ch
.text$mn:0000A674 var_4           = dword ptr -4
.text$mn:0000A674 arg_0           = dword ptr  8
.text$mn:0000A674
.text$mn:0000A674 ; FUNCTION CHUNK AT .text$mn:0000A75E SIZE 00000009 BYTES
.text$mn:0000A674 ; FUNCTION CHUNK AT .text$mn:0000A76E SIZE 0000001E BYTES
.text$mn:0000A674
.text$mn:0000A674                 push    ebp
.text$mn:0000A675                 mov     ebp, esp
.text$mn:0000A677                 push    0FFFFFFFFh
.text$mn:0000A679                 push    offset __ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
.text$mn:0000A67E                 mov     eax, large fs:0
.text$mn:0000A684                 push    eax
.text$mn:0000A685                 push    ecx
.text$mn:0000A686                 sub     esp, 24h
.text$mn:0000A689                 push    ebx
.text$mn:0000A68A                 push    esi
.text$mn:0000A68B                 push    edi
.text$mn:0000A68C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A691                 xor     eax, ebp
.text$mn:0000A693                 push    eax
.text$mn:0000A694                 lea     eax, [ebp+var_C]
.text$mn:0000A697                 mov     large fs:0, eax
.text$mn:0000A69D                 mov     [ebp+var_10], esp
.text$mn:0000A6A0                 mov     [ebp+var_18], ecx
.text$mn:0000A6A3                 lea     eax, [ebp+var_11]
.text$mn:0000A6A6                 push    eax
.text$mn:0000A6A7                 lea     ecx, [ebp+var_12]
.text$mn:0000A6AA                 push    ecx
.text$mn:0000A6AB                 mov     ecx, [ebp+arg_0]
.text$mn:0000A6AE                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000A6B3                 mov     ecx, eax
.text$mn:0000A6B5                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<uint>>::select_on_container_copy_construction(void)
.text$mn:0000A6BA                 push    eax
.text$mn:0000A6BB                 mov     ecx, [ebp+var_18]
.text$mn:0000A6BE                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(std::allocator<uint> const &)
.text$mn:0000A6C3                 mov     [ebp+var_4], 0
.text$mn:0000A6CA                 mov     ecx, [ebp+arg_0]
.text$mn:0000A6CD                 call    ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<uint,std::allocator<uint>>::size(void)
.text$mn:0000A6D2                 push    eax
.text$mn:0000A6D3                 mov     ecx, [ebp+var_18]
.text$mn:0000A6D6                 call    ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<uint,std::allocator<uint>>::_Buy(uint)
.text$mn:0000A6DB                 movzx   edx, al
.text$mn:0000A6DE                 test    edx, edx
.text$mn:0000A6E0                 jz      loc_A76E
.text$mn:0000A6E6                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000A6EA                 mov     eax, [ebp+var_18]
.text$mn:0000A6ED                 mov     ecx, [eax+4]
.text$mn:0000A6F0                 push    ecx
.text$mn:0000A6F1                 sub     esp, 0Ch
.text$mn:0000A6F4                 mov     edx, esp
.text$mn:0000A6F6                 mov     [ebp+var_28], esp
.text$mn:0000A6F9                 push    edx
.text$mn:0000A6FA                 mov     ecx, [ebp+arg_0]
.text$mn:0000A6FD                 call    ?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<uint,std::allocator<uint>>::end(void)
.text$mn:0000A702                 mov     [ebp+var_1C], eax
.text$mn:0000A705                 mov     eax, [ebp+var_1C]
.text$mn:0000A708                 mov     [ebp+var_2C], eax
.text$mn:0000A70B                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000A70F                 sub     esp, 0Ch
.text$mn:0000A712                 mov     ecx, esp
.text$mn:0000A714                 mov     [ebp+var_30], esp
.text$mn:0000A717                 push    ecx
.text$mn:0000A718                 mov     ecx, [ebp+arg_0]
.text$mn:0000A71B                 call    ?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<uint,std::allocator<uint>>::begin(void)
.text$mn:0000A720                 mov     [ebp+var_20], eax
.text$mn:0000A723                 mov     edx, [ebp+var_20]
.text$mn:0000A726                 mov     [ebp+var_34], edx
.text$mn:0000A729                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000A72D                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000A731                 mov     ecx, [ebp+var_18]
.text$mn:0000A734                 call    ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z ; std::vector<uint,std::allocator<uint>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *)
.text$mn:0000A739                 mov     [ebp+var_24], eax
.text$mn:0000A73C                 mov     eax, [ebp+var_18]
.text$mn:0000A73F                 mov     ecx, [ebp+var_24]
.text$mn:0000A742                 mov     [eax+8], ecx
.text$mn:0000A745                 jmp     short loc_A75E
.text$mn:0000A745 ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z endp
.text$mn:0000A745
.text$mn:0000A747
.text$mn:0000A747 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A747
.text$mn:0000A747 ; Attributes: noreturn
.text$mn:0000A747
.text$mn:0000A747 __catch$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$mn:0000A747                                         ; DATA XREF: .xdata$x:00012E54o
.text$mn:0000A747                 mov     ecx, [ebp-18h]
.text$mn:0000A74A                 call    ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<uint,std::allocator<uint>>::_Tidy(void)
.text$mn:0000A74F                 push    0
.text$mn:0000A751                 push    0
.text$mn:0000A753                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000A753 __catch$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$0 endp
.text$mn:0000A753
.text$mn:0000A758 ; ---------------------------------------------------------------------------
.text$mn:0000A758                 mov     eax, offset $LN11
.text$mn:0000A75D                 retn
.text$mn:0000A75E ; ---------------------------------------------------------------------------
.text$mn:0000A75E ; START OF FUNCTION CHUNK FOR ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
.text$mn:0000A75E
.text$mn:0000A75E loc_A75E:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(std::vector<uint,std::allocator<uint>> const &)+D1j
.text$mn:0000A75E                 mov     [ebp+var_4], 0
.text$mn:0000A765                 jmp     short loc_A76E
.text$mn:0000A765 ; END OF FUNCTION CHUNK FOR ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
.text$mn:0000A767
.text$mn:0000A767 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A767
.text$mn:0000A767
.text$mn:0000A767 $LN11           proc near               ; DATA XREF: .text$mn:0000A758o
.text$mn:0000A767                 mov     dword ptr [ebp-4], 0
.text$mn:0000A767 $LN11           endp ; sp-analysis failed
.text$mn:0000A767
.text$mn:0000A76E ; START OF FUNCTION CHUNK FOR ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
.text$mn:0000A76E
.text$mn:0000A76E loc_A76E:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(std::vector<uint,std::allocator<uint>> const &)+6Cj
.text$mn:0000A76E                                         ; std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(std::vector<uint,std::allocator<uint>> const &)+F1j
.text$mn:0000A76E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A775                 mov     eax, [ebp+var_18]
.text$mn:0000A778                 mov     ecx, [ebp+var_C]
.text$mn:0000A77B                 mov     large fs:0, ecx
.text$mn:0000A782                 pop     ecx
.text$mn:0000A783                 pop     edi
.text$mn:0000A784                 pop     esi
.text$mn:0000A785                 pop     ebx
.text$mn:0000A786                 mov     esp, ebp
.text$mn:0000A788                 pop     ebp
.text$mn:0000A789                 retn    4
.text$mn:0000A789 ; END OF FUNCTION CHUNK FOR ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
.text$mn:0000A789 _text$mn        ends
.text$mn:0000A789
.text$x:0000A78C ; ===========================================================================
.text$x:0000A78C
.text$x:0000A78C ; Segment type: Pure code
.text$x:0000A78C ; Segment permissions: Read/Execute
.text$x:0000A78C _text$x         segment para public 'CODE' use32
.text$x:0000A78C                 assume cs:_text$x
.text$x:0000A78C                 ;org 0A78Ch
.text$x:0000A78C ; COMDAT (pick associative to section at A674)
.text$x:0000A78C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A78C
.text$x:0000A78C ; =============== S U B R O U T I N E =======================================
.text$x:0000A78C
.text$x:0000A78C
.text$x:0000A78C __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$2 proc near
.text$x:0000A78C                                         ; DATA XREF: .xdata$x:00012E94o
.text$x:0000A78C                 mov     ecx, [ebp-18h]
.text$x:0000A78F                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::~_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(void)
.text$x:0000A78F __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$2 endp
.text$x:0000A78F
.text$x:0000A794
.text$x:0000A794 ; =============== S U B R O U T I N E =======================================
.text$x:0000A794
.text$x:0000A794
.text$x:0000A794 __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$3 proc near
.text$x:0000A794                                         ; DATA XREF: .xdata$x:00012EA4o
.text$x:0000A794                 mov     ecx, [ebp-28h]
.text$x:0000A797                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$x:0000A797 __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$3 endp
.text$x:0000A797
.text$x:0000A79C
.text$x:0000A79C ; =============== S U B R O U T I N E =======================================
.text$x:0000A79C
.text$x:0000A79C
.text$x:0000A79C __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$4 proc near
.text$x:0000A79C                                         ; DATA XREF: .xdata$x:00012EACo
.text$x:0000A79C                 mov     ecx, [ebp-30h]
.text$x:0000A79F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$x:0000A79F __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$4 endp
.text$x:0000A79F
.text$x:0000A7A4
.text$x:0000A7A4 ; =============== S U B R O U T I N E =======================================
.text$x:0000A7A4
.text$x:0000A7A4
.text$x:0000A7A4 __ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z proc near
.text$x:0000A7A4                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(std::vector<uint,std::allocator<uint>> const &)+5o
.text$x:0000A7A4
.text$x:0000A7A4 arg_4           = dword ptr  8
.text$x:0000A7A4
.text$x:0000A7A4                 mov     edx, [esp+arg_4]
.text$x:0000A7A8                 lea     eax, [edx+0Ch]
.text$x:0000A7AB                 mov     ecx, [edx-38h]
.text$x:0000A7AE                 xor     ecx, eax
.text$x:0000A7B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A7B5                 mov     eax, offset __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
.text$x:0000A7BA                 jmp     ___CxxFrameHandler3
.text$x:0000A7BA __ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000A7BA
.text$x:0000A7BA ; ---------------------------------------------------------------------------
.text$x:0000A7BF                 align 10h
.text$x:0000A7BF _text$x         ends
.text$x:0000A7BF
.text$mn:0000A7C0 ; ===========================================================================
.text$mn:0000A7C0
.text$mn:0000A7C0 ; Segment type: Pure code
.text$mn:0000A7C0 ; Segment permissions: Read/Execute
.text$mn:0000A7C0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A7C0                 assume cs:_text$mn
.text$mn:0000A7C0                 ;org 0A7C0h
.text$mn:0000A7C0 ; COMDAT (pick any)
.text$mn:0000A7C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A7C0
.text$mn:0000A7C0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A7C0
.text$mn:0000A7C0 ; Attributes: bp-based frame
.text$mn:0000A7C0
.text$mn:0000A7C0 ; public: __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::vector<unsigned int, class std::allocator<unsigned int>>(void)
.text$mn:0000A7C0                 public ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.text$mn:0000A7C0 ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ proc near
.text$mn:0000A7C0                                         ; CODE XREF: sessionFileInfo::sessionFileInfo(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+5Dp
.text$mn:0000A7C0                                         ; sessionFileInfo::sessionFileInfo(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+6Cp
.text$mn:0000A7C0
.text$mn:0000A7C0 var_14          = dword ptr -14h
.text$mn:0000A7C0 var_D           = byte ptr -0Dh
.text$mn:0000A7C0 var_C           = dword ptr -0Ch
.text$mn:0000A7C0 var_4           = dword ptr -4
.text$mn:0000A7C0
.text$mn:0000A7C0                 push    ebp
.text$mn:0000A7C1                 mov     ebp, esp
.text$mn:0000A7C3                 push    0FFFFFFFFh
.text$mn:0000A7C5                 push    offset __ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.text$mn:0000A7CA                 mov     eax, large fs:0
.text$mn:0000A7D0                 push    eax
.text$mn:0000A7D1                 sub     esp, 8
.text$mn:0000A7D4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A7D9                 xor     eax, ebp
.text$mn:0000A7DB                 push    eax
.text$mn:0000A7DC                 lea     eax, [ebp+var_C]
.text$mn:0000A7DF                 mov     large fs:0, eax
.text$mn:0000A7E5                 mov     [ebp+var_14], ecx
.text$mn:0000A7E8                 lea     ecx, [ebp+var_D]
.text$mn:0000A7EB                 call    ??0?$allocator@I@std@@QAE@XZ ; std::allocator<uint>::allocator<uint>(void)
.text$mn:0000A7F0                 push    eax
.text$mn:0000A7F1                 mov     ecx, [ebp+var_14]
.text$mn:0000A7F4                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(std::allocator<uint> const &)
.text$mn:0000A7F9                 mov     [ebp+var_4], 0
.text$mn:0000A800                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A807                 mov     eax, [ebp+var_14]
.text$mn:0000A80A                 mov     ecx, [ebp+var_C]
.text$mn:0000A80D                 mov     large fs:0, ecx
.text$mn:0000A814                 pop     ecx
.text$mn:0000A815                 mov     esp, ebp
.text$mn:0000A817                 pop     ebp
.text$mn:0000A818                 retn
.text$mn:0000A818 ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ endp
.text$mn:0000A818
.text$mn:0000A818 ; ---------------------------------------------------------------------------
.text$mn:0000A819                 align 4
.text$mn:0000A819 _text$mn        ends
.text$mn:0000A819
.text$x:0000A81C ; ===========================================================================
.text$x:0000A81C
.text$x:0000A81C ; Segment type: Pure code
.text$x:0000A81C ; Segment permissions: Read/Execute
.text$x:0000A81C _text$x         segment para public 'CODE' use32
.text$x:0000A81C                 assume cs:_text$x
.text$x:0000A81C                 ;org 0A81Ch
.text$x:0000A81C ; COMDAT (pick associative to section at A7C0)
.text$x:0000A81C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A81C
.text$x:0000A81C ; =============== S U B R O U T I N E =======================================
.text$x:0000A81C
.text$x:0000A81C
.text$x:0000A81C __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0 proc near
.text$x:0000A81C                                         ; DATA XREF: .xdata$x:00012E20o
.text$x:0000A81C                 mov     ecx, [ebp-14h]
.text$x:0000A81F                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::~_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(void)
.text$x:0000A81F __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0 endp
.text$x:0000A81F
.text$x:0000A824
.text$x:0000A824 ; =============== S U B R O U T I N E =======================================
.text$x:0000A824
.text$x:0000A824
.text$x:0000A824 __ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ proc near
.text$x:0000A824                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(void)+5o
.text$x:0000A824
.text$x:0000A824 arg_4           = dword ptr  8
.text$x:0000A824
.text$x:0000A824                 mov     edx, [esp+arg_4]
.text$x:0000A828                 lea     eax, [edx+0Ch]
.text$x:0000A82B                 mov     ecx, [edx-0Ch]
.text$x:0000A82E                 xor     ecx, eax
.text$x:0000A830                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A835                 mov     eax, offset __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.text$x:0000A83A                 jmp     ___CxxFrameHandler3
.text$x:0000A83A __ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ endp
.text$x:0000A83A
.text$x:0000A83A ; ---------------------------------------------------------------------------
.text$x:0000A83F                 align 10h
.text$x:0000A83F _text$x         ends
.text$x:0000A83F
.text$mn:0000A840 ; ===========================================================================
.text$mn:0000A840
.text$mn:0000A840 ; Segment type: Pure code
.text$mn:0000A840 ; Segment permissions: Read/Execute
.text$mn:0000A840 _text$mn        segment para public 'CODE' use32
.text$mn:0000A840                 assume cs:_text$mn
.text$mn:0000A840                 ;org 0A840h
.text$mn:0000A840 ; COMDAT (pick any)
.text$mn:0000A840                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A840
.text$mn:0000A840 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A840
.text$mn:0000A840 ; Attributes: bp-based frame
.text$mn:0000A840
.text$mn:0000A840 ; public: __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>(class std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>> const &)
.text$mn:0000A840                 public ??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000A840 ??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000A840                                         ; CODE XREF: Session::Session(Session const &)+55p
.text$mn:0000A840                                         ; Session::Session(Session const &)+6Ep
.text$mn:0000A840
.text$mn:0000A840 var_34          = dword ptr -34h
.text$mn:0000A840 var_30          = dword ptr -30h
.text$mn:0000A840 var_2C          = dword ptr -2Ch
.text$mn:0000A840 var_28          = dword ptr -28h
.text$mn:0000A840 var_24          = dword ptr -24h
.text$mn:0000A840 var_20          = dword ptr -20h
.text$mn:0000A840 var_1C          = dword ptr -1Ch
.text$mn:0000A840 var_18          = dword ptr -18h
.text$mn:0000A840 var_12          = byte ptr -12h
.text$mn:0000A840 var_11          = byte ptr -11h
.text$mn:0000A840 var_10          = dword ptr -10h
.text$mn:0000A840 var_C           = dword ptr -0Ch
.text$mn:0000A840 var_4           = dword ptr -4
.text$mn:0000A840 arg_0           = dword ptr  8
.text$mn:0000A840
.text$mn:0000A840 ; FUNCTION CHUNK AT .text$mn:0000A92A SIZE 00000009 BYTES
.text$mn:0000A840 ; FUNCTION CHUNK AT .text$mn:0000A93A SIZE 0000001E BYTES
.text$mn:0000A840
.text$mn:0000A840                 push    ebp
.text$mn:0000A841                 mov     ebp, esp
.text$mn:0000A843                 push    0FFFFFFFFh
.text$mn:0000A845                 push    offset __ehhandler$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000A84A                 mov     eax, large fs:0
.text$mn:0000A850                 push    eax
.text$mn:0000A851                 push    ecx
.text$mn:0000A852                 sub     esp, 24h
.text$mn:0000A855                 push    ebx
.text$mn:0000A856                 push    esi
.text$mn:0000A857                 push    edi
.text$mn:0000A858                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A85D                 xor     eax, ebp
.text$mn:0000A85F                 push    eax
.text$mn:0000A860                 lea     eax, [ebp+var_C]
.text$mn:0000A863                 mov     large fs:0, eax
.text$mn:0000A869                 mov     [ebp+var_10], esp
.text$mn:0000A86C                 mov     [ebp+var_18], ecx
.text$mn:0000A86F                 lea     eax, [ebp+var_11]
.text$mn:0000A872                 push    eax
.text$mn:0000A873                 lea     ecx, [ebp+var_12]
.text$mn:0000A876                 push    ecx
.text$mn:0000A877                 mov     ecx, [ebp+arg_0]
.text$mn:0000A87A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Getal(void)
.text$mn:0000A87F                 mov     ecx, eax
.text$mn:0000A881                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::select_on_container_copy_construction(void)
.text$mn:0000A886                 push    eax
.text$mn:0000A887                 mov     ecx, [ebp+var_18]
.text$mn:0000A88A                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>(std::allocator<sessionFileInfo> const &)
.text$mn:0000A88F                 mov     [ebp+var_4], 0
.text$mn:0000A896                 mov     ecx, [ebp+arg_0]
.text$mn:0000A899                 call    ?size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::size(void)
.text$mn:0000A89E                 push    eax
.text$mn:0000A89F                 mov     ecx, [ebp+var_18]
.text$mn:0000A8A2                 call    ?_Buy@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAE_NI@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Buy(uint)
.text$mn:0000A8A7                 movzx   edx, al
.text$mn:0000A8AA                 test    edx, edx
.text$mn:0000A8AC                 jz      loc_A93A
.text$mn:0000A8B2                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000A8B6                 mov     eax, [ebp+var_18]
.text$mn:0000A8B9                 mov     ecx, [eax+4]
.text$mn:0000A8BC                 push    ecx
.text$mn:0000A8BD                 sub     esp, 0Ch
.text$mn:0000A8C0                 mov     edx, esp
.text$mn:0000A8C2                 mov     [ebp+var_28], esp
.text$mn:0000A8C5                 push    edx
.text$mn:0000A8C6                 mov     ecx, [ebp+arg_0]
.text$mn:0000A8C9                 call    ?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::end(void)
.text$mn:0000A8CE                 mov     [ebp+var_1C], eax
.text$mn:0000A8D1                 mov     eax, [ebp+var_1C]
.text$mn:0000A8D4                 mov     [ebp+var_2C], eax
.text$mn:0000A8D7                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000A8DB                 sub     esp, 0Ch
.text$mn:0000A8DE                 mov     ecx, esp
.text$mn:0000A8E0                 mov     [ebp+var_30], esp
.text$mn:0000A8E3                 push    ecx
.text$mn:0000A8E4                 mov     ecx, [ebp+arg_0]
.text$mn:0000A8E7                 call    ?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::begin(void)
.text$mn:0000A8EC                 mov     [ebp+var_20], eax
.text$mn:0000A8EF                 mov     edx, [ebp+var_20]
.text$mn:0000A8F2                 mov     [ebp+var_34], edx
.text$mn:0000A8F5                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000A8F9                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000A8FD                 mov     ecx, [ebp+var_18]
.text$mn:0000A900                 call    ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *)
.text$mn:0000A905                 mov     [ebp+var_24], eax
.text$mn:0000A908                 mov     eax, [ebp+var_18]
.text$mn:0000A90B                 mov     ecx, [ebp+var_24]
.text$mn:0000A90E                 mov     [eax+8], ecx
.text$mn:0000A911                 jmp     short loc_A92A
.text$mn:0000A911 ??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:0000A911
.text$mn:0000A913
.text$mn:0000A913 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A913
.text$mn:0000A913 ; Attributes: noreturn
.text$mn:0000A913
.text$mn:0000A913 __catch$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$mn:0000A913                                         ; DATA XREF: .xdata$x:00013140o
.text$mn:0000A913                 mov     ecx, [ebp-18h]
.text$mn:0000A916                 call    ?_Tidy@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Tidy(void)
.text$mn:0000A91B                 push    0
.text$mn:0000A91D                 push    0
.text$mn:0000A91F                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000A91F __catch$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$mn:0000A91F
.text$mn:0000A924 ; ---------------------------------------------------------------------------
.text$mn:0000A924                 mov     eax, offset $LN11_0
.text$mn:0000A929                 retn
.text$mn:0000A92A ; ---------------------------------------------------------------------------
.text$mn:0000A92A ; START OF FUNCTION CHUNK FOR ??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000A92A
.text$mn:0000A92A loc_A92A:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(std::vector<sessionFileInfo,std::allocator<sessionFileInfo>> const &)+D1j
.text$mn:0000A92A                 mov     [ebp+var_4], 0
.text$mn:0000A931                 jmp     short loc_A93A
.text$mn:0000A931 ; END OF FUNCTION CHUNK FOR ??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000A933
.text$mn:0000A933 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A933
.text$mn:0000A933
.text$mn:0000A933 $LN11_0         proc near               ; DATA XREF: .text$mn:0000A924o
.text$mn:0000A933                 mov     dword ptr [ebp-4], 0
.text$mn:0000A933 $LN11_0         endp ; sp-analysis failed
.text$mn:0000A933
.text$mn:0000A93A ; START OF FUNCTION CHUNK FOR ??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000A93A
.text$mn:0000A93A loc_A93A:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(std::vector<sessionFileInfo,std::allocator<sessionFileInfo>> const &)+6Cj
.text$mn:0000A93A                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(std::vector<sessionFileInfo,std::allocator<sessionFileInfo>> const &)+F1j
.text$mn:0000A93A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A941                 mov     eax, [ebp+var_18]
.text$mn:0000A944                 mov     ecx, [ebp+var_C]
.text$mn:0000A947                 mov     large fs:0, ecx
.text$mn:0000A94E                 pop     ecx
.text$mn:0000A94F                 pop     edi
.text$mn:0000A950                 pop     esi
.text$mn:0000A951                 pop     ebx
.text$mn:0000A952                 mov     esp, ebp
.text$mn:0000A954                 pop     ebp
.text$mn:0000A955                 retn    4
.text$mn:0000A955 ; END OF FUNCTION CHUNK FOR ??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000A955 _text$mn        ends
.text$mn:0000A955
.text$x:0000A958 ; ===========================================================================
.text$x:0000A958
.text$x:0000A958 ; Segment type: Pure code
.text$x:0000A958 ; Segment permissions: Read/Execute
.text$x:0000A958 _text$x         segment para public 'CODE' use32
.text$x:0000A958                 assume cs:_text$x
.text$x:0000A958                 ;org 0A958h
.text$x:0000A958 ; COMDAT (pick associative to section at A840)
.text$x:0000A958                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A958
.text$x:0000A958 ; =============== S U B R O U T I N E =======================================
.text$x:0000A958
.text$x:0000A958
.text$x:0000A958 __unwindfunclet$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$2 proc near
.text$x:0000A958                                         ; DATA XREF: .xdata$x:00013180o
.text$x:0000A958                 mov     ecx, [ebp-18h]
.text$x:0000A95B                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>(void)
.text$x:0000A95B __unwindfunclet$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$2 endp
.text$x:0000A95B
.text$x:0000A960
.text$x:0000A960 ; =============== S U B R O U T I N E =======================================
.text$x:0000A960
.text$x:0000A960
.text$x:0000A960 __unwindfunclet$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$3 proc near
.text$x:0000A960                                         ; DATA XREF: .xdata$x:00013190o
.text$x:0000A960                 mov     ecx, [ebp-28h]
.text$x:0000A963                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:0000A963 __unwindfunclet$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$3 endp
.text$x:0000A963
.text$x:0000A968
.text$x:0000A968 ; =============== S U B R O U T I N E =======================================
.text$x:0000A968
.text$x:0000A968
.text$x:0000A968 __unwindfunclet$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$4 proc near
.text$x:0000A968                                         ; DATA XREF: .xdata$x:00013198o
.text$x:0000A968                 mov     ecx, [ebp-30h]
.text$x:0000A96B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:0000A96B __unwindfunclet$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$4 endp
.text$x:0000A96B
.text$x:0000A970
.text$x:0000A970 ; =============== S U B R O U T I N E =======================================
.text$x:0000A970
.text$x:0000A970
.text$x:0000A970 __ehhandler$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:0000A970                                         ; DATA XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(std::vector<sessionFileInfo,std::allocator<sessionFileInfo>> const &)+5o
.text$x:0000A970
.text$x:0000A970 arg_4           = dword ptr  8
.text$x:0000A970
.text$x:0000A970                 mov     edx, [esp+arg_4]
.text$x:0000A974                 lea     eax, [edx+0Ch]
.text$x:0000A977                 mov     ecx, [edx-38h]
.text$x:0000A97A                 xor     ecx, eax
.text$x:0000A97C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A981                 mov     eax, offset __ehfuncinfo$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000A986                 jmp     ___CxxFrameHandler3
.text$x:0000A986 __ehhandler$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000A986
.text$x:0000A986 ; ---------------------------------------------------------------------------
.text$x:0000A98B                 align 4
.text$x:0000A98B _text$x         ends
.text$x:0000A98B
.text$mn:0000A98C ; ===========================================================================
.text$mn:0000A98C
.text$mn:0000A98C ; Segment type: Pure code
.text$mn:0000A98C ; Segment permissions: Read/Execute
.text$mn:0000A98C _text$mn        segment para public 'CODE' use32
.text$mn:0000A98C                 assume cs:_text$mn
.text$mn:0000A98C                 ;org 0A98Ch
.text$mn:0000A98C ; COMDAT (pick any)
.text$mn:0000A98C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A98C
.text$mn:0000A98C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A98C
.text$mn:0000A98C ; Attributes: bp-based frame
.text$mn:0000A98C
.text$mn:0000A98C ; public: __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>(void)
.text$mn:0000A98C                 public ??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ
.text$mn:0000A98C ??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ proc near
.text$mn:0000A98C                                         ; CODE XREF: Session::Session(void)+2Cp
.text$mn:0000A98C                                         ; Session::Session(void)+3Ep
.text$mn:0000A98C
.text$mn:0000A98C var_14          = dword ptr -14h
.text$mn:0000A98C var_D           = byte ptr -0Dh
.text$mn:0000A98C var_C           = dword ptr -0Ch
.text$mn:0000A98C var_4           = dword ptr -4
.text$mn:0000A98C
.text$mn:0000A98C                 push    ebp
.text$mn:0000A98D                 mov     ebp, esp
.text$mn:0000A98F                 push    0FFFFFFFFh
.text$mn:0000A991                 push    offset __ehhandler$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ
.text$mn:0000A996                 mov     eax, large fs:0
.text$mn:0000A99C                 push    eax
.text$mn:0000A99D                 sub     esp, 8
.text$mn:0000A9A0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A9A5                 xor     eax, ebp
.text$mn:0000A9A7                 push    eax
.text$mn:0000A9A8                 lea     eax, [ebp+var_C]
.text$mn:0000A9AB                 mov     large fs:0, eax
.text$mn:0000A9B1                 mov     [ebp+var_14], ecx
.text$mn:0000A9B4                 lea     ecx, [ebp+var_D]
.text$mn:0000A9B7                 call    ??0?$allocator@UsessionFileInfo@@@std@@QAE@XZ ; std::allocator<sessionFileInfo>::allocator<sessionFileInfo>(void)
.text$mn:0000A9BC                 push    eax
.text$mn:0000A9BD                 mov     ecx, [ebp+var_14]
.text$mn:0000A9C0                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>(std::allocator<sessionFileInfo> const &)
.text$mn:0000A9C5                 mov     [ebp+var_4], 0
.text$mn:0000A9CC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A9D3                 mov     eax, [ebp+var_14]
.text$mn:0000A9D6                 mov     ecx, [ebp+var_C]
.text$mn:0000A9D9                 mov     large fs:0, ecx
.text$mn:0000A9E0                 pop     ecx
.text$mn:0000A9E1                 mov     esp, ebp
.text$mn:0000A9E3                 pop     ebp
.text$mn:0000A9E4                 retn
.text$mn:0000A9E4 ??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ endp
.text$mn:0000A9E4
.text$mn:0000A9E4 ; ---------------------------------------------------------------------------
.text$mn:0000A9E5                 align 4
.text$mn:0000A9E5 _text$mn        ends
.text$mn:0000A9E5
.text$x:0000A9E8 ; ===========================================================================
.text$x:0000A9E8
.text$x:0000A9E8 ; Segment type: Pure code
.text$x:0000A9E8 ; Segment permissions: Read/Execute
.text$x:0000A9E8 _text$x         segment para public 'CODE' use32
.text$x:0000A9E8                 assume cs:_text$x
.text$x:0000A9E8                 ;org 0A9E8h
.text$x:0000A9E8 ; COMDAT (pick associative to section at A98C)
.text$x:0000A9E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A9E8
.text$x:0000A9E8 ; =============== S U B R O U T I N E =======================================
.text$x:0000A9E8
.text$x:0000A9E8
.text$x:0000A9E8 __unwindfunclet$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000A9E8                                         ; DATA XREF: .xdata$x:0001310Co
.text$x:0000A9E8                 mov     ecx, [ebp-14h]
.text$x:0000A9EB                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>(void)
.text$x:0000A9EB __unwindfunclet$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000A9EB
.text$x:0000A9F0
.text$x:0000A9F0 ; =============== S U B R O U T I N E =======================================
.text$x:0000A9F0
.text$x:0000A9F0
.text$x:0000A9F0 __ehhandler$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ proc near
.text$x:0000A9F0                                         ; DATA XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(void)+5o
.text$x:0000A9F0
.text$x:0000A9F0 arg_4           = dword ptr  8
.text$x:0000A9F0
.text$x:0000A9F0                 mov     edx, [esp+arg_4]
.text$x:0000A9F4                 lea     eax, [edx+0Ch]
.text$x:0000A9F7                 mov     ecx, [edx-0Ch]
.text$x:0000A9FA                 xor     ecx, eax
.text$x:0000A9FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AA01                 mov     eax, offset __ehfuncinfo$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ
.text$x:0000AA06                 jmp     ___CxxFrameHandler3
.text$x:0000AA06 __ehhandler$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ endp
.text$x:0000AA06
.text$x:0000AA06 ; ---------------------------------------------------------------------------
.text$x:0000AA0B                 align 4
.text$x:0000AA0B _text$x         ends
.text$x:0000AA0B
.text$mn:0000AA0C ; ===========================================================================
.text$mn:0000AA0C
.text$mn:0000AA0C ; Segment type: Pure code
.text$mn:0000AA0C ; Segment permissions: Read/Execute
.text$mn:0000AA0C _text$mn        segment para public 'CODE' use32
.text$mn:0000AA0C                 assume cs:_text$mn
.text$mn:0000AA0C                 ;org 0AA0Ch
.text$mn:0000AA0C ; COMDAT (pick any)
.text$mn:0000AA0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AA0C
.text$mn:0000AA0C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA0C
.text$mn:0000AA0C ; Attributes: bp-based frame
.text$mn:0000AA0C
.text$mn:0000AA0C ; public: __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(void)
.text$mn:0000AA0C                 public ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$mn:0000AA0C ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ proc near
.text$mn:0000AA0C                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+89Ap
.text$mn:0000AA0C                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+8A9p
.text$mn:0000AA0C
.text$mn:0000AA0C var_14          = dword ptr -14h
.text$mn:0000AA0C var_D           = byte ptr -0Dh
.text$mn:0000AA0C var_C           = dword ptr -0Ch
.text$mn:0000AA0C var_4           = dword ptr -4
.text$mn:0000AA0C
.text$mn:0000AA0C                 push    ebp
.text$mn:0000AA0D                 mov     ebp, esp
.text$mn:0000AA0F                 push    0FFFFFFFFh
.text$mn:0000AA11                 push    offset __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$mn:0000AA16                 mov     eax, large fs:0
.text$mn:0000AA1C                 push    eax
.text$mn:0000AA1D                 sub     esp, 8
.text$mn:0000AA20                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000AA25                 xor     eax, ebp
.text$mn:0000AA27                 push    eax
.text$mn:0000AA28                 lea     eax, [ebp+var_C]
.text$mn:0000AA2B                 mov     large fs:0, eax
.text$mn:0000AA31                 mov     [ebp+var_14], ecx
.text$mn:0000AA34                 lea     ecx, [ebp+var_D]
.text$mn:0000AA37                 call    ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(void)
.text$mn:0000AA3C                 push    eax
.text$mn:0000AA3D                 mov     ecx, [ebp+var_14]
.text$mn:0000AA40                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)
.text$mn:0000AA45                 mov     [ebp+var_4], 0
.text$mn:0000AA4C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000AA53                 mov     eax, [ebp+var_14]
.text$mn:0000AA56                 mov     ecx, [ebp+var_C]
.text$mn:0000AA59                 mov     large fs:0, ecx
.text$mn:0000AA60                 pop     ecx
.text$mn:0000AA61                 mov     esp, ebp
.text$mn:0000AA63                 pop     ebp
.text$mn:0000AA64                 retn
.text$mn:0000AA64 ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ endp
.text$mn:0000AA64
.text$mn:0000AA64 ; ---------------------------------------------------------------------------
.text$mn:0000AA65                 align 4
.text$mn:0000AA65 _text$mn        ends
.text$mn:0000AA65
.text$x:0000AA68 ; ===========================================================================
.text$x:0000AA68
.text$x:0000AA68 ; Segment type: Pure code
.text$x:0000AA68 ; Segment permissions: Read/Execute
.text$x:0000AA68 _text$x         segment para public 'CODE' use32
.text$x:0000AA68                 assume cs:_text$x
.text$x:0000AA68                 ;org 0AA68h
.text$x:0000AA68 ; COMDAT (pick associative to section at AA0C)
.text$x:0000AA68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000AA68
.text$x:0000AA68 ; =============== S U B R O U T I N E =======================================
.text$x:0000AA68
.text$x:0000AA68
.text$x:0000AA68 __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0 proc near
.text$x:0000AA68                                         ; DATA XREF: .xdata$x:00013498o
.text$x:0000AA68                 mov     ecx, [ebp-14h]
.text$x:0000AA6B                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)
.text$x:0000AA6B __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0 endp
.text$x:0000AA6B
.text$x:0000AA70
.text$x:0000AA70 ; =============== S U B R O U T I N E =======================================
.text$x:0000AA70
.text$x:0000AA70
.text$x:0000AA70 __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ proc near
.text$x:0000AA70                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+5o
.text$x:0000AA70
.text$x:0000AA70 arg_4           = dword ptr  8
.text$x:0000AA70
.text$x:0000AA70                 mov     edx, [esp+arg_4]
.text$x:0000AA74                 lea     eax, [edx+0Ch]
.text$x:0000AA77                 mov     ecx, [edx-0Ch]
.text$x:0000AA7A                 xor     ecx, eax
.text$x:0000AA7C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AA81                 mov     eax, offset __ehfuncinfo$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$x:0000AA86                 jmp     ___CxxFrameHandler3
.text$x:0000AA86 __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ endp
.text$x:0000AA86
.text$x:0000AA86 ; ---------------------------------------------------------------------------
.text$x:0000AA8B                 align 4
.text$x:0000AA8B _text$x         ends
.text$x:0000AA8B
.text$mn:0000AA8C ; ===========================================================================
.text$mn:0000AA8C
.text$mn:0000AA8C ; Segment type: Pure code
.text$mn:0000AA8C ; Segment permissions: Read/Execute
.text$mn:0000AA8C _text$mn        segment para public 'CODE' use32
.text$mn:0000AA8C                 assume cs:_text$mn
.text$mn:0000AA8C                 ;org 0AA8Ch
.text$mn:0000AA8C ; COMDAT (pick any)
.text$mn:0000AA8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AA8C
.text$mn:0000AA8C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA8C
.text$mn:0000AA8C ; Attributes: bp-based frame
.text$mn:0000AA8C
.text$mn:0000AA8C ; public: __thiscall Position::Position(void)
.text$mn:0000AA8C                 public ??0Position@@QAE@XZ
.text$mn:0000AA8C ??0Position@@QAE@XZ proc near           ; CODE XREF: sessionFileInfo::sessionFileInfo(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+30p
.text$mn:0000AA8C
.text$mn:0000AA8C var_4           = dword ptr -4
.text$mn:0000AA8C
.text$mn:0000AA8C                 push    ebp
.text$mn:0000AA8D                 mov     ebp, esp
.text$mn:0000AA8F                 push    ecx
.text$mn:0000AA90                 mov     [ebp+var_4], ecx
.text$mn:0000AA93                 mov     eax, [ebp+var_4]
.text$mn:0000AA96                 mov     dword ptr [eax], 0
.text$mn:0000AA9C                 mov     ecx, [ebp+var_4]
.text$mn:0000AA9F                 mov     dword ptr [ecx+4], 0
.text$mn:0000AAA6                 mov     edx, [ebp+var_4]
.text$mn:0000AAA9                 mov     dword ptr [edx+8], 0
.text$mn:0000AAB0                 mov     eax, [ebp+var_4]
.text$mn:0000AAB3                 mov     dword ptr [eax+0Ch], 0
.text$mn:0000AABA                 mov     ecx, [ebp+var_4]
.text$mn:0000AABD                 mov     dword ptr [ecx+10h], 0
.text$mn:0000AAC4                 mov     edx, [ebp+var_4]
.text$mn:0000AAC7                 mov     dword ptr [edx+14h], 1
.text$mn:0000AACE                 mov     eax, [ebp+var_4]
.text$mn:0000AAD1                 mov     esp, ebp
.text$mn:0000AAD3                 pop     ebp
.text$mn:0000AAD4                 retn
.text$mn:0000AAD4 ??0Position@@QAE@XZ endp
.text$mn:0000AAD4
.text$mn:0000AAD4 ; ---------------------------------------------------------------------------
.text$mn:0000AAD5                 align 4
.text$mn:0000AAD5 _text$mn        ends
.text$mn:0000AAD5
.text$mn:0000AAD8 ; ===========================================================================
.text$mn:0000AAD8
.text$mn:0000AAD8 ; Segment type: Pure code
.text$mn:0000AAD8 ; Segment permissions: Read/Execute
.text$mn:0000AAD8 _text$mn        segment para public 'CODE' use32
.text$mn:0000AAD8                 assume cs:_text$mn
.text$mn:0000AAD8                 ;org 0AAD8h
.text$mn:0000AAD8 ; COMDAT (pick any)
.text$mn:0000AAD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AAD8
.text$mn:0000AAD8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AAD8
.text$mn:0000AAD8 ; Attributes: bp-based frame
.text$mn:0000AAD8
.text$mn:0000AAD8 ; public: __thiscall Session::Session(struct Session const &)
.text$mn:0000AAD8                 public ??0Session@@QAE@ABU0@@Z
.text$mn:0000AAD8 ??0Session@@QAE@ABU0@@Z proc near       ; CODE XREF: Notepad_plus::loadLastSession(void)+47p
.text$mn:0000AAD8
.text$mn:0000AAD8 var_10          = dword ptr -10h
.text$mn:0000AAD8 var_C           = dword ptr -0Ch
.text$mn:0000AAD8 var_4           = dword ptr -4
.text$mn:0000AAD8 arg_0           = dword ptr  8
.text$mn:0000AAD8
.text$mn:0000AAD8                 push    ebp
.text$mn:0000AAD9                 mov     ebp, esp
.text$mn:0000AADB                 push    0FFFFFFFFh
.text$mn:0000AADD                 push    offset __ehhandler$??0Session@@QAE@ABU0@@Z
.text$mn:0000AAE2                 mov     eax, large fs:0
.text$mn:0000AAE8                 push    eax
.text$mn:0000AAE9                 push    ecx
.text$mn:0000AAEA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000AAEF                 xor     eax, ebp
.text$mn:0000AAF1                 push    eax
.text$mn:0000AAF2                 lea     eax, [ebp+var_C]
.text$mn:0000AAF5                 mov     large fs:0, eax
.text$mn:0000AAFB                 mov     [ebp+var_10], ecx
.text$mn:0000AAFE                 mov     eax, [ebp+var_10]
.text$mn:0000AB01                 mov     ecx, [ebp+arg_0]
.text$mn:0000AB04                 mov     edx, [ecx]
.text$mn:0000AB06                 mov     [eax], edx
.text$mn:0000AB08                 mov     eax, [ebp+var_10]
.text$mn:0000AB0B                 mov     ecx, [ebp+arg_0]
.text$mn:0000AB0E                 mov     edx, [ecx+4]
.text$mn:0000AB11                 mov     [eax+4], edx
.text$mn:0000AB14                 mov     eax, [ebp+var_10]
.text$mn:0000AB17                 mov     ecx, [ebp+arg_0]
.text$mn:0000AB1A                 mov     edx, [ecx+8]
.text$mn:0000AB1D                 mov     [eax+8], edx
.text$mn:0000AB20                 mov     eax, [ebp+arg_0]
.text$mn:0000AB23                 add     eax, 0Ch
.text$mn:0000AB26                 push    eax
.text$mn:0000AB27                 mov     ecx, [ebp+var_10]
.text$mn:0000AB2A                 add     ecx, 0Ch
.text$mn:0000AB2D                 call    ??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(std::vector<sessionFileInfo,std::allocator<sessionFileInfo>> const &)
.text$mn:0000AB32                 mov     [ebp+var_4], 0
.text$mn:0000AB39                 mov     ecx, [ebp+arg_0]
.text$mn:0000AB3C                 add     ecx, 1Ch
.text$mn:0000AB3F                 push    ecx
.text$mn:0000AB40                 mov     ecx, [ebp+var_10]
.text$mn:0000AB43                 add     ecx, 1Ch
.text$mn:0000AB46                 call    ??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(std::vector<sessionFileInfo,std::allocator<sessionFileInfo>> const &)
.text$mn:0000AB4B                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000AB4F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000AB56                 mov     eax, [ebp+var_10]
.text$mn:0000AB59                 mov     ecx, [ebp+var_C]
.text$mn:0000AB5C                 mov     large fs:0, ecx
.text$mn:0000AB63                 pop     ecx
.text$mn:0000AB64                 mov     esp, ebp
.text$mn:0000AB66                 pop     ebp
.text$mn:0000AB67                 retn    4
.text$mn:0000AB67 ??0Session@@QAE@ABU0@@Z endp
.text$mn:0000AB67
.text$mn:0000AB67 ; ---------------------------------------------------------------------------
.text$mn:0000AB6A                 align 4
.text$mn:0000AB6A _text$mn        ends
.text$mn:0000AB6A
.text$x:0000AB6C ; ===========================================================================
.text$x:0000AB6C
.text$x:0000AB6C ; Segment type: Pure code
.text$x:0000AB6C ; Segment permissions: Read/Execute
.text$x:0000AB6C _text$x         segment para public 'CODE' use32
.text$x:0000AB6C                 assume cs:_text$x
.text$x:0000AB6C                 ;org 0AB6Ch
.text$x:0000AB6C ; COMDAT (pick associative to section at AAD8)
.text$x:0000AB6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000AB6C
.text$x:0000AB6C ; =============== S U B R O U T I N E =======================================
.text$x:0000AB6C
.text$x:0000AB6C
.text$x:0000AB6C __unwindfunclet$??0Session@@QAE@ABU0@@Z$0 proc near
.text$x:0000AB6C                                         ; DATA XREF: .xdata$x:000133B4o
.text$x:0000AB6C                 mov     ecx, [ebp-10h]
.text$x:0000AB6F                 add     ecx, 0Ch
.text$x:0000AB72                 jmp     ??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::~vector<sessionFileInfo,std::allocator<sessionFileInfo>>(void)
.text$x:0000AB72 __unwindfunclet$??0Session@@QAE@ABU0@@Z$0 endp
.text$x:0000AB72
.text$x:0000AB77
.text$x:0000AB77 ; =============== S U B R O U T I N E =======================================
.text$x:0000AB77
.text$x:0000AB77
.text$x:0000AB77 __unwindfunclet$??0Session@@QAE@ABU0@@Z$1 proc near
.text$x:0000AB77                                         ; DATA XREF: .xdata$x:000133BCo
.text$x:0000AB77                 mov     ecx, [ebp-10h]
.text$x:0000AB7A                 add     ecx, 1Ch
.text$x:0000AB7D                 jmp     ??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::~vector<sessionFileInfo,std::allocator<sessionFileInfo>>(void)
.text$x:0000AB7D __unwindfunclet$??0Session@@QAE@ABU0@@Z$1 endp
.text$x:0000AB7D
.text$x:0000AB82
.text$x:0000AB82 ; =============== S U B R O U T I N E =======================================
.text$x:0000AB82
.text$x:0000AB82
.text$x:0000AB82 __ehhandler$??0Session@@QAE@ABU0@@Z proc near
.text$x:0000AB82                                         ; DATA XREF: Session::Session(Session const &)+5o
.text$x:0000AB82
.text$x:0000AB82 arg_4           = dword ptr  8
.text$x:0000AB82
.text$x:0000AB82                 mov     edx, [esp+arg_4]
.text$x:0000AB86                 lea     eax, [edx+0Ch]
.text$x:0000AB89                 mov     ecx, [edx-8]
.text$x:0000AB8C                 xor     ecx, eax
.text$x:0000AB8E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AB93                 mov     eax, offset __ehfuncinfo$??0Session@@QAE@ABU0@@Z
.text$x:0000AB98                 jmp     ___CxxFrameHandler3
.text$x:0000AB98 __ehhandler$??0Session@@QAE@ABU0@@Z endp
.text$x:0000AB98
.text$x:0000AB98 ; ---------------------------------------------------------------------------
.text$x:0000AB9D                 align 10h
.text$x:0000AB9D _text$x         ends
.text$x:0000AB9D
.text$mn:0000ABA0 ; ===========================================================================
.text$mn:0000ABA0
.text$mn:0000ABA0 ; Segment type: Pure code
.text$mn:0000ABA0 ; Segment permissions: Read/Execute
.text$mn:0000ABA0 _text$mn        segment para public 'CODE' use32
.text$mn:0000ABA0                 assume cs:_text$mn
.text$mn:0000ABA0                 ;org 0ABA0h
.text$mn:0000ABA0 ; COMDAT (pick any)
.text$mn:0000ABA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000ABA0
.text$mn:0000ABA0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ABA0
.text$mn:0000ABA0 ; Attributes: bp-based frame
.text$mn:0000ABA0
.text$mn:0000ABA0 ; public: __thiscall Session::Session(void)
.text$mn:0000ABA0                 public ??0Session@@QAE@XZ
.text$mn:0000ABA0 ??0Session@@QAE@XZ proc near            ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+377p
.text$mn:0000ABA0                                         ; Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *)+41p
.text$mn:0000ABA0
.text$mn:0000ABA0 var_10          = dword ptr -10h
.text$mn:0000ABA0 var_C           = dword ptr -0Ch
.text$mn:0000ABA0 var_4           = dword ptr -4
.text$mn:0000ABA0
.text$mn:0000ABA0                 push    ebp
.text$mn:0000ABA1                 mov     ebp, esp
.text$mn:0000ABA3                 push    0FFFFFFFFh
.text$mn:0000ABA5                 push    offset __ehhandler$??0Session@@QAE@XZ
.text$mn:0000ABAA                 mov     eax, large fs:0
.text$mn:0000ABB0                 push    eax
.text$mn:0000ABB1                 push    ecx
.text$mn:0000ABB2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000ABB7                 xor     eax, ebp
.text$mn:0000ABB9                 push    eax
.text$mn:0000ABBA                 lea     eax, [ebp+var_C]
.text$mn:0000ABBD                 mov     large fs:0, eax
.text$mn:0000ABC3                 mov     [ebp+var_10], ecx
.text$mn:0000ABC6                 mov     ecx, [ebp+var_10]
.text$mn:0000ABC9                 add     ecx, 0Ch
.text$mn:0000ABCC                 call    ??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(void)
.text$mn:0000ABD1                 mov     [ebp+var_4], 0
.text$mn:0000ABD8                 mov     ecx, [ebp+var_10]
.text$mn:0000ABDB                 add     ecx, 1Ch
.text$mn:0000ABDE                 call    ??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(void)
.text$mn:0000ABE3                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000ABE7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000ABEE                 mov     eax, [ebp+var_10]
.text$mn:0000ABF1                 mov     ecx, [ebp+var_C]
.text$mn:0000ABF4                 mov     large fs:0, ecx
.text$mn:0000ABFB                 pop     ecx
.text$mn:0000ABFC                 mov     esp, ebp
.text$mn:0000ABFE                 pop     ebp
.text$mn:0000ABFF                 retn
.text$mn:0000ABFF ??0Session@@QAE@XZ endp
.text$mn:0000ABFF
.text$mn:0000ABFF _text$mn        ends
.text$mn:0000ABFF
.text$x:0000AC00 ; ===========================================================================
.text$x:0000AC00
.text$x:0000AC00 ; Segment type: Pure code
.text$x:0000AC00 ; Segment permissions: Read/Execute
.text$x:0000AC00 _text$x         segment para public 'CODE' use32
.text$x:0000AC00                 assume cs:_text$x
.text$x:0000AC00                 ;org 0AC00h
.text$x:0000AC00 ; COMDAT (pick associative to section at ABA0)
.text$x:0000AC00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000AC00
.text$x:0000AC00 ; =============== S U B R O U T I N E =======================================
.text$x:0000AC00
.text$x:0000AC00
.text$x:0000AC00 __unwindfunclet$??0Session@@QAE@XZ$0 proc near
.text$x:0000AC00                                         ; DATA XREF: .xdata$x:0001334Co
.text$x:0000AC00                 mov     ecx, [ebp-10h]
.text$x:0000AC03                 add     ecx, 0Ch
.text$x:0000AC06                 jmp     ??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::~vector<sessionFileInfo,std::allocator<sessionFileInfo>>(void)
.text$x:0000AC06 __unwindfunclet$??0Session@@QAE@XZ$0 endp
.text$x:0000AC06
.text$x:0000AC0B
.text$x:0000AC0B ; =============== S U B R O U T I N E =======================================
.text$x:0000AC0B
.text$x:0000AC0B
.text$x:0000AC0B __unwindfunclet$??0Session@@QAE@XZ$1 proc near
.text$x:0000AC0B                                         ; DATA XREF: .xdata$x:00013354o
.text$x:0000AC0B                 mov     ecx, [ebp-10h]
.text$x:0000AC0E                 add     ecx, 1Ch
.text$x:0000AC11                 jmp     ??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::~vector<sessionFileInfo,std::allocator<sessionFileInfo>>(void)
.text$x:0000AC11 __unwindfunclet$??0Session@@QAE@XZ$1 endp
.text$x:0000AC11
.text$x:0000AC16
.text$x:0000AC16 ; =============== S U B R O U T I N E =======================================
.text$x:0000AC16
.text$x:0000AC16
.text$x:0000AC16 __ehhandler$??0Session@@QAE@XZ proc near
.text$x:0000AC16                                         ; DATA XREF: Session::Session(void)+5o
.text$x:0000AC16
.text$x:0000AC16 arg_4           = dword ptr  8
.text$x:0000AC16
.text$x:0000AC16                 mov     edx, [esp+arg_4]
.text$x:0000AC1A                 lea     eax, [edx+0Ch]
.text$x:0000AC1D                 mov     ecx, [edx-8]
.text$x:0000AC20                 xor     ecx, eax
.text$x:0000AC22                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AC27                 mov     eax, offset __ehfuncinfo$??0Session@@QAE@XZ
.text$x:0000AC2C                 jmp     ___CxxFrameHandler3
.text$x:0000AC2C __ehhandler$??0Session@@QAE@XZ endp
.text$x:0000AC2C
.text$x:0000AC2C ; ---------------------------------------------------------------------------
.text$x:0000AC31                 align 4
.text$x:0000AC31 _text$x         ends
.text$x:0000AC31
.text$mn:0000AC34 ; ===========================================================================
.text$mn:0000AC34
.text$mn:0000AC34 ; Segment type: Pure code
.text$mn:0000AC34 ; Segment permissions: Read/Execute
.text$mn:0000AC34 _text$mn        segment para public 'CODE' use32
.text$mn:0000AC34                 assume cs:_text$mn
.text$mn:0000AC34                 ;org 0AC34h
.text$mn:0000AC34 ; COMDAT (pick any)
.text$mn:0000AC34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AC34
.text$mn:0000AC34 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC34
.text$mn:0000AC34 ; Attributes: bp-based frame
.text$mn:0000AC34
.text$mn:0000AC34 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:0000AC34                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:0000AC34 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:0000AC34                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:0000AC34                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+29p ...
.text$mn:0000AC34
.text$mn:0000AC34 var_4           = dword ptr -4
.text$mn:0000AC34
.text$mn:0000AC34                 push    ebp
.text$mn:0000AC35                 mov     ebp, esp
.text$mn:0000AC37                 push    ecx
.text$mn:0000AC38                 mov     [ebp+var_4], ecx
.text$mn:0000AC3B                 mov     eax, [ebp+var_4]
.text$mn:0000AC3E                 mov     dword ptr [eax], 0
.text$mn:0000AC44                 mov     eax, [ebp+var_4]
.text$mn:0000AC47                 mov     esp, ebp
.text$mn:0000AC49                 pop     ebp
.text$mn:0000AC4A                 retn
.text$mn:0000AC4A ??0_Container_base12@std@@QAE@XZ endp
.text$mn:0000AC4A
.text$mn:0000AC4A ; ---------------------------------------------------------------------------
.text$mn:0000AC4B                 align 4
.text$mn:0000AC4B _text$mn        ends
.text$mn:0000AC4B
.text$mn:0000AC4C ; ===========================================================================
.text$mn:0000AC4C
.text$mn:0000AC4C ; Segment type: Pure code
.text$mn:0000AC4C ; Segment permissions: Read/Execute
.text$mn:0000AC4C _text$mn        segment para public 'CODE' use32
.text$mn:0000AC4C                 assume cs:_text$mn
.text$mn:0000AC4C                 ;org 0AC4Ch
.text$mn:0000AC4C ; COMDAT (pick any)
.text$mn:0000AC4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AC4C
.text$mn:0000AC4C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC4C
.text$mn:0000AC4C ; Attributes: bp-based frame
.text$mn:0000AC4C
.text$mn:0000AC4C ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:0000AC4C                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:0000AC4C ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:0000AC4C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:0000AC4C                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+23p ...
.text$mn:0000AC4C
.text$mn:0000AC4C var_4           = dword ptr -4
.text$mn:0000AC4C
.text$mn:0000AC4C                 push    ebp
.text$mn:0000AC4D                 mov     ebp, esp
.text$mn:0000AC4F                 push    ecx
.text$mn:0000AC50                 mov     [ebp+var_4], ecx
.text$mn:0000AC53                 mov     eax, [ebp+var_4]
.text$mn:0000AC56                 mov     dword ptr [eax], 0
.text$mn:0000AC5C                 mov     ecx, [ebp+var_4]
.text$mn:0000AC5F                 mov     dword ptr [ecx+4], 0
.text$mn:0000AC66                 mov     eax, [ebp+var_4]
.text$mn:0000AC69                 mov     esp, ebp
.text$mn:0000AC6B                 pop     ebp
.text$mn:0000AC6C                 retn
.text$mn:0000AC6C ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:0000AC6C
.text$mn:0000AC6C ; ---------------------------------------------------------------------------
.text$mn:0000AC6D                 align 10h
.text$mn:0000AC6D _text$mn        ends
.text$mn:0000AC6D
.text$mn:0000AC70 ; ===========================================================================
.text$mn:0000AC70
.text$mn:0000AC70 ; Segment type: Pure code
.text$mn:0000AC70 ; Segment permissions: Read/Execute
.text$mn:0000AC70 _text$mn        segment para public 'CODE' use32
.text$mn:0000AC70                 assume cs:_text$mn
.text$mn:0000AC70                 ;org 0AC70h
.text$mn:0000AC70 ; COMDAT (pick any)
.text$mn:0000AC70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AC70
.text$mn:0000AC70 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC70
.text$mn:0000AC70 ; Attributes: bp-based frame
.text$mn:0000AC70
.text$mn:0000AC70 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:0000AC70                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000AC70 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:0000AC70                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:0000AC70                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:0000AC70
.text$mn:0000AC70 var_10          = dword ptr -10h
.text$mn:0000AC70 var_C           = dword ptr -0Ch
.text$mn:0000AC70 var_4           = dword ptr -4
.text$mn:0000AC70
.text$mn:0000AC70                 push    ebp
.text$mn:0000AC71                 mov     ebp, esp
.text$mn:0000AC73                 push    0FFFFFFFFh
.text$mn:0000AC75                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000AC7A                 mov     eax, large fs:0
.text$mn:0000AC80                 push    eax
.text$mn:0000AC81                 push    ecx
.text$mn:0000AC82                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000AC87                 xor     eax, ebp
.text$mn:0000AC89                 push    eax
.text$mn:0000AC8A                 lea     eax, [ebp+var_C]
.text$mn:0000AC8D                 mov     large fs:0, eax
.text$mn:0000AC93                 mov     [ebp+var_10], ecx
.text$mn:0000AC96                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000AC99                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:0000AC9E                 mov     [ebp+var_4], 0
.text$mn:0000ACA5                 mov     eax, [ebp+var_10]
.text$mn:0000ACA8                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:0000ACAE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000ACB5                 mov     eax, [ebp+var_10]
.text$mn:0000ACB8                 mov     ecx, [ebp+var_C]
.text$mn:0000ACBB                 mov     large fs:0, ecx
.text$mn:0000ACC2                 pop     ecx
.text$mn:0000ACC3                 mov     esp, ebp
.text$mn:0000ACC5                 pop     ebp
.text$mn:0000ACC6                 retn
.text$mn:0000ACC6 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:0000ACC6
.text$mn:0000ACC6 ; ---------------------------------------------------------------------------
.text$mn:0000ACC7                 align 4
.text$mn:0000ACC7 _text$mn        ends
.text$mn:0000ACC7
.text$x:0000ACC8 ; ===========================================================================
.text$x:0000ACC8
.text$x:0000ACC8 ; Segment type: Pure code
.text$x:0000ACC8 ; Segment permissions: Read/Execute
.text$x:0000ACC8 _text$x         segment para public 'CODE' use32
.text$x:0000ACC8                 assume cs:_text$x
.text$x:0000ACC8                 ;org 0ACC8h
.text$x:0000ACC8 ; COMDAT (pick associative to section at AC70)
.text$x:0000ACC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000ACC8
.text$x:0000ACC8 ; =============== S U B R O U T I N E =======================================
.text$x:0000ACC8
.text$x:0000ACC8
.text$x:0000ACC8 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:0000ACC8                                         ; DATA XREF: .xdata$x:000125BCo
.text$x:0000ACC8                 mov     ecx, [ebp-10h]  ; this
.text$x:0000ACCB                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000ACCB __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:0000ACCB
.text$x:0000ACD0
.text$x:0000ACD0 ; =============== S U B R O U T I N E =======================================
.text$x:0000ACD0
.text$x:0000ACD0
.text$x:0000ACD0 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:0000ACD0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:0000ACD0
.text$x:0000ACD0 arg_4           = dword ptr  8
.text$x:0000ACD0
.text$x:0000ACD0                 mov     edx, [esp+arg_4]
.text$x:0000ACD4                 lea     eax, [edx+0Ch]
.text$x:0000ACD7                 mov     ecx, [edx-8]
.text$x:0000ACDA                 xor     ecx, eax
.text$x:0000ACDC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000ACE1                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:0000ACE6                 jmp     ___CxxFrameHandler3
.text$x:0000ACE6 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:0000ACE6
.text$x:0000ACE6 ; ---------------------------------------------------------------------------
.text$x:0000ACEB                 align 4
.text$x:0000ACEB _text$x         ends
.text$x:0000ACEB
.text$mn:0000ACEC ; ===========================================================================
.text$mn:0000ACEC
.text$mn:0000ACEC ; Segment type: Pure code
.text$mn:0000ACEC ; Segment permissions: Read/Execute
.text$mn:0000ACEC _text$mn        segment para public 'CODE' use32
.text$mn:0000ACEC                 assume cs:_text$mn
.text$mn:0000ACEC                 ;org 0ACECh
.text$mn:0000ACEC ; COMDAT (pick any)
.text$mn:0000ACEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000ACEC
.text$mn:0000ACEC ; =============== S U B R O U T I N E =======================================
.text$mn:0000ACEC
.text$mn:0000ACEC ; Attributes: bp-based frame
.text$mn:0000ACEC
.text$mn:0000ACEC ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:0000ACEC                 public ??0_Ignore@std@@QAE@XZ
.text$mn:0000ACEC ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:0000ACEC
.text$mn:0000ACEC var_4           = dword ptr -4
.text$mn:0000ACEC
.text$mn:0000ACEC                 push    ebp
.text$mn:0000ACED                 mov     ebp, esp
.text$mn:0000ACEF                 push    ecx
.text$mn:0000ACF0                 mov     [ebp+var_4], ecx
.text$mn:0000ACF3                 mov     eax, [ebp+var_4]
.text$mn:0000ACF6                 mov     esp, ebp
.text$mn:0000ACF8                 pop     ebp
.text$mn:0000ACF9                 retn
.text$mn:0000ACF9 ??0_Ignore@std@@QAE@XZ endp
.text$mn:0000ACF9
.text$mn:0000ACF9 ; ---------------------------------------------------------------------------
.text$mn:0000ACFA                 align 4
.text$mn:0000ACFA _text$mn        ends
.text$mn:0000ACFA
.text$mn:0000ACFC ; ===========================================================================
.text$mn:0000ACFC
.text$mn:0000ACFC ; Segment type: Pure code
.text$mn:0000ACFC ; Segment permissions: Read/Execute
.text$mn:0000ACFC _text$mn        segment para public 'CODE' use32
.text$mn:0000ACFC                 assume cs:_text$mn
.text$mn:0000ACFC                 ;org 0ACFCh
.text$mn:0000ACFC ; COMDAT (pick any)
.text$mn:0000ACFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000ACFC
.text$mn:0000ACFC ; =============== S U B R O U T I N E =======================================
.text$mn:0000ACFC
.text$mn:0000ACFC ; Attributes: bp-based frame
.text$mn:0000ACFC
.text$mn:0000ACFC ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:0000ACFC                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:0000ACFC ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:0000ACFC                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:0000ACFC
.text$mn:0000ACFC var_10          = dword ptr -10h
.text$mn:0000ACFC var_C           = dword ptr -0Ch
.text$mn:0000ACFC var_4           = dword ptr -4
.text$mn:0000ACFC
.text$mn:0000ACFC                 push    ebp
.text$mn:0000ACFD                 mov     ebp, esp
.text$mn:0000ACFF                 push    0FFFFFFFFh
.text$mn:0000AD01                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:0000AD06                 mov     eax, large fs:0
.text$mn:0000AD0C                 push    eax
.text$mn:0000AD0D                 push    ecx
.text$mn:0000AD0E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000AD13                 xor     eax, ebp
.text$mn:0000AD15                 push    eax
.text$mn:0000AD16                 lea     eax, [ebp+var_C]
.text$mn:0000AD19                 mov     large fs:0, eax
.text$mn:0000AD1F                 mov     [ebp+var_10], ecx
.text$mn:0000AD22                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000AD25                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000AD2A                 mov     [ebp+var_4], 0
.text$mn:0000AD31                 mov     eax, [ebp+var_10]
.text$mn:0000AD34                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:0000AD3A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000AD41                 mov     eax, [ebp+var_10]
.text$mn:0000AD44                 mov     ecx, [ebp+var_C]
.text$mn:0000AD47                 mov     large fs:0, ecx
.text$mn:0000AD4E                 pop     ecx
.text$mn:0000AD4F                 mov     esp, ebp
.text$mn:0000AD51                 pop     ebp
.text$mn:0000AD52                 retn
.text$mn:0000AD52 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:0000AD52
.text$mn:0000AD52 ; ---------------------------------------------------------------------------
.text$mn:0000AD53                 align 4
.text$mn:0000AD53 _text$mn        ends
.text$mn:0000AD53
.text$x:0000AD54 ; ===========================================================================
.text$x:0000AD54
.text$x:0000AD54 ; Segment type: Pure code
.text$x:0000AD54 ; Segment permissions: Read/Execute
.text$x:0000AD54 _text$x         segment para public 'CODE' use32
.text$x:0000AD54                 assume cs:_text$x
.text$x:0000AD54                 ;org 0AD54h
.text$x:0000AD54 ; COMDAT (pick associative to section at ACFC)
.text$x:0000AD54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000AD54
.text$x:0000AD54 ; =============== S U B R O U T I N E =======================================
.text$x:0000AD54
.text$x:0000AD54
.text$x:0000AD54 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:0000AD54                                         ; DATA XREF: .xdata$x:00012640o
.text$x:0000AD54                 mov     ecx, [ebp-10h]  ; this
.text$x:0000AD57                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000AD57 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:0000AD57
.text$x:0000AD5C
.text$x:0000AD5C ; =============== S U B R O U T I N E =======================================
.text$x:0000AD5C
.text$x:0000AD5C
.text$x:0000AD5C __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:0000AD5C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:0000AD5C
.text$x:0000AD5C arg_4           = dword ptr  8
.text$x:0000AD5C
.text$x:0000AD5C                 mov     edx, [esp+arg_4]
.text$x:0000AD60                 lea     eax, [edx+0Ch]
.text$x:0000AD63                 mov     ecx, [edx-8]
.text$x:0000AD66                 xor     ecx, eax
.text$x:0000AD68                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AD6D                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:0000AD72                 jmp     ___CxxFrameHandler3
.text$x:0000AD72 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:0000AD72
.text$x:0000AD72 ; ---------------------------------------------------------------------------
.text$x:0000AD77                 align 4
.text$x:0000AD77 _text$x         ends
.text$x:0000AD77
.text$mn:0000AD78 ; ===========================================================================
.text$mn:0000AD78
.text$mn:0000AD78 ; Segment type: Pure code
.text$mn:0000AD78 ; Segment permissions: Read/Execute
.text$mn:0000AD78 _text$mn        segment para public 'CODE' use32
.text$mn:0000AD78                 assume cs:_text$mn
.text$mn:0000AD78                 ;org 0AD78h
.text$mn:0000AD78 ; COMDAT (pick any)
.text$mn:0000AD78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AD78
.text$mn:0000AD78 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AD78
.text$mn:0000AD78 ; Attributes: bp-based frame
.text$mn:0000AD78
.text$mn:0000AD78 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:0000AD78                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:0000AD78 ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:0000AD78                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12> const &)+2Dp
.text$mn:0000AD78                                         ; std::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12> const &)+2Dp ...
.text$mn:0000AD78
.text$mn:0000AD78 var_4           = dword ptr -4
.text$mn:0000AD78 arg_0           = dword ptr  8
.text$mn:0000AD78
.text$mn:0000AD78                 push    ebp
.text$mn:0000AD79                 mov     ebp, esp
.text$mn:0000AD7B                 push    ecx
.text$mn:0000AD7C                 mov     [ebp+var_4], ecx
.text$mn:0000AD7F                 mov     eax, [ebp+var_4]
.text$mn:0000AD82                 mov     dword ptr [eax], 0
.text$mn:0000AD88                 mov     ecx, [ebp+var_4]
.text$mn:0000AD8B                 mov     dword ptr [ecx+4], 0
.text$mn:0000AD92                 mov     edx, [ebp+arg_0]
.text$mn:0000AD95                 push    edx
.text$mn:0000AD96                 mov     ecx, [ebp+var_4]
.text$mn:0000AD99                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:0000AD9E                 mov     eax, [ebp+var_4]
.text$mn:0000ADA1                 mov     esp, ebp
.text$mn:0000ADA3                 pop     ebp
.text$mn:0000ADA4                 retn    4
.text$mn:0000ADA4 ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:0000ADA4
.text$mn:0000ADA4 ; ---------------------------------------------------------------------------
.text$mn:0000ADA7                 align 4
.text$mn:0000ADA7 _text$mn        ends
.text$mn:0000ADA7
.text$mn:0000ADA8 ; ===========================================================================
.text$mn:0000ADA8
.text$mn:0000ADA8 ; Segment type: Pure code
.text$mn:0000ADA8 ; Segment permissions: Read/Execute
.text$mn:0000ADA8 _text$mn        segment para public 'CODE' use32
.text$mn:0000ADA8                 assume cs:_text$mn
.text$mn:0000ADA8                 ;org 0ADA8h
.text$mn:0000ADA8 ; COMDAT (pick any)
.text$mn:0000ADA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000ADA8
.text$mn:0000ADA8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ADA8
.text$mn:0000ADA8 ; Attributes: bp-based frame
.text$mn:0000ADA8
.text$mn:0000ADA8 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:0000ADA8                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:0000ADA8 ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:0000ADA8                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)+29p
.text$mn:0000ADA8                                         ; std::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>(void)+29p ...
.text$mn:0000ADA8
.text$mn:0000ADA8 var_4           = dword ptr -4
.text$mn:0000ADA8
.text$mn:0000ADA8                 push    ebp
.text$mn:0000ADA9                 mov     ebp, esp
.text$mn:0000ADAB                 push    ecx
.text$mn:0000ADAC                 mov     [ebp+var_4], ecx
.text$mn:0000ADAF                 mov     eax, [ebp+var_4]
.text$mn:0000ADB2                 mov     dword ptr [eax], 0
.text$mn:0000ADB8                 mov     ecx, [ebp+var_4]
.text$mn:0000ADBB                 mov     dword ptr [ecx+4], 0
.text$mn:0000ADC2                 mov     eax, [ebp+var_4]
.text$mn:0000ADC5                 mov     esp, ebp
.text$mn:0000ADC7                 pop     ebp
.text$mn:0000ADC8                 retn
.text$mn:0000ADC8 ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:0000ADC8
.text$mn:0000ADC8 ; ---------------------------------------------------------------------------
.text$mn:0000ADC9                 align 4
.text$mn:0000ADC9 _text$mn        ends
.text$mn:0000ADC9
.text$mn:0000ADCC ; ===========================================================================
.text$mn:0000ADCC
.text$mn:0000ADCC ; Segment type: Pure code
.text$mn:0000ADCC ; Segment permissions: Read/Execute
.text$mn:0000ADCC _text$mn        segment para public 'CODE' use32
.text$mn:0000ADCC                 assume cs:_text$mn
.text$mn:0000ADCC                 ;org 0ADCCh
.text$mn:0000ADCC ; COMDAT (pick any)
.text$mn:0000ADCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000ADCC
.text$mn:0000ADCC ; =============== S U B R O U T I N E =======================================
.text$mn:0000ADCC
.text$mn:0000ADCC ; Attributes: bp-based frame
.text$mn:0000ADCC
.text$mn:0000ADCC ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:0000ADCC                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:0000ADCC ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:0000ADCC                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:0000ADCC
.text$mn:0000ADCC var_10          = dword ptr -10h
.text$mn:0000ADCC var_C           = dword ptr -0Ch
.text$mn:0000ADCC var_4           = dword ptr -4
.text$mn:0000ADCC
.text$mn:0000ADCC                 push    ebp
.text$mn:0000ADCD                 mov     ebp, esp
.text$mn:0000ADCF                 push    0FFFFFFFFh
.text$mn:0000ADD1                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:0000ADD6                 mov     eax, large fs:0
.text$mn:0000ADDC                 push    eax
.text$mn:0000ADDD                 push    ecx
.text$mn:0000ADDE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000ADE3                 xor     eax, ebp
.text$mn:0000ADE5                 push    eax
.text$mn:0000ADE6                 lea     eax, [ebp+var_C]
.text$mn:0000ADE9                 mov     large fs:0, eax
.text$mn:0000ADEF                 mov     [ebp+var_10], ecx
.text$mn:0000ADF2                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000ADF5                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000ADFA                 mov     [ebp+var_4], 0
.text$mn:0000AE01                 mov     eax, [ebp+var_10]
.text$mn:0000AE04                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:0000AE0A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000AE11                 mov     eax, [ebp+var_10]
.text$mn:0000AE14                 mov     ecx, [ebp+var_C]
.text$mn:0000AE17                 mov     large fs:0, ecx
.text$mn:0000AE1E                 pop     ecx
.text$mn:0000AE1F                 mov     esp, ebp
.text$mn:0000AE21                 pop     ebp
.text$mn:0000AE22                 retn
.text$mn:0000AE22 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:0000AE22
.text$mn:0000AE22 ; ---------------------------------------------------------------------------
.text$mn:0000AE23                 align 4
.text$mn:0000AE23 _text$mn        ends
.text$mn:0000AE23
.text$x:0000AE24 ; ===========================================================================
.text$x:0000AE24
.text$x:0000AE24 ; Segment type: Pure code
.text$x:0000AE24 ; Segment permissions: Read/Execute
.text$x:0000AE24 _text$x         segment para public 'CODE' use32
.text$x:0000AE24                 assume cs:_text$x
.text$x:0000AE24                 ;org 0AE24h
.text$x:0000AE24 ; COMDAT (pick associative to section at ADCC)
.text$x:0000AE24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000AE24
.text$x:0000AE24 ; =============== S U B R O U T I N E =======================================
.text$x:0000AE24
.text$x:0000AE24
.text$x:0000AE24 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:0000AE24                                         ; DATA XREF: .xdata$x:000126C4o
.text$x:0000AE24                 mov     ecx, [ebp-10h]  ; this
.text$x:0000AE27                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000AE27 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:0000AE27
.text$x:0000AE2C
.text$x:0000AE2C ; =============== S U B R O U T I N E =======================================
.text$x:0000AE2C
.text$x:0000AE2C
.text$x:0000AE2C __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:0000AE2C                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:0000AE2C
.text$x:0000AE2C arg_4           = dword ptr  8
.text$x:0000AE2C
.text$x:0000AE2C                 mov     edx, [esp+arg_4]
.text$x:0000AE30                 lea     eax, [edx+0Ch]
.text$x:0000AE33                 mov     ecx, [edx-8]
.text$x:0000AE36                 xor     ecx, eax
.text$x:0000AE38                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AE3D                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:0000AE42                 jmp     ___CxxFrameHandler3
.text$x:0000AE42 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:0000AE42
.text$x:0000AE42 ; ---------------------------------------------------------------------------
.text$x:0000AE47                 align 4
.text$x:0000AE47 _text$x         ends
.text$x:0000AE47
.text$mn:0000AE48 ; ===========================================================================
.text$mn:0000AE48
.text$mn:0000AE48 ; Segment type: Pure code
.text$mn:0000AE48 ; Segment permissions: Read/Execute
.text$mn:0000AE48 _text$mn        segment para public 'CODE' use32
.text$mn:0000AE48                 assume cs:_text$mn
.text$mn:0000AE48                 ;org 0AE48h
.text$mn:0000AE48 ; COMDAT (pick any)
.text$mn:0000AE48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AE48
.text$mn:0000AE48 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE48
.text$mn:0000AE48 ; Attributes: bp-based frame
.text$mn:0000AE48
.text$mn:0000AE48 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:0000AE48                 public ??0error_category@std@@QAE@XZ
.text$mn:0000AE48 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:0000AE48
.text$mn:0000AE48 var_4           = dword ptr -4
.text$mn:0000AE48
.text$mn:0000AE48                 push    ebp
.text$mn:0000AE49                 mov     ebp, esp
.text$mn:0000AE4B                 push    ecx
.text$mn:0000AE4C                 mov     [ebp+var_4], ecx
.text$mn:0000AE4F                 mov     eax, [ebp+var_4]
.text$mn:0000AE52                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:0000AE58                 mov     eax, [ebp+var_4]
.text$mn:0000AE5B                 mov     esp, ebp
.text$mn:0000AE5D                 pop     ebp
.text$mn:0000AE5E                 retn
.text$mn:0000AE5E ??0error_category@std@@QAE@XZ endp
.text$mn:0000AE5E
.text$mn:0000AE5E ; ---------------------------------------------------------------------------
.text$mn:0000AE5F                 align 10h
.text$mn:0000AE5F _text$mn        ends
.text$mn:0000AE5F
.text$mn:0000AE60 ; ===========================================================================
.text$mn:0000AE60
.text$mn:0000AE60 ; Segment type: Pure code
.text$mn:0000AE60 ; Segment permissions: Read/Execute
.text$mn:0000AE60 _text$mn        segment para public 'CODE' use32
.text$mn:0000AE60                 assume cs:_text$mn
.text$mn:0000AE60                 ;org 0AE60h
.text$mn:0000AE60 ; COMDAT (pick any)
.text$mn:0000AE60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AE60
.text$mn:0000AE60 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE60
.text$mn:0000AE60 ; Attributes: bp-based frame
.text$mn:0000AE60
.text$mn:0000AE60 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:0000AE60                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:0000AE60 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:0000AE60                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:0000AE60                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:0000AE60
.text$mn:0000AE60 var_4           = dword ptr -4
.text$mn:0000AE60 arg_0           = dword ptr  8
.text$mn:0000AE60 arg_4           = dword ptr  0Ch
.text$mn:0000AE60
.text$mn:0000AE60                 push    ebp
.text$mn:0000AE61                 mov     ebp, esp
.text$mn:0000AE63                 push    ecx
.text$mn:0000AE64                 mov     [ebp+var_4], ecx
.text$mn:0000AE67                 mov     eax, [ebp+var_4]
.text$mn:0000AE6A                 mov     ecx, [ebp+arg_0]
.text$mn:0000AE6D                 mov     [eax], ecx
.text$mn:0000AE6F                 mov     edx, [ebp+var_4]
.text$mn:0000AE72                 mov     eax, [ebp+arg_4]
.text$mn:0000AE75                 mov     [edx+4], eax
.text$mn:0000AE78                 mov     eax, [ebp+var_4]
.text$mn:0000AE7B                 mov     esp, ebp
.text$mn:0000AE7D                 pop     ebp
.text$mn:0000AE7E                 retn    8
.text$mn:0000AE7E ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:0000AE7E
.text$mn:0000AE7E ; ---------------------------------------------------------------------------
.text$mn:0000AE81                 align 4
.text$mn:0000AE81 _text$mn        ends
.text$mn:0000AE81
.text$mn:0000AE84 ; ===========================================================================
.text$mn:0000AE84
.text$mn:0000AE84 ; Segment type: Pure code
.text$mn:0000AE84 ; Segment permissions: Read/Execute
.text$mn:0000AE84 _text$mn        segment para public 'CODE' use32
.text$mn:0000AE84                 assume cs:_text$mn
.text$mn:0000AE84                 ;org 0AE84h
.text$mn:0000AE84 ; COMDAT (pick any)
.text$mn:0000AE84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AE84
.text$mn:0000AE84 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE84
.text$mn:0000AE84 ; Attributes: bp-based frame
.text$mn:0000AE84
.text$mn:0000AE84 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:0000AE84                 public ??0id@locale@std@@QAE@I@Z
.text$mn:0000AE84 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:0000AE84                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:0000AE84
.text$mn:0000AE84 var_4           = dword ptr -4
.text$mn:0000AE84 arg_0           = dword ptr  8
.text$mn:0000AE84
.text$mn:0000AE84                 push    ebp
.text$mn:0000AE85                 mov     ebp, esp
.text$mn:0000AE87                 push    ecx
.text$mn:0000AE88                 mov     [ebp+var_4], ecx
.text$mn:0000AE8B                 mov     eax, [ebp+var_4]
.text$mn:0000AE8E                 mov     ecx, [ebp+arg_0]
.text$mn:0000AE91                 mov     [eax], ecx
.text$mn:0000AE93                 mov     eax, [ebp+var_4]
.text$mn:0000AE96                 mov     esp, ebp
.text$mn:0000AE98                 pop     ebp
.text$mn:0000AE99                 retn    4
.text$mn:0000AE99 ??0id@locale@std@@QAE@I@Z endp
.text$mn:0000AE99
.text$mn:0000AE99 _text$mn        ends
.text$mn:0000AE99
.text$mn:0000AE9C ; ===========================================================================
.text$mn:0000AE9C
.text$mn:0000AE9C ; Segment type: Pure code
.text$mn:0000AE9C ; Segment permissions: Read/Execute
.text$mn:0000AE9C _text$mn        segment para public 'CODE' use32
.text$mn:0000AE9C                 assume cs:_text$mn
.text$mn:0000AE9C                 ;org 0AE9Ch
.text$mn:0000AE9C ; COMDAT (pick any)
.text$mn:0000AE9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AE9C
.text$mn:0000AE9C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE9C
.text$mn:0000AE9C ; Attributes: bp-based frame
.text$mn:0000AE9C
.text$mn:0000AE9C ; public: __thiscall sessionFileInfo::sessionFileInfo(struct sessionFileInfo const &)
.text$mn:0000AE9C                 public ??0sessionFileInfo@@QAE@ABU0@@Z
.text$mn:0000AE9C ??0sessionFileInfo@@QAE@ABU0@@Z proc near
.text$mn:0000AE9C                                         ; CODE XREF: std::allocator<sessionFileInfo>::construct<sessionFileInfo,sessionFileInfo>(sessionFileInfo *,sessionFileInfo &&)+59p
.text$mn:0000AE9C                                         ; std::allocator<sessionFileInfo>::construct(sessionFileInfo *,sessionFileInfo const &)+50p
.text$mn:0000AE9C
.text$mn:0000AE9C var_10          = dword ptr -10h
.text$mn:0000AE9C var_C           = dword ptr -0Ch
.text$mn:0000AE9C var_4           = dword ptr -4
.text$mn:0000AE9C arg_0           = dword ptr  8
.text$mn:0000AE9C
.text$mn:0000AE9C                 push    ebp
.text$mn:0000AE9D                 mov     ebp, esp
.text$mn:0000AE9F                 push    0FFFFFFFFh
.text$mn:0000AEA1                 push    offset __ehhandler$??0sessionFileInfo@@QAE@ABU0@@Z
.text$mn:0000AEA6                 mov     eax, large fs:0
.text$mn:0000AEAC                 push    eax
.text$mn:0000AEAD                 push    ecx
.text$mn:0000AEAE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000AEB3                 xor     eax, ebp
.text$mn:0000AEB5                 push    eax
.text$mn:0000AEB6                 lea     eax, [ebp+var_C]
.text$mn:0000AEB9                 mov     large fs:0, eax
.text$mn:0000AEBF                 mov     [ebp+var_10], ecx
.text$mn:0000AEC2                 mov     eax, [ebp+arg_0]
.text$mn:0000AEC5                 mov     ecx, [ebp+var_10]
.text$mn:0000AEC8                 mov     edx, [eax]
.text$mn:0000AECA                 mov     [ecx], edx
.text$mn:0000AECC                 mov     edx, [eax+4]
.text$mn:0000AECF                 mov     [ecx+4], edx
.text$mn:0000AED2                 mov     edx, [eax+8]
.text$mn:0000AED5                 mov     [ecx+8], edx
.text$mn:0000AED8                 mov     edx, [eax+0Ch]
.text$mn:0000AEDB                 mov     [ecx+0Ch], edx
.text$mn:0000AEDE                 mov     edx, [eax+10h]
.text$mn:0000AEE1                 mov     [ecx+10h], edx
.text$mn:0000AEE4                 mov     eax, [eax+14h]
.text$mn:0000AEE7                 mov     [ecx+14h], eax
.text$mn:0000AEEA                 mov     ecx, [ebp+arg_0]
.text$mn:0000AEED                 add     ecx, 18h
.text$mn:0000AEF0                 push    ecx
.text$mn:0000AEF1                 mov     ecx, [ebp+var_10]
.text$mn:0000AEF4                 add     ecx, 18h
.text$mn:0000AEF7                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000AEFC                 mov     [ebp+var_4], 0
.text$mn:0000AF03                 mov     edx, [ebp+arg_0]
.text$mn:0000AF06                 add     edx, 34h ; '4'
.text$mn:0000AF09                 push    edx
.text$mn:0000AF0A                 mov     ecx, [ebp+var_10]
.text$mn:0000AF0D                 add     ecx, 34h ; '4'
.text$mn:0000AF10                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000AF15                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000AF19                 mov     eax, [ebp+arg_0]
.text$mn:0000AF1C                 add     eax, 50h ; 'P'
.text$mn:0000AF1F                 push    eax
.text$mn:0000AF20                 mov     ecx, [ebp+var_10]
.text$mn:0000AF23                 add     ecx, 50h ; 'P'
.text$mn:0000AF26                 call    ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ; std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(std::vector<uint,std::allocator<uint>> const &)
.text$mn:0000AF2B                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000AF2F                 mov     ecx, [ebp+arg_0]
.text$mn:0000AF32                 add     ecx, 60h ; '`'
.text$mn:0000AF35                 push    ecx
.text$mn:0000AF36                 mov     ecx, [ebp+var_10]
.text$mn:0000AF39                 add     ecx, 60h ; '`'
.text$mn:0000AF3C                 call    ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ; std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(std::vector<uint,std::allocator<uint>> const &)
.text$mn:0000AF41                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000AF45                 mov     edx, [ebp+var_10]
.text$mn:0000AF48                 mov     eax, [ebp+arg_0]
.text$mn:0000AF4B                 mov     ecx, [eax+70h]
.text$mn:0000AF4E                 mov     [edx+70h], ecx
.text$mn:0000AF51                 mov     edx, [ebp+arg_0]
.text$mn:0000AF54                 add     edx, 74h ; 't'
.text$mn:0000AF57                 push    edx
.text$mn:0000AF58                 mov     ecx, [ebp+var_10]
.text$mn:0000AF5B                 add     ecx, 74h ; 't'
.text$mn:0000AF5E                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000AF63                 mov     byte ptr [ebp+var_4], 4
.text$mn:0000AF67                 mov     eax, [ebp+var_10]
.text$mn:0000AF6A                 mov     ecx, [ebp+arg_0]
.text$mn:0000AF6D                 mov     edx, [ecx+90h]
.text$mn:0000AF73                 mov     [eax+90h], edx
.text$mn:0000AF79                 mov     ecx, [ecx+94h]
.text$mn:0000AF7F                 mov     [eax+94h], ecx
.text$mn:0000AF85                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000AF8C                 mov     eax, [ebp+var_10]
.text$mn:0000AF8F                 mov     ecx, [ebp+var_C]
.text$mn:0000AF92                 mov     large fs:0, ecx
.text$mn:0000AF99                 pop     ecx
.text$mn:0000AF9A                 mov     esp, ebp
.text$mn:0000AF9C                 pop     ebp
.text$mn:0000AF9D                 retn    4
.text$mn:0000AF9D ??0sessionFileInfo@@QAE@ABU0@@Z endp
.text$mn:0000AF9D
.text$mn:0000AF9D _text$mn        ends
.text$mn:0000AF9D
.text$x:0000AFA0 ; ===========================================================================
.text$x:0000AFA0
.text$x:0000AFA0 ; Segment type: Pure code
.text$x:0000AFA0 ; Segment permissions: Read/Execute
.text$x:0000AFA0 _text$x         segment para public 'CODE' use32
.text$x:0000AFA0                 assume cs:_text$x
.text$x:0000AFA0                 ;org 0AFA0h
.text$x:0000AFA0 ; COMDAT (pick associative to section at AE9C)
.text$x:0000AFA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000AFA0
.text$x:0000AFA0 ; =============== S U B R O U T I N E =======================================
.text$x:0000AFA0
.text$x:0000AFA0
.text$x:0000AFA0 __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$0 proc near
.text$x:0000AFA0                                         ; DATA XREF: .xdata$x:00013008o
.text$x:0000AFA0                 mov     ecx, [ebp-10h]
.text$x:0000AFA3                 add     ecx, 18h
.text$x:0000AFA6                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000AFA6 __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$0 endp
.text$x:0000AFA6
.text$x:0000AFAB
.text$x:0000AFAB ; =============== S U B R O U T I N E =======================================
.text$x:0000AFAB
.text$x:0000AFAB
.text$x:0000AFAB __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$1 proc near
.text$x:0000AFAB                                         ; DATA XREF: .xdata$x:00013010o
.text$x:0000AFAB                 mov     ecx, [ebp-10h]
.text$x:0000AFAE                 add     ecx, 34h ; '4'
.text$x:0000AFB1                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000AFB1 __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$1 endp
.text$x:0000AFB1
.text$x:0000AFB6
.text$x:0000AFB6 ; =============== S U B R O U T I N E =======================================
.text$x:0000AFB6
.text$x:0000AFB6
.text$x:0000AFB6 __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$2 proc near
.text$x:0000AFB6                                         ; DATA XREF: .xdata$x:00013018o
.text$x:0000AFB6                 mov     ecx, [ebp-10h]
.text$x:0000AFB9                 add     ecx, 50h ; 'P'
.text$x:0000AFBC                 jmp     ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<uint,std::allocator<uint>>::~vector<uint,std::allocator<uint>>(void)
.text$x:0000AFBC __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$2 endp
.text$x:0000AFBC
.text$x:0000AFC1
.text$x:0000AFC1 ; =============== S U B R O U T I N E =======================================
.text$x:0000AFC1
.text$x:0000AFC1
.text$x:0000AFC1 __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$3 proc near
.text$x:0000AFC1                                         ; DATA XREF: .xdata$x:00013020o
.text$x:0000AFC1                 mov     ecx, [ebp-10h]
.text$x:0000AFC4                 add     ecx, 60h ; '`'
.text$x:0000AFC7                 jmp     ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<uint,std::allocator<uint>>::~vector<uint,std::allocator<uint>>(void)
.text$x:0000AFC7 __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$3 endp
.text$x:0000AFC7
.text$x:0000AFCC
.text$x:0000AFCC ; =============== S U B R O U T I N E =======================================
.text$x:0000AFCC
.text$x:0000AFCC
.text$x:0000AFCC __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$4 proc near
.text$x:0000AFCC                                         ; DATA XREF: .xdata$x:00013028o
.text$x:0000AFCC                 mov     ecx, [ebp-10h]
.text$x:0000AFCF                 add     ecx, 74h ; 't'
.text$x:0000AFD2                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000AFD2 __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$4 endp
.text$x:0000AFD2
.text$x:0000AFD7
.text$x:0000AFD7 ; =============== S U B R O U T I N E =======================================
.text$x:0000AFD7
.text$x:0000AFD7
.text$x:0000AFD7 __ehhandler$??0sessionFileInfo@@QAE@ABU0@@Z proc near
.text$x:0000AFD7                                         ; DATA XREF: sessionFileInfo::sessionFileInfo(sessionFileInfo const &)+5o
.text$x:0000AFD7
.text$x:0000AFD7 arg_4           = dword ptr  8
.text$x:0000AFD7
.text$x:0000AFD7                 mov     edx, [esp+arg_4]
.text$x:0000AFDB                 lea     eax, [edx+0Ch]
.text$x:0000AFDE                 mov     ecx, [edx-8]
.text$x:0000AFE1                 xor     ecx, eax
.text$x:0000AFE3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AFE8                 mov     eax, offset __ehfuncinfo$??0sessionFileInfo@@QAE@ABU0@@Z
.text$x:0000AFED                 jmp     ___CxxFrameHandler3
.text$x:0000AFED __ehhandler$??0sessionFileInfo@@QAE@ABU0@@Z endp
.text$x:0000AFED
.text$x:0000AFED ; ---------------------------------------------------------------------------
.text$x:0000AFF2                 align 4
.text$x:0000AFF2 _text$x         ends
.text$x:0000AFF2
.text$mn:0000AFF4 ; ===========================================================================
.text$mn:0000AFF4
.text$mn:0000AFF4 ; Segment type: Pure code
.text$mn:0000AFF4 ; Segment permissions: Read/Execute
.text$mn:0000AFF4 _text$mn        segment para public 'CODE' use32
.text$mn:0000AFF4                 assume cs:_text$mn
.text$mn:0000AFF4                 ;org 0AFF4h
.text$mn:0000AFF4 ; COMDAT (pick any)
.text$mn:0000AFF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AFF4
.text$mn:0000AFF4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AFF4
.text$mn:0000AFF4 ; Attributes: bp-based frame
.text$mn:0000AFF4
.text$mn:0000AFF4 ; public: __thiscall sessionFileInfo::sessionFileInfo(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>)
.text$mn:0000AFF4                 public ??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
.text$mn:0000AFF4 ??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z proc near
.text$mn:0000AFF4                                         ; CODE XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *)+DFp
.text$mn:0000AFF4
.text$mn:0000AFF4 var_10          = dword ptr -10h
.text$mn:0000AFF4 var_C           = dword ptr -0Ch
.text$mn:0000AFF4 var_4           = dword ptr -4
.text$mn:0000AFF4 arg_0           = byte ptr  8
.text$mn:0000AFF4
.text$mn:0000AFF4                 push    ebp
.text$mn:0000AFF5                 mov     ebp, esp
.text$mn:0000AFF7                 push    0FFFFFFFFh
.text$mn:0000AFF9                 push    offset __ehhandler$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
.text$mn:0000AFFE                 mov     eax, large fs:0
.text$mn:0000B004                 push    eax
.text$mn:0000B005                 push    ecx
.text$mn:0000B006                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B00B                 xor     eax, ebp
.text$mn:0000B00D                 push    eax
.text$mn:0000B00E                 lea     eax, [ebp+var_C]
.text$mn:0000B011                 mov     large fs:0, eax
.text$mn:0000B017                 mov     [ebp+var_10], ecx
.text$mn:0000B01A                 mov     [ebp+var_4], 0
.text$mn:0000B021                 mov     ecx, [ebp+var_10]
.text$mn:0000B024                 call    ??0Position@@QAE@XZ ; Position::Position(void)
.text$mn:0000B029                 lea     eax, [ebp+arg_0]
.text$mn:0000B02C                 push    eax
.text$mn:0000B02D                 mov     ecx, [ebp+var_10]
.text$mn:0000B030                 add     ecx, 18h
.text$mn:0000B033                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000B038                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000B03C                 mov     ecx, [ebp+var_10]
.text$mn:0000B03F                 add     ecx, 34h ; '4'
.text$mn:0000B042                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000B047                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000B04B                 mov     ecx, [ebp+var_10]
.text$mn:0000B04E                 add     ecx, 50h ; 'P'
.text$mn:0000B051                 call    ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(void)
.text$mn:0000B056                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000B05A                 mov     ecx, [ebp+var_10]
.text$mn:0000B05D                 add     ecx, 60h ; '`'
.text$mn:0000B060                 call    ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(void)
.text$mn:0000B065                 mov     byte ptr [ebp+var_4], 4
.text$mn:0000B069                 mov     ecx, [ebp+var_10]
.text$mn:0000B06C                 mov     dword ptr [ecx+70h], 0FFFFFFFFh
.text$mn:0000B073                 mov     ecx, [ebp+var_10]
.text$mn:0000B076                 add     ecx, 74h ; 't'
.text$mn:0000B079                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000B07E                 mov     byte ptr [ebp+var_4], 5
.text$mn:0000B082                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B089                 lea     ecx, [ebp+arg_0]
.text$mn:0000B08C                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000B091                 mov     eax, [ebp+var_10]
.text$mn:0000B094                 mov     ecx, [ebp+var_C]
.text$mn:0000B097                 mov     large fs:0, ecx
.text$mn:0000B09E                 pop     ecx
.text$mn:0000B09F                 mov     esp, ebp
.text$mn:0000B0A1                 pop     ebp
.text$mn:0000B0A2                 retn    1Ch
.text$mn:0000B0A2 ??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z endp
.text$mn:0000B0A2
.text$mn:0000B0A2 ; ---------------------------------------------------------------------------
.text$mn:0000B0A5                 align 4
.text$mn:0000B0A5 _text$mn        ends
.text$mn:0000B0A5
.text$x:0000B0A8 ; ===========================================================================
.text$x:0000B0A8
.text$x:0000B0A8 ; Segment type: Pure code
.text$x:0000B0A8 ; Segment permissions: Read/Execute
.text$x:0000B0A8 _text$x         segment para public 'CODE' use32
.text$x:0000B0A8                 assume cs:_text$x
.text$x:0000B0A8                 ;org 0B0A8h
.text$x:0000B0A8 ; COMDAT (pick associative to section at AFF4)
.text$x:0000B0A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B0A8
.text$x:0000B0A8 ; =============== S U B R O U T I N E =======================================
.text$x:0000B0A8
.text$x:0000B0A8
.text$x:0000B0A8 __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$0 proc near
.text$x:0000B0A8                                         ; DATA XREF: .xdata$x:00012D40o
.text$x:0000B0A8                 lea     ecx, [ebp+8]
.text$x:0000B0AB                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000B0AB __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$0 endp
.text$x:0000B0AB
.text$x:0000B0B0
.text$x:0000B0B0 ; =============== S U B R O U T I N E =======================================
.text$x:0000B0B0
.text$x:0000B0B0
.text$x:0000B0B0 __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$1 proc near
.text$x:0000B0B0                                         ; DATA XREF: .xdata$x:00012D48o
.text$x:0000B0B0                 mov     ecx, [ebp-10h]
.text$x:0000B0B3                 add     ecx, 18h
.text$x:0000B0B6                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000B0B6 __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$1 endp
.text$x:0000B0B6
.text$x:0000B0BB
.text$x:0000B0BB ; =============== S U B R O U T I N E =======================================
.text$x:0000B0BB
.text$x:0000B0BB
.text$x:0000B0BB __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$2 proc near
.text$x:0000B0BB                                         ; DATA XREF: .xdata$x:00012D50o
.text$x:0000B0BB                 mov     ecx, [ebp-10h]
.text$x:0000B0BE                 add     ecx, 34h ; '4'
.text$x:0000B0C1                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000B0C1 __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$2 endp
.text$x:0000B0C1
.text$x:0000B0C6
.text$x:0000B0C6 ; =============== S U B R O U T I N E =======================================
.text$x:0000B0C6
.text$x:0000B0C6
.text$x:0000B0C6 __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$3 proc near
.text$x:0000B0C6                                         ; DATA XREF: .xdata$x:00012D58o
.text$x:0000B0C6                 mov     ecx, [ebp-10h]
.text$x:0000B0C9                 add     ecx, 50h ; 'P'
.text$x:0000B0CC                 jmp     ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<uint,std::allocator<uint>>::~vector<uint,std::allocator<uint>>(void)
.text$x:0000B0CC __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$3 endp
.text$x:0000B0CC
.text$x:0000B0D1
.text$x:0000B0D1 ; =============== S U B R O U T I N E =======================================
.text$x:0000B0D1
.text$x:0000B0D1
.text$x:0000B0D1 __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$4 proc near
.text$x:0000B0D1                                         ; DATA XREF: .xdata$x:00012D60o
.text$x:0000B0D1                 mov     ecx, [ebp-10h]
.text$x:0000B0D4                 add     ecx, 60h ; '`'
.text$x:0000B0D7                 jmp     ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<uint,std::allocator<uint>>::~vector<uint,std::allocator<uint>>(void)
.text$x:0000B0D7 __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$4 endp
.text$x:0000B0D7
.text$x:0000B0DC
.text$x:0000B0DC ; =============== S U B R O U T I N E =======================================
.text$x:0000B0DC
.text$x:0000B0DC
.text$x:0000B0DC __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$5 proc near
.text$x:0000B0DC                                         ; DATA XREF: .xdata$x:00012D68o
.text$x:0000B0DC                 mov     ecx, [ebp-10h]
.text$x:0000B0DF                 add     ecx, 74h ; 't'
.text$x:0000B0E2                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000B0E2 __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$5 endp
.text$x:0000B0E2
.text$x:0000B0E7
.text$x:0000B0E7 ; =============== S U B R O U T I N E =======================================
.text$x:0000B0E7
.text$x:0000B0E7
.text$x:0000B0E7 __ehhandler$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z proc near
.text$x:0000B0E7                                         ; DATA XREF: sessionFileInfo::sessionFileInfo(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+5o
.text$x:0000B0E7
.text$x:0000B0E7 arg_4           = dword ptr  8
.text$x:0000B0E7
.text$x:0000B0E7                 mov     edx, [esp+arg_4]
.text$x:0000B0EB                 lea     eax, [edx+0Ch]
.text$x:0000B0EE                 mov     ecx, [edx-8]
.text$x:0000B0F1                 xor     ecx, eax
.text$x:0000B0F3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B0F8                 mov     eax, offset __ehfuncinfo$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
.text$x:0000B0FD                 jmp     ___CxxFrameHandler3
.text$x:0000B0FD __ehhandler$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z endp
.text$x:0000B0FD
.text$x:0000B0FD ; ---------------------------------------------------------------------------
.text$x:0000B102                 align 4
.text$x:0000B102 _text$x         ends
.text$x:0000B102
.text$mn:0000B104 ; ===========================================================================
.text$mn:0000B104
.text$mn:0000B104 ; Segment type: Pure code
.text$mn:0000B104 ; Segment permissions: Read/Execute
.text$mn:0000B104 _text$mn        segment para public 'CODE' use32
.text$mn:0000B104                 assume cs:_text$mn
.text$mn:0000B104                 ;org 0B104h
.text$mn:0000B104 ; COMDAT (pick any)
.text$mn:0000B104                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B104
.text$mn:0000B104 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B104
.text$mn:0000B104 ; Attributes: bp-based frame
.text$mn:0000B104
.text$mn:0000B104 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>(void)
.text$mn:0000B104                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000B104 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:0000B104                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0+3j
.text$mn:0000B104                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)+37p ...
.text$mn:0000B104
.text$mn:0000B104 var_10          = dword ptr -10h
.text$mn:0000B104 var_C           = dword ptr -0Ch
.text$mn:0000B104 var_4           = dword ptr -4
.text$mn:0000B104
.text$mn:0000B104                 push    ebp
.text$mn:0000B105                 mov     ebp, esp
.text$mn:0000B107                 push    0FFFFFFFFh
.text$mn:0000B109                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000B10E                 mov     eax, large fs:0
.text$mn:0000B114                 push    eax
.text$mn:0000B115                 push    ecx
.text$mn:0000B116                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B11B                 xor     eax, ebp
.text$mn:0000B11D                 push    eax
.text$mn:0000B11E                 lea     eax, [ebp+var_C]
.text$mn:0000B121                 mov     large fs:0, eax
.text$mn:0000B127                 mov     [ebp+var_10], ecx
.text$mn:0000B12A                 mov     [ebp+var_4], 0
.text$mn:0000B131                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B138                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000B13B                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:0000B140                 mov     ecx, [ebp+var_C]
.text$mn:0000B143                 mov     large fs:0, ecx
.text$mn:0000B14A                 pop     ecx
.text$mn:0000B14B                 mov     esp, ebp
.text$mn:0000B14D                 pop     ebp
.text$mn:0000B14E                 retn
.text$mn:0000B14E ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:0000B14E
.text$mn:0000B14E ; ---------------------------------------------------------------------------
.text$mn:0000B14F                 align 10h
.text$mn:0000B14F _text$mn        ends
.text$mn:0000B14F
.text$x:0000B150 ; ===========================================================================
.text$x:0000B150
.text$x:0000B150 ; Segment type: Pure code
.text$x:0000B150 ; Segment permissions: Read/Execute
.text$x:0000B150 _text$x         segment para public 'CODE' use32
.text$x:0000B150                 assume cs:_text$x
.text$x:0000B150                 ;org 0B150h
.text$x:0000B150 ; COMDAT (pick associative to section at B104)
.text$x:0000B150                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B150
.text$x:0000B150 ; =============== S U B R O U T I N E =======================================
.text$x:0000B150
.text$x:0000B150
.text$x:0000B150 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:0000B150                                         ; DATA XREF: .xdata$x:00013B5Co
.text$x:0000B150                 mov     ecx, [ebp-10h]  ; this
.text$x:0000B153                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:0000B153 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:0000B153
.text$x:0000B158
.text$x:0000B158 ; =============== S U B R O U T I N E =======================================
.text$x:0000B158
.text$x:0000B158
.text$x:0000B158 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:0000B158                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)+5o
.text$x:0000B158
.text$x:0000B158 arg_4           = dword ptr  8
.text$x:0000B158
.text$x:0000B158                 mov     edx, [esp+arg_4]
.text$x:0000B15C                 lea     eax, [edx+0Ch]
.text$x:0000B15F                 mov     ecx, [edx-8]
.text$x:0000B162                 xor     ecx, eax
.text$x:0000B164                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B169                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000B16E                 jmp     ___CxxFrameHandler3
.text$x:0000B16E __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000B16E
.text$x:0000B16E ; ---------------------------------------------------------------------------
.text$x:0000B173                 align 4
.text$x:0000B173 _text$x         ends
.text$x:0000B173
.text$mn:0000B174 ; ===========================================================================
.text$mn:0000B174
.text$mn:0000B174 ; Segment type: Pure code
.text$mn:0000B174 ; Segment permissions: Read/Execute
.text$mn:0000B174 _text$mn        segment para public 'CODE' use32
.text$mn:0000B174                 assume cs:_text$mn
.text$mn:0000B174                 ;org 0B174h
.text$mn:0000B174 ; COMDAT (pick any)
.text$mn:0000B174                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B174
.text$mn:0000B174 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B174
.text$mn:0000B174 ; Attributes: bp-based frame
.text$mn:0000B174
.text$mn:0000B174 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, unsigned int, int, unsigned int const *, unsigned int const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, unsigned int, int, unsigned int const *, unsigned int const &, struct std::_Iterator_base12>(void)
.text$mn:0000B174                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000B174 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:0000B174                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:0000B174                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z$0+3j ...
.text$mn:0000B174
.text$mn:0000B174 var_10          = dword ptr -10h
.text$mn:0000B174 var_C           = dword ptr -0Ch
.text$mn:0000B174 var_4           = dword ptr -4
.text$mn:0000B174
.text$mn:0000B174                 push    ebp
.text$mn:0000B175                 mov     ebp, esp
.text$mn:0000B177                 push    0FFFFFFFFh
.text$mn:0000B179                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000B17E                 mov     eax, large fs:0
.text$mn:0000B184                 push    eax
.text$mn:0000B185                 push    ecx
.text$mn:0000B186                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B18B                 xor     eax, ebp
.text$mn:0000B18D                 push    eax
.text$mn:0000B18E                 lea     eax, [ebp+var_C]
.text$mn:0000B191                 mov     large fs:0, eax
.text$mn:0000B197                 mov     [ebp+var_10], ecx
.text$mn:0000B19A                 mov     [ebp+var_4], 0
.text$mn:0000B1A1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B1A8                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000B1AB                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:0000B1B0                 mov     ecx, [ebp+var_C]
.text$mn:0000B1B3                 mov     large fs:0, ecx
.text$mn:0000B1BA                 pop     ecx
.text$mn:0000B1BB                 mov     esp, ebp
.text$mn:0000B1BD                 pop     ebp
.text$mn:0000B1BE                 retn
.text$mn:0000B1BE ??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:0000B1BE
.text$mn:0000B1BE ; ---------------------------------------------------------------------------
.text$mn:0000B1BF                 align 10h
.text$mn:0000B1BF _text$mn        ends
.text$mn:0000B1BF
.text$x:0000B1C0 ; ===========================================================================
.text$x:0000B1C0
.text$x:0000B1C0 ; Segment type: Pure code
.text$x:0000B1C0 ; Segment permissions: Read/Execute
.text$x:0000B1C0 _text$x         segment para public 'CODE' use32
.text$x:0000B1C0                 assume cs:_text$x
.text$x:0000B1C0                 ;org 0B1C0h
.text$x:0000B1C0 ; COMDAT (pick associative to section at B174)
.text$x:0000B1C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B1C0
.text$x:0000B1C0 ; =============== S U B R O U T I N E =======================================
.text$x:0000B1C0
.text$x:0000B1C0
.text$x:0000B1C0 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:0000B1C0                                         ; DATA XREF: .xdata$x:000141B4o
.text$x:0000B1C0                 mov     ecx, [ebp-10h]  ; this
.text$x:0000B1C3                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:0000B1C3 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:0000B1C3
.text$x:0000B1C8
.text$x:0000B1C8 ; =============== S U B R O U T I N E =======================================
.text$x:0000B1C8
.text$x:0000B1C8
.text$x:0000B1C8 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:0000B1C8                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>(void)+5o
.text$x:0000B1C8
.text$x:0000B1C8 arg_4           = dword ptr  8
.text$x:0000B1C8
.text$x:0000B1C8                 mov     edx, [esp+arg_4]
.text$x:0000B1CC                 lea     eax, [edx+0Ch]
.text$x:0000B1CF                 mov     ecx, [edx-8]
.text$x:0000B1D2                 xor     ecx, eax
.text$x:0000B1D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B1D9                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000B1DE                 jmp     ___CxxFrameHandler3
.text$x:0000B1DE __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000B1DE
.text$x:0000B1DE ; ---------------------------------------------------------------------------
.text$x:0000B1E3                 align 4
.text$x:0000B1E3 _text$x         ends
.text$x:0000B1E3
.text$mn:0000B1E4 ; ===========================================================================
.text$mn:0000B1E4
.text$mn:0000B1E4 ; Segment type: Pure code
.text$mn:0000B1E4 ; Segment permissions: Read/Execute
.text$mn:0000B1E4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B1E4                 assume cs:_text$mn
.text$mn:0000B1E4                 ;org 0B1E4h
.text$mn:0000B1E4 ; COMDAT (pick any)
.text$mn:0000B1E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B1E4
.text$mn:0000B1E4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B1E4
.text$mn:0000B1E4 ; Attributes: bp-based frame
.text$mn:0000B1E4
.text$mn:0000B1E4 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct sessionFileInfo, int, struct sessionFileInfo const *, struct sessionFileInfo const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, struct sessionFileInfo, int, struct sessionFileInfo const *, struct sessionFileInfo const &, struct std::_Iterator_base12>(void)
.text$mn:0000B1E4                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000B1E4 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:0000B1E4                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:0000B1E4                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:0000B1E4
.text$mn:0000B1E4 var_10          = dword ptr -10h
.text$mn:0000B1E4 var_C           = dword ptr -0Ch
.text$mn:0000B1E4 var_4           = dword ptr -4
.text$mn:0000B1E4
.text$mn:0000B1E4                 push    ebp
.text$mn:0000B1E5                 mov     ebp, esp
.text$mn:0000B1E7                 push    0FFFFFFFFh
.text$mn:0000B1E9                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000B1EE                 mov     eax, large fs:0
.text$mn:0000B1F4                 push    eax
.text$mn:0000B1F5                 push    ecx
.text$mn:0000B1F6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B1FB                 xor     eax, ebp
.text$mn:0000B1FD                 push    eax
.text$mn:0000B1FE                 lea     eax, [ebp+var_C]
.text$mn:0000B201                 mov     large fs:0, eax
.text$mn:0000B207                 mov     [ebp+var_10], ecx
.text$mn:0000B20A                 mov     [ebp+var_4], 0
.text$mn:0000B211                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B218                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000B21B                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:0000B220                 mov     ecx, [ebp+var_C]
.text$mn:0000B223                 mov     large fs:0, ecx
.text$mn:0000B22A                 pop     ecx
.text$mn:0000B22B                 mov     esp, ebp
.text$mn:0000B22D                 pop     ebp
.text$mn:0000B22E                 retn
.text$mn:0000B22E ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:0000B22E
.text$mn:0000B22E ; ---------------------------------------------------------------------------
.text$mn:0000B22F                 align 10h
.text$mn:0000B22F _text$mn        ends
.text$mn:0000B22F
.text$x:0000B230 ; ===========================================================================
.text$x:0000B230
.text$x:0000B230 ; Segment type: Pure code
.text$x:0000B230 ; Segment permissions: Read/Execute
.text$x:0000B230 _text$x         segment para public 'CODE' use32
.text$x:0000B230                 assume cs:_text$x
.text$x:0000B230                 ;org 0B230h
.text$x:0000B230 ; COMDAT (pick associative to section at B1E4)
.text$x:0000B230                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B230
.text$x:0000B230 ; =============== S U B R O U T I N E =======================================
.text$x:0000B230
.text$x:0000B230
.text$x:0000B230 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:0000B230                                         ; DATA XREF: .xdata$x:00013C0Co
.text$x:0000B230                 mov     ecx, [ebp-10h]  ; this
.text$x:0000B233                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:0000B233 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:0000B233
.text$x:0000B238
.text$x:0000B238 ; =============== S U B R O U T I N E =======================================
.text$x:0000B238
.text$x:0000B238
.text$x:0000B238 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:0000B238                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>(void)+5o
.text$x:0000B238
.text$x:0000B238 arg_4           = dword ptr  8
.text$x:0000B238
.text$x:0000B238                 mov     edx, [esp+arg_4]
.text$x:0000B23C                 lea     eax, [edx+0Ch]
.text$x:0000B23F                 mov     ecx, [edx-8]
.text$x:0000B242                 xor     ecx, eax
.text$x:0000B244                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B249                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000B24E                 jmp     ___CxxFrameHandler3
.text$x:0000B24E __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000B24E
.text$x:0000B24E ; ---------------------------------------------------------------------------
.text$x:0000B253                 align 4
.text$x:0000B253 _text$x         ends
.text$x:0000B253
.text$mn:0000B254 ; ===========================================================================
.text$mn:0000B254
.text$mn:0000B254 ; Segment type: Pure code
.text$mn:0000B254 ; Segment permissions: Read/Execute
.text$mn:0000B254 _text$mn        segment para public 'CODE' use32
.text$mn:0000B254                 assume cs:_text$mn
.text$mn:0000B254                 ;org 0B254h
.text$mn:0000B254 ; COMDAT (pick any)
.text$mn:0000B254                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B254
.text$mn:0000B254 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B254
.text$mn:0000B254 ; Attributes: bp-based frame
.text$mn:0000B254
.text$mn:0000B254 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>(void)
.text$mn:0000B254                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000B254 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:0000B254                                         ; CODE XREF: __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:0000B254                                         ; __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0+3j ...
.text$mn:0000B254
.text$mn:0000B254 var_10          = dword ptr -10h
.text$mn:0000B254 var_C           = dword ptr -0Ch
.text$mn:0000B254 var_4           = dword ptr -4
.text$mn:0000B254
.text$mn:0000B254                 push    ebp
.text$mn:0000B255                 mov     ebp, esp
.text$mn:0000B257                 push    0FFFFFFFFh
.text$mn:0000B259                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000B25E                 mov     eax, large fs:0
.text$mn:0000B264                 push    eax
.text$mn:0000B265                 push    ecx
.text$mn:0000B266                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B26B                 xor     eax, ebp
.text$mn:0000B26D                 push    eax
.text$mn:0000B26E                 lea     eax, [ebp+var_C]
.text$mn:0000B271                 mov     large fs:0, eax
.text$mn:0000B277                 mov     [ebp+var_10], ecx
.text$mn:0000B27A                 mov     [ebp+var_4], 0
.text$mn:0000B281                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B288                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000B28B                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:0000B290                 mov     ecx, [ebp+var_C]
.text$mn:0000B293                 mov     large fs:0, ecx
.text$mn:0000B29A                 pop     ecx
.text$mn:0000B29B                 mov     esp, ebp
.text$mn:0000B29D                 pop     ebp
.text$mn:0000B29E                 retn
.text$mn:0000B29E ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:0000B29E
.text$mn:0000B29E ; ---------------------------------------------------------------------------
.text$mn:0000B29F                 align 10h
.text$mn:0000B29F _text$mn        ends
.text$mn:0000B29F
.text$x:0000B2A0 ; ===========================================================================
.text$x:0000B2A0
.text$x:0000B2A0 ; Segment type: Pure code
.text$x:0000B2A0 ; Segment permissions: Read/Execute
.text$x:0000B2A0 _text$x         segment para public 'CODE' use32
.text$x:0000B2A0                 assume cs:_text$x
.text$x:0000B2A0                 ;org 0B2A0h
.text$x:0000B2A0 ; COMDAT (pick associative to section at B254)
.text$x:0000B2A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B2A0
.text$x:0000B2A0 ; =============== S U B R O U T I N E =======================================
.text$x:0000B2A0
.text$x:0000B2A0
.text$x:0000B2A0 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:0000B2A0                                         ; DATA XREF: .xdata$x:00013A54o
.text$x:0000B2A0                 mov     ecx, [ebp-10h]  ; this
.text$x:0000B2A3                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:0000B2A3 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:0000B2A3
.text$x:0000B2A8
.text$x:0000B2A8 ; =============== S U B R O U T I N E =======================================
.text$x:0000B2A8
.text$x:0000B2A8
.text$x:0000B2A8 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:0000B2A8                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)+5o
.text$x:0000B2A8
.text$x:0000B2A8 arg_4           = dword ptr  8
.text$x:0000B2A8
.text$x:0000B2A8                 mov     edx, [esp+arg_4]
.text$x:0000B2AC                 lea     eax, [edx+0Ch]
.text$x:0000B2AF                 mov     ecx, [edx-8]
.text$x:0000B2B2                 xor     ecx, eax
.text$x:0000B2B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B2B9                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000B2BE                 jmp     ___CxxFrameHandler3
.text$x:0000B2BE __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000B2BE
.text$x:0000B2BE ; ---------------------------------------------------------------------------
.text$x:0000B2C3                 align 4
.text$x:0000B2C3 _text$x         ends
.text$x:0000B2C3
.text$mn:0000B2C4 ; ===========================================================================
.text$mn:0000B2C4
.text$mn:0000B2C4 ; Segment type: Pure code
.text$mn:0000B2C4 ; Segment permissions: Read/Execute
.text$mn:0000B2C4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B2C4                 assume cs:_text$mn
.text$mn:0000B2C4                 ;org 0B2C4h
.text$mn:0000B2C4 ; COMDAT (pick any)
.text$mn:0000B2C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B2C4
.text$mn:0000B2C4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B2C4
.text$mn:0000B2C4 ; Attributes: bp-based frame
.text$mn:0000B2C4
.text$mn:0000B2C4 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:0000B2C4                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000B2C4 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000B2C4                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:0000B2C4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:0000B2C4
.text$mn:0000B2C4 var_10          = dword ptr -10h
.text$mn:0000B2C4 var_C           = dword ptr -0Ch
.text$mn:0000B2C4 var_4           = dword ptr -4
.text$mn:0000B2C4
.text$mn:0000B2C4                 push    ebp
.text$mn:0000B2C5                 mov     ebp, esp
.text$mn:0000B2C7                 push    0FFFFFFFFh
.text$mn:0000B2C9                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000B2CE                 mov     eax, large fs:0
.text$mn:0000B2D4                 push    eax
.text$mn:0000B2D5                 push    ecx
.text$mn:0000B2D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B2DB                 xor     eax, ebp
.text$mn:0000B2DD                 push    eax
.text$mn:0000B2DE                 lea     eax, [ebp+var_C]
.text$mn:0000B2E1                 mov     large fs:0, eax
.text$mn:0000B2E7                 mov     [ebp+var_10], ecx
.text$mn:0000B2EA                 mov     [ebp+var_4], 0
.text$mn:0000B2F1                 mov     ecx, [ebp+var_10]
.text$mn:0000B2F4                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:0000B2F9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B300                 mov     ecx, [ebp+var_10]
.text$mn:0000B303                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:0000B308                 mov     ecx, [ebp+var_C]
.text$mn:0000B30B                 mov     large fs:0, ecx
.text$mn:0000B312                 pop     ecx
.text$mn:0000B313                 mov     esp, ebp
.text$mn:0000B315                 pop     ebp
.text$mn:0000B316                 retn
.text$mn:0000B316 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000B316
.text$mn:0000B316 ; ---------------------------------------------------------------------------
.text$mn:0000B317                 align 4
.text$mn:0000B317 _text$mn        ends
.text$mn:0000B317
.text$x:0000B318 ; ===========================================================================
.text$x:0000B318
.text$x:0000B318 ; Segment type: Pure code
.text$x:0000B318 ; Segment permissions: Read/Execute
.text$x:0000B318 _text$x         segment para public 'CODE' use32
.text$x:0000B318                 assume cs:_text$x
.text$x:0000B318                 ;org 0B318h
.text$x:0000B318 ; COMDAT (pick associative to section at B2C4)
.text$x:0000B318                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B318
.text$x:0000B318 ; =============== S U B R O U T I N E =======================================
.text$x:0000B318
.text$x:0000B318
.text$x:0000B318 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B318                                         ; DATA XREF: .xdata$x:000124ACo
.text$x:0000B318                 mov     ecx, [ebp-10h]
.text$x:0000B31B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000B31B __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000B31B
.text$x:0000B320
.text$x:0000B320 ; =============== S U B R O U T I N E =======================================
.text$x:0000B320
.text$x:0000B320
.text$x:0000B320 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000B320                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:0000B320
.text$x:0000B320 arg_4           = dword ptr  8
.text$x:0000B320
.text$x:0000B320                 mov     edx, [esp+arg_4]
.text$x:0000B324                 lea     eax, [edx+0Ch]
.text$x:0000B327                 mov     ecx, [edx-8]
.text$x:0000B32A                 xor     ecx, eax
.text$x:0000B32C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B331                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:0000B336                 jmp     ___CxxFrameHandler3
.text$x:0000B336 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:0000B336
.text$x:0000B336 ; ---------------------------------------------------------------------------
.text$x:0000B33B                 align 4
.text$x:0000B33B _text$x         ends
.text$x:0000B33B
.text$mn:0000B33C ; ===========================================================================
.text$mn:0000B33C
.text$mn:0000B33C ; Segment type: Pure code
.text$mn:0000B33C ; Segment permissions: Read/Execute
.text$mn:0000B33C _text$mn        segment para public 'CODE' use32
.text$mn:0000B33C                 assume cs:_text$mn
.text$mn:0000B33C                 ;org 0B33Ch
.text$mn:0000B33C ; COMDAT (pick any)
.text$mn:0000B33C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B33C
.text$mn:0000B33C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B33C
.text$mn:0000B33C ; Attributes: bp-based frame
.text$mn:0000B33C
.text$mn:0000B33C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:0000B33C                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:0000B33C ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000B33C                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0+3j
.text$mn:0000B33C                                         ; __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0+3j ...
.text$mn:0000B33C
.text$mn:0000B33C var_10          = dword ptr -10h
.text$mn:0000B33C var_C           = dword ptr -0Ch
.text$mn:0000B33C var_4           = dword ptr -4
.text$mn:0000B33C
.text$mn:0000B33C                 push    ebp
.text$mn:0000B33D                 mov     ebp, esp
.text$mn:0000B33F                 push    0FFFFFFFFh
.text$mn:0000B341                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:0000B346                 mov     eax, large fs:0
.text$mn:0000B34C                 push    eax
.text$mn:0000B34D                 push    ecx
.text$mn:0000B34E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B353                 xor     eax, ebp
.text$mn:0000B355                 push    eax
.text$mn:0000B356                 lea     eax, [ebp+var_C]
.text$mn:0000B359                 mov     large fs:0, eax
.text$mn:0000B35F                 mov     [ebp+var_10], ecx
.text$mn:0000B362                 mov     [ebp+var_4], 0
.text$mn:0000B369                 mov     ecx, [ebp+var_10]
.text$mn:0000B36C                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:0000B371                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B378                 mov     ecx, [ebp+var_10]
.text$mn:0000B37B                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:0000B380                 mov     ecx, [ebp+var_C]
.text$mn:0000B383                 mov     large fs:0, ecx
.text$mn:0000B38A                 pop     ecx
.text$mn:0000B38B                 mov     esp, ebp
.text$mn:0000B38D                 pop     ebp
.text$mn:0000B38E                 retn
.text$mn:0000B38E ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000B38E
.text$mn:0000B38E ; ---------------------------------------------------------------------------
.text$mn:0000B38F                 align 10h
.text$mn:0000B38F _text$mn        ends
.text$mn:0000B38F
.text$x:0000B390 ; ===========================================================================
.text$x:0000B390
.text$x:0000B390 ; Segment type: Pure code
.text$x:0000B390 ; Segment permissions: Read/Execute
.text$x:0000B390 _text$x         segment para public 'CODE' use32
.text$x:0000B390                 assume cs:_text$x
.text$x:0000B390                 ;org 0B390h
.text$x:0000B390 ; COMDAT (pick associative to section at B33C)
.text$x:0000B390                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B390
.text$x:0000B390 ; =============== S U B R O U T I N E =======================================
.text$x:0000B390
.text$x:0000B390
.text$x:0000B390 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B390                                         ; DATA XREF: .xdata$x:000127CCo
.text$x:0000B390                 mov     ecx, [ebp-10h]
.text$x:0000B393                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:0000B393 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000B393
.text$x:0000B398
.text$x:0000B398 ; =============== S U B R O U T I N E =======================================
.text$x:0000B398
.text$x:0000B398
.text$x:0000B398 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000B398                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:0000B398
.text$x:0000B398 arg_4           = dword ptr  8
.text$x:0000B398
.text$x:0000B398                 mov     edx, [esp+arg_4]
.text$x:0000B39C                 lea     eax, [edx+0Ch]
.text$x:0000B39F                 mov     ecx, [edx-8]
.text$x:0000B3A2                 xor     ecx, eax
.text$x:0000B3A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B3A9                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:0000B3AE                 jmp     ___CxxFrameHandler3
.text$x:0000B3AE __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:0000B3AE
.text$x:0000B3AE ; ---------------------------------------------------------------------------
.text$x:0000B3B3                 align 4
.text$x:0000B3B3 _text$x         ends
.text$x:0000B3B3
.text$mn:0000B3B4 ; ===========================================================================
.text$mn:0000B3B4
.text$mn:0000B3B4 ; Segment type: Pure code
.text$mn:0000B3B4 ; Segment permissions: Read/Execute
.text$mn:0000B3B4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B3B4                 assume cs:_text$mn
.text$mn:0000B3B4                 ;org 0B3B4h
.text$mn:0000B3B4 ; COMDAT (pick any)
.text$mn:0000B3B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B3B4
.text$mn:0000B3B4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B3B4
.text$mn:0000B3B4 ; Attributes: bp-based frame
.text$mn:0000B3B4
.text$mn:0000B3B4 ; public: __thiscall std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::~_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>(void)
.text$mn:0000B3B4                 public ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:0000B3B4 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000B3B4                                         ; CODE XREF: __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$5+3j
.text$mn:0000B3B4                                         ; __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$7+3j ...
.text$mn:0000B3B4
.text$mn:0000B3B4 var_10          = dword ptr -10h
.text$mn:0000B3B4 var_C           = dword ptr -0Ch
.text$mn:0000B3B4 var_4           = dword ptr -4
.text$mn:0000B3B4
.text$mn:0000B3B4                 push    ebp
.text$mn:0000B3B5                 mov     ebp, esp
.text$mn:0000B3B7                 push    0FFFFFFFFh
.text$mn:0000B3B9                 push    offset __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:0000B3BE                 mov     eax, large fs:0
.text$mn:0000B3C4                 push    eax
.text$mn:0000B3C5                 push    ecx
.text$mn:0000B3C6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B3CB                 xor     eax, ebp
.text$mn:0000B3CD                 push    eax
.text$mn:0000B3CE                 lea     eax, [ebp+var_C]
.text$mn:0000B3D1                 mov     large fs:0, eax
.text$mn:0000B3D7                 mov     [ebp+var_10], ecx
.text$mn:0000B3DA                 mov     [ebp+var_4], 0
.text$mn:0000B3E1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B3E8                 mov     ecx, [ebp+var_10]
.text$mn:0000B3EB                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$mn:0000B3F0                 mov     ecx, [ebp+var_C]
.text$mn:0000B3F3                 mov     large fs:0, ecx
.text$mn:0000B3FA                 pop     ecx
.text$mn:0000B3FB                 mov     esp, ebp
.text$mn:0000B3FD                 pop     ebp
.text$mn:0000B3FE                 retn
.text$mn:0000B3FE ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000B3FE
.text$mn:0000B3FE ; ---------------------------------------------------------------------------
.text$mn:0000B3FF                 align 10h
.text$mn:0000B3FF _text$mn        ends
.text$mn:0000B3FF
.text$x:0000B400 ; ===========================================================================
.text$x:0000B400
.text$x:0000B400 ; Segment type: Pure code
.text$x:0000B400 ; Segment permissions: Read/Execute
.text$x:0000B400 _text$x         segment para public 'CODE' use32
.text$x:0000B400                 assume cs:_text$x
.text$x:0000B400                 ;org 0B400h
.text$x:0000B400 ; COMDAT (pick associative to section at B3B4)
.text$x:0000B400                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B400
.text$x:0000B400 ; =============== S U B R O U T I N E =======================================
.text$x:0000B400
.text$x:0000B400
.text$x:0000B400 __unwindfunclet$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B400                                         ; DATA XREF: .xdata$x:00013AD8o
.text$x:0000B400                 mov     ecx, [ebp-10h]
.text$x:0000B403                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$x:0000B403 __unwindfunclet$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000B403
.text$x:0000B408
.text$x:0000B408 ; =============== S U B R O U T I N E =======================================
.text$x:0000B408
.text$x:0000B408
.text$x:0000B408 __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000B408                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)+5o
.text$x:0000B408
.text$x:0000B408 arg_4           = dword ptr  8
.text$x:0000B408
.text$x:0000B408                 mov     edx, [esp+arg_4]
.text$x:0000B40C                 lea     eax, [edx+0Ch]
.text$x:0000B40F                 mov     ecx, [edx-8]
.text$x:0000B412                 xor     ecx, eax
.text$x:0000B414                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B419                 mov     eax, offset __ehfuncinfo$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$x:0000B41E                 jmp     ___CxxFrameHandler3
.text$x:0000B41E __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:0000B41E
.text$x:0000B41E ; ---------------------------------------------------------------------------
.text$x:0000B423                 align 4
.text$x:0000B423 _text$x         ends
.text$x:0000B423
.text$mn:0000B424 ; ===========================================================================
.text$mn:0000B424
.text$mn:0000B424 ; Segment type: Pure code
.text$mn:0000B424 ; Segment permissions: Read/Execute
.text$mn:0000B424 _text$mn        segment para public 'CODE' use32
.text$mn:0000B424                 assume cs:_text$mn
.text$mn:0000B424                 ;org 0B424h
.text$mn:0000B424 ; COMDAT (pick any)
.text$mn:0000B424                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B424
.text$mn:0000B424 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B424
.text$mn:0000B424 ; Attributes: bp-based frame
.text$mn:0000B424
.text$mn:0000B424 ; public: __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::~_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>(void)
.text$mn:0000B424                 public ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:0000B424 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000B424                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+F5p
.text$mn:0000B424                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+101p ...
.text$mn:0000B424
.text$mn:0000B424 var_10          = dword ptr -10h
.text$mn:0000B424 var_C           = dword ptr -0Ch
.text$mn:0000B424 var_4           = dword ptr -4
.text$mn:0000B424
.text$mn:0000B424                 push    ebp
.text$mn:0000B425                 mov     ebp, esp
.text$mn:0000B427                 push    0FFFFFFFFh
.text$mn:0000B429                 push    offset __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:0000B42E                 mov     eax, large fs:0
.text$mn:0000B434                 push    eax
.text$mn:0000B435                 push    ecx
.text$mn:0000B436                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B43B                 xor     eax, ebp
.text$mn:0000B43D                 push    eax
.text$mn:0000B43E                 lea     eax, [ebp+var_C]
.text$mn:0000B441                 mov     large fs:0, eax
.text$mn:0000B447                 mov     [ebp+var_10], ecx
.text$mn:0000B44A                 mov     [ebp+var_4], 0
.text$mn:0000B451                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B458                 mov     ecx, [ebp+var_10]
.text$mn:0000B45B                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000B460                 mov     ecx, [ebp+var_C]
.text$mn:0000B463                 mov     large fs:0, ecx
.text$mn:0000B46A                 pop     ecx
.text$mn:0000B46B                 mov     esp, ebp
.text$mn:0000B46D                 pop     ebp
.text$mn:0000B46E                 retn
.text$mn:0000B46E ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000B46E
.text$mn:0000B46E ; ---------------------------------------------------------------------------
.text$mn:0000B46F                 align 10h
.text$mn:0000B46F _text$mn        ends
.text$mn:0000B46F
.text$x:0000B470 ; ===========================================================================
.text$x:0000B470
.text$x:0000B470 ; Segment type: Pure code
.text$x:0000B470 ; Segment permissions: Read/Execute
.text$x:0000B470 _text$x         segment para public 'CODE' use32
.text$x:0000B470                 assume cs:_text$x
.text$x:0000B470                 ;org 0B470h
.text$x:0000B470 ; COMDAT (pick associative to section at B424)
.text$x:0000B470                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B470
.text$x:0000B470 ; =============== S U B R O U T I N E =======================================
.text$x:0000B470
.text$x:0000B470
.text$x:0000B470 __unwindfunclet$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B470                                         ; DATA XREF: .xdata$x:00013DF8o
.text$x:0000B470                 mov     ecx, [ebp-10h]
.text$x:0000B473                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000B473 __unwindfunclet$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000B473
.text$x:0000B478
.text$x:0000B478 ; =============== S U B R O U T I N E =======================================
.text$x:0000B478
.text$x:0000B478
.text$x:0000B478 __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000B478                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)+5o
.text$x:0000B478
.text$x:0000B478 arg_4           = dword ptr  8
.text$x:0000B478
.text$x:0000B478                 mov     edx, [esp+arg_4]
.text$x:0000B47C                 lea     eax, [edx+0Ch]
.text$x:0000B47F                 mov     ecx, [edx-8]
.text$x:0000B482                 xor     ecx, eax
.text$x:0000B484                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B489                 mov     eax, offset __ehfuncinfo$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$x:0000B48E                 jmp     ___CxxFrameHandler3
.text$x:0000B48E __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:0000B48E
.text$x:0000B48E ; ---------------------------------------------------------------------------
.text$x:0000B493                 align 4
.text$x:0000B493 _text$x         ends
.text$x:0000B493
.text$mn:0000B494 ; ===========================================================================
.text$mn:0000B494
.text$mn:0000B494 ; Segment type: Pure code
.text$mn:0000B494 ; Segment permissions: Read/Execute
.text$mn:0000B494 _text$mn        segment para public 'CODE' use32
.text$mn:0000B494                 assume cs:_text$mn
.text$mn:0000B494                 ;org 0B494h
.text$mn:0000B494 ; COMDAT (pick any)
.text$mn:0000B494                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B494
.text$mn:0000B494 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B494
.text$mn:0000B494 ; Attributes: bp-based frame
.text$mn:0000B494
.text$mn:0000B494 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:0000B494                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000B494 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:0000B494                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:0000B494                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:0000B494
.text$mn:0000B494 var_10          = dword ptr -10h
.text$mn:0000B494 var_C           = dword ptr -0Ch
.text$mn:0000B494 var_4           = dword ptr -4
.text$mn:0000B494
.text$mn:0000B494                 push    ebp
.text$mn:0000B495                 mov     ebp, esp
.text$mn:0000B497                 push    0FFFFFFFFh
.text$mn:0000B499                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000B49E                 mov     eax, large fs:0
.text$mn:0000B4A4                 push    eax
.text$mn:0000B4A5                 push    ecx
.text$mn:0000B4A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B4AB                 xor     eax, ebp
.text$mn:0000B4AD                 push    eax
.text$mn:0000B4AE                 lea     eax, [ebp+var_C]
.text$mn:0000B4B1                 mov     large fs:0, eax
.text$mn:0000B4B7                 mov     [ebp+var_10], ecx
.text$mn:0000B4BA                 mov     [ebp+var_4], 0
.text$mn:0000B4C1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B4C8                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000B4CB                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000B4D0                 mov     ecx, [ebp+var_C]
.text$mn:0000B4D3                 mov     large fs:0, ecx
.text$mn:0000B4DA                 pop     ecx
.text$mn:0000B4DB                 mov     esp, ebp
.text$mn:0000B4DD                 pop     ebp
.text$mn:0000B4DE                 retn
.text$mn:0000B4DE ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000B4DE
.text$mn:0000B4DE ; ---------------------------------------------------------------------------
.text$mn:0000B4DF                 align 10h
.text$mn:0000B4DF _text$mn        ends
.text$mn:0000B4DF
.text$x:0000B4E0 ; ===========================================================================
.text$x:0000B4E0
.text$x:0000B4E0 ; Segment type: Pure code
.text$x:0000B4E0 ; Segment permissions: Read/Execute
.text$x:0000B4E0 _text$x         segment para public 'CODE' use32
.text$x:0000B4E0                 assume cs:_text$x
.text$x:0000B4E0                 ;org 0B4E0h
.text$x:0000B4E0 ; COMDAT (pick associative to section at B494)
.text$x:0000B4E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B4E0
.text$x:0000B4E0 ; =============== S U B R O U T I N E =======================================
.text$x:0000B4E0
.text$x:0000B4E0
.text$x:0000B4E0 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B4E0                                         ; DATA XREF: .xdata$x:00012454o
.text$x:0000B4E0                 mov     ecx, [ebp-10h]  ; this
.text$x:0000B4E3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000B4E3 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000B4E3
.text$x:0000B4E8
.text$x:0000B4E8 ; =============== S U B R O U T I N E =======================================
.text$x:0000B4E8
.text$x:0000B4E8
.text$x:0000B4E8 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:0000B4E8                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:0000B4E8
.text$x:0000B4E8 arg_4           = dword ptr  8
.text$x:0000B4E8
.text$x:0000B4E8                 mov     edx, [esp+arg_4]
.text$x:0000B4EC                 lea     eax, [edx+0Ch]
.text$x:0000B4EF                 mov     ecx, [edx-8]
.text$x:0000B4F2                 xor     ecx, eax
.text$x:0000B4F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B4F9                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000B4FE                 jmp     ___CxxFrameHandler3
.text$x:0000B4FE __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000B4FE
.text$x:0000B4FE ; ---------------------------------------------------------------------------
.text$x:0000B503                 align 4
.text$x:0000B503 _text$x         ends
.text$x:0000B503
.text$mn:0000B504 ; ===========================================================================
.text$mn:0000B504
.text$mn:0000B504 ; Segment type: Pure code
.text$mn:0000B504 ; Segment permissions: Read/Execute
.text$mn:0000B504 _text$mn        segment para public 'CODE' use32
.text$mn:0000B504                 assume cs:_text$mn
.text$mn:0000B504                 ;org 0B504h
.text$mn:0000B504 ; COMDAT (pick any)
.text$mn:0000B504                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B504
.text$mn:0000B504 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B504
.text$mn:0000B504 ; Attributes: bp-based frame
.text$mn:0000B504
.text$mn:0000B504 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:0000B504                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:0000B504 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:0000B504                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:0000B504                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:0000B504
.text$mn:0000B504 var_10          = dword ptr -10h
.text$mn:0000B504 var_C           = dword ptr -0Ch
.text$mn:0000B504 var_4           = dword ptr -4
.text$mn:0000B504
.text$mn:0000B504                 push    ebp
.text$mn:0000B505                 mov     ebp, esp
.text$mn:0000B507                 push    0FFFFFFFFh
.text$mn:0000B509                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:0000B50E                 mov     eax, large fs:0
.text$mn:0000B514                 push    eax
.text$mn:0000B515                 push    ecx
.text$mn:0000B516                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B51B                 xor     eax, ebp
.text$mn:0000B51D                 push    eax
.text$mn:0000B51E                 lea     eax, [ebp+var_C]
.text$mn:0000B521                 mov     large fs:0, eax
.text$mn:0000B527                 mov     [ebp+var_10], ecx
.text$mn:0000B52A                 mov     [ebp+var_4], 0
.text$mn:0000B531                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B538                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000B53B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000B540                 mov     ecx, [ebp+var_C]
.text$mn:0000B543                 mov     large fs:0, ecx
.text$mn:0000B54A                 pop     ecx
.text$mn:0000B54B                 mov     esp, ebp
.text$mn:0000B54D                 pop     ebp
.text$mn:0000B54E                 retn
.text$mn:0000B54E ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:0000B54E
.text$mn:0000B54E ; ---------------------------------------------------------------------------
.text$mn:0000B54F                 align 10h
.text$mn:0000B54F _text$mn        ends
.text$mn:0000B54F
.text$x:0000B550 ; ===========================================================================
.text$x:0000B550
.text$x:0000B550 ; Segment type: Pure code
.text$x:0000B550 ; Segment permissions: Read/Execute
.text$x:0000B550 _text$x         segment para public 'CODE' use32
.text$x:0000B550                 assume cs:_text$x
.text$x:0000B550                 ;org 0B550h
.text$x:0000B550 ; COMDAT (pick associative to section at B504)
.text$x:0000B550                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B550
.text$x:0000B550 ; =============== S U B R O U T I N E =======================================
.text$x:0000B550
.text$x:0000B550
.text$x:0000B550 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B550                                         ; DATA XREF: .xdata$x:00012774o
.text$x:0000B550                 mov     ecx, [ebp-10h]  ; this
.text$x:0000B553                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000B553 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:0000B553
.text$x:0000B558
.text$x:0000B558 ; =============== S U B R O U T I N E =======================================
.text$x:0000B558
.text$x:0000B558
.text$x:0000B558 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:0000B558                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:0000B558
.text$x:0000B558 arg_4           = dword ptr  8
.text$x:0000B558
.text$x:0000B558                 mov     edx, [esp+arg_4]
.text$x:0000B55C                 lea     eax, [edx+0Ch]
.text$x:0000B55F                 mov     ecx, [edx-8]
.text$x:0000B562                 xor     ecx, eax
.text$x:0000B564                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B569                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:0000B56E                 jmp     ___CxxFrameHandler3
.text$x:0000B56E __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:0000B56E
.text$x:0000B56E ; ---------------------------------------------------------------------------
.text$x:0000B573                 align 4
.text$x:0000B573 _text$x         ends
.text$x:0000B573
.text$mn:0000B574 ; ===========================================================================
.text$mn:0000B574
.text$mn:0000B574 ; Segment type: Pure code
.text$mn:0000B574 ; Segment permissions: Read/Execute
.text$mn:0000B574 _text$mn        segment para public 'CODE' use32
.text$mn:0000B574                 assume cs:_text$mn
.text$mn:0000B574                 ;org 0B574h
.text$mn:0000B574 ; COMDAT (pick any)
.text$mn:0000B574                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B574
.text$mn:0000B574 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B574
.text$mn:0000B574 ; Attributes: bp-based frame
.text$mn:0000B574
.text$mn:0000B574 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::~_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>(void)
.text$mn:0000B574                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
.text$mn:0000B574 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000B574                                         ; CODE XREF: __unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0+3j
.text$mn:0000B574                                         ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)+3Fp ...
.text$mn:0000B574
.text$mn:0000B574 var_10          = dword ptr -10h
.text$mn:0000B574 var_C           = dword ptr -0Ch
.text$mn:0000B574 var_4           = dword ptr -4
.text$mn:0000B574
.text$mn:0000B574                 push    ebp
.text$mn:0000B575                 mov     ebp, esp
.text$mn:0000B577                 push    0FFFFFFFFh
.text$mn:0000B579                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
.text$mn:0000B57E                 mov     eax, large fs:0
.text$mn:0000B584                 push    eax
.text$mn:0000B585                 push    ecx
.text$mn:0000B586                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B58B                 xor     eax, ebp
.text$mn:0000B58D                 push    eax
.text$mn:0000B58E                 lea     eax, [ebp+var_C]
.text$mn:0000B591                 mov     large fs:0, eax
.text$mn:0000B597                 mov     [ebp+var_10], ecx
.text$mn:0000B59A                 mov     [ebp+var_4], 0
.text$mn:0000B5A1                 mov     ecx, [ebp+var_10]
.text$mn:0000B5A4                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Free_proxy(void)
.text$mn:0000B5A9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B5B0                 mov     ecx, [ebp+var_10]
.text$mn:0000B5B3                 call    ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int>>::~_Vector_val<std::_Simple_types<int>>(void)
.text$mn:0000B5B8                 mov     ecx, [ebp+var_C]
.text$mn:0000B5BB                 mov     large fs:0, ecx
.text$mn:0000B5C2                 pop     ecx
.text$mn:0000B5C3                 mov     esp, ebp
.text$mn:0000B5C5                 pop     ebp
.text$mn:0000B5C6                 retn
.text$mn:0000B5C6 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000B5C6
.text$mn:0000B5C6 ; ---------------------------------------------------------------------------
.text$mn:0000B5C7                 align 4
.text$mn:0000B5C7 _text$mn        ends
.text$mn:0000B5C7
.text$x:0000B5C8 ; ===========================================================================
.text$x:0000B5C8
.text$x:0000B5C8 ; Segment type: Pure code
.text$x:0000B5C8 ; Segment permissions: Read/Execute
.text$x:0000B5C8 _text$x         segment para public 'CODE' use32
.text$x:0000B5C8                 assume cs:_text$x
.text$x:0000B5C8                 ;org 0B5C8h
.text$x:0000B5C8 ; COMDAT (pick associative to section at B574)
.text$x:0000B5C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B5C8
.text$x:0000B5C8 ; =============== S U B R O U T I N E =======================================
.text$x:0000B5C8
.text$x:0000B5C8
.text$x:0000B5C8 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B5C8                                         ; DATA XREF: .xdata$x:00012BBCo
.text$x:0000B5C8                 mov     ecx, [ebp-10h]
.text$x:0000B5CB                 jmp     ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int>>::~_Vector_val<std::_Simple_types<int>>(void)
.text$x:0000B5CB __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000B5CB
.text$x:0000B5D0
.text$x:0000B5D0 ; =============== S U B R O U T I N E =======================================
.text$x:0000B5D0
.text$x:0000B5D0
.text$x:0000B5D0 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000B5D0                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)+5o
.text$x:0000B5D0
.text$x:0000B5D0 arg_4           = dword ptr  8
.text$x:0000B5D0
.text$x:0000B5D0                 mov     edx, [esp+arg_4]
.text$x:0000B5D4                 lea     eax, [edx+0Ch]
.text$x:0000B5D7                 mov     ecx, [edx-8]
.text$x:0000B5DA                 xor     ecx, eax
.text$x:0000B5DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B5E1                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
.text$x:0000B5E6                 jmp     ___CxxFrameHandler3
.text$x:0000B5E6 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ endp
.text$x:0000B5E6
.text$x:0000B5E6 ; ---------------------------------------------------------------------------
.text$x:0000B5EB                 align 4
.text$x:0000B5EB _text$x         ends
.text$x:0000B5EB
.text$mn:0000B5EC ; ===========================================================================
.text$mn:0000B5EC
.text$mn:0000B5EC ; Segment type: Pure code
.text$mn:0000B5EC ; Segment permissions: Read/Execute
.text$mn:0000B5EC _text$mn        segment para public 'CODE' use32
.text$mn:0000B5EC                 assume cs:_text$mn
.text$mn:0000B5EC                 ;org 0B5ECh
.text$mn:0000B5EC ; COMDAT (pick any)
.text$mn:0000B5EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B5EC
.text$mn:0000B5EC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B5EC
.text$mn:0000B5EC ; Attributes: bp-based frame
.text$mn:0000B5EC
.text$mn:0000B5EC ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned int, class std::allocator<unsigned int>>>::~_Vector_alloc<0, struct std::_Vec_base_types<unsigned int, class std::allocator<unsigned int>>>(void)
.text$mn:0000B5EC                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.text$mn:0000B5EC ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000B5EC                                         ; CODE XREF: __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$2+3j
.text$mn:0000B5EC                                         ; __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0+3j ...
.text$mn:0000B5EC
.text$mn:0000B5EC var_10          = dword ptr -10h
.text$mn:0000B5EC var_C           = dword ptr -0Ch
.text$mn:0000B5EC var_4           = dword ptr -4
.text$mn:0000B5EC
.text$mn:0000B5EC                 push    ebp
.text$mn:0000B5ED                 mov     ebp, esp
.text$mn:0000B5EF                 push    0FFFFFFFFh
.text$mn:0000B5F1                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.text$mn:0000B5F6                 mov     eax, large fs:0
.text$mn:0000B5FC                 push    eax
.text$mn:0000B5FD                 push    ecx
.text$mn:0000B5FE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B603                 xor     eax, ebp
.text$mn:0000B605                 push    eax
.text$mn:0000B606                 lea     eax, [ebp+var_C]
.text$mn:0000B609                 mov     large fs:0, eax
.text$mn:0000B60F                 mov     [ebp+var_10], ecx
.text$mn:0000B612                 mov     [ebp+var_4], 0
.text$mn:0000B619                 mov     ecx, [ebp+var_10]
.text$mn:0000B61C                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Free_proxy(void)
.text$mn:0000B621                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B628                 mov     ecx, [ebp+var_10]
.text$mn:0000B62B                 call    ??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<uint>>::~_Vector_val<std::_Simple_types<uint>>(void)
.text$mn:0000B630                 mov     ecx, [ebp+var_C]
.text$mn:0000B633                 mov     large fs:0, ecx
.text$mn:0000B63A                 pop     ecx
.text$mn:0000B63B                 mov     esp, ebp
.text$mn:0000B63D                 pop     ebp
.text$mn:0000B63E                 retn
.text$mn:0000B63E ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000B63E
.text$mn:0000B63E ; ---------------------------------------------------------------------------
.text$mn:0000B63F                 align 10h
.text$mn:0000B63F _text$mn        ends
.text$mn:0000B63F
.text$x:0000B640 ; ===========================================================================
.text$x:0000B640
.text$x:0000B640 ; Segment type: Pure code
.text$x:0000B640 ; Segment permissions: Read/Execute
.text$x:0000B640 _text$x         segment para public 'CODE' use32
.text$x:0000B640                 assume cs:_text$x
.text$x:0000B640                 ;org 0B640h
.text$x:0000B640 ; COMDAT (pick associative to section at B5EC)
.text$x:0000B640                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B640
.text$x:0000B640 ; =============== S U B R O U T I N E =======================================
.text$x:0000B640
.text$x:0000B640
.text$x:0000B640 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B640                                         ; DATA XREF: .xdata$x:00012DF4o
.text$x:0000B640                 mov     ecx, [ebp-10h]
.text$x:0000B643                 jmp     ??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<uint>>::~_Vector_val<std::_Simple_types<uint>>(void)
.text$x:0000B643 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000B643
.text$x:0000B648
.text$x:0000B648 ; =============== S U B R O U T I N E =======================================
.text$x:0000B648
.text$x:0000B648
.text$x:0000B648 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000B648                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::~_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(void)+5o
.text$x:0000B648
.text$x:0000B648 arg_4           = dword ptr  8
.text$x:0000B648
.text$x:0000B648                 mov     edx, [esp+arg_4]
.text$x:0000B64C                 lea     eax, [edx+0Ch]
.text$x:0000B64F                 mov     ecx, [edx-8]
.text$x:0000B652                 xor     ecx, eax
.text$x:0000B654                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B659                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.text$x:0000B65E                 jmp     ___CxxFrameHandler3
.text$x:0000B65E __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ endp
.text$x:0000B65E
.text$x:0000B65E ; ---------------------------------------------------------------------------
.text$x:0000B663                 align 4
.text$x:0000B663 _text$x         ends
.text$x:0000B663
.text$mn:0000B664 ; ===========================================================================
.text$mn:0000B664
.text$mn:0000B664 ; Segment type: Pure code
.text$mn:0000B664 ; Segment permissions: Read/Execute
.text$mn:0000B664 _text$mn        segment para public 'CODE' use32
.text$mn:0000B664                 assume cs:_text$mn
.text$mn:0000B664                 ;org 0B664h
.text$mn:0000B664 ; COMDAT (pick any)
.text$mn:0000B664                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B664
.text$mn:0000B664 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B664
.text$mn:0000B664 ; Attributes: bp-based frame
.text$mn:0000B664
.text$mn:0000B664 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>>::~_Vector_alloc<0, struct std::_Vec_base_types<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>>(void)
.text$mn:0000B664                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000B664 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000B664                                         ; CODE XREF: __unwindfunclet$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$2+3j
.text$mn:0000B664                                         ; __unwindfunclet$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ$0+3j ...
.text$mn:0000B664
.text$mn:0000B664 var_10          = dword ptr -10h
.text$mn:0000B664 var_C           = dword ptr -0Ch
.text$mn:0000B664 var_4           = dword ptr -4
.text$mn:0000B664
.text$mn:0000B664                 push    ebp
.text$mn:0000B665                 mov     ebp, esp
.text$mn:0000B667                 push    0FFFFFFFFh
.text$mn:0000B669                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000B66E                 mov     eax, large fs:0
.text$mn:0000B674                 push    eax
.text$mn:0000B675                 push    ecx
.text$mn:0000B676                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B67B                 xor     eax, ebp
.text$mn:0000B67D                 push    eax
.text$mn:0000B67E                 lea     eax, [ebp+var_C]
.text$mn:0000B681                 mov     large fs:0, eax
.text$mn:0000B687                 mov     [ebp+var_10], ecx
.text$mn:0000B68A                 mov     [ebp+var_4], 0
.text$mn:0000B691                 mov     ecx, [ebp+var_10]
.text$mn:0000B694                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Free_proxy(void)
.text$mn:0000B699                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B6A0                 mov     ecx, [ebp+var_10]
.text$mn:0000B6A3                 call    ??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<sessionFileInfo>>::~_Vector_val<std::_Simple_types<sessionFileInfo>>(void)
.text$mn:0000B6A8                 mov     ecx, [ebp+var_C]
.text$mn:0000B6AB                 mov     large fs:0, ecx
.text$mn:0000B6B2                 pop     ecx
.text$mn:0000B6B3                 mov     esp, ebp
.text$mn:0000B6B5                 pop     ebp
.text$mn:0000B6B6                 retn
.text$mn:0000B6B6 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000B6B6
.text$mn:0000B6B6 ; ---------------------------------------------------------------------------
.text$mn:0000B6B7                 align 4
.text$mn:0000B6B7 _text$mn        ends
.text$mn:0000B6B7
.text$x:0000B6B8 ; ===========================================================================
.text$x:0000B6B8
.text$x:0000B6B8 ; Segment type: Pure code
.text$x:0000B6B8 ; Segment permissions: Read/Execute
.text$x:0000B6B8 _text$x         segment para public 'CODE' use32
.text$x:0000B6B8                 assume cs:_text$x
.text$x:0000B6B8                 ;org 0B6B8h
.text$x:0000B6B8 ; COMDAT (pick associative to section at B664)
.text$x:0000B6B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B6B8
.text$x:0000B6B8 ; =============== S U B R O U T I N E =======================================
.text$x:0000B6B8
.text$x:0000B6B8
.text$x:0000B6B8 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B6B8                                         ; DATA XREF: .xdata$x:000130E0o
.text$x:0000B6B8                 mov     ecx, [ebp-10h]
.text$x:0000B6BB                 jmp     ??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<sessionFileInfo>>::~_Vector_val<std::_Simple_types<sessionFileInfo>>(void)
.text$x:0000B6BB __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000B6BB
.text$x:0000B6C0
.text$x:0000B6C0 ; =============== S U B R O U T I N E =======================================
.text$x:0000B6C0
.text$x:0000B6C0
.text$x:0000B6C0 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000B6C0                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>(void)+5o
.text$x:0000B6C0
.text$x:0000B6C0 arg_4           = dword ptr  8
.text$x:0000B6C0
.text$x:0000B6C0                 mov     edx, [esp+arg_4]
.text$x:0000B6C4                 lea     eax, [edx+0Ch]
.text$x:0000B6C7                 mov     ecx, [edx-8]
.text$x:0000B6CA                 xor     ecx, eax
.text$x:0000B6CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B6D1                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ
.text$x:0000B6D6                 jmp     ___CxxFrameHandler3
.text$x:0000B6D6 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000B6D6
.text$x:0000B6D6 ; ---------------------------------------------------------------------------
.text$x:0000B6DB                 align 4
.text$x:0000B6DB _text$x         ends
.text$x:0000B6DB
.text$mn:0000B6DC ; ===========================================================================
.text$mn:0000B6DC
.text$mn:0000B6DC ; Segment type: Pure code
.text$mn:0000B6DC ; Segment permissions: Read/Execute
.text$mn:0000B6DC _text$mn        segment para public 'CODE' use32
.text$mn:0000B6DC                 assume cs:_text$mn
.text$mn:0000B6DC                 ;org 0B6DCh
.text$mn:0000B6DC ; COMDAT (pick any)
.text$mn:0000B6DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B6DC
.text$mn:0000B6DC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B6DC
.text$mn:0000B6DC ; Attributes: bp-based frame
.text$mn:0000B6DC
.text$mn:0000B6DC ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>::~_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(void)
.text$mn:0000B6DC                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ
.text$mn:0000B6DC ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ proc near
.text$mn:0000B6DC                                         ; CODE XREF: __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0+3j
.text$mn:0000B6DC                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+3Fp ...
.text$mn:0000B6DC
.text$mn:0000B6DC var_10          = dword ptr -10h
.text$mn:0000B6DC var_C           = dword ptr -0Ch
.text$mn:0000B6DC var_4           = dword ptr -4
.text$mn:0000B6DC
.text$mn:0000B6DC                 push    ebp
.text$mn:0000B6DD                 mov     ebp, esp
.text$mn:0000B6DF                 push    0FFFFFFFFh
.text$mn:0000B6E1                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ
.text$mn:0000B6E6                 mov     eax, large fs:0
.text$mn:0000B6EC                 push    eax
.text$mn:0000B6ED                 push    ecx
.text$mn:0000B6EE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B6F3                 xor     eax, ebp
.text$mn:0000B6F5                 push    eax
.text$mn:0000B6F6                 lea     eax, [ebp+var_C]
.text$mn:0000B6F9                 mov     large fs:0, eax
.text$mn:0000B6FF                 mov     [ebp+var_10], ecx
.text$mn:0000B702                 mov     [ebp+var_4], 0
.text$mn:0000B709                 mov     ecx, [ebp+var_10]
.text$mn:0000B70C                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Free_proxy(void)
.text$mn:0000B711                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B718                 mov     ecx, [ebp+var_10]
.text$mn:0000B71B                 call    ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:0000B720                 mov     ecx, [ebp+var_C]
.text$mn:0000B723                 mov     large fs:0, ecx
.text$mn:0000B72A                 pop     ecx
.text$mn:0000B72B                 mov     esp, ebp
.text$mn:0000B72D                 pop     ebp
.text$mn:0000B72E                 retn
.text$mn:0000B72E ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ endp
.text$mn:0000B72E
.text$mn:0000B72E ; ---------------------------------------------------------------------------
.text$mn:0000B72F                 align 10h
.text$mn:0000B72F _text$mn        ends
.text$mn:0000B72F
.text$x:0000B730 ; ===========================================================================
.text$x:0000B730
.text$x:0000B730 ; Segment type: Pure code
.text$x:0000B730 ; Segment permissions: Read/Execute
.text$x:0000B730 _text$x         segment para public 'CODE' use32
.text$x:0000B730                 assume cs:_text$x
.text$x:0000B730                 ;org 0B730h
.text$x:0000B730 ; COMDAT (pick associative to section at B6DC)
.text$x:0000B730                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B730
.text$x:0000B730 ; =============== S U B R O U T I N E =======================================
.text$x:0000B730
.text$x:0000B730
.text$x:0000B730 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B730                                         ; DATA XREF: .xdata$x:0001346Co
.text$x:0000B730                 mov     ecx, [ebp-10h]
.text$x:0000B733                 jmp     ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$x:0000B733 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ$0 endp
.text$x:0000B733
.text$x:0000B738
.text$x:0000B738 ; =============== S U B R O U T I N E =======================================
.text$x:0000B738
.text$x:0000B738
.text$x:0000B738 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ proc near
.text$x:0000B738                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)+5o
.text$x:0000B738
.text$x:0000B738 arg_4           = dword ptr  8
.text$x:0000B738
.text$x:0000B738                 mov     edx, [esp+arg_4]
.text$x:0000B73C                 lea     eax, [edx+0Ch]
.text$x:0000B73F                 mov     ecx, [edx-8]
.text$x:0000B742                 xor     ecx, eax
.text$x:0000B744                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B749                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ
.text$x:0000B74E                 jmp     ___CxxFrameHandler3
.text$x:0000B74E __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ endp
.text$x:0000B74E
.text$x:0000B74E ; ---------------------------------------------------------------------------
.text$x:0000B753                 align 4
.text$x:0000B753 _text$x         ends
.text$x:0000B753
.text$mn:0000B754 ; ===========================================================================
.text$mn:0000B754
.text$mn:0000B754 ; Segment type: Pure code
.text$mn:0000B754 ; Segment permissions: Read/Execute
.text$mn:0000B754 _text$mn        segment para public 'CODE' use32
.text$mn:0000B754                 assume cs:_text$mn
.text$mn:0000B754                 ;org 0B754h
.text$mn:0000B754 ; COMDAT (pick any)
.text$mn:0000B754                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B754
.text$mn:0000B754 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B754
.text$mn:0000B754 ; Attributes: bp-based frame
.text$mn:0000B754
.text$mn:0000B754 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>(void)
.text$mn:0000B754                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$mn:0000B754 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000B754                                         ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+159p
.text$mn:0000B754                                         ; Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+168p ...
.text$mn:0000B754
.text$mn:0000B754 var_10          = dword ptr -10h
.text$mn:0000B754 var_C           = dword ptr -0Ch
.text$mn:0000B754 var_4           = dword ptr -4
.text$mn:0000B754
.text$mn:0000B754                 push    ebp
.text$mn:0000B755                 mov     ebp, esp
.text$mn:0000B757                 push    0FFFFFFFFh
.text$mn:0000B759                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$mn:0000B75E                 mov     eax, large fs:0
.text$mn:0000B764                 push    eax
.text$mn:0000B765                 push    ecx
.text$mn:0000B766                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B76B                 xor     eax, ebp
.text$mn:0000B76D                 push    eax
.text$mn:0000B76E                 lea     eax, [ebp+var_C]
.text$mn:0000B771                 mov     large fs:0, eax
.text$mn:0000B777                 mov     [ebp+var_10], ecx
.text$mn:0000B77A                 mov     [ebp+var_4], 0
.text$mn:0000B781                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B788                 mov     ecx, [ebp+var_10]
.text$mn:0000B78B                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$mn:0000B790                 mov     ecx, [ebp+var_C]
.text$mn:0000B793                 mov     large fs:0, ecx
.text$mn:0000B79A                 pop     ecx
.text$mn:0000B79B                 mov     esp, ebp
.text$mn:0000B79D                 pop     ebp
.text$mn:0000B79E                 retn
.text$mn:0000B79E ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000B79E
.text$mn:0000B79E ; ---------------------------------------------------------------------------
.text$mn:0000B79F                 align 10h
.text$mn:0000B79F _text$mn        ends
.text$mn:0000B79F
.text$x:0000B7A0 ; ===========================================================================
.text$x:0000B7A0
.text$x:0000B7A0 ; Segment type: Pure code
.text$x:0000B7A0 ; Segment permissions: Read/Execute
.text$x:0000B7A0 _text$x         segment para public 'CODE' use32
.text$x:0000B7A0                 assume cs:_text$x
.text$x:0000B7A0                 ;org 0B7A0h
.text$x:0000B7A0 ; COMDAT (pick associative to section at B754)
.text$x:0000B7A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B7A0
.text$x:0000B7A0 ; =============== S U B R O U T I N E =======================================
.text$x:0000B7A0
.text$x:0000B7A0
.text$x:0000B7A0 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B7A0                                         ; DATA XREF: .xdata$x:00013BB4o
.text$x:0000B7A0                 mov     ecx, [ebp-10h]
.text$x:0000B7A3                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$x:0000B7A3 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000B7A3
.text$x:0000B7A8
.text$x:0000B7A8 ; =============== S U B R O U T I N E =======================================
.text$x:0000B7A8
.text$x:0000B7A8
.text$x:0000B7A8 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000B7A8                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)+5o
.text$x:0000B7A8
.text$x:0000B7A8 arg_4           = dword ptr  8
.text$x:0000B7A8
.text$x:0000B7A8                 mov     edx, [esp+arg_4]
.text$x:0000B7AC                 lea     eax, [edx+0Ch]
.text$x:0000B7AF                 mov     ecx, [edx-8]
.text$x:0000B7B2                 xor     ecx, eax
.text$x:0000B7B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B7B9                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$x:0000B7BE                 jmp     ___CxxFrameHandler3
.text$x:0000B7BE __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ endp
.text$x:0000B7BE
.text$x:0000B7BE ; ---------------------------------------------------------------------------
.text$x:0000B7C3                 align 4
.text$x:0000B7C3 _text$x         ends
.text$x:0000B7C3
.text$mn:0000B7C4 ; ===========================================================================
.text$mn:0000B7C4
.text$mn:0000B7C4 ; Segment type: Pure code
.text$mn:0000B7C4 ; Segment permissions: Read/Execute
.text$mn:0000B7C4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B7C4                 assume cs:_text$mn
.text$mn:0000B7C4                 ;org 0B7C4h
.text$mn:0000B7C4 ; COMDAT (pick any)
.text$mn:0000B7C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B7C4
.text$mn:0000B7C4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B7C4
.text$mn:0000B7C4 ; Attributes: bp-based frame
.text$mn:0000B7C4
.text$mn:0000B7C4 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned int>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned int>>>(void)
.text$mn:0000B7C4                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
.text$mn:0000B7C4 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000B7C4                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *)+9Bp
.text$mn:0000B7C4                                         ; std::vector<uint,std::allocator<uint>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *)+AAp ...
.text$mn:0000B7C4
.text$mn:0000B7C4 var_10          = dword ptr -10h
.text$mn:0000B7C4 var_C           = dword ptr -0Ch
.text$mn:0000B7C4 var_4           = dword ptr -4
.text$mn:0000B7C4
.text$mn:0000B7C4                 push    ebp
.text$mn:0000B7C5                 mov     ebp, esp
.text$mn:0000B7C7                 push    0FFFFFFFFh
.text$mn:0000B7C9                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
.text$mn:0000B7CE                 mov     eax, large fs:0
.text$mn:0000B7D4                 push    eax
.text$mn:0000B7D5                 push    ecx
.text$mn:0000B7D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B7DB                 xor     eax, ebp
.text$mn:0000B7DD                 push    eax
.text$mn:0000B7DE                 lea     eax, [ebp+var_C]
.text$mn:0000B7E1                 mov     large fs:0, eax
.text$mn:0000B7E7                 mov     [ebp+var_10], ecx
.text$mn:0000B7EA                 mov     [ebp+var_4], 0
.text$mn:0000B7F1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B7F8                 mov     ecx, [ebp+var_10]
.text$mn:0000B7FB                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>(void)
.text$mn:0000B800                 mov     ecx, [ebp+var_C]
.text$mn:0000B803                 mov     large fs:0, ecx
.text$mn:0000B80A                 pop     ecx
.text$mn:0000B80B                 mov     esp, ebp
.text$mn:0000B80D                 pop     ebp
.text$mn:0000B80E                 retn
.text$mn:0000B80E ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000B80E
.text$mn:0000B80E ; ---------------------------------------------------------------------------
.text$mn:0000B80F                 align 10h
.text$mn:0000B80F _text$mn        ends
.text$mn:0000B80F
.text$x:0000B810 ; ===========================================================================
.text$x:0000B810
.text$x:0000B810 ; Segment type: Pure code
.text$x:0000B810 ; Segment permissions: Read/Execute
.text$x:0000B810 _text$x         segment para public 'CODE' use32
.text$x:0000B810                 assume cs:_text$x
.text$x:0000B810                 ;org 0B810h
.text$x:0000B810 ; COMDAT (pick associative to section at B7C4)
.text$x:0000B810                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B810
.text$x:0000B810 ; =============== S U B R O U T I N E =======================================
.text$x:0000B810
.text$x:0000B810
.text$x:0000B810 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B810                                         ; DATA XREF: .xdata$x:00014238o
.text$x:0000B810                 mov     ecx, [ebp-10h]
.text$x:0000B813                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,uint,int,uint const *,uint const &,std::_Iterator_base12>(void)
.text$x:0000B813 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000B813
.text$x:0000B818
.text$x:0000B818 ; =============== S U B R O U T I N E =======================================
.text$x:0000B818
.text$x:0000B818
.text$x:0000B818 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000B818                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)+5o
.text$x:0000B818
.text$x:0000B818 arg_4           = dword ptr  8
.text$x:0000B818
.text$x:0000B818                 mov     edx, [esp+arg_4]
.text$x:0000B81C                 lea     eax, [edx+0Ch]
.text$x:0000B81F                 mov     ecx, [edx-8]
.text$x:0000B822                 xor     ecx, eax
.text$x:0000B824                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B829                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
.text$x:0000B82E                 jmp     ___CxxFrameHandler3
.text$x:0000B82E __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ endp
.text$x:0000B82E
.text$x:0000B82E ; ---------------------------------------------------------------------------
.text$x:0000B833                 align 4
.text$x:0000B833 _text$x         ends
.text$x:0000B833
.text$mn:0000B834 ; ===========================================================================
.text$mn:0000B834
.text$mn:0000B834 ; Segment type: Pure code
.text$mn:0000B834 ; Segment permissions: Read/Execute
.text$mn:0000B834 _text$mn        segment para public 'CODE' use32
.text$mn:0000B834                 assume cs:_text$mn
.text$mn:0000B834                 ;org 0B834h
.text$mn:0000B834 ; COMDAT (pick any)
.text$mn:0000B834                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B834
.text$mn:0000B834 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B834
.text$mn:0000B834 ; Attributes: bp-based frame
.text$mn:0000B834
.text$mn:0000B834 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>(void)
.text$mn:0000B834                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000B834 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000B834                                         ; CODE XREF: __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$2+6j
.text$mn:0000B834                                         ; __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$6+6j ...
.text$mn:0000B834
.text$mn:0000B834 var_10          = dword ptr -10h
.text$mn:0000B834 var_C           = dword ptr -0Ch
.text$mn:0000B834 var_4           = dword ptr -4
.text$mn:0000B834
.text$mn:0000B834                 push    ebp
.text$mn:0000B835                 mov     ebp, esp
.text$mn:0000B837                 push    0FFFFFFFFh
.text$mn:0000B839                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000B83E                 mov     eax, large fs:0
.text$mn:0000B844                 push    eax
.text$mn:0000B845                 push    ecx
.text$mn:0000B846                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B84B                 xor     eax, ebp
.text$mn:0000B84D                 push    eax
.text$mn:0000B84E                 lea     eax, [ebp+var_C]
.text$mn:0000B851                 mov     large fs:0, eax
.text$mn:0000B857                 mov     [ebp+var_10], ecx
.text$mn:0000B85A                 mov     [ebp+var_4], 0
.text$mn:0000B861                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B868                 mov     ecx, [ebp+var_10]
.text$mn:0000B86B                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>(void)
.text$mn:0000B870                 mov     ecx, [ebp+var_C]
.text$mn:0000B873                 mov     large fs:0, ecx
.text$mn:0000B87A                 pop     ecx
.text$mn:0000B87B                 mov     esp, ebp
.text$mn:0000B87D                 pop     ebp
.text$mn:0000B87E                 retn
.text$mn:0000B87E ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000B87E
.text$mn:0000B87E ; ---------------------------------------------------------------------------
.text$mn:0000B87F                 align 10h
.text$mn:0000B87F _text$mn        ends
.text$mn:0000B87F
.text$x:0000B880 ; ===========================================================================
.text$x:0000B880
.text$x:0000B880 ; Segment type: Pure code
.text$x:0000B880 ; Segment permissions: Read/Execute
.text$x:0000B880 _text$x         segment para public 'CODE' use32
.text$x:0000B880                 assume cs:_text$x
.text$x:0000B880                 ;org 0B880h
.text$x:0000B880 ; COMDAT (pick associative to section at B834)
.text$x:0000B880                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B880
.text$x:0000B880 ; =============== S U B R O U T I N E =======================================
.text$x:0000B880
.text$x:0000B880
.text$x:0000B880 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B880                                         ; DATA XREF: .xdata$x:00013C90o
.text$x:0000B880                 mov     ecx, [ebp-10h]
.text$x:0000B883                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,sessionFileInfo,int,sessionFileInfo const *,sessionFileInfo const &,std::_Iterator_base12>(void)
.text$x:0000B883 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000B883
.text$x:0000B888
.text$x:0000B888 ; =============== S U B R O U T I N E =======================================
.text$x:0000B888
.text$x:0000B888
.text$x:0000B888 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000B888                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)+5o
.text$x:0000B888
.text$x:0000B888 arg_4           = dword ptr  8
.text$x:0000B888
.text$x:0000B888                 mov     edx, [esp+arg_4]
.text$x:0000B88C                 lea     eax, [edx+0Ch]
.text$x:0000B88F                 mov     ecx, [edx-8]
.text$x:0000B892                 xor     ecx, eax
.text$x:0000B894                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B899                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ
.text$x:0000B89E                 jmp     ___CxxFrameHandler3
.text$x:0000B89E __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000B89E
.text$x:0000B89E ; ---------------------------------------------------------------------------
.text$x:0000B8A3                 align 4
.text$x:0000B8A3 _text$x         ends
.text$x:0000B8A3
.text$mn:0000B8A4 ; ===========================================================================
.text$mn:0000B8A4
.text$mn:0000B8A4 ; Segment type: Pure code
.text$mn:0000B8A4 ; Segment permissions: Read/Execute
.text$mn:0000B8A4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B8A4                 assume cs:_text$mn
.text$mn:0000B8A4                 ;org 0B8A4h
.text$mn:0000B8A4 ; COMDAT (pick any)
.text$mn:0000B8A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B8A4
.text$mn:0000B8A4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B8A4
.text$mn:0000B8A4 ; Attributes: bp-based frame
.text$mn:0000B8A4
.text$mn:0000B8A4 ; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>(void)
.text$mn:0000B8A4                 public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000B8A4 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000B8A4                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+E3p
.text$mn:0000B8A4                                         ; Notepad_plus::loadSession(Session &,bool)+137p ...
.text$mn:0000B8A4
.text$mn:0000B8A4 var_10          = dword ptr -10h
.text$mn:0000B8A4 var_C           = dword ptr -0Ch
.text$mn:0000B8A4 var_4           = dword ptr -4
.text$mn:0000B8A4
.text$mn:0000B8A4                 push    ebp
.text$mn:0000B8A5                 mov     ebp, esp
.text$mn:0000B8A7                 push    0FFFFFFFFh
.text$mn:0000B8A9                 push    offset __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000B8AE                 mov     eax, large fs:0
.text$mn:0000B8B4                 push    eax
.text$mn:0000B8B5                 push    ecx
.text$mn:0000B8B6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B8BB                 xor     eax, ebp
.text$mn:0000B8BD                 push    eax
.text$mn:0000B8BE                 lea     eax, [ebp+var_C]
.text$mn:0000B8C1                 mov     large fs:0, eax
.text$mn:0000B8C7                 mov     [ebp+var_10], ecx
.text$mn:0000B8CA                 mov     [ebp+var_4], 0
.text$mn:0000B8D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B8D8                 mov     ecx, [ebp+var_10]
.text$mn:0000B8DB                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:0000B8E0                 mov     ecx, [ebp+var_C]
.text$mn:0000B8E3                 mov     large fs:0, ecx
.text$mn:0000B8EA                 pop     ecx
.text$mn:0000B8EB                 mov     esp, ebp
.text$mn:0000B8ED                 pop     ebp
.text$mn:0000B8EE                 retn
.text$mn:0000B8EE ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000B8EE
.text$mn:0000B8EE ; ---------------------------------------------------------------------------
.text$mn:0000B8EF                 align 10h
.text$mn:0000B8EF _text$mn        ends
.text$mn:0000B8EF
.text$x:0000B8F0 ; ===========================================================================
.text$x:0000B8F0
.text$x:0000B8F0 ; Segment type: Pure code
.text$x:0000B8F0 ; Segment permissions: Read/Execute
.text$x:0000B8F0 _text$x         segment para public 'CODE' use32
.text$x:0000B8F0                 assume cs:_text$x
.text$x:0000B8F0                 ;org 0B8F0h
.text$x:0000B8F0 ; COMDAT (pick associative to section at B8A4)
.text$x:0000B8F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B8F0
.text$x:0000B8F0 ; =============== S U B R O U T I N E =======================================
.text$x:0000B8F0
.text$x:0000B8F0
.text$x:0000B8F0 __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B8F0                                         ; DATA XREF: .xdata$x:00013D48o
.text$x:0000B8F0                 mov     ecx, [ebp-10h]
.text$x:0000B8F3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:0000B8F3 __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000B8F3
.text$x:0000B8F8
.text$x:0000B8F8 ; =============== S U B R O U T I N E =======================================
.text$x:0000B8F8
.text$x:0000B8F8
.text$x:0000B8F8 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000B8F8                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)+5o
.text$x:0000B8F8
.text$x:0000B8F8 arg_4           = dword ptr  8
.text$x:0000B8F8
.text$x:0000B8F8                 mov     edx, [esp+arg_4]
.text$x:0000B8FC                 lea     eax, [edx+0Ch]
.text$x:0000B8FF                 mov     ecx, [edx-8]
.text$x:0000B902                 xor     ecx, eax
.text$x:0000B904                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B909                 mov     eax, offset __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ
.text$x:0000B90E                 jmp     ___CxxFrameHandler3
.text$x:0000B90E __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000B90E
.text$x:0000B90E ; ---------------------------------------------------------------------------
.text$x:0000B913                 align 4
.text$x:0000B913 _text$x         ends
.text$x:0000B913
.text$mn:0000B914 ; ===========================================================================
.text$mn:0000B914
.text$mn:0000B914 ; Segment type: Pure code
.text$mn:0000B914 ; Segment permissions: Read/Execute
.text$mn:0000B914 _text$mn        segment para public 'CODE' use32
.text$mn:0000B914                 assume cs:_text$mn
.text$mn:0000B914                 ;org 0B914h
.text$mn:0000B914 ; COMDAT (pick any)
.text$mn:0000B914                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B914
.text$mn:0000B914 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B914
.text$mn:0000B914 ; Attributes: bp-based frame
.text$mn:0000B914
.text$mn:0000B914 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<int>>::~_Vector_val<struct std::_Simple_types<int>>(void)
.text$mn:0000B914                 public ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$mn:0000B914 ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ proc near
.text$mn:0000B914                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z$0+3j
.text$mn:0000B914                                         ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)+3Fp ...
.text$mn:0000B914
.text$mn:0000B914 var_10          = dword ptr -10h
.text$mn:0000B914 var_C           = dword ptr -0Ch
.text$mn:0000B914 var_4           = dword ptr -4
.text$mn:0000B914
.text$mn:0000B914                 push    ebp
.text$mn:0000B915                 mov     ebp, esp
.text$mn:0000B917                 push    0FFFFFFFFh
.text$mn:0000B919                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$mn:0000B91E                 mov     eax, large fs:0
.text$mn:0000B924                 push    eax
.text$mn:0000B925                 push    ecx
.text$mn:0000B926                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B92B                 xor     eax, ebp
.text$mn:0000B92D                 push    eax
.text$mn:0000B92E                 lea     eax, [ebp+var_C]
.text$mn:0000B931                 mov     large fs:0, eax
.text$mn:0000B937                 mov     [ebp+var_10], ecx
.text$mn:0000B93A                 mov     [ebp+var_4], 0
.text$mn:0000B941                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B948                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000B94B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000B950                 mov     ecx, [ebp+var_C]
.text$mn:0000B953                 mov     large fs:0, ecx
.text$mn:0000B95A                 pop     ecx
.text$mn:0000B95B                 mov     esp, ebp
.text$mn:0000B95D                 pop     ebp
.text$mn:0000B95E                 retn
.text$mn:0000B95E ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ endp
.text$mn:0000B95E
.text$mn:0000B95E ; ---------------------------------------------------------------------------
.text$mn:0000B95F                 align 10h
.text$mn:0000B95F _text$mn        ends
.text$mn:0000B95F
.text$x:0000B960 ; ===========================================================================
.text$x:0000B960
.text$x:0000B960 ; Segment type: Pure code
.text$x:0000B960 ; Segment permissions: Read/Execute
.text$x:0000B960 _text$x         segment para public 'CODE' use32
.text$x:0000B960                 assume cs:_text$x
.text$x:0000B960                 ;org 0B960h
.text$x:0000B960 ; COMDAT (pick associative to section at B914)
.text$x:0000B960                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B960
.text$x:0000B960 ; =============== S U B R O U T I N E =======================================
.text$x:0000B960
.text$x:0000B960
.text$x:0000B960 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B960                                         ; DATA XREF: .xdata$x:00012B64o
.text$x:0000B960                 mov     ecx, [ebp-10h]  ; this
.text$x:0000B963                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000B963 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0 endp
.text$x:0000B963
.text$x:0000B968
.text$x:0000B968 ; =============== S U B R O U T I N E =======================================
.text$x:0000B968
.text$x:0000B968
.text$x:0000B968 __ehhandler$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ proc near
.text$x:0000B968                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<int>>::~_Vector_val<std::_Simple_types<int>>(void)+5o
.text$x:0000B968
.text$x:0000B968 arg_4           = dword ptr  8
.text$x:0000B968
.text$x:0000B968                 mov     edx, [esp+arg_4]
.text$x:0000B96C                 lea     eax, [edx+0Ch]
.text$x:0000B96F                 mov     ecx, [edx-8]
.text$x:0000B972                 xor     ecx, eax
.text$x:0000B974                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B979                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$x:0000B97E                 jmp     ___CxxFrameHandler3
.text$x:0000B97E __ehhandler$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ endp
.text$x:0000B97E
.text$x:0000B97E ; ---------------------------------------------------------------------------
.text$x:0000B983                 align 4
.text$x:0000B983 _text$x         ends
.text$x:0000B983
.text$mn:0000B984 ; ===========================================================================
.text$mn:0000B984
.text$mn:0000B984 ; Segment type: Pure code
.text$mn:0000B984 ; Segment permissions: Read/Execute
.text$mn:0000B984 _text$mn        segment para public 'CODE' use32
.text$mn:0000B984                 assume cs:_text$mn
.text$mn:0000B984                 ;org 0B984h
.text$mn:0000B984 ; COMDAT (pick any)
.text$mn:0000B984                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B984
.text$mn:0000B984 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B984
.text$mn:0000B984 ; Attributes: bp-based frame
.text$mn:0000B984
.text$mn:0000B984 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<unsigned int>>::~_Vector_val<struct std::_Simple_types<unsigned int>>(void)
.text$mn:0000B984                 public ??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.text$mn:0000B984 ??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ proc near
.text$mn:0000B984                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z$0+3j
.text$mn:0000B984                                         ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::~_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(void)+3Fp ...
.text$mn:0000B984
.text$mn:0000B984 var_10          = dword ptr -10h
.text$mn:0000B984 var_C           = dword ptr -0Ch
.text$mn:0000B984 var_4           = dword ptr -4
.text$mn:0000B984
.text$mn:0000B984                 push    ebp
.text$mn:0000B985                 mov     ebp, esp
.text$mn:0000B987                 push    0FFFFFFFFh
.text$mn:0000B989                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.text$mn:0000B98E                 mov     eax, large fs:0
.text$mn:0000B994                 push    eax
.text$mn:0000B995                 push    ecx
.text$mn:0000B996                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B99B                 xor     eax, ebp
.text$mn:0000B99D                 push    eax
.text$mn:0000B99E                 lea     eax, [ebp+var_C]
.text$mn:0000B9A1                 mov     large fs:0, eax
.text$mn:0000B9A7                 mov     [ebp+var_10], ecx
.text$mn:0000B9AA                 mov     [ebp+var_4], 0
.text$mn:0000B9B1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B9B8                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000B9BB                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000B9C0                 mov     ecx, [ebp+var_C]
.text$mn:0000B9C3                 mov     large fs:0, ecx
.text$mn:0000B9CA                 pop     ecx
.text$mn:0000B9CB                 mov     esp, ebp
.text$mn:0000B9CD                 pop     ebp
.text$mn:0000B9CE                 retn
.text$mn:0000B9CE ??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ endp
.text$mn:0000B9CE
.text$mn:0000B9CE ; ---------------------------------------------------------------------------
.text$mn:0000B9CF                 align 10h
.text$mn:0000B9CF _text$mn        ends
.text$mn:0000B9CF
.text$x:0000B9D0 ; ===========================================================================
.text$x:0000B9D0
.text$x:0000B9D0 ; Segment type: Pure code
.text$x:0000B9D0 ; Segment permissions: Read/Execute
.text$x:0000B9D0 _text$x         segment para public 'CODE' use32
.text$x:0000B9D0                 assume cs:_text$x
.text$x:0000B9D0                 ;org 0B9D0h
.text$x:0000B9D0 ; COMDAT (pick associative to section at B984)
.text$x:0000B9D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B9D0
.text$x:0000B9D0 ; =============== S U B R O U T I N E =======================================
.text$x:0000B9D0
.text$x:0000B9D0
.text$x:0000B9D0 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ$0 proc near
.text$x:0000B9D0                                         ; DATA XREF: .xdata$x:00012D9Co
.text$x:0000B9D0                 mov     ecx, [ebp-10h]  ; this
.text$x:0000B9D3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000B9D3 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ$0 endp
.text$x:0000B9D3
.text$x:0000B9D8
.text$x:0000B9D8 ; =============== S U B R O U T I N E =======================================
.text$x:0000B9D8
.text$x:0000B9D8
.text$x:0000B9D8 __ehhandler$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ proc near
.text$x:0000B9D8                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<uint>>::~_Vector_val<std::_Simple_types<uint>>(void)+5o
.text$x:0000B9D8
.text$x:0000B9D8 arg_4           = dword ptr  8
.text$x:0000B9D8
.text$x:0000B9D8                 mov     edx, [esp+arg_4]
.text$x:0000B9DC                 lea     eax, [edx+0Ch]
.text$x:0000B9DF                 mov     ecx, [edx-8]
.text$x:0000B9E2                 xor     ecx, eax
.text$x:0000B9E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B9E9                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.text$x:0000B9EE                 jmp     ___CxxFrameHandler3
.text$x:0000B9EE __ehhandler$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ endp
.text$x:0000B9EE
.text$x:0000B9EE ; ---------------------------------------------------------------------------
.text$x:0000B9F3                 align 4
.text$x:0000B9F3 _text$x         ends
.text$x:0000B9F3
.text$mn:0000B9F4 ; ===========================================================================
.text$mn:0000B9F4
.text$mn:0000B9F4 ; Segment type: Pure code
.text$mn:0000B9F4 ; Segment permissions: Read/Execute
.text$mn:0000B9F4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B9F4                 assume cs:_text$mn
.text$mn:0000B9F4                 ;org 0B9F4h
.text$mn:0000B9F4 ; COMDAT (pick any)
.text$mn:0000B9F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B9F4
.text$mn:0000B9F4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B9F4
.text$mn:0000B9F4 ; Attributes: bp-based frame
.text$mn:0000B9F4
.text$mn:0000B9F4 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>::~_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>(void)
.text$mn:0000B9F4                 public ??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ
.text$mn:0000B9F4 ??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ proc near
.text$mn:0000B9F4                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z$0+3j
.text$mn:0000B9F4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>(void)+3Fp ...
.text$mn:0000B9F4
.text$mn:0000B9F4 var_10          = dword ptr -10h
.text$mn:0000B9F4 var_C           = dword ptr -0Ch
.text$mn:0000B9F4 var_4           = dword ptr -4
.text$mn:0000B9F4
.text$mn:0000B9F4                 push    ebp
.text$mn:0000B9F5                 mov     ebp, esp
.text$mn:0000B9F7                 push    0FFFFFFFFh
.text$mn:0000B9F9                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ
.text$mn:0000B9FE                 mov     eax, large fs:0
.text$mn:0000BA04                 push    eax
.text$mn:0000BA05                 push    ecx
.text$mn:0000BA06                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BA0B                 xor     eax, ebp
.text$mn:0000BA0D                 push    eax
.text$mn:0000BA0E                 lea     eax, [ebp+var_C]
.text$mn:0000BA11                 mov     large fs:0, eax
.text$mn:0000BA17                 mov     [ebp+var_10], ecx
.text$mn:0000BA1A                 mov     [ebp+var_4], 0
.text$mn:0000BA21                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000BA28                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000BA2B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000BA30                 mov     ecx, [ebp+var_C]
.text$mn:0000BA33                 mov     large fs:0, ecx
.text$mn:0000BA3A                 pop     ecx
.text$mn:0000BA3B                 mov     esp, ebp
.text$mn:0000BA3D                 pop     ebp
.text$mn:0000BA3E                 retn
.text$mn:0000BA3E ??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ endp
.text$mn:0000BA3E
.text$mn:0000BA3E ; ---------------------------------------------------------------------------
.text$mn:0000BA3F                 align 10h
.text$mn:0000BA3F _text$mn        ends
.text$mn:0000BA3F
.text$x:0000BA40 ; ===========================================================================
.text$x:0000BA40
.text$x:0000BA40 ; Segment type: Pure code
.text$x:0000BA40 ; Segment permissions: Read/Execute
.text$x:0000BA40 _text$x         segment para public 'CODE' use32
.text$x:0000BA40                 assume cs:_text$x
.text$x:0000BA40                 ;org 0BA40h
.text$x:0000BA40 ; COMDAT (pick associative to section at B9F4)
.text$x:0000BA40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BA40
.text$x:0000BA40 ; =============== S U B R O U T I N E =======================================
.text$x:0000BA40
.text$x:0000BA40
.text$x:0000BA40 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000BA40                                         ; DATA XREF: .xdata$x:00013088o
.text$x:0000BA40                 mov     ecx, [ebp-10h]  ; this
.text$x:0000BA43                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000BA43 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000BA43
.text$x:0000BA48
.text$x:0000BA48 ; =============== S U B R O U T I N E =======================================
.text$x:0000BA48
.text$x:0000BA48
.text$x:0000BA48 __ehhandler$??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ proc near
.text$x:0000BA48                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<sessionFileInfo>>::~_Vector_val<std::_Simple_types<sessionFileInfo>>(void)+5o
.text$x:0000BA48
.text$x:0000BA48 arg_4           = dword ptr  8
.text$x:0000BA48
.text$x:0000BA48                 mov     edx, [esp+arg_4]
.text$x:0000BA4C                 lea     eax, [edx+0Ch]
.text$x:0000BA4F                 mov     ecx, [edx-8]
.text$x:0000BA52                 xor     ecx, eax
.text$x:0000BA54                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BA59                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ
.text$x:0000BA5E                 jmp     ___CxxFrameHandler3
.text$x:0000BA5E __ehhandler$??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ endp
.text$x:0000BA5E
.text$x:0000BA5E ; ---------------------------------------------------------------------------
.text$x:0000BA63                 align 4
.text$x:0000BA63 _text$x         ends
.text$x:0000BA63
.text$mn:0000BA64 ; ===========================================================================
.text$mn:0000BA64
.text$mn:0000BA64 ; Segment type: Pure code
.text$mn:0000BA64 ; Segment permissions: Read/Execute
.text$mn:0000BA64 _text$mn        segment para public 'CODE' use32
.text$mn:0000BA64                 assume cs:_text$mn
.text$mn:0000BA64                 ;org 0BA64h
.text$mn:0000BA64 ; COMDAT (pick any)
.text$mn:0000BA64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BA64
.text$mn:0000BA64 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BA64
.text$mn:0000BA64 ; Attributes: bp-based frame
.text$mn:0000BA64
.text$mn:0000BA64 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::~_Vector_val<struct std::_Simple_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(void)
.text$mn:0000BA64                 public ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$mn:0000BA64 ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000BA64                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$0+3j
.text$mn:0000BA64                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)+3Fp ...
.text$mn:0000BA64
.text$mn:0000BA64 var_10          = dword ptr -10h
.text$mn:0000BA64 var_C           = dword ptr -0Ch
.text$mn:0000BA64 var_4           = dword ptr -4
.text$mn:0000BA64
.text$mn:0000BA64                 push    ebp
.text$mn:0000BA65                 mov     ebp, esp
.text$mn:0000BA67                 push    0FFFFFFFFh
.text$mn:0000BA69                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$mn:0000BA6E                 mov     eax, large fs:0
.text$mn:0000BA74                 push    eax
.text$mn:0000BA75                 push    ecx
.text$mn:0000BA76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BA7B                 xor     eax, ebp
.text$mn:0000BA7D                 push    eax
.text$mn:0000BA7E                 lea     eax, [ebp+var_C]
.text$mn:0000BA81                 mov     large fs:0, eax
.text$mn:0000BA87                 mov     [ebp+var_10], ecx
.text$mn:0000BA8A                 mov     [ebp+var_4], 0
.text$mn:0000BA91                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000BA98                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000BA9B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000BAA0                 mov     ecx, [ebp+var_C]
.text$mn:0000BAA3                 mov     large fs:0, ecx
.text$mn:0000BAAA                 pop     ecx
.text$mn:0000BAAB                 mov     esp, ebp
.text$mn:0000BAAD                 pop     ebp
.text$mn:0000BAAE                 retn
.text$mn:0000BAAE ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000BAAE
.text$mn:0000BAAE ; ---------------------------------------------------------------------------
.text$mn:0000BAAF                 align 10h
.text$mn:0000BAAF _text$mn        ends
.text$mn:0000BAAF
.text$x:0000BAB0 ; ===========================================================================
.text$x:0000BAB0
.text$x:0000BAB0 ; Segment type: Pure code
.text$x:0000BAB0 ; Segment permissions: Read/Execute
.text$x:0000BAB0 _text$x         segment para public 'CODE' use32
.text$x:0000BAB0                 assume cs:_text$x
.text$x:0000BAB0                 ;org 0BAB0h
.text$x:0000BAB0 ; COMDAT (pick associative to section at BA64)
.text$x:0000BAB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BAB0
.text$x:0000BAB0 ; =============== S U B R O U T I N E =======================================
.text$x:0000BAB0
.text$x:0000BAB0
.text$x:0000BAB0 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000BAB0                                         ; DATA XREF: .xdata$x:00013414o
.text$x:0000BAB0                 mov     ecx, [ebp-10h]  ; this
.text$x:0000BAB3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000BAB3 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000BAB3
.text$x:0000BAB8
.text$x:0000BAB8 ; =============== S U B R O U T I N E =======================================
.text$x:0000BAB8
.text$x:0000BAB8
.text$x:0000BAB8 __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000BAB8                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+5o
.text$x:0000BAB8
.text$x:0000BAB8 arg_4           = dword ptr  8
.text$x:0000BAB8
.text$x:0000BAB8                 mov     edx, [esp+arg_4]
.text$x:0000BABC                 lea     eax, [edx+0Ch]
.text$x:0000BABF                 mov     ecx, [edx-8]
.text$x:0000BAC2                 xor     ecx, eax
.text$x:0000BAC4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BAC9                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$x:0000BACE                 jmp     ___CxxFrameHandler3
.text$x:0000BACE __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000BACE
.text$x:0000BACE ; ---------------------------------------------------------------------------
.text$x:0000BAD3                 align 4
.text$x:0000BAD3 _text$x         ends
.text$x:0000BAD3
.text$mn:0000BAD4 ; ===========================================================================
.text$mn:0000BAD4
.text$mn:0000BAD4 ; Segment type: Pure code
.text$mn:0000BAD4 ; Segment permissions: Read/Execute
.text$mn:0000BAD4 _text$mn        segment para public 'CODE' use32
.text$mn:0000BAD4                 assume cs:_text$mn
.text$mn:0000BAD4                 ;org 0BAD4h
.text$mn:0000BAD4 ; COMDAT (pick any)
.text$mn:0000BAD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BAD4
.text$mn:0000BAD4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BAD4
.text$mn:0000BAD4 ; Attributes: bp-based frame
.text$mn:0000BAD4
.text$mn:0000BAD4 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:0000BAD4                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000BAD4 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:0000BAD4                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:0000BAD4                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:0000BAD4
.text$mn:0000BAD4 var_10          = dword ptr -10h
.text$mn:0000BAD4 var_C           = dword ptr -0Ch
.text$mn:0000BAD4 var_4           = dword ptr -4
.text$mn:0000BAD4
.text$mn:0000BAD4                 push    ebp
.text$mn:0000BAD5                 mov     ebp, esp
.text$mn:0000BAD7                 push    0FFFFFFFFh
.text$mn:0000BAD9                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000BADE                 mov     eax, large fs:0
.text$mn:0000BAE4                 push    eax
.text$mn:0000BAE5                 push    ecx
.text$mn:0000BAE6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BAEB                 xor     eax, ebp
.text$mn:0000BAED                 push    eax
.text$mn:0000BAEE                 lea     eax, [ebp+var_C]
.text$mn:0000BAF1                 mov     large fs:0, eax
.text$mn:0000BAF7                 mov     [ebp+var_10], ecx
.text$mn:0000BAFA                 mov     [ebp+var_4], 0
.text$mn:0000BB01                 push    0               ; Size
.text$mn:0000BB03                 push    1               ; char
.text$mn:0000BB05                 mov     ecx, [ebp+var_10]
.text$mn:0000BB08                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000BB0D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000BB14                 mov     ecx, [ebp+var_10]
.text$mn:0000BB17                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:0000BB1C                 mov     ecx, [ebp+var_C]
.text$mn:0000BB1F                 mov     large fs:0, ecx
.text$mn:0000BB26                 pop     ecx
.text$mn:0000BB27                 mov     esp, ebp
.text$mn:0000BB29                 pop     ebp
.text$mn:0000BB2A                 retn
.text$mn:0000BB2A ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:0000BB2A
.text$mn:0000BB2A ; ---------------------------------------------------------------------------
.text$mn:0000BB2B                 align 4
.text$mn:0000BB2B _text$mn        ends
.text$mn:0000BB2B
.text$x:0000BB2C ; ===========================================================================
.text$x:0000BB2C
.text$x:0000BB2C ; Segment type: Pure code
.text$x:0000BB2C ; Segment permissions: Read/Execute
.text$x:0000BB2C _text$x         segment para public 'CODE' use32
.text$x:0000BB2C                 assume cs:_text$x
.text$x:0000BB2C                 ;org 0BB2Ch
.text$x:0000BB2C ; COMDAT (pick associative to section at BAD4)
.text$x:0000BB2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BB2C
.text$x:0000BB2C ; =============== S U B R O U T I N E =======================================
.text$x:0000BB2C
.text$x:0000BB2C
.text$x:0000BB2C __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:0000BB2C                                         ; DATA XREF: .xdata$x:00012504o
.text$x:0000BB2C                 mov     ecx, [ebp-10h]
.text$x:0000BB2F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000BB2F __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000BB2F
.text$x:0000BB34
.text$x:0000BB34 ; =============== S U B R O U T I N E =======================================
.text$x:0000BB34
.text$x:0000BB34
.text$x:0000BB34 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:0000BB34                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:0000BB34
.text$x:0000BB34 arg_4           = dword ptr  8
.text$x:0000BB34
.text$x:0000BB34                 mov     edx, [esp+arg_4]
.text$x:0000BB38                 lea     eax, [edx+0Ch]
.text$x:0000BB3B                 mov     ecx, [edx-8]
.text$x:0000BB3E                 xor     ecx, eax
.text$x:0000BB40                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BB45                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:0000BB4A                 jmp     ___CxxFrameHandler3
.text$x:0000BB4A __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:0000BB4A
.text$x:0000BB4A ; ---------------------------------------------------------------------------
.text$x:0000BB4F                 align 10h
.text$x:0000BB4F _text$x         ends
.text$x:0000BB4F
.text$mn:0000BB50 ; ===========================================================================
.text$mn:0000BB50
.text$mn:0000BB50 ; Segment type: Pure code
.text$mn:0000BB50 ; Segment permissions: Read/Execute
.text$mn:0000BB50 _text$mn        segment para public 'CODE' use32
.text$mn:0000BB50                 assume cs:_text$mn
.text$mn:0000BB50                 ;org 0BB50h
.text$mn:0000BB50 ; COMDAT (pick any)
.text$mn:0000BB50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BB50
.text$mn:0000BB50 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BB50
.text$mn:0000BB50 ; Attributes: bp-based frame
.text$mn:0000BB50
.text$mn:0000BB50 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:0000BB50                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000BB50 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:0000BB50                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+271p
.text$mn:0000BB50                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+2D4p ...
.text$mn:0000BB50
.text$mn:0000BB50 var_10          = dword ptr -10h
.text$mn:0000BB50 var_C           = dword ptr -0Ch
.text$mn:0000BB50 var_4           = dword ptr -4
.text$mn:0000BB50
.text$mn:0000BB50                 push    ebp
.text$mn:0000BB51                 mov     ebp, esp
.text$mn:0000BB53                 push    0FFFFFFFFh
.text$mn:0000BB55                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000BB5A                 mov     eax, large fs:0
.text$mn:0000BB60                 push    eax
.text$mn:0000BB61                 push    ecx
.text$mn:0000BB62                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BB67                 xor     eax, ebp
.text$mn:0000BB69                 push    eax
.text$mn:0000BB6A                 lea     eax, [ebp+var_C]
.text$mn:0000BB6D                 mov     large fs:0, eax
.text$mn:0000BB73                 mov     [ebp+var_10], ecx
.text$mn:0000BB76                 mov     [ebp+var_4], 0
.text$mn:0000BB7D                 push    0
.text$mn:0000BB7F                 push    1
.text$mn:0000BB81                 mov     ecx, [ebp+var_10]
.text$mn:0000BB84                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000BB89                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000BB90                 mov     ecx, [ebp+var_10]
.text$mn:0000BB93                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:0000BB98                 mov     ecx, [ebp+var_C]
.text$mn:0000BB9B                 mov     large fs:0, ecx
.text$mn:0000BBA2                 pop     ecx
.text$mn:0000BBA3                 mov     esp, ebp
.text$mn:0000BBA5                 pop     ebp
.text$mn:0000BBA6                 retn
.text$mn:0000BBA6 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:0000BBA6
.text$mn:0000BBA6 ; ---------------------------------------------------------------------------
.text$mn:0000BBA7                 align 4
.text$mn:0000BBA7 _text$mn        ends
.text$mn:0000BBA7
.text$x:0000BBA8 ; ===========================================================================
.text$x:0000BBA8
.text$x:0000BBA8 ; Segment type: Pure code
.text$x:0000BBA8 ; Segment permissions: Read/Execute
.text$x:0000BBA8 _text$x         segment para public 'CODE' use32
.text$x:0000BBA8                 assume cs:_text$x
.text$x:0000BBA8                 ;org 0BBA8h
.text$x:0000BBA8 ; COMDAT (pick associative to section at BB50)
.text$x:0000BBA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BBA8
.text$x:0000BBA8 ; =============== S U B R O U T I N E =======================================
.text$x:0000BBA8
.text$x:0000BBA8
.text$x:0000BBA8 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:0000BBA8                                         ; DATA XREF: .xdata$x:00012934o
.text$x:0000BBA8                 mov     ecx, [ebp-10h]
.text$x:0000BBAB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000BBAB __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:0000BBAB
.text$x:0000BBB0
.text$x:0000BBB0 ; =============== S U B R O U T I N E =======================================
.text$x:0000BBB0
.text$x:0000BBB0
.text$x:0000BBB0 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:0000BBB0                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:0000BBB0
.text$x:0000BBB0 arg_4           = dword ptr  8
.text$x:0000BBB0
.text$x:0000BBB0                 mov     edx, [esp+arg_4]
.text$x:0000BBB4                 lea     eax, [edx+0Ch]
.text$x:0000BBB7                 mov     ecx, [edx-8]
.text$x:0000BBBA                 xor     ecx, eax
.text$x:0000BBBC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BBC1                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:0000BBC6                 jmp     ___CxxFrameHandler3
.text$x:0000BBC6 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:0000BBC6
.text$x:0000BBC6 ; ---------------------------------------------------------------------------
.text$x:0000BBCB                 align 4
.text$x:0000BBCB _text$x         ends
.text$x:0000BBCB
.text$mn:0000BBCC ; ===========================================================================
.text$mn:0000BBCC
.text$mn:0000BBCC ; Segment type: Pure code
.text$mn:0000BBCC ; Segment permissions: Read/Execute
.text$mn:0000BBCC _text$mn        segment para public 'CODE' use32
.text$mn:0000BBCC                 assume cs:_text$mn
.text$mn:0000BBCC                 ;org 0BBCCh
.text$mn:0000BBCC ; COMDAT (pick any)
.text$mn:0000BBCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BBCC
.text$mn:0000BBCC ; =============== S U B R O U T I N E =======================================
.text$mn:0000BBCC
.text$mn:0000BBCC ; Attributes: bp-based frame
.text$mn:0000BBCC
.text$mn:0000BBCC ; public: __thiscall std::vector<int, class std::allocator<int>>::~vector<int, class std::allocator<int>>(void)
.text$mn:0000BBCC                 public ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$mn:0000BBCC ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ proc near
.text$mn:0000BBCC                                         ; CODE XREF: Notepad_plus::fileCloseAllToLeft(void)+83p
.text$mn:0000BBCC                                         ; Notepad_plus::fileCloseAllToRight(void)+96p ...
.text$mn:0000BBCC
.text$mn:0000BBCC var_10          = dword ptr -10h
.text$mn:0000BBCC var_C           = dword ptr -0Ch
.text$mn:0000BBCC var_4           = dword ptr -4
.text$mn:0000BBCC
.text$mn:0000BBCC                 push    ebp
.text$mn:0000BBCD                 mov     ebp, esp
.text$mn:0000BBCF                 push    0FFFFFFFFh
.text$mn:0000BBD1                 push    offset __ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$mn:0000BBD6                 mov     eax, large fs:0
.text$mn:0000BBDC                 push    eax
.text$mn:0000BBDD                 push    ecx
.text$mn:0000BBDE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BBE3                 xor     eax, ebp
.text$mn:0000BBE5                 push    eax
.text$mn:0000BBE6                 lea     eax, [ebp+var_C]
.text$mn:0000BBE9                 mov     large fs:0, eax
.text$mn:0000BBEF                 mov     [ebp+var_10], ecx
.text$mn:0000BBF2                 mov     [ebp+var_4], 0
.text$mn:0000BBF9                 mov     ecx, [ebp+var_10]
.text$mn:0000BBFC                 call    ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int>>::_Tidy(void)
.text$mn:0000BC01                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000BC08                 mov     ecx, [ebp+var_10]
.text$mn:0000BC0B                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)
.text$mn:0000BC10                 mov     ecx, [ebp+var_C]
.text$mn:0000BC13                 mov     large fs:0, ecx
.text$mn:0000BC1A                 pop     ecx
.text$mn:0000BC1B                 mov     esp, ebp
.text$mn:0000BC1D                 pop     ebp
.text$mn:0000BC1E                 retn
.text$mn:0000BC1E ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ endp
.text$mn:0000BC1E
.text$mn:0000BC1E ; ---------------------------------------------------------------------------
.text$mn:0000BC1F                 align 10h
.text$mn:0000BC1F _text$mn        ends
.text$mn:0000BC1F
.text$x:0000BC20 ; ===========================================================================
.text$x:0000BC20
.text$x:0000BC20 ; Segment type: Pure code
.text$x:0000BC20 ; Segment permissions: Read/Execute
.text$x:0000BC20 _text$x         segment para public 'CODE' use32
.text$x:0000BC20                 assume cs:_text$x
.text$x:0000BC20                 ;org 0BC20h
.text$x:0000BC20 ; COMDAT (pick associative to section at BBCC)
.text$x:0000BC20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BC20
.text$x:0000BC20 ; =============== S U B R O U T I N E =======================================
.text$x:0000BC20
.text$x:0000BC20
.text$x:0000BC20 __unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0 proc near
.text$x:0000BC20                                         ; DATA XREF: .xdata$x:00012C14o
.text$x:0000BC20                 mov     ecx, [ebp-10h]
.text$x:0000BC23                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)
.text$x:0000BC23 __unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0 endp
.text$x:0000BC23
.text$x:0000BC28
.text$x:0000BC28 ; =============== S U B R O U T I N E =======================================
.text$x:0000BC28
.text$x:0000BC28
.text$x:0000BC28 __ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ proc near
.text$x:0000BC28                                         ; DATA XREF: std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)+5o
.text$x:0000BC28
.text$x:0000BC28 arg_4           = dword ptr  8
.text$x:0000BC28
.text$x:0000BC28                 mov     edx, [esp+arg_4]
.text$x:0000BC2C                 lea     eax, [edx+0Ch]
.text$x:0000BC2F                 mov     ecx, [edx-8]
.text$x:0000BC32                 xor     ecx, eax
.text$x:0000BC34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BC39                 mov     eax, offset __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$x:0000BC3E                 jmp     ___CxxFrameHandler3
.text$x:0000BC3E __ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ endp
.text$x:0000BC3E
.text$x:0000BC3E ; ---------------------------------------------------------------------------
.text$x:0000BC43                 align 4
.text$x:0000BC43 _text$x         ends
.text$x:0000BC43
.text$mn:0000BC44 ; ===========================================================================
.text$mn:0000BC44
.text$mn:0000BC44 ; Segment type: Pure code
.text$mn:0000BC44 ; Segment permissions: Read/Execute
.text$mn:0000BC44 _text$mn        segment para public 'CODE' use32
.text$mn:0000BC44                 assume cs:_text$mn
.text$mn:0000BC44                 ;org 0BC44h
.text$mn:0000BC44 ; COMDAT (pick any)
.text$mn:0000BC44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BC44
.text$mn:0000BC44 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BC44
.text$mn:0000BC44 ; Attributes: bp-based frame
.text$mn:0000BC44
.text$mn:0000BC44 ; public: __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::~vector<unsigned int, class std::allocator<unsigned int>>(void)
.text$mn:0000BC44                 public ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.text$mn:0000BC44 ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ proc near
.text$mn:0000BC44                                         ; CODE XREF: __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$2+6j
.text$mn:0000BC44                                         ; __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$3+6j ...
.text$mn:0000BC44
.text$mn:0000BC44 var_10          = dword ptr -10h
.text$mn:0000BC44 var_C           = dword ptr -0Ch
.text$mn:0000BC44 var_4           = dword ptr -4
.text$mn:0000BC44
.text$mn:0000BC44                 push    ebp
.text$mn:0000BC45                 mov     ebp, esp
.text$mn:0000BC47                 push    0FFFFFFFFh
.text$mn:0000BC49                 push    offset __ehhandler$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.text$mn:0000BC4E                 mov     eax, large fs:0
.text$mn:0000BC54                 push    eax
.text$mn:0000BC55                 push    ecx
.text$mn:0000BC56                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BC5B                 xor     eax, ebp
.text$mn:0000BC5D                 push    eax
.text$mn:0000BC5E                 lea     eax, [ebp+var_C]
.text$mn:0000BC61                 mov     large fs:0, eax
.text$mn:0000BC67                 mov     [ebp+var_10], ecx
.text$mn:0000BC6A                 mov     [ebp+var_4], 0
.text$mn:0000BC71                 mov     ecx, [ebp+var_10]
.text$mn:0000BC74                 call    ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<uint,std::allocator<uint>>::_Tidy(void)
.text$mn:0000BC79                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000BC80                 mov     ecx, [ebp+var_10]
.text$mn:0000BC83                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::~_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(void)
.text$mn:0000BC88                 mov     ecx, [ebp+var_C]
.text$mn:0000BC8B                 mov     large fs:0, ecx
.text$mn:0000BC92                 pop     ecx
.text$mn:0000BC93                 mov     esp, ebp
.text$mn:0000BC95                 pop     ebp
.text$mn:0000BC96                 retn
.text$mn:0000BC96 ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ endp
.text$mn:0000BC96
.text$mn:0000BC96 ; ---------------------------------------------------------------------------
.text$mn:0000BC97                 align 4
.text$mn:0000BC97 _text$mn        ends
.text$mn:0000BC97
.text$x:0000BC98 ; ===========================================================================
.text$x:0000BC98
.text$x:0000BC98 ; Segment type: Pure code
.text$x:0000BC98 ; Segment permissions: Read/Execute
.text$x:0000BC98 _text$x         segment para public 'CODE' use32
.text$x:0000BC98                 assume cs:_text$x
.text$x:0000BC98                 ;org 0BC98h
.text$x:0000BC98 ; COMDAT (pick associative to section at BC44)
.text$x:0000BC98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BC98
.text$x:0000BC98 ; =============== S U B R O U T I N E =======================================
.text$x:0000BC98
.text$x:0000BC98
.text$x:0000BC98 __unwindfunclet$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0 proc near
.text$x:0000BC98                                         ; DATA XREF: .xdata$x:00012EBCo
.text$x:0000BC98                 mov     ecx, [ebp-10h]
.text$x:0000BC9B                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::~_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(void)
.text$x:0000BC9B __unwindfunclet$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0 endp
.text$x:0000BC9B
.text$x:0000BCA0
.text$x:0000BCA0 ; =============== S U B R O U T I N E =======================================
.text$x:0000BCA0
.text$x:0000BCA0
.text$x:0000BCA0 __ehhandler$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ proc near
.text$x:0000BCA0                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::~vector<uint,std::allocator<uint>>(void)+5o
.text$x:0000BCA0
.text$x:0000BCA0 arg_4           = dword ptr  8
.text$x:0000BCA0
.text$x:0000BCA0                 mov     edx, [esp+arg_4]
.text$x:0000BCA4                 lea     eax, [edx+0Ch]
.text$x:0000BCA7                 mov     ecx, [edx-8]
.text$x:0000BCAA                 xor     ecx, eax
.text$x:0000BCAC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BCB1                 mov     eax, offset __ehfuncinfo$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.text$x:0000BCB6                 jmp     ___CxxFrameHandler3
.text$x:0000BCB6 __ehhandler$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ endp
.text$x:0000BCB6
.text$x:0000BCB6 ; ---------------------------------------------------------------------------
.text$x:0000BCBB                 align 4
.text$x:0000BCBB _text$x         ends
.text$x:0000BCBB
.text$mn:0000BCBC ; ===========================================================================
.text$mn:0000BCBC
.text$mn:0000BCBC ; Segment type: Pure code
.text$mn:0000BCBC ; Segment permissions: Read/Execute
.text$mn:0000BCBC _text$mn        segment para public 'CODE' use32
.text$mn:0000BCBC                 assume cs:_text$mn
.text$mn:0000BCBC                 ;org 0BCBCh
.text$mn:0000BCBC ; COMDAT (pick any)
.text$mn:0000BCBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BCBC
.text$mn:0000BCBC ; =============== S U B R O U T I N E =======================================
.text$mn:0000BCBC
.text$mn:0000BCBC ; Attributes: bp-based frame
.text$mn:0000BCBC
.text$mn:0000BCBC ; public: __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::~vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>(void)
.text$mn:0000BCBC                 public ??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ
.text$mn:0000BCBC ??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ proc near
.text$mn:0000BCBC                                         ; CODE XREF: __unwindfunclet$??0Session@@QAE@ABU0@@Z$0+6j
.text$mn:0000BCBC                                         ; __unwindfunclet$??0Session@@QAE@ABU0@@Z$1+6j ...
.text$mn:0000BCBC
.text$mn:0000BCBC var_10          = dword ptr -10h
.text$mn:0000BCBC var_C           = dword ptr -0Ch
.text$mn:0000BCBC var_4           = dword ptr -4
.text$mn:0000BCBC
.text$mn:0000BCBC                 push    ebp
.text$mn:0000BCBD                 mov     ebp, esp
.text$mn:0000BCBF                 push    0FFFFFFFFh
.text$mn:0000BCC1                 push    offset __ehhandler$??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ
.text$mn:0000BCC6                 mov     eax, large fs:0
.text$mn:0000BCCC                 push    eax
.text$mn:0000BCCD                 push    ecx
.text$mn:0000BCCE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BCD3                 xor     eax, ebp
.text$mn:0000BCD5                 push    eax
.text$mn:0000BCD6                 lea     eax, [ebp+var_C]
.text$mn:0000BCD9                 mov     large fs:0, eax
.text$mn:0000BCDF                 mov     [ebp+var_10], ecx
.text$mn:0000BCE2                 mov     [ebp+var_4], 0
.text$mn:0000BCE9                 mov     ecx, [ebp+var_10]
.text$mn:0000BCEC                 call    ?_Tidy@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Tidy(void)
.text$mn:0000BCF1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000BCF8                 mov     ecx, [ebp+var_10]
.text$mn:0000BCFB                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>(void)
.text$mn:0000BD00                 mov     ecx, [ebp+var_C]
.text$mn:0000BD03                 mov     large fs:0, ecx
.text$mn:0000BD0A                 pop     ecx
.text$mn:0000BD0B                 mov     esp, ebp
.text$mn:0000BD0D                 pop     ebp
.text$mn:0000BD0E                 retn
.text$mn:0000BD0E ??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ endp
.text$mn:0000BD0E
.text$mn:0000BD0E ; ---------------------------------------------------------------------------
.text$mn:0000BD0F                 align 10h
.text$mn:0000BD0F _text$mn        ends
.text$mn:0000BD0F
.text$x:0000BD10 ; ===========================================================================
.text$x:0000BD10
.text$x:0000BD10 ; Segment type: Pure code
.text$x:0000BD10 ; Segment permissions: Read/Execute
.text$x:0000BD10 _text$x         segment para public 'CODE' use32
.text$x:0000BD10                 assume cs:_text$x
.text$x:0000BD10                 ;org 0BD10h
.text$x:0000BD10 ; COMDAT (pick associative to section at BCBC)
.text$x:0000BD10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BD10
.text$x:0000BD10 ; =============== S U B R O U T I N E =======================================
.text$x:0000BD10
.text$x:0000BD10
.text$x:0000BD10 __unwindfunclet$??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000BD10                                         ; DATA XREF: .xdata$x:000131A8o
.text$x:0000BD10                 mov     ecx, [ebp-10h]
.text$x:0000BD13                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>(void)
.text$x:0000BD13 __unwindfunclet$??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000BD13
.text$x:0000BD18
.text$x:0000BD18 ; =============== S U B R O U T I N E =======================================
.text$x:0000BD18
.text$x:0000BD18
.text$x:0000BD18 __ehhandler$??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ proc near
.text$x:0000BD18                                         ; DATA XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::~vector<sessionFileInfo,std::allocator<sessionFileInfo>>(void)+5o
.text$x:0000BD18
.text$x:0000BD18 arg_4           = dword ptr  8
.text$x:0000BD18
.text$x:0000BD18                 mov     edx, [esp+arg_4]
.text$x:0000BD1C                 lea     eax, [edx+0Ch]
.text$x:0000BD1F                 mov     ecx, [edx-8]
.text$x:0000BD22                 xor     ecx, eax
.text$x:0000BD24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BD29                 mov     eax, offset __ehfuncinfo$??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ
.text$x:0000BD2E                 jmp     ___CxxFrameHandler3
.text$x:0000BD2E __ehhandler$??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ endp
.text$x:0000BD2E
.text$x:0000BD2E ; ---------------------------------------------------------------------------
.text$x:0000BD33                 align 4
.text$x:0000BD33 _text$x         ends
.text$x:0000BD33
.text$mn:0000BD34 ; ===========================================================================
.text$mn:0000BD34
.text$mn:0000BD34 ; Segment type: Pure code
.text$mn:0000BD34 ; Segment permissions: Read/Execute
.text$mn:0000BD34 _text$mn        segment para public 'CODE' use32
.text$mn:0000BD34                 assume cs:_text$mn
.text$mn:0000BD34                 ;org 0BD34h
.text$mn:0000BD34 ; COMDAT (pick any)
.text$mn:0000BD34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BD34
.text$mn:0000BD34 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BD34
.text$mn:0000BD34 ; Attributes: bp-based frame
.text$mn:0000BD34
.text$mn:0000BD34 ; public: __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::~vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(void)
.text$mn:0000BD34                 public ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$mn:0000BD34 ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ proc near
.text$mn:0000BD34                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+B1Ap
.text$mn:0000BD34                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+B29p ...
.text$mn:0000BD34
.text$mn:0000BD34 var_10          = dword ptr -10h
.text$mn:0000BD34 var_C           = dword ptr -0Ch
.text$mn:0000BD34 var_4           = dword ptr -4
.text$mn:0000BD34
.text$mn:0000BD34                 push    ebp
.text$mn:0000BD35                 mov     ebp, esp
.text$mn:0000BD37                 push    0FFFFFFFFh
.text$mn:0000BD39                 push    offset __ehhandler$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$mn:0000BD3E                 mov     eax, large fs:0
.text$mn:0000BD44                 push    eax
.text$mn:0000BD45                 push    ecx
.text$mn:0000BD46                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BD4B                 xor     eax, ebp
.text$mn:0000BD4D                 push    eax
.text$mn:0000BD4E                 lea     eax, [ebp+var_C]
.text$mn:0000BD51                 mov     large fs:0, eax
.text$mn:0000BD57                 mov     [ebp+var_10], ecx
.text$mn:0000BD5A                 mov     [ebp+var_4], 0
.text$mn:0000BD61                 mov     ecx, [ebp+var_10]
.text$mn:0000BD64                 call    ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Tidy(void)
.text$mn:0000BD69                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000BD70                 mov     ecx, [ebp+var_10]
.text$mn:0000BD73                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)
.text$mn:0000BD78                 mov     ecx, [ebp+var_C]
.text$mn:0000BD7B                 mov     large fs:0, ecx
.text$mn:0000BD82                 pop     ecx
.text$mn:0000BD83                 mov     esp, ebp
.text$mn:0000BD85                 pop     ebp
.text$mn:0000BD86                 retn
.text$mn:0000BD86 ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ endp
.text$mn:0000BD86
.text$mn:0000BD86 ; ---------------------------------------------------------------------------
.text$mn:0000BD87                 align 4
.text$mn:0000BD87 _text$mn        ends
.text$mn:0000BD87
.text$x:0000BD88 ; ===========================================================================
.text$x:0000BD88
.text$x:0000BD88 ; Segment type: Pure code
.text$x:0000BD88 ; Segment permissions: Read/Execute
.text$x:0000BD88 _text$x         segment para public 'CODE' use32
.text$x:0000BD88                 assume cs:_text$x
.text$x:0000BD88                 ;org 0BD88h
.text$x:0000BD88 ; COMDAT (pick associative to section at BD34)
.text$x:0000BD88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BD88
.text$x:0000BD88 ; =============== S U B R O U T I N E =======================================
.text$x:0000BD88
.text$x:0000BD88
.text$x:0000BD88 __unwindfunclet$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0 proc near
.text$x:0000BD88                                         ; DATA XREF: .xdata$x:000134C4o
.text$x:0000BD88                 mov     ecx, [ebp-10h]
.text$x:0000BD8B                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)
.text$x:0000BD8B __unwindfunclet$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0 endp
.text$x:0000BD8B
.text$x:0000BD90
.text$x:0000BD90 ; =============== S U B R O U T I N E =======================================
.text$x:0000BD90
.text$x:0000BD90
.text$x:0000BD90 __ehhandler$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ proc near
.text$x:0000BD90                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+5o
.text$x:0000BD90
.text$x:0000BD90 arg_4           = dword ptr  8
.text$x:0000BD90
.text$x:0000BD90                 mov     edx, [esp+arg_4]
.text$x:0000BD94                 lea     eax, [edx+0Ch]
.text$x:0000BD97                 mov     ecx, [edx-8]
.text$x:0000BD9A                 xor     ecx, eax
.text$x:0000BD9C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BDA1                 mov     eax, offset __ehfuncinfo$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$x:0000BDA6                 jmp     ___CxxFrameHandler3
.text$x:0000BDA6 __ehhandler$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ endp
.text$x:0000BDA6
.text$x:0000BDA6 ; ---------------------------------------------------------------------------
.text$x:0000BDAB                 align 4
.text$x:0000BDAB _text$x         ends
.text$x:0000BDAB
.text$mn:0000BDAC ; ===========================================================================
.text$mn:0000BDAC
.text$mn:0000BDAC ; Segment type: Pure code
.text$mn:0000BDAC ; Segment permissions: Read/Execute
.text$mn:0000BDAC _text$mn        segment para public 'CODE' use32
.text$mn:0000BDAC                 assume cs:_text$mn
.text$mn:0000BDAC                 ;org 0BDACh
.text$mn:0000BDAC ; COMDAT (pick any)
.text$mn:0000BDAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BDAC
.text$mn:0000BDAC ; =============== S U B R O U T I N E =======================================
.text$mn:0000BDAC
.text$mn:0000BDAC ; Attributes: bp-based frame
.text$mn:0000BDAC
.text$mn:0000BDAC ; _DWORD __thiscall Session::~Session(Session *__hidden this)
.text$mn:0000BDAC                 public ??1Session@@QAE@XZ
.text$mn:0000BDAC ??1Session@@QAE@XZ proc near            ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+3F7p
.text$mn:0000BDAC                                         ; Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *)+157p ...
.text$mn:0000BDAC
.text$mn:0000BDAC var_10          = dword ptr -10h
.text$mn:0000BDAC var_C           = dword ptr -0Ch
.text$mn:0000BDAC var_4           = dword ptr -4
.text$mn:0000BDAC
.text$mn:0000BDAC                 push    ebp
.text$mn:0000BDAD                 mov     ebp, esp
.text$mn:0000BDAF                 push    0FFFFFFFFh
.text$mn:0000BDB1                 push    offset __ehhandler$??1Session@@QAE@XZ
.text$mn:0000BDB6                 mov     eax, large fs:0
.text$mn:0000BDBC                 push    eax
.text$mn:0000BDBD                 push    ecx
.text$mn:0000BDBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BDC3                 xor     eax, ebp
.text$mn:0000BDC5                 push    eax
.text$mn:0000BDC6                 lea     eax, [ebp+var_C]
.text$mn:0000BDC9                 mov     large fs:0, eax
.text$mn:0000BDCF                 mov     [ebp+var_10], ecx
.text$mn:0000BDD2                 mov     [ebp+var_4], 1
.text$mn:0000BDD9                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000BDDD                 mov     ecx, [ebp+var_10]
.text$mn:0000BDE0                 add     ecx, 1Ch
.text$mn:0000BDE3                 call    ??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::~vector<sessionFileInfo,std::allocator<sessionFileInfo>>(void)
.text$mn:0000BDE8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000BDEF                 mov     ecx, [ebp+var_10]
.text$mn:0000BDF2                 add     ecx, 0Ch
.text$mn:0000BDF5                 call    ??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::~vector<sessionFileInfo,std::allocator<sessionFileInfo>>(void)
.text$mn:0000BDFA                 mov     ecx, [ebp+var_C]
.text$mn:0000BDFD                 mov     large fs:0, ecx
.text$mn:0000BE04                 pop     ecx
.text$mn:0000BE05                 mov     esp, ebp
.text$mn:0000BE07                 pop     ebp
.text$mn:0000BE08                 retn
.text$mn:0000BE08 ??1Session@@QAE@XZ endp
.text$mn:0000BE08
.text$mn:0000BE08 ; ---------------------------------------------------------------------------
.text$mn:0000BE09                 align 4
.text$mn:0000BE09 _text$mn        ends
.text$mn:0000BE09
.text$x:0000BE0C ; ===========================================================================
.text$x:0000BE0C
.text$x:0000BE0C ; Segment type: Pure code
.text$x:0000BE0C ; Segment permissions: Read/Execute
.text$x:0000BE0C _text$x         segment para public 'CODE' use32
.text$x:0000BE0C                 assume cs:_text$x
.text$x:0000BE0C                 ;org 0BE0Ch
.text$x:0000BE0C ; COMDAT (pick associative to section at BDAC)
.text$x:0000BE0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BE0C
.text$x:0000BE0C ; =============== S U B R O U T I N E =======================================
.text$x:0000BE0C
.text$x:0000BE0C
.text$x:0000BE0C __unwindfunclet$??1Session@@QAE@XZ$0 proc near
.text$x:0000BE0C                                         ; DATA XREF: .xdata$x:00013380o
.text$x:0000BE0C                 mov     ecx, [ebp-10h]
.text$x:0000BE0F                 add     ecx, 0Ch
.text$x:0000BE12                 jmp     ??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::~vector<sessionFileInfo,std::allocator<sessionFileInfo>>(void)
.text$x:0000BE12 __unwindfunclet$??1Session@@QAE@XZ$0 endp
.text$x:0000BE12
.text$x:0000BE17
.text$x:0000BE17 ; =============== S U B R O U T I N E =======================================
.text$x:0000BE17
.text$x:0000BE17
.text$x:0000BE17 __unwindfunclet$??1Session@@QAE@XZ$1 proc near
.text$x:0000BE17                                         ; DATA XREF: .xdata$x:00013388o
.text$x:0000BE17                 mov     ecx, [ebp-10h]
.text$x:0000BE1A                 add     ecx, 1Ch
.text$x:0000BE1D                 jmp     ??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::~vector<sessionFileInfo,std::allocator<sessionFileInfo>>(void)
.text$x:0000BE1D __unwindfunclet$??1Session@@QAE@XZ$1 endp
.text$x:0000BE1D
.text$x:0000BE22
.text$x:0000BE22 ; =============== S U B R O U T I N E =======================================
.text$x:0000BE22
.text$x:0000BE22
.text$x:0000BE22 __ehhandler$??1Session@@QAE@XZ proc near
.text$x:0000BE22                                         ; DATA XREF: Session::~Session(void)+5o
.text$x:0000BE22
.text$x:0000BE22 arg_4           = dword ptr  8
.text$x:0000BE22
.text$x:0000BE22                 mov     edx, [esp+arg_4]
.text$x:0000BE26                 lea     eax, [edx+0Ch]
.text$x:0000BE29                 mov     ecx, [edx-8]
.text$x:0000BE2C                 xor     ecx, eax
.text$x:0000BE2E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BE33                 mov     eax, offset __ehfuncinfo$??1Session@@QAE@XZ
.text$x:0000BE38                 jmp     ___CxxFrameHandler3
.text$x:0000BE38 __ehhandler$??1Session@@QAE@XZ endp
.text$x:0000BE38
.text$x:0000BE38 ; ---------------------------------------------------------------------------
.text$x:0000BE3D                 align 10h
.text$x:0000BE3D _text$x         ends
.text$x:0000BE3D
.text$mn:0000BE40 ; ===========================================================================
.text$mn:0000BE40
.text$mn:0000BE40 ; Segment type: Pure code
.text$mn:0000BE40 ; Segment permissions: Read/Execute
.text$mn:0000BE40 _text$mn        segment para public 'CODE' use32
.text$mn:0000BE40                 assume cs:_text$mn
.text$mn:0000BE40                 ;org 0BE40h
.text$mn:0000BE40 ; COMDAT (pick any)
.text$mn:0000BE40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BE40
.text$mn:0000BE40 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BE40
.text$mn:0000BE40 ; Attributes: bp-based frame
.text$mn:0000BE40
.text$mn:0000BE40 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:0000BE40                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:0000BE40 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:0000BE40                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:0000BE40                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:0000BE40
.text$mn:0000BE40 var_4           = dword ptr -4
.text$mn:0000BE40
.text$mn:0000BE40                 push    ebp
.text$mn:0000BE41                 mov     ebp, esp
.text$mn:0000BE43                 push    ecx
.text$mn:0000BE44                 mov     [ebp+var_4], ecx
.text$mn:0000BE47                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000BE4A                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000BE4F                 mov     esp, ebp
.text$mn:0000BE51                 pop     ebp
.text$mn:0000BE52                 retn
.text$mn:0000BE52 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:0000BE52
.text$mn:0000BE52 ; ---------------------------------------------------------------------------
.text$mn:0000BE53                 align 4
.text$mn:0000BE53 _text$mn        ends
.text$mn:0000BE53
.text$mn:0000BE54 ; ===========================================================================
.text$mn:0000BE54
.text$mn:0000BE54 ; Segment type: Pure code
.text$mn:0000BE54 ; Segment permissions: Read/Execute
.text$mn:0000BE54 _text$mn        segment para public 'CODE' use32
.text$mn:0000BE54                 assume cs:_text$mn
.text$mn:0000BE54                 ;org 0BE54h
.text$mn:0000BE54 ; COMDAT (pick any)
.text$mn:0000BE54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BE54
.text$mn:0000BE54 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BE54
.text$mn:0000BE54 ; Attributes: bp-based frame
.text$mn:0000BE54
.text$mn:0000BE54 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:0000BE54                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:0000BE54 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:0000BE54                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:0000BE54                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:0000BE54
.text$mn:0000BE54 var_10          = dword ptr -10h
.text$mn:0000BE54 var_C           = dword ptr -0Ch
.text$mn:0000BE54 var_4           = dword ptr -4
.text$mn:0000BE54
.text$mn:0000BE54                 push    ebp
.text$mn:0000BE55                 mov     ebp, esp
.text$mn:0000BE57                 push    0FFFFFFFFh
.text$mn:0000BE59                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:0000BE5E                 mov     eax, large fs:0
.text$mn:0000BE64                 push    eax
.text$mn:0000BE65                 push    ecx
.text$mn:0000BE66                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BE6B                 xor     eax, ebp
.text$mn:0000BE6D                 push    eax
.text$mn:0000BE6E                 lea     eax, [ebp+var_C]
.text$mn:0000BE71                 mov     large fs:0, eax
.text$mn:0000BE77                 mov     [ebp+var_10], ecx
.text$mn:0000BE7A                 mov     [ebp+var_4], 0
.text$mn:0000BE81                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000BE88                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000BE8B                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000BE90                 mov     ecx, [ebp+var_C]
.text$mn:0000BE93                 mov     large fs:0, ecx
.text$mn:0000BE9A                 pop     ecx
.text$mn:0000BE9B                 mov     esp, ebp
.text$mn:0000BE9D                 pop     ebp
.text$mn:0000BE9E                 retn
.text$mn:0000BE9E ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:0000BE9E
.text$mn:0000BE9E ; ---------------------------------------------------------------------------
.text$mn:0000BE9F                 align 10h
.text$mn:0000BE9F _text$mn        ends
.text$mn:0000BE9F
.text$x:0000BEA0 ; ===========================================================================
.text$x:0000BEA0
.text$x:0000BEA0 ; Segment type: Pure code
.text$x:0000BEA0 ; Segment permissions: Read/Execute
.text$x:0000BEA0 _text$x         segment para public 'CODE' use32
.text$x:0000BEA0                 assume cs:_text$x
.text$x:0000BEA0                 ;org 0BEA0h
.text$x:0000BEA0 ; COMDAT (pick associative to section at BE54)
.text$x:0000BEA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BEA0
.text$x:0000BEA0 ; =============== S U B R O U T I N E =======================================
.text$x:0000BEA0
.text$x:0000BEA0
.text$x:0000BEA0 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:0000BEA0                                         ; DATA XREF: .xdata$x:00012614o
.text$x:0000BEA0                 mov     ecx, [ebp-10h]  ; this
.text$x:0000BEA3                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000BEA3 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:0000BEA3
.text$x:0000BEA8
.text$x:0000BEA8 ; =============== S U B R O U T I N E =======================================
.text$x:0000BEA8
.text$x:0000BEA8
.text$x:0000BEA8 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:0000BEA8                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:0000BEA8
.text$x:0000BEA8 arg_4           = dword ptr  8
.text$x:0000BEA8
.text$x:0000BEA8                 mov     edx, [esp+arg_4]
.text$x:0000BEAC                 lea     eax, [edx+0Ch]
.text$x:0000BEAF                 mov     ecx, [edx-8]
.text$x:0000BEB2                 xor     ecx, eax
.text$x:0000BEB4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BEB9                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:0000BEBE                 jmp     ___CxxFrameHandler3
.text$x:0000BEBE __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:0000BEBE
.text$x:0000BEBE ; ---------------------------------------------------------------------------
.text$x:0000BEC3                 align 4
.text$x:0000BEC3 _text$x         ends
.text$x:0000BEC3
.text$mn:0000BEC4 ; ===========================================================================
.text$mn:0000BEC4
.text$mn:0000BEC4 ; Segment type: Pure code
.text$mn:0000BEC4 ; Segment permissions: Read/Execute
.text$mn:0000BEC4 _text$mn        segment para public 'CODE' use32
.text$mn:0000BEC4                 assume cs:_text$mn
.text$mn:0000BEC4                 ;org 0BEC4h
.text$mn:0000BEC4 ; COMDAT (pick any)
.text$mn:0000BEC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BEC4
.text$mn:0000BEC4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BEC4
.text$mn:0000BEC4 ; Attributes: bp-based frame
.text$mn:0000BEC4
.text$mn:0000BEC4 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:0000BEC4                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:0000BEC4 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:0000BEC4                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:0000BEC4                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:0000BEC4
.text$mn:0000BEC4 var_10          = dword ptr -10h
.text$mn:0000BEC4 var_C           = dword ptr -0Ch
.text$mn:0000BEC4 var_4           = dword ptr -4
.text$mn:0000BEC4
.text$mn:0000BEC4                 push    ebp
.text$mn:0000BEC5                 mov     ebp, esp
.text$mn:0000BEC7                 push    0FFFFFFFFh
.text$mn:0000BEC9                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:0000BECE                 mov     eax, large fs:0
.text$mn:0000BED4                 push    eax
.text$mn:0000BED5                 push    ecx
.text$mn:0000BED6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BEDB                 xor     eax, ebp
.text$mn:0000BEDD                 push    eax
.text$mn:0000BEDE                 lea     eax, [ebp+var_C]
.text$mn:0000BEE1                 mov     large fs:0, eax
.text$mn:0000BEE7                 mov     [ebp+var_10], ecx
.text$mn:0000BEEA                 mov     [ebp+var_4], 0
.text$mn:0000BEF1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000BEF8                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000BEFB                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000BF00                 mov     ecx, [ebp+var_C]
.text$mn:0000BF03                 mov     large fs:0, ecx
.text$mn:0000BF0A                 pop     ecx
.text$mn:0000BF0B                 mov     esp, ebp
.text$mn:0000BF0D                 pop     ebp
.text$mn:0000BF0E                 retn
.text$mn:0000BF0E ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:0000BF0E
.text$mn:0000BF0E ; ---------------------------------------------------------------------------
.text$mn:0000BF0F                 align 10h
.text$mn:0000BF0F _text$mn        ends
.text$mn:0000BF0F
.text$x:0000BF10 ; ===========================================================================
.text$x:0000BF10
.text$x:0000BF10 ; Segment type: Pure code
.text$x:0000BF10 ; Segment permissions: Read/Execute
.text$x:0000BF10 _text$x         segment para public 'CODE' use32
.text$x:0000BF10                 assume cs:_text$x
.text$x:0000BF10                 ;org 0BF10h
.text$x:0000BF10 ; COMDAT (pick associative to section at BEC4)
.text$x:0000BF10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BF10
.text$x:0000BF10 ; =============== S U B R O U T I N E =======================================
.text$x:0000BF10
.text$x:0000BF10
.text$x:0000BF10 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:0000BF10                                         ; DATA XREF: .xdata$x:00012698o
.text$x:0000BF10                 mov     ecx, [ebp-10h]  ; this
.text$x:0000BF13                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000BF13 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:0000BF13
.text$x:0000BF18
.text$x:0000BF18 ; =============== S U B R O U T I N E =======================================
.text$x:0000BF18
.text$x:0000BF18
.text$x:0000BF18 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:0000BF18                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:0000BF18
.text$x:0000BF18 arg_4           = dword ptr  8
.text$x:0000BF18
.text$x:0000BF18                 mov     edx, [esp+arg_4]
.text$x:0000BF1C                 lea     eax, [edx+0Ch]
.text$x:0000BF1F                 mov     ecx, [edx-8]
.text$x:0000BF22                 xor     ecx, eax
.text$x:0000BF24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BF29                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:0000BF2E                 jmp     ___CxxFrameHandler3
.text$x:0000BF2E __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:0000BF2E
.text$x:0000BF2E ; ---------------------------------------------------------------------------
.text$x:0000BF33                 align 4
.text$x:0000BF33 _text$x         ends
.text$x:0000BF33
.text$mn:0000BF34 ; ===========================================================================
.text$mn:0000BF34
.text$mn:0000BF34 ; Segment type: Pure code
.text$mn:0000BF34 ; Segment permissions: Read/Execute
.text$mn:0000BF34 _text$mn        segment para public 'CODE' use32
.text$mn:0000BF34                 assume cs:_text$mn
.text$mn:0000BF34                 ;org 0BF34h
.text$mn:0000BF34 ; COMDAT (pick any)
.text$mn:0000BF34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BF34
.text$mn:0000BF34 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BF34
.text$mn:0000BF34 ; Attributes: bp-based frame
.text$mn:0000BF34
.text$mn:0000BF34 ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:0000BF34                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:0000BF34 ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:0000BF34                                         ; CODE XREF: __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0+3j
.text$mn:0000BF34                                         ; __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0+3j ...
.text$mn:0000BF34
.text$mn:0000BF34 var_14          = byte ptr -14h
.text$mn:0000BF34 var_10          = dword ptr -10h
.text$mn:0000BF34 var_C           = dword ptr -0Ch
.text$mn:0000BF34 var_4           = dword ptr -4
.text$mn:0000BF34
.text$mn:0000BF34                 push    ebp
.text$mn:0000BF35                 mov     ebp, esp
.text$mn:0000BF37                 push    0FFFFFFFFh
.text$mn:0000BF39                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:0000BF3E                 mov     eax, large fs:0
.text$mn:0000BF44                 push    eax
.text$mn:0000BF45                 sub     esp, 8
.text$mn:0000BF48                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BF4D                 xor     eax, ebp
.text$mn:0000BF4F                 push    eax
.text$mn:0000BF50                 lea     eax, [ebp+var_C]
.text$mn:0000BF53                 mov     large fs:0, eax
.text$mn:0000BF59                 mov     [ebp+var_10], ecx
.text$mn:0000BF5C                 push    3               ; int
.text$mn:0000BF5E                 lea     ecx, [ebp+var_14] ; this
.text$mn:0000BF61                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000BF66                 mov     [ebp+var_4], 0
.text$mn:0000BF6D                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000BF70                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:0000BF75                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000BF7C                 lea     ecx, [ebp+var_14] ; this
.text$mn:0000BF7F                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000BF84                 mov     ecx, [ebp+var_C]
.text$mn:0000BF87                 mov     large fs:0, ecx
.text$mn:0000BF8E                 pop     ecx
.text$mn:0000BF8F                 mov     esp, ebp
.text$mn:0000BF91                 pop     ebp
.text$mn:0000BF92                 retn
.text$mn:0000BF92 ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:0000BF92
.text$mn:0000BF92 ; ---------------------------------------------------------------------------
.text$mn:0000BF93                 align 4
.text$mn:0000BF93 _text$mn        ends
.text$mn:0000BF93
.text$x:0000BF94 ; ===========================================================================
.text$x:0000BF94
.text$x:0000BF94 ; Segment type: Pure code
.text$x:0000BF94 ; Segment permissions: Read/Execute
.text$x:0000BF94 _text$x         segment para public 'CODE' use32
.text$x:0000BF94                 assume cs:_text$x
.text$x:0000BF94                 ;org 0BF94h
.text$x:0000BF94 ; COMDAT (pick associative to section at BF34)
.text$x:0000BF94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BF94
.text$x:0000BF94 ; =============== S U B R O U T I N E =======================================
.text$x:0000BF94
.text$x:0000BF94
.text$x:0000BF94 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:0000BF94                                         ; DATA XREF: .xdata$x:000123C8o
.text$x:0000BF94                 lea     ecx, [ebp-14h]  ; this
.text$x:0000BF97                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000BF97 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:0000BF97
.text$x:0000BF9C
.text$x:0000BF9C ; =============== S U B R O U T I N E =======================================
.text$x:0000BF9C
.text$x:0000BF9C
.text$x:0000BF9C __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:0000BF9C                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:0000BF9C
.text$x:0000BF9C arg_4           = dword ptr  8
.text$x:0000BF9C
.text$x:0000BF9C                 mov     edx, [esp+arg_4]
.text$x:0000BFA0                 lea     eax, [edx+0Ch]
.text$x:0000BFA3                 mov     ecx, [edx-0Ch]
.text$x:0000BFA6                 xor     ecx, eax
.text$x:0000BFA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BFAD                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:0000BFB2                 jmp     ___CxxFrameHandler3
.text$x:0000BFB2 __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:0000BFB2
.text$x:0000BFB2 ; ---------------------------------------------------------------------------
.text$x:0000BFB7                 align 4
.text$x:0000BFB7 _text$x         ends
.text$x:0000BFB7
.text$mn:0000BFB8 ; ===========================================================================
.text$mn:0000BFB8
.text$mn:0000BFB8 ; Segment type: Pure code
.text$mn:0000BFB8 ; Segment permissions: Read/Execute
.text$mn:0000BFB8 _text$mn        segment para public 'CODE' use32
.text$mn:0000BFB8                 assume cs:_text$mn
.text$mn:0000BFB8                 ;org 0BFB8h
.text$mn:0000BFB8 ; COMDAT (pick any)
.text$mn:0000BFB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BFB8
.text$mn:0000BFB8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BFB8
.text$mn:0000BFB8 ; Attributes: bp-based frame
.text$mn:0000BFB8
.text$mn:0000BFB8 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:0000BFB8                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:0000BFB8 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:0000BFB8                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:0000BFB8                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:0000BFB8
.text$mn:0000BFB8 var_10          = dword ptr -10h
.text$mn:0000BFB8 var_C           = dword ptr -0Ch
.text$mn:0000BFB8 var_4           = dword ptr -4
.text$mn:0000BFB8
.text$mn:0000BFB8                 push    ebp
.text$mn:0000BFB9                 mov     ebp, esp
.text$mn:0000BFBB                 push    0FFFFFFFFh
.text$mn:0000BFBD                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:0000BFC2                 mov     eax, large fs:0
.text$mn:0000BFC8                 push    eax
.text$mn:0000BFC9                 push    ecx
.text$mn:0000BFCA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BFCF                 xor     eax, ebp
.text$mn:0000BFD1                 push    eax
.text$mn:0000BFD2                 lea     eax, [ebp+var_C]
.text$mn:0000BFD5                 mov     large fs:0, eax
.text$mn:0000BFDB                 mov     [ebp+var_10], ecx
.text$mn:0000BFDE                 mov     [ebp+var_4], 0
.text$mn:0000BFE5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000BFEC                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000BFEF                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000BFF4                 mov     ecx, [ebp+var_C]
.text$mn:0000BFF7                 mov     large fs:0, ecx
.text$mn:0000BFFE                 pop     ecx
.text$mn:0000BFFF                 mov     esp, ebp
.text$mn:0000C001                 pop     ebp
.text$mn:0000C002                 retn
.text$mn:0000C002 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:0000C002
.text$mn:0000C002 ; ---------------------------------------------------------------------------
.text$mn:0000C003                 align 4
.text$mn:0000C003 _text$mn        ends
.text$mn:0000C003
.text$x:0000C004 ; ===========================================================================
.text$x:0000C004
.text$x:0000C004 ; Segment type: Pure code
.text$x:0000C004 ; Segment permissions: Read/Execute
.text$x:0000C004 _text$x         segment para public 'CODE' use32
.text$x:0000C004                 assume cs:_text$x
.text$x:0000C004                 ;org 0C004h
.text$x:0000C004 ; COMDAT (pick associative to section at BFB8)
.text$x:0000C004                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C004
.text$x:0000C004 ; =============== S U B R O U T I N E =======================================
.text$x:0000C004
.text$x:0000C004
.text$x:0000C004 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:0000C004                                         ; DATA XREF: .xdata$x:0001271Co
.text$x:0000C004                 mov     ecx, [ebp-10h]  ; this
.text$x:0000C007                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000C007 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:0000C007
.text$x:0000C00C
.text$x:0000C00C ; =============== S U B R O U T I N E =======================================
.text$x:0000C00C
.text$x:0000C00C
.text$x:0000C00C __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:0000C00C                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:0000C00C
.text$x:0000C00C arg_4           = dword ptr  8
.text$x:0000C00C
.text$x:0000C00C                 mov     edx, [esp+arg_4]
.text$x:0000C010                 lea     eax, [edx+0Ch]
.text$x:0000C013                 mov     ecx, [edx-8]
.text$x:0000C016                 xor     ecx, eax
.text$x:0000C018                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C01D                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:0000C022                 jmp     ___CxxFrameHandler3
.text$x:0000C022 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:0000C022
.text$x:0000C022 ; ---------------------------------------------------------------------------
.text$x:0000C027                 align 4
.text$x:0000C027 _text$x         ends
.text$x:0000C027
.text$mn:0000C028 ; ===========================================================================
.text$mn:0000C028
.text$mn:0000C028 ; Segment type: Pure code
.text$mn:0000C028 ; Segment permissions: Read/Execute
.text$mn:0000C028 _text$mn        segment para public 'CODE' use32
.text$mn:0000C028                 assume cs:_text$mn
.text$mn:0000C028                 ;org 0C028h
.text$mn:0000C028 ; COMDAT (pick any)
.text$mn:0000C028                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C028
.text$mn:0000C028 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C028
.text$mn:0000C028 ; Attributes: bp-based frame
.text$mn:0000C028
.text$mn:0000C028 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:0000C028                 public ??1error_category@std@@UAE@XZ
.text$mn:0000C028 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:0000C028                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:0000C028
.text$mn:0000C028 var_4           = dword ptr -4
.text$mn:0000C028
.text$mn:0000C028                 push    ebp
.text$mn:0000C029                 mov     ebp, esp
.text$mn:0000C02B                 push    ecx
.text$mn:0000C02C                 mov     [ebp+var_4], ecx
.text$mn:0000C02F                 mov     eax, [ebp+var_4]
.text$mn:0000C032                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:0000C038                 mov     esp, ebp
.text$mn:0000C03A                 pop     ebp
.text$mn:0000C03B                 retn
.text$mn:0000C03B ??1error_category@std@@UAE@XZ endp
.text$mn:0000C03B
.text$mn:0000C03B _text$mn        ends
.text$mn:0000C03B
.text$mn:0000C03C ; ===========================================================================
.text$mn:0000C03C
.text$mn:0000C03C ; Segment type: Pure code
.text$mn:0000C03C ; Segment permissions: Read/Execute
.text$mn:0000C03C _text$mn        segment para public 'CODE' use32
.text$mn:0000C03C                 assume cs:_text$mn
.text$mn:0000C03C                 ;org 0C03Ch
.text$mn:0000C03C ; COMDAT (pick any)
.text$mn:0000C03C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C03C
.text$mn:0000C03C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C03C
.text$mn:0000C03C ; Attributes: bp-based frame
.text$mn:0000C03C
.text$mn:0000C03C ; _DWORD __thiscall sessionFileInfo::~sessionFileInfo(sessionFileInfo *__hidden this)
.text$mn:0000C03C                 public ??1sessionFileInfo@@QAE@XZ
.text$mn:0000C03C ??1sessionFileInfo@@QAE@XZ proc near    ; CODE XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *)+10Ap
.text$mn:0000C03C                                         ; __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z$2+6j ...
.text$mn:0000C03C
.text$mn:0000C03C var_10          = dword ptr -10h
.text$mn:0000C03C var_C           = dword ptr -0Ch
.text$mn:0000C03C var_4           = dword ptr -4
.text$mn:0000C03C
.text$mn:0000C03C                 push    ebp
.text$mn:0000C03D                 mov     ebp, esp
.text$mn:0000C03F                 push    0FFFFFFFFh
.text$mn:0000C041                 push    offset __ehhandler$??1sessionFileInfo@@QAE@XZ
.text$mn:0000C046                 mov     eax, large fs:0
.text$mn:0000C04C                 push    eax
.text$mn:0000C04D                 push    ecx
.text$mn:0000C04E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000C053                 xor     eax, ebp
.text$mn:0000C055                 push    eax
.text$mn:0000C056                 lea     eax, [ebp+var_C]
.text$mn:0000C059                 mov     large fs:0, eax
.text$mn:0000C05F                 mov     [ebp+var_10], ecx
.text$mn:0000C062                 mov     [ebp+var_4], 4
.text$mn:0000C069                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000C06D                 mov     ecx, [ebp+var_10]
.text$mn:0000C070                 add     ecx, 74h ; 't'
.text$mn:0000C073                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000C078                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000C07C                 mov     ecx, [ebp+var_10]
.text$mn:0000C07F                 add     ecx, 60h ; '`'
.text$mn:0000C082                 call    ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<uint,std::allocator<uint>>::~vector<uint,std::allocator<uint>>(void)
.text$mn:0000C087                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000C08B                 mov     ecx, [ebp+var_10]
.text$mn:0000C08E                 add     ecx, 50h ; 'P'
.text$mn:0000C091                 call    ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<uint,std::allocator<uint>>::~vector<uint,std::allocator<uint>>(void)
.text$mn:0000C096                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000C09A                 mov     ecx, [ebp+var_10]
.text$mn:0000C09D                 add     ecx, 34h ; '4'
.text$mn:0000C0A0                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000C0A5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000C0AC                 mov     ecx, [ebp+var_10]
.text$mn:0000C0AF                 add     ecx, 18h
.text$mn:0000C0B2                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000C0B7                 mov     ecx, [ebp+var_C]
.text$mn:0000C0BA                 mov     large fs:0, ecx
.text$mn:0000C0C1                 pop     ecx
.text$mn:0000C0C2                 mov     esp, ebp
.text$mn:0000C0C4                 pop     ebp
.text$mn:0000C0C5                 retn
.text$mn:0000C0C5 ??1sessionFileInfo@@QAE@XZ endp
.text$mn:0000C0C5
.text$mn:0000C0C5 ; ---------------------------------------------------------------------------
.text$mn:0000C0C6                 align 4
.text$mn:0000C0C6 _text$mn        ends
.text$mn:0000C0C6
.text$x:0000C0C8 ; ===========================================================================
.text$x:0000C0C8
.text$x:0000C0C8 ; Segment type: Pure code
.text$x:0000C0C8 ; Segment permissions: Read/Execute
.text$x:0000C0C8 _text$x         segment para public 'CODE' use32
.text$x:0000C0C8                 assume cs:_text$x
.text$x:0000C0C8                 ;org 0C0C8h
.text$x:0000C0C8 ; COMDAT (pick associative to section at C03C)
.text$x:0000C0C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C0C8
.text$x:0000C0C8 ; =============== S U B R O U T I N E =======================================
.text$x:0000C0C8
.text$x:0000C0C8
.text$x:0000C0C8 __unwindfunclet$??1sessionFileInfo@@QAE@XZ$0 proc near
.text$x:0000C0C8                                         ; DATA XREF: .xdata$x:00012FBCo
.text$x:0000C0C8                 mov     ecx, [ebp-10h]
.text$x:0000C0CB                 add     ecx, 18h
.text$x:0000C0CE                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000C0CE __unwindfunclet$??1sessionFileInfo@@QAE@XZ$0 endp
.text$x:0000C0CE
.text$x:0000C0D3
.text$x:0000C0D3 ; =============== S U B R O U T I N E =======================================
.text$x:0000C0D3
.text$x:0000C0D3
.text$x:0000C0D3 __unwindfunclet$??1sessionFileInfo@@QAE@XZ$1 proc near
.text$x:0000C0D3                                         ; DATA XREF: .xdata$x:00012FC4o
.text$x:0000C0D3                 mov     ecx, [ebp-10h]
.text$x:0000C0D6                 add     ecx, 34h ; '4'
.text$x:0000C0D9                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000C0D9 __unwindfunclet$??1sessionFileInfo@@QAE@XZ$1 endp
.text$x:0000C0D9
.text$x:0000C0DE
.text$x:0000C0DE ; =============== S U B R O U T I N E =======================================
.text$x:0000C0DE
.text$x:0000C0DE
.text$x:0000C0DE __unwindfunclet$??1sessionFileInfo@@QAE@XZ$2 proc near
.text$x:0000C0DE                                         ; DATA XREF: .xdata$x:00012FCCo
.text$x:0000C0DE                 mov     ecx, [ebp-10h]
.text$x:0000C0E1                 add     ecx, 50h ; 'P'
.text$x:0000C0E4                 jmp     ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<uint,std::allocator<uint>>::~vector<uint,std::allocator<uint>>(void)
.text$x:0000C0E4 __unwindfunclet$??1sessionFileInfo@@QAE@XZ$2 endp
.text$x:0000C0E4
.text$x:0000C0E9
.text$x:0000C0E9 ; =============== S U B R O U T I N E =======================================
.text$x:0000C0E9
.text$x:0000C0E9
.text$x:0000C0E9 __unwindfunclet$??1sessionFileInfo@@QAE@XZ$3 proc near
.text$x:0000C0E9                                         ; DATA XREF: .xdata$x:00012FD4o
.text$x:0000C0E9                 mov     ecx, [ebp-10h]
.text$x:0000C0EC                 add     ecx, 60h ; '`'
.text$x:0000C0EF                 jmp     ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<uint,std::allocator<uint>>::~vector<uint,std::allocator<uint>>(void)
.text$x:0000C0EF __unwindfunclet$??1sessionFileInfo@@QAE@XZ$3 endp
.text$x:0000C0EF
.text$x:0000C0F4
.text$x:0000C0F4 ; =============== S U B R O U T I N E =======================================
.text$x:0000C0F4
.text$x:0000C0F4
.text$x:0000C0F4 __unwindfunclet$??1sessionFileInfo@@QAE@XZ$4 proc near
.text$x:0000C0F4                                         ; DATA XREF: .xdata$x:00012FDCo
.text$x:0000C0F4                 mov     ecx, [ebp-10h]
.text$x:0000C0F7                 add     ecx, 74h ; 't'
.text$x:0000C0FA                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000C0FA __unwindfunclet$??1sessionFileInfo@@QAE@XZ$4 endp
.text$x:0000C0FA
.text$x:0000C0FF
.text$x:0000C0FF ; =============== S U B R O U T I N E =======================================
.text$x:0000C0FF
.text$x:0000C0FF
.text$x:0000C0FF __ehhandler$??1sessionFileInfo@@QAE@XZ proc near
.text$x:0000C0FF                                         ; DATA XREF: sessionFileInfo::~sessionFileInfo(void)+5o
.text$x:0000C0FF
.text$x:0000C0FF arg_4           = dword ptr  8
.text$x:0000C0FF
.text$x:0000C0FF                 mov     edx, [esp+arg_4]
.text$x:0000C103                 lea     eax, [edx+0Ch]
.text$x:0000C106                 mov     ecx, [edx-8]
.text$x:0000C109                 xor     ecx, eax
.text$x:0000C10B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C110                 mov     eax, offset __ehfuncinfo$??1sessionFileInfo@@QAE@XZ
.text$x:0000C115                 jmp     ___CxxFrameHandler3
.text$x:0000C115 __ehhandler$??1sessionFileInfo@@QAE@XZ endp
.text$x:0000C115
.text$x:0000C115 ; ---------------------------------------------------------------------------
.text$x:0000C11A                 align 4
.text$x:0000C11A _text$x         ends
.text$x:0000C11A
.text$mn:0000C11C ; ===========================================================================
.text$mn:0000C11C
.text$mn:0000C11C ; Segment type: Pure code
.text$mn:0000C11C ; Segment permissions: Read/Execute
.text$mn:0000C11C _text$mn        segment para public 'CODE' use32
.text$mn:0000C11C                 assume cs:_text$mn
.text$mn:0000C11C                 ;org 0C11Ch
.text$mn:0000C11C ; COMDAT (pick any)
.text$mn:0000C11C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C11C
.text$mn:0000C11C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C11C
.text$mn:0000C11C ; Attributes: bp-based frame
.text$mn:0000C11C
.text$mn:0000C11C ; void *__cdecl operator new(unsigned int, void *)
.text$mn:0000C11C                 public ??2@YAPAXIPAX@Z
.text$mn:0000C11C ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<int>::construct<int,int &>(int *,int &)+2Ep
.text$mn:0000C11C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep ...
.text$mn:0000C11C
.text$mn:0000C11C arg_4           = dword ptr  0Ch
.text$mn:0000C11C
.text$mn:0000C11C                 push    ebp
.text$mn:0000C11D                 mov     ebp, esp
.text$mn:0000C11F                 mov     eax, [ebp+arg_4]
.text$mn:0000C122                 pop     ebp
.text$mn:0000C123                 retn
.text$mn:0000C123 ??2@YAPAXIPAX@Z endp
.text$mn:0000C123
.text$mn:0000C123 _text$mn        ends
.text$mn:0000C123
.text$mn:0000C124 ; ===========================================================================
.text$mn:0000C124
.text$mn:0000C124 ; Segment type: Pure code
.text$mn:0000C124 ; Segment permissions: Read/Execute
.text$mn:0000C124 _text$mn        segment para public 'CODE' use32
.text$mn:0000C124                 assume cs:_text$mn
.text$mn:0000C124                 ;org 0C124h
.text$mn:0000C124 ; COMDAT (pick any)
.text$mn:0000C124                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C124
.text$mn:0000C124 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C124
.text$mn:0000C124 ; Attributes: bp-based frame
.text$mn:0000C124
.text$mn:0000C124 ; void __cdecl operator delete(void *)
.text$mn:0000C124                 public ??3@YAXPAX0@Z
.text$mn:0000C124 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z$0+8p
.text$mn:0000C124                                         ; __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p ...
.text$mn:0000C124                 push    ebp
.text$mn:0000C125                 mov     ebp, esp
.text$mn:0000C127                 pop     ebp
.text$mn:0000C128                 retn
.text$mn:0000C128 ??3@YAXPAX0@Z   endp
.text$mn:0000C128
.text$mn:0000C128 ; ---------------------------------------------------------------------------
.text$mn:0000C129                 align 4
.text$mn:0000C129 _text$mn        ends
.text$mn:0000C129
.text$mn:0000C12C ; ===========================================================================
.text$mn:0000C12C
.text$mn:0000C12C ; Segment type: Pure code
.text$mn:0000C12C ; Segment permissions: Read/Execute
.text$mn:0000C12C _text$mn        segment para public 'CODE' use32
.text$mn:0000C12C                 assume cs:_text$mn
.text$mn:0000C12C                 ;org 0C12Ch
.text$mn:0000C12C ; COMDAT (pick any)
.text$mn:0000C12C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C12C
.text$mn:0000C12C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C12C
.text$mn:0000C12C ; Attributes: bp-based frame
.text$mn:0000C12C
.text$mn:0000C12C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator=(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &&)
.text$mn:0000C12C                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
.text$mn:0000C12C ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z proc near
.text$mn:0000C12C                                         ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+261p
.text$mn:0000C12C
.text$mn:0000C12C var_2C          = dword ptr -2Ch
.text$mn:0000C12C var_28          = dword ptr -28h
.text$mn:0000C12C var_24          = dword ptr -24h
.text$mn:0000C12C var_20          = dword ptr -20h
.text$mn:0000C12C var_1C          = dword ptr -1Ch
.text$mn:0000C12C var_18          = dword ptr -18h
.text$mn:0000C12C var_14          = dword ptr -14h
.text$mn:0000C12C var_F           = byte ptr -0Fh
.text$mn:0000C12C var_E           = byte ptr -0Eh
.text$mn:0000C12C var_D           = byte ptr -0Dh
.text$mn:0000C12C var_C           = dword ptr -0Ch
.text$mn:0000C12C var_4           = dword ptr -4
.text$mn:0000C12C arg_0           = dword ptr  8
.text$mn:0000C12C
.text$mn:0000C12C                 push    ebp
.text$mn:0000C12D                 mov     ebp, esp
.text$mn:0000C12F                 push    0FFFFFFFFh
.text$mn:0000C131                 push    offset __ehhandler$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
.text$mn:0000C136                 mov     eax, large fs:0
.text$mn:0000C13C                 push    eax
.text$mn:0000C13D                 sub     esp, 20h
.text$mn:0000C140                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000C145                 xor     eax, ebp
.text$mn:0000C147                 push    eax
.text$mn:0000C148                 lea     eax, [ebp+var_C]
.text$mn:0000C14B                 mov     large fs:0, eax
.text$mn:0000C151                 mov     [ebp+var_14], ecx
.text$mn:0000C154                 mov     eax, [ebp+var_14]
.text$mn:0000C157                 cmp     eax, [ebp+arg_0]
.text$mn:0000C15A                 jz      loc_C213
.text$mn:0000C160                 push    0
.text$mn:0000C162                 push    1
.text$mn:0000C164                 mov     ecx, [ebp+var_14]
.text$mn:0000C167                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000C16C                 xor     ecx, ecx
.text$mn:0000C16E                 jz      short loc_C185
.text$mn:0000C170                 lea     edx, [ebp+var_D]
.text$mn:0000C173                 push    edx
.text$mn:0000C174                 mov     ecx, [ebp+arg_0]
.text$mn:0000C177                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000C17C                 push    eax
.text$mn:0000C17D                 mov     ecx, [ebp+var_14]
.text$mn:0000C180                 call    ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Change_alloc(std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:0000C185
.text$mn:0000C185 loc_C185:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+42j
.text$mn:0000C185                 lea     eax, [ebp+var_E]
.text$mn:0000C188                 push    eax
.text$mn:0000C189                 mov     ecx, [ebp+arg_0]
.text$mn:0000C18C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000C191                 push    eax
.text$mn:0000C192                 lea     ecx, [ebp+var_F]
.text$mn:0000C195                 push    ecx
.text$mn:0000C196                 mov     ecx, [ebp+var_14]
.text$mn:0000C199                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000C19E                 push    eax
.text$mn:0000C19F                 call    ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:0000C1A4                 add     esp, 8
.text$mn:0000C1A7                 movzx   edx, al
.text$mn:0000C1AA                 test    edx, edx
.text$mn:0000C1AC                 jz      short loc_C1FE
.text$mn:0000C1AE                 sub     esp, 0Ch
.text$mn:0000C1B1                 mov     eax, esp
.text$mn:0000C1B3                 mov     [ebp+var_20], esp
.text$mn:0000C1B6                 push    eax
.text$mn:0000C1B7                 mov     ecx, [ebp+arg_0]
.text$mn:0000C1BA                 call    ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)
.text$mn:0000C1BF                 mov     [ebp+var_18], eax
.text$mn:0000C1C2                 mov     ecx, [ebp+var_18]
.text$mn:0000C1C5                 mov     [ebp+var_24], ecx
.text$mn:0000C1C8                 mov     [ebp+var_4], 0
.text$mn:0000C1CF                 sub     esp, 0Ch
.text$mn:0000C1D2                 mov     edx, esp
.text$mn:0000C1D4                 mov     [ebp+var_28], esp
.text$mn:0000C1D7                 push    edx
.text$mn:0000C1D8                 mov     ecx, [ebp+arg_0]
.text$mn:0000C1DB                 call    ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)
.text$mn:0000C1E0                 mov     [ebp+var_1C], eax
.text$mn:0000C1E3                 mov     eax, [ebp+var_1C]
.text$mn:0000C1E6                 mov     [ebp+var_2C], eax
.text$mn:0000C1E9                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000C1ED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000C1F4                 mov     ecx, [ebp+var_14]
.text$mn:0000C1F7                 call    ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:0000C1FC                 jmp     short loc_C213
.text$mn:0000C1FE ; ---------------------------------------------------------------------------
.text$mn:0000C1FE
.text$mn:0000C1FE loc_C1FE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+80j
.text$mn:0000C1FE                 mov     ecx, [ebp+arg_0]
.text$mn:0000C201                 push    ecx
.text$mn:0000C202                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:0000C207                 add     esp, 4
.text$mn:0000C20A                 push    eax
.text$mn:0000C20B                 mov     ecx, [ebp+var_14]
.text$mn:0000C20E                 call    ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:0000C213
.text$mn:0000C213 loc_C213:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+2Ej
.text$mn:0000C213                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+D0j
.text$mn:0000C213                 mov     eax, [ebp+var_14]
.text$mn:0000C216                 mov     ecx, [ebp+var_C]
.text$mn:0000C219                 mov     large fs:0, ecx
.text$mn:0000C220                 pop     ecx
.text$mn:0000C221                 mov     esp, ebp
.text$mn:0000C223                 pop     ebp
.text$mn:0000C224                 retn    4
.text$mn:0000C224 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z endp
.text$mn:0000C224
.text$mn:0000C224 ; ---------------------------------------------------------------------------
.text$mn:0000C227                 align 4
.text$mn:0000C227 _text$mn        ends
.text$mn:0000C227
.text$x:0000C228 ; ===========================================================================
.text$x:0000C228
.text$x:0000C228 ; Segment type: Pure code
.text$x:0000C228 ; Segment permissions: Read/Execute
.text$x:0000C228 _text$x         segment para public 'CODE' use32
.text$x:0000C228                 assume cs:_text$x
.text$x:0000C228                 ;org 0C228h
.text$x:0000C228 ; COMDAT (pick associative to section at C12C)
.text$x:0000C228                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C228
.text$x:0000C228 ; =============== S U B R O U T I N E =======================================
.text$x:0000C228
.text$x:0000C228
.text$x:0000C228 __unwindfunclet$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z$0 proc near
.text$x:0000C228                                         ; DATA XREF: .xdata$x:00012900o
.text$x:0000C228                 mov     ecx, [ebp-20h]
.text$x:0000C22B                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000C22B __unwindfunclet$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z$0 endp
.text$x:0000C22B
.text$x:0000C230
.text$x:0000C230 ; =============== S U B R O U T I N E =======================================
.text$x:0000C230
.text$x:0000C230
.text$x:0000C230 __unwindfunclet$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z$1 proc near
.text$x:0000C230                                         ; DATA XREF: .xdata$x:00012908o
.text$x:0000C230                 mov     ecx, [ebp-28h]
.text$x:0000C233                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000C233 __unwindfunclet$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z$1 endp
.text$x:0000C233
.text$x:0000C238
.text$x:0000C238 ; =============== S U B R O U T I N E =======================================
.text$x:0000C238
.text$x:0000C238
.text$x:0000C238 __ehhandler$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z proc near
.text$x:0000C238                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+5o
.text$x:0000C238
.text$x:0000C238 arg_4           = dword ptr  8
.text$x:0000C238
.text$x:0000C238                 mov     edx, [esp+arg_4]
.text$x:0000C23C                 lea     eax, [edx+0Ch]
.text$x:0000C23F                 mov     ecx, [edx-24h]
.text$x:0000C242                 xor     ecx, eax
.text$x:0000C244                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C249                 mov     eax, offset __ehfuncinfo$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
.text$x:0000C24E                 jmp     ___CxxFrameHandler3
.text$x:0000C24E __ehhandler$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z endp
.text$x:0000C24E
.text$x:0000C24E ; ---------------------------------------------------------------------------
.text$x:0000C253                 align 4
.text$x:0000C253 _text$x         ends
.text$x:0000C253
.text$mn:0000C254 ; ===========================================================================
.text$mn:0000C254
.text$mn:0000C254 ; Segment type: Pure code
.text$mn:0000C254 ; Segment permissions: Read/Execute
.text$mn:0000C254 _text$mn        segment para public 'CODE' use32
.text$mn:0000C254                 assume cs:_text$mn
.text$mn:0000C254                 ;org 0C254h
.text$mn:0000C254 ; COMDAT (pick any)
.text$mn:0000C254                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C254
.text$mn:0000C254 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C254
.text$mn:0000C254 ; Attributes: bp-based frame
.text$mn:0000C254
.text$mn:0000C254 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator=(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:0000C254                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
.text$mn:0000C254 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:0000C254                                         ; CODE XREF: Notepad_plus::fileSave(Buffer *)+17Ep
.text$mn:0000C254                                         ; Notepad_plus::fileSave(Buffer *)+25Dp ...
.text$mn:0000C254
.text$mn:0000C254 var_8           = dword ptr -8
.text$mn:0000C254 var_3           = byte ptr -3
.text$mn:0000C254 var_2           = byte ptr -2
.text$mn:0000C254 var_1           = byte ptr -1
.text$mn:0000C254 arg_0           = dword ptr  8
.text$mn:0000C254
.text$mn:0000C254                 push    ebp
.text$mn:0000C255                 mov     ebp, esp
.text$mn:0000C257                 sub     esp, 8
.text$mn:0000C25A                 mov     [ebp+var_8], ecx
.text$mn:0000C25D                 mov     eax, [ebp+var_8]
.text$mn:0000C260                 cmp     eax, [ebp+arg_0]
.text$mn:0000C263                 jz      short loc_C2BF
.text$mn:0000C265                 lea     ecx, [ebp+var_1]
.text$mn:0000C268                 push    ecx
.text$mn:0000C269                 mov     ecx, [ebp+arg_0]
.text$mn:0000C26C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000C271                 push    eax
.text$mn:0000C272                 lea     edx, [ebp+var_2]
.text$mn:0000C275                 push    edx
.text$mn:0000C276                 mov     ecx, [ebp+var_8]
.text$mn:0000C279                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000C27E                 push    eax
.text$mn:0000C27F                 call    ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:0000C284                 add     esp, 8
.text$mn:0000C287                 movzx   eax, al
.text$mn:0000C28A                 test    eax, eax
.text$mn:0000C28C                 jz      short loc_C2B3
.text$mn:0000C28E                 xor     ecx, ecx
.text$mn:0000C290                 jz      short loc_C2B3
.text$mn:0000C292                 push    0
.text$mn:0000C294                 push    1
.text$mn:0000C296                 mov     ecx, [ebp+var_8]
.text$mn:0000C299                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000C29E                 lea     edx, [ebp+var_3]
.text$mn:0000C2A1                 push    edx
.text$mn:0000C2A2                 mov     ecx, [ebp+arg_0]
.text$mn:0000C2A5                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000C2AA                 push    eax
.text$mn:0000C2AB                 mov     ecx, [ebp+var_8]
.text$mn:0000C2AE                 call    ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Change_alloc(std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:0000C2B3
.text$mn:0000C2B3 loc_C2B3:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+38j
.text$mn:0000C2B3                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Cj
.text$mn:0000C2B3                 mov     eax, [ebp+arg_0]
.text$mn:0000C2B6                 push    eax
.text$mn:0000C2B7                 mov     ecx, [ebp+var_8]
.text$mn:0000C2BA                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000C2BF
.text$mn:0000C2BF loc_C2BF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+Fj
.text$mn:0000C2BF                 mov     eax, [ebp+var_8]
.text$mn:0000C2C2                 mov     esp, ebp
.text$mn:0000C2C4                 pop     ebp
.text$mn:0000C2C5                 retn    4
.text$mn:0000C2C5 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:0000C2C5
.text$mn:0000C2C5 _text$mn        ends
.text$mn:0000C2C5
.text$mn:0000C2C8 ; ===========================================================================
.text$mn:0000C2C8
.text$mn:0000C2C8 ; Segment type: Pure code
.text$mn:0000C2C8 ; Segment permissions: Read/Execute
.text$mn:0000C2C8 _text$mn        segment para public 'CODE' use32
.text$mn:0000C2C8                 assume cs:_text$mn
.text$mn:0000C2C8                 ;org 0C2C8h
.text$mn:0000C2C8 ; COMDAT (pick any)
.text$mn:0000C2C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C2C8
.text$mn:0000C2C8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2C8
.text$mn:0000C2C8 ; Attributes: bp-based frame
.text$mn:0000C2C8
.text$mn:0000C2C8 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t *Str)
.text$mn:0000C2C8                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:0000C2C8 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:0000C2C8                                         ; CODE XREF: Notepad_plus::fileSave(Buffer *)+1B4p
.text$mn:0000C2C8                                         ; Notepad_plus::fileSave(Buffer *)+2C4p
.text$mn:0000C2C8
.text$mn:0000C2C8 var_4           = dword ptr -4
.text$mn:0000C2C8 Str             = dword ptr  8
.text$mn:0000C2C8
.text$mn:0000C2C8                 push    ebp
.text$mn:0000C2C9                 mov     ebp, esp
.text$mn:0000C2CB                 push    ecx
.text$mn:0000C2CC                 mov     [ebp+var_4], ecx
.text$mn:0000C2CF                 mov     eax, [ebp+Str]
.text$mn:0000C2D2                 push    eax             ; Str
.text$mn:0000C2D3                 mov     ecx, [ebp+var_4]
.text$mn:0000C2D6                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:0000C2DB                 mov     esp, ebp
.text$mn:0000C2DD                 pop     ebp
.text$mn:0000C2DE                 retn    4
.text$mn:0000C2DE ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:0000C2DE
.text$mn:0000C2DE ; ---------------------------------------------------------------------------
.text$mn:0000C2E1                 align 4
.text$mn:0000C2E1 _text$mn        ends
.text$mn:0000C2E1
.text$mn:0000C2E4 ; ===========================================================================
.text$mn:0000C2E4
.text$mn:0000C2E4 ; Segment type: Pure code
.text$mn:0000C2E4 ; Segment permissions: Read/Execute
.text$mn:0000C2E4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C2E4                 assume cs:_text$mn
.text$mn:0000C2E4                 ;org 0C2E4h
.text$mn:0000C2E4 ; COMDAT (pick any)
.text$mn:0000C2E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C2E4
.text$mn:0000C2E4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2E4
.text$mn:0000C2E4 ; Attributes: bp-based frame
.text$mn:0000C2E4
.text$mn:0000C2E4 ; public: class std::vector<unsigned int, class std::allocator<unsigned int>> & __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::operator=(class std::vector<unsigned int, class std::allocator<unsigned int>> const &)
.text$mn:0000C2E4                 public ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:0000C2E4 ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:0000C2E4                                         ; CODE XREF: sessionFileInfo::operator=(sessionFileInfo const &)+60p
.text$mn:0000C2E4                                         ; sessionFileInfo::operator=(sessionFileInfo const &)+72p
.text$mn:0000C2E4
.text$mn:0000C2E4 var_20          = dword ptr -20h
.text$mn:0000C2E4 var_1C          = dword ptr -1Ch
.text$mn:0000C2E4 var_18          = dword ptr -18h
.text$mn:0000C2E4 var_14          = byte ptr -14h
.text$mn:0000C2E4 var_13          = byte ptr -13h
.text$mn:0000C2E4 var_12          = byte ptr -12h
.text$mn:0000C2E4 var_11          = byte ptr -11h
.text$mn:0000C2E4 var_10          = dword ptr -10h
.text$mn:0000C2E4 var_C           = dword ptr -0Ch
.text$mn:0000C2E4 var_4           = dword ptr -4
.text$mn:0000C2E4 arg_0           = dword ptr  8
.text$mn:0000C2E4
.text$mn:0000C2E4 ; FUNCTION CHUNK AT .text$mn:0000C4FF SIZE 00000009 BYTES
.text$mn:0000C2E4 ; FUNCTION CHUNK AT .text$mn:0000C50F SIZE 00000017 BYTES
.text$mn:0000C2E4
.text$mn:0000C2E4                 push    ebp
.text$mn:0000C2E5                 mov     ebp, esp
.text$mn:0000C2E7                 push    0FFFFFFFFh
.text$mn:0000C2E9                 push    offset __ehhandler$??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:0000C2EE                 mov     eax, large fs:0
.text$mn:0000C2F4                 push    eax
.text$mn:0000C2F5                 push    ecx
.text$mn:0000C2F6                 sub     esp, 10h
.text$mn:0000C2F9                 push    ebx
.text$mn:0000C2FA                 push    esi
.text$mn:0000C2FB                 push    edi
.text$mn:0000C2FC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000C301                 xor     eax, ebp
.text$mn:0000C303                 push    eax
.text$mn:0000C304                 lea     eax, [ebp+var_C]
.text$mn:0000C307                 mov     large fs:0, eax
.text$mn:0000C30D                 mov     [ebp+var_10], esp
.text$mn:0000C310                 mov     [ebp+var_18], ecx
.text$mn:0000C313                 mov     eax, [ebp+var_18]
.text$mn:0000C316                 cmp     eax, [ebp+arg_0]
.text$mn:0000C319                 jz      loc_C50F
.text$mn:0000C31F                 lea     ecx, [ebp+var_11]
.text$mn:0000C322                 push    ecx
.text$mn:0000C323                 mov     ecx, [ebp+arg_0]
.text$mn:0000C326                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000C32B                 push    eax
.text$mn:0000C32C                 lea     edx, [ebp+var_12]
.text$mn:0000C32F                 push    edx
.text$mn:0000C330                 mov     ecx, [ebp+var_18]
.text$mn:0000C333                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000C338                 push    eax
.text$mn:0000C339                 call    ??$?9V?$allocator@I@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@I@std@@@0@0@Z ; std::operator!=<std::allocator<uint>,std::allocator<uint>>(std::_Wrap_alloc<std::allocator<uint>> const &,std::_Wrap_alloc<std::allocator<uint>> const &)
.text$mn:0000C33E                 add     esp, 8
.text$mn:0000C341                 movzx   eax, al
.text$mn:0000C344                 test    eax, eax
.text$mn:0000C346                 jz      short loc_C369
.text$mn:0000C348                 xor     ecx, ecx
.text$mn:0000C34A                 jz      short loc_C369
.text$mn:0000C34C                 mov     ecx, [ebp+var_18]
.text$mn:0000C34F                 call    ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<uint,std::allocator<uint>>::_Tidy(void)
.text$mn:0000C354                 lea     edx, [ebp+var_13]
.text$mn:0000C357                 push    edx
.text$mn:0000C358                 mov     ecx, [ebp+arg_0]
.text$mn:0000C35B                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000C360                 push    eax
.text$mn:0000C361                 mov     ecx, [ebp+var_18]
.text$mn:0000C364                 call    ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@I@std@@@2@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Change_alloc(std::_Wrap_alloc<std::allocator<uint>> const &)
.text$mn:0000C369
.text$mn:0000C369 loc_C369:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+62j
.text$mn:0000C369                                         ; std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+66j
.text$mn:0000C369                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000C36C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000C371                 mov     ecx, [ebp+arg_0]
.text$mn:0000C374                 call    ?empty@?$vector@IV?$allocator@I@std@@@std@@QBE_NXZ ; std::vector<uint,std::allocator<uint>>::empty(void)
.text$mn:0000C379                 movzx   eax, al
.text$mn:0000C37C                 test    eax, eax
.text$mn:0000C37E                 jz      short loc_C38D
.text$mn:0000C380                 mov     ecx, [ebp+var_18]
.text$mn:0000C383                 call    ?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ ; std::vector<uint,std::allocator<uint>>::clear(void)
.text$mn:0000C388                 jmp     loc_C50F
.text$mn:0000C38D ; ---------------------------------------------------------------------------
.text$mn:0000C38D
.text$mn:0000C38D loc_C38D:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+9Aj
.text$mn:0000C38D                 mov     ecx, [ebp+arg_0]
.text$mn:0000C390                 call    ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<uint,std::allocator<uint>>::size(void)
.text$mn:0000C395                 mov     esi, eax
.text$mn:0000C397                 mov     ecx, [ebp+var_18]
.text$mn:0000C39A                 call    ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<uint,std::allocator<uint>>::size(void)
.text$mn:0000C39F                 cmp     esi, eax
.text$mn:0000C3A1                 ja      short loc_C3F2
.text$mn:0000C3A3                 mov     ecx, [ebp+var_18]
.text$mn:0000C3A6                 mov     edx, [ecx+4]
.text$mn:0000C3A9                 push    edx             ; Dst
.text$mn:0000C3AA                 mov     eax, [ebp+arg_0]
.text$mn:0000C3AD                 mov     ecx, [eax+8]
.text$mn:0000C3B0                 push    ecx             ; int
.text$mn:0000C3B1                 mov     edx, [ebp+arg_0]
.text$mn:0000C3B4                 mov     eax, [edx+4]
.text$mn:0000C3B7                 push    eax             ; Src
.text$mn:0000C3B8                 call    ??$_Copy_impl@PAIPAI@std@@YAPAIPAI00@Z ; std::_Copy_impl<uint *,uint *>(uint *,uint *,uint *)
.text$mn:0000C3BD                 add     esp, 0Ch
.text$mn:0000C3C0                 mov     [ebp+var_20], eax
.text$mn:0000C3C3                 mov     ecx, [ebp+var_18]
.text$mn:0000C3C6                 mov     edx, [ecx+8]
.text$mn:0000C3C9                 push    edx
.text$mn:0000C3CA                 mov     eax, [ebp+var_20]
.text$mn:0000C3CD                 push    eax
.text$mn:0000C3CE                 mov     ecx, [ebp+var_18]
.text$mn:0000C3D1                 call    ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<uint,std::allocator<uint>>::_Destroy(uint *,uint *)
.text$mn:0000C3D6                 mov     ecx, [ebp+arg_0]
.text$mn:0000C3D9                 call    ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<uint,std::allocator<uint>>::size(void)
.text$mn:0000C3DE                 mov     ecx, [ebp+var_18]
.text$mn:0000C3E1                 mov     edx, [ecx+4]
.text$mn:0000C3E4                 lea     eax, [edx+eax*4]
.text$mn:0000C3E7                 mov     ecx, [ebp+var_18]
.text$mn:0000C3EA                 mov     [ecx+8], eax
.text$mn:0000C3ED                 jmp     loc_C50F
.text$mn:0000C3F2 ; ---------------------------------------------------------------------------
.text$mn:0000C3F2
.text$mn:0000C3F2 loc_C3F2:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+BDj
.text$mn:0000C3F2                 mov     ecx, [ebp+arg_0]
.text$mn:0000C3F5                 call    ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<uint,std::allocator<uint>>::size(void)
.text$mn:0000C3FA                 mov     esi, eax
.text$mn:0000C3FC                 mov     ecx, [ebp+var_18]
.text$mn:0000C3FF                 call    ?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<uint,std::allocator<uint>>::capacity(void)
.text$mn:0000C404                 cmp     esi, eax
.text$mn:0000C406                 ja      short loc_C45B
.text$mn:0000C408                 mov     ecx, [ebp+var_18]
.text$mn:0000C40B                 call    ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<uint,std::allocator<uint>>::size(void)
.text$mn:0000C410                 mov     edx, [ebp+arg_0]
.text$mn:0000C413                 mov     ecx, [edx+4]
.text$mn:0000C416                 lea     edx, [ecx+eax*4]
.text$mn:0000C419                 mov     [ebp+var_1C], edx
.text$mn:0000C41C                 mov     eax, [ebp+var_18]
.text$mn:0000C41F                 mov     ecx, [eax+4]
.text$mn:0000C422                 push    ecx             ; Dst
.text$mn:0000C423                 mov     edx, [ebp+var_1C]
.text$mn:0000C426                 push    edx             ; int
.text$mn:0000C427                 mov     eax, [ebp+arg_0]
.text$mn:0000C42A                 mov     ecx, [eax+4]
.text$mn:0000C42D                 push    ecx             ; Src
.text$mn:0000C42E                 call    ??$_Copy_impl@PAIPAI@std@@YAPAIPAI00@Z ; std::_Copy_impl<uint *,uint *>(uint *,uint *,uint *)
.text$mn:0000C433                 add     esp, 0Ch
.text$mn:0000C436                 mov     edx, [ebp+var_18]
.text$mn:0000C439                 mov     eax, [edx+8]
.text$mn:0000C43C                 push    eax
.text$mn:0000C43D                 mov     ecx, [ebp+arg_0]
.text$mn:0000C440                 mov     edx, [ecx+8]
.text$mn:0000C443                 push    edx
.text$mn:0000C444                 mov     eax, [ebp+var_1C]
.text$mn:0000C447                 push    eax
.text$mn:0000C448                 mov     ecx, [ebp+var_18]
.text$mn:0000C44B                 call    ??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<uint,std::allocator<uint>>::_Ucopy<uint *>(uint *,uint *,uint *)
.text$mn:0000C450                 mov     ecx, [ebp+var_18]
.text$mn:0000C453                 mov     [ecx+8], eax
.text$mn:0000C456                 jmp     loc_C50F
.text$mn:0000C45B ; ---------------------------------------------------------------------------
.text$mn:0000C45B
.text$mn:0000C45B loc_C45B:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+122j
.text$mn:0000C45B                 mov     edx, [ebp+var_18]
.text$mn:0000C45E                 cmp     dword ptr [edx+4], 0
.text$mn:0000C462                 jz      short loc_C4A4
.text$mn:0000C464                 mov     eax, [ebp+var_18]
.text$mn:0000C467                 mov     ecx, [eax+8]
.text$mn:0000C46A                 push    ecx
.text$mn:0000C46B                 mov     edx, [ebp+var_18]
.text$mn:0000C46E                 mov     eax, [edx+4]
.text$mn:0000C471                 push    eax
.text$mn:0000C472                 mov     ecx, [ebp+var_18]
.text$mn:0000C475                 call    ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<uint,std::allocator<uint>>::_Destroy(uint *,uint *)
.text$mn:0000C47A                 mov     ecx, [ebp+var_18]
.text$mn:0000C47D                 mov     edx, [ebp+var_18]
.text$mn:0000C480                 mov     eax, [ecx+0Ch]
.text$mn:0000C483                 sub     eax, [edx+4]
.text$mn:0000C486                 sar     eax, 2
.text$mn:0000C489                 push    eax             ; int
.text$mn:0000C48A                 mov     ecx, [ebp+var_18]
.text$mn:0000C48D                 mov     edx, [ecx+4]
.text$mn:0000C490                 push    edx             ; void *
.text$mn:0000C491                 lea     eax, [ebp+var_14]
.text$mn:0000C494                 push    eax
.text$mn:0000C495                 mov     ecx, [ebp+var_18]
.text$mn:0000C498                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000C49D                 mov     ecx, eax
.text$mn:0000C49F                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z ; std::_Wrap_alloc<std::allocator<uint>>::deallocate(uint *,uint)
.text$mn:0000C4A4
.text$mn:0000C4A4 loc_C4A4:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+17Ej
.text$mn:0000C4A4                 mov     ecx, [ebp+arg_0]
.text$mn:0000C4A7                 call    ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<uint,std::allocator<uint>>::size(void)
.text$mn:0000C4AC                 push    eax
.text$mn:0000C4AD                 mov     ecx, [ebp+var_18]
.text$mn:0000C4B0                 call    ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<uint,std::allocator<uint>>::_Buy(uint)
.text$mn:0000C4B5                 movzx   ecx, al
.text$mn:0000C4B8                 test    ecx, ecx
.text$mn:0000C4BA                 jz      short loc_C50F
.text$mn:0000C4BC                 mov     [ebp+var_4], 0
.text$mn:0000C4C3                 mov     edx, [ebp+var_18]
.text$mn:0000C4C6                 mov     eax, [edx+4]
.text$mn:0000C4C9                 push    eax
.text$mn:0000C4CA                 mov     ecx, [ebp+arg_0]
.text$mn:0000C4CD                 mov     edx, [ecx+8]
.text$mn:0000C4D0                 push    edx
.text$mn:0000C4D1                 mov     eax, [ebp+arg_0]
.text$mn:0000C4D4                 mov     ecx, [eax+4]
.text$mn:0000C4D7                 push    ecx
.text$mn:0000C4D8                 mov     ecx, [ebp+var_18]
.text$mn:0000C4DB                 call    ??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<uint,std::allocator<uint>>::_Ucopy<uint *>(uint *,uint *,uint *)
.text$mn:0000C4E0                 mov     edx, [ebp+var_18]
.text$mn:0000C4E3                 mov     [edx+8], eax
.text$mn:0000C4E6                 jmp     short loc_C4FF
.text$mn:0000C4E6 ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:0000C4E6
.text$mn:0000C4E8
.text$mn:0000C4E8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C4E8
.text$mn:0000C4E8 ; Attributes: noreturn
.text$mn:0000C4E8
.text$mn:0000C4E8 __catch$??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z$0 proc near
.text$mn:0000C4E8                                         ; DATA XREF: .xdata$x:00012EF0o
.text$mn:0000C4E8                 mov     ecx, [ebp-18h]
.text$mn:0000C4EB                 call    ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<uint,std::allocator<uint>>::_Tidy(void)
.text$mn:0000C4F0                 push    0
.text$mn:0000C4F2                 push    0
.text$mn:0000C4F4                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000C4F4 __catch$??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z$0 endp
.text$mn:0000C4F4
.text$mn:0000C4F9 ; ---------------------------------------------------------------------------
.text$mn:0000C4F9                 mov     eax, offset $LN17_1
.text$mn:0000C4FE                 retn
.text$mn:0000C4FF ; ---------------------------------------------------------------------------
.text$mn:0000C4FF ; START OF FUNCTION CHUNK FOR ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:0000C4FF
.text$mn:0000C4FF loc_C4FF:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+202j
.text$mn:0000C4FF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000C506                 jmp     short loc_C50F
.text$mn:0000C506 ; END OF FUNCTION CHUNK FOR ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:0000C508
.text$mn:0000C508 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C508
.text$mn:0000C508
.text$mn:0000C508 $LN17_1         proc near               ; DATA XREF: .text$mn:0000C4F9o
.text$mn:0000C508                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000C508 $LN17_1         endp ; sp-analysis failed
.text$mn:0000C508
.text$mn:0000C50F ; START OF FUNCTION CHUNK FOR ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:0000C50F
.text$mn:0000C50F loc_C50F:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+35j
.text$mn:0000C50F                                         ; std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+A4j ...
.text$mn:0000C50F                 mov     eax, [ebp+var_18]
.text$mn:0000C512                 mov     ecx, [ebp+var_C]
.text$mn:0000C515                 mov     large fs:0, ecx
.text$mn:0000C51C                 pop     ecx
.text$mn:0000C51D                 pop     edi
.text$mn:0000C51E                 pop     esi
.text$mn:0000C51F                 pop     ebx
.text$mn:0000C520                 mov     esp, ebp
.text$mn:0000C522                 pop     ebp
.text$mn:0000C523                 retn    4
.text$mn:0000C523 ; END OF FUNCTION CHUNK FOR ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:0000C523 ; ---------------------------------------------------------------------------
.text$mn:0000C526                 align 4
.text$mn:0000C526 _text$mn        ends
.text$mn:0000C526
.text$x:0000C528 ; ===========================================================================
.text$x:0000C528
.text$x:0000C528 ; Segment type: Pure code
.text$x:0000C528 ; Segment permissions: Read/Execute
.text$x:0000C528 _text$x         segment para public 'CODE' use32
.text$x:0000C528                 assume cs:_text$x
.text$x:0000C528                 ;org 0C528h
.text$x:0000C528 ; COMDAT (pick associative to section at C2E4)
.text$x:0000C528                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C528
.text$x:0000C528 ; =============== S U B R O U T I N E =======================================
.text$x:0000C528
.text$x:0000C528
.text$x:0000C528 __ehhandler$??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z proc near
.text$x:0000C528                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+5o
.text$x:0000C528
.text$x:0000C528 arg_4           = dword ptr  8
.text$x:0000C528
.text$x:0000C528                 mov     edx, [esp+arg_4]
.text$x:0000C52C                 lea     eax, [edx+0Ch]
.text$x:0000C52F                 mov     ecx, [edx-24h]
.text$x:0000C532                 xor     ecx, eax
.text$x:0000C534                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C539                 mov     eax, offset __ehfuncinfo$??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
.text$x:0000C53E                 jmp     ___CxxFrameHandler3
.text$x:0000C53E __ehhandler$??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z endp
.text$x:0000C53E
.text$x:0000C53E ; ---------------------------------------------------------------------------
.text$x:0000C543                 align 4
.text$x:0000C543 _text$x         ends
.text$x:0000C543
.text$mn:0000C544 ; ===========================================================================
.text$mn:0000C544
.text$mn:0000C544 ; Segment type: Pure code
.text$mn:0000C544 ; Segment permissions: Read/Execute
.text$mn:0000C544 _text$mn        segment para public 'CODE' use32
.text$mn:0000C544                 assume cs:_text$mn
.text$mn:0000C544                 ;org 0C544h
.text$mn:0000C544 ; COMDAT (pick any)
.text$mn:0000C544                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C544
.text$mn:0000C544 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C544
.text$mn:0000C544 ; Attributes: bp-based frame
.text$mn:0000C544
.text$mn:0000C544 ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:0000C544                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:0000C544 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:0000C544                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:0000C544
.text$mn:0000C544 var_14          = byte ptr -14h
.text$mn:0000C544 var_10          = dword ptr -10h
.text$mn:0000C544 var_C           = dword ptr -0Ch
.text$mn:0000C544 var_4           = dword ptr -4
.text$mn:0000C544 arg_0           = dword ptr  8
.text$mn:0000C544
.text$mn:0000C544                 push    ebp
.text$mn:0000C545                 mov     ebp, esp
.text$mn:0000C547                 push    0FFFFFFFFh
.text$mn:0000C549                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:0000C54E                 mov     eax, large fs:0
.text$mn:0000C554                 push    eax
.text$mn:0000C555                 sub     esp, 8
.text$mn:0000C558                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000C55D                 xor     eax, ebp
.text$mn:0000C55F                 push    eax
.text$mn:0000C560                 lea     eax, [ebp+var_C]
.text$mn:0000C563                 mov     large fs:0, eax
.text$mn:0000C569                 mov     [ebp+var_10], ecx
.text$mn:0000C56C                 mov     eax, [ebp+var_10]
.text$mn:0000C56F                 mov     ecx, [ebp+arg_0]
.text$mn:0000C572                 mov     edx, [eax]
.text$mn:0000C574                 cmp     edx, [ecx]
.text$mn:0000C576                 jnz     short loc_C57A
.text$mn:0000C578                 jmp     short loc_C5BC
.text$mn:0000C57A ; ---------------------------------------------------------------------------
.text$mn:0000C57A
.text$mn:0000C57A loc_C57A:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:0000C57A                 mov     eax, [ebp+arg_0]
.text$mn:0000C57D                 cmp     dword ptr [eax], 0
.text$mn:0000C580                 jz      short loc_C594
.text$mn:0000C582                 mov     ecx, [ebp+arg_0]
.text$mn:0000C585                 mov     edx, [ecx]
.text$mn:0000C587                 mov     eax, [edx]
.text$mn:0000C589                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000C58A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000C58D                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:0000C592                 jmp     short loc_C5BC
.text$mn:0000C594 ; ---------------------------------------------------------------------------
.text$mn:0000C594
.text$mn:0000C594 loc_C594:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:0000C594                 push    3               ; int
.text$mn:0000C596                 lea     ecx, [ebp+var_14] ; this
.text$mn:0000C599                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000C59E                 mov     [ebp+var_4], 0
.text$mn:0000C5A5                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000C5A8                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:0000C5AD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000C5B4                 lea     ecx, [ebp+var_14] ; this
.text$mn:0000C5B7                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000C5BC
.text$mn:0000C5BC loc_C5BC:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:0000C5BC                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:0000C5BC                 mov     eax, [ebp+var_10]
.text$mn:0000C5BF                 mov     ecx, [ebp+var_C]
.text$mn:0000C5C2                 mov     large fs:0, ecx
.text$mn:0000C5C9                 pop     ecx
.text$mn:0000C5CA                 mov     esp, ebp
.text$mn:0000C5CC                 pop     ebp
.text$mn:0000C5CD                 retn    4
.text$mn:0000C5CD ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:0000C5CD
.text$mn:0000C5CD _text$mn        ends
.text$mn:0000C5CD
.text$x:0000C5D0 ; ===========================================================================
.text$x:0000C5D0
.text$x:0000C5D0 ; Segment type: Pure code
.text$x:0000C5D0 ; Segment permissions: Read/Execute
.text$x:0000C5D0 _text$x         segment para public 'CODE' use32
.text$x:0000C5D0                 assume cs:_text$x
.text$x:0000C5D0                 ;org 0C5D0h
.text$x:0000C5D0 ; COMDAT (pick associative to section at C544)
.text$x:0000C5D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C5D0
.text$x:0000C5D0 ; =============== S U B R O U T I N E =======================================
.text$x:0000C5D0
.text$x:0000C5D0
.text$x:0000C5D0 __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:0000C5D0                                         ; DATA XREF: .xdata$x:0001239Co
.text$x:0000C5D0                 lea     ecx, [ebp-14h]  ; this
.text$x:0000C5D3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000C5D3 __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:0000C5D3
.text$x:0000C5D8
.text$x:0000C5D8 ; =============== S U B R O U T I N E =======================================
.text$x:0000C5D8
.text$x:0000C5D8
.text$x:0000C5D8 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:0000C5D8                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:0000C5D8
.text$x:0000C5D8 arg_4           = dword ptr  8
.text$x:0000C5D8
.text$x:0000C5D8                 mov     edx, [esp+arg_4]
.text$x:0000C5DC                 lea     eax, [edx+0Ch]
.text$x:0000C5DF                 mov     ecx, [edx-0Ch]
.text$x:0000C5E2                 xor     ecx, eax
.text$x:0000C5E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C5E9                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:0000C5EE                 jmp     ___CxxFrameHandler3
.text$x:0000C5EE __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:0000C5EE
.text$x:0000C5EE ; ---------------------------------------------------------------------------
.text$x:0000C5F3                 align 4
.text$x:0000C5F3 _text$x         ends
.text$x:0000C5F3
.text$mn:0000C5F4 ; ===========================================================================
.text$mn:0000C5F4
.text$mn:0000C5F4 ; Segment type: Pure code
.text$mn:0000C5F4 ; Segment permissions: Read/Execute
.text$mn:0000C5F4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C5F4                 assume cs:_text$mn
.text$mn:0000C5F4                 ;org 0C5F4h
.text$mn:0000C5F4 ; COMDAT (pick any)
.text$mn:0000C5F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C5F4
.text$mn:0000C5F4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C5F4
.text$mn:0000C5F4 ; Attributes: bp-based frame
.text$mn:0000C5F4
.text$mn:0000C5F4 ; public: struct sessionFileInfo & __thiscall sessionFileInfo::operator=(struct sessionFileInfo const &)
.text$mn:0000C5F4                 public ??4sessionFileInfo@@QAEAAU0@ABU0@@Z
.text$mn:0000C5F4 ??4sessionFileInfo@@QAEAAU0@ABU0@@Z proc near
.text$mn:0000C5F4                                         ; CODE XREF: std::_Move<sessionFileInfo *,sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *,std::_Nonscalar_ptr_iterator_tag)+34p
.text$mn:0000C5F4
.text$mn:0000C5F4 var_4           = dword ptr -4
.text$mn:0000C5F4 arg_0           = dword ptr  8
.text$mn:0000C5F4
.text$mn:0000C5F4                 push    ebp
.text$mn:0000C5F5                 mov     ebp, esp
.text$mn:0000C5F7                 push    ecx
.text$mn:0000C5F8                 mov     [ebp+var_4], ecx
.text$mn:0000C5FB                 mov     eax, [ebp+arg_0]
.text$mn:0000C5FE                 mov     ecx, [ebp+var_4]
.text$mn:0000C601                 mov     edx, [eax]
.text$mn:0000C603                 mov     [ecx], edx
.text$mn:0000C605                 mov     edx, [eax+4]
.text$mn:0000C608                 mov     [ecx+4], edx
.text$mn:0000C60B                 mov     edx, [eax+8]
.text$mn:0000C60E                 mov     [ecx+8], edx
.text$mn:0000C611                 mov     edx, [eax+0Ch]
.text$mn:0000C614                 mov     [ecx+0Ch], edx
.text$mn:0000C617                 mov     edx, [eax+10h]
.text$mn:0000C61A                 mov     [ecx+10h], edx
.text$mn:0000C61D                 mov     eax, [eax+14h]
.text$mn:0000C620                 mov     [ecx+14h], eax
.text$mn:0000C623                 mov     ecx, [ebp+arg_0]
.text$mn:0000C626                 add     ecx, 18h
.text$mn:0000C629                 push    ecx
.text$mn:0000C62A                 mov     ecx, [ebp+var_4]
.text$mn:0000C62D                 add     ecx, 18h
.text$mn:0000C630                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000C635                 mov     edx, [ebp+arg_0]
.text$mn:0000C638                 add     edx, 34h ; '4'
.text$mn:0000C63B                 push    edx
.text$mn:0000C63C                 mov     ecx, [ebp+var_4]
.text$mn:0000C63F                 add     ecx, 34h ; '4'
.text$mn:0000C642                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000C647                 mov     eax, [ebp+arg_0]
.text$mn:0000C64A                 add     eax, 50h ; 'P'
.text$mn:0000C64D                 push    eax
.text$mn:0000C64E                 mov     ecx, [ebp+var_4]
.text$mn:0000C651                 add     ecx, 50h ; 'P'
.text$mn:0000C654                 call    ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)
.text$mn:0000C659                 mov     ecx, [ebp+arg_0]
.text$mn:0000C65C                 add     ecx, 60h ; '`'
.text$mn:0000C65F                 push    ecx
.text$mn:0000C660                 mov     ecx, [ebp+var_4]
.text$mn:0000C663                 add     ecx, 60h ; '`'
.text$mn:0000C666                 call    ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)
.text$mn:0000C66B                 mov     edx, [ebp+var_4]
.text$mn:0000C66E                 mov     eax, [ebp+arg_0]
.text$mn:0000C671                 mov     ecx, [eax+70h]
.text$mn:0000C674                 mov     [edx+70h], ecx
.text$mn:0000C677                 mov     edx, [ebp+arg_0]
.text$mn:0000C67A                 add     edx, 74h ; 't'
.text$mn:0000C67D                 push    edx
.text$mn:0000C67E                 mov     ecx, [ebp+var_4]
.text$mn:0000C681                 add     ecx, 74h ; 't'
.text$mn:0000C684                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000C689                 mov     eax, [ebp+var_4]
.text$mn:0000C68C                 mov     ecx, [ebp+arg_0]
.text$mn:0000C68F                 mov     edx, [ecx+90h]
.text$mn:0000C695                 mov     [eax+90h], edx
.text$mn:0000C69B                 mov     ecx, [ecx+94h]
.text$mn:0000C6A1                 mov     [eax+94h], ecx
.text$mn:0000C6A7                 mov     eax, [ebp+var_4]
.text$mn:0000C6AA                 mov     esp, ebp
.text$mn:0000C6AC                 pop     ebp
.text$mn:0000C6AD                 retn    4
.text$mn:0000C6AD ??4sessionFileInfo@@QAEAAU0@ABU0@@Z endp
.text$mn:0000C6AD
.text$mn:0000C6AD _text$mn        ends
.text$mn:0000C6AD
.text$mn:0000C6B0 ; ===========================================================================
.text$mn:0000C6B0
.text$mn:0000C6B0 ; Segment type: Pure code
.text$mn:0000C6B0 ; Segment permissions: Read/Execute
.text$mn:0000C6B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000C6B0                 assume cs:_text$mn
.text$mn:0000C6B0                 ;org 0C6B0h
.text$mn:0000C6B0 ; COMDAT (pick any)
.text$mn:0000C6B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C6B0
.text$mn:0000C6B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C6B0
.text$mn:0000C6B0 ; Attributes: bp-based frame
.text$mn:0000C6B0
.text$mn:0000C6B0 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_Iterator_base12 *)
.text$mn:0000C6B0                 public ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:0000C6B0 ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:0000C6B0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+39p
.text$mn:0000C6B0
.text$mn:0000C6B0 var_8           = dword ptr -8
.text$mn:0000C6B0 var_4           = dword ptr -4
.text$mn:0000C6B0 arg_0           = dword ptr  8
.text$mn:0000C6B0
.text$mn:0000C6B0                 push    ebp
.text$mn:0000C6B1                 mov     ebp, esp
.text$mn:0000C6B3                 sub     esp, 8
.text$mn:0000C6B6                 mov     [ebp+var_4], ecx
.text$mn:0000C6B9                 mov     eax, [ebp+arg_0]
.text$mn:0000C6BC                 push    eax             ; std::_Iterator_base12 *
.text$mn:0000C6BD                 mov     ecx, [ebp+var_4]
.text$mn:0000C6C0                 call    ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000C6C5                 mov     ecx, [ebp+var_4]
.text$mn:0000C6C8                 mov     edx, [ebp+arg_0]
.text$mn:0000C6CB                 mov     eax, [ecx+8]
.text$mn:0000C6CE                 cmp     eax, [edx+8]
.text$mn:0000C6D1                 jnz     short loc_C6DC
.text$mn:0000C6D3                 mov     [ebp+var_8], 1
.text$mn:0000C6DA                 jmp     short loc_C6E3
.text$mn:0000C6DC ; ---------------------------------------------------------------------------
.text$mn:0000C6DC
.text$mn:0000C6DC loc_C6DC:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+21j
.text$mn:0000C6DC                 mov     [ebp+var_8], 0
.text$mn:0000C6E3
.text$mn:0000C6E3 loc_C6E3:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+2Aj
.text$mn:0000C6E3                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000C6E6                 mov     esp, ebp
.text$mn:0000C6E8                 pop     ebp
.text$mn:0000C6E9                 retn    4
.text$mn:0000C6E9 ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:0000C6E9
.text$mn:0000C6E9 _text$mn        ends
.text$mn:0000C6E9
.text$mn:0000C6EC ; ===========================================================================
.text$mn:0000C6EC
.text$mn:0000C6EC ; Segment type: Pure code
.text$mn:0000C6EC ; Segment permissions: Read/Execute
.text$mn:0000C6EC _text$mn        segment para public 'CODE' use32
.text$mn:0000C6EC                 assume cs:_text$mn
.text$mn:0000C6EC                 ;org 0C6ECh
.text$mn:0000C6EC ; COMDAT (pick any)
.text$mn:0000C6EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C6EC
.text$mn:0000C6EC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C6EC
.text$mn:0000C6EC ; Attributes: bp-based frame
.text$mn:0000C6EC
.text$mn:0000C6EC ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator==(std::_Iterator_base12 *)
.text$mn:0000C6EC                 public ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:0000C6EC ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:0000C6EC                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+10p
.text$mn:0000C6EC
.text$mn:0000C6EC var_8           = dword ptr -8
.text$mn:0000C6EC var_4           = dword ptr -4
.text$mn:0000C6EC arg_0           = dword ptr  8
.text$mn:0000C6EC
.text$mn:0000C6EC                 push    ebp
.text$mn:0000C6ED                 mov     ebp, esp
.text$mn:0000C6EF                 sub     esp, 8
.text$mn:0000C6F2                 mov     [ebp+var_4], ecx
.text$mn:0000C6F5                 mov     eax, [ebp+arg_0]
.text$mn:0000C6F8                 push    eax             ; std::_Iterator_base12 *
.text$mn:0000C6F9                 mov     ecx, [ebp+var_4]
.text$mn:0000C6FC                 call    ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:0000C701                 mov     ecx, [ebp+var_4]
.text$mn:0000C704                 mov     edx, [ebp+arg_0]
.text$mn:0000C707                 mov     eax, [ecx+8]
.text$mn:0000C70A                 cmp     eax, [edx+8]
.text$mn:0000C70D                 jnz     short loc_C718
.text$mn:0000C70F                 mov     [ebp+var_8], 1
.text$mn:0000C716                 jmp     short loc_C71F
.text$mn:0000C718 ; ---------------------------------------------------------------------------
.text$mn:0000C718
.text$mn:0000C718 loc_C718:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+21j
.text$mn:0000C718                 mov     [ebp+var_8], 0
.text$mn:0000C71F
.text$mn:0000C71F loc_C71F:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+2Aj
.text$mn:0000C71F                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000C722                 mov     esp, ebp
.text$mn:0000C724                 pop     ebp
.text$mn:0000C725                 retn    4
.text$mn:0000C725 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:0000C725
.text$mn:0000C725 _text$mn        ends
.text$mn:0000C725
.text$mn:0000C728 ; ===========================================================================
.text$mn:0000C728
.text$mn:0000C728 ; Segment type: Pure code
.text$mn:0000C728 ; Segment permissions: Read/Execute
.text$mn:0000C728 _text$mn        segment para public 'CODE' use32
.text$mn:0000C728                 assume cs:_text$mn
.text$mn:0000C728                 ;org 0C728h
.text$mn:0000C728 ; COMDAT (pick any)
.text$mn:0000C728                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C728
.text$mn:0000C728 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C728
.text$mn:0000C728 ; Attributes: bp-based frame
.text$mn:0000C728
.text$mn:0000C728 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:0000C728                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:0000C728 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:0000C728                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:0000C728                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:0000C728
.text$mn:0000C728 var_8           = dword ptr -8
.text$mn:0000C728 var_4           = dword ptr -4
.text$mn:0000C728 arg_0           = dword ptr  8
.text$mn:0000C728
.text$mn:0000C728                 push    ebp
.text$mn:0000C729                 mov     ebp, esp
.text$mn:0000C72B                 sub     esp, 8
.text$mn:0000C72E                 mov     [ebp+var_8], ecx
.text$mn:0000C731                 mov     eax, [ebp+var_8]
.text$mn:0000C734                 cmp     eax, [ebp+arg_0]
.text$mn:0000C737                 jnz     short loc_C742
.text$mn:0000C739                 mov     [ebp+var_4], 1
.text$mn:0000C740                 jmp     short loc_C749
.text$mn:0000C742 ; ---------------------------------------------------------------------------
.text$mn:0000C742
.text$mn:0000C742 loc_C742:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:0000C742                 mov     [ebp+var_4], 0
.text$mn:0000C749
.text$mn:0000C749 loc_C749:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:0000C749                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000C74C                 mov     esp, ebp
.text$mn:0000C74E                 pop     ebp
.text$mn:0000C74F                 retn    4
.text$mn:0000C74F ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:0000C74F
.text$mn:0000C74F ; ---------------------------------------------------------------------------
.text$mn:0000C752                 align 4
.text$mn:0000C752 _text$mn        ends
.text$mn:0000C752
.text$mn:0000C754 ; ===========================================================================
.text$mn:0000C754
.text$mn:0000C754 ; Segment type: Pure code
.text$mn:0000C754 ; Segment permissions: Read/Execute
.text$mn:0000C754 _text$mn        segment para public 'CODE' use32
.text$mn:0000C754                 assume cs:_text$mn
.text$mn:0000C754                 ;org 0C754h
.text$mn:0000C754 ; COMDAT (pick any)
.text$mn:0000C754                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C754
.text$mn:0000C754 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C754
.text$mn:0000C754 ; Attributes: bp-based frame
.text$mn:0000C754
.text$mn:0000C754 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:0000C754                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:0000C754 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:0000C754                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:0000C754
.text$mn:0000C754 var_8           = dword ptr -8
.text$mn:0000C754 var_4           = dword ptr -4
.text$mn:0000C754 arg_0           = dword ptr  8
.text$mn:0000C754
.text$mn:0000C754                 push    ebp
.text$mn:0000C755                 mov     ebp, esp
.text$mn:0000C757                 sub     esp, 8
.text$mn:0000C75A                 push    esi
.text$mn:0000C75B                 mov     [ebp+var_4], ecx
.text$mn:0000C75E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000C761                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000C766                 push    eax
.text$mn:0000C767                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000C76A                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000C76F                 mov     ecx, eax
.text$mn:0000C771                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000C776                 movzx   eax, al
.text$mn:0000C779                 test    eax, eax
.text$mn:0000C77B                 jz      short loc_C79C
.text$mn:0000C77D                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000C780                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:0000C785                 mov     esi, eax
.text$mn:0000C787                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000C78A                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:0000C78F                 cmp     esi, eax
.text$mn:0000C791                 jnz     short loc_C79C
.text$mn:0000C793                 mov     [ebp+var_8], 1
.text$mn:0000C79A                 jmp     short loc_C7A3
.text$mn:0000C79C ; ---------------------------------------------------------------------------
.text$mn:0000C79C
.text$mn:0000C79C loc_C79C:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:0000C79C                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:0000C79C                 mov     [ebp+var_8], 0
.text$mn:0000C7A3
.text$mn:0000C7A3 loc_C7A3:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:0000C7A3                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000C7A6                 pop     esi
.text$mn:0000C7A7                 mov     esp, ebp
.text$mn:0000C7A9                 pop     ebp
.text$mn:0000C7AA                 retn    4
.text$mn:0000C7AA ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:0000C7AA
.text$mn:0000C7AA ; ---------------------------------------------------------------------------
.text$mn:0000C7AD                 align 10h
.text$mn:0000C7AD _text$mn        ends
.text$mn:0000C7AD
.text$mn:0000C7B0 ; ===========================================================================
.text$mn:0000C7B0
.text$mn:0000C7B0 ; Segment type: Pure code
.text$mn:0000C7B0 ; Segment permissions: Read/Execute
.text$mn:0000C7B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000C7B0                 assume cs:_text$mn
.text$mn:0000C7B0                 ;org 0C7B0h
.text$mn:0000C7B0 ; COMDAT (pick any)
.text$mn:0000C7B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C7B0
.text$mn:0000C7B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C7B0
.text$mn:0000C7B0 ; Attributes: bp-based frame
.text$mn:0000C7B0
.text$mn:0000C7B0 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Iterator_base12 *)
.text$mn:0000C7B0                 public ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:0000C7B0 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:0000C7B0                                         ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+5Cp
.text$mn:0000C7B0                                         ; Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+1ECp
.text$mn:0000C7B0
.text$mn:0000C7B0 var_8           = dword ptr -8
.text$mn:0000C7B0 var_4           = dword ptr -4
.text$mn:0000C7B0 arg_0           = dword ptr  8
.text$mn:0000C7B0
.text$mn:0000C7B0                 push    ebp
.text$mn:0000C7B1                 mov     ebp, esp
.text$mn:0000C7B3                 sub     esp, 8
.text$mn:0000C7B6                 mov     [ebp+var_8], ecx
.text$mn:0000C7B9                 mov     eax, [ebp+arg_0]
.text$mn:0000C7BC                 push    eax             ; std::_Iterator_base12 *
.text$mn:0000C7BD                 mov     ecx, [ebp+var_8]
.text$mn:0000C7C0                 call    ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:0000C7C5                 movzx   ecx, al
.text$mn:0000C7C8                 test    ecx, ecx
.text$mn:0000C7CA                 jnz     short loc_C7D5
.text$mn:0000C7CC                 mov     [ebp+var_4], 1
.text$mn:0000C7D3                 jmp     short loc_C7DC
.text$mn:0000C7D5 ; ---------------------------------------------------------------------------
.text$mn:0000C7D5
.text$mn:0000C7D5 loc_C7D5:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+1Aj
.text$mn:0000C7D5                 mov     [ebp+var_4], 0
.text$mn:0000C7DC
.text$mn:0000C7DC loc_C7DC:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+23j
.text$mn:0000C7DC                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000C7DF                 mov     esp, ebp
.text$mn:0000C7E1                 pop     ebp
.text$mn:0000C7E2                 retn    4
.text$mn:0000C7E2 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:0000C7E2
.text$mn:0000C7E2 ; ---------------------------------------------------------------------------
.text$mn:0000C7E5                 align 4
.text$mn:0000C7E5 _text$mn        ends
.text$mn:0000C7E5
.text$mn:0000C7E8 ; ===========================================================================
.text$mn:0000C7E8
.text$mn:0000C7E8 ; Segment type: Pure code
.text$mn:0000C7E8 ; Segment permissions: Read/Execute
.text$mn:0000C7E8 _text$mn        segment para public 'CODE' use32
.text$mn:0000C7E8                 assume cs:_text$mn
.text$mn:0000C7E8                 ;org 0C7E8h
.text$mn:0000C7E8 ; COMDAT (pick any)
.text$mn:0000C7E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C7E8
.text$mn:0000C7E8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C7E8
.text$mn:0000C7E8 ; Attributes: bp-based frame
.text$mn:0000C7E8
.text$mn:0000C7E8 ; public: unsigned int & __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::operator[](unsigned int)
.text$mn:0000C7E8                 public ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z
.text$mn:0000C7E8 ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z proc near
.text$mn:0000C7E8                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+522p
.text$mn:0000C7E8                                         ; Notepad_plus::loadSession(Session &,bool)+B65p
.text$mn:0000C7E8
.text$mn:0000C7E8 var_4           = dword ptr -4
.text$mn:0000C7E8 arg_0           = dword ptr  8
.text$mn:0000C7E8
.text$mn:0000C7E8                 push    ebp
.text$mn:0000C7E9                 mov     ebp, esp
.text$mn:0000C7EB                 push    ecx
.text$mn:0000C7EC                 mov     [ebp+var_4], ecx
.text$mn:0000C7EF                 mov     ecx, [ebp+var_4]
.text$mn:0000C7F2                 call    ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<uint,std::allocator<uint>>::size(void)
.text$mn:0000C7F7                 cmp     eax, [ebp+arg_0]
.text$mn:0000C7FA                 ja      short loc_C864
.text$mn:0000C7FC                 push    4B1h            ; unsigned int
.text$mn:0000C801                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000C806                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:0000C80B                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000C810                 add     esp, 0Ch
.text$mn:0000C813                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000C818                 test    eax, eax
.text$mn:0000C81A                 jz      short loc_C820
.text$mn:0000C81C                 xor     ecx, ecx
.text$mn:0000C81E                 jnz     short loc_C846
.text$mn:0000C820
.text$mn:0000C820 loc_C820:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator[](uint)+32j
.text$mn:0000C820                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:0000C825                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000C82A                 push    0
.text$mn:0000C82C                 push    4B2h
.text$mn:0000C831                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000C836                 push    2
.text$mn:0000C838                 call    __CrtDbgReportW
.text$mn:0000C83D                 add     esp, 18h
.text$mn:0000C840                 cmp     eax, 1
.text$mn:0000C843                 jnz     short loc_C846
.text$mn:0000C845                 int     3               ; Trap to Debugger
.text$mn:0000C846
.text$mn:0000C846 loc_C846:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator[](uint)+36j
.text$mn:0000C846                                         ; std::vector<uint,std::allocator<uint>>::operator[](uint)+5Bj
.text$mn:0000C846                 push    0
.text$mn:0000C848                 push    4B2h
.text$mn:0000C84D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000C852                 push    offset ??_C@_1JG@ILDNFCDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAi?$AAn?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs@ ; "std::vector<unsigned int,class std::all"...
.text$mn:0000C857                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000C85C                 call    __invalid_parameter
.text$mn:0000C861                 add     esp, 14h
.text$mn:0000C864
.text$mn:0000C864 loc_C864:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator[](uint)+12j
.text$mn:0000C864                 mov     eax, [ebp+var_4]
.text$mn:0000C867                 mov     ecx, [eax+4]
.text$mn:0000C86A                 mov     edx, [ebp+arg_0]
.text$mn:0000C86D                 lea     eax, [ecx+edx*4]
.text$mn:0000C870                 mov     esp, ebp
.text$mn:0000C872                 pop     ebp
.text$mn:0000C873                 retn    4
.text$mn:0000C873 ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z endp
.text$mn:0000C873
.text$mn:0000C873 ; ---------------------------------------------------------------------------
.text$mn:0000C876                 align 4
.text$mn:0000C876 _text$mn        ends
.text$mn:0000C876
.text$mn:0000C878 ; ===========================================================================
.text$mn:0000C878
.text$mn:0000C878 ; Segment type: Pure code
.text$mn:0000C878 ; Segment permissions: Read/Execute
.text$mn:0000C878 _text$mn        segment para public 'CODE' use32
.text$mn:0000C878                 assume cs:_text$mn
.text$mn:0000C878                 ;org 0C878h
.text$mn:0000C878 ; COMDAT (pick any)
.text$mn:0000C878                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C878
.text$mn:0000C878 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C878
.text$mn:0000C878 ; Attributes: bp-based frame
.text$mn:0000C878
.text$mn:0000C878 ; public: struct LangMenuItem & __thiscall std::vector<struct LangMenuItem, class std::allocator<struct LangMenuItem>>::operator[](unsigned int)
.text$mn:0000C878                 public ??A?$vector@ULangMenuItem@@V?$allocator@ULangMenuItem@@@std@@@std@@QAEAAULangMenuItem@@I@Z
.text$mn:0000C878 ??A?$vector@ULangMenuItem@@V?$allocator@ULangMenuItem@@@std@@@std@@QAEAAULangMenuItem@@I@Z proc near
.text$mn:0000C878                                         ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+DEp
.text$mn:0000C878
.text$mn:0000C878 var_4           = dword ptr -4
.text$mn:0000C878 arg_0           = dword ptr  8
.text$mn:0000C878
.text$mn:0000C878                 push    ebp
.text$mn:0000C879                 mov     ebp, esp
.text$mn:0000C87B                 push    ecx
.text$mn:0000C87C                 mov     [ebp+var_4], ecx
.text$mn:0000C87F                 mov     ecx, [ebp+var_4]
.text$mn:0000C882                 call    ?size@?$vector@ULangMenuItem@@V?$allocator@ULangMenuItem@@@std@@@std@@QBEIXZ ; std::vector<LangMenuItem,std::allocator<LangMenuItem>>::size(void)
.text$mn:0000C887                 cmp     eax, [ebp+arg_0]
.text$mn:0000C88A                 ja      short loc_C8F4
.text$mn:0000C88C                 push    4B1h            ; unsigned int
.text$mn:0000C891                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000C896                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:0000C89B                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000C8A0                 add     esp, 0Ch
.text$mn:0000C8A3                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000C8A8                 test    eax, eax
.text$mn:0000C8AA                 jz      short loc_C8B0
.text$mn:0000C8AC                 xor     ecx, ecx
.text$mn:0000C8AE                 jnz     short loc_C8D6
.text$mn:0000C8B0
.text$mn:0000C8B0 loc_C8B0:                               ; CODE XREF: std::vector<LangMenuItem,std::allocator<LangMenuItem>>::operator[](uint)+32j
.text$mn:0000C8B0                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:0000C8B5                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000C8BA                 push    0
.text$mn:0000C8BC                 push    4B2h
.text$mn:0000C8C1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000C8C6                 push    2
.text$mn:0000C8C8                 call    __CrtDbgReportW
.text$mn:0000C8CD                 add     esp, 18h
.text$mn:0000C8D0                 cmp     eax, 1
.text$mn:0000C8D3                 jnz     short loc_C8D6
.text$mn:0000C8D5                 int     3               ; Trap to Debugger
.text$mn:0000C8D6
.text$mn:0000C8D6 loc_C8D6:                               ; CODE XREF: std::vector<LangMenuItem,std::allocator<LangMenuItem>>::operator[](uint)+36j
.text$mn:0000C8D6                                         ; std::vector<LangMenuItem,std::allocator<LangMenuItem>>::operator[](uint)+5Bj
.text$mn:0000C8D6                 push    0
.text$mn:0000C8D8                 push    4B2h
.text$mn:0000C8DD                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000C8E2                 push    offset ??_C@_1LC@JLHHOOPB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAL?$AAa?$AAn?$AAg?$AAM?$AAe?$AAn?$AAu?$AAI?$AAt?$AAe?$AAm?$AA?0@ ; "std::vector<struct LangMenuItem,class s"...
.text$mn:0000C8E7                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000C8EC                 call    __invalid_parameter
.text$mn:0000C8F1                 add     esp, 14h
.text$mn:0000C8F4
.text$mn:0000C8F4 loc_C8F4:                               ; CODE XREF: std::vector<LangMenuItem,std::allocator<LangMenuItem>>::operator[](uint)+12j
.text$mn:0000C8F4                 imul    eax, [ebp+arg_0], 24h
.text$mn:0000C8F8                 mov     ecx, [ebp+var_4]
.text$mn:0000C8FB                 add     eax, [ecx+4]
.text$mn:0000C8FE                 mov     esp, ebp
.text$mn:0000C900                 pop     ebp
.text$mn:0000C901                 retn    4
.text$mn:0000C901 ??A?$vector@ULangMenuItem@@V?$allocator@ULangMenuItem@@@std@@@std@@QAEAAULangMenuItem@@I@Z endp
.text$mn:0000C901
.text$mn:0000C901 _text$mn        ends
.text$mn:0000C901
.text$mn:0000C904 ; ===========================================================================
.text$mn:0000C904
.text$mn:0000C904 ; Segment type: Pure code
.text$mn:0000C904 ; Segment permissions: Read/Execute
.text$mn:0000C904 _text$mn        segment para public 'CODE' use32
.text$mn:0000C904                 assume cs:_text$mn
.text$mn:0000C904                 ;org 0C904h
.text$mn:0000C904 ; COMDAT (pick any)
.text$mn:0000C904                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C904
.text$mn:0000C904 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C904
.text$mn:0000C904 ; Attributes: bp-based frame
.text$mn:0000C904
.text$mn:0000C904 ; public: struct sessionFileInfo & __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::operator[](unsigned int)
.text$mn:0000C904                 public ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z
.text$mn:0000C904 ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z proc near
.text$mn:0000C904                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+7Bp
.text$mn:0000C904                                         ; Notepad_plus::loadSession(Session &,bool)+1A0p ...
.text$mn:0000C904
.text$mn:0000C904 var_4           = dword ptr -4
.text$mn:0000C904 arg_0           = dword ptr  8
.text$mn:0000C904
.text$mn:0000C904                 push    ebp
.text$mn:0000C905                 mov     ebp, esp
.text$mn:0000C907                 push    ecx
.text$mn:0000C908                 mov     [ebp+var_4], ecx
.text$mn:0000C90B                 mov     ecx, [ebp+var_4]
.text$mn:0000C90E                 call    ?size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::size(void)
.text$mn:0000C913                 cmp     eax, [ebp+arg_0]
.text$mn:0000C916                 ja      short loc_C980
.text$mn:0000C918                 push    4B1h            ; unsigned int
.text$mn:0000C91D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000C922                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:0000C927                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000C92C                 add     esp, 0Ch
.text$mn:0000C92F                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000C934                 test    eax, eax
.text$mn:0000C936                 jz      short loc_C93C
.text$mn:0000C938                 xor     ecx, ecx
.text$mn:0000C93A                 jnz     short loc_C962
.text$mn:0000C93C
.text$mn:0000C93C loc_C93C:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)+32j
.text$mn:0000C93C                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:0000C941                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000C946                 push    0
.text$mn:0000C948                 push    4B2h
.text$mn:0000C94D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000C952                 push    2
.text$mn:0000C954                 call    __CrtDbgReportW
.text$mn:0000C959                 add     esp, 18h
.text$mn:0000C95C                 cmp     eax, 1
.text$mn:0000C95F                 jnz     short loc_C962
.text$mn:0000C961                 int     3               ; Trap to Debugger
.text$mn:0000C962
.text$mn:0000C962 loc_C962:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)+36j
.text$mn:0000C962                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)+5Bj
.text$mn:0000C962                 push    0
.text$mn:0000C964                 push    4B2h
.text$mn:0000C969                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000C96E                 push    offset ??_C@_1LO@OOOAEPIG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAs?$AAe?$AAs?$AAs?$AAi?$AAo?$AAn?$AAF?$AAi?$AAl?$AAe?$AAI?$AAn@ ; "std::vector<struct sessionFileInfo,clas"...
.text$mn:0000C973                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000C978                 call    __invalid_parameter
.text$mn:0000C97D                 add     esp, 14h
.text$mn:0000C980
.text$mn:0000C980 loc_C980:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)+12j
.text$mn:0000C980                 imul    eax, [ebp+arg_0], 98h
.text$mn:0000C987                 mov     ecx, [ebp+var_4]
.text$mn:0000C98A                 add     eax, [ecx+4]
.text$mn:0000C98D                 mov     esp, ebp
.text$mn:0000C98F                 pop     ebp
.text$mn:0000C990                 retn    4
.text$mn:0000C990 ??A?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEAAUsessionFileInfo@@I@Z endp
.text$mn:0000C990
.text$mn:0000C990 ; ---------------------------------------------------------------------------
.text$mn:0000C993                 align 4
.text$mn:0000C993 _text$mn        ends
.text$mn:0000C993
.text$mn:0000C994 ; ===========================================================================
.text$mn:0000C994
.text$mn:0000C994 ; Segment type: Pure code
.text$mn:0000C994 ; Segment permissions: Read/Execute
.text$mn:0000C994 _text$mn        segment para public 'CODE' use32
.text$mn:0000C994                 assume cs:_text$mn
.text$mn:0000C994                 ;org 0C994h
.text$mn:0000C994 ; COMDAT (pick any)
.text$mn:0000C994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C994
.text$mn:0000C994 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C994
.text$mn:0000C994 ; Attributes: bp-based frame
.text$mn:0000C994
.text$mn:0000C994 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::operator[](unsigned int)
.text$mn:0000C994                 public ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@I@Z
.text$mn:0000C994 ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@I@Z proc near
.text$mn:0000C994                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+AF6p
.text$mn:0000C994
.text$mn:0000C994 var_4           = dword ptr -4
.text$mn:0000C994 arg_0           = dword ptr  8
.text$mn:0000C994
.text$mn:0000C994                 push    ebp
.text$mn:0000C995                 mov     ebp, esp
.text$mn:0000C997                 push    ecx
.text$mn:0000C998                 mov     [ebp+var_4], ecx
.text$mn:0000C99B                 mov     ecx, [ebp+var_4]
.text$mn:0000C99E                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:0000C9A3                 cmp     eax, [ebp+arg_0]
.text$mn:0000C9A6                 ja      short loc_CA10
.text$mn:0000C9A8                 push    4B1h            ; unsigned int
.text$mn:0000C9AD                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000C9B2                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:0000C9B7                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000C9BC                 add     esp, 0Ch
.text$mn:0000C9BF                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000C9C4                 test    eax, eax
.text$mn:0000C9C6                 jz      short loc_C9CC
.text$mn:0000C9C8                 xor     ecx, ecx
.text$mn:0000C9CA                 jnz     short loc_C9F2
.text$mn:0000C9CC
.text$mn:0000C9CC loc_C9CC:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)+32j
.text$mn:0000C9CC                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:0000C9D1                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000C9D6                 push    0
.text$mn:0000C9D8                 push    4B2h
.text$mn:0000C9DD                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000C9E2                 push    2
.text$mn:0000C9E4                 call    __CrtDbgReportW
.text$mn:0000C9E9                 add     esp, 18h
.text$mn:0000C9EC                 cmp     eax, 1
.text$mn:0000C9EF                 jnz     short loc_C9F2
.text$mn:0000C9F1                 int     3               ; Trap to Debugger
.text$mn:0000C9F2
.text$mn:0000C9F2 loc_C9F2:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)+36j
.text$mn:0000C9F2                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)+5Bj
.text$mn:0000C9F2                 push    0
.text$mn:0000C9F4                 push    4B2h
.text$mn:0000C9F9                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000C9FE                 push    offset ??_C@_1BOI@OCMBMPPD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr@ ; "std::vector<class std::basic_string<wch"...
.text$mn:0000CA03                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000CA08                 call    __invalid_parameter
.text$mn:0000CA0D                 add     esp, 14h
.text$mn:0000CA10
.text$mn:0000CA10 loc_CA10:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)+12j
.text$mn:0000CA10                 imul    eax, [ebp+arg_0], 1Ch
.text$mn:0000CA14                 mov     ecx, [ebp+var_4]
.text$mn:0000CA17                 add     eax, [ecx+4]
.text$mn:0000CA1A                 mov     esp, ebp
.text$mn:0000CA1C                 pop     ebp
.text$mn:0000CA1D                 retn    4
.text$mn:0000CA1D ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@I@Z endp
.text$mn:0000CA1D
.text$mn:0000CA1D _text$mn        ends
.text$mn:0000CA1D
.text$mn:0000CA20 ; ===========================================================================
.text$mn:0000CA20
.text$mn:0000CA20 ; Segment type: Pure code
.text$mn:0000CA20 ; Segment permissions: Read/Execute
.text$mn:0000CA20 _text$mn        segment para public 'CODE' use32
.text$mn:0000CA20                 assume cs:_text$mn
.text$mn:0000CA20                 ;org 0CA20h
.text$mn:0000CA20 ; COMDAT (pick any)
.text$mn:0000CA20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CA20
.text$mn:0000CA20 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CA20
.text$mn:0000CA20 ; Attributes: bp-based frame
.text$mn:0000CA20
.text$mn:0000CA20 ; public: wchar_t const & __thiscall std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::operator*(void)const
.text$mn:0000CA20                 public ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ
.text$mn:0000CA20 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ proc near
.text$mn:0000CA20                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+Ap
.text$mn:0000CA20
.text$mn:0000CA20 var_4           = dword ptr -4
.text$mn:0000CA20
.text$mn:0000CA20                 push    ebp
.text$mn:0000CA21                 mov     ebp, esp
.text$mn:0000CA23                 push    ecx
.text$mn:0000CA24                 push    esi
.text$mn:0000CA25                 mov     [ebp+var_4], ecx
.text$mn:0000CA28                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CA2B                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000CA30                 test    eax, eax
.text$mn:0000CA32                 jz      short loc_CA7B
.text$mn:0000CA34                 mov     eax, [ebp+var_4]
.text$mn:0000CA37                 cmp     dword ptr [eax+8], 0
.text$mn:0000CA3B                 jz      short loc_CA7B
.text$mn:0000CA3D                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CA40                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000CA45                 mov     ecx, eax
.text$mn:0000CA47                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CA4C                 mov     ecx, [ebp+var_4]
.text$mn:0000CA4F                 cmp     [ecx+8], eax
.text$mn:0000CA52                 jb      short loc_CA7B
.text$mn:0000CA54                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CA57                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000CA5C                 mov     ecx, eax
.text$mn:0000CA5E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CA63                 mov     esi, eax
.text$mn:0000CA65                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CA68                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000CA6D                 mov     edx, [eax+14h]
.text$mn:0000CA70                 lea     eax, [esi+edx*2]
.text$mn:0000CA73                 mov     ecx, [ebp+var_4]
.text$mn:0000CA76                 cmp     eax, [ecx+8]
.text$mn:0000CA79                 ja      short loc_CADA
.text$mn:0000CA7B
.text$mn:0000CA7B loc_CA7B:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+12j
.text$mn:0000CA7B                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+1Bj ...
.text$mn:0000CA7B                 push    4Fh ; 'O'       ; unsigned int
.text$mn:0000CA7D                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000CA82                 push    offset ??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; "string iterator not dereferencable"
.text$mn:0000CA87                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000CA8C                 add     esp, 0Ch
.text$mn:0000CA8F                 mov     edx, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000CA94                 test    edx, edx
.text$mn:0000CA96                 jz      short loc_CA9C
.text$mn:0000CA98                 xor     eax, eax
.text$mn:0000CA9A                 jnz     short loc_CABF
.text$mn:0000CA9C
.text$mn:0000CA9C loc_CA9C:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+76j
.text$mn:0000CA9C                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:0000CAA1                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000CAA6                 push    0
.text$mn:0000CAA8                 push    50h ; 'P'
.text$mn:0000CAAA                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000CAAF                 push    2
.text$mn:0000CAB1                 call    __CrtDbgReportW
.text$mn:0000CAB6                 add     esp, 18h
.text$mn:0000CAB9                 cmp     eax, 1
.text$mn:0000CABC                 jnz     short loc_CABF
.text$mn:0000CABE                 int     3               ; Trap to Debugger
.text$mn:0000CABF
.text$mn:0000CABF loc_CABF:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+7Aj
.text$mn:0000CABF                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+9Cj
.text$mn:0000CABF                 push    0
.text$mn:0000CAC1                 push    50h ; 'P'
.text$mn:0000CAC3                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000CAC8                 push    offset ??_C@_1MM@BFHGHMKD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_String_const_iterator<class std::"...
.text$mn:0000CACD                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000CAD2                 call    __invalid_parameter
.text$mn:0000CAD7                 add     esp, 14h
.text$mn:0000CADA
.text$mn:0000CADA loc_CADA:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+59j
.text$mn:0000CADA                 mov     edx, [ebp+var_4]
.text$mn:0000CADD                 mov     eax, [edx+8]
.text$mn:0000CAE0                 pop     esi
.text$mn:0000CAE1                 mov     esp, ebp
.text$mn:0000CAE3                 pop     ebp
.text$mn:0000CAE4                 retn
.text$mn:0000CAE4 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ endp
.text$mn:0000CAE4
.text$mn:0000CAE4 ; ---------------------------------------------------------------------------
.text$mn:0000CAE5                 align 4
.text$mn:0000CAE5 _text$mn        ends
.text$mn:0000CAE5
.text$mn:0000CAE8 ; ===========================================================================
.text$mn:0000CAE8
.text$mn:0000CAE8 ; Segment type: Pure code
.text$mn:0000CAE8 ; Segment permissions: Read/Execute
.text$mn:0000CAE8 _text$mn        segment para public 'CODE' use32
.text$mn:0000CAE8                 assume cs:_text$mn
.text$mn:0000CAE8                 ;org 0CAE8h
.text$mn:0000CAE8 ; COMDAT (pick any)
.text$mn:0000CAE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CAE8
.text$mn:0000CAE8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CAE8
.text$mn:0000CAE8 ; Attributes: bp-based frame
.text$mn:0000CAE8
.text$mn:0000CAE8 ; public: wchar_t & __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::operator*(void)const
.text$mn:0000CAE8                 public ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ
.text$mn:0000CAE8 ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ proc near
.text$mn:0000CAE8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+135p
.text$mn:0000CAE8
.text$mn:0000CAE8 var_4           = dword ptr -4
.text$mn:0000CAE8
.text$mn:0000CAE8                 push    ebp
.text$mn:0000CAE9                 mov     ebp, esp
.text$mn:0000CAEB                 push    ecx
.text$mn:0000CAEC                 mov     [ebp+var_4], ecx
.text$mn:0000CAEF                 mov     ecx, [ebp+var_4]
.text$mn:0000CAF2                 call    ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)
.text$mn:0000CAF7                 mov     esp, ebp
.text$mn:0000CAF9                 pop     ebp
.text$mn:0000CAFA                 retn
.text$mn:0000CAFA ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ endp
.text$mn:0000CAFA
.text$mn:0000CAFA ; ---------------------------------------------------------------------------
.text$mn:0000CAFB                 align 4
.text$mn:0000CAFB _text$mn        ends
.text$mn:0000CAFB
.text$mn:0000CAFC ; ===========================================================================
.text$mn:0000CAFC
.text$mn:0000CAFC ; Segment type: Pure code
.text$mn:0000CAFC ; Segment permissions: Read/Execute
.text$mn:0000CAFC _text$mn        segment para public 'CODE' use32
.text$mn:0000CAFC                 assume cs:_text$mn
.text$mn:0000CAFC                 ;org 0CAFCh
.text$mn:0000CAFC ; COMDAT (pick any)
.text$mn:0000CAFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CAFC
.text$mn:0000CAFC ; =============== S U B R O U T I N E =======================================
.text$mn:0000CAFC
.text$mn:0000CAFC ; Attributes: bp-based frame
.text$mn:0000CAFC
.text$mn:0000CAFC ; public: int const & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::operator*(void)const
.text$mn:0000CAFC                 public ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ
.text$mn:0000CAFC ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ proc near
.text$mn:0000CAFC                                         ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+6Fp
.text$mn:0000CAFC                                         ; Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+209p
.text$mn:0000CAFC
.text$mn:0000CAFC var_4           = dword ptr -4
.text$mn:0000CAFC
.text$mn:0000CAFC                 push    ebp
.text$mn:0000CAFD                 mov     ebp, esp
.text$mn:0000CAFF                 push    ecx
.text$mn:0000CB00                 mov     [ebp+var_4], ecx
.text$mn:0000CB03                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CB06                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000CB0B                 test    eax, eax
.text$mn:0000CB0D                 jz      short loc_CB3E
.text$mn:0000CB0F                 mov     eax, [ebp+var_4]
.text$mn:0000CB12                 cmp     dword ptr [eax+8], 0
.text$mn:0000CB16                 jz      short loc_CB3E
.text$mn:0000CB18                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CB1B                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000CB20                 mov     ecx, [ebp+var_4]
.text$mn:0000CB23                 mov     edx, [ecx+8]
.text$mn:0000CB26                 cmp     edx, [eax+4]
.text$mn:0000CB29                 jb      short loc_CB3E
.text$mn:0000CB2B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CB2E                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000CB33                 mov     ecx, [ebp+var_4]
.text$mn:0000CB36                 mov     edx, [eax+8]
.text$mn:0000CB39                 cmp     edx, [ecx+8]
.text$mn:0000CB3C                 ja      short loc_CB9D
.text$mn:0000CB3E
.text$mn:0000CB3E loc_CB3E:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+11j
.text$mn:0000CB3E                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+1Aj ...
.text$mn:0000CB3E                 push    48h ; 'H'       ; unsigned int
.text$mn:0000CB40                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000CB45                 push    offset ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; "vector iterator not dereferencable"
.text$mn:0000CB4A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000CB4F                 add     esp, 0Ch
.text$mn:0000CB52                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000CB57                 test    eax, eax
.text$mn:0000CB59                 jz      short loc_CB5F
.text$mn:0000CB5B                 xor     ecx, ecx
.text$mn:0000CB5D                 jnz     short loc_CB82
.text$mn:0000CB5F
.text$mn:0000CB5F loc_CB5F:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+5Dj
.text$mn:0000CB5F                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:0000CB64                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000CB69                 push    0
.text$mn:0000CB6B                 push    49h ; 'I'
.text$mn:0000CB6D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000CB72                 push    2
.text$mn:0000CB74                 call    __CrtDbgReportW
.text$mn:0000CB79                 add     esp, 18h
.text$mn:0000CB7C                 cmp     eax, 1
.text$mn:0000CB7F                 jnz     short loc_CB82
.text$mn:0000CB81                 int     3               ; Trap to Debugger
.text$mn:0000CB82
.text$mn:0000CB82 loc_CB82:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+61j
.text$mn:0000CB82                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+83j
.text$mn:0000CB82                 push    0
.text$mn:0000CB84                 push    49h ; 'I'
.text$mn:0000CB86                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000CB8B                 push    offset ??_C@_1ME@LLCFNFIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:0000CB90                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000CB95                 call    __invalid_parameter
.text$mn:0000CB9A                 add     esp, 14h
.text$mn:0000CB9D
.text$mn:0000CB9D loc_CB9D:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+40j
.text$mn:0000CB9D                 mov     eax, [ebp+var_4]
.text$mn:0000CBA0                 mov     eax, [eax+8]
.text$mn:0000CBA3                 mov     esp, ebp
.text$mn:0000CBA5                 pop     ebp
.text$mn:0000CBA6                 retn
.text$mn:0000CBA6 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ endp
.text$mn:0000CBA6
.text$mn:0000CBA6 ; ---------------------------------------------------------------------------
.text$mn:0000CBA7                 align 4
.text$mn:0000CBA7 _text$mn        ends
.text$mn:0000CBA7
.text$mn:0000CBA8 ; ===========================================================================
.text$mn:0000CBA8
.text$mn:0000CBA8 ; Segment type: Pure code
.text$mn:0000CBA8 ; Segment permissions: Read/Execute
.text$mn:0000CBA8 _text$mn        segment para public 'CODE' use32
.text$mn:0000CBA8                 assume cs:_text$mn
.text$mn:0000CBA8                 ;org 0CBA8h
.text$mn:0000CBA8 ; COMDAT (pick any)
.text$mn:0000CBA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CBA8
.text$mn:0000CBA8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CBA8
.text$mn:0000CBA8 ; Attributes: bp-based frame
.text$mn:0000CBA8
.text$mn:0000CBA8 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::operator++(void)
.text$mn:0000CBA8                 public ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:0000CBA8 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:0000CBA8                                         ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+50p
.text$mn:0000CBA8                                         ; Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+1E0p
.text$mn:0000CBA8
.text$mn:0000CBA8 var_4           = dword ptr -4
.text$mn:0000CBA8
.text$mn:0000CBA8                 push    ebp
.text$mn:0000CBA9                 mov     ebp, esp
.text$mn:0000CBAB                 push    ecx
.text$mn:0000CBAC                 mov     [ebp+var_4], ecx
.text$mn:0000CBAF                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CBB2                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000CBB7                 test    eax, eax
.text$mn:0000CBB9                 jz      short loc_CBD7
.text$mn:0000CBBB                 mov     eax, [ebp+var_4]
.text$mn:0000CBBE                 cmp     dword ptr [eax+8], 0
.text$mn:0000CBC2                 jz      short loc_CBD7
.text$mn:0000CBC4                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CBC7                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000CBCC                 mov     ecx, [ebp+var_4]
.text$mn:0000CBCF                 mov     edx, [eax+8]
.text$mn:0000CBD2                 cmp     edx, [ecx+8]
.text$mn:0000CBD5                 ja      short loc_CC36
.text$mn:0000CBD7
.text$mn:0000CBD7 loc_CBD7:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+11j
.text$mn:0000CBD7                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+1Aj
.text$mn:0000CBD7                 push    65h ; 'e'       ; unsigned int
.text$mn:0000CBD9                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000CBDE                 push    offset ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ ; "vector iterator not incrementable"
.text$mn:0000CBE3                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000CBE8                 add     esp, 0Ch
.text$mn:0000CBEB                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000CBF0                 test    eax, eax
.text$mn:0000CBF2                 jz      short loc_CBF8
.text$mn:0000CBF4                 xor     ecx, ecx
.text$mn:0000CBF6                 jnz     short loc_CC1B
.text$mn:0000CBF8
.text$mn:0000CBF8 loc_CBF8:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+4Aj
.text$mn:0000CBF8                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:0000CBFD                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000CC02                 push    0
.text$mn:0000CC04                 push    66h ; 'f'
.text$mn:0000CC06                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000CC0B                 push    2
.text$mn:0000CC0D                 call    __CrtDbgReportW
.text$mn:0000CC12                 add     esp, 18h
.text$mn:0000CC15                 cmp     eax, 1
.text$mn:0000CC18                 jnz     short loc_CC1B
.text$mn:0000CC1A                 int     3               ; Trap to Debugger
.text$mn:0000CC1B
.text$mn:0000CC1B loc_CC1B:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+4Ej
.text$mn:0000CC1B                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+70j
.text$mn:0000CC1B                 push    0
.text$mn:0000CC1D                 push    66h ; 'f'
.text$mn:0000CC1F                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000CC24                 push    offset ??_C@_1MG@OPNGNDCB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:0000CC29                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000CC2E                 call    __invalid_parameter
.text$mn:0000CC33                 add     esp, 14h
.text$mn:0000CC36
.text$mn:0000CC36 loc_CC36:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+2Dj
.text$mn:0000CC36                 mov     eax, [ebp+var_4]
.text$mn:0000CC39                 mov     ecx, [eax+8]
.text$mn:0000CC3C                 add     ecx, 4
.text$mn:0000CC3F                 mov     edx, [ebp+var_4]
.text$mn:0000CC42                 mov     [edx+8], ecx
.text$mn:0000CC45                 mov     eax, [ebp+var_4]
.text$mn:0000CC48                 mov     esp, ebp
.text$mn:0000CC4A                 pop     ebp
.text$mn:0000CC4B                 retn
.text$mn:0000CC4B ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:0000CC4B
.text$mn:0000CC4B _text$mn        ends
.text$mn:0000CC4B
.text$mn:0000CC4C ; ===========================================================================
.text$mn:0000CC4C
.text$mn:0000CC4C ; Segment type: Pure code
.text$mn:0000CC4C ; Segment permissions: Read/Execute
.text$mn:0000CC4C _text$mn        segment para public 'CODE' use32
.text$mn:0000CC4C                 assume cs:_text$mn
.text$mn:0000CC4C                 ;org 0CC4Ch
.text$mn:0000CC4C ; COMDAT (pick any)
.text$mn:0000CC4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CC4C
.text$mn:0000CC4C ; =============== S U B R O U T I N E =======================================
.text$mn:0000CC4C
.text$mn:0000CC4C ; Attributes: bp-based frame
.text$mn:0000CC4C
.text$mn:0000CC4C ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_Iterator_base12 *)
.text$mn:0000CC4C                 public ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z
.text$mn:0000CC4C ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z proc near
.text$mn:0000CC4C                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+4Bp
.text$mn:0000CC4C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+42p
.text$mn:0000CC4C
.text$mn:0000CC4C var_4           = dword ptr -4
.text$mn:0000CC4C arg_0           = dword ptr  8
.text$mn:0000CC4C
.text$mn:0000CC4C                 push    ebp
.text$mn:0000CC4D                 mov     ebp, esp
.text$mn:0000CC4F                 push    ecx
.text$mn:0000CC50                 mov     [ebp+var_4], ecx
.text$mn:0000CC53                 mov     eax, [ebp+arg_0]
.text$mn:0000CC56                 push    eax             ; std::_Iterator_base12 *
.text$mn:0000CC57                 mov     ecx, [ebp+var_4]
.text$mn:0000CC5A                 call    ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000CC5F                 mov     ecx, [ebp+var_4]
.text$mn:0000CC62                 mov     edx, [ebp+arg_0]
.text$mn:0000CC65                 mov     eax, [ecx+8]
.text$mn:0000CC68                 sub     eax, [edx+8]
.text$mn:0000CC6B                 sar     eax, 1
.text$mn:0000CC6D                 mov     esp, ebp
.text$mn:0000CC6F                 pop     ebp
.text$mn:0000CC70                 retn    4
.text$mn:0000CC70 ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z endp
.text$mn:0000CC70
.text$mn:0000CC70 ; ---------------------------------------------------------------------------
.text$mn:0000CC73                 align 4
.text$mn:0000CC73 _text$mn        ends
.text$mn:0000CC73
.text$mn:0000CC74 ; ===========================================================================
.text$mn:0000CC74
.text$mn:0000CC74 ; Segment type: Pure code
.text$mn:0000CC74 ; Segment permissions: Read/Execute
.text$mn:0000CC74 _text$mn        segment para public 'CODE' use32
.text$mn:0000CC74                 assume cs:_text$mn
.text$mn:0000CC74                 ;org 0CC74h
.text$mn:0000CC74 ; COMDAT (pick any)
.text$mn:0000CC74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CC74
.text$mn:0000CC74 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CC74
.text$mn:0000CC74 ; Attributes: bp-based frame
.text$mn:0000CC74
.text$mn:0000CC74 ; int __stdcall std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_Iterator_base12 *)
.text$mn:0000CC74                 public ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$mn:0000CC74 ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z proc near
.text$mn:0000CC74                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+12Cp
.text$mn:0000CC74
.text$mn:0000CC74 var_28          = byte ptr -28h
.text$mn:0000CC74 var_1C          = dword ptr -1Ch
.text$mn:0000CC74 var_18          = dword ptr -18h
.text$mn:0000CC74 var_14          = dword ptr -14h
.text$mn:0000CC74 var_10          = dword ptr -10h
.text$mn:0000CC74 var_C           = dword ptr -0Ch
.text$mn:0000CC74 var_4           = dword ptr -4
.text$mn:0000CC74 arg_0           = dword ptr  8
.text$mn:0000CC74
.text$mn:0000CC74                 push    ebp
.text$mn:0000CC75                 mov     ebp, esp
.text$mn:0000CC77                 push    0FFFFFFFFh
.text$mn:0000CC79                 push    offset __ehhandler$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$mn:0000CC7E                 mov     eax, large fs:0
.text$mn:0000CC84                 push    eax
.text$mn:0000CC85                 sub     esp, 1Ch
.text$mn:0000CC88                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000CC8D                 xor     eax, ebp
.text$mn:0000CC8F                 push    eax
.text$mn:0000CC90                 lea     eax, [ebp+var_C]
.text$mn:0000CC93                 mov     large fs:0, eax
.text$mn:0000CC99                 mov     [ebp+var_10], ecx
.text$mn:0000CC9C                 mov     eax, [ebp+arg_0]
.text$mn:0000CC9F                 push    eax             ; std::_Iterator_base12 *
.text$mn:0000CCA0                 mov     ecx, [ebp+var_10]
.text$mn:0000CCA3                 push    ecx             ; struct std::_Iterator_base12 *
.text$mn:0000CCA4                 lea     ecx, [ebp+var_28]
.text$mn:0000CCA7                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000CCAC                 mov     [ebp+var_14], eax
.text$mn:0000CCAF                 mov     edx, [ebp+var_14]
.text$mn:0000CCB2                 mov     [ebp+var_18], edx
.text$mn:0000CCB5                 mov     [ebp+var_4], 0
.text$mn:0000CCBC                 mov     ecx, [ebp+var_18]
.text$mn:0000CCBF                 call    ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000CCC4                 mov     [ebp+var_1C], eax
.text$mn:0000CCC7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000CCCE                 lea     ecx, [ebp+var_28]
.text$mn:0000CCD1                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000CCD6                 mov     eax, [ebp+var_1C]
.text$mn:0000CCD9                 mov     ecx, [ebp+var_C]
.text$mn:0000CCDC                 mov     large fs:0, ecx
.text$mn:0000CCE3                 pop     ecx
.text$mn:0000CCE4                 mov     esp, ebp
.text$mn:0000CCE6                 pop     ebp
.text$mn:0000CCE7                 retn    4
.text$mn:0000CCE7 ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z endp
.text$mn:0000CCE7
.text$mn:0000CCE7 ; ---------------------------------------------------------------------------
.text$mn:0000CCEA                 align 4
.text$mn:0000CCEA _text$mn        ends
.text$mn:0000CCEA
.text$x:0000CCEC ; ===========================================================================
.text$x:0000CCEC
.text$x:0000CCEC ; Segment type: Pure code
.text$x:0000CCEC ; Segment permissions: Read/Execute
.text$x:0000CCEC _text$x         segment para public 'CODE' use32
.text$x:0000CCEC                 assume cs:_text$x
.text$x:0000CCEC                 ;org 0CCECh
.text$x:0000CCEC ; COMDAT (pick associative to section at CC74)
.text$x:0000CCEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000CCEC
.text$x:0000CCEC ; =============== S U B R O U T I N E =======================================
.text$x:0000CCEC
.text$x:0000CCEC
.text$x:0000CCEC __unwindfunclet$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$0 proc near
.text$x:0000CCEC                                         ; DATA XREF: .xdata$x:00013DCCo
.text$x:0000CCEC                 lea     ecx, [ebp-28h]
.text$x:0000CCEF                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000CCEF __unwindfunclet$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$0 endp
.text$x:0000CCEF
.text$x:0000CCF4
.text$x:0000CCF4 ; =============== S U B R O U T I N E =======================================
.text$x:0000CCF4
.text$x:0000CCF4
.text$x:0000CCF4 __ehhandler$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z proc near
.text$x:0000CCF4                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+5o
.text$x:0000CCF4
.text$x:0000CCF4 arg_4           = dword ptr  8
.text$x:0000CCF4
.text$x:0000CCF4                 mov     edx, [esp+arg_4]
.text$x:0000CCF8                 lea     eax, [edx+0Ch]
.text$x:0000CCFB                 mov     ecx, [edx-20h]
.text$x:0000CCFE                 xor     ecx, eax
.text$x:0000CD00                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000CD05                 mov     eax, offset __ehfuncinfo$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$x:0000CD0A                 jmp     ___CxxFrameHandler3
.text$x:0000CD0A __ehhandler$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z endp
.text$x:0000CD0A
.text$x:0000CD0A ; ---------------------------------------------------------------------------
.text$x:0000CD0F                 align 10h
.text$x:0000CD0F _text$x         ends
.text$x:0000CD0F
.text$mn:0000CD10 ; ===========================================================================
.text$mn:0000CD10
.text$mn:0000CD10 ; Segment type: Pure code
.text$mn:0000CD10 ; Segment permissions: Read/Execute
.text$mn:0000CD10 _text$mn        segment para public 'CODE' use32
.text$mn:0000CD10                 assume cs:_text$mn
.text$mn:0000CD10                 ;org 0CD10h
.text$mn:0000CD10 ; COMDAT (pick any)
.text$mn:0000CD10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CD10
.text$mn:0000CD10 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CD10
.text$mn:0000CD10 ; Attributes: bp-based frame
.text$mn:0000CD10
.text$mn:0000CD10 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>> __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>::operator+(int)const
.text$mn:0000CD10                 public ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:0000CD10 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:0000CD10                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+D4p
.text$mn:0000CD10                                         ; Notepad_plus::loadSession(Session &,bool)+59Fp ...
.text$mn:0000CD10
.text$mn:0000CD10 var_20          = byte ptr -20h
.text$mn:0000CD10 var_14          = dword ptr -14h
.text$mn:0000CD10 var_10          = dword ptr -10h
.text$mn:0000CD10 var_C           = dword ptr -0Ch
.text$mn:0000CD10 var_4           = dword ptr -4
.text$mn:0000CD10 arg_0           = dword ptr  8
.text$mn:0000CD10 arg_4           = dword ptr  0Ch
.text$mn:0000CD10
.text$mn:0000CD10                 push    ebp
.text$mn:0000CD11                 mov     ebp, esp
.text$mn:0000CD13                 push    0FFFFFFFFh
.text$mn:0000CD15                 push    offset __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:0000CD1A                 mov     eax, large fs:0
.text$mn:0000CD20                 push    eax
.text$mn:0000CD21                 sub     esp, 14h
.text$mn:0000CD24                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000CD29                 xor     eax, ebp
.text$mn:0000CD2B                 push    eax
.text$mn:0000CD2C                 lea     eax, [ebp+var_C]
.text$mn:0000CD2F                 mov     large fs:0, eax
.text$mn:0000CD35                 mov     [ebp+var_14], ecx
.text$mn:0000CD38                 mov     [ebp+var_10], 0
.text$mn:0000CD3F                 mov     eax, [ebp+var_14]
.text$mn:0000CD42                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000CD43                 lea     ecx, [ebp+var_20]
.text$mn:0000CD46                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>> const &)
.text$mn:0000CD4B                 mov     [ebp+var_4], 1
.text$mn:0000CD52                 mov     ecx, [ebp+arg_4]
.text$mn:0000CD55                 push    ecx
.text$mn:0000CD56                 lea     ecx, [ebp+var_20]
.text$mn:0000CD59                 call    ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+=(int)
.text$mn:0000CD5E                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000CD5F                 mov     ecx, [ebp+arg_0]
.text$mn:0000CD62                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>> const &)
.text$mn:0000CD67                 mov     edx, [ebp+var_10]
.text$mn:0000CD6A                 or      edx, 1
.text$mn:0000CD6D                 mov     [ebp+var_10], edx
.text$mn:0000CD70                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000CD74                 lea     ecx, [ebp+var_20]
.text$mn:0000CD77                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:0000CD7C                 mov     eax, [ebp+arg_0]
.text$mn:0000CD7F                 mov     ecx, [ebp+var_C]
.text$mn:0000CD82                 mov     large fs:0, ecx
.text$mn:0000CD89                 pop     ecx
.text$mn:0000CD8A                 mov     esp, ebp
.text$mn:0000CD8C                 pop     ebp
.text$mn:0000CD8D                 retn    8
.text$mn:0000CD8D ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:0000CD8D
.text$mn:0000CD8D _text$mn        ends
.text$mn:0000CD8D
.text$x:0000CD90 ; ===========================================================================
.text$x:0000CD90
.text$x:0000CD90 ; Segment type: Pure code
.text$x:0000CD90 ; Segment permissions: Read/Execute
.text$x:0000CD90 _text$x         segment para public 'CODE' use32
.text$x:0000CD90                 assume cs:_text$x
.text$x:0000CD90                 ;org 0CD90h
.text$x:0000CD90 ; COMDAT (pick associative to section at CD10)
.text$x:0000CD90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000CD90
.text$x:0000CD90 ; =============== S U B R O U T I N E =======================================
.text$x:0000CD90
.text$x:0000CD90
.text$x:0000CD90 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:0000CD90                                         ; DATA XREF: .xdata$x:00013D1Co
.text$x:0000CD90                 lea     ecx, [ebp-20h]
.text$x:0000CD93                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:0000CD93 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:0000CD93
.text$x:0000CD98
.text$x:0000CD98 ; =============== S U B R O U T I N E =======================================
.text$x:0000CD98
.text$x:0000CD98
.text$x:0000CD98 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:0000CD98                                         ; DATA XREF: .xdata$x:00013D14o
.text$x:0000CD98                 mov     eax, [ebp-10h]
.text$x:0000CD9B                 and     eax, 1
.text$x:0000CD9E                 jz      $LN5_0
.text$x:0000CDA4                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000CDA8                 mov     ecx, [ebp+8]
.text$x:0000CDAB                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:0000CDB0 ; ---------------------------------------------------------------------------
.text$x:0000CDB0
.text$x:0000CDB0 $LN5_0:                                 ; CODE XREF: __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:0000CDB0                 retn
.text$x:0000CDB0 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:0000CDB0
.text$x:0000CDB1
.text$x:0000CDB1 ; =============== S U B R O U T I N E =======================================
.text$x:0000CDB1
.text$x:0000CDB1
.text$x:0000CDB1 __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:0000CDB1                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+(int)+5o
.text$x:0000CDB1
.text$x:0000CDB1 arg_4           = dword ptr  8
.text$x:0000CDB1
.text$x:0000CDB1                 mov     edx, [esp+arg_4]
.text$x:0000CDB5                 lea     eax, [edx+0Ch]
.text$x:0000CDB8                 mov     ecx, [edx-18h]
.text$x:0000CDBB                 xor     ecx, eax
.text$x:0000CDBD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000CDC2                 mov     eax, offset __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:0000CDC7                 jmp     ___CxxFrameHandler3
.text$x:0000CDC7 __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:0000CDC7
.text$x:0000CDC7 _text$x         ends
.text$x:0000CDC7
.text$mn:0000CDCC ; ===========================================================================
.text$mn:0000CDCC
.text$mn:0000CDCC ; Segment type: Pure code
.text$mn:0000CDCC ; Segment permissions: Read/Execute
.text$mn:0000CDCC _text$mn        segment para public 'CODE' use32
.text$mn:0000CDCC                 assume cs:_text$mn
.text$mn:0000CDCC                 ;org 0CDCCh
.text$mn:0000CDCC ; COMDAT (pick any)
.text$mn:0000CDCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CDCC
.text$mn:0000CDCC ; =============== S U B R O U T I N E =======================================
.text$mn:0000CDCC
.text$mn:0000CDCC ; Attributes: bp-based frame
.text$mn:0000CDCC
.text$mn:0000CDCC ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>::operator+=(int)
.text$mn:0000CDCC                 public ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:0000CDCC ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:0000CDCC                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+=(int)+Ep
.text$mn:0000CDCC
.text$mn:0000CDCC var_4           = dword ptr -4
.text$mn:0000CDCC arg_0           = dword ptr  8
.text$mn:0000CDCC
.text$mn:0000CDCC                 push    ebp
.text$mn:0000CDCD                 mov     ebp, esp
.text$mn:0000CDCF                 push    ecx
.text$mn:0000CDD0                 push    esi
.text$mn:0000CDD1                 mov     [ebp+var_4], ecx
.text$mn:0000CDD4                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CDD7                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000CDDC                 test    eax, eax
.text$mn:0000CDDE                 jz      short loc_CE14
.text$mn:0000CDE0                 imul    esi, [ebp+arg_0], 98h
.text$mn:0000CDE7                 mov     eax, [ebp+var_4]
.text$mn:0000CDEA                 add     esi, [eax+8]
.text$mn:0000CDED                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CDF0                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000CDF5                 cmp     esi, [eax+4]
.text$mn:0000CDF8                 jb      short loc_CE14
.text$mn:0000CDFA                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CDFD                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000CE02                 imul    ecx, [ebp+arg_0], 98h
.text$mn:0000CE09                 mov     edx, [ebp+var_4]
.text$mn:0000CE0C                 add     ecx, [edx+8]
.text$mn:0000CE0F                 cmp     [eax+8], ecx
.text$mn:0000CE12                 jnb     short loc_CE7C
.text$mn:0000CE14
.text$mn:0000CE14 loc_CE14:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+=(int)+12j
.text$mn:0000CE14                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+=(int)+2Cj
.text$mn:0000CE14                 push    9Fh ; 'ƒ'       ; unsigned int
.text$mn:0000CE19                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000CE1E                 push    offset ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ ; "vector iterator + offset out of range"
.text$mn:0000CE23                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000CE28                 add     esp, 0Ch
.text$mn:0000CE2B                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000CE30                 test    eax, eax
.text$mn:0000CE32                 jz      short loc_CE38
.text$mn:0000CE34                 xor     ecx, ecx
.text$mn:0000CE36                 jnz     short loc_CE5E
.text$mn:0000CE38
.text$mn:0000CE38 loc_CE38:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+=(int)+66j
.text$mn:0000CE38                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:0000CE3D                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000CE42                 push    0
.text$mn:0000CE44                 push    0A0h ; 'á'
.text$mn:0000CE49                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000CE4E                 push    2
.text$mn:0000CE50                 call    __CrtDbgReportW
.text$mn:0000CE55                 add     esp, 18h
.text$mn:0000CE58                 cmp     eax, 1
.text$mn:0000CE5B                 jnz     short loc_CE5E
.text$mn:0000CE5D                 int     3               ; Trap to Debugger
.text$mn:0000CE5E
.text$mn:0000CE5E loc_CE5E:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+=(int)+6Aj
.text$mn:0000CE5E                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+=(int)+8Fj
.text$mn:0000CE5E                 push    0
.text$mn:0000CE60                 push    0A0h ; 'á'
.text$mn:0000CE65                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000CE6A                 push    offset ??_C@_1OM@OFJPGKJA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:0000CE6F                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000CE74                 call    __invalid_parameter
.text$mn:0000CE79                 add     esp, 14h
.text$mn:0000CE7C
.text$mn:0000CE7C loc_CE7C:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+=(int)+46j
.text$mn:0000CE7C                 imul    eax, [ebp+arg_0], 98h
.text$mn:0000CE83                 mov     ecx, [ebp+var_4]
.text$mn:0000CE86                 add     eax, [ecx+8]
.text$mn:0000CE89                 mov     edx, [ebp+var_4]
.text$mn:0000CE8C                 mov     [edx+8], eax
.text$mn:0000CE8F                 mov     eax, [ebp+var_4]
.text$mn:0000CE92                 pop     esi
.text$mn:0000CE93                 mov     esp, ebp
.text$mn:0000CE95                 pop     ebp
.text$mn:0000CE96                 retn    4
.text$mn:0000CE96 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:0000CE96
.text$mn:0000CE96 ; ---------------------------------------------------------------------------
.text$mn:0000CE99                 align 4
.text$mn:0000CE99 _text$mn        ends
.text$mn:0000CE99
.text$mn:0000CE9C ; ===========================================================================
.text$mn:0000CE9C
.text$mn:0000CE9C ; Segment type: Pure code
.text$mn:0000CE9C ; Segment permissions: Read/Execute
.text$mn:0000CE9C _text$mn        segment para public 'CODE' use32
.text$mn:0000CE9C                 assume cs:_text$mn
.text$mn:0000CE9C                 ;org 0CE9Ch
.text$mn:0000CE9C ; COMDAT (pick any)
.text$mn:0000CE9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CE9C
.text$mn:0000CE9C ; =============== S U B R O U T I N E =======================================
.text$mn:0000CE9C
.text$mn:0000CE9C ; Attributes: bp-based frame
.text$mn:0000CE9C
.text$mn:0000CE9C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>::operator+=(int)
.text$mn:0000CE9C                 public ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:0000CE9C ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:0000CE9C                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+(int)+49p
.text$mn:0000CE9C
.text$mn:0000CE9C var_4           = dword ptr -4
.text$mn:0000CE9C arg_0           = dword ptr  8
.text$mn:0000CE9C
.text$mn:0000CE9C                 push    ebp
.text$mn:0000CE9D                 mov     ebp, esp
.text$mn:0000CE9F                 push    ecx
.text$mn:0000CEA0                 mov     [ebp+var_4], ecx
.text$mn:0000CEA3                 mov     eax, [ebp+arg_0]
.text$mn:0000CEA6                 push    eax
.text$mn:0000CEA7                 mov     ecx, [ebp+var_4]
.text$mn:0000CEAA                 call    ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+=(int)
.text$mn:0000CEAF                 mov     eax, [ebp+var_4]
.text$mn:0000CEB2                 mov     esp, ebp
.text$mn:0000CEB4                 pop     ebp
.text$mn:0000CEB5                 retn    4
.text$mn:0000CEB5 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:0000CEB5
.text$mn:0000CEB5 _text$mn        ends
.text$mn:0000CEB5
.text$mn:0000CEB8 ; ===========================================================================
.text$mn:0000CEB8
.text$mn:0000CEB8 ; Segment type: Pure code
.text$mn:0000CEB8 ; Segment permissions: Read/Execute
.text$mn:0000CEB8 _text$mn        segment para public 'CODE' use32
.text$mn:0000CEB8                 assume cs:_text$mn
.text$mn:0000CEB8                 ;org 0CEB8h
.text$mn:0000CEB8 ; COMDAT (pick any)
.text$mn:0000CEB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CEB8
.text$mn:0000CEB8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CEB8
.text$mn:0000CEB8 ; Attributes: bp-based frame
.text$mn:0000CEB8
.text$mn:0000CEB8 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator+=(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:0000CEB8                 public ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
.text$mn:0000CEB8 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:0000CEB8                                         ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+323p
.text$mn:0000CEB8
.text$mn:0000CEB8 var_4           = dword ptr -4
.text$mn:0000CEB8 arg_0           = dword ptr  8
.text$mn:0000CEB8
.text$mn:0000CEB8                 push    ebp
.text$mn:0000CEB9                 mov     ebp, esp
.text$mn:0000CEBB                 push    ecx
.text$mn:0000CEBC                 mov     [ebp+var_4], ecx
.text$mn:0000CEBF                 mov     eax, [ebp+arg_0]
.text$mn:0000CEC2                 push    eax
.text$mn:0000CEC3                 mov     ecx, [ebp+var_4]
.text$mn:0000CEC6                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000CECB                 mov     esp, ebp
.text$mn:0000CECD                 pop     ebp
.text$mn:0000CECE                 retn    4
.text$mn:0000CECE ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:0000CECE
.text$mn:0000CECE ; ---------------------------------------------------------------------------
.text$mn:0000CED1                 align 4
.text$mn:0000CED1 _text$mn        ends
.text$mn:0000CED1
.text$mn:0000CED4 ; ===========================================================================
.text$mn:0000CED4
.text$mn:0000CED4 ; Segment type: Pure code
.text$mn:0000CED4 ; Segment permissions: Read/Execute
.text$mn:0000CED4 _text$mn        segment para public 'CODE' use32
.text$mn:0000CED4                 assume cs:_text$mn
.text$mn:0000CED4                 ;org 0CED4h
.text$mn:0000CED4 ; COMDAT (pick any)
.text$mn:0000CED4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CED4
.text$mn:0000CED4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CED4
.text$mn:0000CED4 ; Attributes: bp-based frame
.text$mn:0000CED4
.text$mn:0000CED4 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t *Str)
.text$mn:0000CED4                 public ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:0000CED4 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:0000CED4                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+9B2p
.text$mn:0000CED4                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+B54p ...
.text$mn:0000CED4
.text$mn:0000CED4 var_4           = dword ptr -4
.text$mn:0000CED4 Str             = dword ptr  8
.text$mn:0000CED4
.text$mn:0000CED4                 push    ebp
.text$mn:0000CED5                 mov     ebp, esp
.text$mn:0000CED7                 push    ecx
.text$mn:0000CED8                 mov     [ebp+var_4], ecx
.text$mn:0000CEDB                 mov     eax, [ebp+Str]
.text$mn:0000CEDE                 push    eax             ; Str
.text$mn:0000CEDF                 mov     ecx, [ebp+var_4]
.text$mn:0000CEE2                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)
.text$mn:0000CEE7                 mov     esp, ebp
.text$mn:0000CEE9                 pop     ebp
.text$mn:0000CEEA                 retn    4
.text$mn:0000CEEA ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:0000CEEA
.text$mn:0000CEEA ; ---------------------------------------------------------------------------
.text$mn:0000CEED                 align 10h
.text$mn:0000CEED _text$mn        ends
.text$mn:0000CEED
.text$mn:0000CEF0 ; ===========================================================================
.text$mn:0000CEF0
.text$mn:0000CEF0 ; Segment type: Pure code
.text$mn:0000CEF0 ; Segment permissions: Read/Execute
.text$mn:0000CEF0 _text$mn        segment para public 'CODE' use32
.text$mn:0000CEF0                 assume cs:_text$mn
.text$mn:0000CEF0                 ;org 0CEF0h
.text$mn:0000CEF0 ; COMDAT (pick any)
.text$mn:0000CEF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CEF0
.text$mn:0000CEF0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CEF0
.text$mn:0000CEF0 ; Attributes: bp-based frame
.text$mn:0000CEF0
.text$mn:0000CEF0 ; public: void * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::`scalar deleting destructor'(unsigned int)
.text$mn:0000CEF0                 public ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z
.text$mn:0000CEF0 ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z proc near
.text$mn:0000CEF0                                         ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+Cp
.text$mn:0000CEF0
.text$mn:0000CEF0 var_4           = dword ptr -4
.text$mn:0000CEF0 arg_0           = dword ptr  8
.text$mn:0000CEF0
.text$mn:0000CEF0                 push    ebp
.text$mn:0000CEF1                 mov     ebp, esp
.text$mn:0000CEF3                 push    ecx
.text$mn:0000CEF4                 mov     [ebp+var_4], ecx
.text$mn:0000CEF7                 mov     ecx, [ebp+var_4]
.text$mn:0000CEFA                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000CEFF                 mov     eax, [ebp+arg_0]
.text$mn:0000CF02                 and     eax, 1
.text$mn:0000CF05                 jz      short loc_CF13
.text$mn:0000CF07                 mov     ecx, [ebp+var_4]
.text$mn:0000CF0A                 push    ecx             ; void *
.text$mn:0000CF0B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000CF10                 add     esp, 4
.text$mn:0000CF13
.text$mn:0000CF13 loc_CF13:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`scalar deleting destructor'(uint)+15j
.text$mn:0000CF13                 mov     eax, [ebp+var_4]
.text$mn:0000CF16                 mov     esp, ebp
.text$mn:0000CF18                 pop     ebp
.text$mn:0000CF19                 retn    4
.text$mn:0000CF19 ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z endp
.text$mn:0000CF19
.text$mn:0000CF19 _text$mn        ends
.text$mn:0000CF19
.text$mn:0000CF1C ; ===========================================================================
.text$mn:0000CF1C
.text$mn:0000CF1C ; Segment type: Pure code
.text$mn:0000CF1C ; Segment permissions: Read/Execute
.text$mn:0000CF1C _text$mn        segment para public 'CODE' use32
.text$mn:0000CF1C                 assume cs:_text$mn
.text$mn:0000CF1C                 ;org 0CF1Ch
.text$mn:0000CF1C ; COMDAT (pick any)
.text$mn:0000CF1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CF1C
.text$mn:0000CF1C ; =============== S U B R O U T I N E =======================================
.text$mn:0000CF1C
.text$mn:0000CF1C ; Attributes: bp-based frame
.text$mn:0000CF1C
.text$mn:0000CF1C ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000CF1C                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:0000CF1C ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000CF1C
.text$mn:0000CF1C var_4           = dword ptr -4
.text$mn:0000CF1C arg_0           = dword ptr  8
.text$mn:0000CF1C
.text$mn:0000CF1C                 push    ebp
.text$mn:0000CF1D                 mov     ebp, esp
.text$mn:0000CF1F                 push    ecx
.text$mn:0000CF20                 mov     [ebp+var_4], ecx
.text$mn:0000CF23                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CF26                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000CF2B                 mov     eax, [ebp+arg_0]
.text$mn:0000CF2E                 and     eax, 1
.text$mn:0000CF31                 jz      short loc_CF3F
.text$mn:0000CF33                 mov     ecx, [ebp+var_4]
.text$mn:0000CF36                 push    ecx             ; void *
.text$mn:0000CF37                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000CF3C                 add     esp, 4
.text$mn:0000CF3F
.text$mn:0000CF3F loc_CF3F:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000CF3F                 mov     eax, [ebp+var_4]
.text$mn:0000CF42                 mov     esp, ebp
.text$mn:0000CF44                 pop     ebp
.text$mn:0000CF45                 retn    4
.text$mn:0000CF45 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:0000CF45
.text$mn:0000CF45 _text$mn        ends
.text$mn:0000CF45
.text$mn:0000CF48 ; ===========================================================================
.text$mn:0000CF48
.text$mn:0000CF48 ; Segment type: Pure code
.text$mn:0000CF48 ; Segment permissions: Read/Execute
.text$mn:0000CF48 _text$mn        segment para public 'CODE' use32
.text$mn:0000CF48                 assume cs:_text$mn
.text$mn:0000CF48                 ;org 0CF48h
.text$mn:0000CF48 ; COMDAT (pick any)
.text$mn:0000CF48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CF48
.text$mn:0000CF48 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CF48
.text$mn:0000CF48 ; Attributes: bp-based frame
.text$mn:0000CF48
.text$mn:0000CF48 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000CF48                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:0000CF48 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000CF48
.text$mn:0000CF48 var_4           = dword ptr -4
.text$mn:0000CF48 arg_0           = dword ptr  8
.text$mn:0000CF48
.text$mn:0000CF48                 push    ebp
.text$mn:0000CF49                 mov     ebp, esp
.text$mn:0000CF4B                 push    ecx
.text$mn:0000CF4C                 mov     [ebp+var_4], ecx
.text$mn:0000CF4F                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CF52                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:0000CF57                 mov     eax, [ebp+arg_0]
.text$mn:0000CF5A                 and     eax, 1
.text$mn:0000CF5D                 jz      short loc_CF6B
.text$mn:0000CF5F                 mov     ecx, [ebp+var_4]
.text$mn:0000CF62                 push    ecx             ; void *
.text$mn:0000CF63                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000CF68                 add     esp, 4
.text$mn:0000CF6B
.text$mn:0000CF6B loc_CF6B:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000CF6B                 mov     eax, [ebp+var_4]
.text$mn:0000CF6E                 mov     esp, ebp
.text$mn:0000CF70                 pop     ebp
.text$mn:0000CF71                 retn    4
.text$mn:0000CF71 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:0000CF71
.text$mn:0000CF71 _text$mn        ends
.text$mn:0000CF71
.text$mn:0000CF74 ; ===========================================================================
.text$mn:0000CF74
.text$mn:0000CF74 ; Segment type: Pure code
.text$mn:0000CF74 ; Segment permissions: Read/Execute
.text$mn:0000CF74 _text$mn        segment para public 'CODE' use32
.text$mn:0000CF74                 assume cs:_text$mn
.text$mn:0000CF74                 ;org 0CF74h
.text$mn:0000CF74 ; COMDAT (pick any)
.text$mn:0000CF74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CF74
.text$mn:0000CF74 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CF74
.text$mn:0000CF74 ; Attributes: bp-based frame
.text$mn:0000CF74
.text$mn:0000CF74 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000CF74                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:0000CF74 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000CF74
.text$mn:0000CF74 var_4           = dword ptr -4
.text$mn:0000CF74 arg_0           = dword ptr  8
.text$mn:0000CF74
.text$mn:0000CF74                 push    ebp
.text$mn:0000CF75                 mov     ebp, esp
.text$mn:0000CF77                 push    ecx
.text$mn:0000CF78                 mov     [ebp+var_4], ecx
.text$mn:0000CF7B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CF7E                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:0000CF83                 mov     eax, [ebp+arg_0]
.text$mn:0000CF86                 and     eax, 1
.text$mn:0000CF89                 jz      short loc_CF97
.text$mn:0000CF8B                 mov     ecx, [ebp+var_4]
.text$mn:0000CF8E                 push    ecx             ; void *
.text$mn:0000CF8F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000CF94                 add     esp, 4
.text$mn:0000CF97
.text$mn:0000CF97 loc_CF97:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000CF97                 mov     eax, [ebp+var_4]
.text$mn:0000CF9A                 mov     esp, ebp
.text$mn:0000CF9C                 pop     ebp
.text$mn:0000CF9D                 retn    4
.text$mn:0000CF9D ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:0000CF9D
.text$mn:0000CF9D _text$mn        ends
.text$mn:0000CF9D
.text$mn:0000CFA0 ; ===========================================================================
.text$mn:0000CFA0
.text$mn:0000CFA0 ; Segment type: Pure code
.text$mn:0000CFA0 ; Segment permissions: Read/Execute
.text$mn:0000CFA0 _text$mn        segment para public 'CODE' use32
.text$mn:0000CFA0                 assume cs:_text$mn
.text$mn:0000CFA0                 ;org 0CFA0h
.text$mn:0000CFA0 ; COMDAT (pick any)
.text$mn:0000CFA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CFA0
.text$mn:0000CFA0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CFA0
.text$mn:0000CFA0 ; Attributes: bp-based frame
.text$mn:0000CFA0
.text$mn:0000CFA0 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000CFA0                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:0000CFA0 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:0000CFA0
.text$mn:0000CFA0 var_4           = dword ptr -4
.text$mn:0000CFA0 arg_0           = dword ptr  8
.text$mn:0000CFA0
.text$mn:0000CFA0                 push    ebp
.text$mn:0000CFA1                 mov     ebp, esp
.text$mn:0000CFA3                 push    ecx
.text$mn:0000CFA4                 mov     [ebp+var_4], ecx
.text$mn:0000CFA7                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CFAA                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000CFAF                 mov     eax, [ebp+arg_0]
.text$mn:0000CFB2                 and     eax, 1
.text$mn:0000CFB5                 jz      short loc_CFC3
.text$mn:0000CFB7                 mov     ecx, [ebp+var_4]
.text$mn:0000CFBA                 push    ecx             ; void *
.text$mn:0000CFBB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000CFC0                 add     esp, 4
.text$mn:0000CFC3
.text$mn:0000CFC3 loc_CFC3:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000CFC3                 mov     eax, [ebp+var_4]
.text$mn:0000CFC6                 mov     esp, ebp
.text$mn:0000CFC8                 pop     ebp
.text$mn:0000CFC9                 retn    4
.text$mn:0000CFC9 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:0000CFC9
.text$mn:0000CFC9 _text$mn        ends
.text$mn:0000CFC9
.text$mn:0000CFCC ; ===========================================================================
.text$mn:0000CFCC
.text$mn:0000CFCC ; Segment type: Pure code
.text$mn:0000CFCC ; Segment permissions: Read/Execute
.text$mn:0000CFCC _text$mn        segment para public 'CODE' use32
.text$mn:0000CFCC                 assume cs:_text$mn
.text$mn:0000CFCC                 ;org 0CFCCh
.text$mn:0000CFCC ; COMDAT (pick any)
.text$mn:0000CFCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CFCC
.text$mn:0000CFCC ; =============== S U B R O U T I N E =======================================
.text$mn:0000CFCC
.text$mn:0000CFCC ; Attributes: bp-based frame
.text$mn:0000CFCC
.text$mn:0000CFCC ; public: void * __thiscall sessionFileInfo::`scalar deleting destructor'(unsigned int)
.text$mn:0000CFCC                 public ??_GsessionFileInfo@@QAEPAXI@Z
.text$mn:0000CFCC ??_GsessionFileInfo@@QAEPAXI@Z proc near
.text$mn:0000CFCC                                         ; CODE XREF: std::allocator<sessionFileInfo>::destroy<sessionFileInfo>(sessionFileInfo *)+Cp
.text$mn:0000CFCC
.text$mn:0000CFCC var_4           = dword ptr -4
.text$mn:0000CFCC arg_0           = dword ptr  8
.text$mn:0000CFCC
.text$mn:0000CFCC                 push    ebp
.text$mn:0000CFCD                 mov     ebp, esp
.text$mn:0000CFCF                 push    ecx
.text$mn:0000CFD0                 mov     [ebp+var_4], ecx
.text$mn:0000CFD3                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000CFD6                 call    ??1sessionFileInfo@@QAE@XZ ; sessionFileInfo::~sessionFileInfo(void)
.text$mn:0000CFDB                 mov     eax, [ebp+arg_0]
.text$mn:0000CFDE                 and     eax, 1
.text$mn:0000CFE1                 jz      short loc_CFEF
.text$mn:0000CFE3                 mov     ecx, [ebp+var_4]
.text$mn:0000CFE6                 push    ecx             ; void *
.text$mn:0000CFE7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000CFEC                 add     esp, 4
.text$mn:0000CFEF
.text$mn:0000CFEF loc_CFEF:                               ; CODE XREF: sessionFileInfo::`scalar deleting destructor'(uint)+15j
.text$mn:0000CFEF                 mov     eax, [ebp+var_4]
.text$mn:0000CFF2                 mov     esp, ebp
.text$mn:0000CFF4                 pop     ebp
.text$mn:0000CFF5                 retn    4
.text$mn:0000CFF5 ??_GsessionFileInfo@@QAEPAXI@Z endp
.text$mn:0000CFF5
.text$mn:0000CFF5 _text$mn        ends
.text$mn:0000CFF5
.text$di:0000CFF8 ; ===========================================================================
.text$di:0000CFF8
.text$di:0000CFF8 ; Segment type: Pure code
.text$di:0000CFF8 ; Segment permissions: Read/Execute
.text$di:0000CFF8 _text$di        segment para public 'CODE' use32
.text$di:0000CFF8                 assume cs:_text$di
.text$di:0000CFF8                 ;org 0CFF8h
.text$di:0000CFF8 ; COMDAT (pick any)
.text$di:0000CFF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000CFF8
.text$di:0000CFF8 ; =============== S U B R O U T I N E =======================================
.text$di:0000CFF8
.text$di:0000CFF8 ; Attributes: bp-based frame
.text$di:0000CFF8
.text$di:0000CFF8 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:0000CFF8 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:0000CFF8                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:0000CFF8                 push    ebp
.text$di:0000CFF9                 mov     ebp, esp
.text$di:0000CFFB                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:0000D000                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:0000D005                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000D00A                 call    _atexit
.text$di:0000D00F                 add     esp, 4
.text$di:0000D012                 pop     ebp
.text$di:0000D013                 retn
.text$di:0000D013 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:0000D013
.text$di:0000D013 _text$di        ends
.text$di:0000D013
.text$di:0000D014 ; ===========================================================================
.text$di:0000D014
.text$di:0000D014 ; Segment type: Pure code
.text$di:0000D014 ; Segment permissions: Read/Execute
.text$di:0000D014 _text$di        segment para public 'CODE' use32
.text$di:0000D014                 assume cs:_text$di
.text$di:0000D014                 ;org 0D014h
.text$di:0000D014 ; COMDAT (pick any)
.text$di:0000D014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000D014
.text$di:0000D014 ; =============== S U B R O U T I N E =======================================
.text$di:0000D014
.text$di:0000D014 ; Attributes: bp-based frame
.text$di:0000D014
.text$di:0000D014 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:0000D014 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:0000D014                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:0000D014                 push    ebp
.text$di:0000D015                 mov     ebp, esp
.text$di:0000D017                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:0000D01C                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:0000D021                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000D026                 call    _atexit
.text$di:0000D02B                 add     esp, 4
.text$di:0000D02E                 pop     ebp
.text$di:0000D02F                 retn
.text$di:0000D02F ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:0000D02F
.text$di:0000D02F _text$di        ends
.text$di:0000D02F
.text$di:0000D030 ; ===========================================================================
.text$di:0000D030
.text$di:0000D030 ; Segment type: Pure code
.text$di:0000D030 ; Segment permissions: Read/Execute
.text$di:0000D030 _text$di        segment para public 'CODE' use32
.text$di:0000D030                 assume cs:_text$di
.text$di:0000D030                 ;org 0D030h
.text$di:0000D030 ; COMDAT (pick any)
.text$di:0000D030                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000D030
.text$di:0000D030 ; =============== S U B R O U T I N E =======================================
.text$di:0000D030
.text$di:0000D030 ; Attributes: bp-based frame
.text$di:0000D030
.text$di:0000D030 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:0000D030 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:0000D030                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:0000D030                 push    ebp
.text$di:0000D031                 mov     ebp, esp
.text$di:0000D033                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:0000D038                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:0000D03D                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000D042                 call    _atexit
.text$di:0000D047                 add     esp, 4
.text$di:0000D04A                 pop     ebp
.text$di:0000D04B                 retn
.text$di:0000D04B ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:0000D04B
.text$di:0000D04B _text$di        ends
.text$di:0000D04B
.text$di:0000D04C ; ===========================================================================
.text$di:0000D04C
.text$di:0000D04C ; Segment type: Pure code
.text$di:0000D04C ; Segment permissions: Read/Execute
.text$di:0000D04C _text$di        segment para public 'CODE' use32
.text$di:0000D04C                 assume cs:_text$di
.text$di:0000D04C                 ;org 0D04Ch
.text$di:0000D04C ; COMDAT (pick any)
.text$di:0000D04C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000D04C
.text$di:0000D04C ; =============== S U B R O U T I N E =======================================
.text$di:0000D04C
.text$di:0000D04C ; Attributes: bp-based frame
.text$di:0000D04C
.text$di:0000D04C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:0000D04C ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000D04C                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:0000D04C                 push    ebp
.text$di:0000D04D                 mov     ebp, esp
.text$di:0000D04F                 push    0               ; unsigned int
.text$di:0000D051                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000D056                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000D05B                 pop     ebp
.text$di:0000D05C                 retn
.text$di:0000D05C ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000D05C
.text$di:0000D05C ; ---------------------------------------------------------------------------
.text$di:0000D05D                 align 10h
.text$di:0000D05D _text$di        ends
.text$di:0000D05D
.text$di:0000D060 ; ===========================================================================
.text$di:0000D060
.text$di:0000D060 ; Segment type: Pure code
.text$di:0000D060 ; Segment permissions: Read/Execute
.text$di:0000D060 _text$di        segment para public 'CODE' use32
.text$di:0000D060                 assume cs:_text$di
.text$di:0000D060                 ;org 0D060h
.text$di:0000D060 ; COMDAT (pick any)
.text$di:0000D060                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000D060
.text$di:0000D060 ; =============== S U B R O U T I N E =======================================
.text$di:0000D060
.text$di:0000D060 ; Attributes: bp-based frame
.text$di:0000D060
.text$di:0000D060 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:0000D060 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000D060                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:0000D060                 push    ebp
.text$di:0000D061                 mov     ebp, esp
.text$di:0000D063                 push    0               ; unsigned int
.text$di:0000D065                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000D06A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000D06F                 pop     ebp
.text$di:0000D070                 retn
.text$di:0000D070 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000D070
.text$di:0000D070 ; ---------------------------------------------------------------------------
.text$di:0000D071                 align 4
.text$di:0000D071 _text$di        ends
.text$di:0000D071
.text$di:0000D074 ; ===========================================================================
.text$di:0000D074
.text$di:0000D074 ; Segment type: Pure code
.text$di:0000D074 ; Segment permissions: Read/Execute
.text$di:0000D074 _text$di        segment para public 'CODE' use32
.text$di:0000D074                 assume cs:_text$di
.text$di:0000D074                 ;org 0D074h
.text$di:0000D074 ; COMDAT (pick any)
.text$di:0000D074                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000D074
.text$di:0000D074 ; =============== S U B R O U T I N E =======================================
.text$di:0000D074
.text$di:0000D074 ; Attributes: bp-based frame
.text$di:0000D074
.text$di:0000D074 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:0000D074 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000D074                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:0000D074                 push    ebp
.text$di:0000D075                 mov     ebp, esp
.text$di:0000D077                 push    0               ; unsigned int
.text$di:0000D079                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:0000D07E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000D083                 pop     ebp
.text$di:0000D084                 retn
.text$di:0000D084 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000D084
.text$di:0000D084 ; ---------------------------------------------------------------------------
.text$di:0000D085                 align 4
.text$di:0000D085 _text$di        ends
.text$di:0000D085
.text$di:0000D088 ; ===========================================================================
.text$di:0000D088
.text$di:0000D088 ; Segment type: Pure code
.text$di:0000D088 ; Segment permissions: Read/Execute
.text$di:0000D088 _text$di        segment para public 'CODE' use32
.text$di:0000D088                 assume cs:_text$di
.text$di:0000D088                 ;org 0D088h
.text$di:0000D088 ; COMDAT (pick any)
.text$di:0000D088                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000D088
.text$di:0000D088 ; =============== S U B R O U T I N E =======================================
.text$di:0000D088
.text$di:0000D088 ; Attributes: bp-based frame
.text$di:0000D088
.text$di:0000D088 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:0000D088 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000D088                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:0000D088                 push    ebp
.text$di:0000D089                 mov     ebp, esp
.text$di:0000D08B                 push    0               ; unsigned int
.text$di:0000D08D                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:0000D092                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000D097                 pop     ebp
.text$di:0000D098                 retn
.text$di:0000D098 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000D098
.text$di:0000D098 ; ---------------------------------------------------------------------------
.text$di:0000D099                 align 4
.text$di:0000D099 _text$di        ends
.text$di:0000D099
.text$di:0000D09C ; ===========================================================================
.text$di:0000D09C
.text$di:0000D09C ; Segment type: Pure code
.text$di:0000D09C ; Segment permissions: Read/Execute
.text$di:0000D09C _text$di        segment para public 'CODE' use32
.text$di:0000D09C                 assume cs:_text$di
.text$di:0000D09C                 ;org 0D09Ch
.text$di:0000D09C ; COMDAT (pick any)
.text$di:0000D09C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000D09C
.text$di:0000D09C ; =============== S U B R O U T I N E =======================================
.text$di:0000D09C
.text$di:0000D09C ; Attributes: bp-based frame
.text$di:0000D09C
.text$di:0000D09C ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:0000D09C ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:0000D09C
.text$di:0000D09C var_1           = byte ptr -1
.text$di:0000D09C
.text$di:0000D09C                 push    ebp
.text$di:0000D09D                 mov     ebp, esp
.text$di:0000D09F                 push    ecx
.text$di:0000D0A0                 xor     eax, eax
.text$di:0000D0A2                 mov     [ebp+var_1], al
.text$di:0000D0A5                 mov     esp, ebp
.text$di:0000D0A7                 pop     ebp
.text$di:0000D0A8                 retn
.text$di:0000D0A8 ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:0000D0A8
.text$di:0000D0A8 ; ---------------------------------------------------------------------------
.text$di:0000D0A9                 align 4
.text$di:0000D0A9 _text$di        ends
.text$di:0000D0A9
.text$di:0000D0AC ; ===========================================================================
.text$di:0000D0AC
.text$di:0000D0AC ; Segment type: Pure code
.text$di:0000D0AC ; Segment permissions: Read/Execute
.text$di:0000D0AC _text$di        segment para public 'CODE' use32
.text$di:0000D0AC                 assume cs:_text$di
.text$di:0000D0AC                 ;org 0D0ACh
.text$di:0000D0AC ; COMDAT (pick any)
.text$di:0000D0AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000D0AC
.text$di:0000D0AC ; =============== S U B R O U T I N E =======================================
.text$di:0000D0AC
.text$di:0000D0AC ; Attributes: bp-based frame
.text$di:0000D0AC
.text$di:0000D0AC ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:0000D0AC ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:0000D0AC
.text$di:0000D0AC var_1           = byte ptr -1
.text$di:0000D0AC
.text$di:0000D0AC                 push    ebp
.text$di:0000D0AD                 mov     ebp, esp
.text$di:0000D0AF                 push    ecx
.text$di:0000D0B0                 xor     eax, eax
.text$di:0000D0B2                 mov     [ebp+var_1], al
.text$di:0000D0B5                 mov     esp, ebp
.text$di:0000D0B7                 pop     ebp
.text$di:0000D0B8                 retn
.text$di:0000D0B8 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:0000D0B8
.text$di:0000D0B8 ; ---------------------------------------------------------------------------
.text$di:0000D0B9                 align 4
.text$di:0000D0B9 _text$di        ends
.text$di:0000D0B9
.text$di:0000D0BC ; ===========================================================================
.text$di:0000D0BC
.text$di:0000D0BC ; Segment type: Pure code
.text$di:0000D0BC ; Segment permissions: Read/Execute
.text$di:0000D0BC _text$di        segment para public 'CODE' use32
.text$di:0000D0BC                 assume cs:_text$di
.text$di:0000D0BC                 ;org 0D0BCh
.text$di:0000D0BC ; COMDAT (pick any)
.text$di:0000D0BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000D0BC
.text$di:0000D0BC ; =============== S U B R O U T I N E =======================================
.text$di:0000D0BC
.text$di:0000D0BC ; Attributes: bp-based frame
.text$di:0000D0BC
.text$di:0000D0BC ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:0000D0BC ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:0000D0BC                 push    ebp
.text$di:0000D0BD                 mov     ebp, esp
.text$di:0000D0BF                 mov     ecx, offset _ignore ; this
.text$di:0000D0C4                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:0000D0C9                 pop     ebp
.text$di:0000D0CA                 retn
.text$di:0000D0CA ??__Eignore@std@@YAXXZ endp
.text$di:0000D0CA
.text$di:0000D0CA ; ---------------------------------------------------------------------------
.text$di:0000D0CB                 align 4
.text$di:0000D0CB _text$di        ends
.text$di:0000D0CB
.text$di:0000D0CC ; ===========================================================================
.text$di:0000D0CC
.text$di:0000D0CC ; Segment type: Pure code
.text$di:0000D0CC ; Segment permissions: Read/Execute
.text$di:0000D0CC _text$di        segment para public 'CODE' use32
.text$di:0000D0CC                 assume cs:_text$di
.text$di:0000D0CC                 ;org 0D0CCh
.text$di:0000D0CC ; COMDAT (pick any)
.text$di:0000D0CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000D0CC
.text$di:0000D0CC ; =============== S U B R O U T I N E =======================================
.text$di:0000D0CC
.text$di:0000D0CC ; Attributes: bp-based frame
.text$di:0000D0CC
.text$di:0000D0CC ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:0000D0CC ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:0000D0CC                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:0000D0CC
.text$di:0000D0CC var_1           = byte ptr -1
.text$di:0000D0CC
.text$di:0000D0CC                 push    ebp
.text$di:0000D0CD                 mov     ebp, esp
.text$di:0000D0CF                 push    ecx
.text$di:0000D0D0                 xor     eax, eax
.text$di:0000D0D2                 mov     [ebp+var_1], al
.text$di:0000D0D5                 mov     esp, ebp
.text$di:0000D0D7                 pop     ebp
.text$di:0000D0D8                 retn
.text$di:0000D0D8 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:0000D0D8
.text$di:0000D0D8 ; ---------------------------------------------------------------------------
.text$di:0000D0D9                 align 4
.text$di:0000D0D9 _text$di        ends
.text$di:0000D0D9
.text$yd:0000D0DC ; ===========================================================================
.text$yd:0000D0DC
.text$yd:0000D0DC ; Segment type: Pure code
.text$yd:0000D0DC ; Segment permissions: Read/Execute
.text$yd:0000D0DC _text$yd        segment para public 'CODE' use32
.text$yd:0000D0DC                 assume cs:_text$yd
.text$yd:0000D0DC                 ;org 0D0DCh
.text$yd:0000D0DC ; COMDAT (pick any)
.text$yd:0000D0DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:0000D0DC
.text$yd:0000D0DC ; =============== S U B R O U T I N E =======================================
.text$yd:0000D0DC
.text$yd:0000D0DC ; Attributes: bp-based frame
.text$yd:0000D0DC
.text$yd:0000D0DC ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:0000D0DC ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:0000D0DC                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:0000D0DC                 push    ebp
.text$yd:0000D0DD                 mov     ebp, esp
.text$yd:0000D0DF                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:0000D0E4                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:0000D0E9                 pop     ebp
.text$yd:0000D0EA                 retn
.text$yd:0000D0EA ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:0000D0EA
.text$yd:0000D0EA ; ---------------------------------------------------------------------------
.text$yd:0000D0EB                 align 4
.text$yd:0000D0EB _text$yd        ends
.text$yd:0000D0EB
.text$yd:0000D0EC ; ===========================================================================
.text$yd:0000D0EC
.text$yd:0000D0EC ; Segment type: Pure code
.text$yd:0000D0EC ; Segment permissions: Read/Execute
.text$yd:0000D0EC _text$yd        segment para public 'CODE' use32
.text$yd:0000D0EC                 assume cs:_text$yd
.text$yd:0000D0EC                 ;org 0D0ECh
.text$yd:0000D0EC ; COMDAT (pick any)
.text$yd:0000D0EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:0000D0EC
.text$yd:0000D0EC ; =============== S U B R O U T I N E =======================================
.text$yd:0000D0EC
.text$yd:0000D0EC ; Attributes: bp-based frame
.text$yd:0000D0EC
.text$yd:0000D0EC ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:0000D0EC ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:0000D0EC                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:0000D0EC                 push    ebp
.text$yd:0000D0ED                 mov     ebp, esp
.text$yd:0000D0EF                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:0000D0F4                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:0000D0F9                 pop     ebp
.text$yd:0000D0FA                 retn
.text$yd:0000D0FA ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:0000D0FA
.text$yd:0000D0FA ; ---------------------------------------------------------------------------
.text$yd:0000D0FB                 align 4
.text$yd:0000D0FB _text$yd        ends
.text$yd:0000D0FB
.text$yd:0000D0FC ; ===========================================================================
.text$yd:0000D0FC
.text$yd:0000D0FC ; Segment type: Pure code
.text$yd:0000D0FC ; Segment permissions: Read/Execute
.text$yd:0000D0FC _text$yd        segment para public 'CODE' use32
.text$yd:0000D0FC                 assume cs:_text$yd
.text$yd:0000D0FC                 ;org 0D0FCh
.text$yd:0000D0FC ; COMDAT (pick any)
.text$yd:0000D0FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:0000D0FC
.text$yd:0000D0FC ; =============== S U B R O U T I N E =======================================
.text$yd:0000D0FC
.text$yd:0000D0FC ; Attributes: bp-based frame
.text$yd:0000D0FC
.text$yd:0000D0FC ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:0000D0FC ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:0000D0FC                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:0000D0FC                 push    ebp
.text$yd:0000D0FD                 mov     ebp, esp
.text$yd:0000D0FF                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:0000D104                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:0000D109                 pop     ebp
.text$yd:0000D10A                 retn
.text$yd:0000D10A ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:0000D10A
.text$yd:0000D10A ; ---------------------------------------------------------------------------
.text$yd:0000D10B                 align 4
.text$yd:0000D10B _text$yd        ends
.text$yd:0000D10B
.text$mn:0000D10C ; ===========================================================================
.text$mn:0000D10C
.text$mn:0000D10C ; Segment type: Pure code
.text$mn:0000D10C ; Segment permissions: Read/Execute
.text$mn:0000D10C _text$mn        segment para public 'CODE' use32
.text$mn:0000D10C                 assume cs:_text$mn
.text$mn:0000D10C                 ;org 0D10Ch
.text$mn:0000D10C ; COMDAT (pick any)
.text$mn:0000D10C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D10C
.text$mn:0000D10C ; =============== S U B R O U T I N E =======================================
.text$mn:0000D10C
.text$mn:0000D10C ; Attributes: bp-based frame
.text$mn:0000D10C
.text$mn:0000D10C ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:0000D10C                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:0000D10C ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:0000D10C                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)+3Cp
.text$mn:0000D10C                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+45p ...
.text$mn:0000D10C
.text$mn:0000D10C var_1C          = byte ptr -1Ch
.text$mn:0000D10C var_18          = byte ptr -18h
.text$mn:0000D10C var_14          = dword ptr -14h
.text$mn:0000D10C var_10          = dword ptr -10h
.text$mn:0000D10C var_C           = dword ptr -0Ch
.text$mn:0000D10C var_4           = dword ptr -4
.text$mn:0000D10C arg_0           = dword ptr  8
.text$mn:0000D10C
.text$mn:0000D10C                 push    ebp
.text$mn:0000D10D                 mov     ebp, esp
.text$mn:0000D10F                 push    0FFFFFFFFh
.text$mn:0000D111                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:0000D116                 mov     eax, large fs:0
.text$mn:0000D11C                 push    eax
.text$mn:0000D11D                 sub     esp, 10h
.text$mn:0000D120                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000D125                 xor     eax, ebp
.text$mn:0000D127                 push    eax
.text$mn:0000D128                 lea     eax, [ebp+var_C]
.text$mn:0000D12B                 mov     large fs:0, eax
.text$mn:0000D131                 mov     [ebp+var_10], ecx
.text$mn:0000D134                 cmp     [ebp+arg_0], 0
.text$mn:0000D138                 jnz     short loc_D164
.text$mn:0000D13A                 push    3               ; int
.text$mn:0000D13C                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000D13F                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000D144                 mov     [ebp+var_4], 0
.text$mn:0000D14B                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000D14E                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:0000D153                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000D15A                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000D15D                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000D162                 jmp     short loc_D1BB
.text$mn:0000D164 ; ---------------------------------------------------------------------------
.text$mn:0000D164
.text$mn:0000D164 loc_D164:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:0000D164                 mov     eax, [ebp+arg_0]
.text$mn:0000D167                 mov     ecx, [eax]
.text$mn:0000D169                 mov     [ebp+var_14], ecx
.text$mn:0000D16C                 mov     edx, [ebp+var_10]
.text$mn:0000D16F                 mov     eax, [edx]
.text$mn:0000D171                 cmp     eax, [ebp+var_14]
.text$mn:0000D174                 jz      short loc_D1BB
.text$mn:0000D176                 push    3               ; int
.text$mn:0000D178                 lea     ecx, [ebp+var_1C] ; this
.text$mn:0000D17B                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000D180                 mov     [ebp+var_4], 1
.text$mn:0000D187                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000D18A                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:0000D18F                 mov     ecx, [ebp+var_10]
.text$mn:0000D192                 mov     edx, [ebp+var_14]
.text$mn:0000D195                 mov     eax, [edx+4]
.text$mn:0000D198                 mov     [ecx+4], eax
.text$mn:0000D19B                 mov     ecx, [ebp+var_14]
.text$mn:0000D19E                 mov     edx, [ebp+var_10]
.text$mn:0000D1A1                 mov     [ecx+4], edx
.text$mn:0000D1A4                 mov     eax, [ebp+var_10]
.text$mn:0000D1A7                 mov     ecx, [ebp+var_14]
.text$mn:0000D1AA                 mov     [eax], ecx
.text$mn:0000D1AC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000D1B3                 lea     ecx, [ebp+var_1C] ; this
.text$mn:0000D1B6                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000D1BB
.text$mn:0000D1BB loc_D1BB:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:0000D1BB                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:0000D1BB                 mov     ecx, [ebp+var_C]
.text$mn:0000D1BE                 mov     large fs:0, ecx
.text$mn:0000D1C5                 pop     ecx
.text$mn:0000D1C6                 mov     esp, ebp
.text$mn:0000D1C8                 pop     ebp
.text$mn:0000D1C9                 retn    4
.text$mn:0000D1C9 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:0000D1C9
.text$mn:0000D1C9 _text$mn        ends
.text$mn:0000D1C9
.text$x:0000D1CC ; ===========================================================================
.text$x:0000D1CC
.text$x:0000D1CC ; Segment type: Pure code
.text$x:0000D1CC ; Segment permissions: Read/Execute
.text$x:0000D1CC _text$x         segment para public 'CODE' use32
.text$x:0000D1CC                 assume cs:_text$x
.text$x:0000D1CC                 ;org 0D1CCh
.text$x:0000D1CC ; COMDAT (pick associative to section at D10C)
.text$x:0000D1CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000D1CC
.text$x:0000D1CC ; =============== S U B R O U T I N E =======================================
.text$x:0000D1CC
.text$x:0000D1CC
.text$x:0000D1CC __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:0000D1CC                                         ; DATA XREF: .xdata$x:000123F4o
.text$x:0000D1CC                 lea     ecx, [ebp-18h]  ; this
.text$x:0000D1CF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000D1CF __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:0000D1CF
.text$x:0000D1D4
.text$x:0000D1D4 ; =============== S U B R O U T I N E =======================================
.text$x:0000D1D4
.text$x:0000D1D4
.text$x:0000D1D4 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:0000D1D4                                         ; DATA XREF: .xdata$x:000123FCo
.text$x:0000D1D4                 lea     ecx, [ebp-1Ch]  ; this
.text$x:0000D1D7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000D1D7 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:0000D1D7
.text$x:0000D1DC
.text$x:0000D1DC ; =============== S U B R O U T I N E =======================================
.text$x:0000D1DC
.text$x:0000D1DC
.text$x:0000D1DC __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:0000D1DC                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:0000D1DC
.text$x:0000D1DC arg_4           = dword ptr  8
.text$x:0000D1DC
.text$x:0000D1DC                 mov     edx, [esp+arg_4]
.text$x:0000D1E0                 lea     eax, [edx+0Ch]
.text$x:0000D1E3                 mov     ecx, [edx-14h]
.text$x:0000D1E6                 xor     ecx, eax
.text$x:0000D1E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000D1ED                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:0000D1F2                 jmp     ___CxxFrameHandler3
.text$x:0000D1F2 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:0000D1F2
.text$x:0000D1F2 ; ---------------------------------------------------------------------------
.text$x:0000D1F7                 align 4
.text$x:0000D1F7 _text$x         ends
.text$x:0000D1F7
.text$mn:0000D1F8 ; ===========================================================================
.text$mn:0000D1F8
.text$mn:0000D1F8 ; Segment type: Pure code
.text$mn:0000D1F8 ; Segment permissions: Read/Execute
.text$mn:0000D1F8 _text$mn        segment para public 'CODE' use32
.text$mn:0000D1F8                 assume cs:_text$mn
.text$mn:0000D1F8                 ;org 0D1F8h
.text$mn:0000D1F8 ; COMDAT (pick any)
.text$mn:0000D1F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D1F8
.text$mn:0000D1F8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D1F8
.text$mn:0000D1F8 ; Attributes: bp-based frame
.text$mn:0000D1F8
.text$mn:0000D1F8 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:0000D1F8                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:0000D1F8 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000D1F8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:0000D1F8
.text$mn:0000D1F8 var_10          = byte ptr -10h
.text$mn:0000D1F8 var_8           = dword ptr -8
.text$mn:0000D1F8 var_1           = byte ptr -1
.text$mn:0000D1F8
.text$mn:0000D1F8                 push    ebp
.text$mn:0000D1F9                 mov     ebp, esp
.text$mn:0000D1FB                 sub     esp, 10h
.text$mn:0000D1FE                 mov     [ebp+var_8], ecx
.text$mn:0000D201                 lea     ecx, [ebp+var_1]
.text$mn:0000D204                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000D209                 push    1
.text$mn:0000D20B                 lea     ecx, [ebp+var_1]
.text$mn:0000D20E                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:0000D213                 mov     ecx, [ebp+var_8]
.text$mn:0000D216                 mov     [ecx], eax
.text$mn:0000D218                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000D21B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:0000D220                 push    eax             ; int
.text$mn:0000D221                 mov     edx, [ebp+var_8]
.text$mn:0000D224                 mov     eax, [edx]
.text$mn:0000D226                 push    eax             ; void *
.text$mn:0000D227                 lea     ecx, [ebp+var_1]
.text$mn:0000D22A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000D22F                 mov     ecx, [ebp+var_8]
.text$mn:0000D232                 mov     edx, [ecx]
.text$mn:0000D234                 mov     eax, [ebp+var_8]
.text$mn:0000D237                 mov     [edx], eax
.text$mn:0000D239                 mov     esp, ebp
.text$mn:0000D23B                 pop     ebp
.text$mn:0000D23C                 retn
.text$mn:0000D23C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000D23C
.text$mn:0000D23C ; ---------------------------------------------------------------------------
.text$mn:0000D23D                 align 10h
.text$mn:0000D23D _text$mn        ends
.text$mn:0000D23D
.text$mn:0000D240 ; ===========================================================================
.text$mn:0000D240
.text$mn:0000D240 ; Segment type: Pure code
.text$mn:0000D240 ; Segment permissions: Read/Execute
.text$mn:0000D240 _text$mn        segment para public 'CODE' use32
.text$mn:0000D240                 assume cs:_text$mn
.text$mn:0000D240                 ;org 0D240h
.text$mn:0000D240 ; COMDAT (pick any)
.text$mn:0000D240                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D240
.text$mn:0000D240 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D240
.text$mn:0000D240 ; Attributes: bp-based frame
.text$mn:0000D240
.text$mn:0000D240 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:0000D240                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:0000D240 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000D240                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:0000D240
.text$mn:0000D240 var_10          = byte ptr -10h
.text$mn:0000D240 var_8           = dword ptr -8
.text$mn:0000D240 var_1           = byte ptr -1
.text$mn:0000D240
.text$mn:0000D240                 push    ebp
.text$mn:0000D241                 mov     ebp, esp
.text$mn:0000D243                 sub     esp, 10h
.text$mn:0000D246                 mov     [ebp+var_8], ecx
.text$mn:0000D249                 lea     ecx, [ebp+var_1]
.text$mn:0000D24C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000D251                 push    1
.text$mn:0000D253                 lea     ecx, [ebp+var_1]
.text$mn:0000D256                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:0000D25B                 mov     ecx, [ebp+var_8]
.text$mn:0000D25E                 mov     [ecx], eax
.text$mn:0000D260                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000D263                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:0000D268                 push    eax             ; int
.text$mn:0000D269                 mov     edx, [ebp+var_8]
.text$mn:0000D26C                 mov     eax, [edx]
.text$mn:0000D26E                 push    eax             ; void *
.text$mn:0000D26F                 lea     ecx, [ebp+var_1]
.text$mn:0000D272                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000D277                 mov     ecx, [ebp+var_8]
.text$mn:0000D27A                 mov     edx, [ecx]
.text$mn:0000D27C                 mov     eax, [ebp+var_8]
.text$mn:0000D27F                 mov     [edx], eax
.text$mn:0000D281                 mov     esp, ebp
.text$mn:0000D283                 pop     ebp
.text$mn:0000D284                 retn
.text$mn:0000D284 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000D284
.text$mn:0000D284 ; ---------------------------------------------------------------------------
.text$mn:0000D285                 align 4
.text$mn:0000D285 _text$mn        ends
.text$mn:0000D285
.text$mn:0000D288 ; ===========================================================================
.text$mn:0000D288
.text$mn:0000D288 ; Segment type: Pure code
.text$mn:0000D288 ; Segment permissions: Read/Execute
.text$mn:0000D288 _text$mn        segment para public 'CODE' use32
.text$mn:0000D288                 assume cs:_text$mn
.text$mn:0000D288                 ;org 0D288h
.text$mn:0000D288 ; COMDAT (pick any)
.text$mn:0000D288                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D288
.text$mn:0000D288 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D288
.text$mn:0000D288 ; Attributes: bp-based frame
.text$mn:0000D288
.text$mn:0000D288 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::_Alloc_proxy(void)
.text$mn:0000D288                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ
.text$mn:0000D288 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000D288                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(std::allocator<int> const &)+38p
.text$mn:0000D288
.text$mn:0000D288 var_10          = byte ptr -10h
.text$mn:0000D288 var_8           = dword ptr -8
.text$mn:0000D288 var_1           = byte ptr -1
.text$mn:0000D288
.text$mn:0000D288                 push    ebp
.text$mn:0000D289                 mov     ebp, esp
.text$mn:0000D28B                 sub     esp, 10h
.text$mn:0000D28E                 mov     [ebp+var_8], ecx
.text$mn:0000D291                 lea     ecx, [ebp+var_1]
.text$mn:0000D294                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:0000D299                 push    1
.text$mn:0000D29B                 lea     ecx, [ebp+var_1]
.text$mn:0000D29E                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:0000D2A3                 mov     ecx, [ebp+var_8]
.text$mn:0000D2A6                 mov     [ecx], eax
.text$mn:0000D2A8                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000D2AB                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:0000D2B0                 push    eax             ; int
.text$mn:0000D2B1                 mov     edx, [ebp+var_8]
.text$mn:0000D2B4                 mov     eax, [edx]
.text$mn:0000D2B6                 push    eax             ; void *
.text$mn:0000D2B7                 lea     ecx, [ebp+var_1]
.text$mn:0000D2BA                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000D2BF                 mov     ecx, [ebp+var_8]
.text$mn:0000D2C2                 mov     edx, [ecx]
.text$mn:0000D2C4                 mov     eax, [ebp+var_8]
.text$mn:0000D2C7                 mov     [edx], eax
.text$mn:0000D2C9                 mov     esp, ebp
.text$mn:0000D2CB                 pop     ebp
.text$mn:0000D2CC                 retn
.text$mn:0000D2CC ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000D2CC
.text$mn:0000D2CC ; ---------------------------------------------------------------------------
.text$mn:0000D2CD                 align 10h
.text$mn:0000D2CD _text$mn        ends
.text$mn:0000D2CD
.text$mn:0000D2D0 ; ===========================================================================
.text$mn:0000D2D0
.text$mn:0000D2D0 ; Segment type: Pure code
.text$mn:0000D2D0 ; Segment permissions: Read/Execute
.text$mn:0000D2D0 _text$mn        segment para public 'CODE' use32
.text$mn:0000D2D0                 assume cs:_text$mn
.text$mn:0000D2D0                 ;org 0D2D0h
.text$mn:0000D2D0 ; COMDAT (pick any)
.text$mn:0000D2D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D2D0
.text$mn:0000D2D0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D2D0
.text$mn:0000D2D0 ; Attributes: bp-based frame
.text$mn:0000D2D0
.text$mn:0000D2D0 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned int, class std::allocator<unsigned int>>>::_Alloc_proxy(void)
.text$mn:0000D2D0                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ
.text$mn:0000D2D0 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000D2D0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(std::allocator<uint> const &)+38p
.text$mn:0000D2D0
.text$mn:0000D2D0 var_10          = byte ptr -10h
.text$mn:0000D2D0 var_8           = dword ptr -8
.text$mn:0000D2D0 var_1           = byte ptr -1
.text$mn:0000D2D0
.text$mn:0000D2D0                 push    ebp
.text$mn:0000D2D1                 mov     ebp, esp
.text$mn:0000D2D3                 sub     esp, 10h
.text$mn:0000D2D6                 mov     [ebp+var_8], ecx
.text$mn:0000D2D9                 lea     ecx, [ebp+var_1]
.text$mn:0000D2DC                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:0000D2E1                 push    1
.text$mn:0000D2E3                 lea     ecx, [ebp+var_1]
.text$mn:0000D2E6                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:0000D2EB                 mov     ecx, [ebp+var_8]
.text$mn:0000D2EE                 mov     [ecx], eax
.text$mn:0000D2F0                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000D2F3                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:0000D2F8                 push    eax             ; int
.text$mn:0000D2F9                 mov     edx, [ebp+var_8]
.text$mn:0000D2FC                 mov     eax, [edx]
.text$mn:0000D2FE                 push    eax             ; void *
.text$mn:0000D2FF                 lea     ecx, [ebp+var_1]
.text$mn:0000D302                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000D307                 mov     ecx, [ebp+var_8]
.text$mn:0000D30A                 mov     edx, [ecx]
.text$mn:0000D30C                 mov     eax, [ebp+var_8]
.text$mn:0000D30F                 mov     [edx], eax
.text$mn:0000D311                 mov     esp, ebp
.text$mn:0000D313                 pop     ebp
.text$mn:0000D314                 retn
.text$mn:0000D314 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000D314
.text$mn:0000D314 ; ---------------------------------------------------------------------------
.text$mn:0000D315                 align 4
.text$mn:0000D315 _text$mn        ends
.text$mn:0000D315
.text$mn:0000D318 ; ===========================================================================
.text$mn:0000D318
.text$mn:0000D318 ; Segment type: Pure code
.text$mn:0000D318 ; Segment permissions: Read/Execute
.text$mn:0000D318 _text$mn        segment para public 'CODE' use32
.text$mn:0000D318                 assume cs:_text$mn
.text$mn:0000D318                 ;org 0D318h
.text$mn:0000D318 ; COMDAT (pick any)
.text$mn:0000D318                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D318
.text$mn:0000D318 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D318
.text$mn:0000D318 ; Attributes: bp-based frame
.text$mn:0000D318
.text$mn:0000D318 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>>::_Alloc_proxy(void)
.text$mn:0000D318                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAEXXZ
.text$mn:0000D318 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000D318                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>(std::allocator<sessionFileInfo> const &)+38p
.text$mn:0000D318
.text$mn:0000D318 var_10          = byte ptr -10h
.text$mn:0000D318 var_8           = dword ptr -8
.text$mn:0000D318 var_1           = byte ptr -1
.text$mn:0000D318
.text$mn:0000D318                 push    ebp
.text$mn:0000D319                 mov     ebp, esp
.text$mn:0000D31B                 sub     esp, 10h
.text$mn:0000D31E                 mov     [ebp+var_8], ecx
.text$mn:0000D321                 lea     ecx, [ebp+var_1]
.text$mn:0000D324                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:0000D329                 push    1
.text$mn:0000D32B                 lea     ecx, [ebp+var_1]
.text$mn:0000D32E                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:0000D333                 mov     ecx, [ebp+var_8]
.text$mn:0000D336                 mov     [ecx], eax
.text$mn:0000D338                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000D33B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:0000D340                 push    eax             ; int
.text$mn:0000D341                 mov     edx, [ebp+var_8]
.text$mn:0000D344                 mov     eax, [edx]
.text$mn:0000D346                 push    eax             ; void *
.text$mn:0000D347                 lea     ecx, [ebp+var_1]
.text$mn:0000D34A                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000D34F                 mov     ecx, [ebp+var_8]
.text$mn:0000D352                 mov     edx, [ecx]
.text$mn:0000D354                 mov     eax, [ebp+var_8]
.text$mn:0000D357                 mov     [edx], eax
.text$mn:0000D359                 mov     esp, ebp
.text$mn:0000D35B                 pop     ebp
.text$mn:0000D35C                 retn
.text$mn:0000D35C ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000D35C
.text$mn:0000D35C ; ---------------------------------------------------------------------------
.text$mn:0000D35D                 align 10h
.text$mn:0000D35D _text$mn        ends
.text$mn:0000D35D
.text$mn:0000D360 ; ===========================================================================
.text$mn:0000D360
.text$mn:0000D360 ; Segment type: Pure code
.text$mn:0000D360 ; Segment permissions: Read/Execute
.text$mn:0000D360 _text$mn        segment para public 'CODE' use32
.text$mn:0000D360                 assume cs:_text$mn
.text$mn:0000D360                 ;org 0D360h
.text$mn:0000D360 ; COMDAT (pick any)
.text$mn:0000D360                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D360
.text$mn:0000D360 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D360
.text$mn:0000D360 ; Attributes: bp-based frame
.text$mn:0000D360
.text$mn:0000D360 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>::_Alloc_proxy(void)
.text$mn:0000D360                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ
.text$mn:0000D360 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ proc near
.text$mn:0000D360                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)+38p
.text$mn:0000D360
.text$mn:0000D360 var_10          = byte ptr -10h
.text$mn:0000D360 var_8           = dword ptr -8
.text$mn:0000D360 var_1           = byte ptr -1
.text$mn:0000D360
.text$mn:0000D360                 push    ebp
.text$mn:0000D361                 mov     ebp, esp
.text$mn:0000D363                 sub     esp, 10h
.text$mn:0000D366                 mov     [ebp+var_8], ecx
.text$mn:0000D369                 lea     ecx, [ebp+var_1]
.text$mn:0000D36C                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:0000D371                 push    1
.text$mn:0000D373                 lea     ecx, [ebp+var_1]
.text$mn:0000D376                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:0000D37B                 mov     ecx, [ebp+var_8]
.text$mn:0000D37E                 mov     [ecx], eax
.text$mn:0000D380                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000D383                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:0000D388                 push    eax             ; int
.text$mn:0000D389                 mov     edx, [ebp+var_8]
.text$mn:0000D38C                 mov     eax, [edx]
.text$mn:0000D38E                 push    eax             ; void *
.text$mn:0000D38F                 lea     ecx, [ebp+var_1]
.text$mn:0000D392                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000D397                 mov     ecx, [ebp+var_8]
.text$mn:0000D39A                 mov     edx, [ecx]
.text$mn:0000D39C                 mov     eax, [ebp+var_8]
.text$mn:0000D39F                 mov     [edx], eax
.text$mn:0000D3A1                 mov     esp, ebp
.text$mn:0000D3A3                 pop     ebp
.text$mn:0000D3A4                 retn
.text$mn:0000D3A4 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ endp
.text$mn:0000D3A4
.text$mn:0000D3A4 ; ---------------------------------------------------------------------------
.text$mn:0000D3A5                 align 4
.text$mn:0000D3A5 _text$mn        ends
.text$mn:0000D3A5
.text$mn:0000D3A8 ; ===========================================================================
.text$mn:0000D3A8
.text$mn:0000D3A8 ; Segment type: Pure code
.text$mn:0000D3A8 ; Segment permissions: Read/Execute
.text$mn:0000D3A8 _text$mn        segment para public 'CODE' use32
.text$mn:0000D3A8                 assume cs:_text$mn
.text$mn:0000D3A8                 ;org 0D3A8h
.text$mn:0000D3A8 ; COMDAT (pick any)
.text$mn:0000D3A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D3A8
.text$mn:0000D3A8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D3A8
.text$mn:0000D3A8 ; Attributes: bp-based frame
.text$mn:0000D3A8
.text$mn:0000D3A8 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Assign_rv(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &&)
.text$mn:0000D3A8                 public ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z
.text$mn:0000D3A8 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z proc near
.text$mn:0000D3A8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+60p
.text$mn:0000D3A8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+E2p
.text$mn:0000D3A8
.text$mn:0000D3A8 var_8           = dword ptr -8
.text$mn:0000D3A8 var_1           = byte ptr -1
.text$mn:0000D3A8 arg_0           = dword ptr  8
.text$mn:0000D3A8
.text$mn:0000D3A8                 push    ebp
.text$mn:0000D3A9                 mov     ebp, esp
.text$mn:0000D3AB                 sub     esp, 8
.text$mn:0000D3AE                 mov     [ebp+var_8], ecx
.text$mn:0000D3B1                 mov     eax, [ebp+arg_0]
.text$mn:0000D3B4                 cmp     dword ptr [eax+18h], 8
.text$mn:0000D3B8                 jnb     short loc_D3DC
.text$mn:0000D3BA                 mov     ecx, [ebp+arg_0]
.text$mn:0000D3BD                 mov     edx, [ecx+14h]
.text$mn:0000D3C0                 add     edx, 1
.text$mn:0000D3C3                 push    edx             ; int
.text$mn:0000D3C4                 mov     eax, [ebp+arg_0]
.text$mn:0000D3C7                 add     eax, 4
.text$mn:0000D3CA                 push    eax             ; Src
.text$mn:0000D3CB                 mov     ecx, [ebp+var_8]
.text$mn:0000D3CE                 add     ecx, 4
.text$mn:0000D3D1                 push    ecx             ; Dst
.text$mn:0000D3D2                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000D3D7                 add     esp, 0Ch
.text$mn:0000D3DA                 jmp     short loc_D407
.text$mn:0000D3DC ; ---------------------------------------------------------------------------
.text$mn:0000D3DC
.text$mn:0000D3DC loc_D3DC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+10j
.text$mn:0000D3DC                 mov     edx, [ebp+arg_0]
.text$mn:0000D3DF                 add     edx, 4
.text$mn:0000D3E2                 push    edx             ; int
.text$mn:0000D3E3                 mov     eax, [ebp+var_8]
.text$mn:0000D3E6                 add     eax, 4
.text$mn:0000D3E9                 push    eax             ; void *
.text$mn:0000D3EA                 lea     ecx, [ebp+var_1]
.text$mn:0000D3ED                 push    ecx
.text$mn:0000D3EE                 mov     ecx, [ebp+var_8]
.text$mn:0000D3F1                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000D3F6                 mov     ecx, eax
.text$mn:0000D3F8                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:0000D3FD                 mov     edx, [ebp+arg_0]
.text$mn:0000D400                 mov     dword ptr [edx+4], 0
.text$mn:0000D407
.text$mn:0000D407 loc_D407:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+32j
.text$mn:0000D407                 mov     eax, [ebp+var_8]
.text$mn:0000D40A                 mov     ecx, [ebp+arg_0]
.text$mn:0000D40D                 mov     edx, [ecx+14h]
.text$mn:0000D410                 mov     [eax+14h], edx
.text$mn:0000D413                 mov     eax, [ebp+var_8]
.text$mn:0000D416                 mov     ecx, [ebp+arg_0]
.text$mn:0000D419                 mov     edx, [ecx+18h]
.text$mn:0000D41C                 mov     [eax+18h], edx
.text$mn:0000D41F                 push    0
.text$mn:0000D421                 push    0
.text$mn:0000D423                 mov     ecx, [ebp+arg_0]
.text$mn:0000D426                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000D42B                 mov     esp, ebp
.text$mn:0000D42D                 pop     ebp
.text$mn:0000D42E                 retn    4
.text$mn:0000D42E ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z endp
.text$mn:0000D42E
.text$mn:0000D42E ; ---------------------------------------------------------------------------
.text$mn:0000D431                 align 4
.text$mn:0000D431 _text$mn        ends
.text$mn:0000D431
.text$mn:0000D434 ; ===========================================================================
.text$mn:0000D434
.text$mn:0000D434 ; Segment type: Pure code
.text$mn:0000D434 ; Segment permissions: Read/Execute
.text$mn:0000D434 _text$mn        segment para public 'CODE' use32
.text$mn:0000D434                 assume cs:_text$mn
.text$mn:0000D434                 ;org 0D434h
.text$mn:0000D434 ; COMDAT (pick any)
.text$mn:0000D434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D434
.text$mn:0000D434 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D434
.text$mn:0000D434 ; Attributes: bp-based frame
.text$mn:0000D434
.text$mn:0000D434 ; protected: bool __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::_Buy(unsigned int)
.text$mn:0000D434                 public ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z
.text$mn:0000D434 ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z proc near
.text$mn:0000D434                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(std::vector<uint,std::allocator<uint>> const &)+62p
.text$mn:0000D434                                         ; std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+1CCp
.text$mn:0000D434
.text$mn:0000D434 var_8           = dword ptr -8
.text$mn:0000D434 var_1           = byte ptr -1
.text$mn:0000D434 arg_0           = dword ptr  8
.text$mn:0000D434
.text$mn:0000D434                 push    ebp
.text$mn:0000D435                 mov     ebp, esp
.text$mn:0000D437                 sub     esp, 8
.text$mn:0000D43A                 mov     [ebp+var_8], ecx
.text$mn:0000D43D                 mov     eax, [ebp+var_8]
.text$mn:0000D440                 mov     dword ptr [eax+4], 0
.text$mn:0000D447                 mov     ecx, [ebp+var_8]
.text$mn:0000D44A                 mov     dword ptr [ecx+8], 0
.text$mn:0000D451                 mov     edx, [ebp+var_8]
.text$mn:0000D454                 mov     dword ptr [edx+0Ch], 0
.text$mn:0000D45B                 cmp     [ebp+arg_0], 0
.text$mn:0000D45F                 jnz     short loc_D467
.text$mn:0000D461                 xor     al, al
.text$mn:0000D463                 jmp     short loc_D4BB
.text$mn:0000D465 ; ---------------------------------------------------------------------------
.text$mn:0000D465                 jmp     short loc_D4B9
.text$mn:0000D467 ; ---------------------------------------------------------------------------
.text$mn:0000D467
.text$mn:0000D467 loc_D467:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Buy(uint)+2Bj
.text$mn:0000D467                 mov     ecx, [ebp+var_8]
.text$mn:0000D46A                 call    ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<uint,std::allocator<uint>>::max_size(void)
.text$mn:0000D46F                 cmp     eax, [ebp+arg_0]
.text$mn:0000D472                 jnb     short loc_D47E
.text$mn:0000D474                 mov     ecx, [ebp+var_8]
.text$mn:0000D477                 call    ?_Xlen@?$vector@IV?$allocator@I@std@@@std@@IBEXXZ ; std::vector<uint,std::allocator<uint>>::_Xlen(void)
.text$mn:0000D47C                 jmp     short loc_D4B9
.text$mn:0000D47E ; ---------------------------------------------------------------------------
.text$mn:0000D47E
.text$mn:0000D47E loc_D47E:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Buy(uint)+3Ej
.text$mn:0000D47E                 mov     eax, [ebp+arg_0]
.text$mn:0000D481                 push    eax
.text$mn:0000D482                 lea     ecx, [ebp+var_1]
.text$mn:0000D485                 push    ecx
.text$mn:0000D486                 mov     ecx, [ebp+var_8]
.text$mn:0000D489                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000D48E                 mov     ecx, eax
.text$mn:0000D490                 call    ?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z ; std::_Wrap_alloc<std::allocator<uint>>::allocate(uint)
.text$mn:0000D495                 mov     edx, [ebp+var_8]
.text$mn:0000D498                 mov     [edx+4], eax
.text$mn:0000D49B                 mov     eax, [ebp+var_8]
.text$mn:0000D49E                 mov     ecx, [ebp+var_8]
.text$mn:0000D4A1                 mov     edx, [ecx+4]
.text$mn:0000D4A4                 mov     [eax+8], edx
.text$mn:0000D4A7                 mov     eax, [ebp+var_8]
.text$mn:0000D4AA                 mov     ecx, [eax+4]
.text$mn:0000D4AD                 mov     edx, [ebp+arg_0]
.text$mn:0000D4B0                 lea     eax, [ecx+edx*4]
.text$mn:0000D4B3                 mov     ecx, [ebp+var_8]
.text$mn:0000D4B6                 mov     [ecx+0Ch], eax
.text$mn:0000D4B9
.text$mn:0000D4B9 loc_D4B9:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Buy(uint)+31j
.text$mn:0000D4B9                                         ; std::vector<uint,std::allocator<uint>>::_Buy(uint)+48j
.text$mn:0000D4B9                 mov     al, 1
.text$mn:0000D4BB
.text$mn:0000D4BB loc_D4BB:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Buy(uint)+2Fj
.text$mn:0000D4BB                 mov     esp, ebp
.text$mn:0000D4BD                 pop     ebp
.text$mn:0000D4BE                 retn    4
.text$mn:0000D4BE ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z endp
.text$mn:0000D4BE
.text$mn:0000D4BE ; ---------------------------------------------------------------------------
.text$mn:0000D4C1                 align 4
.text$mn:0000D4C1 _text$mn        ends
.text$mn:0000D4C1
.text$mn:0000D4C4 ; ===========================================================================
.text$mn:0000D4C4
.text$mn:0000D4C4 ; Segment type: Pure code
.text$mn:0000D4C4 ; Segment permissions: Read/Execute
.text$mn:0000D4C4 _text$mn        segment para public 'CODE' use32
.text$mn:0000D4C4                 assume cs:_text$mn
.text$mn:0000D4C4                 ;org 0D4C4h
.text$mn:0000D4C4 ; COMDAT (pick any)
.text$mn:0000D4C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D4C4
.text$mn:0000D4C4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D4C4
.text$mn:0000D4C4 ; Attributes: bp-based frame
.text$mn:0000D4C4
.text$mn:0000D4C4 ; protected: bool __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::_Buy(unsigned int)
.text$mn:0000D4C4                 public ?_Buy@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAE_NI@Z
.text$mn:0000D4C4 ?_Buy@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAE_NI@Z proc near
.text$mn:0000D4C4                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(std::vector<sessionFileInfo,std::allocator<sessionFileInfo>> const &)+62p
.text$mn:0000D4C4
.text$mn:0000D4C4 var_8           = dword ptr -8
.text$mn:0000D4C4 var_1           = byte ptr -1
.text$mn:0000D4C4 arg_0           = dword ptr  8
.text$mn:0000D4C4
.text$mn:0000D4C4                 push    ebp
.text$mn:0000D4C5                 mov     ebp, esp
.text$mn:0000D4C7                 sub     esp, 8
.text$mn:0000D4CA                 mov     [ebp+var_8], ecx
.text$mn:0000D4CD                 mov     eax, [ebp+var_8]
.text$mn:0000D4D0                 mov     dword ptr [eax+4], 0
.text$mn:0000D4D7                 mov     ecx, [ebp+var_8]
.text$mn:0000D4DA                 mov     dword ptr [ecx+8], 0
.text$mn:0000D4E1                 mov     edx, [ebp+var_8]
.text$mn:0000D4E4                 mov     dword ptr [edx+0Ch], 0
.text$mn:0000D4EB                 cmp     [ebp+arg_0], 0
.text$mn:0000D4EF                 jnz     short loc_D4F7
.text$mn:0000D4F1                 xor     al, al
.text$mn:0000D4F3                 jmp     short loc_D54C
.text$mn:0000D4F5 ; ---------------------------------------------------------------------------
.text$mn:0000D4F5                 jmp     short loc_D54A
.text$mn:0000D4F7 ; ---------------------------------------------------------------------------
.text$mn:0000D4F7
.text$mn:0000D4F7 loc_D4F7:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Buy(uint)+2Bj
.text$mn:0000D4F7                 mov     ecx, [ebp+var_8]
.text$mn:0000D4FA                 call    ?max_size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::max_size(void)
.text$mn:0000D4FF                 cmp     eax, [ebp+arg_0]
.text$mn:0000D502                 jnb     short loc_D50E
.text$mn:0000D504                 mov     ecx, [ebp+var_8]
.text$mn:0000D507                 call    ?_Xlen@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Xlen(void)
.text$mn:0000D50C                 jmp     short loc_D54A
.text$mn:0000D50E ; ---------------------------------------------------------------------------
.text$mn:0000D50E
.text$mn:0000D50E loc_D50E:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Buy(uint)+3Ej
.text$mn:0000D50E                 mov     eax, [ebp+arg_0]
.text$mn:0000D511                 push    eax
.text$mn:0000D512                 lea     ecx, [ebp+var_1]
.text$mn:0000D515                 push    ecx
.text$mn:0000D516                 mov     ecx, [ebp+var_8]
.text$mn:0000D519                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Getal(void)
.text$mn:0000D51E                 mov     ecx, eax
.text$mn:0000D520                 call    ?allocate@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEPAUsessionFileInfo@@I@Z ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::allocate(uint)
.text$mn:0000D525                 mov     edx, [ebp+var_8]
.text$mn:0000D528                 mov     [edx+4], eax
.text$mn:0000D52B                 mov     eax, [ebp+var_8]
.text$mn:0000D52E                 mov     ecx, [ebp+var_8]
.text$mn:0000D531                 mov     edx, [ecx+4]
.text$mn:0000D534                 mov     [eax+8], edx
.text$mn:0000D537                 imul    eax, [ebp+arg_0], 98h
.text$mn:0000D53E                 mov     ecx, [ebp+var_8]
.text$mn:0000D541                 add     eax, [ecx+4]
.text$mn:0000D544                 mov     edx, [ebp+var_8]
.text$mn:0000D547                 mov     [edx+0Ch], eax
.text$mn:0000D54A
.text$mn:0000D54A loc_D54A:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Buy(uint)+31j
.text$mn:0000D54A                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Buy(uint)+48j
.text$mn:0000D54A                 mov     al, 1
.text$mn:0000D54C
.text$mn:0000D54C loc_D54C:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Buy(uint)+2Fj
.text$mn:0000D54C                 mov     esp, ebp
.text$mn:0000D54E                 pop     ebp
.text$mn:0000D54F                 retn    4
.text$mn:0000D54F ?_Buy@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAE_NI@Z endp
.text$mn:0000D54F
.text$mn:0000D54F ; ---------------------------------------------------------------------------
.text$mn:0000D552                 align 4
.text$mn:0000D552 _text$mn        ends
.text$mn:0000D552
.text$mn:0000D554 ; ===========================================================================
.text$mn:0000D554
.text$mn:0000D554 ; Segment type: Pure code
.text$mn:0000D554 ; Segment permissions: Read/Execute
.text$mn:0000D554 _text$mn        segment para public 'CODE' use32
.text$mn:0000D554                 assume cs:_text$mn
.text$mn:0000D554                 ;org 0D554h
.text$mn:0000D554 ; COMDAT (pick any)
.text$mn:0000D554                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D554
.text$mn:0000D554 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D554
.text$mn:0000D554 ; Attributes: bp-based frame
.text$mn:0000D554
.text$mn:0000D554 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Change_alloc(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:0000D554                 public ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
.text$mn:0000D554 ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z proc near
.text$mn:0000D554                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+54p
.text$mn:0000D554                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Ap
.text$mn:0000D554
.text$mn:0000D554 var_4           = dword ptr -4
.text$mn:0000D554
.text$mn:0000D554                 push    ebp
.text$mn:0000D555                 mov     ebp, esp
.text$mn:0000D557                 push    ecx
.text$mn:0000D558                 mov     [ebp+var_4], ecx
.text$mn:0000D55B                 mov     esp, ebp
.text$mn:0000D55D                 pop     ebp
.text$mn:0000D55E                 retn    4
.text$mn:0000D55E ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z endp
.text$mn:0000D55E
.text$mn:0000D55E ; ---------------------------------------------------------------------------
.text$mn:0000D561                 align 4
.text$mn:0000D561 _text$mn        ends
.text$mn:0000D561
.text$mn:0000D564 ; ===========================================================================
.text$mn:0000D564
.text$mn:0000D564 ; Segment type: Pure code
.text$mn:0000D564 ; Segment permissions: Read/Execute
.text$mn:0000D564 _text$mn        segment para public 'CODE' use32
.text$mn:0000D564                 assume cs:_text$mn
.text$mn:0000D564                 ;org 0D564h
.text$mn:0000D564 ; COMDAT (pick any)
.text$mn:0000D564                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D564
.text$mn:0000D564 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D564
.text$mn:0000D564 ; Attributes: bp-based frame
.text$mn:0000D564
.text$mn:0000D564 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned int, class std::allocator<unsigned int>>>::_Change_alloc(struct std::_Wrap_alloc<class std::allocator<unsigned int>> const &)
.text$mn:0000D564                 public ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@I@std@@@2@@Z
.text$mn:0000D564 ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@I@std@@@2@@Z proc near
.text$mn:0000D564                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+80p
.text$mn:0000D564
.text$mn:0000D564 var_4           = dword ptr -4
.text$mn:0000D564
.text$mn:0000D564                 push    ebp
.text$mn:0000D565                 mov     ebp, esp
.text$mn:0000D567                 push    ecx
.text$mn:0000D568                 mov     [ebp+var_4], ecx
.text$mn:0000D56B                 mov     esp, ebp
.text$mn:0000D56D                 pop     ebp
.text$mn:0000D56E                 retn    4
.text$mn:0000D56E ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@I@std@@@2@@Z endp
.text$mn:0000D56E
.text$mn:0000D56E ; ---------------------------------------------------------------------------
.text$mn:0000D571                 align 4
.text$mn:0000D571 _text$mn        ends
.text$mn:0000D571
.text$mn:0000D574 ; ===========================================================================
.text$mn:0000D574
.text$mn:0000D574 ; Segment type: Pure code
.text$mn:0000D574 ; Segment permissions: Read/Execute
.text$mn:0000D574 _text$mn        segment para public 'CODE' use32
.text$mn:0000D574                 assume cs:_text$mn
.text$mn:0000D574                 ;org 0D574h
.text$mn:0000D574 ; COMDAT (pick any)
.text$mn:0000D574                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D574
.text$mn:0000D574 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D574
.text$mn:0000D574 ; Attributes: bp-based frame
.text$mn:0000D574
.text$mn:0000D574 ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:0000D574                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:0000D574 ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:0000D574                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+80p
.text$mn:0000D574                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Orphan_range(sessionFileInfo *,sessionFileInfo *)+80p ...
.text$mn:0000D574
.text$mn:0000D574 var_4           = dword ptr -4
.text$mn:0000D574
.text$mn:0000D574                 push    ebp
.text$mn:0000D575                 mov     ebp, esp
.text$mn:0000D577                 push    ecx
.text$mn:0000D578                 mov     [ebp+var_4], ecx
.text$mn:0000D57B                 mov     eax, [ebp+var_4]
.text$mn:0000D57E                 mov     dword ptr [eax], 0
.text$mn:0000D584                 mov     esp, ebp
.text$mn:0000D586                 pop     ebp
.text$mn:0000D587                 retn
.text$mn:0000D587 ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:0000D587
.text$mn:0000D587 _text$mn        ends
.text$mn:0000D587
.text$mn:0000D588 ; ===========================================================================
.text$mn:0000D588
.text$mn:0000D588 ; Segment type: Pure code
.text$mn:0000D588 ; Segment permissions: Read/Execute
.text$mn:0000D588 _text$mn        segment para public 'CODE' use32
.text$mn:0000D588                 assume cs:_text$mn
.text$mn:0000D588                 ;org 0D588h
.text$mn:0000D588 ; COMDAT (pick any)
.text$mn:0000D588                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D588
.text$mn:0000D588 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D588
.text$mn:0000D588 ; Attributes: bp-based frame
.text$mn:0000D588
.text$mn:0000D588 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Iterator_base12 *)
.text$mn:0000D588                 public ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z
.text$mn:0000D588 ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z proc near
.text$mn:0000D588                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+10p
.text$mn:0000D588                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+Ep
.text$mn:0000D588
.text$mn:0000D588 var_4           = dword ptr -4
.text$mn:0000D588 arg_0           = dword ptr  8
.text$mn:0000D588
.text$mn:0000D588                 push    ebp
.text$mn:0000D589                 mov     ebp, esp
.text$mn:0000D58B                 push    ecx
.text$mn:0000D58C                 push    esi
.text$mn:0000D58D                 mov     [ebp+var_4], ecx
.text$mn:0000D590                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000D593                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000D598                 test    eax, eax
.text$mn:0000D59A                 jz      short loc_D5B2
.text$mn:0000D59C                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000D59F                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000D5A4                 mov     esi, eax
.text$mn:0000D5A6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000D5A9                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000D5AE                 cmp     esi, eax
.text$mn:0000D5B0                 jz      short loc_D61A
.text$mn:0000D5B2
.text$mn:0000D5B2 loc_D5B2:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+12j
.text$mn:0000D5B2                 push    0FAh ; '·'      ; unsigned int
.text$mn:0000D5B7                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000D5BC                 push    offset ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; "string iterators incompatible"
.text$mn:0000D5C1                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000D5C6                 add     esp, 0Ch
.text$mn:0000D5C9                 mov     eax, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
.text$mn:0000D5CE                 test    eax, eax
.text$mn:0000D5D0                 jz      short loc_D5D6
.text$mn:0000D5D2                 xor     ecx, ecx
.text$mn:0000D5D4                 jnz     short loc_D5FC
.text$mn:0000D5D6
.text$mn:0000D5D6 loc_D5D6:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+48j
.text$mn:0000D5D6                 push    offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
.text$mn:0000D5DB                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000D5E0                 push    0
.text$mn:0000D5E2                 push    0FBh ; 'v'
.text$mn:0000D5E7                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000D5EC                 push    2
.text$mn:0000D5EE                 call    __CrtDbgReportW
.text$mn:0000D5F3                 add     esp, 18h
.text$mn:0000D5F6                 cmp     eax, 1
.text$mn:0000D5F9                 jnz     short loc_D5FC
.text$mn:0000D5FB                 int     3               ; Trap to Debugger
.text$mn:0000D5FC
.text$mn:0000D5FC loc_D5FC:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+4Cj
.text$mn:0000D5FC                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+71j
.text$mn:0000D5FC                 push    0
.text$mn:0000D5FE                 push    0FBh ; 'v'
.text$mn:0000D603                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000D608                 push    offset ??_C@_1MG@CLNEOJNJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_String_const_iterator<class std::"...
.text$mn:0000D60D                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:0000D612                 call    __invalid_parameter
.text$mn:0000D617                 add     esp, 14h
.text$mn:0000D61A
.text$mn:0000D61A loc_D61A:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+28j
.text$mn:0000D61A                 pop     esi
.text$mn:0000D61B                 mov     esp, ebp
.text$mn:0000D61D                 pop     ebp
.text$mn:0000D61E                 retn    4
.text$mn:0000D61E ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z endp
.text$mn:0000D61E
.text$mn:0000D61E ; ---------------------------------------------------------------------------
.text$mn:0000D621                 align 4
.text$mn:0000D621 _text$mn        ends
.text$mn:0000D621
.text$mn:0000D624 ; ===========================================================================
.text$mn:0000D624
.text$mn:0000D624 ; Segment type: Pure code
.text$mn:0000D624 ; Segment permissions: Read/Execute
.text$mn:0000D624 _text$mn        segment para public 'CODE' use32
.text$mn:0000D624                 assume cs:_text$mn
.text$mn:0000D624                 ;org 0D624h
.text$mn:0000D624 ; COMDAT (pick any)
.text$mn:0000D624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D624
.text$mn:0000D624 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D624
.text$mn:0000D624 ; Attributes: bp-based frame
.text$mn:0000D624
.text$mn:0000D624 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Iterator_base12 *)
.text$mn:0000D624                 public ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXABV12@@Z
.text$mn:0000D624 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXABV12@@Z proc near
.text$mn:0000D624                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+10p
.text$mn:0000D624
.text$mn:0000D624 var_4           = dword ptr -4
.text$mn:0000D624 arg_0           = dword ptr  8
.text$mn:0000D624
.text$mn:0000D624                 push    ebp
.text$mn:0000D625                 mov     ebp, esp
.text$mn:0000D627                 push    ecx
.text$mn:0000D628                 push    esi
.text$mn:0000D629                 mov     [ebp+var_4], ecx
.text$mn:0000D62C                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000D62F                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000D634                 test    eax, eax
.text$mn:0000D636                 jz      short loc_D64E
.text$mn:0000D638                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000D63B                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000D640                 mov     esi, eax
.text$mn:0000D642                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000D645                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000D64A                 cmp     esi, eax
.text$mn:0000D64C                 jz      short loc_D6B6
.text$mn:0000D64E
.text$mn:0000D64E loc_D64E:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+12j
.text$mn:0000D64E                 push    0F0h ; '='      ; unsigned int
.text$mn:0000D653                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000D658                 push    offset ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; "vector iterators incompatible"
.text$mn:0000D65D                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000D662                 add     esp, 0Ch
.text$mn:0000D665                 mov     eax, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
.text$mn:0000D66A                 test    eax, eax
.text$mn:0000D66C                 jz      short loc_D672
.text$mn:0000D66E                 xor     ecx, ecx
.text$mn:0000D670                 jnz     short loc_D698
.text$mn:0000D672
.text$mn:0000D672 loc_D672:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+48j
.text$mn:0000D672                 push    offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
.text$mn:0000D677                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000D67C                 push    0
.text$mn:0000D67E                 push    0F1h ; '±'
.text$mn:0000D683                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000D688                 push    2
.text$mn:0000D68A                 call    __CrtDbgReportW
.text$mn:0000D68F                 add     esp, 18h
.text$mn:0000D692                 cmp     eax, 1
.text$mn:0000D695                 jnz     short loc_D698
.text$mn:0000D697                 int     3               ; Trap to Debugger
.text$mn:0000D698
.text$mn:0000D698 loc_D698:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+4Cj
.text$mn:0000D698                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+71j
.text$mn:0000D698                 push    0
.text$mn:0000D69A                 push    0F1h ; '±'
.text$mn:0000D69F                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000D6A4                 push    offset ??_C@_1LO@MGELDLOO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:0000D6A9                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:0000D6AE                 call    __invalid_parameter
.text$mn:0000D6B3                 add     esp, 14h
.text$mn:0000D6B6
.text$mn:0000D6B6 loc_D6B6:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+28j
.text$mn:0000D6B6                 pop     esi
.text$mn:0000D6B7                 mov     esp, ebp
.text$mn:0000D6B9                 pop     ebp
.text$mn:0000D6BA                 retn    4
.text$mn:0000D6BA ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXABV12@@Z endp
.text$mn:0000D6BA
.text$mn:0000D6BA ; ---------------------------------------------------------------------------
.text$mn:0000D6BD                 align 10h
.text$mn:0000D6BD _text$mn        ends
.text$mn:0000D6BD
.text$mn:0000D6C0 ; ===========================================================================
.text$mn:0000D6C0
.text$mn:0000D6C0 ; Segment type: Pure code
.text$mn:0000D6C0 ; Segment permissions: Read/Execute
.text$mn:0000D6C0 _text$mn        segment para public 'CODE' use32
.text$mn:0000D6C0                 assume cs:_text$mn
.text$mn:0000D6C0                 ;org 0D6C0h
.text$mn:0000D6C0 ; COMDAT (pick any)
.text$mn:0000D6C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D6C0
.text$mn:0000D6C0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D6C0
.text$mn:0000D6C0 ; Attributes: bp-based frame
.text$mn:0000D6C0
.text$mn:0000D6C0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:0000D6C0                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000D6C0 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:0000D6C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:0000D6C0
.text$mn:0000D6C0 var_20          = dword ptr -20h
.text$mn:0000D6C0 var_1C          = dword ptr -1Ch
.text$mn:0000D6C0 var_18          = dword ptr -18h
.text$mn:0000D6C0 var_11          = byte ptr -11h
.text$mn:0000D6C0 var_10          = dword ptr -10h
.text$mn:0000D6C0 var_C           = byte ptr -0Ch
.text$mn:0000D6C0 var_4           = dword ptr -4
.text$mn:0000D6C0 arg_0           = dword ptr  8
.text$mn:0000D6C0
.text$mn:0000D6C0 ; FUNCTION CHUNK AT .text$mn:0000D7E2 SIZE 00000009 BYTES
.text$mn:0000D6C0
.text$mn:0000D6C0                 push    ebp
.text$mn:0000D6C1                 mov     ebp, esp
.text$mn:0000D6C3                 push    0FFFFFFFFh
.text$mn:0000D6C5                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000D6CA                 mov     eax, large fs:0
.text$mn:0000D6D0                 push    eax
.text$mn:0000D6D1                 push    ecx
.text$mn:0000D6D2                 sub     esp, 10h
.text$mn:0000D6D5                 push    ebx
.text$mn:0000D6D6                 push    esi
.text$mn:0000D6D7                 push    edi
.text$mn:0000D6D8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000D6DD                 xor     eax, ebp
.text$mn:0000D6DF                 push    eax
.text$mn:0000D6E0                 lea     eax, [ebp+var_C]
.text$mn:0000D6E3                 mov     large fs:0, eax
.text$mn:0000D6E9                 mov     [ebp+var_10], esp
.text$mn:0000D6EC                 mov     [ebp+var_18], ecx
.text$mn:0000D6EF                 mov     eax, [ebp+arg_0]
.text$mn:0000D6F2                 or      eax, 0Fh
.text$mn:0000D6F5                 mov     [ebp+var_1C], eax
.text$mn:0000D6F8                 mov     ecx, [ebp+var_18]
.text$mn:0000D6FB                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000D700                 cmp     eax, [ebp+var_1C]
.text$mn:0000D703                 jnb     short loc_D70D
.text$mn:0000D705                 mov     ecx, [ebp+arg_0]
.text$mn:0000D708                 mov     [ebp+var_1C], ecx
.text$mn:0000D70B                 jmp     short loc_D75F
.text$mn:0000D70D ; ---------------------------------------------------------------------------
.text$mn:0000D70D
.text$mn:0000D70D loc_D70D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:0000D70D                 mov     edx, [ebp+var_18]
.text$mn:0000D710                 mov     ecx, [edx+18h]
.text$mn:0000D713                 shr     ecx, 1
.text$mn:0000D715                 mov     eax, [ebp+var_1C]
.text$mn:0000D718                 xor     edx, edx
.text$mn:0000D71A                 mov     esi, 3
.text$mn:0000D71F                 div     esi
.text$mn:0000D721                 cmp     ecx, eax
.text$mn:0000D723                 ja      short loc_D727
.text$mn:0000D725                 jmp     short loc_D75F
.text$mn:0000D727 ; ---------------------------------------------------------------------------
.text$mn:0000D727
.text$mn:0000D727 loc_D727:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:0000D727                 mov     ecx, [ebp+var_18]
.text$mn:0000D72A                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000D72F                 mov     edx, [ebp+var_18]
.text$mn:0000D732                 mov     ecx, [edx+18h]
.text$mn:0000D735                 shr     ecx, 1
.text$mn:0000D737                 sub     eax, ecx
.text$mn:0000D739                 mov     edx, [ebp+var_18]
.text$mn:0000D73C                 cmp     [edx+18h], eax
.text$mn:0000D73F                 ja      short loc_D754
.text$mn:0000D741                 mov     eax, [ebp+var_18]
.text$mn:0000D744                 mov     ecx, [eax+18h]
.text$mn:0000D747                 shr     ecx, 1
.text$mn:0000D749                 mov     edx, [ebp+var_18]
.text$mn:0000D74C                 add     ecx, [edx+18h]
.text$mn:0000D74F                 mov     [ebp+var_1C], ecx
.text$mn:0000D752                 jmp     short loc_D75F
.text$mn:0000D754 ; ---------------------------------------------------------------------------
.text$mn:0000D754
.text$mn:0000D754 loc_D754:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:0000D754                 mov     ecx, [ebp+var_18]
.text$mn:0000D757                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000D75C                 mov     [ebp+var_1C], eax
.text$mn:0000D75F
.text$mn:0000D75F loc_D75F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:0000D75F                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:0000D75F                 mov     [ebp+var_4], 0
.text$mn:0000D766                 mov     eax, [ebp+var_1C]
.text$mn:0000D769                 add     eax, 1
.text$mn:0000D76C                 push    eax
.text$mn:0000D76D                 lea     ecx, [ebp+var_11]
.text$mn:0000D770                 push    ecx
.text$mn:0000D771                 mov     ecx, [ebp+var_18]
.text$mn:0000D774                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000D779                 mov     ecx, eax
.text$mn:0000D77B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:0000D780                 mov     [ebp+var_20], eax
.text$mn:0000D783                 jmp     short loc_D7E2
.text$mn:0000D783 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:0000D783
.text$mn:0000D785
.text$mn:0000D785 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D785
.text$mn:0000D785
.text$mn:0000D785 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:0000D785                                         ; DATA XREF: .xdata$x:00012538o
.text$mn:0000D785
.text$mn:0000D785 ; FUNCTION CHUNK AT .text$mn:0000D7CC SIZE 00000009 BYTES
.text$mn:0000D785 ; FUNCTION CHUNK AT .text$mn:0000D7DC SIZE 00000006 BYTES
.text$mn:0000D785
.text$mn:0000D785                 mov     [ebp-10h], esp
.text$mn:0000D788                 mov     edx, [ebp+8]
.text$mn:0000D78B                 mov     [ebp-1Ch], edx
.text$mn:0000D78E                 mov     byte ptr [ebp-4], 2
.text$mn:0000D792                 mov     eax, [ebp-1Ch]
.text$mn:0000D795                 add     eax, 1
.text$mn:0000D798                 push    eax
.text$mn:0000D799                 lea     ecx, [ebp-12h]
.text$mn:0000D79C                 push    ecx
.text$mn:0000D79D                 mov     ecx, [ebp-18h]
.text$mn:0000D7A0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000D7A5                 mov     ecx, eax
.text$mn:0000D7A7                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:0000D7AC                 mov     [ebp-20h], eax
.text$mn:0000D7AF                 jmp     short loc_D7CC
.text$mn:0000D7AF __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:0000D7AF
.text$mn:0000D7B1
.text$mn:0000D7B1 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D7B1
.text$mn:0000D7B1 ; Attributes: noreturn
.text$mn:0000D7B1
.text$mn:0000D7B1 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:0000D7B1                                         ; DATA XREF: .xdata$x:00012548o
.text$mn:0000D7B1                 push    0               ; Size
.text$mn:0000D7B3                 push    1               ; char
.text$mn:0000D7B5                 mov     ecx, [ebp-18h]
.text$mn:0000D7B8                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000D7BD                 push    0
.text$mn:0000D7BF                 push    0
.text$mn:0000D7C1                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000D7C1 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:0000D7C1
.text$mn:0000D7C6 ; ---------------------------------------------------------------------------
.text$mn:0000D7C6                 mov     eax, offset $LN17
.text$mn:0000D7CB                 retn
.text$mn:0000D7CC ; ---------------------------------------------------------------------------
.text$mn:0000D7CC ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000D7CC
.text$mn:0000D7CC loc_D7CC:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:0000D7CC                 mov     dword ptr [ebp-4], 1
.text$mn:0000D7D3                 jmp     short loc_D7DC
.text$mn:0000D7D3 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000D7D5
.text$mn:0000D7D5 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D7D5
.text$mn:0000D7D5
.text$mn:0000D7D5 $LN17           proc near               ; DATA XREF: .text$mn:0000D7C6o
.text$mn:0000D7D5                 mov     dword ptr [ebp-4], 1
.text$mn:0000D7D5 $LN17           endp ; sp-analysis failed
.text$mn:0000D7D5
.text$mn:0000D7DC ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000D7DC
.text$mn:0000D7DC loc_D7DC:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:0000D7DC                 mov     eax, offset $LN19
.text$mn:0000D7E1                 retn
.text$mn:0000D7E1 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000D7E2 ; ---------------------------------------------------------------------------
.text$mn:0000D7E2 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000D7E2
.text$mn:0000D7E2 loc_D7E2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:0000D7E2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000D7E9                 jmp     short loc_D7F2
.text$mn:0000D7E9 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000D7EB
.text$mn:0000D7EB ; =============== S U B R O U T I N E =======================================
.text$mn:0000D7EB
.text$mn:0000D7EB
.text$mn:0000D7EB $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_D7DCo
.text$mn:0000D7EB                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000D7F2
.text$mn:0000D7F2 loc_D7F2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:0000D7F2                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000D7F6                 jbe     short loc_D811
.text$mn:0000D7F8                 mov     edx, [ebp+0Ch]
.text$mn:0000D7FB                 push    edx             ; Size
.text$mn:0000D7FC                 mov     ecx, [ebp-18h]
.text$mn:0000D7FF                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000D804                 push    eax             ; Src
.text$mn:0000D805                 mov     eax, [ebp-20h]
.text$mn:0000D808                 push    eax             ; Dst
.text$mn:0000D809                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000D80E                 add     esp, 0Ch
.text$mn:0000D811
.text$mn:0000D811 loc_D811:                               ; CODE XREF: $LN19+Bj
.text$mn:0000D811                 push    0               ; Size
.text$mn:0000D813                 push    1               ; char
.text$mn:0000D815                 mov     ecx, [ebp-18h]
.text$mn:0000D818                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000D81D                 lea     ecx, [ebp-20h]
.text$mn:0000D820                 push    ecx             ; int
.text$mn:0000D821                 mov     edx, [ebp-18h]
.text$mn:0000D824                 add     edx, 4
.text$mn:0000D827                 push    edx             ; void *
.text$mn:0000D828                 lea     eax, [ebp-13h]
.text$mn:0000D82B                 push    eax
.text$mn:0000D82C                 mov     ecx, [ebp-18h]
.text$mn:0000D82F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000D834                 mov     ecx, eax
.text$mn:0000D836                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000D83B                 mov     ecx, [ebp-18h]
.text$mn:0000D83E                 mov     edx, [ebp-1Ch]
.text$mn:0000D841                 mov     [ecx+18h], edx
.text$mn:0000D844                 mov     eax, [ebp+0Ch]
.text$mn:0000D847                 push    eax
.text$mn:0000D848                 mov     ecx, [ebp-18h]
.text$mn:0000D84B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000D850                 mov     ecx, [ebp-0Ch]
.text$mn:0000D853                 mov     large fs:0, ecx
.text$mn:0000D85A                 pop     ecx
.text$mn:0000D85B                 pop     edi
.text$mn:0000D85C                 pop     esi
.text$mn:0000D85D                 pop     ebx
.text$mn:0000D85E                 mov     esp, ebp
.text$mn:0000D860                 pop     ebp
.text$mn:0000D861                 retn    8
.text$mn:0000D861 $LN19           endp ; sp-analysis failed
.text$mn:0000D861
.text$mn:0000D861 _text$mn        ends
.text$mn:0000D861
.text$x:0000D864 ; ===========================================================================
.text$x:0000D864
.text$x:0000D864 ; Segment type: Pure code
.text$x:0000D864 ; Segment permissions: Read/Execute
.text$x:0000D864 _text$x         segment para public 'CODE' use32
.text$x:0000D864                 assume cs:_text$x
.text$x:0000D864                 ;org 0D864h
.text$x:0000D864 ; COMDAT (pick associative to section at D6C0)
.text$x:0000D864                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000D864
.text$x:0000D864 ; =============== S U B R O U T I N E =======================================
.text$x:0000D864
.text$x:0000D864
.text$x:0000D864 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:0000D864                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:0000D864
.text$x:0000D864 arg_4           = dword ptr  8
.text$x:0000D864
.text$x:0000D864                 mov     edx, [esp+arg_4]
.text$x:0000D868                 lea     eax, [edx+0Ch]
.text$x:0000D86B                 mov     ecx, [edx-24h]
.text$x:0000D86E                 xor     ecx, eax
.text$x:0000D870                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000D875                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:0000D87A                 jmp     ___CxxFrameHandler3
.text$x:0000D87A __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:0000D87A
.text$x:0000D87A ; ---------------------------------------------------------------------------
.text$x:0000D87F                 align 10h
.text$x:0000D87F _text$x         ends
.text$x:0000D87F
.text$mn:0000D880 ; ===========================================================================
.text$mn:0000D880
.text$mn:0000D880 ; Segment type: Pure code
.text$mn:0000D880 ; Segment permissions: Read/Execute
.text$mn:0000D880 _text$mn        segment para public 'CODE' use32
.text$mn:0000D880                 assume cs:_text$mn
.text$mn:0000D880                 ;org 0D880h
.text$mn:0000D880 ; COMDAT (pick any)
.text$mn:0000D880                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D880
.text$mn:0000D880 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D880
.text$mn:0000D880 ; Attributes: bp-based frame
.text$mn:0000D880
.text$mn:0000D880 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:0000D880                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000D880 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:0000D880                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:0000D880
.text$mn:0000D880 var_20          = dword ptr -20h
.text$mn:0000D880 var_1C          = dword ptr -1Ch
.text$mn:0000D880 var_18          = dword ptr -18h
.text$mn:0000D880 var_11          = byte ptr -11h
.text$mn:0000D880 var_10          = dword ptr -10h
.text$mn:0000D880 var_C           = byte ptr -0Ch
.text$mn:0000D880 var_4           = dword ptr -4
.text$mn:0000D880 arg_0           = dword ptr  8
.text$mn:0000D880
.text$mn:0000D880 ; FUNCTION CHUNK AT .text$mn:0000D9A2 SIZE 00000009 BYTES
.text$mn:0000D880
.text$mn:0000D880                 push    ebp
.text$mn:0000D881                 mov     ebp, esp
.text$mn:0000D883                 push    0FFFFFFFFh
.text$mn:0000D885                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000D88A                 mov     eax, large fs:0
.text$mn:0000D890                 push    eax
.text$mn:0000D891                 push    ecx
.text$mn:0000D892                 sub     esp, 10h
.text$mn:0000D895                 push    ebx
.text$mn:0000D896                 push    esi
.text$mn:0000D897                 push    edi
.text$mn:0000D898                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000D89D                 xor     eax, ebp
.text$mn:0000D89F                 push    eax
.text$mn:0000D8A0                 lea     eax, [ebp+var_C]
.text$mn:0000D8A3                 mov     large fs:0, eax
.text$mn:0000D8A9                 mov     [ebp+var_10], esp
.text$mn:0000D8AC                 mov     [ebp+var_18], ecx
.text$mn:0000D8AF                 mov     eax, [ebp+arg_0]
.text$mn:0000D8B2                 or      eax, 7
.text$mn:0000D8B5                 mov     [ebp+var_1C], eax
.text$mn:0000D8B8                 mov     ecx, [ebp+var_18]
.text$mn:0000D8BB                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:0000D8C0                 cmp     eax, [ebp+var_1C]
.text$mn:0000D8C3                 jnb     short loc_D8CD
.text$mn:0000D8C5                 mov     ecx, [ebp+arg_0]
.text$mn:0000D8C8                 mov     [ebp+var_1C], ecx
.text$mn:0000D8CB                 jmp     short loc_D91F
.text$mn:0000D8CD ; ---------------------------------------------------------------------------
.text$mn:0000D8CD
.text$mn:0000D8CD loc_D8CD:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:0000D8CD                 mov     edx, [ebp+var_18]
.text$mn:0000D8D0                 mov     ecx, [edx+18h]
.text$mn:0000D8D3                 shr     ecx, 1
.text$mn:0000D8D5                 mov     eax, [ebp+var_1C]
.text$mn:0000D8D8                 xor     edx, edx
.text$mn:0000D8DA                 mov     esi, 3
.text$mn:0000D8DF                 div     esi
.text$mn:0000D8E1                 cmp     ecx, eax
.text$mn:0000D8E3                 ja      short loc_D8E7
.text$mn:0000D8E5                 jmp     short loc_D91F
.text$mn:0000D8E7 ; ---------------------------------------------------------------------------
.text$mn:0000D8E7
.text$mn:0000D8E7 loc_D8E7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:0000D8E7                 mov     ecx, [ebp+var_18]
.text$mn:0000D8EA                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:0000D8EF                 mov     edx, [ebp+var_18]
.text$mn:0000D8F2                 mov     ecx, [edx+18h]
.text$mn:0000D8F5                 shr     ecx, 1
.text$mn:0000D8F7                 sub     eax, ecx
.text$mn:0000D8F9                 mov     edx, [ebp+var_18]
.text$mn:0000D8FC                 cmp     [edx+18h], eax
.text$mn:0000D8FF                 ja      short loc_D914
.text$mn:0000D901                 mov     eax, [ebp+var_18]
.text$mn:0000D904                 mov     ecx, [eax+18h]
.text$mn:0000D907                 shr     ecx, 1
.text$mn:0000D909                 mov     edx, [ebp+var_18]
.text$mn:0000D90C                 add     ecx, [edx+18h]
.text$mn:0000D90F                 mov     [ebp+var_1C], ecx
.text$mn:0000D912                 jmp     short loc_D91F
.text$mn:0000D914 ; ---------------------------------------------------------------------------
.text$mn:0000D914
.text$mn:0000D914 loc_D914:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:0000D914                 mov     ecx, [ebp+var_18]
.text$mn:0000D917                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:0000D91C                 mov     [ebp+var_1C], eax
.text$mn:0000D91F
.text$mn:0000D91F loc_D91F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:0000D91F                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:0000D91F                 mov     [ebp+var_4], 0
.text$mn:0000D926                 mov     eax, [ebp+var_1C]
.text$mn:0000D929                 add     eax, 1
.text$mn:0000D92C                 push    eax
.text$mn:0000D92D                 lea     ecx, [ebp+var_11]
.text$mn:0000D930                 push    ecx
.text$mn:0000D931                 mov     ecx, [ebp+var_18]
.text$mn:0000D934                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000D939                 mov     ecx, eax
.text$mn:0000D93B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:0000D940                 mov     [ebp+var_20], eax
.text$mn:0000D943                 jmp     short loc_D9A2
.text$mn:0000D943 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:0000D943
.text$mn:0000D945
.text$mn:0000D945 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D945
.text$mn:0000D945
.text$mn:0000D945 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:0000D945                                         ; DATA XREF: .xdata$x:00012A80o
.text$mn:0000D945
.text$mn:0000D945 ; FUNCTION CHUNK AT .text$mn:0000D98C SIZE 00000009 BYTES
.text$mn:0000D945 ; FUNCTION CHUNK AT .text$mn:0000D99C SIZE 00000006 BYTES
.text$mn:0000D945
.text$mn:0000D945                 mov     [ebp-10h], esp
.text$mn:0000D948                 mov     edx, [ebp+8]
.text$mn:0000D94B                 mov     [ebp-1Ch], edx
.text$mn:0000D94E                 mov     byte ptr [ebp-4], 2
.text$mn:0000D952                 mov     eax, [ebp-1Ch]
.text$mn:0000D955                 add     eax, 1
.text$mn:0000D958                 push    eax
.text$mn:0000D959                 lea     ecx, [ebp-12h]
.text$mn:0000D95C                 push    ecx
.text$mn:0000D95D                 mov     ecx, [ebp-18h]
.text$mn:0000D960                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000D965                 mov     ecx, eax
.text$mn:0000D967                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:0000D96C                 mov     [ebp-20h], eax
.text$mn:0000D96F                 jmp     short loc_D98C
.text$mn:0000D96F __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:0000D96F
.text$mn:0000D971
.text$mn:0000D971 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D971
.text$mn:0000D971 ; Attributes: noreturn
.text$mn:0000D971
.text$mn:0000D971 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:0000D971                                         ; DATA XREF: .xdata$x:00012A90o
.text$mn:0000D971                 push    0
.text$mn:0000D973                 push    1
.text$mn:0000D975                 mov     ecx, [ebp-18h]
.text$mn:0000D978                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000D97D                 push    0
.text$mn:0000D97F                 push    0
.text$mn:0000D981                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000D981 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:0000D981
.text$mn:0000D986 ; ---------------------------------------------------------------------------
.text$mn:0000D986                 mov     eax, offset $LN17_0
.text$mn:0000D98B                 retn
.text$mn:0000D98C ; ---------------------------------------------------------------------------
.text$mn:0000D98C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000D98C
.text$mn:0000D98C loc_D98C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:0000D98C                 mov     dword ptr [ebp-4], 1
.text$mn:0000D993                 jmp     short loc_D99C
.text$mn:0000D993 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000D995
.text$mn:0000D995 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D995
.text$mn:0000D995
.text$mn:0000D995 $LN17_0         proc near               ; DATA XREF: .text$mn:0000D986o
.text$mn:0000D995                 mov     dword ptr [ebp-4], 1
.text$mn:0000D995 $LN17_0         endp ; sp-analysis failed
.text$mn:0000D995
.text$mn:0000D99C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000D99C
.text$mn:0000D99C loc_D99C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:0000D99C                 mov     eax, offset $LN19_0
.text$mn:0000D9A1                 retn
.text$mn:0000D9A1 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000D9A2 ; ---------------------------------------------------------------------------
.text$mn:0000D9A2 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000D9A2
.text$mn:0000D9A2 loc_D9A2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:0000D9A2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000D9A9                 jmp     short loc_D9B2
.text$mn:0000D9A9 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000D9AB
.text$mn:0000D9AB ; =============== S U B R O U T I N E =======================================
.text$mn:0000D9AB
.text$mn:0000D9AB
.text$mn:0000D9AB $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_D99Co
.text$mn:0000D9AB                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000D9B2
.text$mn:0000D9B2 loc_D9B2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:0000D9B2                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000D9B6                 jbe     short loc_D9D1
.text$mn:0000D9B8                 mov     edx, [ebp+0Ch]
.text$mn:0000D9BB                 push    edx             ; int
.text$mn:0000D9BC                 mov     ecx, [ebp-18h]
.text$mn:0000D9BF                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000D9C4                 push    eax             ; Src
.text$mn:0000D9C5                 mov     eax, [ebp-20h]
.text$mn:0000D9C8                 push    eax             ; Dst
.text$mn:0000D9C9                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000D9CE                 add     esp, 0Ch
.text$mn:0000D9D1
.text$mn:0000D9D1 loc_D9D1:                               ; CODE XREF: $LN19_0+Bj
.text$mn:0000D9D1                 push    0
.text$mn:0000D9D3                 push    1
.text$mn:0000D9D5                 mov     ecx, [ebp-18h]
.text$mn:0000D9D8                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000D9DD                 lea     ecx, [ebp-20h]
.text$mn:0000D9E0                 push    ecx             ; int
.text$mn:0000D9E1                 mov     edx, [ebp-18h]
.text$mn:0000D9E4                 add     edx, 4
.text$mn:0000D9E7                 push    edx             ; void *
.text$mn:0000D9E8                 lea     eax, [ebp-13h]
.text$mn:0000D9EB                 push    eax
.text$mn:0000D9EC                 mov     ecx, [ebp-18h]
.text$mn:0000D9EF                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000D9F4                 mov     ecx, eax
.text$mn:0000D9F6                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:0000D9FB                 mov     ecx, [ebp-18h]
.text$mn:0000D9FE                 mov     edx, [ebp-1Ch]
.text$mn:0000DA01                 mov     [ecx+18h], edx
.text$mn:0000DA04                 mov     eax, [ebp+0Ch]
.text$mn:0000DA07                 push    eax
.text$mn:0000DA08                 mov     ecx, [ebp-18h]
.text$mn:0000DA0B                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000DA10                 mov     ecx, [ebp-0Ch]
.text$mn:0000DA13                 mov     large fs:0, ecx
.text$mn:0000DA1A                 pop     ecx
.text$mn:0000DA1B                 pop     edi
.text$mn:0000DA1C                 pop     esi
.text$mn:0000DA1D                 pop     ebx
.text$mn:0000DA1E                 mov     esp, ebp
.text$mn:0000DA20                 pop     ebp
.text$mn:0000DA21                 retn    8
.text$mn:0000DA21 $LN19_0         endp ; sp-analysis failed
.text$mn:0000DA21
.text$mn:0000DA21 _text$mn        ends
.text$mn:0000DA21
.text$x:0000DA24 ; ===========================================================================
.text$x:0000DA24
.text$x:0000DA24 ; Segment type: Pure code
.text$x:0000DA24 ; Segment permissions: Read/Execute
.text$x:0000DA24 _text$x         segment para public 'CODE' use32
.text$x:0000DA24                 assume cs:_text$x
.text$x:0000DA24                 ;org 0DA24h
.text$x:0000DA24 ; COMDAT (pick associative to section at D880)
.text$x:0000DA24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000DA24
.text$x:0000DA24 ; =============== S U B R O U T I N E =======================================
.text$x:0000DA24
.text$x:0000DA24
.text$x:0000DA24 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:0000DA24                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:0000DA24
.text$x:0000DA24 arg_4           = dword ptr  8
.text$x:0000DA24
.text$x:0000DA24                 mov     edx, [esp+arg_4]
.text$x:0000DA28                 lea     eax, [edx+0Ch]
.text$x:0000DA2B                 mov     ecx, [edx-24h]
.text$x:0000DA2E                 xor     ecx, eax
.text$x:0000DA30                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000DA35                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:0000DA3A                 jmp     ___CxxFrameHandler3
.text$x:0000DA3A __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:0000DA3A
.text$x:0000DA3A ; ---------------------------------------------------------------------------
.text$x:0000DA3F                 align 10h
.text$x:0000DA3F _text$x         ends
.text$x:0000DA3F
.text$mn:0000DA40 ; ===========================================================================
.text$mn:0000DA40
.text$mn:0000DA40 ; Segment type: Pure code
.text$mn:0000DA40 ; Segment permissions: Read/Execute
.text$mn:0000DA40 _text$mn        segment para public 'CODE' use32
.text$mn:0000DA40                 assume cs:_text$mn
.text$mn:0000DA40                 ;org 0DA40h
.text$mn:0000DA40 ; COMDAT (pick any)
.text$mn:0000DA40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DA40
.text$mn:0000DA40 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DA40
.text$mn:0000DA40 ; Attributes: bp-based frame
.text$mn:0000DA40
.text$mn:0000DA40 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Destroy(int *, int *)
.text$mn:0000DA40                 public ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
.text$mn:0000DA40 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z proc near
.text$mn:0000DA40                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+CBp
.text$mn:0000DA40                                         ; std::vector<int,std::allocator<int>>::_Tidy(void)+2Bp
.text$mn:0000DA40
.text$mn:0000DA40 var_8           = dword ptr -8
.text$mn:0000DA40 var_1           = byte ptr -1
.text$mn:0000DA40 arg_0           = dword ptr  8
.text$mn:0000DA40 arg_4           = dword ptr  0Ch
.text$mn:0000DA40
.text$mn:0000DA40                 push    ebp
.text$mn:0000DA41                 mov     ebp, esp
.text$mn:0000DA43                 sub     esp, 8
.text$mn:0000DA46                 mov     [ebp+var_8], ecx
.text$mn:0000DA49                 lea     eax, [ebp+var_1]
.text$mn:0000DA4C                 push    eax
.text$mn:0000DA4D                 mov     ecx, [ebp+var_8]
.text$mn:0000DA50                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:0000DA55                 lea     ecx, [ebp+var_1]
.text$mn:0000DA58                 push    ecx
.text$mn:0000DA59                 mov     edx, [ebp+arg_4]
.text$mn:0000DA5C                 push    edx
.text$mn:0000DA5D                 mov     eax, [ebp+arg_0]
.text$mn:0000DA60                 push    eax
.text$mn:0000DA61                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &)
.text$mn:0000DA66                 add     esp, 0Ch
.text$mn:0000DA69                 mov     esp, ebp
.text$mn:0000DA6B                 pop     ebp
.text$mn:0000DA6C                 retn    8
.text$mn:0000DA6C ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z endp
.text$mn:0000DA6C
.text$mn:0000DA6C ; ---------------------------------------------------------------------------
.text$mn:0000DA6F                 align 10h
.text$mn:0000DA6F _text$mn        ends
.text$mn:0000DA6F
.text$mn:0000DA70 ; ===========================================================================
.text$mn:0000DA70
.text$mn:0000DA70 ; Segment type: Pure code
.text$mn:0000DA70 ; Segment permissions: Read/Execute
.text$mn:0000DA70 _text$mn        segment para public 'CODE' use32
.text$mn:0000DA70                 assume cs:_text$mn
.text$mn:0000DA70                 ;org 0DA70h
.text$mn:0000DA70 ; COMDAT (pick any)
.text$mn:0000DA70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DA70
.text$mn:0000DA70 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DA70
.text$mn:0000DA70 ; Attributes: bp-based frame
.text$mn:0000DA70
.text$mn:0000DA70 ; protected: void __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::_Destroy(unsigned int *, unsigned int *)
.text$mn:0000DA70                 public ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z
.text$mn:0000DA70 ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z proc near
.text$mn:0000DA70                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+EDp
.text$mn:0000DA70                                         ; std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+191p ...
.text$mn:0000DA70
.text$mn:0000DA70 var_8           = dword ptr -8
.text$mn:0000DA70 var_1           = byte ptr -1
.text$mn:0000DA70 arg_0           = dword ptr  8
.text$mn:0000DA70 arg_4           = dword ptr  0Ch
.text$mn:0000DA70
.text$mn:0000DA70                 push    ebp
.text$mn:0000DA71                 mov     ebp, esp
.text$mn:0000DA73                 sub     esp, 8
.text$mn:0000DA76                 mov     [ebp+var_8], ecx
.text$mn:0000DA79                 lea     eax, [ebp+var_1]
.text$mn:0000DA7C                 push    eax
.text$mn:0000DA7D                 mov     ecx, [ebp+var_8]
.text$mn:0000DA80                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000DA85                 lea     ecx, [ebp+var_1]
.text$mn:0000DA88                 push    ecx
.text$mn:0000DA89                 mov     edx, [ebp+arg_4]
.text$mn:0000DA8C                 push    edx
.text$mn:0000DA8D                 mov     eax, [ebp+arg_0]
.text$mn:0000DA90                 push    eax
.text$mn:0000DA91                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<uint>>>(uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)
.text$mn:0000DA96                 add     esp, 0Ch
.text$mn:0000DA99                 mov     esp, ebp
.text$mn:0000DA9B                 pop     ebp
.text$mn:0000DA9C                 retn    8
.text$mn:0000DA9C ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z endp
.text$mn:0000DA9C
.text$mn:0000DA9C ; ---------------------------------------------------------------------------
.text$mn:0000DA9F                 align 10h
.text$mn:0000DA9F _text$mn        ends
.text$mn:0000DA9F
.text$mn:0000DAA0 ; ===========================================================================
.text$mn:0000DAA0
.text$mn:0000DAA0 ; Segment type: Pure code
.text$mn:0000DAA0 ; Segment permissions: Read/Execute
.text$mn:0000DAA0 _text$mn        segment para public 'CODE' use32
.text$mn:0000DAA0                 assume cs:_text$mn
.text$mn:0000DAA0                 ;org 0DAA0h
.text$mn:0000DAA0 ; COMDAT (pick any)
.text$mn:0000DAA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DAA0
.text$mn:0000DAA0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DAA0
.text$mn:0000DAA0 ; Attributes: bp-based frame
.text$mn:0000DAA0
.text$mn:0000DAA0 ; protected: void __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::_Destroy(struct sessionFileInfo *, struct sessionFileInfo *)
.text$mn:0000DAA0                 public ?_Destroy@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXPAUsessionFileInfo@@0@Z
.text$mn:0000DAA0 ?_Destroy@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXPAUsessionFileInfo@@0@Z proc near
.text$mn:0000DAA0                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reallocate(uint)+CBp
.text$mn:0000DAA0                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Tidy(void)+2Bp ...
.text$mn:0000DAA0
.text$mn:0000DAA0 var_8           = dword ptr -8
.text$mn:0000DAA0 var_1           = byte ptr -1
.text$mn:0000DAA0 arg_0           = dword ptr  8
.text$mn:0000DAA0 arg_4           = dword ptr  0Ch
.text$mn:0000DAA0
.text$mn:0000DAA0                 push    ebp
.text$mn:0000DAA1                 mov     ebp, esp
.text$mn:0000DAA3                 sub     esp, 8
.text$mn:0000DAA6                 mov     [ebp+var_8], ecx
.text$mn:0000DAA9                 lea     eax, [ebp+var_1]
.text$mn:0000DAAC                 push    eax
.text$mn:0000DAAD                 mov     ecx, [ebp+var_8]
.text$mn:0000DAB0                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Getal(void)
.text$mn:0000DAB5                 lea     ecx, [ebp+var_1]
.text$mn:0000DAB8                 push    ecx
.text$mn:0000DAB9                 mov     edx, [ebp+arg_4]
.text$mn:0000DABC                 push    edx
.text$mn:0000DABD                 mov     eax, [ebp+arg_0]
.text$mn:0000DAC0                 push    eax
.text$mn:0000DAC1                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@YAXPAUsessionFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<sessionFileInfo>>>(sessionFileInfo *,sessionFileInfo *,std::_Wrap_alloc<std::allocator<sessionFileInfo>> &)
.text$mn:0000DAC6                 add     esp, 0Ch
.text$mn:0000DAC9                 mov     esp, ebp
.text$mn:0000DACB                 pop     ebp
.text$mn:0000DACC                 retn    8
.text$mn:0000DACC ?_Destroy@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXPAUsessionFileInfo@@0@Z endp
.text$mn:0000DACC
.text$mn:0000DACC ; ---------------------------------------------------------------------------
.text$mn:0000DACF                 align 10h
.text$mn:0000DACF _text$mn        ends
.text$mn:0000DACF
.text$mn:0000DAD0 ; ===========================================================================
.text$mn:0000DAD0
.text$mn:0000DAD0 ; Segment type: Pure code
.text$mn:0000DAD0 ; Segment permissions: Read/Execute
.text$mn:0000DAD0 _text$mn        segment para public 'CODE' use32
.text$mn:0000DAD0                 assume cs:_text$mn
.text$mn:0000DAD0                 ;org 0DAD0h
.text$mn:0000DAD0 ; COMDAT (pick any)
.text$mn:0000DAD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DAD0
.text$mn:0000DAD0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DAD0
.text$mn:0000DAD0 ; Attributes: bp-based frame
.text$mn:0000DAD0
.text$mn:0000DAD0 ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Destroy(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:0000DAD0                 public ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.text$mn:0000DAD0 ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z proc near
.text$mn:0000DAD0                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+CBp
.text$mn:0000DAD0                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Tidy(void)+2Bp
.text$mn:0000DAD0
.text$mn:0000DAD0 var_8           = dword ptr -8
.text$mn:0000DAD0 var_1           = byte ptr -1
.text$mn:0000DAD0 arg_0           = dword ptr  8
.text$mn:0000DAD0 arg_4           = dword ptr  0Ch
.text$mn:0000DAD0
.text$mn:0000DAD0                 push    ebp
.text$mn:0000DAD1                 mov     ebp, esp
.text$mn:0000DAD3                 sub     esp, 8
.text$mn:0000DAD6                 mov     [ebp+var_8], ecx
.text$mn:0000DAD9                 lea     eax, [ebp+var_1]
.text$mn:0000DADC                 push    eax
.text$mn:0000DADD                 mov     ecx, [ebp+var_8]
.text$mn:0000DAE0                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000DAE5                 lea     ecx, [ebp+var_1]
.text$mn:0000DAE8                 push    ecx
.text$mn:0000DAE9                 mov     edx, [ebp+arg_4]
.text$mn:0000DAEC                 push    edx
.text$mn:0000DAED                 mov     eax, [ebp+arg_0]
.text$mn:0000DAF0                 push    eax
.text$mn:0000DAF1                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)
.text$mn:0000DAF6                 add     esp, 0Ch
.text$mn:0000DAF9                 mov     esp, ebp
.text$mn:0000DAFB                 pop     ebp
.text$mn:0000DAFC                 retn    8
.text$mn:0000DAFC ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z endp
.text$mn:0000DAFC
.text$mn:0000DAFC ; ---------------------------------------------------------------------------
.text$mn:0000DAFF                 align 10h
.text$mn:0000DAFF _text$mn        ends
.text$mn:0000DAFF
.text$mn:0000DB00 ; ===========================================================================
.text$mn:0000DB00
.text$mn:0000DB00 ; Segment type: Pure code
.text$mn:0000DB00 ; Segment permissions: Read/Execute
.text$mn:0000DB00 _text$mn        segment para public 'CODE' use32
.text$mn:0000DB00                 assume cs:_text$mn
.text$mn:0000DB00                 ;org 0DB00h
.text$mn:0000DB00 ; COMDAT (pick any)
.text$mn:0000DB00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DB00
.text$mn:0000DB00 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DB00
.text$mn:0000DB00 ; Attributes: bp-based frame
.text$mn:0000DB00
.text$mn:0000DB00 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:0000DB00                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:0000DB00 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:0000DB00                                         ; CODE XREF: $LN19+60p
.text$mn:0000DB00                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:0000DB00
.text$mn:0000DB00 var_8           = dword ptr -8
.text$mn:0000DB00 var_1           = byte ptr -1
.text$mn:0000DB00 arg_0           = dword ptr  8
.text$mn:0000DB00
.text$mn:0000DB00                 push    ebp
.text$mn:0000DB01                 mov     ebp, esp
.text$mn:0000DB03                 sub     esp, 8
.text$mn:0000DB06                 mov     [ebp+var_8], ecx
.text$mn:0000DB09                 mov     [ebp+var_1], 0
.text$mn:0000DB0D                 mov     eax, [ebp+var_8]
.text$mn:0000DB10                 mov     ecx, [ebp+arg_0]
.text$mn:0000DB13                 mov     [eax+14h], ecx
.text$mn:0000DB16                 lea     edx, [ebp+var_1]
.text$mn:0000DB19                 push    edx
.text$mn:0000DB1A                 mov     ecx, [ebp+var_8]
.text$mn:0000DB1D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000DB22                 add     eax, [ebp+arg_0]
.text$mn:0000DB25                 push    eax
.text$mn:0000DB26                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:0000DB2B                 add     esp, 8
.text$mn:0000DB2E                 mov     esp, ebp
.text$mn:0000DB30                 pop     ebp
.text$mn:0000DB31                 retn    4
.text$mn:0000DB31 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:0000DB31
.text$mn:0000DB31 _text$mn        ends
.text$mn:0000DB31
.text$mn:0000DB34 ; ===========================================================================
.text$mn:0000DB34
.text$mn:0000DB34 ; Segment type: Pure code
.text$mn:0000DB34 ; Segment permissions: Read/Execute
.text$mn:0000DB34 _text$mn        segment para public 'CODE' use32
.text$mn:0000DB34                 assume cs:_text$mn
.text$mn:0000DB34                 ;org 0DB34h
.text$mn:0000DB34 ; COMDAT (pick any)
.text$mn:0000DB34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DB34
.text$mn:0000DB34 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DB34
.text$mn:0000DB34 ; Attributes: bp-based frame
.text$mn:0000DB34
.text$mn:0000DB34 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:0000DB34                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:0000DB34 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:0000DB34                                         ; CODE XREF: $LN19_0+60p
.text$mn:0000DB34                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:0000DB34
.text$mn:0000DB34 var_8           = dword ptr -8
.text$mn:0000DB34 var_2           = word ptr -2
.text$mn:0000DB34 arg_0           = dword ptr  8
.text$mn:0000DB34
.text$mn:0000DB34                 push    ebp
.text$mn:0000DB35                 mov     ebp, esp
.text$mn:0000DB37                 sub     esp, 8
.text$mn:0000DB3A                 mov     [ebp+var_8], ecx
.text$mn:0000DB3D                 xor     eax, eax
.text$mn:0000DB3F                 mov     [ebp+var_2], ax
.text$mn:0000DB43                 mov     ecx, [ebp+var_8]
.text$mn:0000DB46                 mov     edx, [ebp+arg_0]
.text$mn:0000DB49                 mov     [ecx+14h], edx
.text$mn:0000DB4C                 lea     eax, [ebp+var_2]
.text$mn:0000DB4F                 push    eax
.text$mn:0000DB50                 mov     ecx, [ebp+var_8]
.text$mn:0000DB53                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000DB58                 mov     ecx, [ebp+arg_0]
.text$mn:0000DB5B                 lea     edx, [eax+ecx*2]
.text$mn:0000DB5E                 push    edx
.text$mn:0000DB5F                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:0000DB64                 add     esp, 8
.text$mn:0000DB67                 mov     esp, ebp
.text$mn:0000DB69                 pop     ebp
.text$mn:0000DB6A                 retn    4
.text$mn:0000DB6A ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:0000DB6A
.text$mn:0000DB6A ; ---------------------------------------------------------------------------
.text$mn:0000DB6D                 align 10h
.text$mn:0000DB6D _text$mn        ends
.text$mn:0000DB6D
.text$mn:0000DB70 ; ===========================================================================
.text$mn:0000DB70
.text$mn:0000DB70 ; Segment type: Pure code
.text$mn:0000DB70 ; Segment permissions: Read/Execute
.text$mn:0000DB70 _text$mn        segment para public 'CODE' use32
.text$mn:0000DB70                 assume cs:_text$mn
.text$mn:0000DB70                 ;org 0DB70h
.text$mn:0000DB70 ; COMDAT (pick any)
.text$mn:0000DB70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DB70
.text$mn:0000DB70 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DB70
.text$mn:0000DB70 ; Attributes: bp-based frame
.text$mn:0000DB70
.text$mn:0000DB70 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:0000DB70                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:0000DB70 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000DB70                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:0000DB70
.text$mn:0000DB70 var_8           = dword ptr -8
.text$mn:0000DB70 var_1           = byte ptr -1
.text$mn:0000DB70
.text$mn:0000DB70                 push    ebp
.text$mn:0000DB71                 mov     ebp, esp
.text$mn:0000DB73                 sub     esp, 8
.text$mn:0000DB76                 mov     [ebp+var_8], ecx
.text$mn:0000DB79                 lea     ecx, [ebp+var_1]
.text$mn:0000DB7C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000DB81                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000DB84                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000DB89                 mov     eax, [ebp+var_8]
.text$mn:0000DB8C                 mov     ecx, [eax]
.text$mn:0000DB8E                 push    ecx
.text$mn:0000DB8F                 lea     ecx, [ebp+var_1]
.text$mn:0000DB92                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000DB97                 push    1               ; int
.text$mn:0000DB99                 mov     edx, [ebp+var_8]
.text$mn:0000DB9C                 mov     eax, [edx]
.text$mn:0000DB9E                 push    eax             ; void *
.text$mn:0000DB9F                 lea     ecx, [ebp+var_1]
.text$mn:0000DBA2                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000DBA7                 mov     ecx, [ebp+var_8]
.text$mn:0000DBAA                 mov     dword ptr [ecx], 0
.text$mn:0000DBB0                 mov     esp, ebp
.text$mn:0000DBB2                 pop     ebp
.text$mn:0000DBB3                 retn
.text$mn:0000DBB3 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000DBB3
.text$mn:0000DBB3 _text$mn        ends
.text$mn:0000DBB3
.text$mn:0000DBB4 ; ===========================================================================
.text$mn:0000DBB4
.text$mn:0000DBB4 ; Segment type: Pure code
.text$mn:0000DBB4 ; Segment permissions: Read/Execute
.text$mn:0000DBB4 _text$mn        segment para public 'CODE' use32
.text$mn:0000DBB4                 assume cs:_text$mn
.text$mn:0000DBB4                 ;org 0DBB4h
.text$mn:0000DBB4 ; COMDAT (pick any)
.text$mn:0000DBB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DBB4
.text$mn:0000DBB4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DBB4
.text$mn:0000DBB4 ; Attributes: bp-based frame
.text$mn:0000DBB4
.text$mn:0000DBB4 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:0000DBB4                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:0000DBB4 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000DBB4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:0000DBB4
.text$mn:0000DBB4 var_8           = dword ptr -8
.text$mn:0000DBB4 var_1           = byte ptr -1
.text$mn:0000DBB4
.text$mn:0000DBB4                 push    ebp
.text$mn:0000DBB5                 mov     ebp, esp
.text$mn:0000DBB7                 sub     esp, 8
.text$mn:0000DBBA                 mov     [ebp+var_8], ecx
.text$mn:0000DBBD                 lea     ecx, [ebp+var_1]
.text$mn:0000DBC0                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000DBC5                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000DBC8                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000DBCD                 mov     eax, [ebp+var_8]
.text$mn:0000DBD0                 mov     ecx, [eax]
.text$mn:0000DBD2                 push    ecx
.text$mn:0000DBD3                 lea     ecx, [ebp+var_1]
.text$mn:0000DBD6                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000DBDB                 push    1               ; int
.text$mn:0000DBDD                 mov     edx, [ebp+var_8]
.text$mn:0000DBE0                 mov     eax, [edx]
.text$mn:0000DBE2                 push    eax             ; void *
.text$mn:0000DBE3                 lea     ecx, [ebp+var_1]
.text$mn:0000DBE6                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000DBEB                 mov     ecx, [ebp+var_8]
.text$mn:0000DBEE                 mov     dword ptr [ecx], 0
.text$mn:0000DBF4                 mov     esp, ebp
.text$mn:0000DBF6                 pop     ebp
.text$mn:0000DBF7                 retn
.text$mn:0000DBF7 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000DBF7
.text$mn:0000DBF7 _text$mn        ends
.text$mn:0000DBF7
.text$mn:0000DBF8 ; ===========================================================================
.text$mn:0000DBF8
.text$mn:0000DBF8 ; Segment type: Pure code
.text$mn:0000DBF8 ; Segment permissions: Read/Execute
.text$mn:0000DBF8 _text$mn        segment para public 'CODE' use32
.text$mn:0000DBF8                 assume cs:_text$mn
.text$mn:0000DBF8                 ;org 0DBF8h
.text$mn:0000DBF8 ; COMDAT (pick any)
.text$mn:0000DBF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DBF8
.text$mn:0000DBF8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DBF8
.text$mn:0000DBF8 ; Attributes: bp-based frame
.text$mn:0000DBF8
.text$mn:0000DBF8 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::_Free_proxy(void)
.text$mn:0000DBF8                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ
.text$mn:0000DBF8 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000DBF8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)+30p
.text$mn:0000DBF8
.text$mn:0000DBF8 var_8           = dword ptr -8
.text$mn:0000DBF8 var_1           = byte ptr -1
.text$mn:0000DBF8
.text$mn:0000DBF8                 push    ebp
.text$mn:0000DBF9                 mov     ebp, esp
.text$mn:0000DBFB                 sub     esp, 8
.text$mn:0000DBFE                 mov     [ebp+var_8], ecx
.text$mn:0000DC01                 lea     ecx, [ebp+var_1]
.text$mn:0000DC04                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:0000DC09                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000DC0C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000DC11                 mov     eax, [ebp+var_8]
.text$mn:0000DC14                 mov     ecx, [eax]
.text$mn:0000DC16                 push    ecx
.text$mn:0000DC17                 lea     ecx, [ebp+var_1]
.text$mn:0000DC1A                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000DC1F                 push    1               ; int
.text$mn:0000DC21                 mov     edx, [ebp+var_8]
.text$mn:0000DC24                 mov     eax, [edx]
.text$mn:0000DC26                 push    eax             ; void *
.text$mn:0000DC27                 lea     ecx, [ebp+var_1]
.text$mn:0000DC2A                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000DC2F                 mov     ecx, [ebp+var_8]
.text$mn:0000DC32                 mov     dword ptr [ecx], 0
.text$mn:0000DC38                 mov     esp, ebp
.text$mn:0000DC3A                 pop     ebp
.text$mn:0000DC3B                 retn
.text$mn:0000DC3B ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000DC3B
.text$mn:0000DC3B _text$mn        ends
.text$mn:0000DC3B
.text$mn:0000DC3C ; ===========================================================================
.text$mn:0000DC3C
.text$mn:0000DC3C ; Segment type: Pure code
.text$mn:0000DC3C ; Segment permissions: Read/Execute
.text$mn:0000DC3C _text$mn        segment para public 'CODE' use32
.text$mn:0000DC3C                 assume cs:_text$mn
.text$mn:0000DC3C                 ;org 0DC3Ch
.text$mn:0000DC3C ; COMDAT (pick any)
.text$mn:0000DC3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DC3C
.text$mn:0000DC3C ; =============== S U B R O U T I N E =======================================
.text$mn:0000DC3C
.text$mn:0000DC3C ; Attributes: bp-based frame
.text$mn:0000DC3C
.text$mn:0000DC3C ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned int, class std::allocator<unsigned int>>>::_Free_proxy(void)
.text$mn:0000DC3C                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ
.text$mn:0000DC3C ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000DC3C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::~_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(void)+30p
.text$mn:0000DC3C
.text$mn:0000DC3C var_8           = dword ptr -8
.text$mn:0000DC3C var_1           = byte ptr -1
.text$mn:0000DC3C
.text$mn:0000DC3C                 push    ebp
.text$mn:0000DC3D                 mov     ebp, esp
.text$mn:0000DC3F                 sub     esp, 8
.text$mn:0000DC42                 mov     [ebp+var_8], ecx
.text$mn:0000DC45                 lea     ecx, [ebp+var_1]
.text$mn:0000DC48                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:0000DC4D                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000DC50                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000DC55                 mov     eax, [ebp+var_8]
.text$mn:0000DC58                 mov     ecx, [eax]
.text$mn:0000DC5A                 push    ecx
.text$mn:0000DC5B                 lea     ecx, [ebp+var_1]
.text$mn:0000DC5E                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000DC63                 push    1               ; int
.text$mn:0000DC65                 mov     edx, [ebp+var_8]
.text$mn:0000DC68                 mov     eax, [edx]
.text$mn:0000DC6A                 push    eax             ; void *
.text$mn:0000DC6B                 lea     ecx, [ebp+var_1]
.text$mn:0000DC6E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000DC73                 mov     ecx, [ebp+var_8]
.text$mn:0000DC76                 mov     dword ptr [ecx], 0
.text$mn:0000DC7C                 mov     esp, ebp
.text$mn:0000DC7E                 pop     ebp
.text$mn:0000DC7F                 retn
.text$mn:0000DC7F ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000DC7F
.text$mn:0000DC7F _text$mn        ends
.text$mn:0000DC7F
.text$mn:0000DC80 ; ===========================================================================
.text$mn:0000DC80
.text$mn:0000DC80 ; Segment type: Pure code
.text$mn:0000DC80 ; Segment permissions: Read/Execute
.text$mn:0000DC80 _text$mn        segment para public 'CODE' use32
.text$mn:0000DC80                 assume cs:_text$mn
.text$mn:0000DC80                 ;org 0DC80h
.text$mn:0000DC80 ; COMDAT (pick any)
.text$mn:0000DC80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DC80
.text$mn:0000DC80 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DC80
.text$mn:0000DC80 ; Attributes: bp-based frame
.text$mn:0000DC80
.text$mn:0000DC80 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>>::_Free_proxy(void)
.text$mn:0000DC80                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAEXXZ
.text$mn:0000DC80 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000DC80                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>(void)+30p
.text$mn:0000DC80
.text$mn:0000DC80 var_8           = dword ptr -8
.text$mn:0000DC80 var_1           = byte ptr -1
.text$mn:0000DC80
.text$mn:0000DC80                 push    ebp
.text$mn:0000DC81                 mov     ebp, esp
.text$mn:0000DC83                 sub     esp, 8
.text$mn:0000DC86                 mov     [ebp+var_8], ecx
.text$mn:0000DC89                 lea     ecx, [ebp+var_1]
.text$mn:0000DC8C                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:0000DC91                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000DC94                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000DC99                 mov     eax, [ebp+var_8]
.text$mn:0000DC9C                 mov     ecx, [eax]
.text$mn:0000DC9E                 push    ecx
.text$mn:0000DC9F                 lea     ecx, [ebp+var_1]
.text$mn:0000DCA2                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000DCA7                 push    1               ; int
.text$mn:0000DCA9                 mov     edx, [ebp+var_8]
.text$mn:0000DCAC                 mov     eax, [edx]
.text$mn:0000DCAE                 push    eax             ; void *
.text$mn:0000DCAF                 lea     ecx, [ebp+var_1]
.text$mn:0000DCB2                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000DCB7                 mov     ecx, [ebp+var_8]
.text$mn:0000DCBA                 mov     dword ptr [ecx], 0
.text$mn:0000DCC0                 mov     esp, ebp
.text$mn:0000DCC2                 pop     ebp
.text$mn:0000DCC3                 retn
.text$mn:0000DCC3 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000DCC3
.text$mn:0000DCC3 _text$mn        ends
.text$mn:0000DCC3
.text$mn:0000DCC4 ; ===========================================================================
.text$mn:0000DCC4
.text$mn:0000DCC4 ; Segment type: Pure code
.text$mn:0000DCC4 ; Segment permissions: Read/Execute
.text$mn:0000DCC4 _text$mn        segment para public 'CODE' use32
.text$mn:0000DCC4                 assume cs:_text$mn
.text$mn:0000DCC4                 ;org 0DCC4h
.text$mn:0000DCC4 ; COMDAT (pick any)
.text$mn:0000DCC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DCC4
.text$mn:0000DCC4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DCC4
.text$mn:0000DCC4 ; Attributes: bp-based frame
.text$mn:0000DCC4
.text$mn:0000DCC4 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>::_Free_proxy(void)
.text$mn:0000DCC4                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ
.text$mn:0000DCC4 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ proc near
.text$mn:0000DCC4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)+30p
.text$mn:0000DCC4
.text$mn:0000DCC4 var_8           = dword ptr -8
.text$mn:0000DCC4 var_1           = byte ptr -1
.text$mn:0000DCC4
.text$mn:0000DCC4                 push    ebp
.text$mn:0000DCC5                 mov     ebp, esp
.text$mn:0000DCC7                 sub     esp, 8
.text$mn:0000DCCA                 mov     [ebp+var_8], ecx
.text$mn:0000DCCD                 lea     ecx, [ebp+var_1]
.text$mn:0000DCD0                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:0000DCD5                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000DCD8                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000DCDD                 mov     eax, [ebp+var_8]
.text$mn:0000DCE0                 mov     ecx, [eax]
.text$mn:0000DCE2                 push    ecx
.text$mn:0000DCE3                 lea     ecx, [ebp+var_1]
.text$mn:0000DCE6                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000DCEB                 push    1               ; int
.text$mn:0000DCED                 mov     edx, [ebp+var_8]
.text$mn:0000DCF0                 mov     eax, [edx]
.text$mn:0000DCF2                 push    eax             ; void *
.text$mn:0000DCF3                 lea     ecx, [ebp+var_1]
.text$mn:0000DCF6                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000DCFB                 mov     ecx, [ebp+var_8]
.text$mn:0000DCFE                 mov     dword ptr [ecx], 0
.text$mn:0000DD04                 mov     esp, ebp
.text$mn:0000DD06                 pop     ebp
.text$mn:0000DD07                 retn
.text$mn:0000DD07 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ endp
.text$mn:0000DD07
.text$mn:0000DD07 _text$mn        ends
.text$mn:0000DD07
.text$mn:0000DD08 ; ===========================================================================
.text$mn:0000DD08
.text$mn:0000DD08 ; Segment type: Pure code
.text$mn:0000DD08 ; Segment permissions: Read/Execute
.text$mn:0000DD08 _text$mn        segment para public 'CODE' use32
.text$mn:0000DD08                 assume cs:_text$mn
.text$mn:0000DD08                 ;org 0DD08h
.text$mn:0000DD08 ; COMDAT (pick any)
.text$mn:0000DD08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DD08
.text$mn:0000DD08 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DD08
.text$mn:0000DD08 ; Attributes: bp-based frame
.text$mn:0000DD08
.text$mn:0000DD08 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:0000DD08                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:0000DD08 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:0000DD08                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:0000DD08                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:0000DD08
.text$mn:0000DD08 var_4           = dword ptr -4
.text$mn:0000DD08 arg_0           = dword ptr  8
.text$mn:0000DD08
.text$mn:0000DD08                 push    ebp
.text$mn:0000DD09                 mov     ebp, esp
.text$mn:0000DD0B                 push    ecx
.text$mn:0000DD0C                 mov     [ebp+var_4], ecx
.text$mn:0000DD0F                 mov     ecx, [ebp+arg_0]
.text$mn:0000DD12                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:0000DD17                 mov     eax, [ebp+arg_0]
.text$mn:0000DD1A                 mov     esp, ebp
.text$mn:0000DD1C                 pop     ebp
.text$mn:0000DD1D                 retn    4
.text$mn:0000DD1D ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:0000DD1D
.text$mn:0000DD1D _text$mn        ends
.text$mn:0000DD1D
.text$mn:0000DD20 ; ===========================================================================
.text$mn:0000DD20
.text$mn:0000DD20 ; Segment type: Pure code
.text$mn:0000DD20 ; Segment permissions: Read/Execute
.text$mn:0000DD20 _text$mn        segment para public 'CODE' use32
.text$mn:0000DD20                 assume cs:_text$mn
.text$mn:0000DD20                 ;org 0DD20h
.text$mn:0000DD20 ; COMDAT (pick any)
.text$mn:0000DD20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DD20
.text$mn:0000DD20 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DD20
.text$mn:0000DD20 ; Attributes: bp-based frame
.text$mn:0000DD20
.text$mn:0000DD20 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:0000DD20                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:0000DD20 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:0000DD20                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+2Fp
.text$mn:0000DD20                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+33p ...
.text$mn:0000DD20
.text$mn:0000DD20 var_4           = dword ptr -4
.text$mn:0000DD20 arg_0           = dword ptr  8
.text$mn:0000DD20
.text$mn:0000DD20                 push    ebp
.text$mn:0000DD21                 mov     ebp, esp
.text$mn:0000DD23                 push    ecx
.text$mn:0000DD24                 mov     [ebp+var_4], ecx
.text$mn:0000DD27                 mov     ecx, [ebp+arg_0]
.text$mn:0000DD2A                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:0000DD2F                 mov     eax, [ebp+arg_0]
.text$mn:0000DD32                 mov     esp, ebp
.text$mn:0000DD34                 pop     ebp
.text$mn:0000DD35                 retn    4
.text$mn:0000DD35 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:0000DD35
.text$mn:0000DD35 _text$mn        ends
.text$mn:0000DD35
.text$mn:0000DD38 ; ===========================================================================
.text$mn:0000DD38
.text$mn:0000DD38 ; Segment type: Pure code
.text$mn:0000DD38 ; Segment permissions: Read/Execute
.text$mn:0000DD38 _text$mn        segment para public 'CODE' use32
.text$mn:0000DD38                 assume cs:_text$mn
.text$mn:0000DD38                 ;org 0DD38h
.text$mn:0000DD38 ; COMDAT (pick any)
.text$mn:0000DD38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DD38
.text$mn:0000DD38 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DD38
.text$mn:0000DD38 ; Attributes: bp-based frame
.text$mn:0000DD38
.text$mn:0000DD38 ; public: struct std::_Wrap_alloc<class std::allocator<int>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::_Getal(void)const
.text$mn:0000DD38                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ
.text$mn:0000DD38 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ proc near
.text$mn:0000DD38                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Umove<int *>(int *,int *,int *)+10p
.text$mn:0000DD38                                         ; std::vector<int,std::allocator<int>>::_Destroy(int *,int *)+10p ...
.text$mn:0000DD38
.text$mn:0000DD38 var_4           = dword ptr -4
.text$mn:0000DD38 arg_0           = dword ptr  8
.text$mn:0000DD38
.text$mn:0000DD38                 push    ebp
.text$mn:0000DD39                 mov     ebp, esp
.text$mn:0000DD3B                 push    ecx
.text$mn:0000DD3C                 mov     [ebp+var_4], ecx
.text$mn:0000DD3F                 mov     ecx, [ebp+arg_0]
.text$mn:0000DD42                 call    ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<int>>::_Wrap_alloc<std::allocator<int>>(void)
.text$mn:0000DD47                 mov     eax, [ebp+arg_0]
.text$mn:0000DD4A                 mov     esp, ebp
.text$mn:0000DD4C                 pop     ebp
.text$mn:0000DD4D                 retn    4
.text$mn:0000DD4D ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ endp
.text$mn:0000DD4D
.text$mn:0000DD4D _text$mn        ends
.text$mn:0000DD4D
.text$mn:0000DD50 ; ===========================================================================
.text$mn:0000DD50
.text$mn:0000DD50 ; Segment type: Pure code
.text$mn:0000DD50 ; Segment permissions: Read/Execute
.text$mn:0000DD50 _text$mn        segment para public 'CODE' use32
.text$mn:0000DD50                 assume cs:_text$mn
.text$mn:0000DD50                 ;org 0DD50h
.text$mn:0000DD50 ; COMDAT (pick any)
.text$mn:0000DD50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DD50
.text$mn:0000DD50 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DD50
.text$mn:0000DD50 ; Attributes: bp-based frame
.text$mn:0000DD50
.text$mn:0000DD50 ; public: struct std::_Wrap_alloc<class std::allocator<unsigned int>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned int, class std::allocator<unsigned int>>>::_Getal(void)const
.text$mn:0000DD50                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ
.text$mn:0000DD50 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ proc near
.text$mn:0000DD50                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Ucopy<uint *>(uint *,uint *,uint *)+10p
.text$mn:0000DD50                                         ; std::vector<uint,std::allocator<uint>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>,uint *)+36p ...
.text$mn:0000DD50
.text$mn:0000DD50 var_4           = dword ptr -4
.text$mn:0000DD50 arg_0           = dword ptr  8
.text$mn:0000DD50
.text$mn:0000DD50                 push    ebp
.text$mn:0000DD51                 mov     ebp, esp
.text$mn:0000DD53                 push    ecx
.text$mn:0000DD54                 mov     [ebp+var_4], ecx
.text$mn:0000DD57                 mov     ecx, [ebp+arg_0]
.text$mn:0000DD5A                 call    ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<uint>>::_Wrap_alloc<std::allocator<uint>>(void)
.text$mn:0000DD5F                 mov     eax, [ebp+arg_0]
.text$mn:0000DD62                 mov     esp, ebp
.text$mn:0000DD64                 pop     ebp
.text$mn:0000DD65                 retn    4
.text$mn:0000DD65 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ endp
.text$mn:0000DD65
.text$mn:0000DD65 _text$mn        ends
.text$mn:0000DD65
.text$mn:0000DD68 ; ===========================================================================
.text$mn:0000DD68
.text$mn:0000DD68 ; Segment type: Pure code
.text$mn:0000DD68 ; Segment permissions: Read/Execute
.text$mn:0000DD68 _text$mn        segment para public 'CODE' use32
.text$mn:0000DD68                 assume cs:_text$mn
.text$mn:0000DD68                 ;org 0DD68h
.text$mn:0000DD68 ; COMDAT (pick any)
.text$mn:0000DD68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DD68
.text$mn:0000DD68 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DD68
.text$mn:0000DD68 ; Attributes: bp-based frame
.text$mn:0000DD68
.text$mn:0000DD68 ; public: struct std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>>::_Getal(void)const
.text$mn:0000DD68                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@XZ
.text$mn:0000DD68 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@XZ proc near
.text$mn:0000DD68                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>,sessionFileInfo *)+36p
.text$mn:0000DD68                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Umove<sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *)+10p ...
.text$mn:0000DD68
.text$mn:0000DD68 var_4           = dword ptr -4
.text$mn:0000DD68 arg_0           = dword ptr  8
.text$mn:0000DD68
.text$mn:0000DD68                 push    ebp
.text$mn:0000DD69                 mov     ebp, esp
.text$mn:0000DD6B                 push    ecx
.text$mn:0000DD6C                 mov     [ebp+var_4], ecx
.text$mn:0000DD6F                 mov     ecx, [ebp+arg_0]
.text$mn:0000DD72                 call    ??0?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::_Wrap_alloc<std::allocator<sessionFileInfo>>(void)
.text$mn:0000DD77                 mov     eax, [ebp+arg_0]
.text$mn:0000DD7A                 mov     esp, ebp
.text$mn:0000DD7C                 pop     ebp
.text$mn:0000DD7D                 retn    4
.text$mn:0000DD7D ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@XZ endp
.text$mn:0000DD7D
.text$mn:0000DD7D _text$mn        ends
.text$mn:0000DD7D
.text$mn:0000DD80 ; ===========================================================================
.text$mn:0000DD80
.text$mn:0000DD80 ; Segment type: Pure code
.text$mn:0000DD80 ; Segment permissions: Read/Execute
.text$mn:0000DD80 _text$mn        segment para public 'CODE' use32
.text$mn:0000DD80                 assume cs:_text$mn
.text$mn:0000DD80                 ;org 0DD80h
.text$mn:0000DD80 ; COMDAT (pick any)
.text$mn:0000DD80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DD80
.text$mn:0000DD80 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DD80
.text$mn:0000DD80 ; Attributes: bp-based frame
.text$mn:0000DD80
.text$mn:0000DD80 ; public: struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>::_Getal(void)const
.text$mn:0000DD80                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ
.text$mn:0000DD80 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ proc near
.text$mn:0000DD80                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Umove<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+10p
.text$mn:0000DD80                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Destroy(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+10p ...
.text$mn:0000DD80
.text$mn:0000DD80 var_4           = dword ptr -4
.text$mn:0000DD80 arg_0           = dword ptr  8
.text$mn:0000DD80
.text$mn:0000DD80                 push    ebp
.text$mn:0000DD81                 mov     ebp, esp
.text$mn:0000DD83                 push    ecx
.text$mn:0000DD84                 mov     [ebp+var_4], ecx
.text$mn:0000DD87                 mov     ecx, [ebp+arg_0]
.text$mn:0000DD8A                 call    ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:0000DD8F                 mov     eax, [ebp+arg_0]
.text$mn:0000DD92                 mov     esp, ebp
.text$mn:0000DD94                 pop     ebp
.text$mn:0000DD95                 retn    4
.text$mn:0000DD95 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ endp
.text$mn:0000DD95
.text$mn:0000DD95 _text$mn        ends
.text$mn:0000DD95
.text$mn:0000DD98 ; ===========================================================================
.text$mn:0000DD98
.text$mn:0000DD98 ; Segment type: Pure code
.text$mn:0000DD98 ; Segment permissions: Read/Execute
.text$mn:0000DD98 _text$mn        segment para public 'CODE' use32
.text$mn:0000DD98                 assume cs:_text$mn
.text$mn:0000DD98                 ;org 0DD98h
.text$mn:0000DD98 ; COMDAT (pick any)
.text$mn:0000DD98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DD98
.text$mn:0000DD98 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DD98
.text$mn:0000DD98 ; Attributes: bp-based frame
.text$mn:0000DD98
.text$mn:0000DD98 ; const struct std::_Container_base12 *__thiscall std::_Iterator_base12::_Getcont(std::_Iterator_base12 *__hidden this)
.text$mn:0000DD98                 public ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
.text$mn:0000DD98 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ proc near
.text$mn:0000DD98                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+Bp
.text$mn:0000DD98                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+20p ...
.text$mn:0000DD98
.text$mn:0000DD98 var_8           = dword ptr -8
.text$mn:0000DD98 var_4           = dword ptr -4
.text$mn:0000DD98
.text$mn:0000DD98                 push    ebp
.text$mn:0000DD99                 mov     ebp, esp
.text$mn:0000DD9B                 sub     esp, 8
.text$mn:0000DD9E                 mov     [ebp+var_4], ecx
.text$mn:0000DDA1                 mov     eax, [ebp+var_4]
.text$mn:0000DDA4                 cmp     dword ptr [eax], 0
.text$mn:0000DDA7                 jnz     short loc_DDB2
.text$mn:0000DDA9                 mov     [ebp+var_8], 0
.text$mn:0000DDB0                 jmp     short loc_DDBC
.text$mn:0000DDB2 ; ---------------------------------------------------------------------------
.text$mn:0000DDB2
.text$mn:0000DDB2 loc_DDB2:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+Fj
.text$mn:0000DDB2                 mov     ecx, [ebp+var_4]
.text$mn:0000DDB5                 mov     edx, [ecx]
.text$mn:0000DDB7                 mov     eax, [edx]
.text$mn:0000DDB9                 mov     [ebp+var_8], eax
.text$mn:0000DDBC
.text$mn:0000DDBC loc_DDBC:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+18j
.text$mn:0000DDBC                 mov     eax, [ebp+var_8]
.text$mn:0000DDBF                 mov     esp, ebp
.text$mn:0000DDC1                 pop     ebp
.text$mn:0000DDC2                 retn
.text$mn:0000DDC2 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ endp
.text$mn:0000DDC2
.text$mn:0000DDC2 ; ---------------------------------------------------------------------------
.text$mn:0000DDC3                 align 4
.text$mn:0000DDC3 _text$mn        ends
.text$mn:0000DDC3
.text$mn:0000DDC4 ; ===========================================================================
.text$mn:0000DDC4
.text$mn:0000DDC4 ; Segment type: Pure code
.text$mn:0000DDC4 ; Segment permissions: Read/Execute
.text$mn:0000DDC4 _text$mn        segment para public 'CODE' use32
.text$mn:0000DDC4                 assume cs:_text$mn
.text$mn:0000DDC4                 ;org 0DDC4h
.text$mn:0000DDC4 ; COMDAT (pick any)
.text$mn:0000DDC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DDC4
.text$mn:0000DDC4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DDC4
.text$mn:0000DDC4 ; Attributes: bp-based frame
.text$mn:0000DDC4
.text$mn:0000DDC4 ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:0000DDC4                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:0000DDC4 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:0000DDC4                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+3Cp
.text$mn:0000DDC4                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Orphan_range(sessionFileInfo *,sessionFileInfo *)+3Cp ...
.text$mn:0000DDC4
.text$mn:0000DDC4 var_8           = dword ptr -8
.text$mn:0000DDC4 var_4           = dword ptr -4
.text$mn:0000DDC4
.text$mn:0000DDC4                 push    ebp
.text$mn:0000DDC5                 mov     ebp, esp
.text$mn:0000DDC7                 sub     esp, 8
.text$mn:0000DDCA                 mov     [ebp+var_4], ecx
.text$mn:0000DDCD                 mov     eax, [ebp+var_4]
.text$mn:0000DDD0                 cmp     dword ptr [eax], 0
.text$mn:0000DDD3                 jnz     short loc_DDDE
.text$mn:0000DDD5                 mov     [ebp+var_8], 0
.text$mn:0000DDDC                 jmp     short loc_DDE9
.text$mn:0000DDDE ; ---------------------------------------------------------------------------
.text$mn:0000DDDE
.text$mn:0000DDDE loc_DDDE:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:0000DDDE                 mov     ecx, [ebp+var_4]
.text$mn:0000DDE1                 mov     edx, [ecx]
.text$mn:0000DDE3                 add     edx, 4
.text$mn:0000DDE6                 mov     [ebp+var_8], edx
.text$mn:0000DDE9
.text$mn:0000DDE9 loc_DDE9:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:0000DDE9                 mov     eax, [ebp+var_8]
.text$mn:0000DDEC                 mov     esp, ebp
.text$mn:0000DDEE                 pop     ebp
.text$mn:0000DDEF                 retn
.text$mn:0000DDEF ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:0000DDEF
.text$mn:0000DDEF _text$mn        ends
.text$mn:0000DDEF
.text$mn:0000DDF0 ; ===========================================================================
.text$mn:0000DDF0
.text$mn:0000DDF0 ; Segment type: Pure code
.text$mn:0000DDF0 ; Segment permissions: Read/Execute
.text$mn:0000DDF0 _text$mn        segment para public 'CODE' use32
.text$mn:0000DDF0                 assume cs:_text$mn
.text$mn:0000DDF0                 ;org 0DDF0h
.text$mn:0000DDF0 ; COMDAT (pick any)
.text$mn:0000DDF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DDF0
.text$mn:0000DDF0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DDF0
.text$mn:0000DDF0 ; Attributes: bp-based frame
.text$mn:0000DDF0
.text$mn:0000DDF0 ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:0000DDF0                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:0000DDF0 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:0000DDF0                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+71p
.text$mn:0000DDF0                                         ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+8Ap ...
.text$mn:0000DDF0
.text$mn:0000DDF0 var_4           = dword ptr -4
.text$mn:0000DDF0
.text$mn:0000DDF0                 push    ebp
.text$mn:0000DDF1                 mov     ebp, esp
.text$mn:0000DDF3                 push    ecx
.text$mn:0000DDF4                 mov     [ebp+var_4], ecx
.text$mn:0000DDF7                 mov     eax, [ebp+var_4]
.text$mn:0000DDFA                 add     eax, 4
.text$mn:0000DDFD                 mov     esp, ebp
.text$mn:0000DDFF                 pop     ebp
.text$mn:0000DE00                 retn
.text$mn:0000DE00 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:0000DE00
.text$mn:0000DE00 ; ---------------------------------------------------------------------------
.text$mn:0000DE01                 align 4
.text$mn:0000DE01 _text$mn        ends
.text$mn:0000DE01
.text$mn:0000DE04 ; ===========================================================================
.text$mn:0000DE04
.text$mn:0000DE04 ; Segment type: Pure code
.text$mn:0000DE04 ; Segment permissions: Read/Execute
.text$mn:0000DE04 _text$mn        segment para public 'CODE' use32
.text$mn:0000DE04                 assume cs:_text$mn
.text$mn:0000DE04                 ;org 0DE04h
.text$mn:0000DE04 ; COMDAT (pick any)
.text$mn:0000DE04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DE04
.text$mn:0000DE04 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DE04
.text$mn:0000DE04 ; Attributes: bp-based frame
.text$mn:0000DE04
.text$mn:0000DE04 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:0000DE04                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:0000DE04 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:0000DE04                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:0000DE04                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:0000DE04
.text$mn:0000DE04 var_C           = dword ptr -0Ch
.text$mn:0000DE04 Size            = dword ptr -8
.text$mn:0000DE04 var_4           = dword ptr -4
.text$mn:0000DE04 arg_0           = dword ptr  8
.text$mn:0000DE04 arg_4           = byte ptr  0Ch
.text$mn:0000DE04
.text$mn:0000DE04                 push    ebp
.text$mn:0000DE05                 mov     ebp, esp
.text$mn:0000DE07                 sub     esp, 0Ch
.text$mn:0000DE0A                 mov     [ebp+var_4], ecx
.text$mn:0000DE0D                 mov     ecx, [ebp+var_4]
.text$mn:0000DE10                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000DE15                 cmp     eax, [ebp+arg_0]
.text$mn:0000DE18                 jnb     short loc_DE22
.text$mn:0000DE1A                 mov     ecx, [ebp+var_4]
.text$mn:0000DE1D                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:0000DE22
.text$mn:0000DE22 loc_DE22:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:0000DE22                 mov     eax, [ebp+var_4]
.text$mn:0000DE25                 mov     ecx, [eax+18h]
.text$mn:0000DE28                 cmp     ecx, [ebp+arg_0]
.text$mn:0000DE2B                 jnb     short loc_DE42
.text$mn:0000DE2D                 mov     edx, [ebp+var_4]
.text$mn:0000DE30                 mov     eax, [edx+14h]
.text$mn:0000DE33                 push    eax
.text$mn:0000DE34                 mov     ecx, [ebp+arg_0]
.text$mn:0000DE37                 push    ecx
.text$mn:0000DE38                 mov     ecx, [ebp+var_4]
.text$mn:0000DE3B                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:0000DE40                 jmp     short loc_DE8C
.text$mn:0000DE42 ; ---------------------------------------------------------------------------
.text$mn:0000DE42
.text$mn:0000DE42 loc_DE42:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:0000DE42                 movzx   edx, [ebp+arg_4]
.text$mn:0000DE46                 test    edx, edx
.text$mn:0000DE48                 jz      short loc_DE7C
.text$mn:0000DE4A                 cmp     [ebp+arg_0], 10h
.text$mn:0000DE4E                 jnb     short loc_DE7C
.text$mn:0000DE50                 mov     eax, [ebp+var_4]
.text$mn:0000DE53                 mov     ecx, [ebp+arg_0]
.text$mn:0000DE56                 cmp     ecx, [eax+14h]
.text$mn:0000DE59                 jnb     short loc_DE63
.text$mn:0000DE5B                 mov     edx, [ebp+arg_0]
.text$mn:0000DE5E                 mov     [ebp+Size], edx
.text$mn:0000DE61                 jmp     short loc_DE6C
.text$mn:0000DE63 ; ---------------------------------------------------------------------------
.text$mn:0000DE63
.text$mn:0000DE63 loc_DE63:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:0000DE63                 mov     eax, [ebp+var_4]
.text$mn:0000DE66                 mov     ecx, [eax+14h]
.text$mn:0000DE69                 mov     [ebp+Size], ecx
.text$mn:0000DE6C
.text$mn:0000DE6C loc_DE6C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:0000DE6C                 mov     edx, [ebp+Size]
.text$mn:0000DE6F                 push    edx             ; Size
.text$mn:0000DE70                 push    1               ; char
.text$mn:0000DE72                 mov     ecx, [ebp+var_4]
.text$mn:0000DE75                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000DE7A                 jmp     short loc_DE8C
.text$mn:0000DE7C ; ---------------------------------------------------------------------------
.text$mn:0000DE7C
.text$mn:0000DE7C loc_DE7C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:0000DE7C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:0000DE7C                 cmp     [ebp+arg_0], 0
.text$mn:0000DE80                 jnz     short loc_DE8C
.text$mn:0000DE82                 push    0
.text$mn:0000DE84                 mov     ecx, [ebp+var_4]
.text$mn:0000DE87                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000DE8C
.text$mn:0000DE8C loc_DE8C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:0000DE8C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:0000DE8C                 cmp     [ebp+arg_0], 0
.text$mn:0000DE90                 jbe     short loc_DE9B
.text$mn:0000DE92                 mov     [ebp+var_C], 1
.text$mn:0000DE99                 jmp     short loc_DEA2
.text$mn:0000DE9B ; ---------------------------------------------------------------------------
.text$mn:0000DE9B
.text$mn:0000DE9B loc_DE9B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000DE9B                 mov     [ebp+var_C], 0
.text$mn:0000DEA2
.text$mn:0000DEA2 loc_DEA2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:0000DEA2                 mov     al, byte ptr [ebp+var_C]
.text$mn:0000DEA5                 mov     esp, ebp
.text$mn:0000DEA7                 pop     ebp
.text$mn:0000DEA8                 retn    8
.text$mn:0000DEA8 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:0000DEA8
.text$mn:0000DEA8 ; ---------------------------------------------------------------------------
.text$mn:0000DEAB                 align 4
.text$mn:0000DEAB _text$mn        ends
.text$mn:0000DEAB
.text$mn:0000DEAC ; ===========================================================================
.text$mn:0000DEAC
.text$mn:0000DEAC ; Segment type: Pure code
.text$mn:0000DEAC ; Segment permissions: Read/Execute
.text$mn:0000DEAC _text$mn        segment para public 'CODE' use32
.text$mn:0000DEAC                 assume cs:_text$mn
.text$mn:0000DEAC                 ;org 0DEACh
.text$mn:0000DEAC ; COMDAT (pick any)
.text$mn:0000DEAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DEAC
.text$mn:0000DEAC ; =============== S U B R O U T I N E =======================================
.text$mn:0000DEAC
.text$mn:0000DEAC ; Attributes: bp-based frame
.text$mn:0000DEAC
.text$mn:0000DEAC ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:0000DEAC                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:0000DEAC ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:0000DEAC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Dp
.text$mn:0000DEAC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+8Ep ...
.text$mn:0000DEAC
.text$mn:0000DEAC var_C           = dword ptr -0Ch
.text$mn:0000DEAC var_8           = dword ptr -8
.text$mn:0000DEAC var_4           = dword ptr -4
.text$mn:0000DEAC arg_0           = dword ptr  8
.text$mn:0000DEAC arg_4           = byte ptr  0Ch
.text$mn:0000DEAC
.text$mn:0000DEAC                 push    ebp
.text$mn:0000DEAD                 mov     ebp, esp
.text$mn:0000DEAF                 sub     esp, 0Ch
.text$mn:0000DEB2                 mov     [ebp+var_4], ecx
.text$mn:0000DEB5                 mov     ecx, [ebp+var_4]
.text$mn:0000DEB8                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:0000DEBD                 cmp     eax, [ebp+arg_0]
.text$mn:0000DEC0                 jnb     short loc_DECA
.text$mn:0000DEC2                 mov     ecx, [ebp+var_4]
.text$mn:0000DEC5                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000DECA
.text$mn:0000DECA loc_DECA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:0000DECA                 mov     eax, [ebp+var_4]
.text$mn:0000DECD                 mov     ecx, [eax+18h]
.text$mn:0000DED0                 cmp     ecx, [ebp+arg_0]
.text$mn:0000DED3                 jnb     short loc_DEEA
.text$mn:0000DED5                 mov     edx, [ebp+var_4]
.text$mn:0000DED8                 mov     eax, [edx+14h]
.text$mn:0000DEDB                 push    eax
.text$mn:0000DEDC                 mov     ecx, [ebp+arg_0]
.text$mn:0000DEDF                 push    ecx
.text$mn:0000DEE0                 mov     ecx, [ebp+var_4]
.text$mn:0000DEE3                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:0000DEE8                 jmp     short loc_DF34
.text$mn:0000DEEA ; ---------------------------------------------------------------------------
.text$mn:0000DEEA
.text$mn:0000DEEA loc_DEEA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:0000DEEA                 movzx   edx, [ebp+arg_4]
.text$mn:0000DEEE                 test    edx, edx
.text$mn:0000DEF0                 jz      short loc_DF24
.text$mn:0000DEF2                 cmp     [ebp+arg_0], 8
.text$mn:0000DEF6                 jnb     short loc_DF24
.text$mn:0000DEF8                 mov     eax, [ebp+var_4]
.text$mn:0000DEFB                 mov     ecx, [ebp+arg_0]
.text$mn:0000DEFE                 cmp     ecx, [eax+14h]
.text$mn:0000DF01                 jnb     short loc_DF0B
.text$mn:0000DF03                 mov     edx, [ebp+arg_0]
.text$mn:0000DF06                 mov     [ebp+var_8], edx
.text$mn:0000DF09                 jmp     short loc_DF14
.text$mn:0000DF0B ; ---------------------------------------------------------------------------
.text$mn:0000DF0B
.text$mn:0000DF0B loc_DF0B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:0000DF0B                 mov     eax, [ebp+var_4]
.text$mn:0000DF0E                 mov     ecx, [eax+14h]
.text$mn:0000DF11                 mov     [ebp+var_8], ecx
.text$mn:0000DF14
.text$mn:0000DF14 loc_DF14:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:0000DF14                 mov     edx, [ebp+var_8]
.text$mn:0000DF17                 push    edx
.text$mn:0000DF18                 push    1
.text$mn:0000DF1A                 mov     ecx, [ebp+var_4]
.text$mn:0000DF1D                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000DF22                 jmp     short loc_DF34
.text$mn:0000DF24 ; ---------------------------------------------------------------------------
.text$mn:0000DF24
.text$mn:0000DF24 loc_DF24:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:0000DF24                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:0000DF24                 cmp     [ebp+arg_0], 0
.text$mn:0000DF28                 jnz     short loc_DF34
.text$mn:0000DF2A                 push    0
.text$mn:0000DF2C                 mov     ecx, [ebp+var_4]
.text$mn:0000DF2F                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000DF34
.text$mn:0000DF34 loc_DF34:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:0000DF34                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:0000DF34                 cmp     [ebp+arg_0], 0
.text$mn:0000DF38                 jbe     short loc_DF43
.text$mn:0000DF3A                 mov     [ebp+var_C], 1
.text$mn:0000DF41                 jmp     short loc_DF4A
.text$mn:0000DF43 ; ---------------------------------------------------------------------------
.text$mn:0000DF43
.text$mn:0000DF43 loc_DF43:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:0000DF43                 mov     [ebp+var_C], 0
.text$mn:0000DF4A
.text$mn:0000DF4A loc_DF4A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:0000DF4A                 mov     al, byte ptr [ebp+var_C]
.text$mn:0000DF4D                 mov     esp, ebp
.text$mn:0000DF4F                 pop     ebp
.text$mn:0000DF50                 retn    8
.text$mn:0000DF50 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:0000DF50
.text$mn:0000DF50 ; ---------------------------------------------------------------------------
.text$mn:0000DF53                 align 4
.text$mn:0000DF53 _text$mn        ends
.text$mn:0000DF53
.text$mn:0000DF54 ; ===========================================================================
.text$mn:0000DF54
.text$mn:0000DF54 ; Segment type: Pure code
.text$mn:0000DF54 ; Segment permissions: Read/Execute
.text$mn:0000DF54 _text$mn        segment para public 'CODE' use32
.text$mn:0000DF54                 assume cs:_text$mn
.text$mn:0000DF54                 ;org 0DF54h
.text$mn:0000DF54 ; COMDAT (pick any)
.text$mn:0000DF54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DF54
.text$mn:0000DF54 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DF54
.text$mn:0000DF54 ; Attributes: bp-based frame
.text$mn:0000DF54
.text$mn:0000DF54 ; protected: unsigned int __thiscall std::vector<int, class std::allocator<int>>::_Grow_to(unsigned int)const
.text$mn:0000DF54                 public ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z
.text$mn:0000DF54 ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z proc near
.text$mn:0000DF54                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+45p
.text$mn:0000DF54
.text$mn:0000DF54 var_C           = dword ptr -0Ch
.text$mn:0000DF54 var_8           = dword ptr -8
.text$mn:0000DF54 var_4           = dword ptr -4
.text$mn:0000DF54 arg_0           = dword ptr  8
.text$mn:0000DF54
.text$mn:0000DF54                 push    ebp
.text$mn:0000DF55                 mov     ebp, esp
.text$mn:0000DF57                 sub     esp, 0Ch
.text$mn:0000DF5A                 mov     [ebp+var_8], ecx
.text$mn:0000DF5D                 mov     ecx, [ebp+var_8]
.text$mn:0000DF60                 call    ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::capacity(void)
.text$mn:0000DF65                 mov     [ebp+var_4], eax
.text$mn:0000DF68                 mov     ecx, [ebp+var_8]
.text$mn:0000DF6B                 call    ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::max_size(void)
.text$mn:0000DF70                 mov     ecx, [ebp+var_4]
.text$mn:0000DF73                 shr     ecx, 1
.text$mn:0000DF75                 sub     eax, ecx
.text$mn:0000DF77                 cmp     eax, [ebp+var_4]
.text$mn:0000DF7A                 jnb     short loc_DF85
.text$mn:0000DF7C                 mov     [ebp+var_C], 0
.text$mn:0000DF83                 jmp     short loc_DF90
.text$mn:0000DF85 ; ---------------------------------------------------------------------------
.text$mn:0000DF85
.text$mn:0000DF85 loc_DF85:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+26j
.text$mn:0000DF85                 mov     edx, [ebp+var_4]
.text$mn:0000DF88                 shr     edx, 1
.text$mn:0000DF8A                 add     edx, [ebp+var_4]
.text$mn:0000DF8D                 mov     [ebp+var_C], edx
.text$mn:0000DF90
.text$mn:0000DF90 loc_DF90:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+2Fj
.text$mn:0000DF90                 mov     eax, [ebp+var_C]
.text$mn:0000DF93                 mov     [ebp+var_4], eax
.text$mn:0000DF96                 mov     ecx, [ebp+var_4]
.text$mn:0000DF99                 cmp     ecx, [ebp+arg_0]
.text$mn:0000DF9C                 jnb     short loc_DFA4
.text$mn:0000DF9E                 mov     edx, [ebp+arg_0]
.text$mn:0000DFA1                 mov     [ebp+var_4], edx
.text$mn:0000DFA4
.text$mn:0000DFA4 loc_DFA4:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+48j
.text$mn:0000DFA4                 mov     eax, [ebp+var_4]
.text$mn:0000DFA7                 mov     esp, ebp
.text$mn:0000DFA9                 pop     ebp
.text$mn:0000DFAA                 retn    4
.text$mn:0000DFAA ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z endp
.text$mn:0000DFAA
.text$mn:0000DFAA ; ---------------------------------------------------------------------------
.text$mn:0000DFAD                 align 10h
.text$mn:0000DFAD _text$mn        ends
.text$mn:0000DFAD
.text$mn:0000DFB0 ; ===========================================================================
.text$mn:0000DFB0
.text$mn:0000DFB0 ; Segment type: Pure code
.text$mn:0000DFB0 ; Segment permissions: Read/Execute
.text$mn:0000DFB0 _text$mn        segment para public 'CODE' use32
.text$mn:0000DFB0                 assume cs:_text$mn
.text$mn:0000DFB0                 ;org 0DFB0h
.text$mn:0000DFB0 ; COMDAT (pick any)
.text$mn:0000DFB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000DFB0
.text$mn:0000DFB0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000DFB0
.text$mn:0000DFB0 ; Attributes: bp-based frame
.text$mn:0000DFB0
.text$mn:0000DFB0 ; protected: unsigned int __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::_Grow_to(unsigned int)const
.text$mn:0000DFB0                 public ?_Grow_to@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEII@Z
.text$mn:0000DFB0 ?_Grow_to@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEII@Z proc near
.text$mn:0000DFB0                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reserve(uint)+45p
.text$mn:0000DFB0
.text$mn:0000DFB0 var_C           = dword ptr -0Ch
.text$mn:0000DFB0 var_8           = dword ptr -8
.text$mn:0000DFB0 var_4           = dword ptr -4
.text$mn:0000DFB0 arg_0           = dword ptr  8
.text$mn:0000DFB0
.text$mn:0000DFB0                 push    ebp
.text$mn:0000DFB1                 mov     ebp, esp
.text$mn:0000DFB3                 sub     esp, 0Ch
.text$mn:0000DFB6                 mov     [ebp+var_8], ecx
.text$mn:0000DFB9                 mov     ecx, [ebp+var_8]
.text$mn:0000DFBC                 call    ?capacity@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::capacity(void)
.text$mn:0000DFC1                 mov     [ebp+var_4], eax
.text$mn:0000DFC4                 mov     ecx, [ebp+var_8]
.text$mn:0000DFC7                 call    ?max_size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::max_size(void)
.text$mn:0000DFCC                 mov     ecx, [ebp+var_4]
.text$mn:0000DFCF                 shr     ecx, 1
.text$mn:0000DFD1                 sub     eax, ecx
.text$mn:0000DFD3                 cmp     eax, [ebp+var_4]
.text$mn:0000DFD6                 jnb     short loc_DFE1
.text$mn:0000DFD8                 mov     [ebp+var_C], 0
.text$mn:0000DFDF                 jmp     short loc_DFEC
.text$mn:0000DFE1 ; ---------------------------------------------------------------------------
.text$mn:0000DFE1
.text$mn:0000DFE1 loc_DFE1:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Grow_to(uint)+26j
.text$mn:0000DFE1                 mov     edx, [ebp+var_4]
.text$mn:0000DFE4                 shr     edx, 1
.text$mn:0000DFE6                 add     edx, [ebp+var_4]
.text$mn:0000DFE9                 mov     [ebp+var_C], edx
.text$mn:0000DFEC
.text$mn:0000DFEC loc_DFEC:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Grow_to(uint)+2Fj
.text$mn:0000DFEC                 mov     eax, [ebp+var_C]
.text$mn:0000DFEF                 mov     [ebp+var_4], eax
.text$mn:0000DFF2                 mov     ecx, [ebp+var_4]
.text$mn:0000DFF5                 cmp     ecx, [ebp+arg_0]
.text$mn:0000DFF8                 jnb     short loc_E000
.text$mn:0000DFFA                 mov     edx, [ebp+arg_0]
.text$mn:0000DFFD                 mov     [ebp+var_4], edx
.text$mn:0000E000
.text$mn:0000E000 loc_E000:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Grow_to(uint)+48j
.text$mn:0000E000                 mov     eax, [ebp+var_4]
.text$mn:0000E003                 mov     esp, ebp
.text$mn:0000E005                 pop     ebp
.text$mn:0000E006                 retn    4
.text$mn:0000E006 ?_Grow_to@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEII@Z endp
.text$mn:0000E006
.text$mn:0000E006 ; ---------------------------------------------------------------------------
.text$mn:0000E009                 align 4
.text$mn:0000E009 _text$mn        ends
.text$mn:0000E009
.text$mn:0000E00C ; ===========================================================================
.text$mn:0000E00C
.text$mn:0000E00C ; Segment type: Pure code
.text$mn:0000E00C ; Segment permissions: Read/Execute
.text$mn:0000E00C _text$mn        segment para public 'CODE' use32
.text$mn:0000E00C                 assume cs:_text$mn
.text$mn:0000E00C                 ;org 0E00Ch
.text$mn:0000E00C ; COMDAT (pick any)
.text$mn:0000E00C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E00C
.text$mn:0000E00C ; =============== S U B R O U T I N E =======================================
.text$mn:0000E00C
.text$mn:0000E00C ; Attributes: bp-based frame
.text$mn:0000E00C
.text$mn:0000E00C ; protected: unsigned int __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Grow_to(unsigned int)const
.text$mn:0000E00C                 public ?_Grow_to@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEII@Z
.text$mn:0000E00C ?_Grow_to@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEII@Z proc near
.text$mn:0000E00C                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+45p
.text$mn:0000E00C
.text$mn:0000E00C var_C           = dword ptr -0Ch
.text$mn:0000E00C var_8           = dword ptr -8
.text$mn:0000E00C var_4           = dword ptr -4
.text$mn:0000E00C arg_0           = dword ptr  8
.text$mn:0000E00C
.text$mn:0000E00C                 push    ebp
.text$mn:0000E00D                 mov     ebp, esp
.text$mn:0000E00F                 sub     esp, 0Ch
.text$mn:0000E012                 mov     [ebp+var_8], ecx
.text$mn:0000E015                 mov     ecx, [ebp+var_8]
.text$mn:0000E018                 call    ?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::capacity(void)
.text$mn:0000E01D                 mov     [ebp+var_4], eax
.text$mn:0000E020                 mov     ecx, [ebp+var_8]
.text$mn:0000E023                 call    ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(void)
.text$mn:0000E028                 mov     ecx, [ebp+var_4]
.text$mn:0000E02B                 shr     ecx, 1
.text$mn:0000E02D                 sub     eax, ecx
.text$mn:0000E02F                 cmp     eax, [ebp+var_4]
.text$mn:0000E032                 jnb     short loc_E03D
.text$mn:0000E034                 mov     [ebp+var_C], 0
.text$mn:0000E03B                 jmp     short loc_E048
.text$mn:0000E03D ; ---------------------------------------------------------------------------
.text$mn:0000E03D
.text$mn:0000E03D loc_E03D:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)+26j
.text$mn:0000E03D                 mov     edx, [ebp+var_4]
.text$mn:0000E040                 shr     edx, 1
.text$mn:0000E042                 add     edx, [ebp+var_4]
.text$mn:0000E045                 mov     [ebp+var_C], edx
.text$mn:0000E048
.text$mn:0000E048 loc_E048:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)+2Fj
.text$mn:0000E048                 mov     eax, [ebp+var_C]
.text$mn:0000E04B                 mov     [ebp+var_4], eax
.text$mn:0000E04E                 mov     ecx, [ebp+var_4]
.text$mn:0000E051                 cmp     ecx, [ebp+arg_0]
.text$mn:0000E054                 jnb     short loc_E05C
.text$mn:0000E056                 mov     edx, [ebp+arg_0]
.text$mn:0000E059                 mov     [ebp+var_4], edx
.text$mn:0000E05C
.text$mn:0000E05C loc_E05C:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)+48j
.text$mn:0000E05C                 mov     eax, [ebp+var_4]
.text$mn:0000E05F                 mov     esp, ebp
.text$mn:0000E061                 pop     ebp
.text$mn:0000E062                 retn    4
.text$mn:0000E062 ?_Grow_to@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEII@Z endp
.text$mn:0000E062
.text$mn:0000E062 ; ---------------------------------------------------------------------------
.text$mn:0000E065                 align 4
.text$mn:0000E065 _text$mn        ends
.text$mn:0000E065
.text$mn:0000E068 ; ===========================================================================
.text$mn:0000E068
.text$mn:0000E068 ; Segment type: Pure code
.text$mn:0000E068 ; Segment permissions: Read/Execute
.text$mn:0000E068 _text$mn        segment para public 'CODE' use32
.text$mn:0000E068                 assume cs:_text$mn
.text$mn:0000E068                 ;org 0E068h
.text$mn:0000E068 ; COMDAT (pick any)
.text$mn:0000E068                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E068
.text$mn:0000E068 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E068
.text$mn:0000E068 ; Attributes: bp-based frame
.text$mn:0000E068
.text$mn:0000E068 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:0000E068                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:0000E068 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:0000E068                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:0000E068
.text$mn:0000E068 var_4           = dword ptr -4
.text$mn:0000E068 arg_0           = dword ptr  8
.text$mn:0000E068
.text$mn:0000E068                 push    ebp
.text$mn:0000E069                 mov     ebp, esp
.text$mn:0000E06B                 push    ecx
.text$mn:0000E06C                 mov     [ebp+var_4], ecx
.text$mn:0000E06F                 cmp     [ebp+arg_0], 0
.text$mn:0000E073                 jz      short loc_E095
.text$mn:0000E075                 mov     ecx, [ebp+var_4]
.text$mn:0000E078                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000E07D                 cmp     [ebp+arg_0], eax
.text$mn:0000E080                 jb      short loc_E095
.text$mn:0000E082                 mov     ecx, [ebp+var_4]
.text$mn:0000E085                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000E08A                 mov     ecx, [ebp+var_4]
.text$mn:0000E08D                 add     eax, [ecx+14h]
.text$mn:0000E090                 cmp     eax, [ebp+arg_0]
.text$mn:0000E093                 ja      short loc_E09B
.text$mn:0000E095
.text$mn:0000E095 loc_E095:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:0000E095                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:0000E095                 xor     al, al
.text$mn:0000E097                 jmp     short loc_E09D
.text$mn:0000E099 ; ---------------------------------------------------------------------------
.text$mn:0000E099                 jmp     short loc_E09D
.text$mn:0000E09B ; ---------------------------------------------------------------------------
.text$mn:0000E09B
.text$mn:0000E09B loc_E09B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000E09B                 mov     al, 1
.text$mn:0000E09D
.text$mn:0000E09D loc_E09D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:0000E09D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:0000E09D                 mov     esp, ebp
.text$mn:0000E09F                 pop     ebp
.text$mn:0000E0A0                 retn    4
.text$mn:0000E0A0 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:0000E0A0
.text$mn:0000E0A0 ; ---------------------------------------------------------------------------
.text$mn:0000E0A3                 align 4
.text$mn:0000E0A3 _text$mn        ends
.text$mn:0000E0A3
.text$mn:0000E0A4 ; ===========================================================================
.text$mn:0000E0A4
.text$mn:0000E0A4 ; Segment type: Pure code
.text$mn:0000E0A4 ; Segment permissions: Read/Execute
.text$mn:0000E0A4 _text$mn        segment para public 'CODE' use32
.text$mn:0000E0A4                 assume cs:_text$mn
.text$mn:0000E0A4                 ;org 0E0A4h
.text$mn:0000E0A4 ; COMDAT (pick any)
.text$mn:0000E0A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E0A4
.text$mn:0000E0A4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E0A4
.text$mn:0000E0A4 ; Attributes: bp-based frame
.text$mn:0000E0A4
.text$mn:0000E0A4 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:0000E0A4                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:0000E0A4 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:0000E0A4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+2Cp
.text$mn:0000E0A4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap ...
.text$mn:0000E0A4
.text$mn:0000E0A4 var_4           = dword ptr -4
.text$mn:0000E0A4 arg_0           = dword ptr  8
.text$mn:0000E0A4
.text$mn:0000E0A4                 push    ebp
.text$mn:0000E0A5                 mov     ebp, esp
.text$mn:0000E0A7                 push    ecx
.text$mn:0000E0A8                 mov     [ebp+var_4], ecx
.text$mn:0000E0AB                 cmp     [ebp+arg_0], 0
.text$mn:0000E0AF                 jz      short loc_E0D4
.text$mn:0000E0B1                 mov     ecx, [ebp+var_4]
.text$mn:0000E0B4                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000E0B9                 cmp     [ebp+arg_0], eax
.text$mn:0000E0BC                 jb      short loc_E0D4
.text$mn:0000E0BE                 mov     ecx, [ebp+var_4]
.text$mn:0000E0C1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000E0C6                 mov     ecx, [ebp+var_4]
.text$mn:0000E0C9                 mov     edx, [ecx+14h]
.text$mn:0000E0CC                 lea     eax, [eax+edx*2]
.text$mn:0000E0CF                 cmp     eax, [ebp+arg_0]
.text$mn:0000E0D2                 ja      short loc_E0DA
.text$mn:0000E0D4
.text$mn:0000E0D4 loc_E0D4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:0000E0D4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:0000E0D4                 xor     al, al
.text$mn:0000E0D6                 jmp     short loc_E0DC
.text$mn:0000E0D8 ; ---------------------------------------------------------------------------
.text$mn:0000E0D8                 jmp     short loc_E0DC
.text$mn:0000E0DA ; ---------------------------------------------------------------------------
.text$mn:0000E0DA
.text$mn:0000E0DA loc_E0DA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:0000E0DA                 mov     al, 1
.text$mn:0000E0DC
.text$mn:0000E0DC loc_E0DC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:0000E0DC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:0000E0DC                 mov     esp, ebp
.text$mn:0000E0DE                 pop     ebp
.text$mn:0000E0DF                 retn    4
.text$mn:0000E0DF ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:0000E0DF
.text$mn:0000E0DF ; ---------------------------------------------------------------------------
.text$mn:0000E0E2                 align 4
.text$mn:0000E0E2 _text$mn        ends
.text$mn:0000E0E2
.text$mn:0000E0E4 ; ===========================================================================
.text$mn:0000E0E4
.text$mn:0000E0E4 ; Segment type: Pure code
.text$mn:0000E0E4 ; Segment permissions: Read/Execute
.text$mn:0000E0E4 _text$mn        segment para public 'CODE' use32
.text$mn:0000E0E4                 assume cs:_text$mn
.text$mn:0000E0E4                 ;org 0E0E4h
.text$mn:0000E0E4 ; COMDAT (pick any)
.text$mn:0000E0E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E0E4
.text$mn:0000E0E4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E0E4
.text$mn:0000E0E4 ; Attributes: bp-based frame
.text$mn:0000E0E4
.text$mn:0000E0E4 ; protected: bool __thiscall std::vector<int, class std::allocator<int>>::_Inside(int const *)const
.text$mn:0000E0E4                 public ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z
.text$mn:0000E0E4 ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z proc near
.text$mn:0000E0E4                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+19p
.text$mn:0000E0E4
.text$mn:0000E0E4 var_8           = dword ptr -8
.text$mn:0000E0E4 var_4           = dword ptr -4
.text$mn:0000E0E4 arg_0           = dword ptr  8
.text$mn:0000E0E4
.text$mn:0000E0E4                 push    ebp
.text$mn:0000E0E5                 mov     ebp, esp
.text$mn:0000E0E7                 sub     esp, 8
.text$mn:0000E0EA                 mov     [ebp+var_4], ecx
.text$mn:0000E0ED                 mov     eax, [ebp+var_4]
.text$mn:0000E0F0                 mov     ecx, [ebp+arg_0]
.text$mn:0000E0F3                 cmp     ecx, [eax+8]
.text$mn:0000E0F6                 jnb     short loc_E10C
.text$mn:0000E0F8                 mov     edx, [ebp+var_4]
.text$mn:0000E0FB                 mov     eax, [edx+4]
.text$mn:0000E0FE                 cmp     eax, [ebp+arg_0]
.text$mn:0000E101                 ja      short loc_E10C
.text$mn:0000E103                 mov     [ebp+var_8], 1
.text$mn:0000E10A                 jmp     short loc_E113
.text$mn:0000E10C ; ---------------------------------------------------------------------------
.text$mn:0000E10C
.text$mn:0000E10C loc_E10C:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Inside(int const *)+12j
.text$mn:0000E10C                                         ; std::vector<int,std::allocator<int>>::_Inside(int const *)+1Dj
.text$mn:0000E10C                 mov     [ebp+var_8], 0
.text$mn:0000E113
.text$mn:0000E113 loc_E113:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Inside(int const *)+26j
.text$mn:0000E113                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000E116                 mov     esp, ebp
.text$mn:0000E118                 pop     ebp
.text$mn:0000E119                 retn    4
.text$mn:0000E119 ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z endp
.text$mn:0000E119
.text$mn:0000E119 _text$mn        ends
.text$mn:0000E119
.text$mn:0000E11C ; ===========================================================================
.text$mn:0000E11C
.text$mn:0000E11C ; Segment type: Pure code
.text$mn:0000E11C ; Segment permissions: Read/Execute
.text$mn:0000E11C _text$mn        segment para public 'CODE' use32
.text$mn:0000E11C                 assume cs:_text$mn
.text$mn:0000E11C                 ;org 0E11Ch
.text$mn:0000E11C ; COMDAT (pick any)
.text$mn:0000E11C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E11C
.text$mn:0000E11C ; =============== S U B R O U T I N E =======================================
.text$mn:0000E11C
.text$mn:0000E11C ; Attributes: bp-based frame
.text$mn:0000E11C
.text$mn:0000E11C ; protected: bool __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::_Inside(struct sessionFileInfo const *)const
.text$mn:0000E11C                 public ?_Inside@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBE_NPBUsessionFileInfo@@@Z
.text$mn:0000E11C ?_Inside@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBE_NPBUsessionFileInfo@@@Z proc near
.text$mn:0000E11C                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::push_back(sessionFileInfo &&)+19p
.text$mn:0000E11C
.text$mn:0000E11C var_8           = dword ptr -8
.text$mn:0000E11C var_4           = dword ptr -4
.text$mn:0000E11C arg_0           = dword ptr  8
.text$mn:0000E11C
.text$mn:0000E11C                 push    ebp
.text$mn:0000E11D                 mov     ebp, esp
.text$mn:0000E11F                 sub     esp, 8
.text$mn:0000E122                 mov     [ebp+var_4], ecx
.text$mn:0000E125                 mov     eax, [ebp+var_4]
.text$mn:0000E128                 mov     ecx, [ebp+arg_0]
.text$mn:0000E12B                 cmp     ecx, [eax+8]
.text$mn:0000E12E                 jnb     short loc_E144
.text$mn:0000E130                 mov     edx, [ebp+var_4]
.text$mn:0000E133                 mov     eax, [edx+4]
.text$mn:0000E136                 cmp     eax, [ebp+arg_0]
.text$mn:0000E139                 ja      short loc_E144
.text$mn:0000E13B                 mov     [ebp+var_8], 1
.text$mn:0000E142                 jmp     short loc_E14B
.text$mn:0000E144 ; ---------------------------------------------------------------------------
.text$mn:0000E144
.text$mn:0000E144 loc_E144:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Inside(sessionFileInfo const *)+12j
.text$mn:0000E144                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Inside(sessionFileInfo const *)+1Dj
.text$mn:0000E144                 mov     [ebp+var_8], 0
.text$mn:0000E14B
.text$mn:0000E14B loc_E14B:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Inside(sessionFileInfo const *)+26j
.text$mn:0000E14B                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000E14E                 mov     esp, ebp
.text$mn:0000E150                 pop     ebp
.text$mn:0000E151                 retn    4
.text$mn:0000E151 ?_Inside@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBE_NPBUsessionFileInfo@@@Z endp
.text$mn:0000E151
.text$mn:0000E151 _text$mn        ends
.text$mn:0000E151
.text$mn:0000E154 ; ===========================================================================
.text$mn:0000E154
.text$mn:0000E154 ; Segment type: Pure code
.text$mn:0000E154 ; Segment permissions: Read/Execute
.text$mn:0000E154 _text$mn        segment para public 'CODE' use32
.text$mn:0000E154                 assume cs:_text$mn
.text$mn:0000E154                 ;org 0E154h
.text$mn:0000E154 ; COMDAT (pick any)
.text$mn:0000E154                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E154
.text$mn:0000E154 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E154
.text$mn:0000E154 ; Attributes: bp-based frame
.text$mn:0000E154
.text$mn:0000E154 ; protected: bool __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Inside(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const *)const
.text$mn:0000E154                 public ?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBE_NPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
.text$mn:0000E154 ?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBE_NPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z proc near
.text$mn:0000E154                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+19p
.text$mn:0000E154
.text$mn:0000E154 var_8           = dword ptr -8
.text$mn:0000E154 var_4           = dword ptr -4
.text$mn:0000E154 arg_0           = dword ptr  8
.text$mn:0000E154
.text$mn:0000E154                 push    ebp
.text$mn:0000E155                 mov     ebp, esp
.text$mn:0000E157                 sub     esp, 8
.text$mn:0000E15A                 mov     [ebp+var_4], ecx
.text$mn:0000E15D                 mov     eax, [ebp+var_4]
.text$mn:0000E160                 mov     ecx, [ebp+arg_0]
.text$mn:0000E163                 cmp     ecx, [eax+8]
.text$mn:0000E166                 jnb     short loc_E17C
.text$mn:0000E168                 mov     edx, [ebp+var_4]
.text$mn:0000E16B                 mov     eax, [edx+4]
.text$mn:0000E16E                 cmp     eax, [ebp+arg_0]
.text$mn:0000E171                 ja      short loc_E17C
.text$mn:0000E173                 mov     [ebp+var_8], 1
.text$mn:0000E17A                 jmp     short loc_E183
.text$mn:0000E17C ; ---------------------------------------------------------------------------
.text$mn:0000E17C
.text$mn:0000E17C loc_E17C:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Inside(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const *)+12j
.text$mn:0000E17C                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Inside(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const *)+1Dj
.text$mn:0000E17C                 mov     [ebp+var_8], 0
.text$mn:0000E183
.text$mn:0000E183 loc_E183:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Inside(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const *)+26j
.text$mn:0000E183                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000E186                 mov     esp, ebp
.text$mn:0000E188                 pop     ebp
.text$mn:0000E189                 retn    4
.text$mn:0000E189 ?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBE_NPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z endp
.text$mn:0000E189
.text$mn:0000E189 _text$mn        ends
.text$mn:0000E189
.text$mn:0000E18C ; ===========================================================================
.text$mn:0000E18C
.text$mn:0000E18C ; Segment type: Pure code
.text$mn:0000E18C ; Segment permissions: Read/Execute
.text$mn:0000E18C _text$mn        segment para public 'CODE' use32
.text$mn:0000E18C                 assume cs:_text$mn
.text$mn:0000E18C                 ;org 0E18Ch
.text$mn:0000E18C ; COMDAT (pick any)
.text$mn:0000E18C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E18C
.text$mn:0000E18C ; =============== S U B R O U T I N E =======================================
.text$mn:0000E18C
.text$mn:0000E18C ; Attributes: bp-based frame
.text$mn:0000E18C
.text$mn:0000E18C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>> __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::_Make_iter(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>)const
.text$mn:0000E18C                 public ?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z
.text$mn:0000E18C ?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z proc near
.text$mn:0000E18C                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)+F7p
.text$mn:0000E18C
.text$mn:0000E18C var_14          = dword ptr -14h
.text$mn:0000E18C var_10          = dword ptr -10h
.text$mn:0000E18C var_C           = dword ptr -0Ch
.text$mn:0000E18C var_4           = dword ptr -4
.text$mn:0000E18C arg_0           = dword ptr  8
.text$mn:0000E18C arg_4           = byte ptr  0Ch
.text$mn:0000E18C arg_C           = dword ptr  14h
.text$mn:0000E18C
.text$mn:0000E18C                 push    ebp
.text$mn:0000E18D                 mov     ebp, esp
.text$mn:0000E18F                 push    0FFFFFFFFh
.text$mn:0000E191                 push    offset __ehhandler$?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z
.text$mn:0000E196                 mov     eax, large fs:0
.text$mn:0000E19C                 push    eax
.text$mn:0000E19D                 sub     esp, 8
.text$mn:0000E1A0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000E1A5                 xor     eax, ebp
.text$mn:0000E1A7                 push    eax
.text$mn:0000E1A8                 lea     eax, [ebp+var_C]
.text$mn:0000E1AB                 mov     large fs:0, eax
.text$mn:0000E1B1                 mov     [ebp+var_14], ecx
.text$mn:0000E1B4                 mov     [ebp+var_10], 0
.text$mn:0000E1BB                 mov     [ebp+var_4], 1
.text$mn:0000E1C2                 mov     eax, [ebp+var_14]
.text$mn:0000E1C5                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000E1C6                 mov     ecx, [ebp+arg_C]
.text$mn:0000E1C9                 push    ecx             ; int
.text$mn:0000E1CA                 mov     ecx, [ebp+arg_0]
.text$mn:0000E1CD                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(sessionFileInfo *,std::_Container_base12 const *)
.text$mn:0000E1D2                 mov     edx, [ebp+var_10]
.text$mn:0000E1D5                 or      edx, 1
.text$mn:0000E1D8                 mov     [ebp+var_10], edx
.text$mn:0000E1DB                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000E1DF                 lea     ecx, [ebp+arg_4]
.text$mn:0000E1E2                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:0000E1E7                 mov     eax, [ebp+arg_0]
.text$mn:0000E1EA                 mov     ecx, [ebp+var_C]
.text$mn:0000E1ED                 mov     large fs:0, ecx
.text$mn:0000E1F4                 pop     ecx
.text$mn:0000E1F5                 mov     esp, ebp
.text$mn:0000E1F7                 pop     ebp
.text$mn:0000E1F8                 retn    10h
.text$mn:0000E1F8 ?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z endp
.text$mn:0000E1F8
.text$mn:0000E1F8 ; ---------------------------------------------------------------------------
.text$mn:0000E1FB                 align 4
.text$mn:0000E1FB _text$mn        ends
.text$mn:0000E1FB
.text$x:0000E1FC ; ===========================================================================
.text$x:0000E1FC
.text$x:0000E1FC ; Segment type: Pure code
.text$x:0000E1FC ; Segment permissions: Read/Execute
.text$x:0000E1FC _text$x         segment para public 'CODE' use32
.text$x:0000E1FC                 assume cs:_text$x
.text$x:0000E1FC                 ;org 0E1FCh
.text$x:0000E1FC ; COMDAT (pick associative to section at E18C)
.text$x:0000E1FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000E1FC
.text$x:0000E1FC ; =============== S U B R O U T I N E =======================================
.text$x:0000E1FC
.text$x:0000E1FC
.text$x:0000E1FC __unwindfunclet$?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$0 proc near
.text$x:0000E1FC                                         ; DATA XREF: .xdata$x:00013260o
.text$x:0000E1FC                 lea     ecx, [ebp+0Ch]
.text$x:0000E1FF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:0000E1FF __unwindfunclet$?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$0 endp
.text$x:0000E1FF
.text$x:0000E204
.text$x:0000E204 ; =============== S U B R O U T I N E =======================================
.text$x:0000E204
.text$x:0000E204
.text$x:0000E204 __unwindfunclet$?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$1 proc near
.text$x:0000E204                                         ; DATA XREF: .xdata$x:00013258o
.text$x:0000E204                 mov     eax, [ebp-10h]
.text$x:0000E207                 and     eax, 1
.text$x:0000E20A                 jz      $LN5
.text$x:0000E210                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000E214                 mov     ecx, [ebp+8]
.text$x:0000E217                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:0000E21C ; ---------------------------------------------------------------------------
.text$x:0000E21C
.text$x:0000E21C $LN5:                                   ; CODE XREF: __unwindfunclet$?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$1+6j
.text$x:0000E21C                 retn
.text$x:0000E21C __unwindfunclet$?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$1 endp
.text$x:0000E21C
.text$x:0000E21D
.text$x:0000E21D ; =============== S U B R O U T I N E =======================================
.text$x:0000E21D
.text$x:0000E21D
.text$x:0000E21D __ehhandler$?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z proc near
.text$x:0000E21D                                         ; DATA XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)+5o
.text$x:0000E21D
.text$x:0000E21D arg_4           = dword ptr  8
.text$x:0000E21D
.text$x:0000E21D                 mov     edx, [esp+arg_4]
.text$x:0000E221                 lea     eax, [edx+0Ch]
.text$x:0000E224                 mov     ecx, [edx-0Ch]
.text$x:0000E227                 xor     ecx, eax
.text$x:0000E229                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000E22E                 mov     eax, offset __ehfuncinfo$?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z
.text$x:0000E233                 jmp     ___CxxFrameHandler3
.text$x:0000E233 __ehhandler$?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z endp
.text$x:0000E233
.text$x:0000E233 _text$x         ends
.text$x:0000E233
.text$mn:0000E238 ; ===========================================================================
.text$mn:0000E238
.text$mn:0000E238 ; Segment type: Pure code
.text$mn:0000E238 ; Segment permissions: Read/Execute
.text$mn:0000E238 _text$mn        segment para public 'CODE' use32
.text$mn:0000E238                 assume cs:_text$mn
.text$mn:0000E238                 ;org 0E238h
.text$mn:0000E238 ; COMDAT (pick any)
.text$mn:0000E238                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E238
.text$mn:0000E238 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E238
.text$mn:0000E238 ; Attributes: bp-based frame
.text$mn:0000E238
.text$mn:0000E238 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000E238                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:0000E238 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:0000E238                                         ; CODE XREF: $LN19+14p
.text$mn:0000E238                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:0000E238
.text$mn:0000E238 var_8           = dword ptr -8
.text$mn:0000E238 var_4           = dword ptr -4
.text$mn:0000E238
.text$mn:0000E238                 push    ebp
.text$mn:0000E239                 mov     ebp, esp
.text$mn:0000E23B                 sub     esp, 8
.text$mn:0000E23E                 mov     [ebp+var_4], ecx
.text$mn:0000E241                 mov     eax, [ebp+var_4]
.text$mn:0000E244                 cmp     dword ptr [eax+18h], 10h
.text$mn:0000E248                 jb      short loc_E25E
.text$mn:0000E24A                 mov     ecx, [ebp+var_4]
.text$mn:0000E24D                 mov     edx, [ecx+4]
.text$mn:0000E250                 push    edx
.text$mn:0000E251                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000E256                 add     esp, 4
.text$mn:0000E259                 mov     [ebp+var_8], eax
.text$mn:0000E25C                 jmp     short loc_E267
.text$mn:0000E25E ; ---------------------------------------------------------------------------
.text$mn:0000E25E
.text$mn:0000E25E loc_E25E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000E25E                 mov     eax, [ebp+var_4]
.text$mn:0000E261                 add     eax, 4
.text$mn:0000E264                 mov     [ebp+var_8], eax
.text$mn:0000E267
.text$mn:0000E267 loc_E267:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000E267                 mov     eax, [ebp+var_8]
.text$mn:0000E26A                 mov     esp, ebp
.text$mn:0000E26C                 pop     ebp
.text$mn:0000E26D                 retn
.text$mn:0000E26D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:0000E26D
.text$mn:0000E26D ; ---------------------------------------------------------------------------
.text$mn:0000E26E                 align 10h
.text$mn:0000E26E _text$mn        ends
.text$mn:0000E26E
.text$mn:0000E270 ; ===========================================================================
.text$mn:0000E270
.text$mn:0000E270 ; Segment type: Pure code
.text$mn:0000E270 ; Segment permissions: Read/Execute
.text$mn:0000E270 _text$mn        segment para public 'CODE' use32
.text$mn:0000E270                 assume cs:_text$mn
.text$mn:0000E270                 ;org 0E270h
.text$mn:0000E270 ; COMDAT (pick any)
.text$mn:0000E270                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E270
.text$mn:0000E270 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E270
.text$mn:0000E270 ; Attributes: bp-based frame
.text$mn:0000E270
.text$mn:0000E270 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:0000E270                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:0000E270 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:0000E270                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:0000E270
.text$mn:0000E270 var_8           = dword ptr -8
.text$mn:0000E270 var_4           = dword ptr -4
.text$mn:0000E270
.text$mn:0000E270                 push    ebp
.text$mn:0000E271                 mov     ebp, esp
.text$mn:0000E273                 sub     esp, 8
.text$mn:0000E276                 mov     [ebp+var_4], ecx
.text$mn:0000E279                 mov     eax, [ebp+var_4]
.text$mn:0000E27C                 cmp     dword ptr [eax+18h], 10h
.text$mn:0000E280                 jb      short loc_E296
.text$mn:0000E282                 mov     ecx, [ebp+var_4]
.text$mn:0000E285                 mov     edx, [ecx+4]
.text$mn:0000E288                 push    edx
.text$mn:0000E289                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000E28E                 add     esp, 4
.text$mn:0000E291                 mov     [ebp+var_8], eax
.text$mn:0000E294                 jmp     short loc_E29F
.text$mn:0000E296 ; ---------------------------------------------------------------------------
.text$mn:0000E296
.text$mn:0000E296 loc_E296:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000E296                 mov     eax, [ebp+var_4]
.text$mn:0000E299                 add     eax, 4
.text$mn:0000E29C                 mov     [ebp+var_8], eax
.text$mn:0000E29F
.text$mn:0000E29F loc_E29F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000E29F                 mov     eax, [ebp+var_8]
.text$mn:0000E2A2                 mov     esp, ebp
.text$mn:0000E2A4                 pop     ebp
.text$mn:0000E2A5                 retn
.text$mn:0000E2A5 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:0000E2A5
.text$mn:0000E2A5 ; ---------------------------------------------------------------------------
.text$mn:0000E2A6                 align 4
.text$mn:0000E2A6 _text$mn        ends
.text$mn:0000E2A6
.text$mn:0000E2A8 ; ===========================================================================
.text$mn:0000E2A8
.text$mn:0000E2A8 ; Segment type: Pure code
.text$mn:0000E2A8 ; Segment permissions: Read/Execute
.text$mn:0000E2A8 _text$mn        segment para public 'CODE' use32
.text$mn:0000E2A8                 assume cs:_text$mn
.text$mn:0000E2A8                 ;org 0E2A8h
.text$mn:0000E2A8 ; COMDAT (pick any)
.text$mn:0000E2A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E2A8
.text$mn:0000E2A8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E2A8
.text$mn:0000E2A8 ; Attributes: bp-based frame
.text$mn:0000E2A8
.text$mn:0000E2A8 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000E2A8                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:0000E2A8 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:0000E2A8                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+27p
.text$mn:0000E2A8                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+3Ep ...
.text$mn:0000E2A8
.text$mn:0000E2A8 var_8           = dword ptr -8
.text$mn:0000E2A8 var_4           = dword ptr -4
.text$mn:0000E2A8
.text$mn:0000E2A8                 push    ebp
.text$mn:0000E2A9                 mov     ebp, esp
.text$mn:0000E2AB                 sub     esp, 8
.text$mn:0000E2AE                 mov     [ebp+var_4], ecx
.text$mn:0000E2B1                 mov     eax, [ebp+var_4]
.text$mn:0000E2B4                 cmp     dword ptr [eax+18h], 8
.text$mn:0000E2B8                 jb      short loc_E2CE
.text$mn:0000E2BA                 mov     ecx, [ebp+var_4]
.text$mn:0000E2BD                 mov     edx, [ecx+4]
.text$mn:0000E2C0                 push    edx
.text$mn:0000E2C1                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000E2C6                 add     esp, 4
.text$mn:0000E2C9                 mov     [ebp+var_8], eax
.text$mn:0000E2CC                 jmp     short loc_E2D7
.text$mn:0000E2CE ; ---------------------------------------------------------------------------
.text$mn:0000E2CE
.text$mn:0000E2CE loc_E2CE:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:0000E2CE                 mov     eax, [ebp+var_4]
.text$mn:0000E2D1                 add     eax, 4
.text$mn:0000E2D4                 mov     [ebp+var_8], eax
.text$mn:0000E2D7
.text$mn:0000E2D7 loc_E2D7:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:0000E2D7                 mov     eax, [ebp+var_8]
.text$mn:0000E2DA                 mov     esp, ebp
.text$mn:0000E2DC                 pop     ebp
.text$mn:0000E2DD                 retn
.text$mn:0000E2DD ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:0000E2DD
.text$mn:0000E2DD ; ---------------------------------------------------------------------------
.text$mn:0000E2DE                 align 10h
.text$mn:0000E2DE _text$mn        ends
.text$mn:0000E2DE
.text$mn:0000E2E0 ; ===========================================================================
.text$mn:0000E2E0
.text$mn:0000E2E0 ; Segment type: Pure code
.text$mn:0000E2E0 ; Segment permissions: Read/Execute
.text$mn:0000E2E0 _text$mn        segment para public 'CODE' use32
.text$mn:0000E2E0                 assume cs:_text$mn
.text$mn:0000E2E0                 ;org 0E2E0h
.text$mn:0000E2E0 ; COMDAT (pick any)
.text$mn:0000E2E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E2E0
.text$mn:0000E2E0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E2E0
.text$mn:0000E2E0 ; Attributes: bp-based frame
.text$mn:0000E2E0
.text$mn:0000E2E0 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:0000E2E0                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:0000E2E0 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:0000E2E0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+80p
.text$mn:0000E2E0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp ...
.text$mn:0000E2E0
.text$mn:0000E2E0 var_8           = dword ptr -8
.text$mn:0000E2E0 var_4           = dword ptr -4
.text$mn:0000E2E0
.text$mn:0000E2E0                 push    ebp
.text$mn:0000E2E1                 mov     ebp, esp
.text$mn:0000E2E3                 sub     esp, 8
.text$mn:0000E2E6                 mov     [ebp+var_4], ecx
.text$mn:0000E2E9                 mov     eax, [ebp+var_4]
.text$mn:0000E2EC                 cmp     dword ptr [eax+18h], 8
.text$mn:0000E2F0                 jb      short loc_E306
.text$mn:0000E2F2                 mov     ecx, [ebp+var_4]
.text$mn:0000E2F5                 mov     edx, [ecx+4]
.text$mn:0000E2F8                 push    edx
.text$mn:0000E2F9                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000E2FE                 add     esp, 4
.text$mn:0000E301                 mov     [ebp+var_8], eax
.text$mn:0000E304                 jmp     short loc_E30F
.text$mn:0000E306 ; ---------------------------------------------------------------------------
.text$mn:0000E306
.text$mn:0000E306 loc_E306:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:0000E306                 mov     eax, [ebp+var_4]
.text$mn:0000E309                 add     eax, 4
.text$mn:0000E30C                 mov     [ebp+var_8], eax
.text$mn:0000E30F
.text$mn:0000E30F loc_E30F:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:0000E30F                 mov     eax, [ebp+var_8]
.text$mn:0000E312                 mov     esp, ebp
.text$mn:0000E314                 pop     ebp
.text$mn:0000E315                 retn
.text$mn:0000E315 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:0000E315
.text$mn:0000E315 ; ---------------------------------------------------------------------------
.text$mn:0000E316                 align 4
.text$mn:0000E316 _text$mn        ends
.text$mn:0000E316
.text$mn:0000E318 ; ===========================================================================
.text$mn:0000E318
.text$mn:0000E318 ; Segment type: Pure code
.text$mn:0000E318 ; Segment permissions: Read/Execute
.text$mn:0000E318 _text$mn        segment para public 'CODE' use32
.text$mn:0000E318                 assume cs:_text$mn
.text$mn:0000E318                 ;org 0E318h
.text$mn:0000E318 ; COMDAT (pick any)
.text$mn:0000E318                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E318
.text$mn:0000E318 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E318
.text$mn:0000E318 ; Attributes: bp-based frame
.text$mn:0000E318
.text$mn:0000E318 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:0000E318                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000E318 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:0000E318                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:0000E318                                         ; std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+88p ...
.text$mn:0000E318
.text$mn:0000E318 var_18          = byte ptr -18h
.text$mn:0000E318 var_14          = dword ptr -14h
.text$mn:0000E318 var_10          = dword ptr -10h
.text$mn:0000E318 var_C           = dword ptr -0Ch
.text$mn:0000E318 var_4           = dword ptr -4
.text$mn:0000E318
.text$mn:0000E318                 push    ebp
.text$mn:0000E319                 mov     ebp, esp
.text$mn:0000E31B                 push    0FFFFFFFFh
.text$mn:0000E31D                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000E322                 mov     eax, large fs:0
.text$mn:0000E328                 push    eax
.text$mn:0000E329                 sub     esp, 0Ch
.text$mn:0000E32C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000E331                 xor     eax, ebp
.text$mn:0000E333                 push    eax
.text$mn:0000E334                 lea     eax, [ebp+var_C]
.text$mn:0000E337                 mov     large fs:0, eax
.text$mn:0000E33D                 mov     [ebp+var_14], ecx
.text$mn:0000E340                 mov     eax, [ebp+var_14]
.text$mn:0000E343                 cmp     dword ptr [eax], 0
.text$mn:0000E346                 jz      short loc_E3A3
.text$mn:0000E348                 push    3               ; int
.text$mn:0000E34A                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000E34D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000E352                 mov     [ebp+var_4], 0
.text$mn:0000E359                 mov     ecx, [ebp+var_14]
.text$mn:0000E35C                 mov     edx, [ecx]
.text$mn:0000E35E                 add     edx, 4
.text$mn:0000E361                 mov     [ebp+var_10], edx
.text$mn:0000E364                 jmp     short loc_E373
.text$mn:0000E366 ; ---------------------------------------------------------------------------
.text$mn:0000E366
.text$mn:0000E366 loc_E366:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:0000E366                 mov     eax, [ebp+var_10]
.text$mn:0000E369                 mov     ecx, [eax]
.text$mn:0000E36B                 mov     edx, [ebp+var_10]
.text$mn:0000E36E                 mov     eax, [ecx+4]
.text$mn:0000E371                 mov     [edx], eax
.text$mn:0000E373
.text$mn:0000E373 loc_E373:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:0000E373                 mov     ecx, [ebp+var_10]
.text$mn:0000E376                 cmp     dword ptr [ecx], 0
.text$mn:0000E379                 jz      short loc_E388
.text$mn:0000E37B                 mov     edx, [ebp+var_10]
.text$mn:0000E37E                 mov     eax, [edx]
.text$mn:0000E380                 mov     dword ptr [eax], 0
.text$mn:0000E386                 jmp     short loc_E366
.text$mn:0000E388 ; ---------------------------------------------------------------------------
.text$mn:0000E388
.text$mn:0000E388 loc_E388:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:0000E388                 mov     ecx, [ebp+var_14]
.text$mn:0000E38B                 mov     edx, [ecx]
.text$mn:0000E38D                 mov     dword ptr [edx+4], 0
.text$mn:0000E394                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000E39B                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000E39E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000E3A3
.text$mn:0000E3A3 loc_E3A3:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:0000E3A3                 mov     ecx, [ebp+var_C]
.text$mn:0000E3A6                 mov     large fs:0, ecx
.text$mn:0000E3AD                 pop     ecx
.text$mn:0000E3AE                 mov     esp, ebp
.text$mn:0000E3B0                 pop     ebp
.text$mn:0000E3B1                 retn
.text$mn:0000E3B1 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:0000E3B1
.text$mn:0000E3B1 ; ---------------------------------------------------------------------------
.text$mn:0000E3B2                 align 4
.text$mn:0000E3B2 _text$mn        ends
.text$mn:0000E3B2
.text$x:0000E3B4 ; ===========================================================================
.text$x:0000E3B4
.text$x:0000E3B4 ; Segment type: Pure code
.text$x:0000E3B4 ; Segment permissions: Read/Execute
.text$x:0000E3B4 _text$x         segment para public 'CODE' use32
.text$x:0000E3B4                 assume cs:_text$x
.text$x:0000E3B4                 ;org 0E3B4h
.text$x:0000E3B4 ; COMDAT (pick associative to section at E318)
.text$x:0000E3B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000E3B4
.text$x:0000E3B4 ; =============== S U B R O U T I N E =======================================
.text$x:0000E3B4
.text$x:0000E3B4
.text$x:0000E3B4 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:0000E3B4                                         ; DATA XREF: .xdata$x:00012370o
.text$x:0000E3B4                 lea     ecx, [ebp-18h]  ; this
.text$x:0000E3B7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000E3B7 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:0000E3B7
.text$x:0000E3BC
.text$x:0000E3BC ; =============== S U B R O U T I N E =======================================
.text$x:0000E3BC
.text$x:0000E3BC
.text$x:0000E3BC __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:0000E3BC                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:0000E3BC
.text$x:0000E3BC arg_4           = dword ptr  8
.text$x:0000E3BC
.text$x:0000E3BC                 mov     edx, [esp+arg_4]
.text$x:0000E3C0                 lea     eax, [edx+0Ch]
.text$x:0000E3C3                 mov     ecx, [edx-10h]
.text$x:0000E3C6                 xor     ecx, eax
.text$x:0000E3C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000E3CD                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:0000E3D2                 jmp     ___CxxFrameHandler3
.text$x:0000E3D2 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:0000E3D2
.text$x:0000E3D2 ; ---------------------------------------------------------------------------
.text$x:0000E3D7                 align 4
.text$x:0000E3D7 _text$x         ends
.text$x:0000E3D7
.text$mn:0000E3D8 ; ===========================================================================
.text$mn:0000E3D8
.text$mn:0000E3D8 ; Segment type: Pure code
.text$mn:0000E3D8 ; Segment permissions: Read/Execute
.text$mn:0000E3D8 _text$mn        segment para public 'CODE' use32
.text$mn:0000E3D8                 assume cs:_text$mn
.text$mn:0000E3D8                 ;org 0E3D8h
.text$mn:0000E3D8 ; COMDAT (pick any)
.text$mn:0000E3D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E3D8
.text$mn:0000E3D8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E3D8
.text$mn:0000E3D8 ; Attributes: bp-based frame
.text$mn:0000E3D8
.text$mn:0000E3D8 ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:0000E3D8                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:0000E3D8 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:0000E3D8                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:0000E3D8                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:0000E3D8
.text$mn:0000E3D8 var_8           = dword ptr -8
.text$mn:0000E3D8 var_4           = dword ptr -4
.text$mn:0000E3D8
.text$mn:0000E3D8                 push    ebp
.text$mn:0000E3D9                 mov     ebp, esp
.text$mn:0000E3DB                 sub     esp, 8
.text$mn:0000E3DE                 mov     [ebp+var_8], ecx
.text$mn:0000E3E1                 mov     eax, [ebp+var_8]
.text$mn:0000E3E4                 cmp     dword ptr [eax], 0
.text$mn:0000E3E7                 jz      short loc_E446
.text$mn:0000E3E9                 mov     ecx, [ebp+var_8]
.text$mn:0000E3EC                 mov     edx, [ecx]
.text$mn:0000E3EE                 add     edx, 4
.text$mn:0000E3F1                 mov     [ebp+var_4], edx
.text$mn:0000E3F4
.text$mn:0000E3F4 loc_E3F4:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:0000E3F4                 mov     eax, [ebp+var_4]
.text$mn:0000E3F7                 cmp     dword ptr [eax], 0
.text$mn:0000E3FA                 jz      short loc_E413
.text$mn:0000E3FC                 mov     ecx, [ebp+var_4]
.text$mn:0000E3FF                 mov     edx, [ecx]
.text$mn:0000E401                 cmp     edx, [ebp+var_8]
.text$mn:0000E404                 jz      short loc_E413
.text$mn:0000E406                 mov     eax, [ebp+var_4]
.text$mn:0000E409                 mov     ecx, [eax]
.text$mn:0000E40B                 add     ecx, 4
.text$mn:0000E40E                 mov     [ebp+var_4], ecx
.text$mn:0000E411                 jmp     short loc_E3F4
.text$mn:0000E413 ; ---------------------------------------------------------------------------
.text$mn:0000E413
.text$mn:0000E413 loc_E413:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:0000E413                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:0000E413                 mov     edx, [ebp+var_4]
.text$mn:0000E416                 cmp     dword ptr [edx], 0
.text$mn:0000E419                 jnz     short loc_E432
.text$mn:0000E41B                 push    0C9h ; '+'      ; unsigned int
.text$mn:0000E420                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000E425                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:0000E42A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000E42F                 add     esp, 0Ch
.text$mn:0000E432
.text$mn:0000E432 loc_E432:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:0000E432                 mov     eax, [ebp+var_4]
.text$mn:0000E435                 mov     ecx, [ebp+var_8]
.text$mn:0000E438                 mov     edx, [ecx+4]
.text$mn:0000E43B                 mov     [eax], edx
.text$mn:0000E43D                 mov     eax, [ebp+var_8]
.text$mn:0000E440                 mov     dword ptr [eax], 0
.text$mn:0000E446
.text$mn:0000E446 loc_E446:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:0000E446                 mov     esp, ebp
.text$mn:0000E448                 pop     ebp
.text$mn:0000E449                 retn
.text$mn:0000E449 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:0000E449
.text$mn:0000E449 ; ---------------------------------------------------------------------------
.text$mn:0000E44A                 align 4
.text$mn:0000E44A _text$mn        ends
.text$mn:0000E44A
.text$mn:0000E44C ; ===========================================================================
.text$mn:0000E44C
.text$mn:0000E44C ; Segment type: Pure code
.text$mn:0000E44C ; Segment permissions: Read/Execute
.text$mn:0000E44C _text$mn        segment para public 'CODE' use32
.text$mn:0000E44C                 assume cs:_text$mn
.text$mn:0000E44C                 ;org 0E44Ch
.text$mn:0000E44C ; COMDAT (pick any)
.text$mn:0000E44C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E44C
.text$mn:0000E44C ; =============== S U B R O U T I N E =======================================
.text$mn:0000E44C
.text$mn:0000E44C ; Attributes: bp-based frame
.text$mn:0000E44C
.text$mn:0000E44C ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Orphan_range(int *, int *)const
.text$mn:0000E44C                 public ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.text$mn:0000E44C ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z proc near
.text$mn:0000E44C                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+66p
.text$mn:0000E44C                                         ; std::vector<int,std::allocator<int>>::push_back(int const &)+CCp
.text$mn:0000E44C
.text$mn:0000E44C var_18          = byte ptr -18h
.text$mn:0000E44C var_14          = dword ptr -14h
.text$mn:0000E44C var_10          = dword ptr -10h
.text$mn:0000E44C var_C           = dword ptr -0Ch
.text$mn:0000E44C var_4           = dword ptr -4
.text$mn:0000E44C arg_0           = dword ptr  8
.text$mn:0000E44C arg_4           = dword ptr  0Ch
.text$mn:0000E44C
.text$mn:0000E44C                 push    ebp
.text$mn:0000E44D                 mov     ebp, esp
.text$mn:0000E44F                 push    0FFFFFFFFh
.text$mn:0000E451                 push    offset __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.text$mn:0000E456                 mov     eax, large fs:0
.text$mn:0000E45C                 push    eax
.text$mn:0000E45D                 sub     esp, 0Ch
.text$mn:0000E460                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000E465                 xor     eax, ebp
.text$mn:0000E467                 push    eax
.text$mn:0000E468                 lea     eax, [ebp+var_C]
.text$mn:0000E46B                 mov     large fs:0, eax
.text$mn:0000E471                 mov     [ebp+var_14], ecx
.text$mn:0000E474                 push    3               ; int
.text$mn:0000E476                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000E479                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000E47E                 mov     [ebp+var_4], 0
.text$mn:0000E485                 mov     ecx, [ebp+var_14] ; this
.text$mn:0000E488                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:0000E48D                 mov     [ebp+var_10], eax
.text$mn:0000E490                 cmp     [ebp+var_10], 0
.text$mn:0000E494                 jz      short loc_E4E4
.text$mn:0000E496
.text$mn:0000E496 loc_E496:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *):loc_E4E2j
.text$mn:0000E496                 mov     eax, [ebp+var_10]
.text$mn:0000E499                 cmp     dword ptr [eax], 0
.text$mn:0000E49C                 jz      short loc_E4E4
.text$mn:0000E49E                 mov     ecx, [ebp+var_10]
.text$mn:0000E4A1                 mov     edx, [ecx]
.text$mn:0000E4A3                 mov     eax, [edx+8]
.text$mn:0000E4A6                 cmp     eax, [ebp+arg_0]
.text$mn:0000E4A9                 jb      short loc_E4B8
.text$mn:0000E4AB                 mov     ecx, [ebp+var_10]
.text$mn:0000E4AE                 mov     edx, [ecx]
.text$mn:0000E4B0                 mov     eax, [ebp+arg_4]
.text$mn:0000E4B3                 cmp     eax, [edx+8]
.text$mn:0000E4B6                 jnb     short loc_E4C7
.text$mn:0000E4B8
.text$mn:0000E4B8 loc_E4B8:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+5Dj
.text$mn:0000E4B8                 mov     ecx, [ebp+var_10]
.text$mn:0000E4BB                 mov     ecx, [ecx]      ; this
.text$mn:0000E4BD                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000E4C2                 mov     [ebp+var_10], eax
.text$mn:0000E4C5                 jmp     short loc_E4E2
.text$mn:0000E4C7 ; ---------------------------------------------------------------------------
.text$mn:0000E4C7
.text$mn:0000E4C7 loc_E4C7:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+6Aj
.text$mn:0000E4C7                 mov     edx, [ebp+var_10]
.text$mn:0000E4CA                 mov     ecx, [edx]      ; this
.text$mn:0000E4CC                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:0000E4D1                 mov     eax, [ebp+var_10]
.text$mn:0000E4D4                 mov     ecx, [eax]      ; this
.text$mn:0000E4D6                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000E4DB                 mov     ecx, [ebp+var_10]
.text$mn:0000E4DE                 mov     edx, [eax]
.text$mn:0000E4E0                 mov     [ecx], edx
.text$mn:0000E4E2
.text$mn:0000E4E2 loc_E4E2:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+79j
.text$mn:0000E4E2                 jmp     short loc_E496
.text$mn:0000E4E4 ; ---------------------------------------------------------------------------
.text$mn:0000E4E4
.text$mn:0000E4E4 loc_E4E4:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+48j
.text$mn:0000E4E4                                         ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+50j
.text$mn:0000E4E4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000E4EB                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000E4EE                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000E4F3                 mov     ecx, [ebp+var_C]
.text$mn:0000E4F6                 mov     large fs:0, ecx
.text$mn:0000E4FD                 pop     ecx
.text$mn:0000E4FE                 mov     esp, ebp
.text$mn:0000E500                 pop     ebp
.text$mn:0000E501                 retn    8
.text$mn:0000E501 ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z endp
.text$mn:0000E501
.text$mn:0000E501 _text$mn        ends
.text$mn:0000E501
.text$x:0000E504 ; ===========================================================================
.text$x:0000E504
.text$x:0000E504 ; Segment type: Pure code
.text$x:0000E504 ; Segment permissions: Read/Execute
.text$x:0000E504 _text$x         segment para public 'CODE' use32
.text$x:0000E504                 assume cs:_text$x
.text$x:0000E504                 ;org 0E504h
.text$x:0000E504 ; COMDAT (pick associative to section at E44C)
.text$x:0000E504                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000E504
.text$x:0000E504 ; =============== S U B R O U T I N E =======================================
.text$x:0000E504
.text$x:0000E504
.text$x:0000E504 __unwindfunclet$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z$0 proc near
.text$x:0000E504                                         ; DATA XREF: .xdata$x:00012CF0o
.text$x:0000E504                 lea     ecx, [ebp-18h]  ; this
.text$x:0000E507                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000E507 __unwindfunclet$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z$0 endp
.text$x:0000E507
.text$x:0000E50C
.text$x:0000E50C ; =============== S U B R O U T I N E =======================================
.text$x:0000E50C
.text$x:0000E50C
.text$x:0000E50C __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z proc near
.text$x:0000E50C                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+5o
.text$x:0000E50C
.text$x:0000E50C arg_4           = dword ptr  8
.text$x:0000E50C
.text$x:0000E50C                 mov     edx, [esp+arg_4]
.text$x:0000E510                 lea     eax, [edx+0Ch]
.text$x:0000E513                 mov     ecx, [edx-10h]
.text$x:0000E516                 xor     ecx, eax
.text$x:0000E518                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000E51D                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.text$x:0000E522                 jmp     ___CxxFrameHandler3
.text$x:0000E522 __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z endp
.text$x:0000E522
.text$x:0000E522 ; ---------------------------------------------------------------------------
.text$x:0000E527                 align 4
.text$x:0000E527 _text$x         ends
.text$x:0000E527
.text$mn:0000E528 ; ===========================================================================
.text$mn:0000E528
.text$mn:0000E528 ; Segment type: Pure code
.text$mn:0000E528 ; Segment permissions: Read/Execute
.text$mn:0000E528 _text$mn        segment para public 'CODE' use32
.text$mn:0000E528                 assume cs:_text$mn
.text$mn:0000E528                 ;org 0E528h
.text$mn:0000E528 ; COMDAT (pick any)
.text$mn:0000E528                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E528
.text$mn:0000E528 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E528
.text$mn:0000E528 ; Attributes: bp-based frame
.text$mn:0000E528
.text$mn:0000E528 ; protected: void __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::_Orphan_range(struct sessionFileInfo *, struct sessionFileInfo *)const
.text$mn:0000E528                 public ?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z
.text$mn:0000E528 ?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z proc near
.text$mn:0000E528                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)+B7p
.text$mn:0000E528                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::push_back(sessionFileInfo &&)+6Fp ...
.text$mn:0000E528
.text$mn:0000E528 var_18          = byte ptr -18h
.text$mn:0000E528 var_14          = dword ptr -14h
.text$mn:0000E528 var_10          = dword ptr -10h
.text$mn:0000E528 var_C           = dword ptr -0Ch
.text$mn:0000E528 var_4           = dword ptr -4
.text$mn:0000E528 arg_0           = dword ptr  8
.text$mn:0000E528 arg_4           = dword ptr  0Ch
.text$mn:0000E528
.text$mn:0000E528                 push    ebp
.text$mn:0000E529                 mov     ebp, esp
.text$mn:0000E52B                 push    0FFFFFFFFh
.text$mn:0000E52D                 push    offset __ehhandler$?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z
.text$mn:0000E532                 mov     eax, large fs:0
.text$mn:0000E538                 push    eax
.text$mn:0000E539                 sub     esp, 0Ch
.text$mn:0000E53C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000E541                 xor     eax, ebp
.text$mn:0000E543                 push    eax
.text$mn:0000E544                 lea     eax, [ebp+var_C]
.text$mn:0000E547                 mov     large fs:0, eax
.text$mn:0000E54D                 mov     [ebp+var_14], ecx
.text$mn:0000E550                 push    3               ; int
.text$mn:0000E552                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000E555                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000E55A                 mov     [ebp+var_4], 0
.text$mn:0000E561                 mov     ecx, [ebp+var_14] ; this
.text$mn:0000E564                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:0000E569                 mov     [ebp+var_10], eax
.text$mn:0000E56C                 cmp     [ebp+var_10], 0
.text$mn:0000E570                 jz      short loc_E5C0
.text$mn:0000E572
.text$mn:0000E572 loc_E572:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Orphan_range(sessionFileInfo *,sessionFileInfo *):loc_E5BEj
.text$mn:0000E572                 mov     eax, [ebp+var_10]
.text$mn:0000E575                 cmp     dword ptr [eax], 0
.text$mn:0000E578                 jz      short loc_E5C0
.text$mn:0000E57A                 mov     ecx, [ebp+var_10]
.text$mn:0000E57D                 mov     edx, [ecx]
.text$mn:0000E57F                 mov     eax, [edx+8]
.text$mn:0000E582                 cmp     eax, [ebp+arg_0]
.text$mn:0000E585                 jb      short loc_E594
.text$mn:0000E587                 mov     ecx, [ebp+var_10]
.text$mn:0000E58A                 mov     edx, [ecx]
.text$mn:0000E58C                 mov     eax, [ebp+arg_4]
.text$mn:0000E58F                 cmp     eax, [edx+8]
.text$mn:0000E592                 jnb     short loc_E5A3
.text$mn:0000E594
.text$mn:0000E594 loc_E594:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Orphan_range(sessionFileInfo *,sessionFileInfo *)+5Dj
.text$mn:0000E594                 mov     ecx, [ebp+var_10]
.text$mn:0000E597                 mov     ecx, [ecx]      ; this
.text$mn:0000E599                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000E59E                 mov     [ebp+var_10], eax
.text$mn:0000E5A1                 jmp     short loc_E5BE
.text$mn:0000E5A3 ; ---------------------------------------------------------------------------
.text$mn:0000E5A3
.text$mn:0000E5A3 loc_E5A3:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Orphan_range(sessionFileInfo *,sessionFileInfo *)+6Aj
.text$mn:0000E5A3                 mov     edx, [ebp+var_10]
.text$mn:0000E5A6                 mov     ecx, [edx]      ; this
.text$mn:0000E5A8                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:0000E5AD                 mov     eax, [ebp+var_10]
.text$mn:0000E5B0                 mov     ecx, [eax]      ; this
.text$mn:0000E5B2                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000E5B7                 mov     ecx, [ebp+var_10]
.text$mn:0000E5BA                 mov     edx, [eax]
.text$mn:0000E5BC                 mov     [ecx], edx
.text$mn:0000E5BE
.text$mn:0000E5BE loc_E5BE:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Orphan_range(sessionFileInfo *,sessionFileInfo *)+79j
.text$mn:0000E5BE                 jmp     short loc_E572
.text$mn:0000E5C0 ; ---------------------------------------------------------------------------
.text$mn:0000E5C0
.text$mn:0000E5C0 loc_E5C0:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Orphan_range(sessionFileInfo *,sessionFileInfo *)+48j
.text$mn:0000E5C0                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Orphan_range(sessionFileInfo *,sessionFileInfo *)+50j
.text$mn:0000E5C0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000E5C7                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000E5CA                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000E5CF                 mov     ecx, [ebp+var_C]
.text$mn:0000E5D2                 mov     large fs:0, ecx
.text$mn:0000E5D9                 pop     ecx
.text$mn:0000E5DA                 mov     esp, ebp
.text$mn:0000E5DC                 pop     ebp
.text$mn:0000E5DD                 retn    8
.text$mn:0000E5DD ?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z endp
.text$mn:0000E5DD
.text$mn:0000E5DD _text$mn        ends
.text$mn:0000E5DD
.text$x:0000E5E0 ; ===========================================================================
.text$x:0000E5E0
.text$x:0000E5E0 ; Segment type: Pure code
.text$x:0000E5E0 ; Segment permissions: Read/Execute
.text$x:0000E5E0 _text$x         segment para public 'CODE' use32
.text$x:0000E5E0                 assume cs:_text$x
.text$x:0000E5E0                 ;org 0E5E0h
.text$x:0000E5E0 ; COMDAT (pick associative to section at E528)
.text$x:0000E5E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000E5E0
.text$x:0000E5E0 ; =============== S U B R O U T I N E =======================================
.text$x:0000E5E0
.text$x:0000E5E0
.text$x:0000E5E0 __unwindfunclet$?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z$0 proc near
.text$x:0000E5E0                                         ; DATA XREF: .xdata$x:00013320o
.text$x:0000E5E0                 lea     ecx, [ebp-18h]  ; this
.text$x:0000E5E3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000E5E3 __unwindfunclet$?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z$0 endp
.text$x:0000E5E3
.text$x:0000E5E8
.text$x:0000E5E8 ; =============== S U B R O U T I N E =======================================
.text$x:0000E5E8
.text$x:0000E5E8
.text$x:0000E5E8 __ehhandler$?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z proc near
.text$x:0000E5E8                                         ; DATA XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Orphan_range(sessionFileInfo *,sessionFileInfo *)+5o
.text$x:0000E5E8
.text$x:0000E5E8 arg_4           = dword ptr  8
.text$x:0000E5E8
.text$x:0000E5E8                 mov     edx, [esp+arg_4]
.text$x:0000E5EC                 lea     eax, [edx+0Ch]
.text$x:0000E5EF                 mov     ecx, [edx-10h]
.text$x:0000E5F2                 xor     ecx, eax
.text$x:0000E5F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000E5F9                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z
.text$x:0000E5FE                 jmp     ___CxxFrameHandler3
.text$x:0000E5FE __ehhandler$?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z endp
.text$x:0000E5FE
.text$x:0000E5FE ; ---------------------------------------------------------------------------
.text$x:0000E603                 align 4
.text$x:0000E603 _text$x         ends
.text$x:0000E603
.text$mn:0000E604 ; ===========================================================================
.text$mn:0000E604
.text$mn:0000E604 ; Segment type: Pure code
.text$mn:0000E604 ; Segment permissions: Read/Execute
.text$mn:0000E604 _text$mn        segment para public 'CODE' use32
.text$mn:0000E604                 assume cs:_text$mn
.text$mn:0000E604                 ;org 0E604h
.text$mn:0000E604 ; COMDAT (pick any)
.text$mn:0000E604                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E604
.text$mn:0000E604 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E604
.text$mn:0000E604 ; Attributes: bp-based frame
.text$mn:0000E604
.text$mn:0000E604 ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Orphan_range(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)const
.text$mn:0000E604                 public ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.text$mn:0000E604 ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z proc near
.text$mn:0000E604                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+6Fp
.text$mn:0000E604                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+DCp
.text$mn:0000E604
.text$mn:0000E604 var_18          = byte ptr -18h
.text$mn:0000E604 var_14          = dword ptr -14h
.text$mn:0000E604 var_10          = dword ptr -10h
.text$mn:0000E604 var_C           = dword ptr -0Ch
.text$mn:0000E604 var_4           = dword ptr -4
.text$mn:0000E604 arg_0           = dword ptr  8
.text$mn:0000E604 arg_4           = dword ptr  0Ch
.text$mn:0000E604
.text$mn:0000E604                 push    ebp
.text$mn:0000E605                 mov     ebp, esp
.text$mn:0000E607                 push    0FFFFFFFFh
.text$mn:0000E609                 push    offset __ehhandler$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.text$mn:0000E60E                 mov     eax, large fs:0
.text$mn:0000E614                 push    eax
.text$mn:0000E615                 sub     esp, 0Ch
.text$mn:0000E618                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000E61D                 xor     eax, ebp
.text$mn:0000E61F                 push    eax
.text$mn:0000E620                 lea     eax, [ebp+var_C]
.text$mn:0000E623                 mov     large fs:0, eax
.text$mn:0000E629                 mov     [ebp+var_14], ecx
.text$mn:0000E62C                 push    3               ; int
.text$mn:0000E62E                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000E631                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000E636                 mov     [ebp+var_4], 0
.text$mn:0000E63D                 mov     ecx, [ebp+var_14] ; this
.text$mn:0000E640                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:0000E645                 mov     [ebp+var_10], eax
.text$mn:0000E648                 cmp     [ebp+var_10], 0
.text$mn:0000E64C                 jz      short loc_E69C
.text$mn:0000E64E
.text$mn:0000E64E loc_E64E:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *):loc_E69Aj
.text$mn:0000E64E                 mov     eax, [ebp+var_10]
.text$mn:0000E651                 cmp     dword ptr [eax], 0
.text$mn:0000E654                 jz      short loc_E69C
.text$mn:0000E656                 mov     ecx, [ebp+var_10]
.text$mn:0000E659                 mov     edx, [ecx]
.text$mn:0000E65B                 mov     eax, [edx+8]
.text$mn:0000E65E                 cmp     eax, [ebp+arg_0]
.text$mn:0000E661                 jb      short loc_E670
.text$mn:0000E663                 mov     ecx, [ebp+var_10]
.text$mn:0000E666                 mov     edx, [ecx]
.text$mn:0000E668                 mov     eax, [ebp+arg_4]
.text$mn:0000E66B                 cmp     eax, [edx+8]
.text$mn:0000E66E                 jnb     short loc_E67F
.text$mn:0000E670
.text$mn:0000E670 loc_E670:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+5Dj
.text$mn:0000E670                 mov     ecx, [ebp+var_10]
.text$mn:0000E673                 mov     ecx, [ecx]      ; this
.text$mn:0000E675                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000E67A                 mov     [ebp+var_10], eax
.text$mn:0000E67D                 jmp     short loc_E69A
.text$mn:0000E67F ; ---------------------------------------------------------------------------
.text$mn:0000E67F
.text$mn:0000E67F loc_E67F:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+6Aj
.text$mn:0000E67F                 mov     edx, [ebp+var_10]
.text$mn:0000E682                 mov     ecx, [edx]      ; this
.text$mn:0000E684                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:0000E689                 mov     eax, [ebp+var_10]
.text$mn:0000E68C                 mov     ecx, [eax]      ; this
.text$mn:0000E68E                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000E693                 mov     ecx, [ebp+var_10]
.text$mn:0000E696                 mov     edx, [eax]
.text$mn:0000E698                 mov     [ecx], edx
.text$mn:0000E69A
.text$mn:0000E69A loc_E69A:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+79j
.text$mn:0000E69A                 jmp     short loc_E64E
.text$mn:0000E69C ; ---------------------------------------------------------------------------
.text$mn:0000E69C
.text$mn:0000E69C loc_E69C:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+48j
.text$mn:0000E69C                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+50j
.text$mn:0000E69C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000E6A3                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000E6A6                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000E6AB                 mov     ecx, [ebp+var_C]
.text$mn:0000E6AE                 mov     large fs:0, ecx
.text$mn:0000E6B5                 pop     ecx
.text$mn:0000E6B6                 mov     esp, ebp
.text$mn:0000E6B8                 pop     ebp
.text$mn:0000E6B9                 retn    8
.text$mn:0000E6B9 ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z endp
.text$mn:0000E6B9
.text$mn:0000E6B9 _text$mn        ends
.text$mn:0000E6B9
.text$x:0000E6BC ; ===========================================================================
.text$x:0000E6BC
.text$x:0000E6BC ; Segment type: Pure code
.text$x:0000E6BC ; Segment permissions: Read/Execute
.text$x:0000E6BC _text$x         segment para public 'CODE' use32
.text$x:0000E6BC                 assume cs:_text$x
.text$x:0000E6BC                 ;org 0E6BCh
.text$x:0000E6BC ; COMDAT (pick associative to section at E604)
.text$x:0000E6BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000E6BC
.text$x:0000E6BC ; =============== S U B R O U T I N E =======================================
.text$x:0000E6BC
.text$x:0000E6BC
.text$x:0000E6BC __unwindfunclet$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$0 proc near
.text$x:0000E6BC                                         ; DATA XREF: .xdata$x:00013548o
.text$x:0000E6BC                 lea     ecx, [ebp-18h]  ; this
.text$x:0000E6BF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000E6BF __unwindfunclet$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$0 endp
.text$x:0000E6BF
.text$x:0000E6C4
.text$x:0000E6C4 ; =============== S U B R O U T I N E =======================================
.text$x:0000E6C4
.text$x:0000E6C4
.text$x:0000E6C4 __ehhandler$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z proc near
.text$x:0000E6C4                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+5o
.text$x:0000E6C4
.text$x:0000E6C4 arg_4           = dword ptr  8
.text$x:0000E6C4
.text$x:0000E6C4                 mov     edx, [esp+arg_4]
.text$x:0000E6C8                 lea     eax, [edx+0Ch]
.text$x:0000E6CB                 mov     ecx, [edx-10h]
.text$x:0000E6CE                 xor     ecx, eax
.text$x:0000E6D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000E6D5                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.text$x:0000E6DA                 jmp     ___CxxFrameHandler3
.text$x:0000E6DA __ehhandler$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z endp
.text$x:0000E6DA
.text$x:0000E6DA ; ---------------------------------------------------------------------------
.text$x:0000E6DF                 align 10h
.text$x:0000E6DF _text$x         ends
.text$x:0000E6DF
.text$mn:0000E6E0 ; ===========================================================================
.text$mn:0000E6E0
.text$mn:0000E6E0 ; Segment type: Pure code
.text$mn:0000E6E0 ; Segment permissions: Read/Execute
.text$mn:0000E6E0 _text$mn        segment para public 'CODE' use32
.text$mn:0000E6E0                 assume cs:_text$mn
.text$mn:0000E6E0                 ;org 0E6E0h
.text$mn:0000E6E0 ; COMDAT (pick any)
.text$mn:0000E6E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E6E0
.text$mn:0000E6E0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E6E0
.text$mn:0000E6E0 ; Attributes: bp-based frame
.text$mn:0000E6E0
.text$mn:0000E6E0 ; public: static unsigned int __cdecl std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Pdif(class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:0000E6E0                 public ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z
.text$mn:0000E6E0 ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z proc near
.text$mn:0000E6E0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+89p
.text$mn:0000E6E0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+FAp ...
.text$mn:0000E6E0
.text$mn:0000E6E0 var_14          = dword ptr -14h
.text$mn:0000E6E0 var_10          = dword ptr -10h
.text$mn:0000E6E0 var_C           = dword ptr -0Ch
.text$mn:0000E6E0 var_4           = dword ptr -4
.text$mn:0000E6E0 arg_0           = byte ptr  8
.text$mn:0000E6E0 arg_8           = dword ptr  10h
.text$mn:0000E6E0 arg_C           = byte ptr  14h
.text$mn:0000E6E0
.text$mn:0000E6E0                 push    ebp
.text$mn:0000E6E1                 mov     ebp, esp
.text$mn:0000E6E3                 push    0FFFFFFFFh
.text$mn:0000E6E5                 push    offset __ehhandler$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z
.text$mn:0000E6EA                 mov     eax, large fs:0
.text$mn:0000E6F0                 push    eax
.text$mn:0000E6F1                 sub     esp, 8
.text$mn:0000E6F4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000E6F9                 xor     eax, ebp
.text$mn:0000E6FB                 push    eax
.text$mn:0000E6FC                 lea     eax, [ebp+var_C]
.text$mn:0000E6FF                 mov     large fs:0, eax
.text$mn:0000E705                 mov     [ebp+var_4], 1
.text$mn:0000E70C                 cmp     [ebp+arg_8], 0
.text$mn:0000E710                 jnz     short loc_E71B
.text$mn:0000E712                 mov     [ebp+var_10], 0
.text$mn:0000E719                 jmp     short loc_E72A
.text$mn:0000E71B ; ---------------------------------------------------------------------------
.text$mn:0000E71B
.text$mn:0000E71B loc_E71B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+30j
.text$mn:0000E71B                 lea     eax, [ebp+arg_C]
.text$mn:0000E71E                 push    eax             ; std::_Iterator_base12 *
.text$mn:0000E71F                 lea     ecx, [ebp+arg_0]
.text$mn:0000E722                 call    ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000E727                 mov     [ebp+var_10], eax
.text$mn:0000E72A
.text$mn:0000E72A loc_E72A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+39j
.text$mn:0000E72A                 mov     ecx, [ebp+var_10]
.text$mn:0000E72D                 mov     [ebp+var_14], ecx
.text$mn:0000E730                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000E734                 lea     ecx, [ebp+arg_0]
.text$mn:0000E737                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000E73C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000E743                 lea     ecx, [ebp+arg_C]
.text$mn:0000E746                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000E74B                 mov     eax, [ebp+var_14]
.text$mn:0000E74E                 mov     ecx, [ebp+var_C]
.text$mn:0000E751                 mov     large fs:0, ecx
.text$mn:0000E758                 pop     ecx
.text$mn:0000E759                 mov     esp, ebp
.text$mn:0000E75B                 pop     ebp
.text$mn:0000E75C                 retn
.text$mn:0000E75C ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z endp
.text$mn:0000E75C
.text$mn:0000E75C ; ---------------------------------------------------------------------------
.text$mn:0000E75D                 align 10h
.text$mn:0000E75D _text$mn        ends
.text$mn:0000E75D
.text$x:0000E760 ; ===========================================================================
.text$x:0000E760
.text$x:0000E760 ; Segment type: Pure code
.text$x:0000E760 ; Segment permissions: Read/Execute
.text$x:0000E760 _text$x         segment para public 'CODE' use32
.text$x:0000E760                 assume cs:_text$x
.text$x:0000E760                 ;org 0E760h
.text$x:0000E760 ; COMDAT (pick associative to section at E6E0)
.text$x:0000E760                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000E760
.text$x:0000E760 ; =============== S U B R O U T I N E =======================================
.text$x:0000E760
.text$x:0000E760
.text$x:0000E760 __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$0 proc near
.text$x:0000E760                                         ; DATA XREF: .xdata$x:00012B04o
.text$x:0000E760                 lea     ecx, [ebp+14h]
.text$x:0000E763                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000E763 __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$0 endp
.text$x:0000E763
.text$x:0000E768
.text$x:0000E768 ; =============== S U B R O U T I N E =======================================
.text$x:0000E768
.text$x:0000E768
.text$x:0000E768 __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$1 proc near
.text$x:0000E768                                         ; DATA XREF: .xdata$x:00012B0Co
.text$x:0000E768                 lea     ecx, [ebp+8]
.text$x:0000E76B                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000E76B __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$1 endp
.text$x:0000E76B
.text$x:0000E770
.text$x:0000E770 ; =============== S U B R O U T I N E =======================================
.text$x:0000E770
.text$x:0000E770
.text$x:0000E770 __ehhandler$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z proc near
.text$x:0000E770                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:0000E770
.text$x:0000E770 arg_4           = dword ptr  8
.text$x:0000E770
.text$x:0000E770                 mov     edx, [esp+arg_4]
.text$x:0000E774                 lea     eax, [edx+0Ch]
.text$x:0000E777                 mov     ecx, [edx-0Ch]
.text$x:0000E77A                 xor     ecx, eax
.text$x:0000E77C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000E781                 mov     eax, offset __ehfuncinfo$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z
.text$x:0000E786                 jmp     ___CxxFrameHandler3
.text$x:0000E786 __ehhandler$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z endp
.text$x:0000E786
.text$x:0000E786 ; ---------------------------------------------------------------------------
.text$x:0000E78B                 align 4
.text$x:0000E78B _text$x         ends
.text$x:0000E78B
.text$mn:0000E78C ; ===========================================================================
.text$mn:0000E78C
.text$mn:0000E78C ; Segment type: Pure code
.text$mn:0000E78C ; Segment permissions: Read/Execute
.text$mn:0000E78C _text$mn        segment para public 'CODE' use32
.text$mn:0000E78C                 assume cs:_text$mn
.text$mn:0000E78C                 ;org 0E78Ch
.text$mn:0000E78C ; COMDAT (pick any)
.text$mn:0000E78C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E78C
.text$mn:0000E78C ; =============== S U B R O U T I N E =======================================
.text$mn:0000E78C
.text$mn:0000E78C ; Attributes: bp-based frame
.text$mn:0000E78C
.text$mn:0000E78C ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Reallocate(unsigned int)
.text$mn:0000E78C                 public ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:0000E78C ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z proc near
.text$mn:0000E78C                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+4Ep
.text$mn:0000E78C
.text$mn:0000E78C var_20          = dword ptr -20h
.text$mn:0000E78C var_1C          = dword ptr -1Ch
.text$mn:0000E78C var_18          = dword ptr -18h
.text$mn:0000E78C var_13          = byte ptr -13h
.text$mn:0000E78C var_11          = byte ptr -11h
.text$mn:0000E78C var_10          = dword ptr -10h
.text$mn:0000E78C var_C           = dword ptr -0Ch
.text$mn:0000E78C var_4           = dword ptr -4
.text$mn:0000E78C arg_0           = dword ptr  8
.text$mn:0000E78C
.text$mn:0000E78C ; FUNCTION CHUNK AT .text$mn:0000E822 SIZE 00000009 BYTES
.text$mn:0000E78C ; FUNCTION CHUNK AT .text$mn:0000E832 SIZE 00000097 BYTES
.text$mn:0000E78C
.text$mn:0000E78C                 push    ebp
.text$mn:0000E78D                 mov     ebp, esp
.text$mn:0000E78F                 push    0FFFFFFFFh
.text$mn:0000E791                 push    offset __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:0000E796                 mov     eax, large fs:0
.text$mn:0000E79C                 push    eax
.text$mn:0000E79D                 push    ecx
.text$mn:0000E79E                 sub     esp, 10h
.text$mn:0000E7A1                 push    ebx
.text$mn:0000E7A2                 push    esi
.text$mn:0000E7A3                 push    edi
.text$mn:0000E7A4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000E7A9                 xor     eax, ebp
.text$mn:0000E7AB                 push    eax
.text$mn:0000E7AC                 lea     eax, [ebp+var_C]
.text$mn:0000E7AF                 mov     large fs:0, eax
.text$mn:0000E7B5                 mov     [ebp+var_10], esp
.text$mn:0000E7B8                 mov     [ebp+var_18], ecx
.text$mn:0000E7BB                 mov     eax, [ebp+arg_0]
.text$mn:0000E7BE                 push    eax
.text$mn:0000E7BF                 lea     ecx, [ebp+var_11]
.text$mn:0000E7C2                 push    ecx
.text$mn:0000E7C3                 mov     ecx, [ebp+var_18]
.text$mn:0000E7C6                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:0000E7CB                 mov     ecx, eax
.text$mn:0000E7CD                 call    ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z ; std::_Wrap_alloc<std::allocator<int>>::allocate(uint)
.text$mn:0000E7D2                 mov     [ebp+var_1C], eax
.text$mn:0000E7D5                 mov     [ebp+var_4], 0
.text$mn:0000E7DC                 mov     edx, [ebp+var_1C]
.text$mn:0000E7DF                 push    edx
.text$mn:0000E7E0                 mov     eax, [ebp+var_18]
.text$mn:0000E7E3                 mov     ecx, [eax+8]
.text$mn:0000E7E6                 push    ecx
.text$mn:0000E7E7                 mov     edx, [ebp+var_18]
.text$mn:0000E7EA                 mov     eax, [edx+4]
.text$mn:0000E7ED                 push    eax
.text$mn:0000E7EE                 mov     ecx, [ebp+var_18]
.text$mn:0000E7F1                 call    ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int>>::_Umove<int *>(int *,int *,int *)
.text$mn:0000E7F6                 jmp     short loc_E822
.text$mn:0000E7F6 ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z endp
.text$mn:0000E7F6
.text$mn:0000E7F8
.text$mn:0000E7F8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E7F8
.text$mn:0000E7F8 ; Attributes: noreturn
.text$mn:0000E7F8
.text$mn:0000E7F8 __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0 proc near
.text$mn:0000E7F8                                         ; DATA XREF: .xdata$x:00012CA0o
.text$mn:0000E7F8                 mov     ecx, [ebp+8]
.text$mn:0000E7FB                 push    ecx             ; int
.text$mn:0000E7FC                 mov     edx, [ebp-1Ch]
.text$mn:0000E7FF                 push    edx             ; void *
.text$mn:0000E800                 lea     eax, [ebp-12h]
.text$mn:0000E803                 push    eax
.text$mn:0000E804                 mov     ecx, [ebp-18h]
.text$mn:0000E807                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:0000E80C                 mov     ecx, eax
.text$mn:0000E80E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int>>::deallocate(int *,uint)
.text$mn:0000E813                 push    0
.text$mn:0000E815                 push    0
.text$mn:0000E817                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000E817 __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0 endp
.text$mn:0000E817
.text$mn:0000E81C ; ---------------------------------------------------------------------------
.text$mn:0000E81C                 mov     eax, offset $LN8
.text$mn:0000E821                 retn
.text$mn:0000E822 ; ---------------------------------------------------------------------------
.text$mn:0000E822 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:0000E822
.text$mn:0000E822 loc_E822:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+6Aj
.text$mn:0000E822                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000E829                 jmp     short loc_E832
.text$mn:0000E829 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:0000E82B
.text$mn:0000E82B ; =============== S U B R O U T I N E =======================================
.text$mn:0000E82B
.text$mn:0000E82B
.text$mn:0000E82B $LN8            proc near               ; DATA XREF: .text$mn:0000E81Co
.text$mn:0000E82B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000E82B $LN8            endp ; sp-analysis failed
.text$mn:0000E82B
.text$mn:0000E832 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:0000E832
.text$mn:0000E832 loc_E832:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+9Dj
.text$mn:0000E832                 mov     ecx, [ebp+var_18]
.text$mn:0000E835                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000E83A                 mov     [ebp+var_20], eax
.text$mn:0000E83D                 mov     ecx, [ebp+var_18]
.text$mn:0000E840                 cmp     dword ptr [ecx+4], 0
.text$mn:0000E844                 jz      short loc_E886
.text$mn:0000E846                 mov     edx, [ebp+var_18]
.text$mn:0000E849                 mov     eax, [edx+8]
.text$mn:0000E84C                 push    eax
.text$mn:0000E84D                 mov     ecx, [ebp+var_18]
.text$mn:0000E850                 mov     edx, [ecx+4]
.text$mn:0000E853                 push    edx
.text$mn:0000E854                 mov     ecx, [ebp+var_18]
.text$mn:0000E857                 call    ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Destroy(int *,int *)
.text$mn:0000E85C                 mov     eax, [ebp+var_18]
.text$mn:0000E85F                 mov     ecx, [ebp+var_18]
.text$mn:0000E862                 mov     edx, [eax+0Ch]
.text$mn:0000E865                 sub     edx, [ecx+4]
.text$mn:0000E868                 sar     edx, 2
.text$mn:0000E86B                 push    edx             ; int
.text$mn:0000E86C                 mov     eax, [ebp+var_18]
.text$mn:0000E86F                 mov     ecx, [eax+4]
.text$mn:0000E872                 push    ecx             ; void *
.text$mn:0000E873                 lea     edx, [ebp+var_13]
.text$mn:0000E876                 push    edx
.text$mn:0000E877                 mov     ecx, [ebp+var_18]
.text$mn:0000E87A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:0000E87F                 mov     ecx, eax
.text$mn:0000E881                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int>>::deallocate(int *,uint)
.text$mn:0000E886
.text$mn:0000E886 loc_E886:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+B8j
.text$mn:0000E886                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000E889                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000E88E                 mov     eax, [ebp+arg_0]
.text$mn:0000E891                 mov     ecx, [ebp+var_1C]
.text$mn:0000E894                 lea     edx, [ecx+eax*4]
.text$mn:0000E897                 mov     eax, [ebp+var_18]
.text$mn:0000E89A                 mov     [eax+0Ch], edx
.text$mn:0000E89D                 mov     ecx, [ebp+var_20]
.text$mn:0000E8A0                 mov     edx, [ebp+var_1C]
.text$mn:0000E8A3                 lea     eax, [edx+ecx*4]
.text$mn:0000E8A6                 mov     ecx, [ebp+var_18]
.text$mn:0000E8A9                 mov     [ecx+8], eax
.text$mn:0000E8AC                 mov     edx, [ebp+var_18]
.text$mn:0000E8AF                 mov     eax, [ebp+var_1C]
.text$mn:0000E8B2                 mov     [edx+4], eax
.text$mn:0000E8B5                 mov     ecx, [ebp+var_C]
.text$mn:0000E8B8                 mov     large fs:0, ecx
.text$mn:0000E8BF                 pop     ecx
.text$mn:0000E8C0                 pop     edi
.text$mn:0000E8C1                 pop     esi
.text$mn:0000E8C2                 pop     ebx
.text$mn:0000E8C3                 mov     esp, ebp
.text$mn:0000E8C5                 pop     ebp
.text$mn:0000E8C6                 retn    4
.text$mn:0000E8C6 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:0000E8C6 ; ---------------------------------------------------------------------------
.text$mn:0000E8C9                 align 4
.text$mn:0000E8C9 _text$mn        ends
.text$mn:0000E8C9
.text$x:0000E8CC ; ===========================================================================
.text$x:0000E8CC
.text$x:0000E8CC ; Segment type: Pure code
.text$x:0000E8CC ; Segment permissions: Read/Execute
.text$x:0000E8CC _text$x         segment para public 'CODE' use32
.text$x:0000E8CC                 assume cs:_text$x
.text$x:0000E8CC                 ;org 0E8CCh
.text$x:0000E8CC ; COMDAT (pick associative to section at E78C)
.text$x:0000E8CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000E8CC
.text$x:0000E8CC ; =============== S U B R O U T I N E =======================================
.text$x:0000E8CC
.text$x:0000E8CC
.text$x:0000E8CC __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z proc near
.text$x:0000E8CC                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+5o
.text$x:0000E8CC
.text$x:0000E8CC arg_4           = dword ptr  8
.text$x:0000E8CC
.text$x:0000E8CC                 mov     edx, [esp+arg_4]
.text$x:0000E8D0                 lea     eax, [edx+0Ch]
.text$x:0000E8D3                 mov     ecx, [edx-24h]
.text$x:0000E8D6                 xor     ecx, eax
.text$x:0000E8D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000E8DD                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$x:0000E8E2                 jmp     ___CxxFrameHandler3
.text$x:0000E8E2 __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z endp
.text$x:0000E8E2
.text$x:0000E8E2 ; ---------------------------------------------------------------------------
.text$x:0000E8E7                 align 4
.text$x:0000E8E7 _text$x         ends
.text$x:0000E8E7
.text$mn:0000E8E8 ; ===========================================================================
.text$mn:0000E8E8
.text$mn:0000E8E8 ; Segment type: Pure code
.text$mn:0000E8E8 ; Segment permissions: Read/Execute
.text$mn:0000E8E8 _text$mn        segment para public 'CODE' use32
.text$mn:0000E8E8                 assume cs:_text$mn
.text$mn:0000E8E8                 ;org 0E8E8h
.text$mn:0000E8E8 ; COMDAT (pick any)
.text$mn:0000E8E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000E8E8
.text$mn:0000E8E8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E8E8
.text$mn:0000E8E8 ; Attributes: bp-based frame
.text$mn:0000E8E8
.text$mn:0000E8E8 ; protected: void __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::_Reallocate(unsigned int)
.text$mn:0000E8E8                 public ?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z
.text$mn:0000E8E8 ?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z proc near
.text$mn:0000E8E8                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reserve(uint)+4Ep
.text$mn:0000E8E8
.text$mn:0000E8E8 var_20          = dword ptr -20h
.text$mn:0000E8E8 var_1C          = dword ptr -1Ch
.text$mn:0000E8E8 var_18          = dword ptr -18h
.text$mn:0000E8E8 var_13          = byte ptr -13h
.text$mn:0000E8E8 var_11          = byte ptr -11h
.text$mn:0000E8E8 var_10          = dword ptr -10h
.text$mn:0000E8E8 var_C           = dword ptr -0Ch
.text$mn:0000E8E8 var_4           = dword ptr -4
.text$mn:0000E8E8 arg_0           = dword ptr  8
.text$mn:0000E8E8
.text$mn:0000E8E8 ; FUNCTION CHUNK AT .text$mn:0000E97E SIZE 00000009 BYTES
.text$mn:0000E8E8 ; FUNCTION CHUNK AT .text$mn:0000E98E SIZE 0000009E BYTES
.text$mn:0000E8E8
.text$mn:0000E8E8                 push    ebp
.text$mn:0000E8E9                 mov     ebp, esp
.text$mn:0000E8EB                 push    0FFFFFFFFh
.text$mn:0000E8ED                 push    offset __ehhandler$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z
.text$mn:0000E8F2                 mov     eax, large fs:0
.text$mn:0000E8F8                 push    eax
.text$mn:0000E8F9                 push    ecx
.text$mn:0000E8FA                 sub     esp, 10h
.text$mn:0000E8FD                 push    ebx
.text$mn:0000E8FE                 push    esi
.text$mn:0000E8FF                 push    edi
.text$mn:0000E900                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000E905                 xor     eax, ebp
.text$mn:0000E907                 push    eax
.text$mn:0000E908                 lea     eax, [ebp+var_C]
.text$mn:0000E90B                 mov     large fs:0, eax
.text$mn:0000E911                 mov     [ebp+var_10], esp
.text$mn:0000E914                 mov     [ebp+var_18], ecx
.text$mn:0000E917                 mov     eax, [ebp+arg_0]
.text$mn:0000E91A                 push    eax
.text$mn:0000E91B                 lea     ecx, [ebp+var_11]
.text$mn:0000E91E                 push    ecx
.text$mn:0000E91F                 mov     ecx, [ebp+var_18]
.text$mn:0000E922                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Getal(void)
.text$mn:0000E927                 mov     ecx, eax
.text$mn:0000E929                 call    ?allocate@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEPAUsessionFileInfo@@I@Z ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::allocate(uint)
.text$mn:0000E92E                 mov     [ebp+var_1C], eax
.text$mn:0000E931                 mov     [ebp+var_4], 0
.text$mn:0000E938                 mov     edx, [ebp+var_1C]
.text$mn:0000E93B                 push    edx
.text$mn:0000E93C                 mov     eax, [ebp+var_18]
.text$mn:0000E93F                 mov     ecx, [eax+8]
.text$mn:0000E942                 push    ecx
.text$mn:0000E943                 mov     edx, [ebp+var_18]
.text$mn:0000E946                 mov     eax, [edx+4]
.text$mn:0000E949                 push    eax
.text$mn:0000E94A                 mov     ecx, [ebp+var_18]
.text$mn:0000E94D                 call    ??$_Umove@PAUsessionFileInfo@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@PAU2@00@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Umove<sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *)
.text$mn:0000E952                 jmp     short loc_E97E
.text$mn:0000E952 ?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z endp
.text$mn:0000E952
.text$mn:0000E954
.text$mn:0000E954 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E954
.text$mn:0000E954 ; Attributes: noreturn
.text$mn:0000E954
.text$mn:0000E954 __catch$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:0000E954                                         ; DATA XREF: .xdata$x:000132D0o
.text$mn:0000E954                 mov     ecx, [ebp+8]
.text$mn:0000E957                 push    ecx             ; int
.text$mn:0000E958                 mov     edx, [ebp-1Ch]
.text$mn:0000E95B                 push    edx             ; void *
.text$mn:0000E95C                 lea     eax, [ebp-12h]
.text$mn:0000E95F                 push    eax
.text$mn:0000E960                 mov     ecx, [ebp-18h]
.text$mn:0000E963                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Getal(void)
.text$mn:0000E968                 mov     ecx, eax
.text$mn:0000E96A                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@I@Z ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::deallocate(sessionFileInfo *,uint)
.text$mn:0000E96F                 push    0
.text$mn:0000E971                 push    0
.text$mn:0000E973                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000E973 __catch$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:0000E973
.text$mn:0000E978 ; ---------------------------------------------------------------------------
.text$mn:0000E978                 mov     eax, offset $LN8_1
.text$mn:0000E97D                 retn
.text$mn:0000E97E ; ---------------------------------------------------------------------------
.text$mn:0000E97E ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z
.text$mn:0000E97E
.text$mn:0000E97E loc_E97E:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reallocate(uint)+6Aj
.text$mn:0000E97E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000E985                 jmp     short loc_E98E
.text$mn:0000E985 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z
.text$mn:0000E987
.text$mn:0000E987 ; =============== S U B R O U T I N E =======================================
.text$mn:0000E987
.text$mn:0000E987
.text$mn:0000E987 $LN8_1          proc near               ; DATA XREF: .text$mn:0000E978o
.text$mn:0000E987                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000E987 $LN8_1          endp ; sp-analysis failed
.text$mn:0000E987
.text$mn:0000E98E ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z
.text$mn:0000E98E
.text$mn:0000E98E loc_E98E:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reallocate(uint)+9Dj
.text$mn:0000E98E                 mov     ecx, [ebp+var_18]
.text$mn:0000E991                 call    ?size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::size(void)
.text$mn:0000E996                 mov     [ebp+var_20], eax
.text$mn:0000E999                 mov     ecx, [ebp+var_18]
.text$mn:0000E99C                 cmp     dword ptr [ecx+4], 0
.text$mn:0000E9A0                 jz      short loc_E9E7
.text$mn:0000E9A2                 mov     edx, [ebp+var_18]
.text$mn:0000E9A5                 mov     eax, [edx+8]
.text$mn:0000E9A8                 push    eax
.text$mn:0000E9A9                 mov     ecx, [ebp+var_18]
.text$mn:0000E9AC                 mov     edx, [ecx+4]
.text$mn:0000E9AF                 push    edx
.text$mn:0000E9B0                 mov     ecx, [ebp+var_18]
.text$mn:0000E9B3                 call    ?_Destroy@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXPAUsessionFileInfo@@0@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Destroy(sessionFileInfo *,sessionFileInfo *)
.text$mn:0000E9B8                 mov     eax, [ebp+var_18]
.text$mn:0000E9BB                 mov     ecx, [ebp+var_18]
.text$mn:0000E9BE                 mov     eax, [eax+0Ch]
.text$mn:0000E9C1                 sub     eax, [ecx+4]
.text$mn:0000E9C4                 cdq
.text$mn:0000E9C5                 mov     ecx, 98h ; 'ÿ'
.text$mn:0000E9CA                 idiv    ecx
.text$mn:0000E9CC                 push    eax             ; int
.text$mn:0000E9CD                 mov     edx, [ebp+var_18]
.text$mn:0000E9D0                 mov     eax, [edx+4]
.text$mn:0000E9D3                 push    eax             ; void *
.text$mn:0000E9D4                 lea     ecx, [ebp+var_13]
.text$mn:0000E9D7                 push    ecx
.text$mn:0000E9D8                 mov     ecx, [ebp+var_18]
.text$mn:0000E9DB                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Getal(void)
.text$mn:0000E9E0                 mov     ecx, eax
.text$mn:0000E9E2                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@I@Z ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::deallocate(sessionFileInfo *,uint)
.text$mn:0000E9E7
.text$mn:0000E9E7 loc_E9E7:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reallocate(uint)+B8j
.text$mn:0000E9E7                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000E9EA                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000E9EF                 imul    edx, [ebp+arg_0], 98h
.text$mn:0000E9F6                 add     edx, [ebp+var_1C]
.text$mn:0000E9F9                 mov     eax, [ebp+var_18]
.text$mn:0000E9FC                 mov     [eax+0Ch], edx
.text$mn:0000E9FF                 imul    ecx, [ebp+var_20], 98h
.text$mn:0000EA06                 add     ecx, [ebp+var_1C]
.text$mn:0000EA09                 mov     edx, [ebp+var_18]
.text$mn:0000EA0C                 mov     [edx+8], ecx
.text$mn:0000EA0F                 mov     eax, [ebp+var_18]
.text$mn:0000EA12                 mov     ecx, [ebp+var_1C]
.text$mn:0000EA15                 mov     [eax+4], ecx
.text$mn:0000EA18                 mov     ecx, [ebp+var_C]
.text$mn:0000EA1B                 mov     large fs:0, ecx
.text$mn:0000EA22                 pop     ecx
.text$mn:0000EA23                 pop     edi
.text$mn:0000EA24                 pop     esi
.text$mn:0000EA25                 pop     ebx
.text$mn:0000EA26                 mov     esp, ebp
.text$mn:0000EA28                 pop     ebp
.text$mn:0000EA29                 retn    4
.text$mn:0000EA29 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z
.text$mn:0000EA29 _text$mn        ends
.text$mn:0000EA29
.text$x:0000EA2C ; ===========================================================================
.text$x:0000EA2C
.text$x:0000EA2C ; Segment type: Pure code
.text$x:0000EA2C ; Segment permissions: Read/Execute
.text$x:0000EA2C _text$x         segment para public 'CODE' use32
.text$x:0000EA2C                 assume cs:_text$x
.text$x:0000EA2C                 ;org 0EA2Ch
.text$x:0000EA2C ; COMDAT (pick associative to section at E8E8)
.text$x:0000EA2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000EA2C
.text$x:0000EA2C ; =============== S U B R O U T I N E =======================================
.text$x:0000EA2C
.text$x:0000EA2C
.text$x:0000EA2C __ehhandler$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z proc near
.text$x:0000EA2C                                         ; DATA XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reallocate(uint)+5o
.text$x:0000EA2C
.text$x:0000EA2C arg_4           = dword ptr  8
.text$x:0000EA2C
.text$x:0000EA2C                 mov     edx, [esp+arg_4]
.text$x:0000EA30                 lea     eax, [edx+0Ch]
.text$x:0000EA33                 mov     ecx, [edx-24h]
.text$x:0000EA36                 xor     ecx, eax
.text$x:0000EA38                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000EA3D                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z
.text$x:0000EA42                 jmp     ___CxxFrameHandler3
.text$x:0000EA42 __ehhandler$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z endp
.text$x:0000EA42
.text$x:0000EA42 ; ---------------------------------------------------------------------------
.text$x:0000EA47                 align 4
.text$x:0000EA47 _text$x         ends
.text$x:0000EA47
.text$mn:0000EA48 ; ===========================================================================
.text$mn:0000EA48
.text$mn:0000EA48 ; Segment type: Pure code
.text$mn:0000EA48 ; Segment permissions: Read/Execute
.text$mn:0000EA48 _text$mn        segment para public 'CODE' use32
.text$mn:0000EA48                 assume cs:_text$mn
.text$mn:0000EA48                 ;org 0EA48h
.text$mn:0000EA48 ; COMDAT (pick any)
.text$mn:0000EA48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000EA48
.text$mn:0000EA48 ; =============== S U B R O U T I N E =======================================
.text$mn:0000EA48
.text$mn:0000EA48 ; Attributes: bp-based frame
.text$mn:0000EA48
.text$mn:0000EA48 ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Reallocate(unsigned int)
.text$mn:0000EA48                 public ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000EA48 ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z proc near
.text$mn:0000EA48                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+4Ep
.text$mn:0000EA48
.text$mn:0000EA48 var_20          = dword ptr -20h
.text$mn:0000EA48 var_1C          = dword ptr -1Ch
.text$mn:0000EA48 var_18          = dword ptr -18h
.text$mn:0000EA48 var_13          = byte ptr -13h
.text$mn:0000EA48 var_11          = byte ptr -11h
.text$mn:0000EA48 var_10          = dword ptr -10h
.text$mn:0000EA48 var_C           = dword ptr -0Ch
.text$mn:0000EA48 var_4           = dword ptr -4
.text$mn:0000EA48 arg_0           = dword ptr  8
.text$mn:0000EA48
.text$mn:0000EA48 ; FUNCTION CHUNK AT .text$mn:0000EADE SIZE 00000009 BYTES
.text$mn:0000EA48 ; FUNCTION CHUNK AT .text$mn:0000EAEE SIZE 00000098 BYTES
.text$mn:0000EA48
.text$mn:0000EA48                 push    ebp
.text$mn:0000EA49                 mov     ebp, esp
.text$mn:0000EA4B                 push    0FFFFFFFFh
.text$mn:0000EA4D                 push    offset __ehhandler$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000EA52                 mov     eax, large fs:0
.text$mn:0000EA58                 push    eax
.text$mn:0000EA59                 push    ecx
.text$mn:0000EA5A                 sub     esp, 10h
.text$mn:0000EA5D                 push    ebx
.text$mn:0000EA5E                 push    esi
.text$mn:0000EA5F                 push    edi
.text$mn:0000EA60                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000EA65                 xor     eax, ebp
.text$mn:0000EA67                 push    eax
.text$mn:0000EA68                 lea     eax, [ebp+var_C]
.text$mn:0000EA6B                 mov     large fs:0, eax
.text$mn:0000EA71                 mov     [ebp+var_10], esp
.text$mn:0000EA74                 mov     [ebp+var_18], ecx
.text$mn:0000EA77                 mov     eax, [ebp+arg_0]
.text$mn:0000EA7A                 push    eax
.text$mn:0000EA7B                 lea     ecx, [ebp+var_11]
.text$mn:0000EA7E                 push    ecx
.text$mn:0000EA7F                 mov     ecx, [ebp+var_18]
.text$mn:0000EA82                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000EA87                 mov     ecx, eax
.text$mn:0000EA89                 call    ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::allocate(uint)
.text$mn:0000EA8E                 mov     [ebp+var_1C], eax
.text$mn:0000EA91                 mov     [ebp+var_4], 0
.text$mn:0000EA98                 mov     edx, [ebp+var_1C]
.text$mn:0000EA9B                 push    edx
.text$mn:0000EA9C                 mov     eax, [ebp+var_18]
.text$mn:0000EA9F                 mov     ecx, [eax+8]
.text$mn:0000EAA2                 push    ecx
.text$mn:0000EAA3                 mov     edx, [ebp+var_18]
.text$mn:0000EAA6                 mov     eax, [edx+4]
.text$mn:0000EAA9                 push    eax
.text$mn:0000EAAA                 mov     ecx, [ebp+var_18]
.text$mn:0000EAAD                 call    ??$_Umove@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PAV21@00@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Umove<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000EAB2                 jmp     short loc_EADE
.text$mn:0000EAB2 ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z endp
.text$mn:0000EAB2
.text$mn:0000EAB4
.text$mn:0000EAB4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000EAB4
.text$mn:0000EAB4 ; Attributes: noreturn
.text$mn:0000EAB4
.text$mn:0000EAB4 __catch$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$0 proc near
.text$mn:0000EAB4                                         ; DATA XREF: .xdata$x:000134F8o
.text$mn:0000EAB4                 mov     ecx, [ebp+8]
.text$mn:0000EAB7                 push    ecx             ; int
.text$mn:0000EAB8                 mov     edx, [ebp-1Ch]
.text$mn:0000EABB                 push    edx             ; void *
.text$mn:0000EABC                 lea     eax, [ebp-12h]
.text$mn:0000EABF                 push    eax
.text$mn:0000EAC0                 mov     ecx, [ebp-18h]
.text$mn:0000EAC3                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000EAC8                 mov     ecx, eax
.text$mn:0000EACA                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::deallocate(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,uint)
.text$mn:0000EACF                 push    0
.text$mn:0000EAD1                 push    0
.text$mn:0000EAD3                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000EAD3 __catch$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$0 endp
.text$mn:0000EAD3
.text$mn:0000EAD8 ; ---------------------------------------------------------------------------
.text$mn:0000EAD8                 mov     eax, offset $LN8_2
.text$mn:0000EADD                 retn
.text$mn:0000EADE ; ---------------------------------------------------------------------------
.text$mn:0000EADE ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000EADE
.text$mn:0000EADE loc_EADE:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+6Aj
.text$mn:0000EADE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000EAE5                 jmp     short loc_EAEE
.text$mn:0000EAE5 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000EAE7
.text$mn:0000EAE7 ; =============== S U B R O U T I N E =======================================
.text$mn:0000EAE7
.text$mn:0000EAE7
.text$mn:0000EAE7 $LN8_2          proc near               ; DATA XREF: .text$mn:0000EAD8o
.text$mn:0000EAE7                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000EAE7 $LN8_2          endp ; sp-analysis failed
.text$mn:0000EAE7
.text$mn:0000EAEE ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000EAEE
.text$mn:0000EAEE loc_EAEE:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+9Dj
.text$mn:0000EAEE                 mov     ecx, [ebp+var_18]
.text$mn:0000EAF1                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:0000EAF6                 mov     [ebp+var_20], eax
.text$mn:0000EAF9                 mov     ecx, [ebp+var_18]
.text$mn:0000EAFC                 cmp     dword ptr [ecx+4], 0
.text$mn:0000EB00                 jz      short loc_EB47
.text$mn:0000EB02                 mov     edx, [ebp+var_18]
.text$mn:0000EB05                 mov     eax, [edx+8]
.text$mn:0000EB08                 push    eax
.text$mn:0000EB09                 mov     ecx, [ebp+var_18]
.text$mn:0000EB0C                 mov     edx, [ecx+4]
.text$mn:0000EB0F                 push    edx
.text$mn:0000EB10                 mov     ecx, [ebp+var_18]
.text$mn:0000EB13                 call    ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Destroy(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000EB18                 mov     eax, [ebp+var_18]
.text$mn:0000EB1B                 mov     ecx, [ebp+var_18]
.text$mn:0000EB1E                 mov     eax, [eax+0Ch]
.text$mn:0000EB21                 sub     eax, [ecx+4]
.text$mn:0000EB24                 cdq
.text$mn:0000EB25                 mov     ecx, 1Ch
.text$mn:0000EB2A                 idiv    ecx
.text$mn:0000EB2C                 push    eax             ; int
.text$mn:0000EB2D                 mov     edx, [ebp+var_18]
.text$mn:0000EB30                 mov     eax, [edx+4]
.text$mn:0000EB33                 push    eax             ; void *
.text$mn:0000EB34                 lea     ecx, [ebp+var_13]
.text$mn:0000EB37                 push    ecx
.text$mn:0000EB38                 mov     ecx, [ebp+var_18]
.text$mn:0000EB3B                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000EB40                 mov     ecx, eax
.text$mn:0000EB42                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::deallocate(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,uint)
.text$mn:0000EB47
.text$mn:0000EB47 loc_EB47:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+B8j
.text$mn:0000EB47                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000EB4A                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000EB4F                 imul    edx, [ebp+arg_0], 1Ch
.text$mn:0000EB53                 add     edx, [ebp+var_1C]
.text$mn:0000EB56                 mov     eax, [ebp+var_18]
.text$mn:0000EB59                 mov     [eax+0Ch], edx
.text$mn:0000EB5C                 imul    ecx, [ebp+var_20], 1Ch
.text$mn:0000EB60                 add     ecx, [ebp+var_1C]
.text$mn:0000EB63                 mov     edx, [ebp+var_18]
.text$mn:0000EB66                 mov     [edx+8], ecx
.text$mn:0000EB69                 mov     eax, [ebp+var_18]
.text$mn:0000EB6C                 mov     ecx, [ebp+var_1C]
.text$mn:0000EB6F                 mov     [eax+4], ecx
.text$mn:0000EB72                 mov     ecx, [ebp+var_C]
.text$mn:0000EB75                 mov     large fs:0, ecx
.text$mn:0000EB7C                 pop     ecx
.text$mn:0000EB7D                 pop     edi
.text$mn:0000EB7E                 pop     esi
.text$mn:0000EB7F                 pop     ebx
.text$mn:0000EB80                 mov     esp, ebp
.text$mn:0000EB82                 pop     ebp
.text$mn:0000EB83                 retn    4
.text$mn:0000EB83 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000EB83 ; ---------------------------------------------------------------------------
.text$mn:0000EB86                 align 4
.text$mn:0000EB86 _text$mn        ends
.text$mn:0000EB86
.text$x:0000EB88 ; ===========================================================================
.text$x:0000EB88
.text$x:0000EB88 ; Segment type: Pure code
.text$x:0000EB88 ; Segment permissions: Read/Execute
.text$x:0000EB88 _text$x         segment para public 'CODE' use32
.text$x:0000EB88                 assume cs:_text$x
.text$x:0000EB88                 ;org 0EB88h
.text$x:0000EB88 ; COMDAT (pick associative to section at EA48)
.text$x:0000EB88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000EB88
.text$x:0000EB88 ; =============== S U B R O U T I N E =======================================
.text$x:0000EB88
.text$x:0000EB88
.text$x:0000EB88 __ehhandler$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z proc near
.text$x:0000EB88                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+5o
.text$x:0000EB88
.text$x:0000EB88 arg_4           = dword ptr  8
.text$x:0000EB88
.text$x:0000EB88                 mov     edx, [esp+arg_4]
.text$x:0000EB8C                 lea     eax, [edx+0Ch]
.text$x:0000EB8F                 mov     ecx, [edx-24h]
.text$x:0000EB92                 xor     ecx, eax
.text$x:0000EB94                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000EB99                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$x:0000EB9E                 jmp     ___CxxFrameHandler3
.text$x:0000EB9E __ehhandler$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z endp
.text$x:0000EB9E
.text$x:0000EB9E ; ---------------------------------------------------------------------------
.text$x:0000EBA3                 align 4
.text$x:0000EBA3 _text$x         ends
.text$x:0000EBA3
.text$mn:0000EBA4 ; ===========================================================================
.text$mn:0000EBA4
.text$mn:0000EBA4 ; Segment type: Pure code
.text$mn:0000EBA4 ; Segment permissions: Read/Execute
.text$mn:0000EBA4 _text$mn        segment para public 'CODE' use32
.text$mn:0000EBA4                 assume cs:_text$mn
.text$mn:0000EBA4                 ;org 0EBA4h
.text$mn:0000EBA4 ; COMDAT (pick any)
.text$mn:0000EBA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000EBA4
.text$mn:0000EBA4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000EBA4
.text$mn:0000EBA4 ; Attributes: bp-based frame
.text$mn:0000EBA4
.text$mn:0000EBA4 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Reserve(unsigned int)
.text$mn:0000EBA4                 public ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:0000EBA4 ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z proc near
.text$mn:0000EBA4                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+50p
.text$mn:0000EBA4                                         ; std::vector<int,std::allocator<int>>::push_back(int const &)+B6p
.text$mn:0000EBA4
.text$mn:0000EBA4 var_4           = dword ptr -4
.text$mn:0000EBA4 arg_0           = dword ptr  8
.text$mn:0000EBA4
.text$mn:0000EBA4                 push    ebp
.text$mn:0000EBA5                 mov     ebp, esp
.text$mn:0000EBA7                 push    ecx
.text$mn:0000EBA8                 push    esi
.text$mn:0000EBA9                 mov     [ebp+var_4], ecx
.text$mn:0000EBAC                 mov     ecx, [ebp+var_4]
.text$mn:0000EBAF                 call    ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::_Unused_capacity(void)
.text$mn:0000EBB4                 cmp     eax, [ebp+arg_0]
.text$mn:0000EBB7                 jnb     short loc_EBF7
.text$mn:0000EBB9                 mov     ecx, [ebp+var_4]
.text$mn:0000EBBC                 call    ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::max_size(void)
.text$mn:0000EBC1                 mov     esi, eax
.text$mn:0000EBC3                 mov     ecx, [ebp+var_4]
.text$mn:0000EBC6                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000EBCB                 sub     esi, eax
.text$mn:0000EBCD                 cmp     esi, [ebp+arg_0]
.text$mn:0000EBD0                 jnb     short loc_EBDA
.text$mn:0000EBD2                 mov     ecx, [ebp+var_4]
.text$mn:0000EBD5                 call    ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int>>::_Xlen(void)
.text$mn:0000EBDA
.text$mn:0000EBDA loc_EBDA:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+2Cj
.text$mn:0000EBDA                 mov     ecx, [ebp+var_4]
.text$mn:0000EBDD                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000EBE2                 add     eax, [ebp+arg_0]
.text$mn:0000EBE5                 push    eax
.text$mn:0000EBE6                 mov     ecx, [ebp+var_4]
.text$mn:0000EBE9                 call    ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ; std::vector<int,std::allocator<int>>::_Grow_to(uint)
.text$mn:0000EBEE                 push    eax
.text$mn:0000EBEF                 mov     ecx, [ebp+var_4]
.text$mn:0000EBF2                 call    ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int>>::_Reallocate(uint)
.text$mn:0000EBF7
.text$mn:0000EBF7 loc_EBF7:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+13j
.text$mn:0000EBF7                 pop     esi
.text$mn:0000EBF8                 mov     esp, ebp
.text$mn:0000EBFA                 pop     ebp
.text$mn:0000EBFB                 retn    4
.text$mn:0000EBFB ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z endp
.text$mn:0000EBFB
.text$mn:0000EBFB ; ---------------------------------------------------------------------------
.text$mn:0000EBFE                 align 10h
.text$mn:0000EBFE _text$mn        ends
.text$mn:0000EBFE
.text$mn:0000EC00 ; ===========================================================================
.text$mn:0000EC00
.text$mn:0000EC00 ; Segment type: Pure code
.text$mn:0000EC00 ; Segment permissions: Read/Execute
.text$mn:0000EC00 _text$mn        segment para public 'CODE' use32
.text$mn:0000EC00                 assume cs:_text$mn
.text$mn:0000EC00                 ;org 0EC00h
.text$mn:0000EC00 ; COMDAT (pick any)
.text$mn:0000EC00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000EC00
.text$mn:0000EC00 ; =============== S U B R O U T I N E =======================================
.text$mn:0000EC00
.text$mn:0000EC00 ; Attributes: bp-based frame
.text$mn:0000EC00
.text$mn:0000EC00 ; protected: void __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::_Reserve(unsigned int)
.text$mn:0000EC00                 public ?_Reserve@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z
.text$mn:0000EC00 ?_Reserve@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z proc near
.text$mn:0000EC00                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::push_back(sessionFileInfo &&)+59p
.text$mn:0000EC00                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::push_back(sessionFileInfo &&)+CBp
.text$mn:0000EC00
.text$mn:0000EC00 var_4           = dword ptr -4
.text$mn:0000EC00 arg_0           = dword ptr  8
.text$mn:0000EC00
.text$mn:0000EC00                 push    ebp
.text$mn:0000EC01                 mov     ebp, esp
.text$mn:0000EC03                 push    ecx
.text$mn:0000EC04                 push    esi
.text$mn:0000EC05                 mov     [ebp+var_4], ecx
.text$mn:0000EC08                 mov     ecx, [ebp+var_4]
.text$mn:0000EC0B                 call    ?_Unused_capacity@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Unused_capacity(void)
.text$mn:0000EC10                 cmp     eax, [ebp+arg_0]
.text$mn:0000EC13                 jnb     short loc_EC53
.text$mn:0000EC15                 mov     ecx, [ebp+var_4]
.text$mn:0000EC18                 call    ?max_size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::max_size(void)
.text$mn:0000EC1D                 mov     esi, eax
.text$mn:0000EC1F                 mov     ecx, [ebp+var_4]
.text$mn:0000EC22                 call    ?size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::size(void)
.text$mn:0000EC27                 sub     esi, eax
.text$mn:0000EC29                 cmp     esi, [ebp+arg_0]
.text$mn:0000EC2C                 jnb     short loc_EC36
.text$mn:0000EC2E                 mov     ecx, [ebp+var_4]
.text$mn:0000EC31                 call    ?_Xlen@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Xlen(void)
.text$mn:0000EC36
.text$mn:0000EC36 loc_EC36:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reserve(uint)+2Cj
.text$mn:0000EC36                 mov     ecx, [ebp+var_4]
.text$mn:0000EC39                 call    ?size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::size(void)
.text$mn:0000EC3E                 add     eax, [ebp+arg_0]
.text$mn:0000EC41                 push    eax
.text$mn:0000EC42                 mov     ecx, [ebp+var_4]
.text$mn:0000EC45                 call    ?_Grow_to@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEII@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Grow_to(uint)
.text$mn:0000EC4A                 push    eax
.text$mn:0000EC4B                 mov     ecx, [ebp+var_4]
.text$mn:0000EC4E                 call    ?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reallocate(uint)
.text$mn:0000EC53
.text$mn:0000EC53 loc_EC53:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reserve(uint)+13j
.text$mn:0000EC53                 pop     esi
.text$mn:0000EC54                 mov     esp, ebp
.text$mn:0000EC56                 pop     ebp
.text$mn:0000EC57                 retn    4
.text$mn:0000EC57 ?_Reserve@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z endp
.text$mn:0000EC57
.text$mn:0000EC57 ; ---------------------------------------------------------------------------
.text$mn:0000EC5A                 align 4
.text$mn:0000EC5A _text$mn        ends
.text$mn:0000EC5A
.text$mn:0000EC5C ; ===========================================================================
.text$mn:0000EC5C
.text$mn:0000EC5C ; Segment type: Pure code
.text$mn:0000EC5C ; Segment permissions: Read/Execute
.text$mn:0000EC5C _text$mn        segment para public 'CODE' use32
.text$mn:0000EC5C                 assume cs:_text$mn
.text$mn:0000EC5C                 ;org 0EC5Ch
.text$mn:0000EC5C ; COMDAT (pick any)
.text$mn:0000EC5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000EC5C
.text$mn:0000EC5C ; =============== S U B R O U T I N E =======================================
.text$mn:0000EC5C
.text$mn:0000EC5C ; Attributes: bp-based frame
.text$mn:0000EC5C
.text$mn:0000EC5C ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Reserve(unsigned int)
.text$mn:0000EC5C                 public ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000EC5C ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z proc near
.text$mn:0000EC5C                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+59p
.text$mn:0000EC5C                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+C6p
.text$mn:0000EC5C
.text$mn:0000EC5C var_4           = dword ptr -4
.text$mn:0000EC5C arg_0           = dword ptr  8
.text$mn:0000EC5C
.text$mn:0000EC5C                 push    ebp
.text$mn:0000EC5D                 mov     ebp, esp
.text$mn:0000EC5F                 push    ecx
.text$mn:0000EC60                 push    esi
.text$mn:0000EC61                 mov     [ebp+var_4], ecx
.text$mn:0000EC64                 mov     ecx, [ebp+var_4]
.text$mn:0000EC67                 call    ?_Unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Unused_capacity(void)
.text$mn:0000EC6C                 cmp     eax, [ebp+arg_0]
.text$mn:0000EC6F                 jnb     short loc_ECAF
.text$mn:0000EC71                 mov     ecx, [ebp+var_4]
.text$mn:0000EC74                 call    ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(void)
.text$mn:0000EC79                 mov     esi, eax
.text$mn:0000EC7B                 mov     ecx, [ebp+var_4]
.text$mn:0000EC7E                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:0000EC83                 sub     esi, eax
.text$mn:0000EC85                 cmp     esi, [ebp+arg_0]
.text$mn:0000EC88                 jnb     short loc_EC92
.text$mn:0000EC8A                 mov     ecx, [ebp+var_4]
.text$mn:0000EC8D                 call    ?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Xlen(void)
.text$mn:0000EC92
.text$mn:0000EC92 loc_EC92:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+2Cj
.text$mn:0000EC92                 mov     ecx, [ebp+var_4]
.text$mn:0000EC95                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:0000EC9A                 add     eax, [ebp+arg_0]
.text$mn:0000EC9D                 push    eax
.text$mn:0000EC9E                 mov     ecx, [ebp+var_4]
.text$mn:0000ECA1                 call    ?_Grow_to@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEII@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)
.text$mn:0000ECA6                 push    eax
.text$mn:0000ECA7                 mov     ecx, [ebp+var_4]
.text$mn:0000ECAA                 call    ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)
.text$mn:0000ECAF
.text$mn:0000ECAF loc_ECAF:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+13j
.text$mn:0000ECAF                 pop     esi
.text$mn:0000ECB0                 mov     esp, ebp
.text$mn:0000ECB2                 pop     ebp
.text$mn:0000ECB3                 retn    4
.text$mn:0000ECB3 ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z endp
.text$mn:0000ECB3
.text$mn:0000ECB3 ; ---------------------------------------------------------------------------
.text$mn:0000ECB6                 align 4
.text$mn:0000ECB6 _text$mn        ends
.text$mn:0000ECB6
.text$mn:0000ECB8 ; ===========================================================================
.text$mn:0000ECB8
.text$mn:0000ECB8 ; Segment type: Pure code
.text$mn:0000ECB8 ; Segment permissions: Read/Execute
.text$mn:0000ECB8 _text$mn        segment para public 'CODE' use32
.text$mn:0000ECB8                 assume cs:_text$mn
.text$mn:0000ECB8                 ;org 0ECB8h
.text$mn:0000ECB8 ; COMDAT (pick any)
.text$mn:0000ECB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000ECB8
.text$mn:0000ECB8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ECB8
.text$mn:0000ECB8 ; Attributes: bp-based frame
.text$mn:0000ECB8
.text$mn:0000ECB8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:0000ECB8                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:0000ECB8 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:0000ECB8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:0000ECB8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:0000ECB8
.text$mn:0000ECB8 var_C           = dword ptr -0Ch
.text$mn:0000ECB8 var_8           = dword ptr -8
.text$mn:0000ECB8 var_2           = byte ptr -2
.text$mn:0000ECB8 var_1           = byte ptr -1
.text$mn:0000ECB8 arg_0           = byte ptr  8
.text$mn:0000ECB8 Size            = dword ptr  0Ch
.text$mn:0000ECB8
.text$mn:0000ECB8                 push    ebp
.text$mn:0000ECB9                 mov     ebp, esp
.text$mn:0000ECBB                 sub     esp, 0Ch
.text$mn:0000ECBE                 mov     [ebp+var_8], ecx
.text$mn:0000ECC1                 movzx   eax, [ebp+arg_0]
.text$mn:0000ECC5                 test    eax, eax
.text$mn:0000ECC7                 jnz     short loc_ECCB
.text$mn:0000ECC9                 jmp     short loc_ED3E
.text$mn:0000ECCB ; ---------------------------------------------------------------------------
.text$mn:0000ECCB
.text$mn:0000ECCB loc_ECCB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000ECCB                 mov     ecx, [ebp+var_8]
.text$mn:0000ECCE                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000ECD2                 jb      short loc_ED3E
.text$mn:0000ECD4                 mov     edx, [ebp+var_8]
.text$mn:0000ECD7                 mov     eax, [edx+4]
.text$mn:0000ECDA                 mov     [ebp+var_C], eax
.text$mn:0000ECDD                 mov     ecx, [ebp+var_8]
.text$mn:0000ECE0                 add     ecx, 4
.text$mn:0000ECE3                 push    ecx
.text$mn:0000ECE4                 lea     edx, [ebp+var_1]
.text$mn:0000ECE7                 push    edx
.text$mn:0000ECE8                 mov     ecx, [ebp+var_8]
.text$mn:0000ECEB                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000ECF0                 mov     ecx, eax
.text$mn:0000ECF2                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000ECF7                 cmp     [ebp+Size], 0
.text$mn:0000ECFB                 jbe     short loc_ED1D
.text$mn:0000ECFD                 mov     eax, [ebp+Size]
.text$mn:0000ED00                 push    eax             ; Size
.text$mn:0000ED01                 mov     ecx, [ebp+var_C]
.text$mn:0000ED04                 push    ecx
.text$mn:0000ED05                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000ED0A                 add     esp, 4
.text$mn:0000ED0D                 push    eax             ; Src
.text$mn:0000ED0E                 mov     edx, [ebp+var_8]
.text$mn:0000ED11                 add     edx, 4
.text$mn:0000ED14                 push    edx             ; Dst
.text$mn:0000ED15                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000ED1A                 add     esp, 0Ch
.text$mn:0000ED1D
.text$mn:0000ED1D loc_ED1D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:0000ED1D                 mov     eax, [ebp+var_8]
.text$mn:0000ED20                 mov     ecx, [eax+18h]
.text$mn:0000ED23                 add     ecx, 1
.text$mn:0000ED26                 push    ecx             ; int
.text$mn:0000ED27                 mov     edx, [ebp+var_C]
.text$mn:0000ED2A                 push    edx             ; void *
.text$mn:0000ED2B                 lea     eax, [ebp+var_2]
.text$mn:0000ED2E                 push    eax
.text$mn:0000ED2F                 mov     ecx, [ebp+var_8]
.text$mn:0000ED32                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000ED37                 mov     ecx, eax
.text$mn:0000ED39                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:0000ED3E
.text$mn:0000ED3E loc_ED3E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:0000ED3E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:0000ED3E                 mov     ecx, [ebp+var_8]
.text$mn:0000ED41                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:0000ED48                 mov     edx, [ebp+Size]
.text$mn:0000ED4B                 push    edx
.text$mn:0000ED4C                 mov     ecx, [ebp+var_8]
.text$mn:0000ED4F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000ED54                 mov     esp, ebp
.text$mn:0000ED56                 pop     ebp
.text$mn:0000ED57                 retn    8
.text$mn:0000ED57 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:0000ED57
.text$mn:0000ED57 ; ---------------------------------------------------------------------------
.text$mn:0000ED5A                 align 4
.text$mn:0000ED5A _text$mn        ends
.text$mn:0000ED5A
.text$mn:0000ED5C ; ===========================================================================
.text$mn:0000ED5C
.text$mn:0000ED5C ; Segment type: Pure code
.text$mn:0000ED5C ; Segment permissions: Read/Execute
.text$mn:0000ED5C _text$mn        segment para public 'CODE' use32
.text$mn:0000ED5C                 assume cs:_text$mn
.text$mn:0000ED5C                 ;org 0ED5Ch
.text$mn:0000ED5C ; COMDAT (pick any)
.text$mn:0000ED5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000ED5C
.text$mn:0000ED5C ; =============== S U B R O U T I N E =======================================
.text$mn:0000ED5C
.text$mn:0000ED5C ; Attributes: bp-based frame
.text$mn:0000ED5C
.text$mn:0000ED5C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:0000ED5C                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:0000ED5C ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:0000ED5C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+4Bp
.text$mn:0000ED5C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+56p ...
.text$mn:0000ED5C
.text$mn:0000ED5C var_C           = dword ptr -0Ch
.text$mn:0000ED5C var_8           = dword ptr -8
.text$mn:0000ED5C var_2           = byte ptr -2
.text$mn:0000ED5C var_1           = byte ptr -1
.text$mn:0000ED5C arg_0           = byte ptr  8
.text$mn:0000ED5C arg_4           = dword ptr  0Ch
.text$mn:0000ED5C
.text$mn:0000ED5C                 push    ebp
.text$mn:0000ED5D                 mov     ebp, esp
.text$mn:0000ED5F                 sub     esp, 0Ch
.text$mn:0000ED62                 mov     [ebp+var_8], ecx
.text$mn:0000ED65                 movzx   eax, [ebp+arg_0]
.text$mn:0000ED69                 test    eax, eax
.text$mn:0000ED6B                 jnz     short loc_ED6F
.text$mn:0000ED6D                 jmp     short loc_EDE2
.text$mn:0000ED6F ; ---------------------------------------------------------------------------
.text$mn:0000ED6F
.text$mn:0000ED6F loc_ED6F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:0000ED6F                 mov     ecx, [ebp+var_8]
.text$mn:0000ED72                 cmp     dword ptr [ecx+18h], 8
.text$mn:0000ED76                 jb      short loc_EDE2
.text$mn:0000ED78                 mov     edx, [ebp+var_8]
.text$mn:0000ED7B                 mov     eax, [edx+4]
.text$mn:0000ED7E                 mov     [ebp+var_C], eax
.text$mn:0000ED81                 mov     ecx, [ebp+var_8]
.text$mn:0000ED84                 add     ecx, 4
.text$mn:0000ED87                 push    ecx
.text$mn:0000ED88                 lea     edx, [ebp+var_1]
.text$mn:0000ED8B                 push    edx
.text$mn:0000ED8C                 mov     ecx, [ebp+var_8]
.text$mn:0000ED8F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000ED94                 mov     ecx, eax
.text$mn:0000ED96                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:0000ED9B                 cmp     [ebp+arg_4], 0
.text$mn:0000ED9F                 jbe     short loc_EDC1
.text$mn:0000EDA1                 mov     eax, [ebp+arg_4]
.text$mn:0000EDA4                 push    eax             ; int
.text$mn:0000EDA5                 mov     ecx, [ebp+var_C]
.text$mn:0000EDA8                 push    ecx
.text$mn:0000EDA9                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000EDAE                 add     esp, 4
.text$mn:0000EDB1                 push    eax             ; Src
.text$mn:0000EDB2                 mov     edx, [ebp+var_8]
.text$mn:0000EDB5                 add     edx, 4
.text$mn:0000EDB8                 push    edx             ; Dst
.text$mn:0000EDB9                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000EDBE                 add     esp, 0Ch
.text$mn:0000EDC1
.text$mn:0000EDC1 loc_EDC1:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:0000EDC1                 mov     eax, [ebp+var_8]
.text$mn:0000EDC4                 mov     ecx, [eax+18h]
.text$mn:0000EDC7                 add     ecx, 1
.text$mn:0000EDCA                 push    ecx             ; int
.text$mn:0000EDCB                 mov     edx, [ebp+var_C]
.text$mn:0000EDCE                 push    edx             ; void *
.text$mn:0000EDCF                 lea     eax, [ebp+var_2]
.text$mn:0000EDD2                 push    eax
.text$mn:0000EDD3                 mov     ecx, [ebp+var_8]
.text$mn:0000EDD6                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000EDDB                 mov     ecx, eax
.text$mn:0000EDDD                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:0000EDE2
.text$mn:0000EDE2 loc_EDE2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:0000EDE2                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:0000EDE2                 mov     ecx, [ebp+var_8]
.text$mn:0000EDE5                 mov     dword ptr [ecx+18h], 7
.text$mn:0000EDEC                 mov     edx, [ebp+arg_4]
.text$mn:0000EDEF                 push    edx
.text$mn:0000EDF0                 mov     ecx, [ebp+var_8]
.text$mn:0000EDF3                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000EDF8                 mov     esp, ebp
.text$mn:0000EDFA                 pop     ebp
.text$mn:0000EDFB                 retn    8
.text$mn:0000EDFB ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:0000EDFB
.text$mn:0000EDFB ; ---------------------------------------------------------------------------
.text$mn:0000EDFE                 align 10h
.text$mn:0000EDFE _text$mn        ends
.text$mn:0000EDFE
.text$mn:0000EE00 ; ===========================================================================
.text$mn:0000EE00
.text$mn:0000EE00 ; Segment type: Pure code
.text$mn:0000EE00 ; Segment permissions: Read/Execute
.text$mn:0000EE00 _text$mn        segment para public 'CODE' use32
.text$mn:0000EE00                 assume cs:_text$mn
.text$mn:0000EE00                 ;org 0EE00h
.text$mn:0000EE00 ; COMDAT (pick any)
.text$mn:0000EE00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000EE00
.text$mn:0000EE00 ; =============== S U B R O U T I N E =======================================
.text$mn:0000EE00
.text$mn:0000EE00 ; Attributes: bp-based frame
.text$mn:0000EE00
.text$mn:0000EE00 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Tidy(void)
.text$mn:0000EE00                 public ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
.text$mn:0000EE00 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ proc near
.text$mn:0000EE00                                         ; CODE XREF: std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)+30p
.text$mn:0000EE00
.text$mn:0000EE00 var_8           = dword ptr -8
.text$mn:0000EE00 var_1           = byte ptr -1
.text$mn:0000EE00
.text$mn:0000EE00                 push    ebp
.text$mn:0000EE01                 mov     ebp, esp
.text$mn:0000EE03                 sub     esp, 8
.text$mn:0000EE06                 mov     [ebp+var_8], ecx
.text$mn:0000EE09                 mov     eax, [ebp+var_8]
.text$mn:0000EE0C                 cmp     dword ptr [eax+4], 0
.text$mn:0000EE10                 jz      short loc_EE78
.text$mn:0000EE12                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000EE15                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000EE1A                 mov     ecx, [ebp+var_8]
.text$mn:0000EE1D                 mov     edx, [ecx+8]
.text$mn:0000EE20                 push    edx
.text$mn:0000EE21                 mov     eax, [ebp+var_8]
.text$mn:0000EE24                 mov     ecx, [eax+4]
.text$mn:0000EE27                 push    ecx
.text$mn:0000EE28                 mov     ecx, [ebp+var_8]
.text$mn:0000EE2B                 call    ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Destroy(int *,int *)
.text$mn:0000EE30                 mov     edx, [ebp+var_8]
.text$mn:0000EE33                 mov     eax, [ebp+var_8]
.text$mn:0000EE36                 mov     ecx, [edx+0Ch]
.text$mn:0000EE39                 sub     ecx, [eax+4]
.text$mn:0000EE3C                 sar     ecx, 2
.text$mn:0000EE3F                 push    ecx             ; int
.text$mn:0000EE40                 mov     edx, [ebp+var_8]
.text$mn:0000EE43                 mov     eax, [edx+4]
.text$mn:0000EE46                 push    eax             ; void *
.text$mn:0000EE47                 lea     ecx, [ebp+var_1]
.text$mn:0000EE4A                 push    ecx
.text$mn:0000EE4B                 mov     ecx, [ebp+var_8]
.text$mn:0000EE4E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:0000EE53                 mov     ecx, eax
.text$mn:0000EE55                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int>>::deallocate(int *,uint)
.text$mn:0000EE5A                 mov     edx, [ebp+var_8]
.text$mn:0000EE5D                 mov     dword ptr [edx+4], 0
.text$mn:0000EE64                 mov     eax, [ebp+var_8]
.text$mn:0000EE67                 mov     dword ptr [eax+8], 0
.text$mn:0000EE6E                 mov     ecx, [ebp+var_8]
.text$mn:0000EE71                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000EE78
.text$mn:0000EE78 loc_EE78:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Tidy(void)+10j
.text$mn:0000EE78                 mov     esp, ebp
.text$mn:0000EE7A                 pop     ebp
.text$mn:0000EE7B                 retn
.text$mn:0000EE7B ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ endp
.text$mn:0000EE7B
.text$mn:0000EE7B _text$mn        ends
.text$mn:0000EE7B
.text$mn:0000EE7C ; ===========================================================================
.text$mn:0000EE7C
.text$mn:0000EE7C ; Segment type: Pure code
.text$mn:0000EE7C ; Segment permissions: Read/Execute
.text$mn:0000EE7C _text$mn        segment para public 'CODE' use32
.text$mn:0000EE7C                 assume cs:_text$mn
.text$mn:0000EE7C                 ;org 0EE7Ch
.text$mn:0000EE7C ; COMDAT (pick any)
.text$mn:0000EE7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000EE7C
.text$mn:0000EE7C ; =============== S U B R O U T I N E =======================================
.text$mn:0000EE7C
.text$mn:0000EE7C ; Attributes: bp-based frame
.text$mn:0000EE7C
.text$mn:0000EE7C ; protected: void __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::_Tidy(void)
.text$mn:0000EE7C                 public ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ
.text$mn:0000EE7C ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ proc near
.text$mn:0000EE7C                                         ; CODE XREF: __catch$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$0+3p
.text$mn:0000EE7C                                         ; std::vector<uint,std::allocator<uint>>::~vector<uint,std::allocator<uint>>(void)+30p ...
.text$mn:0000EE7C
.text$mn:0000EE7C var_8           = dword ptr -8
.text$mn:0000EE7C var_1           = byte ptr -1
.text$mn:0000EE7C
.text$mn:0000EE7C                 push    ebp
.text$mn:0000EE7D                 mov     ebp, esp
.text$mn:0000EE7F                 sub     esp, 8
.text$mn:0000EE82                 mov     [ebp+var_8], ecx
.text$mn:0000EE85                 mov     eax, [ebp+var_8]
.text$mn:0000EE88                 cmp     dword ptr [eax+4], 0
.text$mn:0000EE8C                 jz      short loc_EEF4
.text$mn:0000EE8E                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000EE91                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000EE96                 mov     ecx, [ebp+var_8]
.text$mn:0000EE99                 mov     edx, [ecx+8]
.text$mn:0000EE9C                 push    edx
.text$mn:0000EE9D                 mov     eax, [ebp+var_8]
.text$mn:0000EEA0                 mov     ecx, [eax+4]
.text$mn:0000EEA3                 push    ecx
.text$mn:0000EEA4                 mov     ecx, [ebp+var_8]
.text$mn:0000EEA7                 call    ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<uint,std::allocator<uint>>::_Destroy(uint *,uint *)
.text$mn:0000EEAC                 mov     edx, [ebp+var_8]
.text$mn:0000EEAF                 mov     eax, [ebp+var_8]
.text$mn:0000EEB2                 mov     ecx, [edx+0Ch]
.text$mn:0000EEB5                 sub     ecx, [eax+4]
.text$mn:0000EEB8                 sar     ecx, 2
.text$mn:0000EEBB                 push    ecx             ; int
.text$mn:0000EEBC                 mov     edx, [ebp+var_8]
.text$mn:0000EEBF                 mov     eax, [edx+4]
.text$mn:0000EEC2                 push    eax             ; void *
.text$mn:0000EEC3                 lea     ecx, [ebp+var_1]
.text$mn:0000EEC6                 push    ecx
.text$mn:0000EEC7                 mov     ecx, [ebp+var_8]
.text$mn:0000EECA                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000EECF                 mov     ecx, eax
.text$mn:0000EED1                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z ; std::_Wrap_alloc<std::allocator<uint>>::deallocate(uint *,uint)
.text$mn:0000EED6                 mov     edx, [ebp+var_8]
.text$mn:0000EED9                 mov     dword ptr [edx+4], 0
.text$mn:0000EEE0                 mov     eax, [ebp+var_8]
.text$mn:0000EEE3                 mov     dword ptr [eax+8], 0
.text$mn:0000EEEA                 mov     ecx, [ebp+var_8]
.text$mn:0000EEED                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000EEF4
.text$mn:0000EEF4 loc_EEF4:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Tidy(void)+10j
.text$mn:0000EEF4                 mov     esp, ebp
.text$mn:0000EEF6                 pop     ebp
.text$mn:0000EEF7                 retn
.text$mn:0000EEF7 ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ endp
.text$mn:0000EEF7
.text$mn:0000EEF7 _text$mn        ends
.text$mn:0000EEF7
.text$mn:0000EEF8 ; ===========================================================================
.text$mn:0000EEF8
.text$mn:0000EEF8 ; Segment type: Pure code
.text$mn:0000EEF8 ; Segment permissions: Read/Execute
.text$mn:0000EEF8 _text$mn        segment para public 'CODE' use32
.text$mn:0000EEF8                 assume cs:_text$mn
.text$mn:0000EEF8                 ;org 0EEF8h
.text$mn:0000EEF8 ; COMDAT (pick any)
.text$mn:0000EEF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000EEF8
.text$mn:0000EEF8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000EEF8
.text$mn:0000EEF8 ; Attributes: bp-based frame
.text$mn:0000EEF8
.text$mn:0000EEF8 ; protected: void __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::_Tidy(void)
.text$mn:0000EEF8                 public ?_Tidy@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXXZ
.text$mn:0000EEF8 ?_Tidy@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXXZ proc near
.text$mn:0000EEF8                                         ; CODE XREF: __catch$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$0+3p
.text$mn:0000EEF8                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::~vector<sessionFileInfo,std::allocator<sessionFileInfo>>(void)+30p
.text$mn:0000EEF8
.text$mn:0000EEF8 var_8           = dword ptr -8
.text$mn:0000EEF8 var_1           = byte ptr -1
.text$mn:0000EEF8
.text$mn:0000EEF8                 push    ebp
.text$mn:0000EEF9                 mov     ebp, esp
.text$mn:0000EEFB                 sub     esp, 8
.text$mn:0000EEFE                 mov     [ebp+var_8], ecx
.text$mn:0000EF01                 mov     eax, [ebp+var_8]
.text$mn:0000EF04                 cmp     dword ptr [eax+4], 0
.text$mn:0000EF08                 jz      short loc_EF77
.text$mn:0000EF0A                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000EF0D                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000EF12                 mov     ecx, [ebp+var_8]
.text$mn:0000EF15                 mov     edx, [ecx+8]
.text$mn:0000EF18                 push    edx
.text$mn:0000EF19                 mov     eax, [ebp+var_8]
.text$mn:0000EF1C                 mov     ecx, [eax+4]
.text$mn:0000EF1F                 push    ecx
.text$mn:0000EF20                 mov     ecx, [ebp+var_8]
.text$mn:0000EF23                 call    ?_Destroy@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXPAUsessionFileInfo@@0@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Destroy(sessionFileInfo *,sessionFileInfo *)
.text$mn:0000EF28                 mov     edx, [ebp+var_8]
.text$mn:0000EF2B                 mov     eax, [ebp+var_8]
.text$mn:0000EF2E                 mov     ecx, [edx+0Ch]
.text$mn:0000EF31                 sub     ecx, [eax+4]
.text$mn:0000EF34                 mov     eax, ecx
.text$mn:0000EF36                 cdq
.text$mn:0000EF37                 mov     ecx, 98h ; 'ÿ'
.text$mn:0000EF3C                 idiv    ecx
.text$mn:0000EF3E                 push    eax             ; int
.text$mn:0000EF3F                 mov     edx, [ebp+var_8]
.text$mn:0000EF42                 mov     eax, [edx+4]
.text$mn:0000EF45                 push    eax             ; void *
.text$mn:0000EF46                 lea     ecx, [ebp+var_1]
.text$mn:0000EF49                 push    ecx
.text$mn:0000EF4A                 mov     ecx, [ebp+var_8]
.text$mn:0000EF4D                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Getal(void)
.text$mn:0000EF52                 mov     ecx, eax
.text$mn:0000EF54                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@I@Z ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::deallocate(sessionFileInfo *,uint)
.text$mn:0000EF59                 mov     edx, [ebp+var_8]
.text$mn:0000EF5C                 mov     dword ptr [edx+4], 0
.text$mn:0000EF63                 mov     eax, [ebp+var_8]
.text$mn:0000EF66                 mov     dword ptr [eax+8], 0
.text$mn:0000EF6D                 mov     ecx, [ebp+var_8]
.text$mn:0000EF70                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000EF77
.text$mn:0000EF77 loc_EF77:                               ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Tidy(void)+10j
.text$mn:0000EF77                 mov     esp, ebp
.text$mn:0000EF79                 pop     ebp
.text$mn:0000EF7A                 retn
.text$mn:0000EF7A ?_Tidy@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXXZ endp
.text$mn:0000EF7A
.text$mn:0000EF7A ; ---------------------------------------------------------------------------
.text$mn:0000EF7B                 align 4
.text$mn:0000EF7B _text$mn        ends
.text$mn:0000EF7B
.text$mn:0000EF7C ; ===========================================================================
.text$mn:0000EF7C
.text$mn:0000EF7C ; Segment type: Pure code
.text$mn:0000EF7C ; Segment permissions: Read/Execute
.text$mn:0000EF7C _text$mn        segment para public 'CODE' use32
.text$mn:0000EF7C                 assume cs:_text$mn
.text$mn:0000EF7C                 ;org 0EF7Ch
.text$mn:0000EF7C ; COMDAT (pick any)
.text$mn:0000EF7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000EF7C
.text$mn:0000EF7C ; =============== S U B R O U T I N E =======================================
.text$mn:0000EF7C
.text$mn:0000EF7C ; Attributes: bp-based frame
.text$mn:0000EF7C
.text$mn:0000EF7C ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Tidy(void)
.text$mn:0000EF7C                 public ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ
.text$mn:0000EF7C ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ proc near
.text$mn:0000EF7C                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+30p
.text$mn:0000EF7C
.text$mn:0000EF7C var_8           = dword ptr -8
.text$mn:0000EF7C var_1           = byte ptr -1
.text$mn:0000EF7C
.text$mn:0000EF7C                 push    ebp
.text$mn:0000EF7D                 mov     ebp, esp
.text$mn:0000EF7F                 sub     esp, 8
.text$mn:0000EF82                 mov     [ebp+var_8], ecx
.text$mn:0000EF85                 mov     eax, [ebp+var_8]
.text$mn:0000EF88                 cmp     dword ptr [eax+4], 0
.text$mn:0000EF8C                 jz      short loc_EFFB
.text$mn:0000EF8E                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000EF91                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000EF96                 mov     ecx, [ebp+var_8]
.text$mn:0000EF99                 mov     edx, [ecx+8]
.text$mn:0000EF9C                 push    edx
.text$mn:0000EF9D                 mov     eax, [ebp+var_8]
.text$mn:0000EFA0                 mov     ecx, [eax+4]
.text$mn:0000EFA3                 push    ecx
.text$mn:0000EFA4                 mov     ecx, [ebp+var_8]
.text$mn:0000EFA7                 call    ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Destroy(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000EFAC                 mov     edx, [ebp+var_8]
.text$mn:0000EFAF                 mov     eax, [ebp+var_8]
.text$mn:0000EFB2                 mov     ecx, [edx+0Ch]
.text$mn:0000EFB5                 sub     ecx, [eax+4]
.text$mn:0000EFB8                 mov     eax, ecx
.text$mn:0000EFBA                 cdq
.text$mn:0000EFBB                 mov     ecx, 1Ch
.text$mn:0000EFC0                 idiv    ecx
.text$mn:0000EFC2                 push    eax             ; int
.text$mn:0000EFC3                 mov     edx, [ebp+var_8]
.text$mn:0000EFC6                 mov     eax, [edx+4]
.text$mn:0000EFC9                 push    eax             ; void *
.text$mn:0000EFCA                 lea     ecx, [ebp+var_1]
.text$mn:0000EFCD                 push    ecx
.text$mn:0000EFCE                 mov     ecx, [ebp+var_8]
.text$mn:0000EFD1                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000EFD6                 mov     ecx, eax
.text$mn:0000EFD8                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::deallocate(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,uint)
.text$mn:0000EFDD                 mov     edx, [ebp+var_8]
.text$mn:0000EFE0                 mov     dword ptr [edx+4], 0
.text$mn:0000EFE7                 mov     eax, [ebp+var_8]
.text$mn:0000EFEA                 mov     dword ptr [eax+8], 0
.text$mn:0000EFF1                 mov     ecx, [ebp+var_8]
.text$mn:0000EFF4                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000EFFB
.text$mn:0000EFFB loc_EFFB:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Tidy(void)+10j
.text$mn:0000EFFB                 mov     esp, ebp
.text$mn:0000EFFD                 pop     ebp
.text$mn:0000EFFE                 retn
.text$mn:0000EFFE ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ endp
.text$mn:0000EFFE
.text$mn:0000EFFE ; ---------------------------------------------------------------------------
.text$mn:0000EFFF                 align 10h
.text$mn:0000EFFF _text$mn        ends
.text$mn:0000EFFF
.text$mn:0000F000 ; ===========================================================================
.text$mn:0000F000
.text$mn:0000F000 ; Segment type: Pure code
.text$mn:0000F000 ; Segment permissions: Read/Execute
.text$mn:0000F000 _text$mn        segment para public 'CODE' use32
.text$mn:0000F000                 assume cs:_text$mn
.text$mn:0000F000                 ;org 0F000h
.text$mn:0000F000 ; COMDAT (pick any)
.text$mn:0000F000                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F000
.text$mn:0000F000 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F000
.text$mn:0000F000 ; Attributes: bp-based frame
.text$mn:0000F000
.text$mn:0000F000 ; public: unsigned int const * __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned int>>>::_Unchecked(void)const
.text$mn:0000F000                 public ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEPBIXZ
.text$mn:0000F000 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEPBIXZ proc near
.text$mn:0000F000                                         ; CODE XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<uint>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>)+2Dp
.text$mn:0000F000
.text$mn:0000F000 var_4           = dword ptr -4
.text$mn:0000F000
.text$mn:0000F000                 push    ebp
.text$mn:0000F001                 mov     ebp, esp
.text$mn:0000F003                 push    ecx
.text$mn:0000F004                 mov     [ebp+var_4], ecx
.text$mn:0000F007                 mov     eax, [ebp+var_4]
.text$mn:0000F00A                 mov     eax, [eax+8]
.text$mn:0000F00D                 mov     esp, ebp
.text$mn:0000F00F                 pop     ebp
.text$mn:0000F010                 retn
.text$mn:0000F010 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEPBIXZ endp
.text$mn:0000F010
.text$mn:0000F010 ; ---------------------------------------------------------------------------
.text$mn:0000F011                 align 4
.text$mn:0000F011 _text$mn        ends
.text$mn:0000F011
.text$mn:0000F014 ; ===========================================================================
.text$mn:0000F014
.text$mn:0000F014 ; Segment type: Pure code
.text$mn:0000F014 ; Segment permissions: Read/Execute
.text$mn:0000F014 _text$mn        segment para public 'CODE' use32
.text$mn:0000F014                 assume cs:_text$mn
.text$mn:0000F014                 ;org 0F014h
.text$mn:0000F014 ; COMDAT (pick any)
.text$mn:0000F014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F014
.text$mn:0000F014 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F014
.text$mn:0000F014 ; Attributes: bp-based frame
.text$mn:0000F014
.text$mn:0000F014 ; public: struct sessionFileInfo const * __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>::_Unchecked(void)const
.text$mn:0000F014                 public ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBEPBUsessionFileInfo@@XZ
.text$mn:0000F014 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBEPBUsessionFileInfo@@XZ proc near
.text$mn:0000F014                                         ; CODE XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)+2Dp
.text$mn:0000F014
.text$mn:0000F014 var_4           = dword ptr -4
.text$mn:0000F014
.text$mn:0000F014                 push    ebp
.text$mn:0000F015                 mov     ebp, esp
.text$mn:0000F017                 push    ecx
.text$mn:0000F018                 mov     [ebp+var_4], ecx
.text$mn:0000F01B                 mov     eax, [ebp+var_4]
.text$mn:0000F01E                 mov     eax, [eax+8]
.text$mn:0000F021                 mov     esp, ebp
.text$mn:0000F023                 pop     ebp
.text$mn:0000F024                 retn
.text$mn:0000F024 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBEPBUsessionFileInfo@@XZ endp
.text$mn:0000F024
.text$mn:0000F024 ; ---------------------------------------------------------------------------
.text$mn:0000F025                 align 4
.text$mn:0000F025 _text$mn        ends
.text$mn:0000F025
.text$mn:0000F028 ; ===========================================================================
.text$mn:0000F028
.text$mn:0000F028 ; Segment type: Pure code
.text$mn:0000F028 ; Segment permissions: Read/Execute
.text$mn:0000F028 _text$mn        segment para public 'CODE' use32
.text$mn:0000F028                 assume cs:_text$mn
.text$mn:0000F028                 ;org 0F028h
.text$mn:0000F028 ; COMDAT (pick any)
.text$mn:0000F028                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F028
.text$mn:0000F028 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F028
.text$mn:0000F028 ; Attributes: bp-based frame
.text$mn:0000F028
.text$mn:0000F028 ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::_Unused_capacity(void)const
.text$mn:0000F028                 public ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:0000F028 ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:0000F028                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+Bp
.text$mn:0000F028
.text$mn:0000F028 var_4           = dword ptr -4
.text$mn:0000F028
.text$mn:0000F028                 push    ebp
.text$mn:0000F029                 mov     ebp, esp
.text$mn:0000F02B                 push    ecx
.text$mn:0000F02C                 mov     [ebp+var_4], ecx
.text$mn:0000F02F                 mov     eax, [ebp+var_4]
.text$mn:0000F032                 mov     ecx, [ebp+var_4]
.text$mn:0000F035                 mov     eax, [eax+0Ch]
.text$mn:0000F038                 sub     eax, [ecx+8]
.text$mn:0000F03B                 sar     eax, 2
.text$mn:0000F03E                 mov     esp, ebp
.text$mn:0000F040                 pop     ebp
.text$mn:0000F041                 retn
.text$mn:0000F041 ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:0000F041
.text$mn:0000F041 ; ---------------------------------------------------------------------------
.text$mn:0000F042                 align 4
.text$mn:0000F042 _text$mn        ends
.text$mn:0000F042
.text$mn:0000F044 ; ===========================================================================
.text$mn:0000F044
.text$mn:0000F044 ; Segment type: Pure code
.text$mn:0000F044 ; Segment permissions: Read/Execute
.text$mn:0000F044 _text$mn        segment para public 'CODE' use32
.text$mn:0000F044                 assume cs:_text$mn
.text$mn:0000F044                 ;org 0F044h
.text$mn:0000F044 ; COMDAT (pick any)
.text$mn:0000F044                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F044
.text$mn:0000F044 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F044
.text$mn:0000F044 ; Attributes: bp-based frame
.text$mn:0000F044
.text$mn:0000F044 ; public: unsigned int __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::_Unused_capacity(void)const
.text$mn:0000F044                 public ?_Unused_capacity@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ
.text$mn:0000F044 ?_Unused_capacity@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:0000F044                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reserve(uint)+Bp
.text$mn:0000F044
.text$mn:0000F044 var_4           = dword ptr -4
.text$mn:0000F044
.text$mn:0000F044                 push    ebp
.text$mn:0000F045                 mov     ebp, esp
.text$mn:0000F047                 push    ecx
.text$mn:0000F048                 mov     [ebp+var_4], ecx
.text$mn:0000F04B                 mov     eax, [ebp+var_4]
.text$mn:0000F04E                 mov     ecx, [ebp+var_4]
.text$mn:0000F051                 mov     eax, [eax+0Ch]
.text$mn:0000F054                 sub     eax, [ecx+8]
.text$mn:0000F057                 cdq
.text$mn:0000F058                 mov     ecx, 98h ; 'ÿ'
.text$mn:0000F05D                 idiv    ecx
.text$mn:0000F05F                 mov     esp, ebp
.text$mn:0000F061                 pop     ebp
.text$mn:0000F062                 retn
.text$mn:0000F062 ?_Unused_capacity@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ endp
.text$mn:0000F062
.text$mn:0000F062 ; ---------------------------------------------------------------------------
.text$mn:0000F063                 align 4
.text$mn:0000F063 _text$mn        ends
.text$mn:0000F063
.text$mn:0000F064 ; ===========================================================================
.text$mn:0000F064
.text$mn:0000F064 ; Segment type: Pure code
.text$mn:0000F064 ; Segment permissions: Read/Execute
.text$mn:0000F064 _text$mn        segment para public 'CODE' use32
.text$mn:0000F064                 assume cs:_text$mn
.text$mn:0000F064                 ;org 0F064h
.text$mn:0000F064 ; COMDAT (pick any)
.text$mn:0000F064                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F064
.text$mn:0000F064 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F064
.text$mn:0000F064 ; Attributes: bp-based frame
.text$mn:0000F064
.text$mn:0000F064 ; public: unsigned int __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Unused_capacity(void)const
.text$mn:0000F064                 public ?_Unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ
.text$mn:0000F064 ?_Unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ proc near
.text$mn:0000F064                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+Bp
.text$mn:0000F064
.text$mn:0000F064 var_4           = dword ptr -4
.text$mn:0000F064
.text$mn:0000F064                 push    ebp
.text$mn:0000F065                 mov     ebp, esp
.text$mn:0000F067                 push    ecx
.text$mn:0000F068                 mov     [ebp+var_4], ecx
.text$mn:0000F06B                 mov     eax, [ebp+var_4]
.text$mn:0000F06E                 mov     ecx, [ebp+var_4]
.text$mn:0000F071                 mov     eax, [eax+0Ch]
.text$mn:0000F074                 sub     eax, [ecx+8]
.text$mn:0000F077                 cdq
.text$mn:0000F078                 mov     ecx, 1Ch
.text$mn:0000F07D                 idiv    ecx
.text$mn:0000F07F                 mov     esp, ebp
.text$mn:0000F081                 pop     ebp
.text$mn:0000F082                 retn
.text$mn:0000F082 ?_Unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ endp
.text$mn:0000F082
.text$mn:0000F082 ; ---------------------------------------------------------------------------
.text$mn:0000F083                 align 4
.text$mn:0000F083 _text$mn        ends
.text$mn:0000F083
.text$mn:0000F084 ; ===========================================================================
.text$mn:0000F084
.text$mn:0000F084 ; Segment type: Pure code
.text$mn:0000F084 ; Segment permissions: Read/Execute
.text$mn:0000F084 _text$mn        segment para public 'CODE' use32
.text$mn:0000F084                 assume cs:_text$mn
.text$mn:0000F084                 ;org 0F084h
.text$mn:0000F084 ; COMDAT (pick any)
.text$mn:0000F084                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F084
.text$mn:0000F084 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F084
.text$mn:0000F084 ; Attributes: bp-based frame
.text$mn:0000F084
.text$mn:0000F084 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:0000F084                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:0000F084 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:0000F084                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:0000F084
.text$mn:0000F084 var_4           = dword ptr -4
.text$mn:0000F084
.text$mn:0000F084                 push    ebp
.text$mn:0000F085                 mov     ebp, esp
.text$mn:0000F087                 push    ecx
.text$mn:0000F088                 mov     [ebp+var_4], ecx
.text$mn:0000F08B                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:0000F090                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000F095                 mov     esp, ebp
.text$mn:0000F097                 pop     ebp
.text$mn:0000F098                 retn
.text$mn:0000F098 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000F098
.text$mn:0000F098 ; ---------------------------------------------------------------------------
.text$mn:0000F099                 align 4
.text$mn:0000F099 _text$mn        ends
.text$mn:0000F099
.text$mn:0000F09C ; ===========================================================================
.text$mn:0000F09C
.text$mn:0000F09C ; Segment type: Pure code
.text$mn:0000F09C ; Segment permissions: Read/Execute
.text$mn:0000F09C _text$mn        segment para public 'CODE' use32
.text$mn:0000F09C                 assume cs:_text$mn
.text$mn:0000F09C                 ;org 0F09Ch
.text$mn:0000F09C ; COMDAT (pick any)
.text$mn:0000F09C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F09C
.text$mn:0000F09C ; =============== S U B R O U T I N E =======================================
.text$mn:0000F09C
.text$mn:0000F09C ; Attributes: bp-based frame
.text$mn:0000F09C
.text$mn:0000F09C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:0000F09C                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:0000F09C ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:0000F09C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:0000F09C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Dp ...
.text$mn:0000F09C
.text$mn:0000F09C var_4           = dword ptr -4
.text$mn:0000F09C
.text$mn:0000F09C                 push    ebp
.text$mn:0000F09D                 mov     ebp, esp
.text$mn:0000F09F                 push    ecx
.text$mn:0000F0A0                 mov     [ebp+var_4], ecx
.text$mn:0000F0A3                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:0000F0A8                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000F0AD                 mov     esp, ebp
.text$mn:0000F0AF                 pop     ebp
.text$mn:0000F0B0                 retn
.text$mn:0000F0B0 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:0000F0B0
.text$mn:0000F0B0 ; ---------------------------------------------------------------------------
.text$mn:0000F0B1                 align 4
.text$mn:0000F0B1 _text$mn        ends
.text$mn:0000F0B1
.text$mn:0000F0B4 ; ===========================================================================
.text$mn:0000F0B4
.text$mn:0000F0B4 ; Segment type: Pure code
.text$mn:0000F0B4 ; Segment permissions: Read/Execute
.text$mn:0000F0B4 _text$mn        segment para public 'CODE' use32
.text$mn:0000F0B4                 assume cs:_text$mn
.text$mn:0000F0B4                 ;org 0F0B4h
.text$mn:0000F0B4 ; COMDAT (pick any)
.text$mn:0000F0B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F0B4
.text$mn:0000F0B4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F0B4
.text$mn:0000F0B4 ; Attributes: bp-based frame
.text$mn:0000F0B4
.text$mn:0000F0B4 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Xlen(void)const
.text$mn:0000F0B4                 public ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
.text$mn:0000F0B4 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ proc near
.text$mn:0000F0B4                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+31p
.text$mn:0000F0B4
.text$mn:0000F0B4 var_4           = dword ptr -4
.text$mn:0000F0B4
.text$mn:0000F0B4                 push    ebp
.text$mn:0000F0B5                 mov     ebp, esp
.text$mn:0000F0B7                 push    ecx
.text$mn:0000F0B8                 mov     [ebp+var_4], ecx
.text$mn:0000F0BB                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000F0C0                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000F0C5                 mov     esp, ebp
.text$mn:0000F0C7                 pop     ebp
.text$mn:0000F0C8                 retn
.text$mn:0000F0C8 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ endp
.text$mn:0000F0C8
.text$mn:0000F0C8 ; ---------------------------------------------------------------------------
.text$mn:0000F0C9                 align 4
.text$mn:0000F0C9 _text$mn        ends
.text$mn:0000F0C9
.text$mn:0000F0CC ; ===========================================================================
.text$mn:0000F0CC
.text$mn:0000F0CC ; Segment type: Pure code
.text$mn:0000F0CC ; Segment permissions: Read/Execute
.text$mn:0000F0CC _text$mn        segment para public 'CODE' use32
.text$mn:0000F0CC                 assume cs:_text$mn
.text$mn:0000F0CC                 ;org 0F0CCh
.text$mn:0000F0CC ; COMDAT (pick any)
.text$mn:0000F0CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F0CC
.text$mn:0000F0CC ; =============== S U B R O U T I N E =======================================
.text$mn:0000F0CC
.text$mn:0000F0CC ; Attributes: bp-based frame
.text$mn:0000F0CC
.text$mn:0000F0CC ; protected: void __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::_Xlen(void)const
.text$mn:0000F0CC                 public ?_Xlen@?$vector@IV?$allocator@I@std@@@std@@IBEXXZ
.text$mn:0000F0CC ?_Xlen@?$vector@IV?$allocator@I@std@@@std@@IBEXXZ proc near
.text$mn:0000F0CC                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Buy(uint)+43p
.text$mn:0000F0CC
.text$mn:0000F0CC var_4           = dword ptr -4
.text$mn:0000F0CC
.text$mn:0000F0CC                 push    ebp
.text$mn:0000F0CD                 mov     ebp, esp
.text$mn:0000F0CF                 push    ecx
.text$mn:0000F0D0                 mov     [ebp+var_4], ecx
.text$mn:0000F0D3                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000F0D8                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000F0DD                 mov     esp, ebp
.text$mn:0000F0DF                 pop     ebp
.text$mn:0000F0E0                 retn
.text$mn:0000F0E0 ?_Xlen@?$vector@IV?$allocator@I@std@@@std@@IBEXXZ endp
.text$mn:0000F0E0
.text$mn:0000F0E0 ; ---------------------------------------------------------------------------
.text$mn:0000F0E1                 align 4
.text$mn:0000F0E1 _text$mn        ends
.text$mn:0000F0E1
.text$mn:0000F0E4 ; ===========================================================================
.text$mn:0000F0E4
.text$mn:0000F0E4 ; Segment type: Pure code
.text$mn:0000F0E4 ; Segment permissions: Read/Execute
.text$mn:0000F0E4 _text$mn        segment para public 'CODE' use32
.text$mn:0000F0E4                 assume cs:_text$mn
.text$mn:0000F0E4                 ;org 0F0E4h
.text$mn:0000F0E4 ; COMDAT (pick any)
.text$mn:0000F0E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F0E4
.text$mn:0000F0E4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F0E4
.text$mn:0000F0E4 ; Attributes: bp-based frame
.text$mn:0000F0E4
.text$mn:0000F0E4 ; protected: void __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::_Xlen(void)const
.text$mn:0000F0E4                 public ?_Xlen@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXXZ
.text$mn:0000F0E4 ?_Xlen@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXXZ proc near
.text$mn:0000F0E4                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Buy(uint)+43p
.text$mn:0000F0E4                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reserve(uint)+31p
.text$mn:0000F0E4
.text$mn:0000F0E4 var_4           = dword ptr -4
.text$mn:0000F0E4
.text$mn:0000F0E4                 push    ebp
.text$mn:0000F0E5                 mov     ebp, esp
.text$mn:0000F0E7                 push    ecx
.text$mn:0000F0E8                 mov     [ebp+var_4], ecx
.text$mn:0000F0EB                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000F0F0                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000F0F5                 mov     esp, ebp
.text$mn:0000F0F7                 pop     ebp
.text$mn:0000F0F8                 retn
.text$mn:0000F0F8 ?_Xlen@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXXZ endp
.text$mn:0000F0F8
.text$mn:0000F0F8 ; ---------------------------------------------------------------------------
.text$mn:0000F0F9                 align 4
.text$mn:0000F0F9 _text$mn        ends
.text$mn:0000F0F9
.text$mn:0000F0FC ; ===========================================================================
.text$mn:0000F0FC
.text$mn:0000F0FC ; Segment type: Pure code
.text$mn:0000F0FC ; Segment permissions: Read/Execute
.text$mn:0000F0FC _text$mn        segment para public 'CODE' use32
.text$mn:0000F0FC                 assume cs:_text$mn
.text$mn:0000F0FC                 ;org 0F0FCh
.text$mn:0000F0FC ; COMDAT (pick any)
.text$mn:0000F0FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F0FC
.text$mn:0000F0FC ; =============== S U B R O U T I N E =======================================
.text$mn:0000F0FC
.text$mn:0000F0FC ; Attributes: bp-based frame
.text$mn:0000F0FC
.text$mn:0000F0FC ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Xlen(void)const
.text$mn:0000F0FC                 public ?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ
.text$mn:0000F0FC ?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ proc near
.text$mn:0000F0FC                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+31p
.text$mn:0000F0FC
.text$mn:0000F0FC var_4           = dword ptr -4
.text$mn:0000F0FC
.text$mn:0000F0FC                 push    ebp
.text$mn:0000F0FD                 mov     ebp, esp
.text$mn:0000F0FF                 push    ecx
.text$mn:0000F100                 mov     [ebp+var_4], ecx
.text$mn:0000F103                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000F108                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000F10D                 mov     esp, ebp
.text$mn:0000F10F                 pop     ebp
.text$mn:0000F110                 retn
.text$mn:0000F110 ?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ endp
.text$mn:0000F110
.text$mn:0000F110 ; ---------------------------------------------------------------------------
.text$mn:0000F111                 align 4
.text$mn:0000F111 _text$mn        ends
.text$mn:0000F111
.text$mn:0000F114 ; ===========================================================================
.text$mn:0000F114
.text$mn:0000F114 ; Segment type: Pure code
.text$mn:0000F114 ; Segment permissions: Read/Execute
.text$mn:0000F114 _text$mn        segment para public 'CODE' use32
.text$mn:0000F114                 assume cs:_text$mn
.text$mn:0000F114                 ;org 0F114h
.text$mn:0000F114 ; COMDAT (pick any)
.text$mn:0000F114                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F114
.text$mn:0000F114 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F114
.text$mn:0000F114 ; Attributes: bp-based frame
.text$mn:0000F114
.text$mn:0000F114 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:0000F114                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:0000F114 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:0000F114                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:0000F114                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:0000F114
.text$mn:0000F114 var_4           = dword ptr -4
.text$mn:0000F114
.text$mn:0000F114                 push    ebp
.text$mn:0000F115                 mov     ebp, esp
.text$mn:0000F117                 push    ecx
.text$mn:0000F118                 mov     [ebp+var_4], ecx
.text$mn:0000F11B                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:0000F120                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:0000F125                 mov     esp, ebp
.text$mn:0000F127                 pop     ebp
.text$mn:0000F128                 retn
.text$mn:0000F128 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000F128
.text$mn:0000F128 ; ---------------------------------------------------------------------------
.text$mn:0000F129                 align 4
.text$mn:0000F129 _text$mn        ends
.text$mn:0000F129
.text$mn:0000F12C ; ===========================================================================
.text$mn:0000F12C
.text$mn:0000F12C ; Segment type: Pure code
.text$mn:0000F12C ; Segment permissions: Read/Execute
.text$mn:0000F12C _text$mn        segment para public 'CODE' use32
.text$mn:0000F12C                 assume cs:_text$mn
.text$mn:0000F12C                 ;org 0F12Ch
.text$mn:0000F12C ; COMDAT (pick any)
.text$mn:0000F12C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F12C
.text$mn:0000F12C ; =============== S U B R O U T I N E =======================================
.text$mn:0000F12C
.text$mn:0000F12C ; Attributes: bp-based frame
.text$mn:0000F12C
.text$mn:0000F12C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:0000F12C                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:0000F12C ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:0000F12C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:0000F12C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p ...
.text$mn:0000F12C
.text$mn:0000F12C var_4           = dword ptr -4
.text$mn:0000F12C
.text$mn:0000F12C                 push    ebp
.text$mn:0000F12D                 mov     ebp, esp
.text$mn:0000F12F                 push    ecx
.text$mn:0000F130                 mov     [ebp+var_4], ecx
.text$mn:0000F133                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:0000F138                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:0000F13D                 mov     esp, ebp
.text$mn:0000F13F                 pop     ebp
.text$mn:0000F140                 retn
.text$mn:0000F140 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:0000F140
.text$mn:0000F140 ; ---------------------------------------------------------------------------
.text$mn:0000F141                 align 4
.text$mn:0000F141 _text$mn        ends
.text$mn:0000F141
.text$mn:0000F144 ; ===========================================================================
.text$mn:0000F144
.text$mn:0000F144 ; Segment type: Pure code
.text$mn:0000F144 ; Segment permissions: Read/Execute
.text$mn:0000F144 _text$mn        segment para public 'CODE' use32
.text$mn:0000F144                 assume cs:_text$mn
.text$mn:0000F144                 ;org 0F144h
.text$mn:0000F144 ; COMDAT (pick any)
.text$mn:0000F144                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F144
.text$mn:0000F144 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F144
.text$mn:0000F144 ; Attributes: bp-based frame
.text$mn:0000F144
.text$mn:0000F144 ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Xran(void)const
.text$mn:0000F144                 public ?_Xran@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ
.text$mn:0000F144 ?_Xran@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ proc near
.text$mn:0000F144                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::at(uint)+17p
.text$mn:0000F144
.text$mn:0000F144 var_4           = dword ptr -4
.text$mn:0000F144
.text$mn:0000F144                 push    ebp
.text$mn:0000F145                 mov     ebp, esp
.text$mn:0000F147                 push    ecx
.text$mn:0000F148                 mov     [ebp+var_4], ecx
.text$mn:0000F14B                 push    offset ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; "invalid vector<T> subscript"
.text$mn:0000F150                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:0000F155                 mov     esp, ebp
.text$mn:0000F157                 pop     ebp
.text$mn:0000F158                 retn
.text$mn:0000F158 ?_Xran@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ endp
.text$mn:0000F158
.text$mn:0000F158 ; ---------------------------------------------------------------------------
.text$mn:0000F159                 align 4
.text$mn:0000F159 _text$mn        ends
.text$mn:0000F159
.text$mn:0000F15C ; ===========================================================================
.text$mn:0000F15C
.text$mn:0000F15C ; Segment type: Pure code
.text$mn:0000F15C ; Segment permissions: Read/Execute
.text$mn:0000F15C _text$mn        segment para public 'CODE' use32
.text$mn:0000F15C                 assume cs:_text$mn
.text$mn:0000F15C                 ;org 0F15Ch
.text$mn:0000F15C ; COMDAT (pick any)
.text$mn:0000F15C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F15C
.text$mn:0000F15C ; =============== S U B R O U T I N E =======================================
.text$mn:0000F15C
.text$mn:0000F15C ; Attributes: bp-based frame
.text$mn:0000F15C
.text$mn:0000F15C ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:0000F15C                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:0000F15C ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:0000F15C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:0000F15C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:0000F15C
.text$mn:0000F15C var_4           = dword ptr -4
.text$mn:0000F15C arg_0           = dword ptr  8
.text$mn:0000F15C
.text$mn:0000F15C                 push    ebp
.text$mn:0000F15D                 mov     ebp, esp
.text$mn:0000F15F                 push    ecx
.text$mn:0000F160                 mov     [ebp+var_4], ecx
.text$mn:0000F163                 mov     eax, [ebp+arg_0]
.text$mn:0000F166                 push    eax
.text$mn:0000F167                 mov     ecx, [ebp+var_4]
.text$mn:0000F16A                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000F16F                 mov     esp, ebp
.text$mn:0000F171                 pop     ebp
.text$mn:0000F172                 retn    4
.text$mn:0000F172 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:0000F172
.text$mn:0000F172 ; ---------------------------------------------------------------------------
.text$mn:0000F175                 align 4
.text$mn:0000F175 _text$mn        ends
.text$mn:0000F175
.text$mn:0000F178 ; ===========================================================================
.text$mn:0000F178
.text$mn:0000F178 ; Segment type: Pure code
.text$mn:0000F178 ; Segment permissions: Read/Execute
.text$mn:0000F178 _text$mn        segment para public 'CODE' use32
.text$mn:0000F178                 assume cs:_text$mn
.text$mn:0000F178                 ;org 0F178h
.text$mn:0000F178 ; COMDAT (pick any)
.text$mn:0000F178                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F178
.text$mn:0000F178 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F178
.text$mn:0000F178 ; Attributes: bp-based frame
.text$mn:0000F178
.text$mn:0000F178 ; public: int * __thiscall std::_Wrap_alloc<class std::allocator<int>>::allocate(unsigned int)
.text$mn:0000F178                 public ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z
.text$mn:0000F178 ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z proc near
.text$mn:0000F178                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+41p
.text$mn:0000F178
.text$mn:0000F178 var_4           = dword ptr -4
.text$mn:0000F178 arg_0           = dword ptr  8
.text$mn:0000F178
.text$mn:0000F178                 push    ebp
.text$mn:0000F179                 mov     ebp, esp
.text$mn:0000F17B                 push    ecx
.text$mn:0000F17C                 mov     [ebp+var_4], ecx
.text$mn:0000F17F                 mov     eax, [ebp+arg_0]
.text$mn:0000F182                 push    eax
.text$mn:0000F183                 mov     ecx, [ebp+var_4]
.text$mn:0000F186                 call    ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate(uint)
.text$mn:0000F18B                 mov     esp, ebp
.text$mn:0000F18D                 pop     ebp
.text$mn:0000F18E                 retn    4
.text$mn:0000F18E ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z endp
.text$mn:0000F18E
.text$mn:0000F18E ; ---------------------------------------------------------------------------
.text$mn:0000F191                 align 4
.text$mn:0000F191 _text$mn        ends
.text$mn:0000F191
.text$mn:0000F194 ; ===========================================================================
.text$mn:0000F194
.text$mn:0000F194 ; Segment type: Pure code
.text$mn:0000F194 ; Segment permissions: Read/Execute
.text$mn:0000F194 _text$mn        segment para public 'CODE' use32
.text$mn:0000F194                 assume cs:_text$mn
.text$mn:0000F194                 ;org 0F194h
.text$mn:0000F194 ; COMDAT (pick any)
.text$mn:0000F194                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F194
.text$mn:0000F194 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F194
.text$mn:0000F194 ; Attributes: bp-based frame
.text$mn:0000F194
.text$mn:0000F194 ; public: unsigned int * __thiscall std::_Wrap_alloc<class std::allocator<unsigned int>>::allocate(unsigned int)
.text$mn:0000F194                 public ?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z
.text$mn:0000F194 ?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z proc near
.text$mn:0000F194                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Buy(uint)+5Cp
.text$mn:0000F194
.text$mn:0000F194 var_4           = dword ptr -4
.text$mn:0000F194 arg_0           = dword ptr  8
.text$mn:0000F194
.text$mn:0000F194                 push    ebp
.text$mn:0000F195                 mov     ebp, esp
.text$mn:0000F197                 push    ecx
.text$mn:0000F198                 mov     [ebp+var_4], ecx
.text$mn:0000F19B                 mov     eax, [ebp+arg_0]
.text$mn:0000F19E                 push    eax
.text$mn:0000F19F                 mov     ecx, [ebp+var_4]
.text$mn:0000F1A2                 call    ?allocate@?$allocator@I@std@@QAEPAII@Z ; std::allocator<uint>::allocate(uint)
.text$mn:0000F1A7                 mov     esp, ebp
.text$mn:0000F1A9                 pop     ebp
.text$mn:0000F1AA                 retn    4
.text$mn:0000F1AA ?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z endp
.text$mn:0000F1AA
.text$mn:0000F1AA ; ---------------------------------------------------------------------------
.text$mn:0000F1AD                 align 10h
.text$mn:0000F1AD _text$mn        ends
.text$mn:0000F1AD
.text$mn:0000F1B0 ; ===========================================================================
.text$mn:0000F1B0
.text$mn:0000F1B0 ; Segment type: Pure code
.text$mn:0000F1B0 ; Segment permissions: Read/Execute
.text$mn:0000F1B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000F1B0                 assume cs:_text$mn
.text$mn:0000F1B0                 ;org 0F1B0h
.text$mn:0000F1B0 ; COMDAT (pick any)
.text$mn:0000F1B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F1B0
.text$mn:0000F1B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F1B0
.text$mn:0000F1B0 ; Attributes: bp-based frame
.text$mn:0000F1B0
.text$mn:0000F1B0 ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:0000F1B0                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:0000F1B0 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:0000F1B0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Alloc_proxy(void)+16p
.text$mn:0000F1B0                                         ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Alloc_proxy(void)+16p ...
.text$mn:0000F1B0
.text$mn:0000F1B0 var_4           = dword ptr -4
.text$mn:0000F1B0 arg_0           = dword ptr  8
.text$mn:0000F1B0
.text$mn:0000F1B0                 push    ebp
.text$mn:0000F1B1                 mov     ebp, esp
.text$mn:0000F1B3                 push    ecx
.text$mn:0000F1B4                 mov     [ebp+var_4], ecx
.text$mn:0000F1B7                 mov     eax, [ebp+arg_0]
.text$mn:0000F1BA                 push    eax
.text$mn:0000F1BB                 mov     ecx, [ebp+var_4]
.text$mn:0000F1BE                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:0000F1C3                 mov     esp, ebp
.text$mn:0000F1C5                 pop     ebp
.text$mn:0000F1C6                 retn    4
.text$mn:0000F1C6 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:0000F1C6
.text$mn:0000F1C6 ; ---------------------------------------------------------------------------
.text$mn:0000F1C9                 align 4
.text$mn:0000F1C9 _text$mn        ends
.text$mn:0000F1C9
.text$mn:0000F1CC ; ===========================================================================
.text$mn:0000F1CC
.text$mn:0000F1CC ; Segment type: Pure code
.text$mn:0000F1CC ; Segment permissions: Read/Execute
.text$mn:0000F1CC _text$mn        segment para public 'CODE' use32
.text$mn:0000F1CC                 assume cs:_text$mn
.text$mn:0000F1CC                 ;org 0F1CCh
.text$mn:0000F1CC ; COMDAT (pick any)
.text$mn:0000F1CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F1CC
.text$mn:0000F1CC ; =============== S U B R O U T I N E =======================================
.text$mn:0000F1CC
.text$mn:0000F1CC ; Attributes: bp-based frame
.text$mn:0000F1CC
.text$mn:0000F1CC ; public: struct sessionFileInfo * __thiscall std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>>::allocate(unsigned int)
.text$mn:0000F1CC                 public ?allocate@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEPAUsessionFileInfo@@I@Z
.text$mn:0000F1CC ?allocate@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEPAUsessionFileInfo@@I@Z proc near
.text$mn:0000F1CC                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Buy(uint)+5Cp
.text$mn:0000F1CC                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reallocate(uint)+41p
.text$mn:0000F1CC
.text$mn:0000F1CC var_4           = dword ptr -4
.text$mn:0000F1CC arg_0           = dword ptr  8
.text$mn:0000F1CC
.text$mn:0000F1CC                 push    ebp
.text$mn:0000F1CD                 mov     ebp, esp
.text$mn:0000F1CF                 push    ecx
.text$mn:0000F1D0                 mov     [ebp+var_4], ecx
.text$mn:0000F1D3                 mov     eax, [ebp+arg_0]
.text$mn:0000F1D6                 push    eax
.text$mn:0000F1D7                 mov     ecx, [ebp+var_4]
.text$mn:0000F1DA                 call    ?allocate@?$allocator@UsessionFileInfo@@@std@@QAEPAUsessionFileInfo@@I@Z ; std::allocator<sessionFileInfo>::allocate(uint)
.text$mn:0000F1DF                 mov     esp, ebp
.text$mn:0000F1E1                 pop     ebp
.text$mn:0000F1E2                 retn    4
.text$mn:0000F1E2 ?allocate@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEPAUsessionFileInfo@@I@Z endp
.text$mn:0000F1E2
.text$mn:0000F1E2 ; ---------------------------------------------------------------------------
.text$mn:0000F1E5                 align 4
.text$mn:0000F1E5 _text$mn        ends
.text$mn:0000F1E5
.text$mn:0000F1E8 ; ===========================================================================
.text$mn:0000F1E8
.text$mn:0000F1E8 ; Segment type: Pure code
.text$mn:0000F1E8 ; Segment permissions: Read/Execute
.text$mn:0000F1E8 _text$mn        segment para public 'CODE' use32
.text$mn:0000F1E8                 assume cs:_text$mn
.text$mn:0000F1E8                 ;org 0F1E8h
.text$mn:0000F1E8 ; COMDAT (pick any)
.text$mn:0000F1E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F1E8
.text$mn:0000F1E8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F1E8
.text$mn:0000F1E8 ; Attributes: bp-based frame
.text$mn:0000F1E8
.text$mn:0000F1E8 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __thiscall std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::allocate(unsigned int)
.text$mn:0000F1E8                 public ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:0000F1E8 ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$mn:0000F1E8                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+41p
.text$mn:0000F1E8
.text$mn:0000F1E8 var_4           = dword ptr -4
.text$mn:0000F1E8 arg_0           = dword ptr  8
.text$mn:0000F1E8
.text$mn:0000F1E8                 push    ebp
.text$mn:0000F1E9                 mov     ebp, esp
.text$mn:0000F1EB                 push    ecx
.text$mn:0000F1EC                 mov     [ebp+var_4], ecx
.text$mn:0000F1EF                 mov     eax, [ebp+arg_0]
.text$mn:0000F1F2                 push    eax
.text$mn:0000F1F3                 mov     ecx, [ebp+var_4]
.text$mn:0000F1F6                 call    ?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::allocate(uint)
.text$mn:0000F1FB                 mov     esp, ebp
.text$mn:0000F1FD                 pop     ebp
.text$mn:0000F1FE                 retn    4
.text$mn:0000F1FE ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp
.text$mn:0000F1FE
.text$mn:0000F1FE ; ---------------------------------------------------------------------------
.text$mn:0000F201                 align 4
.text$mn:0000F201 _text$mn        ends
.text$mn:0000F201
.text$mn:0000F204 ; ===========================================================================
.text$mn:0000F204
.text$mn:0000F204 ; Segment type: Pure code
.text$mn:0000F204 ; Segment permissions: Read/Execute
.text$mn:0000F204 _text$mn        segment para public 'CODE' use32
.text$mn:0000F204                 assume cs:_text$mn
.text$mn:0000F204                 ;org 0F204h
.text$mn:0000F204 ; COMDAT (pick any)
.text$mn:0000F204                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F204
.text$mn:0000F204 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F204
.text$mn:0000F204 ; Attributes: bp-based frame
.text$mn:0000F204
.text$mn:0000F204 ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:0000F204                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:0000F204 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:0000F204                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:0000F204                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:0000F204
.text$mn:0000F204 var_4           = dword ptr -4
.text$mn:0000F204 arg_0           = dword ptr  8
.text$mn:0000F204
.text$mn:0000F204                 push    ebp
.text$mn:0000F205                 mov     ebp, esp
.text$mn:0000F207                 push    ecx
.text$mn:0000F208                 mov     [ebp+var_4], ecx
.text$mn:0000F20B                 mov     eax, [ebp+arg_0]
.text$mn:0000F20E                 push    eax
.text$mn:0000F20F                 mov     ecx, [ebp+var_4]
.text$mn:0000F212                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:0000F217                 mov     esp, ebp
.text$mn:0000F219                 pop     ebp
.text$mn:0000F21A                 retn    4
.text$mn:0000F21A ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:0000F21A
.text$mn:0000F21A ; ---------------------------------------------------------------------------
.text$mn:0000F21D                 align 10h
.text$mn:0000F21D _text$mn        ends
.text$mn:0000F21D
.text$mn:0000F220 ; ===========================================================================
.text$mn:0000F220
.text$mn:0000F220 ; Segment type: Pure code
.text$mn:0000F220 ; Segment permissions: Read/Execute
.text$mn:0000F220 _text$mn        segment para public 'CODE' use32
.text$mn:0000F220                 assume cs:_text$mn
.text$mn:0000F220                 ;org 0F220h
.text$mn:0000F220 ; COMDAT (pick any)
.text$mn:0000F220                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F220
.text$mn:0000F220 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F220
.text$mn:0000F220 ; Attributes: bp-based frame
.text$mn:0000F220
.text$mn:0000F220 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:0000F220                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:0000F220 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:0000F220                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:0000F220
.text$mn:0000F220 var_4           = dword ptr -4
.text$mn:0000F220 arg_0           = dword ptr  8
.text$mn:0000F220
.text$mn:0000F220                 push    ebp
.text$mn:0000F221                 mov     ebp, esp
.text$mn:0000F223                 push    ecx
.text$mn:0000F224                 mov     [ebp+var_4], ecx
.text$mn:0000F227                 push    0
.text$mn:0000F229                 mov     eax, [ebp+arg_0]
.text$mn:0000F22C                 push    eax
.text$mn:0000F22D                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:0000F232                 add     esp, 8
.text$mn:0000F235                 mov     esp, ebp
.text$mn:0000F237                 pop     ebp
.text$mn:0000F238                 retn    4
.text$mn:0000F238 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:0000F238
.text$mn:0000F238 ; ---------------------------------------------------------------------------
.text$mn:0000F23B                 align 4
.text$mn:0000F23B _text$mn        ends
.text$mn:0000F23B
.text$mn:0000F23C ; ===========================================================================
.text$mn:0000F23C
.text$mn:0000F23C ; Segment type: Pure code
.text$mn:0000F23C ; Segment permissions: Read/Execute
.text$mn:0000F23C _text$mn        segment para public 'CODE' use32
.text$mn:0000F23C                 assume cs:_text$mn
.text$mn:0000F23C                 ;org 0F23Ch
.text$mn:0000F23C ; COMDAT (pick any)
.text$mn:0000F23C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F23C
.text$mn:0000F23C ; =============== S U B R O U T I N E =======================================
.text$mn:0000F23C
.text$mn:0000F23C ; Attributes: bp-based frame
.text$mn:0000F23C
.text$mn:0000F23C ; public: int * __thiscall std::allocator<int>::allocate(unsigned int)
.text$mn:0000F23C                 public ?allocate@?$allocator@H@std@@QAEPAHI@Z
.text$mn:0000F23C ?allocate@?$allocator@H@std@@QAEPAHI@Z proc near
.text$mn:0000F23C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::allocate(uint)+Ep
.text$mn:0000F23C
.text$mn:0000F23C var_4           = dword ptr -4
.text$mn:0000F23C arg_0           = dword ptr  8
.text$mn:0000F23C
.text$mn:0000F23C                 push    ebp
.text$mn:0000F23D                 mov     ebp, esp
.text$mn:0000F23F                 push    ecx
.text$mn:0000F240                 mov     [ebp+var_4], ecx
.text$mn:0000F243                 push    0
.text$mn:0000F245                 mov     eax, [ebp+arg_0]
.text$mn:0000F248                 push    eax
.text$mn:0000F249                 call    ??$_Allocate@H@std@@YAPAHIPAH@Z ; std::_Allocate<int>(uint,int *)
.text$mn:0000F24E                 add     esp, 8
.text$mn:0000F251                 mov     esp, ebp
.text$mn:0000F253                 pop     ebp
.text$mn:0000F254                 retn    4
.text$mn:0000F254 ?allocate@?$allocator@H@std@@QAEPAHI@Z endp
.text$mn:0000F254
.text$mn:0000F254 ; ---------------------------------------------------------------------------
.text$mn:0000F257                 align 4
.text$mn:0000F257 _text$mn        ends
.text$mn:0000F257
.text$mn:0000F258 ; ===========================================================================
.text$mn:0000F258
.text$mn:0000F258 ; Segment type: Pure code
.text$mn:0000F258 ; Segment permissions: Read/Execute
.text$mn:0000F258 _text$mn        segment para public 'CODE' use32
.text$mn:0000F258                 assume cs:_text$mn
.text$mn:0000F258                 ;org 0F258h
.text$mn:0000F258 ; COMDAT (pick any)
.text$mn:0000F258                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F258
.text$mn:0000F258 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F258
.text$mn:0000F258 ; Attributes: bp-based frame
.text$mn:0000F258
.text$mn:0000F258 ; public: unsigned int * __thiscall std::allocator<unsigned int>::allocate(unsigned int)
.text$mn:0000F258                 public ?allocate@?$allocator@I@std@@QAEPAII@Z
.text$mn:0000F258 ?allocate@?$allocator@I@std@@QAEPAII@Z proc near
.text$mn:0000F258                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::allocate(uint)+Ep
.text$mn:0000F258
.text$mn:0000F258 var_4           = dword ptr -4
.text$mn:0000F258 arg_0           = dword ptr  8
.text$mn:0000F258
.text$mn:0000F258                 push    ebp
.text$mn:0000F259                 mov     ebp, esp
.text$mn:0000F25B                 push    ecx
.text$mn:0000F25C                 mov     [ebp+var_4], ecx
.text$mn:0000F25F                 push    0
.text$mn:0000F261                 mov     eax, [ebp+arg_0]
.text$mn:0000F264                 push    eax
.text$mn:0000F265                 call    ??$_Allocate@I@std@@YAPAIIPAI@Z ; std::_Allocate<uint>(uint,uint *)
.text$mn:0000F26A                 add     esp, 8
.text$mn:0000F26D                 mov     esp, ebp
.text$mn:0000F26F                 pop     ebp
.text$mn:0000F270                 retn    4
.text$mn:0000F270 ?allocate@?$allocator@I@std@@QAEPAII@Z endp
.text$mn:0000F270
.text$mn:0000F270 ; ---------------------------------------------------------------------------
.text$mn:0000F273                 align 4
.text$mn:0000F273 _text$mn        ends
.text$mn:0000F273
.text$mn:0000F274 ; ===========================================================================
.text$mn:0000F274
.text$mn:0000F274 ; Segment type: Pure code
.text$mn:0000F274 ; Segment permissions: Read/Execute
.text$mn:0000F274 _text$mn        segment para public 'CODE' use32
.text$mn:0000F274                 assume cs:_text$mn
.text$mn:0000F274                 ;org 0F274h
.text$mn:0000F274 ; COMDAT (pick any)
.text$mn:0000F274                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F274
.text$mn:0000F274 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F274
.text$mn:0000F274 ; Attributes: bp-based frame
.text$mn:0000F274
.text$mn:0000F274 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:0000F274                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:0000F274 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:0000F274                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:0000F274                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p ...
.text$mn:0000F274
.text$mn:0000F274 var_4           = dword ptr -4
.text$mn:0000F274 arg_0           = dword ptr  8
.text$mn:0000F274
.text$mn:0000F274                 push    ebp
.text$mn:0000F275                 mov     ebp, esp
.text$mn:0000F277                 push    ecx
.text$mn:0000F278                 mov     [ebp+var_4], ecx
.text$mn:0000F27B                 push    0
.text$mn:0000F27D                 mov     eax, [ebp+arg_0]
.text$mn:0000F280                 push    eax
.text$mn:0000F281                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000F286                 add     esp, 8
.text$mn:0000F289                 mov     esp, ebp
.text$mn:0000F28B                 pop     ebp
.text$mn:0000F28C                 retn    4
.text$mn:0000F28C ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:0000F28C
.text$mn:0000F28C ; ---------------------------------------------------------------------------
.text$mn:0000F28F                 align 10h
.text$mn:0000F28F _text$mn        ends
.text$mn:0000F28F
.text$mn:0000F290 ; ===========================================================================
.text$mn:0000F290
.text$mn:0000F290 ; Segment type: Pure code
.text$mn:0000F290 ; Segment permissions: Read/Execute
.text$mn:0000F290 _text$mn        segment para public 'CODE' use32
.text$mn:0000F290                 assume cs:_text$mn
.text$mn:0000F290                 ;org 0F290h
.text$mn:0000F290 ; COMDAT (pick any)
.text$mn:0000F290                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F290
.text$mn:0000F290 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F290
.text$mn:0000F290 ; Attributes: bp-based frame
.text$mn:0000F290
.text$mn:0000F290 ; public: struct sessionFileInfo * __thiscall std::allocator<struct sessionFileInfo>::allocate(unsigned int)
.text$mn:0000F290                 public ?allocate@?$allocator@UsessionFileInfo@@@std@@QAEPAUsessionFileInfo@@I@Z
.text$mn:0000F290 ?allocate@?$allocator@UsessionFileInfo@@@std@@QAEPAUsessionFileInfo@@I@Z proc near
.text$mn:0000F290                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<sessionFileInfo>>::allocate(uint)+Ep
.text$mn:0000F290
.text$mn:0000F290 var_4           = dword ptr -4
.text$mn:0000F290 arg_0           = dword ptr  8
.text$mn:0000F290
.text$mn:0000F290                 push    ebp
.text$mn:0000F291                 mov     ebp, esp
.text$mn:0000F293                 push    ecx
.text$mn:0000F294                 mov     [ebp+var_4], ecx
.text$mn:0000F297                 push    0
.text$mn:0000F299                 mov     eax, [ebp+arg_0]
.text$mn:0000F29C                 push    eax
.text$mn:0000F29D                 call    ??$_Allocate@UsessionFileInfo@@@std@@YAPAUsessionFileInfo@@IPAU1@@Z ; std::_Allocate<sessionFileInfo>(uint,sessionFileInfo *)
.text$mn:0000F2A2                 add     esp, 8
.text$mn:0000F2A5                 mov     esp, ebp
.text$mn:0000F2A7                 pop     ebp
.text$mn:0000F2A8                 retn    4
.text$mn:0000F2A8 ?allocate@?$allocator@UsessionFileInfo@@@std@@QAEPAUsessionFileInfo@@I@Z endp
.text$mn:0000F2A8
.text$mn:0000F2A8 ; ---------------------------------------------------------------------------
.text$mn:0000F2AB                 align 4
.text$mn:0000F2AB _text$mn        ends
.text$mn:0000F2AB
.text$mn:0000F2AC ; ===========================================================================
.text$mn:0000F2AC
.text$mn:0000F2AC ; Segment type: Pure code
.text$mn:0000F2AC ; Segment permissions: Read/Execute
.text$mn:0000F2AC _text$mn        segment para public 'CODE' use32
.text$mn:0000F2AC                 assume cs:_text$mn
.text$mn:0000F2AC                 ;org 0F2ACh
.text$mn:0000F2AC ; COMDAT (pick any)
.text$mn:0000F2AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F2AC
.text$mn:0000F2AC ; =============== S U B R O U T I N E =======================================
.text$mn:0000F2AC
.text$mn:0000F2AC ; Attributes: bp-based frame
.text$mn:0000F2AC
.text$mn:0000F2AC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __thiscall std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>::allocate(unsigned int)
.text$mn:0000F2AC                 public ?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:0000F2AC ?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$mn:0000F2AC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::allocate(uint)+Ep
.text$mn:0000F2AC
.text$mn:0000F2AC var_4           = dword ptr -4
.text$mn:0000F2AC arg_0           = dword ptr  8
.text$mn:0000F2AC
.text$mn:0000F2AC                 push    ebp
.text$mn:0000F2AD                 mov     ebp, esp
.text$mn:0000F2AF                 push    ecx
.text$mn:0000F2B0                 mov     [ebp+var_4], ecx
.text$mn:0000F2B3                 push    0
.text$mn:0000F2B5                 mov     eax, [ebp+arg_0]
.text$mn:0000F2B8                 push    eax
.text$mn:0000F2B9                 call    ??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000F2BE                 add     esp, 8
.text$mn:0000F2C1                 mov     esp, ebp
.text$mn:0000F2C3                 pop     ebp
.text$mn:0000F2C4                 retn    4
.text$mn:0000F2C4 ?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp
.text$mn:0000F2C4
.text$mn:0000F2C4 ; ---------------------------------------------------------------------------
.text$mn:0000F2C7                 align 4
.text$mn:0000F2C7 _text$mn        ends
.text$mn:0000F2C7
.text$mn:0000F2C8 ; ===========================================================================
.text$mn:0000F2C8
.text$mn:0000F2C8 ; Segment type: Pure code
.text$mn:0000F2C8 ; Segment permissions: Read/Execute
.text$mn:0000F2C8 _text$mn        segment para public 'CODE' use32
.text$mn:0000F2C8                 assume cs:_text$mn
.text$mn:0000F2C8                 ;org 0F2C8h
.text$mn:0000F2C8 ; COMDAT (pick any)
.text$mn:0000F2C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F2C8
.text$mn:0000F2C8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F2C8
.text$mn:0000F2C8 ; Attributes: bp-based frame
.text$mn:0000F2C8
.text$mn:0000F2C8 ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:0000F2C8                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:0000F2C8 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:0000F2C8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:0000F2C8
.text$mn:0000F2C8 var_4           = dword ptr -4
.text$mn:0000F2C8 arg_0           = dword ptr  8
.text$mn:0000F2C8
.text$mn:0000F2C8                 push    ebp
.text$mn:0000F2C9                 mov     ebp, esp
.text$mn:0000F2CB                 push    ecx
.text$mn:0000F2CC                 mov     [ebp+var_4], ecx
.text$mn:0000F2CF                 push    0
.text$mn:0000F2D1                 mov     eax, [ebp+arg_0]
.text$mn:0000F2D4                 push    eax
.text$mn:0000F2D5                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:0000F2DA                 add     esp, 8
.text$mn:0000F2DD                 mov     esp, ebp
.text$mn:0000F2DF                 pop     ebp
.text$mn:0000F2E0                 retn    4
.text$mn:0000F2E0 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:0000F2E0
.text$mn:0000F2E0 ; ---------------------------------------------------------------------------
.text$mn:0000F2E3                 align 4
.text$mn:0000F2E3 _text$mn        ends
.text$mn:0000F2E3
.text$mn:0000F2E4 ; ===========================================================================
.text$mn:0000F2E4
.text$mn:0000F2E4 ; Segment type: Pure code
.text$mn:0000F2E4 ; Segment permissions: Read/Execute
.text$mn:0000F2E4 _text$mn        segment para public 'CODE' use32
.text$mn:0000F2E4                 assume cs:_text$mn
.text$mn:0000F2E4                 ;org 0F2E4h
.text$mn:0000F2E4 ; COMDAT (pick any)
.text$mn:0000F2E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F2E4
.text$mn:0000F2E4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F2E4
.text$mn:0000F2E4 ; Attributes: bp-based frame
.text$mn:0000F2E4
.text$mn:0000F2E4 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::append(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:0000F2E4                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
.text$mn:0000F2E4 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z proc near
.text$mn:0000F2E4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+Ep
.text$mn:0000F2E4
.text$mn:0000F2E4 var_4           = dword ptr -4
.text$mn:0000F2E4 arg_0           = dword ptr  8
.text$mn:0000F2E4
.text$mn:0000F2E4                 push    ebp
.text$mn:0000F2E5                 mov     ebp, esp
.text$mn:0000F2E7                 push    ecx
.text$mn:0000F2E8                 mov     [ebp+var_4], ecx
.text$mn:0000F2EB                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000F2F0                 push    eax
.text$mn:0000F2F1                 push    0
.text$mn:0000F2F3                 mov     ecx, [ebp+arg_0]
.text$mn:0000F2F6                 push    ecx
.text$mn:0000F2F7                 mov     ecx, [ebp+var_4]
.text$mn:0000F2FA                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000F2FF                 mov     esp, ebp
.text$mn:0000F301                 pop     ebp
.text$mn:0000F302                 retn    4
.text$mn:0000F302 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z endp
.text$mn:0000F302
.text$mn:0000F302 ; ---------------------------------------------------------------------------
.text$mn:0000F305                 align 4
.text$mn:0000F305 _text$mn        ends
.text$mn:0000F305
.text$mn:0000F308 ; ===========================================================================
.text$mn:0000F308
.text$mn:0000F308 ; Segment type: Pure code
.text$mn:0000F308 ; Segment permissions: Read/Execute
.text$mn:0000F308 _text$mn        segment para public 'CODE' use32
.text$mn:0000F308                 assume cs:_text$mn
.text$mn:0000F308                 ;org 0F308h
.text$mn:0000F308 ; COMDAT (pick any)
.text$mn:0000F308                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F308
.text$mn:0000F308 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F308
.text$mn:0000F308 ; Attributes: bp-based frame
.text$mn:0000F308
.text$mn:0000F308 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::append(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:0000F308                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000F308 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000F308                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+16p
.text$mn:0000F308                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+53p
.text$mn:0000F308
.text$mn:0000F308 var_8           = dword ptr -8
.text$mn:0000F308 var_4           = dword ptr -4
.text$mn:0000F308 arg_0           = dword ptr  8
.text$mn:0000F308 arg_4           = dword ptr  0Ch
.text$mn:0000F308 arg_8           = dword ptr  10h
.text$mn:0000F308
.text$mn:0000F308                 push    ebp
.text$mn:0000F309                 mov     ebp, esp
.text$mn:0000F30B                 sub     esp, 8
.text$mn:0000F30E                 mov     [ebp+var_4], ecx
.text$mn:0000F311                 mov     ecx, [ebp+arg_0]
.text$mn:0000F314                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000F319                 cmp     eax, [ebp+arg_4]
.text$mn:0000F31C                 jnb     short loc_F326
.text$mn:0000F31E                 mov     ecx, [ebp+var_4]
.text$mn:0000F321                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000F326
.text$mn:0000F326 loc_F326:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:0000F326                 mov     ecx, [ebp+arg_0]
.text$mn:0000F329                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000F32E                 sub     eax, [ebp+arg_4]
.text$mn:0000F331                 mov     [ebp+var_8], eax
.text$mn:0000F334                 mov     eax, [ebp+var_8]
.text$mn:0000F337                 cmp     eax, [ebp+arg_8]
.text$mn:0000F33A                 jnb     short loc_F342
.text$mn:0000F33C                 mov     ecx, [ebp+var_8]
.text$mn:0000F33F                 mov     [ebp+arg_8], ecx
.text$mn:0000F342
.text$mn:0000F342 loc_F342:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:0000F342                 mov     edx, [ebp+var_4]
.text$mn:0000F345                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000F34A                 sub     eax, [edx+14h]
.text$mn:0000F34D                 cmp     eax, [ebp+arg_8]
.text$mn:0000F350                 ja      short loc_F35A
.text$mn:0000F352                 mov     ecx, [ebp+var_4]
.text$mn:0000F355                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000F35A
.text$mn:0000F35A loc_F35A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+48j
.text$mn:0000F35A                 cmp     [ebp+arg_8], 0
.text$mn:0000F35E                 jbe     short loc_F3BA
.text$mn:0000F360                 mov     ecx, [ebp+var_4]
.text$mn:0000F363                 mov     edx, [ecx+14h]
.text$mn:0000F366                 add     edx, [ebp+arg_8]
.text$mn:0000F369                 mov     [ebp+var_8], edx
.text$mn:0000F36C                 push    0
.text$mn:0000F36E                 mov     eax, [ebp+var_8]
.text$mn:0000F371                 push    eax
.text$mn:0000F372                 mov     ecx, [ebp+var_4]
.text$mn:0000F375                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000F37A                 movzx   ecx, al
.text$mn:0000F37D                 test    ecx, ecx
.text$mn:0000F37F                 jz      short loc_F3BA
.text$mn:0000F381                 mov     edx, [ebp+arg_8]
.text$mn:0000F384                 push    edx             ; int
.text$mn:0000F385                 mov     ecx, [ebp+arg_0]
.text$mn:0000F388                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000F38D                 mov     ecx, [ebp+arg_4]
.text$mn:0000F390                 lea     edx, [eax+ecx*2]
.text$mn:0000F393                 push    edx             ; Src
.text$mn:0000F394                 mov     ecx, [ebp+var_4]
.text$mn:0000F397                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000F39C                 mov     ecx, [ebp+var_4]
.text$mn:0000F39F                 mov     edx, [ecx+14h]
.text$mn:0000F3A2                 lea     eax, [eax+edx*2]
.text$mn:0000F3A5                 push    eax             ; Dst
.text$mn:0000F3A6                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000F3AB                 add     esp, 0Ch
.text$mn:0000F3AE                 mov     ecx, [ebp+var_8]
.text$mn:0000F3B1                 push    ecx
.text$mn:0000F3B2                 mov     ecx, [ebp+var_4]
.text$mn:0000F3B5                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000F3BA
.text$mn:0000F3BA loc_F3BA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+56j
.text$mn:0000F3BA                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+77j
.text$mn:0000F3BA                 mov     eax, [ebp+var_4]
.text$mn:0000F3BD                 mov     esp, ebp
.text$mn:0000F3BF                 pop     ebp
.text$mn:0000F3C0                 retn    0Ch
.text$mn:0000F3C0 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000F3C0
.text$mn:0000F3C0 ; ---------------------------------------------------------------------------
.text$mn:0000F3C3                 align 4
.text$mn:0000F3C3 _text$mn        ends
.text$mn:0000F3C3
.text$mn:0000F3C4 ; ===========================================================================
.text$mn:0000F3C4
.text$mn:0000F3C4 ; Segment type: Pure code
.text$mn:0000F3C4 ; Segment permissions: Read/Execute
.text$mn:0000F3C4 _text$mn        segment para public 'CODE' use32
.text$mn:0000F3C4                 assume cs:_text$mn
.text$mn:0000F3C4                 ;org 0F3C4h
.text$mn:0000F3C4 ; COMDAT (pick any)
.text$mn:0000F3C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F3C4
.text$mn:0000F3C4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F3C4
.text$mn:0000F3C4 ; Attributes: bp-based frame
.text$mn:0000F3C4
.text$mn:0000F3C4 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t *Str)
.text$mn:0000F3C4                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:0000F3C4 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:0000F3C4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)+Ep
.text$mn:0000F3C4
.text$mn:0000F3C4 var_4           = dword ptr -4
.text$mn:0000F3C4 Str             = dword ptr  8
.text$mn:0000F3C4
.text$mn:0000F3C4                 push    ebp
.text$mn:0000F3C5                 mov     ebp, esp
.text$mn:0000F3C7                 push    ecx
.text$mn:0000F3C8                 mov     [ebp+var_4], ecx
.text$mn:0000F3CB                 push    43Eh            ; unsigned int
.text$mn:0000F3D0                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000F3D5                 mov     eax, [ebp+Str]
.text$mn:0000F3D8                 push    eax             ; int
.text$mn:0000F3D9                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000F3DE                 add     esp, 0Ch
.text$mn:0000F3E1                 mov     ecx, [ebp+Str]
.text$mn:0000F3E4                 push    ecx             ; Str
.text$mn:0000F3E5                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000F3EA                 add     esp, 4
.text$mn:0000F3ED                 push    eax             ; int
.text$mn:0000F3EE                 mov     edx, [ebp+Str]
.text$mn:0000F3F1                 push    edx             ; Src
.text$mn:0000F3F2                 mov     ecx, [ebp+var_4]
.text$mn:0000F3F5                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)
.text$mn:0000F3FA                 mov     esp, ebp
.text$mn:0000F3FC                 pop     ebp
.text$mn:0000F3FD                 retn    4
.text$mn:0000F3FD ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:0000F3FD
.text$mn:0000F3FD _text$mn        ends
.text$mn:0000F3FD
.text$mn:0000F400 ; ===========================================================================
.text$mn:0000F400
.text$mn:0000F400 ; Segment type: Pure code
.text$mn:0000F400 ; Segment permissions: Read/Execute
.text$mn:0000F400 _text$mn        segment para public 'CODE' use32
.text$mn:0000F400                 assume cs:_text$mn
.text$mn:0000F400                 ;org 0F400h
.text$mn:0000F400 ; COMDAT (pick any)
.text$mn:0000F400                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F400
.text$mn:0000F400 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F400
.text$mn:0000F400 ; Attributes: bp-based frame
.text$mn:0000F400
.text$mn:0000F400 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(void *Src, int)
.text$mn:0000F400                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:0000F400 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:0000F400                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+31p
.text$mn:0000F400
.text$mn:0000F400 var_8           = dword ptr -8
.text$mn:0000F400 var_4           = dword ptr -4
.text$mn:0000F400 Src             = dword ptr  8
.text$mn:0000F400 arg_4           = dword ptr  0Ch
.text$mn:0000F400
.text$mn:0000F400                 push    ebp
.text$mn:0000F401                 mov     ebp, esp
.text$mn:0000F403                 sub     esp, 8
.text$mn:0000F406                 mov     [ebp+var_4], ecx
.text$mn:0000F409                 cmp     [ebp+arg_4], 0
.text$mn:0000F40D                 jz      short loc_F425
.text$mn:0000F40F                 push    42Ah            ; unsigned int
.text$mn:0000F414                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000F419                 mov     eax, [ebp+Src]
.text$mn:0000F41C                 push    eax             ; int
.text$mn:0000F41D                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000F422                 add     esp, 0Ch
.text$mn:0000F425
.text$mn:0000F425 loc_F425:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+Dj
.text$mn:0000F425                 mov     ecx, [ebp+Src]
.text$mn:0000F428                 push    ecx
.text$mn:0000F429                 mov     ecx, [ebp+var_4]
.text$mn:0000F42C                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:0000F431                 movzx   edx, al
.text$mn:0000F434                 test    edx, edx
.text$mn:0000F436                 jz      short loc_F45A
.text$mn:0000F438                 mov     eax, [ebp+arg_4]
.text$mn:0000F43B                 push    eax
.text$mn:0000F43C                 mov     ecx, [ebp+var_4]
.text$mn:0000F43F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000F444                 mov     ecx, [ebp+Src]
.text$mn:0000F447                 sub     ecx, eax
.text$mn:0000F449                 sar     ecx, 1
.text$mn:0000F44B                 push    ecx
.text$mn:0000F44C                 mov     edx, [ebp+var_4]
.text$mn:0000F44F                 push    edx
.text$mn:0000F450                 mov     ecx, [ebp+var_4]
.text$mn:0000F453                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000F458                 jmp     short loc_F4CB
.text$mn:0000F45A ; ---------------------------------------------------------------------------
.text$mn:0000F45A
.text$mn:0000F45A loc_F45A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+36j
.text$mn:0000F45A                 mov     eax, [ebp+var_4]
.text$mn:0000F45D                 mov     ecx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000F463                 sub     ecx, [eax+14h]
.text$mn:0000F466                 cmp     ecx, [ebp+arg_4]
.text$mn:0000F469                 ja      short loc_F473
.text$mn:0000F46B                 mov     ecx, [ebp+var_4]
.text$mn:0000F46E                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000F473
.text$mn:0000F473 loc_F473:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+69j
.text$mn:0000F473                 cmp     [ebp+arg_4], 0
.text$mn:0000F477                 jbe     short loc_F4C8
.text$mn:0000F479                 mov     edx, [ebp+var_4]
.text$mn:0000F47C                 mov     eax, [edx+14h]
.text$mn:0000F47F                 add     eax, [ebp+arg_4]
.text$mn:0000F482                 mov     [ebp+var_8], eax
.text$mn:0000F485                 push    0
.text$mn:0000F487                 mov     ecx, [ebp+var_8]
.text$mn:0000F48A                 push    ecx
.text$mn:0000F48B                 mov     ecx, [ebp+var_4]
.text$mn:0000F48E                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000F493                 movzx   edx, al
.text$mn:0000F496                 test    edx, edx
.text$mn:0000F498                 jz      short loc_F4C8
.text$mn:0000F49A                 mov     eax, [ebp+arg_4]
.text$mn:0000F49D                 push    eax             ; int
.text$mn:0000F49E                 mov     ecx, [ebp+Src]
.text$mn:0000F4A1                 push    ecx             ; Src
.text$mn:0000F4A2                 mov     ecx, [ebp+var_4]
.text$mn:0000F4A5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000F4AA                 mov     edx, [ebp+var_4]
.text$mn:0000F4AD                 mov     ecx, [edx+14h]
.text$mn:0000F4B0                 lea     edx, [eax+ecx*2]
.text$mn:0000F4B3                 push    edx             ; Dst
.text$mn:0000F4B4                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000F4B9                 add     esp, 0Ch
.text$mn:0000F4BC                 mov     eax, [ebp+var_8]
.text$mn:0000F4BF                 push    eax
.text$mn:0000F4C0                 mov     ecx, [ebp+var_4]
.text$mn:0000F4C3                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000F4C8
.text$mn:0000F4C8 loc_F4C8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+77j
.text$mn:0000F4C8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+98j
.text$mn:0000F4C8                 mov     eax, [ebp+var_4]
.text$mn:0000F4CB
.text$mn:0000F4CB loc_F4CB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+58j
.text$mn:0000F4CB                 mov     esp, ebp
.text$mn:0000F4CD                 pop     ebp
.text$mn:0000F4CE                 retn    8
.text$mn:0000F4CE ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:0000F4CE
.text$mn:0000F4CE ; ---------------------------------------------------------------------------
.text$mn:0000F4D1                 align 4
.text$mn:0000F4D1 _text$mn        ends
.text$mn:0000F4D1
.text$mn:0000F4D4 ; ===========================================================================
.text$mn:0000F4D4
.text$mn:0000F4D4 ; Segment type: Pure code
.text$mn:0000F4D4 ; Segment permissions: Read/Execute
.text$mn:0000F4D4 _text$mn        segment para public 'CODE' use32
.text$mn:0000F4D4                 assume cs:_text$mn
.text$mn:0000F4D4                 ;org 0F4D4h
.text$mn:0000F4D4 ; COMDAT (pick any)
.text$mn:0000F4D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F4D4
.text$mn:0000F4D4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F4D4
.text$mn:0000F4D4 ; Attributes: bp-based frame
.text$mn:0000F4D4
.text$mn:0000F4D4 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:0000F4D4                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000F4D4 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000F4D4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:0000F4D4
.text$mn:0000F4D4 Size            = dword ptr -8
.text$mn:0000F4D4 var_4           = dword ptr -4
.text$mn:0000F4D4 arg_0           = dword ptr  8
.text$mn:0000F4D4 arg_4           = dword ptr  0Ch
.text$mn:0000F4D4 arg_8           = dword ptr  10h
.text$mn:0000F4D4
.text$mn:0000F4D4                 push    ebp
.text$mn:0000F4D5                 mov     ebp, esp
.text$mn:0000F4D7                 sub     esp, 8
.text$mn:0000F4DA                 mov     [ebp+var_4], ecx
.text$mn:0000F4DD                 mov     ecx, [ebp+arg_0]
.text$mn:0000F4E0                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000F4E5                 cmp     eax, [ebp+arg_4]
.text$mn:0000F4E8                 jnb     short loc_F4F2
.text$mn:0000F4EA                 mov     ecx, [ebp+var_4]
.text$mn:0000F4ED                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000F4F2
.text$mn:0000F4F2 loc_F4F2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:0000F4F2                 mov     ecx, [ebp+arg_0]
.text$mn:0000F4F5                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000F4FA                 sub     eax, [ebp+arg_4]
.text$mn:0000F4FD                 mov     [ebp+Size], eax
.text$mn:0000F500                 mov     eax, [ebp+arg_8]
.text$mn:0000F503                 cmp     eax, [ebp+Size]
.text$mn:0000F506                 jnb     short loc_F50E
.text$mn:0000F508                 mov     ecx, [ebp+arg_8]
.text$mn:0000F50B                 mov     [ebp+Size], ecx
.text$mn:0000F50E
.text$mn:0000F50E loc_F50E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000F50E                 mov     edx, [ebp+var_4]
.text$mn:0000F511                 cmp     edx, [ebp+arg_0]
.text$mn:0000F514                 jnz     short loc_F535
.text$mn:0000F516                 mov     eax, [ebp+arg_4]
.text$mn:0000F519                 add     eax, [ebp+Size]
.text$mn:0000F51C                 push    eax
.text$mn:0000F51D                 mov     ecx, [ebp+var_4]
.text$mn:0000F520                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:0000F525                 mov     ecx, [ebp+arg_4]
.text$mn:0000F528                 push    ecx
.text$mn:0000F529                 push    0
.text$mn:0000F52B                 mov     ecx, [ebp+var_4]
.text$mn:0000F52E                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:0000F533                 jmp     short loc_F577
.text$mn:0000F535 ; ---------------------------------------------------------------------------
.text$mn:0000F535
.text$mn:0000F535 loc_F535:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:0000F535                 push    0
.text$mn:0000F537                 mov     edx, [ebp+Size]
.text$mn:0000F53A                 push    edx
.text$mn:0000F53B                 mov     ecx, [ebp+var_4]
.text$mn:0000F53E                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000F543                 movzx   eax, al
.text$mn:0000F546                 test    eax, eax
.text$mn:0000F548                 jz      short loc_F577
.text$mn:0000F54A                 mov     ecx, [ebp+Size]
.text$mn:0000F54D                 push    ecx             ; Size
.text$mn:0000F54E                 mov     ecx, [ebp+arg_0]
.text$mn:0000F551                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000F556                 add     eax, [ebp+arg_4]
.text$mn:0000F559                 push    eax             ; Src
.text$mn:0000F55A                 mov     ecx, [ebp+var_4]
.text$mn:0000F55D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000F562                 push    eax             ; Dst
.text$mn:0000F563                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000F568                 add     esp, 0Ch
.text$mn:0000F56B                 mov     edx, [ebp+Size]
.text$mn:0000F56E                 push    edx
.text$mn:0000F56F                 mov     ecx, [ebp+var_4]
.text$mn:0000F572                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000F577
.text$mn:0000F577 loc_F577:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:0000F577                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:0000F577                 mov     eax, [ebp+var_4]
.text$mn:0000F57A                 mov     esp, ebp
.text$mn:0000F57C                 pop     ebp
.text$mn:0000F57D                 retn    0Ch
.text$mn:0000F57D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000F57D
.text$mn:0000F57D _text$mn        ends
.text$mn:0000F57D
.text$mn:0000F580 ; ===========================================================================
.text$mn:0000F580
.text$mn:0000F580 ; Segment type: Pure code
.text$mn:0000F580 ; Segment permissions: Read/Execute
.text$mn:0000F580 _text$mn        segment para public 'CODE' use32
.text$mn:0000F580                 assume cs:_text$mn
.text$mn:0000F580                 ;org 0F580h
.text$mn:0000F580 ; COMDAT (pick any)
.text$mn:0000F580                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F580
.text$mn:0000F580 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F580
.text$mn:0000F580 ; Attributes: bp-based frame
.text$mn:0000F580
.text$mn:0000F580 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:0000F580                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:0000F580 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:0000F580                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:0000F580
.text$mn:0000F580 var_4           = dword ptr -4
.text$mn:0000F580 Str             = dword ptr  8
.text$mn:0000F580
.text$mn:0000F580                 push    ebp
.text$mn:0000F581                 mov     ebp, esp
.text$mn:0000F583                 push    ecx
.text$mn:0000F584                 mov     [ebp+var_4], ecx
.text$mn:0000F587                 push    490h            ; unsigned int
.text$mn:0000F58C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000F591                 mov     eax, [ebp+Str]
.text$mn:0000F594                 push    eax             ; int
.text$mn:0000F595                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000F59A                 add     esp, 0Ch
.text$mn:0000F59D                 mov     ecx, [ebp+Str]
.text$mn:0000F5A0                 push    ecx             ; Str
.text$mn:0000F5A1                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:0000F5A6                 add     esp, 4
.text$mn:0000F5A9                 push    eax             ; Size
.text$mn:0000F5AA                 mov     edx, [ebp+Str]
.text$mn:0000F5AD                 push    edx             ; Src
.text$mn:0000F5AE                 mov     ecx, [ebp+var_4]
.text$mn:0000F5B1                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:0000F5B6                 mov     esp, ebp
.text$mn:0000F5B8                 pop     ebp
.text$mn:0000F5B9                 retn    4
.text$mn:0000F5B9 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:0000F5B9
.text$mn:0000F5B9 _text$mn        ends
.text$mn:0000F5B9
.text$mn:0000F5BC ; ===========================================================================
.text$mn:0000F5BC
.text$mn:0000F5BC ; Segment type: Pure code
.text$mn:0000F5BC ; Segment permissions: Read/Execute
.text$mn:0000F5BC _text$mn        segment para public 'CODE' use32
.text$mn:0000F5BC                 assume cs:_text$mn
.text$mn:0000F5BC                 ;org 0F5BCh
.text$mn:0000F5BC ; COMDAT (pick any)
.text$mn:0000F5BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F5BC
.text$mn:0000F5BC ; =============== S U B R O U T I N E =======================================
.text$mn:0000F5BC
.text$mn:0000F5BC ; Attributes: bp-based frame
.text$mn:0000F5BC
.text$mn:0000F5BC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:0000F5BC                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:0000F5BC ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:0000F5BC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:0000F5BC
.text$mn:0000F5BC var_4           = dword ptr -4
.text$mn:0000F5BC Src             = dword ptr  8
.text$mn:0000F5BC Size            = dword ptr  0Ch
.text$mn:0000F5BC
.text$mn:0000F5BC                 push    ebp
.text$mn:0000F5BD                 mov     ebp, esp
.text$mn:0000F5BF                 push    ecx
.text$mn:0000F5C0                 mov     [ebp+var_4], ecx
.text$mn:0000F5C3                 cmp     [ebp+Size], 0
.text$mn:0000F5C7                 jz      short loc_F5DF
.text$mn:0000F5C9                 push    47Fh            ; unsigned int
.text$mn:0000F5CE                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000F5D3                 mov     eax, [ebp+Src]
.text$mn:0000F5D6                 push    eax             ; int
.text$mn:0000F5D7                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000F5DC                 add     esp, 0Ch
.text$mn:0000F5DF
.text$mn:0000F5DF loc_F5DF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000F5DF                 mov     ecx, [ebp+Src]
.text$mn:0000F5E2                 push    ecx
.text$mn:0000F5E3                 mov     ecx, [ebp+var_4]
.text$mn:0000F5E6                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000F5EB                 movzx   edx, al
.text$mn:0000F5EE                 test    edx, edx
.text$mn:0000F5F0                 jz      short loc_F612
.text$mn:0000F5F2                 mov     eax, [ebp+Size]
.text$mn:0000F5F5                 push    eax
.text$mn:0000F5F6                 mov     ecx, [ebp+var_4]
.text$mn:0000F5F9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000F5FE                 mov     ecx, [ebp+Src]
.text$mn:0000F601                 sub     ecx, eax
.text$mn:0000F603                 push    ecx
.text$mn:0000F604                 mov     edx, [ebp+var_4]
.text$mn:0000F607                 push    edx
.text$mn:0000F608                 mov     ecx, [ebp+var_4]
.text$mn:0000F60B                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:0000F610                 jmp     short loc_F64F
.text$mn:0000F612 ; ---------------------------------------------------------------------------
.text$mn:0000F612
.text$mn:0000F612 loc_F612:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:0000F612                 push    0
.text$mn:0000F614                 mov     eax, [ebp+Size]
.text$mn:0000F617                 push    eax
.text$mn:0000F618                 mov     ecx, [ebp+var_4]
.text$mn:0000F61B                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000F620                 movzx   ecx, al
.text$mn:0000F623                 test    ecx, ecx
.text$mn:0000F625                 jz      short loc_F64C
.text$mn:0000F627                 mov     edx, [ebp+Size]
.text$mn:0000F62A                 push    edx             ; Size
.text$mn:0000F62B                 mov     eax, [ebp+Src]
.text$mn:0000F62E                 push    eax             ; Src
.text$mn:0000F62F                 mov     ecx, [ebp+var_4]
.text$mn:0000F632                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000F637                 push    eax             ; Dst
.text$mn:0000F638                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000F63D                 add     esp, 0Ch
.text$mn:0000F640                 mov     ecx, [ebp+Size]
.text$mn:0000F643                 push    ecx
.text$mn:0000F644                 mov     ecx, [ebp+var_4]
.text$mn:0000F647                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000F64C
.text$mn:0000F64C loc_F64C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:0000F64C                 mov     eax, [ebp+var_4]
.text$mn:0000F64F
.text$mn:0000F64F loc_F64F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:0000F64F                 mov     esp, ebp
.text$mn:0000F651                 pop     ebp
.text$mn:0000F652                 retn    8
.text$mn:0000F652 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:0000F652
.text$mn:0000F652 ; ---------------------------------------------------------------------------
.text$mn:0000F655                 align 4
.text$mn:0000F655 _text$mn        ends
.text$mn:0000F655
.text$mn:0000F658 ; ===========================================================================
.text$mn:0000F658
.text$mn:0000F658 ; Segment type: Pure code
.text$mn:0000F658 ; Segment permissions: Read/Execute
.text$mn:0000F658 _text$mn        segment para public 'CODE' use32
.text$mn:0000F658                 assume cs:_text$mn
.text$mn:0000F658                 ;org 0F658h
.text$mn:0000F658 ; COMDAT (pick any)
.text$mn:0000F658                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F658
.text$mn:0000F658 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F658
.text$mn:0000F658 ; Attributes: bp-based frame
.text$mn:0000F658
.text$mn:0000F658 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:0000F658                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
.text$mn:0000F658 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z proc near
.text$mn:0000F658                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+66p
.text$mn:0000F658
.text$mn:0000F658 var_4           = dword ptr -4
.text$mn:0000F658 arg_0           = dword ptr  8
.text$mn:0000F658
.text$mn:0000F658                 push    ebp
.text$mn:0000F659                 mov     ebp, esp
.text$mn:0000F65B                 push    ecx
.text$mn:0000F65C                 mov     [ebp+var_4], ecx
.text$mn:0000F65F                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000F664                 push    eax
.text$mn:0000F665                 push    0
.text$mn:0000F667                 mov     ecx, [ebp+arg_0]
.text$mn:0000F66A                 push    ecx
.text$mn:0000F66B                 mov     ecx, [ebp+var_4]
.text$mn:0000F66E                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000F673                 mov     esp, ebp
.text$mn:0000F675                 pop     ebp
.text$mn:0000F676                 retn    4
.text$mn:0000F676 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z endp
.text$mn:0000F676
.text$mn:0000F676 ; ---------------------------------------------------------------------------
.text$mn:0000F679                 align 4
.text$mn:0000F679 _text$mn        ends
.text$mn:0000F679
.text$mn:0000F67C ; ===========================================================================
.text$mn:0000F67C
.text$mn:0000F67C ; Segment type: Pure code
.text$mn:0000F67C ; Segment permissions: Read/Execute
.text$mn:0000F67C _text$mn        segment para public 'CODE' use32
.text$mn:0000F67C                 assume cs:_text$mn
.text$mn:0000F67C                 ;org 0F67Ch
.text$mn:0000F67C ; COMDAT (pick any)
.text$mn:0000F67C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F67C
.text$mn:0000F67C ; =============== S U B R O U T I N E =======================================
.text$mn:0000F67C
.text$mn:0000F67C ; Attributes: bp-based frame
.text$mn:0000F67C
.text$mn:0000F67C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:0000F67C                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000F67C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000F67C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Bp
.text$mn:0000F67C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint,std::allocator<wchar_t> const &)+54p ...
.text$mn:0000F67C
.text$mn:0000F67C var_8           = dword ptr -8
.text$mn:0000F67C var_4           = dword ptr -4
.text$mn:0000F67C arg_0           = dword ptr  8
.text$mn:0000F67C arg_4           = dword ptr  0Ch
.text$mn:0000F67C arg_8           = dword ptr  10h
.text$mn:0000F67C
.text$mn:0000F67C                 push    ebp
.text$mn:0000F67D                 mov     ebp, esp
.text$mn:0000F67F                 sub     esp, 8
.text$mn:0000F682                 mov     [ebp+var_4], ecx
.text$mn:0000F685                 mov     ecx, [ebp+arg_0]
.text$mn:0000F688                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000F68D                 cmp     eax, [ebp+arg_4]
.text$mn:0000F690                 jnb     short loc_F69A
.text$mn:0000F692                 mov     ecx, [ebp+var_4]
.text$mn:0000F695                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000F69A
.text$mn:0000F69A loc_F69A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:0000F69A                 mov     ecx, [ebp+arg_0]
.text$mn:0000F69D                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000F6A2                 sub     eax, [ebp+arg_4]
.text$mn:0000F6A5                 mov     [ebp+var_8], eax
.text$mn:0000F6A8                 mov     eax, [ebp+arg_8]
.text$mn:0000F6AB                 cmp     eax, [ebp+var_8]
.text$mn:0000F6AE                 jnb     short loc_F6B6
.text$mn:0000F6B0                 mov     ecx, [ebp+arg_8]
.text$mn:0000F6B3                 mov     [ebp+var_8], ecx
.text$mn:0000F6B6
.text$mn:0000F6B6 loc_F6B6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:0000F6B6                 mov     edx, [ebp+var_4]
.text$mn:0000F6B9                 cmp     edx, [ebp+arg_0]
.text$mn:0000F6BC                 jnz     short loc_F6DD
.text$mn:0000F6BE                 mov     eax, [ebp+arg_4]
.text$mn:0000F6C1                 add     eax, [ebp+var_8]
.text$mn:0000F6C4                 push    eax
.text$mn:0000F6C5                 mov     ecx, [ebp+var_4]
.text$mn:0000F6C8                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:0000F6CD                 mov     ecx, [ebp+arg_4]
.text$mn:0000F6D0                 push    ecx
.text$mn:0000F6D1                 push    0
.text$mn:0000F6D3                 mov     ecx, [ebp+var_4]
.text$mn:0000F6D6                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:0000F6DB                 jmp     short loc_F722
.text$mn:0000F6DD ; ---------------------------------------------------------------------------
.text$mn:0000F6DD
.text$mn:0000F6DD loc_F6DD:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:0000F6DD                 push    0
.text$mn:0000F6DF                 mov     edx, [ebp+var_8]
.text$mn:0000F6E2                 push    edx
.text$mn:0000F6E3                 mov     ecx, [ebp+var_4]
.text$mn:0000F6E6                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000F6EB                 movzx   eax, al
.text$mn:0000F6EE                 test    eax, eax
.text$mn:0000F6F0                 jz      short loc_F722
.text$mn:0000F6F2                 mov     ecx, [ebp+var_8]
.text$mn:0000F6F5                 push    ecx             ; int
.text$mn:0000F6F6                 mov     ecx, [ebp+arg_0]
.text$mn:0000F6F9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000F6FE                 mov     edx, [ebp+arg_4]
.text$mn:0000F701                 lea     eax, [eax+edx*2]
.text$mn:0000F704                 push    eax             ; Src
.text$mn:0000F705                 mov     ecx, [ebp+var_4]
.text$mn:0000F708                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000F70D                 push    eax             ; Dst
.text$mn:0000F70E                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000F713                 add     esp, 0Ch
.text$mn:0000F716                 mov     ecx, [ebp+var_8]
.text$mn:0000F719                 push    ecx
.text$mn:0000F71A                 mov     ecx, [ebp+var_4]
.text$mn:0000F71D                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000F722
.text$mn:0000F722 loc_F722:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:0000F722                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:0000F722                 mov     eax, [ebp+var_4]
.text$mn:0000F725                 mov     esp, ebp
.text$mn:0000F727                 pop     ebp
.text$mn:0000F728                 retn    0Ch
.text$mn:0000F728 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000F728
.text$mn:0000F728 ; ---------------------------------------------------------------------------
.text$mn:0000F72B                 align 4
.text$mn:0000F72B _text$mn        ends
.text$mn:0000F72B
.text$mn:0000F72C ; ===========================================================================
.text$mn:0000F72C
.text$mn:0000F72C ; Segment type: Pure code
.text$mn:0000F72C ; Segment permissions: Read/Execute
.text$mn:0000F72C _text$mn        segment para public 'CODE' use32
.text$mn:0000F72C                 assume cs:_text$mn
.text$mn:0000F72C                 ;org 0F72Ch
.text$mn:0000F72C ; COMDAT (pick any)
.text$mn:0000F72C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F72C
.text$mn:0000F72C ; =============== S U B R O U T I N E =======================================
.text$mn:0000F72C
.text$mn:0000F72C ; Attributes: bp-based frame
.text$mn:0000F72C
.text$mn:0000F72C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:0000F72C                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:0000F72C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:0000F72C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+53p
.text$mn:0000F72C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)+Ep
.text$mn:0000F72C
.text$mn:0000F72C var_4           = dword ptr -4
.text$mn:0000F72C Str             = dword ptr  8
.text$mn:0000F72C
.text$mn:0000F72C                 push    ebp
.text$mn:0000F72D                 mov     ebp, esp
.text$mn:0000F72F                 push    ecx
.text$mn:0000F730                 mov     [ebp+var_4], ecx
.text$mn:0000F733                 push    490h            ; unsigned int
.text$mn:0000F738                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000F73D                 mov     eax, [ebp+Str]
.text$mn:0000F740                 push    eax             ; int
.text$mn:0000F741                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000F746                 add     esp, 0Ch
.text$mn:0000F749                 mov     ecx, [ebp+Str]
.text$mn:0000F74C                 push    ecx             ; Str
.text$mn:0000F74D                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000F752                 add     esp, 4
.text$mn:0000F755                 push    eax             ; int
.text$mn:0000F756                 mov     edx, [ebp+Str]
.text$mn:0000F759                 push    edx             ; Src
.text$mn:0000F75A                 mov     ecx, [ebp+var_4]
.text$mn:0000F75D                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:0000F762                 mov     esp, ebp
.text$mn:0000F764                 pop     ebp
.text$mn:0000F765                 retn    4
.text$mn:0000F765 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:0000F765
.text$mn:0000F765 _text$mn        ends
.text$mn:0000F765
.text$mn:0000F768 ; ===========================================================================
.text$mn:0000F768
.text$mn:0000F768 ; Segment type: Pure code
.text$mn:0000F768 ; Segment permissions: Read/Execute
.text$mn:0000F768 _text$mn        segment para public 'CODE' use32
.text$mn:0000F768                 assume cs:_text$mn
.text$mn:0000F768                 ;org 0F768h
.text$mn:0000F768 ; COMDAT (pick any)
.text$mn:0000F768                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F768
.text$mn:0000F768 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F768
.text$mn:0000F768 ; Attributes: bp-based frame
.text$mn:0000F768
.text$mn:0000F768 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:0000F768                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:0000F768 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:0000F768                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *,uint)+57p
.text$mn:0000F768                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:0000F768
.text$mn:0000F768 var_4           = dword ptr -4
.text$mn:0000F768 Src             = dword ptr  8
.text$mn:0000F768 arg_4           = dword ptr  0Ch
.text$mn:0000F768
.text$mn:0000F768                 push    ebp
.text$mn:0000F769                 mov     ebp, esp
.text$mn:0000F76B                 push    ecx
.text$mn:0000F76C                 mov     [ebp+var_4], ecx
.text$mn:0000F76F                 cmp     [ebp+arg_4], 0
.text$mn:0000F773                 jz      short loc_F78B
.text$mn:0000F775                 push    47Fh            ; unsigned int
.text$mn:0000F77A                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000F77F                 mov     eax, [ebp+Src]
.text$mn:0000F782                 push    eax             ; int
.text$mn:0000F783                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000F788                 add     esp, 0Ch
.text$mn:0000F78B
.text$mn:0000F78B loc_F78B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:0000F78B                 mov     ecx, [ebp+Src]
.text$mn:0000F78E                 push    ecx
.text$mn:0000F78F                 mov     ecx, [ebp+var_4]
.text$mn:0000F792                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:0000F797                 movzx   edx, al
.text$mn:0000F79A                 test    edx, edx
.text$mn:0000F79C                 jz      short loc_F7C0
.text$mn:0000F79E                 mov     eax, [ebp+arg_4]
.text$mn:0000F7A1                 push    eax
.text$mn:0000F7A2                 mov     ecx, [ebp+var_4]
.text$mn:0000F7A5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000F7AA                 mov     ecx, [ebp+Src]
.text$mn:0000F7AD                 sub     ecx, eax
.text$mn:0000F7AF                 sar     ecx, 1
.text$mn:0000F7B1                 push    ecx
.text$mn:0000F7B2                 mov     edx, [ebp+var_4]
.text$mn:0000F7B5                 push    edx
.text$mn:0000F7B6                 mov     ecx, [ebp+var_4]
.text$mn:0000F7B9                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000F7BE                 jmp     short loc_F7FD
.text$mn:0000F7C0 ; ---------------------------------------------------------------------------
.text$mn:0000F7C0
.text$mn:0000F7C0 loc_F7C0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:0000F7C0                 push    0
.text$mn:0000F7C2                 mov     eax, [ebp+arg_4]
.text$mn:0000F7C5                 push    eax
.text$mn:0000F7C6                 mov     ecx, [ebp+var_4]
.text$mn:0000F7C9                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000F7CE                 movzx   ecx, al
.text$mn:0000F7D1                 test    ecx, ecx
.text$mn:0000F7D3                 jz      short loc_F7FA
.text$mn:0000F7D5                 mov     edx, [ebp+arg_4]
.text$mn:0000F7D8                 push    edx             ; int
.text$mn:0000F7D9                 mov     eax, [ebp+Src]
.text$mn:0000F7DC                 push    eax             ; Src
.text$mn:0000F7DD                 mov     ecx, [ebp+var_4]
.text$mn:0000F7E0                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000F7E5                 push    eax             ; Dst
.text$mn:0000F7E6                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000F7EB                 add     esp, 0Ch
.text$mn:0000F7EE                 mov     ecx, [ebp+arg_4]
.text$mn:0000F7F1                 push    ecx
.text$mn:0000F7F2                 mov     ecx, [ebp+var_4]
.text$mn:0000F7F5                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000F7FA
.text$mn:0000F7FA loc_F7FA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:0000F7FA                 mov     eax, [ebp+var_4]
.text$mn:0000F7FD
.text$mn:0000F7FD loc_F7FD:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:0000F7FD                 mov     esp, ebp
.text$mn:0000F7FF                 pop     ebp
.text$mn:0000F800                 retn    8
.text$mn:0000F800 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:0000F800
.text$mn:0000F800 ; ---------------------------------------------------------------------------
.text$mn:0000F803                 align 4
.text$mn:0000F803 _text$mn        ends
.text$mn:0000F803
.text$mn:0000F804 ; ===========================================================================
.text$mn:0000F804
.text$mn:0000F804 ; Segment type: Pure code
.text$mn:0000F804 ; Segment permissions: Read/Execute
.text$mn:0000F804 _text$mn        segment para public 'CODE' use32
.text$mn:0000F804                 assume cs:_text$mn
.text$mn:0000F804                 ;org 0F804h
.text$mn:0000F804 ; COMDAT (pick any)
.text$mn:0000F804                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F804
.text$mn:0000F804 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F804
.text$mn:0000F804 ; Attributes: bp-based frame
.text$mn:0000F804
.text$mn:0000F804 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:0000F804                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:0000F804 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:0000F804                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:0000F804
.text$mn:0000F804 arg_0           = dword ptr  8
.text$mn:0000F804 arg_4           = dword ptr  0Ch
.text$mn:0000F804
.text$mn:0000F804                 push    ebp
.text$mn:0000F805                 mov     ebp, esp
.text$mn:0000F807                 mov     eax, [ebp+arg_0]
.text$mn:0000F80A                 mov     ecx, [ebp+arg_4]
.text$mn:0000F80D                 mov     dl, [ecx]
.text$mn:0000F80F                 mov     [eax], dl
.text$mn:0000F811                 pop     ebp
.text$mn:0000F812                 retn
.text$mn:0000F812 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:0000F812
.text$mn:0000F812 ; ---------------------------------------------------------------------------
.text$mn:0000F813                 align 4
.text$mn:0000F813 _text$mn        ends
.text$mn:0000F813
.text$mn:0000F814 ; ===========================================================================
.text$mn:0000F814
.text$mn:0000F814 ; Segment type: Pure code
.text$mn:0000F814 ; Segment permissions: Read/Execute
.text$mn:0000F814 _text$mn        segment para public 'CODE' use32
.text$mn:0000F814                 assume cs:_text$mn
.text$mn:0000F814                 ;org 0F814h
.text$mn:0000F814 ; COMDAT (pick any)
.text$mn:0000F814                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F814
.text$mn:0000F814 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F814
.text$mn:0000F814 ; Attributes: bp-based frame
.text$mn:0000F814
.text$mn:0000F814 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:0000F814                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:0000F814 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:0000F814                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:0000F814
.text$mn:0000F814 arg_0           = dword ptr  8
.text$mn:0000F814 arg_4           = dword ptr  0Ch
.text$mn:0000F814
.text$mn:0000F814                 push    ebp
.text$mn:0000F815                 mov     ebp, esp
.text$mn:0000F817                 mov     eax, [ebp+arg_0]
.text$mn:0000F81A                 mov     ecx, [ebp+arg_4]
.text$mn:0000F81D                 mov     dx, [ecx]
.text$mn:0000F820                 mov     [eax], dx
.text$mn:0000F823                 pop     ebp
.text$mn:0000F824                 retn
.text$mn:0000F824 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:0000F824
.text$mn:0000F824 ; ---------------------------------------------------------------------------
.text$mn:0000F825                 align 4
.text$mn:0000F825 _text$mn        ends
.text$mn:0000F825
.text$mn:0000F828 ; ===========================================================================
.text$mn:0000F828
.text$mn:0000F828 ; Segment type: Pure code
.text$mn:0000F828 ; Segment permissions: Read/Execute
.text$mn:0000F828 _text$mn        segment para public 'CODE' use32
.text$mn:0000F828                 assume cs:_text$mn
.text$mn:0000F828                 ;org 0F828h
.text$mn:0000F828 ; COMDAT (pick any)
.text$mn:0000F828                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F828
.text$mn:0000F828 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F828
.text$mn:0000F828 ; Attributes: bp-based frame
.text$mn:0000F828
.text$mn:0000F828 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::at(unsigned int)
.text$mn:0000F828                 public ?at@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:0000F828 ?at@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$mn:0000F828                                         ; CODE XREF: Notepad_plus::fileOpen(void)+11Cp
.text$mn:0000F828
.text$mn:0000F828 var_4           = dword ptr -4
.text$mn:0000F828 arg_0           = dword ptr  8
.text$mn:0000F828
.text$mn:0000F828                 push    ebp
.text$mn:0000F829                 mov     ebp, esp
.text$mn:0000F82B                 push    ecx
.text$mn:0000F82C                 mov     [ebp+var_4], ecx
.text$mn:0000F82F                 mov     ecx, [ebp+var_4]
.text$mn:0000F832                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:0000F837                 cmp     eax, [ebp+arg_0]
.text$mn:0000F83A                 ja      short loc_F844
.text$mn:0000F83C                 mov     ecx, [ebp+var_4]
.text$mn:0000F83F                 call    ?_Xran@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Xran(void)
.text$mn:0000F844
.text$mn:0000F844 loc_F844:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::at(uint)+12j
.text$mn:0000F844                 imul    eax, [ebp+arg_0], 1Ch
.text$mn:0000F848                 mov     ecx, [ebp+var_4]
.text$mn:0000F84B                 add     eax, [ecx+4]
.text$mn:0000F84E                 mov     esp, ebp
.text$mn:0000F850                 pop     ebp
.text$mn:0000F851                 retn    4
.text$mn:0000F851 ?at@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp
.text$mn:0000F851
.text$mn:0000F851 _text$mn        ends
.text$mn:0000F851
.text$mn:0000F854 ; ===========================================================================
.text$mn:0000F854
.text$mn:0000F854 ; Segment type: Pure code
.text$mn:0000F854 ; Segment permissions: Read/Execute
.text$mn:0000F854 _text$mn        segment para public 'CODE' use32
.text$mn:0000F854                 assume cs:_text$mn
.text$mn:0000F854                 ;org 0F854h
.text$mn:0000F854 ; COMDAT (pick any)
.text$mn:0000F854                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F854
.text$mn:0000F854 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F854
.text$mn:0000F854 ; Attributes: bp-based frame
.text$mn:0000F854
.text$mn:0000F854 ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::begin(void)
.text$mn:0000F854                 public ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000F854 ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$mn:0000F854                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+A9p
.text$mn:0000F854                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+AFp ...
.text$mn:0000F854
.text$mn:0000F854 var_14          = dword ptr -14h
.text$mn:0000F854 var_10          = dword ptr -10h
.text$mn:0000F854 var_C           = dword ptr -0Ch
.text$mn:0000F854 var_4           = dword ptr -4
.text$mn:0000F854 arg_0           = dword ptr  8
.text$mn:0000F854
.text$mn:0000F854                 push    ebp
.text$mn:0000F855                 mov     ebp, esp
.text$mn:0000F857                 push    0FFFFFFFFh
.text$mn:0000F859                 push    offset __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000F85E                 mov     eax, large fs:0
.text$mn:0000F864                 push    eax
.text$mn:0000F865                 sub     esp, 8
.text$mn:0000F868                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000F86D                 xor     eax, ebp
.text$mn:0000F86F                 push    eax
.text$mn:0000F870                 lea     eax, [ebp+var_C]
.text$mn:0000F873                 mov     large fs:0, eax
.text$mn:0000F879                 mov     [ebp+var_10], ecx
.text$mn:0000F87C                 mov     [ebp+var_14], 0
.text$mn:0000F883                 mov     eax, [ebp+var_10]
.text$mn:0000F886                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000F887                 mov     ecx, [ebp+var_10]
.text$mn:0000F88A                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000F88F                 push    eax             ; int
.text$mn:0000F890                 mov     ecx, [ebp+arg_0]
.text$mn:0000F893                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)
.text$mn:0000F898                 mov     [ebp+var_4], 0
.text$mn:0000F89F                 mov     ecx, [ebp+var_14]
.text$mn:0000F8A2                 or      ecx, 1
.text$mn:0000F8A5                 mov     [ebp+var_14], ecx
.text$mn:0000F8A8                 mov     eax, [ebp+arg_0]
.text$mn:0000F8AB                 mov     ecx, [ebp+var_C]
.text$mn:0000F8AE                 mov     large fs:0, ecx
.text$mn:0000F8B5                 pop     ecx
.text$mn:0000F8B6                 mov     esp, ebp
.text$mn:0000F8B8                 pop     ebp
.text$mn:0000F8B9                 retn    4
.text$mn:0000F8B9 ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$mn:0000F8B9
.text$mn:0000F8B9 _text$mn        ends
.text$mn:0000F8B9
.text$x:0000F8BC ; ===========================================================================
.text$x:0000F8BC
.text$x:0000F8BC ; Segment type: Pure code
.text$x:0000F8BC ; Segment permissions: Read/Execute
.text$x:0000F8BC _text$x         segment para public 'CODE' use32
.text$x:0000F8BC                 assume cs:_text$x
.text$x:0000F8BC                 ;org 0F8BCh
.text$x:0000F8BC ; COMDAT (pick associative to section at F854)
.text$x:0000F8BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000F8BC
.text$x:0000F8BC ; =============== S U B R O U T I N E =======================================
.text$x:0000F8BC
.text$x:0000F8BC
.text$x:0000F8BC __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 proc near
.text$x:0000F8BC                                         ; DATA XREF: .xdata$x:000129F4o
.text$x:0000F8BC                 mov     eax, [ebp-14h]
.text$x:0000F8BF                 and     eax, 1
.text$x:0000F8C2                 jz      $LN4
.text$x:0000F8C8                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000F8CC                 mov     ecx, [ebp+8]
.text$x:0000F8CF                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000F8D4 ; ---------------------------------------------------------------------------
.text$x:0000F8D4
.text$x:0000F8D4 $LN4:                                   ; CODE XREF: __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0+6j
.text$x:0000F8D4                 retn
.text$x:0000F8D4 __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 endp
.text$x:0000F8D4
.text$x:0000F8D5
.text$x:0000F8D5 ; =============== S U B R O U T I N E =======================================
.text$x:0000F8D5
.text$x:0000F8D5
.text$x:0000F8D5 __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$x:0000F8D5                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)+5o
.text$x:0000F8D5
.text$x:0000F8D5 arg_4           = dword ptr  8
.text$x:0000F8D5
.text$x:0000F8D5                 mov     edx, [esp+arg_4]
.text$x:0000F8D9                 lea     eax, [edx+0Ch]
.text$x:0000F8DC                 mov     ecx, [edx-0Ch]
.text$x:0000F8DF                 xor     ecx, eax
.text$x:0000F8E1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000F8E6                 mov     eax, offset __ehfuncinfo$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$x:0000F8EB                 jmp     ___CxxFrameHandler3
.text$x:0000F8EB __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$x:0000F8EB
.text$x:0000F8EB _text$x         ends
.text$x:0000F8EB
.text$mn:0000F8F0 ; ===========================================================================
.text$mn:0000F8F0
.text$mn:0000F8F0 ; Segment type: Pure code
.text$mn:0000F8F0 ; Segment permissions: Read/Execute
.text$mn:0000F8F0 _text$mn        segment para public 'CODE' use32
.text$mn:0000F8F0                 assume cs:_text$mn
.text$mn:0000F8F0                 ;org 0F8F0h
.text$mn:0000F8F0 ; COMDAT (pick any)
.text$mn:0000F8F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F8F0
.text$mn:0000F8F0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000F8F0
.text$mn:0000F8F0 ; Attributes: bp-based frame
.text$mn:0000F8F0
.text$mn:0000F8F0 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> __thiscall std::vector<int, class std::allocator<int>>::begin(void)const
.text$mn:0000F8F0                 public ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$mn:0000F8F0 ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ proc near
.text$mn:0000F8F0                                         ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+42p
.text$mn:0000F8F0                                         ; Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+1D2p
.text$mn:0000F8F0
.text$mn:0000F8F0 var_14          = dword ptr -14h
.text$mn:0000F8F0 var_10          = dword ptr -10h
.text$mn:0000F8F0 var_C           = dword ptr -0Ch
.text$mn:0000F8F0 var_4           = dword ptr -4
.text$mn:0000F8F0 arg_0           = dword ptr  8
.text$mn:0000F8F0
.text$mn:0000F8F0                 push    ebp
.text$mn:0000F8F1                 mov     ebp, esp
.text$mn:0000F8F3                 push    0FFFFFFFFh
.text$mn:0000F8F5                 push    offset __ehhandler$?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$mn:0000F8FA                 mov     eax, large fs:0
.text$mn:0000F900                 push    eax
.text$mn:0000F901                 sub     esp, 8
.text$mn:0000F904                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000F909                 xor     eax, ebp
.text$mn:0000F90B                 push    eax
.text$mn:0000F90C                 lea     eax, [ebp+var_C]
.text$mn:0000F90F                 mov     large fs:0, eax
.text$mn:0000F915                 mov     [ebp+var_10], ecx
.text$mn:0000F918                 mov     [ebp+var_14], 0
.text$mn:0000F91F                 mov     eax, [ebp+var_10]
.text$mn:0000F922                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000F923                 mov     ecx, [ebp+var_10]
.text$mn:0000F926                 mov     edx, [ecx+4]
.text$mn:0000F929                 push    edx             ; int
.text$mn:0000F92A                 mov     ecx, [ebp+arg_0]
.text$mn:0000F92D                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)
.text$mn:0000F932                 mov     [ebp+var_4], 0
.text$mn:0000F939                 mov     eax, [ebp+var_14]
.text$mn:0000F93C                 or      eax, 1
.text$mn:0000F93F                 mov     [ebp+var_14], eax
.text$mn:0000F942                 mov     eax, [ebp+arg_0]
.text$mn:0000F945                 mov     ecx, [ebp+var_C]
.text$mn:0000F948                 mov     large fs:0, ecx
.text$mn:0000F94F                 pop     ecx
.text$mn:0000F950                 mov     esp, ebp
.text$mn:0000F952                 pop     ebp
.text$mn:0000F953                 retn    4
.text$mn:0000F953 ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ endp
.text$mn:0000F953
.text$mn:0000F953 ; ---------------------------------------------------------------------------
.text$mn:0000F956                 align 4
.text$mn:0000F956 _text$mn        ends
.text$mn:0000F956
.text$x:0000F958 ; ===========================================================================
.text$x:0000F958
.text$x:0000F958 ; Segment type: Pure code
.text$x:0000F958 ; Segment permissions: Read/Execute
.text$x:0000F958 _text$x         segment para public 'CODE' use32
.text$x:0000F958                 assume cs:_text$x
.text$x:0000F958                 ;org 0F958h
.text$x:0000F958 ; COMDAT (pick associative to section at F8F0)
.text$x:0000F958                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000F958
.text$x:0000F958 ; =============== S U B R O U T I N E =======================================
.text$x:0000F958
.text$x:0000F958
.text$x:0000F958 __unwindfunclet$?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0 proc near
.text$x:0000F958                                         ; DATA XREF: .xdata$x:00012C40o
.text$x:0000F958                 mov     eax, [ebp-14h]
.text$x:0000F95B                 and     eax, 1
.text$x:0000F95E                 jz      $LN4_2
.text$x:0000F964                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000F968                 mov     ecx, [ebp+8]
.text$x:0000F96B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000F970 ; ---------------------------------------------------------------------------
.text$x:0000F970
.text$x:0000F970 $LN4_2:                                 ; CODE XREF: __unwindfunclet$?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0+6j
.text$x:0000F970                 retn
.text$x:0000F970 __unwindfunclet$?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0 endp
.text$x:0000F970
.text$x:0000F971
.text$x:0000F971 ; =============== S U B R O U T I N E =======================================
.text$x:0000F971
.text$x:0000F971
.text$x:0000F971 __ehhandler$?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ proc near
.text$x:0000F971                                         ; DATA XREF: std::vector<int,std::allocator<int>>::begin(void)+5o
.text$x:0000F971
.text$x:0000F971 arg_4           = dword ptr  8
.text$x:0000F971
.text$x:0000F971                 mov     edx, [esp+arg_4]
.text$x:0000F975                 lea     eax, [edx+0Ch]
.text$x:0000F978                 mov     ecx, [edx-0Ch]
.text$x:0000F97B                 xor     ecx, eax
.text$x:0000F97D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000F982                 mov     eax, offset __ehfuncinfo$?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$x:0000F987                 jmp     ___CxxFrameHandler3
.text$x:0000F987 __ehhandler$?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ endp
.text$x:0000F987
.text$x:0000F987 _text$x         ends
.text$x:0000F987
.text$mn:0000F98C ; ===========================================================================
.text$mn:0000F98C
.text$mn:0000F98C ; Segment type: Pure code
.text$mn:0000F98C ; Segment permissions: Read/Execute
.text$mn:0000F98C _text$mn        segment para public 'CODE' use32
.text$mn:0000F98C                 assume cs:_text$mn
.text$mn:0000F98C                 ;org 0F98Ch
.text$mn:0000F98C ; COMDAT (pick any)
.text$mn:0000F98C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000F98C
.text$mn:0000F98C ; =============== S U B R O U T I N E =======================================
.text$mn:0000F98C
.text$mn:0000F98C ; Attributes: bp-based frame
.text$mn:0000F98C
.text$mn:0000F98C ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned int>>> __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::begin(void)const
.text$mn:0000F98C                 public ?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
.text$mn:0000F98C ?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ proc near
.text$mn:0000F98C                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(std::vector<uint,std::allocator<uint>> const &)+A7p
.text$mn:0000F98C
.text$mn:0000F98C var_14          = dword ptr -14h
.text$mn:0000F98C var_10          = dword ptr -10h
.text$mn:0000F98C var_C           = dword ptr -0Ch
.text$mn:0000F98C var_4           = dword ptr -4
.text$mn:0000F98C arg_0           = dword ptr  8
.text$mn:0000F98C
.text$mn:0000F98C                 push    ebp
.text$mn:0000F98D                 mov     ebp, esp
.text$mn:0000F98F                 push    0FFFFFFFFh
.text$mn:0000F991                 push    offset __ehhandler$?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
.text$mn:0000F996                 mov     eax, large fs:0
.text$mn:0000F99C                 push    eax
.text$mn:0000F99D                 sub     esp, 8
.text$mn:0000F9A0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000F9A5                 xor     eax, ebp
.text$mn:0000F9A7                 push    eax
.text$mn:0000F9A8                 lea     eax, [ebp+var_C]
.text$mn:0000F9AB                 mov     large fs:0, eax
.text$mn:0000F9B1                 mov     [ebp+var_10], ecx
.text$mn:0000F9B4                 mov     [ebp+var_14], 0
.text$mn:0000F9BB                 mov     eax, [ebp+var_10]
.text$mn:0000F9BE                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000F9BF                 mov     ecx, [ebp+var_10]
.text$mn:0000F9C2                 mov     edx, [ecx+4]
.text$mn:0000F9C5                 push    edx             ; int
.text$mn:0000F9C6                 mov     ecx, [ebp+arg_0]
.text$mn:0000F9C9                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(uint *,std::_Container_base12 const *)
.text$mn:0000F9CE                 mov     [ebp+var_4], 0
.text$mn:0000F9D5                 mov     eax, [ebp+var_14]
.text$mn:0000F9D8                 or      eax, 1
.text$mn:0000F9DB                 mov     [ebp+var_14], eax
.text$mn:0000F9DE                 mov     eax, [ebp+arg_0]
.text$mn:0000F9E1                 mov     ecx, [ebp+var_C]
.text$mn:0000F9E4                 mov     large fs:0, ecx
.text$mn:0000F9EB                 pop     ecx
.text$mn:0000F9EC                 mov     esp, ebp
.text$mn:0000F9EE                 pop     ebp
.text$mn:0000F9EF                 retn    4
.text$mn:0000F9EF ?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ endp
.text$mn:0000F9EF
.text$mn:0000F9EF ; ---------------------------------------------------------------------------
.text$mn:0000F9F2                 align 4
.text$mn:0000F9F2 _text$mn        ends
.text$mn:0000F9F2
.text$x:0000F9F4 ; ===========================================================================
.text$x:0000F9F4
.text$x:0000F9F4 ; Segment type: Pure code
.text$x:0000F9F4 ; Segment permissions: Read/Execute
.text$x:0000F9F4 _text$x         segment para public 'CODE' use32
.text$x:0000F9F4                 assume cs:_text$x
.text$x:0000F9F4                 ;org 0F9F4h
.text$x:0000F9F4 ; COMDAT (pick associative to section at F98C)
.text$x:0000F9F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000F9F4
.text$x:0000F9F4 ; =============== S U B R O U T I N E =======================================
.text$x:0000F9F4
.text$x:0000F9F4
.text$x:0000F9F4 __unwindfunclet$?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ$0 proc near
.text$x:0000F9F4                                         ; DATA XREF: .xdata$x:00012F40o
.text$x:0000F9F4                 mov     eax, [ebp-14h]
.text$x:0000F9F7                 and     eax, 1
.text$x:0000F9FA                 jz      $LN4_4
.text$x:0000FA00                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000FA04                 mov     ecx, [ebp+8]
.text$x:0000FA07                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$x:0000FA0C ; ---------------------------------------------------------------------------
.text$x:0000FA0C
.text$x:0000FA0C $LN4_4:                                 ; CODE XREF: __unwindfunclet$?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ$0+6j
.text$x:0000FA0C                 retn
.text$x:0000FA0C __unwindfunclet$?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ$0 endp
.text$x:0000FA0C
.text$x:0000FA0D
.text$x:0000FA0D ; =============== S U B R O U T I N E =======================================
.text$x:0000FA0D
.text$x:0000FA0D
.text$x:0000FA0D __ehhandler$?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ proc near
.text$x:0000FA0D                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::begin(void)+5o
.text$x:0000FA0D
.text$x:0000FA0D arg_4           = dword ptr  8
.text$x:0000FA0D
.text$x:0000FA0D                 mov     edx, [esp+arg_4]
.text$x:0000FA11                 lea     eax, [edx+0Ch]
.text$x:0000FA14                 mov     ecx, [edx-0Ch]
.text$x:0000FA17                 xor     ecx, eax
.text$x:0000FA19                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000FA1E                 mov     eax, offset __ehfuncinfo$?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
.text$x:0000FA23                 jmp     ___CxxFrameHandler3
.text$x:0000FA23 __ehhandler$?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ endp
.text$x:0000FA23
.text$x:0000FA23 _text$x         ends
.text$x:0000FA23
.text$mn:0000FA28 ; ===========================================================================
.text$mn:0000FA28
.text$mn:0000FA28 ; Segment type: Pure code
.text$mn:0000FA28 ; Segment permissions: Read/Execute
.text$mn:0000FA28 _text$mn        segment para public 'CODE' use32
.text$mn:0000FA28                 assume cs:_text$mn
.text$mn:0000FA28                 ;org 0FA28h
.text$mn:0000FA28 ; COMDAT (pick any)
.text$mn:0000FA28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FA28
.text$mn:0000FA28 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FA28
.text$mn:0000FA28 ; Attributes: bp-based frame
.text$mn:0000FA28
.text$mn:0000FA28 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>> __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::begin(void)
.text$mn:0000FA28                 public ?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ
.text$mn:0000FA28 ?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ proc near
.text$mn:0000FA28                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+BCp
.text$mn:0000FA28                                         ; Notepad_plus::loadSession(Session &,bool)+581p ...
.text$mn:0000FA28
.text$mn:0000FA28 var_14          = dword ptr -14h
.text$mn:0000FA28 var_10          = dword ptr -10h
.text$mn:0000FA28 var_C           = dword ptr -0Ch
.text$mn:0000FA28 var_4           = dword ptr -4
.text$mn:0000FA28 arg_0           = dword ptr  8
.text$mn:0000FA28
.text$mn:0000FA28                 push    ebp
.text$mn:0000FA29                 mov     ebp, esp
.text$mn:0000FA2B                 push    0FFFFFFFFh
.text$mn:0000FA2D                 push    offset __ehhandler$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ
.text$mn:0000FA32                 mov     eax, large fs:0
.text$mn:0000FA38                 push    eax
.text$mn:0000FA39                 sub     esp, 8
.text$mn:0000FA3C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000FA41                 xor     eax, ebp
.text$mn:0000FA43                 push    eax
.text$mn:0000FA44                 lea     eax, [ebp+var_C]
.text$mn:0000FA47                 mov     large fs:0, eax
.text$mn:0000FA4D                 mov     [ebp+var_10], ecx
.text$mn:0000FA50                 mov     [ebp+var_14], 0
.text$mn:0000FA57                 mov     eax, [ebp+var_10]
.text$mn:0000FA5A                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000FA5B                 mov     ecx, [ebp+var_10]
.text$mn:0000FA5E                 mov     edx, [ecx+4]
.text$mn:0000FA61                 push    edx             ; int
.text$mn:0000FA62                 mov     ecx, [ebp+arg_0]
.text$mn:0000FA65                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(sessionFileInfo *,std::_Container_base12 const *)
.text$mn:0000FA6A                 mov     [ebp+var_4], 0
.text$mn:0000FA71                 mov     eax, [ebp+var_14]
.text$mn:0000FA74                 or      eax, 1
.text$mn:0000FA77                 mov     [ebp+var_14], eax
.text$mn:0000FA7A                 mov     eax, [ebp+arg_0]
.text$mn:0000FA7D                 mov     ecx, [ebp+var_C]
.text$mn:0000FA80                 mov     large fs:0, ecx
.text$mn:0000FA87                 pop     ecx
.text$mn:0000FA88                 mov     esp, ebp
.text$mn:0000FA8A                 pop     ebp
.text$mn:0000FA8B                 retn    4
.text$mn:0000FA8B ?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ endp
.text$mn:0000FA8B
.text$mn:0000FA8B ; ---------------------------------------------------------------------------
.text$mn:0000FA8E                 align 10h
.text$mn:0000FA8E _text$mn        ends
.text$mn:0000FA8E
.text$x:0000FA90 ; ===========================================================================
.text$x:0000FA90
.text$x:0000FA90 ; Segment type: Pure code
.text$x:0000FA90 ; Segment permissions: Read/Execute
.text$x:0000FA90 _text$x         segment para public 'CODE' use32
.text$x:0000FA90                 assume cs:_text$x
.text$x:0000FA90                 ;org 0FA90h
.text$x:0000FA90 ; COMDAT (pick associative to section at FA28)
.text$x:0000FA90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000FA90
.text$x:0000FA90 ; =============== S U B R O U T I N E =======================================
.text$x:0000FA90
.text$x:0000FA90
.text$x:0000FA90 __unwindfunclet$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ$0 proc near
.text$x:0000FA90                                         ; DATA XREF: .xdata$x:000131D4o
.text$x:0000FA90                 mov     eax, [ebp-14h]
.text$x:0000FA93                 and     eax, 1
.text$x:0000FA96                 jz      $LN4_6
.text$x:0000FA9C                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000FAA0                 mov     ecx, [ebp+8]
.text$x:0000FAA3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:0000FAA8 ; ---------------------------------------------------------------------------
.text$x:0000FAA8
.text$x:0000FAA8 $LN4_6:                                 ; CODE XREF: __unwindfunclet$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ$0+6j
.text$x:0000FAA8                 retn
.text$x:0000FAA8 __unwindfunclet$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ$0 endp
.text$x:0000FAA8
.text$x:0000FAA9
.text$x:0000FAA9 ; =============== S U B R O U T I N E =======================================
.text$x:0000FAA9
.text$x:0000FAA9
.text$x:0000FAA9 __ehhandler$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ proc near
.text$x:0000FAA9                                         ; DATA XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::begin(void)+5o
.text$x:0000FAA9
.text$x:0000FAA9 arg_4           = dword ptr  8
.text$x:0000FAA9
.text$x:0000FAA9                 mov     edx, [esp+arg_4]
.text$x:0000FAAD                 lea     eax, [edx+0Ch]
.text$x:0000FAB0                 mov     ecx, [edx-0Ch]
.text$x:0000FAB3                 xor     ecx, eax
.text$x:0000FAB5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000FABA                 mov     eax, offset __ehfuncinfo$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ
.text$x:0000FABF                 jmp     ___CxxFrameHandler3
.text$x:0000FABF __ehhandler$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ endp
.text$x:0000FABF
.text$x:0000FABF _text$x         ends
.text$x:0000FABF
.text$mn:0000FAC4 ; ===========================================================================
.text$mn:0000FAC4
.text$mn:0000FAC4 ; Segment type: Pure code
.text$mn:0000FAC4 ; Segment permissions: Read/Execute
.text$mn:0000FAC4 _text$mn        segment para public 'CODE' use32
.text$mn:0000FAC4                 assume cs:_text$mn
.text$mn:0000FAC4                 ;org 0FAC4h
.text$mn:0000FAC4 ; COMDAT (pick any)
.text$mn:0000FAC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FAC4
.text$mn:0000FAC4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FAC4
.text$mn:0000FAC4 ; Attributes: bp-based frame
.text$mn:0000FAC4
.text$mn:0000FAC4 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>> __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::begin(void)const
.text$mn:0000FAC4                 public ?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ
.text$mn:0000FAC4 ?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ proc near
.text$mn:0000FAC4                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(std::vector<sessionFileInfo,std::allocator<sessionFileInfo>> const &)+A7p
.text$mn:0000FAC4
.text$mn:0000FAC4 var_14          = dword ptr -14h
.text$mn:0000FAC4 var_10          = dword ptr -10h
.text$mn:0000FAC4 var_C           = dword ptr -0Ch
.text$mn:0000FAC4 var_4           = dword ptr -4
.text$mn:0000FAC4 arg_0           = dword ptr  8
.text$mn:0000FAC4
.text$mn:0000FAC4                 push    ebp
.text$mn:0000FAC5                 mov     ebp, esp
.text$mn:0000FAC7                 push    0FFFFFFFFh
.text$mn:0000FAC9                 push    offset __ehhandler$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ
.text$mn:0000FACE                 mov     eax, large fs:0
.text$mn:0000FAD4                 push    eax
.text$mn:0000FAD5                 sub     esp, 8
.text$mn:0000FAD8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000FADD                 xor     eax, ebp
.text$mn:0000FADF                 push    eax
.text$mn:0000FAE0                 lea     eax, [ebp+var_C]
.text$mn:0000FAE3                 mov     large fs:0, eax
.text$mn:0000FAE9                 mov     [ebp+var_10], ecx
.text$mn:0000FAEC                 mov     [ebp+var_14], 0
.text$mn:0000FAF3                 mov     eax, [ebp+var_10]
.text$mn:0000FAF6                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000FAF7                 mov     ecx, [ebp+var_10]
.text$mn:0000FAFA                 mov     edx, [ecx+4]
.text$mn:0000FAFD                 push    edx             ; int
.text$mn:0000FAFE                 mov     ecx, [ebp+arg_0]
.text$mn:0000FB01                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(sessionFileInfo *,std::_Container_base12 const *)
.text$mn:0000FB06                 mov     [ebp+var_4], 0
.text$mn:0000FB0D                 mov     eax, [ebp+var_14]
.text$mn:0000FB10                 or      eax, 1
.text$mn:0000FB13                 mov     [ebp+var_14], eax
.text$mn:0000FB16                 mov     eax, [ebp+arg_0]
.text$mn:0000FB19                 mov     ecx, [ebp+var_C]
.text$mn:0000FB1C                 mov     large fs:0, ecx
.text$mn:0000FB23                 pop     ecx
.text$mn:0000FB24                 mov     esp, ebp
.text$mn:0000FB26                 pop     ebp
.text$mn:0000FB27                 retn    4
.text$mn:0000FB27 ?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ endp
.text$mn:0000FB27
.text$mn:0000FB27 ; ---------------------------------------------------------------------------
.text$mn:0000FB2A                 align 4
.text$mn:0000FB2A _text$mn        ends
.text$mn:0000FB2A
.text$x:0000FB2C ; ===========================================================================
.text$x:0000FB2C
.text$x:0000FB2C ; Segment type: Pure code
.text$x:0000FB2C ; Segment permissions: Read/Execute
.text$x:0000FB2C _text$x         segment para public 'CODE' use32
.text$x:0000FB2C                 assume cs:_text$x
.text$x:0000FB2C                 ;org 0FB2Ch
.text$x:0000FB2C ; COMDAT (pick associative to section at FAC4)
.text$x:0000FB2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000FB2C
.text$x:0000FB2C ; =============== S U B R O U T I N E =======================================
.text$x:0000FB2C
.text$x:0000FB2C
.text$x:0000FB2C __unwindfunclet$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ$0 proc near
.text$x:0000FB2C                                         ; DATA XREF: .xdata$x:00013200o
.text$x:0000FB2C                 mov     eax, [ebp-14h]
.text$x:0000FB2F                 and     eax, 1
.text$x:0000FB32                 jz      $LN4_7
.text$x:0000FB38                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000FB3C                 mov     ecx, [ebp+8]
.text$x:0000FB3F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:0000FB44 ; ---------------------------------------------------------------------------
.text$x:0000FB44
.text$x:0000FB44 $LN4_7:                                 ; CODE XREF: __unwindfunclet$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ$0+6j
.text$x:0000FB44                 retn
.text$x:0000FB44 __unwindfunclet$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ$0 endp
.text$x:0000FB44
.text$x:0000FB45
.text$x:0000FB45 ; =============== S U B R O U T I N E =======================================
.text$x:0000FB45
.text$x:0000FB45
.text$x:0000FB45 __ehhandler$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ proc near
.text$x:0000FB45                                         ; DATA XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::begin(void)+5o
.text$x:0000FB45
.text$x:0000FB45 arg_4           = dword ptr  8
.text$x:0000FB45
.text$x:0000FB45                 mov     edx, [esp+arg_4]
.text$x:0000FB49                 lea     eax, [edx+0Ch]
.text$x:0000FB4C                 mov     ecx, [edx-0Ch]
.text$x:0000FB4F                 xor     ecx, eax
.text$x:0000FB51                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000FB56                 mov     eax, offset __ehfuncinfo$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ
.text$x:0000FB5B                 jmp     ___CxxFrameHandler3
.text$x:0000FB5B __ehhandler$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ endp
.text$x:0000FB5B
.text$x:0000FB5B _text$x         ends
.text$x:0000FB5B
.text$mn:0000FB60 ; ===========================================================================
.text$mn:0000FB60
.text$mn:0000FB60 ; Segment type: Pure code
.text$mn:0000FB60 ; Segment permissions: Read/Execute
.text$mn:0000FB60 _text$mn        segment para public 'CODE' use32
.text$mn:0000FB60                 assume cs:_text$mn
.text$mn:0000FB60                 ;org 0FB60h
.text$mn:0000FB60 ; COMDAT (pick any)
.text$mn:0000FB60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FB60
.text$mn:0000FB60 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FB60
.text$mn:0000FB60 ; Attributes: bp-based frame
.text$mn:0000FB60
.text$mn:0000FB60 ; bool __thiscall Notepad_plus::bothActive(Notepad_plus *__hidden this)
.text$mn:0000FB60                 public ?bothActive@Notepad_plus@@AAE_NXZ
.text$mn:0000FB60 ?bothActive@Notepad_plus@@AAE_NXZ proc near
.text$mn:0000FB60                                         ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+6B7p
.text$mn:0000FB60                                         ; Notepad_plus::fileCloseAllButCurrent(void)+227p
.text$mn:0000FB60
.text$mn:0000FB60 var_8           = dword ptr -8
.text$mn:0000FB60 var_4           = dword ptr -4
.text$mn:0000FB60
.text$mn:0000FB60                 push    ebp
.text$mn:0000FB61                 mov     ebp, esp
.text$mn:0000FB63                 sub     esp, 8
.text$mn:0000FB66                 mov     [ebp+var_8], ecx
.text$mn:0000FB69                 mov     eax, [ebp+var_8]
.text$mn:0000FB6C                 movzx   ecx, byte ptr [eax+551C4h]
.text$mn:0000FB73                 and     ecx, 3
.text$mn:0000FB76                 cmp     ecx, 3
.text$mn:0000FB79                 jnz     short loc_FB84
.text$mn:0000FB7B                 mov     [ebp+var_4], 1
.text$mn:0000FB82                 jmp     short loc_FB8B
.text$mn:0000FB84 ; ---------------------------------------------------------------------------
.text$mn:0000FB84
.text$mn:0000FB84 loc_FB84:                               ; CODE XREF: Notepad_plus::bothActive(void)+19j
.text$mn:0000FB84                 mov     [ebp+var_4], 0
.text$mn:0000FB8B
.text$mn:0000FB8B loc_FB8B:                               ; CODE XREF: Notepad_plus::bothActive(void)+22j
.text$mn:0000FB8B                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000FB8E                 mov     esp, ebp
.text$mn:0000FB90                 pop     ebp
.text$mn:0000FB91                 retn
.text$mn:0000FB91 ?bothActive@Notepad_plus@@AAE_NXZ endp
.text$mn:0000FB91
.text$mn:0000FB91 ; ---------------------------------------------------------------------------
.text$mn:0000FB92                 align 4
.text$mn:0000FB92 _text$mn        ends
.text$mn:0000FB92
.text$mn:0000FB94 ; ===========================================================================
.text$mn:0000FB94
.text$mn:0000FB94 ; Segment type: Pure code
.text$mn:0000FB94 ; Segment permissions: Read/Execute
.text$mn:0000FB94 _text$mn        segment para public 'CODE' use32
.text$mn:0000FB94                 assume cs:_text$mn
.text$mn:0000FB94                 ;org 0FB94h
.text$mn:0000FB94 ; COMDAT (pick any)
.text$mn:0000FB94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FB94
.text$mn:0000FB94 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FB94
.text$mn:0000FB94 ; Attributes: bp-based frame
.text$mn:0000FB94
.text$mn:0000FB94 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:0000FB94                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:0000FB94 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:0000FB94                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+3DAp
.text$mn:0000FB94                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+958p ...
.text$mn:0000FB94
.text$mn:0000FB94 var_4           = dword ptr -4
.text$mn:0000FB94
.text$mn:0000FB94                 push    ebp
.text$mn:0000FB95                 mov     ebp, esp
.text$mn:0000FB97                 push    ecx
.text$mn:0000FB98                 mov     [ebp+var_4], ecx
.text$mn:0000FB9B                 mov     ecx, [ebp+var_4]
.text$mn:0000FB9E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000FBA3                 mov     esp, ebp
.text$mn:0000FBA5                 pop     ebp
.text$mn:0000FBA6                 retn
.text$mn:0000FBA6 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:0000FBA6
.text$mn:0000FBA6 ; ---------------------------------------------------------------------------
.text$mn:0000FBA7                 align 4
.text$mn:0000FBA7 _text$mn        ends
.text$mn:0000FBA7
.text$mn:0000FBA8 ; ===========================================================================
.text$mn:0000FBA8
.text$mn:0000FBA8 ; Segment type: Pure code
.text$mn:0000FBA8 ; Segment permissions: Read/Execute
.text$mn:0000FBA8 _text$mn        segment para public 'CODE' use32
.text$mn:0000FBA8                 assume cs:_text$mn
.text$mn:0000FBA8                 ;org 0FBA8h
.text$mn:0000FBA8 ; COMDAT (pick any)
.text$mn:0000FBA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FBA8
.text$mn:0000FBA8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FBA8
.text$mn:0000FBA8 ; Attributes: bp-based frame
.text$mn:0000FBA8
.text$mn:0000FBA8 ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::capacity(void)const
.text$mn:0000FBA8                 public ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:0000FBA8 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:0000FBA8                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+Cp
.text$mn:0000FBA8
.text$mn:0000FBA8 var_4           = dword ptr -4
.text$mn:0000FBA8
.text$mn:0000FBA8                 push    ebp
.text$mn:0000FBA9                 mov     ebp, esp
.text$mn:0000FBAB                 push    ecx
.text$mn:0000FBAC                 mov     [ebp+var_4], ecx
.text$mn:0000FBAF                 mov     eax, [ebp+var_4]
.text$mn:0000FBB2                 mov     ecx, [ebp+var_4]
.text$mn:0000FBB5                 mov     eax, [eax+0Ch]
.text$mn:0000FBB8                 sub     eax, [ecx+4]
.text$mn:0000FBBB                 sar     eax, 2
.text$mn:0000FBBE                 mov     esp, ebp
.text$mn:0000FBC0                 pop     ebp
.text$mn:0000FBC1                 retn
.text$mn:0000FBC1 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:0000FBC1
.text$mn:0000FBC1 ; ---------------------------------------------------------------------------
.text$mn:0000FBC2                 align 4
.text$mn:0000FBC2 _text$mn        ends
.text$mn:0000FBC2
.text$mn:0000FBC4 ; ===========================================================================
.text$mn:0000FBC4
.text$mn:0000FBC4 ; Segment type: Pure code
.text$mn:0000FBC4 ; Segment permissions: Read/Execute
.text$mn:0000FBC4 _text$mn        segment para public 'CODE' use32
.text$mn:0000FBC4                 assume cs:_text$mn
.text$mn:0000FBC4                 ;org 0FBC4h
.text$mn:0000FBC4 ; COMDAT (pick any)
.text$mn:0000FBC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FBC4
.text$mn:0000FBC4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FBC4
.text$mn:0000FBC4 ; Attributes: bp-based frame
.text$mn:0000FBC4
.text$mn:0000FBC4 ; public: unsigned int __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::capacity(void)const
.text$mn:0000FBC4                 public ?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
.text$mn:0000FBC4 ?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ proc near
.text$mn:0000FBC4                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+11Bp
.text$mn:0000FBC4
.text$mn:0000FBC4 var_4           = dword ptr -4
.text$mn:0000FBC4
.text$mn:0000FBC4                 push    ebp
.text$mn:0000FBC5                 mov     ebp, esp
.text$mn:0000FBC7                 push    ecx
.text$mn:0000FBC8                 mov     [ebp+var_4], ecx
.text$mn:0000FBCB                 mov     eax, [ebp+var_4]
.text$mn:0000FBCE                 mov     ecx, [ebp+var_4]
.text$mn:0000FBD1                 mov     eax, [eax+0Ch]
.text$mn:0000FBD4                 sub     eax, [ecx+4]
.text$mn:0000FBD7                 sar     eax, 2
.text$mn:0000FBDA                 mov     esp, ebp
.text$mn:0000FBDC                 pop     ebp
.text$mn:0000FBDD                 retn
.text$mn:0000FBDD ?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ endp
.text$mn:0000FBDD
.text$mn:0000FBDD ; ---------------------------------------------------------------------------
.text$mn:0000FBDE                 align 10h
.text$mn:0000FBDE _text$mn        ends
.text$mn:0000FBDE
.text$mn:0000FBE0 ; ===========================================================================
.text$mn:0000FBE0
.text$mn:0000FBE0 ; Segment type: Pure code
.text$mn:0000FBE0 ; Segment permissions: Read/Execute
.text$mn:0000FBE0 _text$mn        segment para public 'CODE' use32
.text$mn:0000FBE0                 assume cs:_text$mn
.text$mn:0000FBE0                 ;org 0FBE0h
.text$mn:0000FBE0 ; COMDAT (pick any)
.text$mn:0000FBE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FBE0
.text$mn:0000FBE0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FBE0
.text$mn:0000FBE0 ; Attributes: bp-based frame
.text$mn:0000FBE0
.text$mn:0000FBE0 ; public: unsigned int __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::capacity(void)const
.text$mn:0000FBE0                 public ?capacity@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ
.text$mn:0000FBE0 ?capacity@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:0000FBE0                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Grow_to(uint)+Cp
.text$mn:0000FBE0
.text$mn:0000FBE0 var_4           = dword ptr -4
.text$mn:0000FBE0
.text$mn:0000FBE0                 push    ebp
.text$mn:0000FBE1                 mov     ebp, esp
.text$mn:0000FBE3                 push    ecx
.text$mn:0000FBE4                 mov     [ebp+var_4], ecx
.text$mn:0000FBE7                 mov     eax, [ebp+var_4]
.text$mn:0000FBEA                 mov     ecx, [ebp+var_4]
.text$mn:0000FBED                 mov     eax, [eax+0Ch]
.text$mn:0000FBF0                 sub     eax, [ecx+4]
.text$mn:0000FBF3                 cdq
.text$mn:0000FBF4                 mov     ecx, 98h ; 'ÿ'
.text$mn:0000FBF9                 idiv    ecx
.text$mn:0000FBFB                 mov     esp, ebp
.text$mn:0000FBFD                 pop     ebp
.text$mn:0000FBFE                 retn
.text$mn:0000FBFE ?capacity@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ endp
.text$mn:0000FBFE
.text$mn:0000FBFE ; ---------------------------------------------------------------------------
.text$mn:0000FBFF                 align 10h
.text$mn:0000FBFF _text$mn        ends
.text$mn:0000FBFF
.text$mn:0000FC00 ; ===========================================================================
.text$mn:0000FC00
.text$mn:0000FC00 ; Segment type: Pure code
.text$mn:0000FC00 ; Segment permissions: Read/Execute
.text$mn:0000FC00 _text$mn        segment para public 'CODE' use32
.text$mn:0000FC00                 assume cs:_text$mn
.text$mn:0000FC00                 ;org 0FC00h
.text$mn:0000FC00 ; COMDAT (pick any)
.text$mn:0000FC00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FC00
.text$mn:0000FC00 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FC00
.text$mn:0000FC00 ; Attributes: bp-based frame
.text$mn:0000FC00
.text$mn:0000FC00 ; public: unsigned int __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::capacity(void)const
.text$mn:0000FC00                 public ?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ
.text$mn:0000FC00 ?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ proc near
.text$mn:0000FC00                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)+Cp
.text$mn:0000FC00
.text$mn:0000FC00 var_4           = dword ptr -4
.text$mn:0000FC00
.text$mn:0000FC00                 push    ebp
.text$mn:0000FC01                 mov     ebp, esp
.text$mn:0000FC03                 push    ecx
.text$mn:0000FC04                 mov     [ebp+var_4], ecx
.text$mn:0000FC07                 mov     eax, [ebp+var_4]
.text$mn:0000FC0A                 mov     ecx, [ebp+var_4]
.text$mn:0000FC0D                 mov     eax, [eax+0Ch]
.text$mn:0000FC10                 sub     eax, [ecx+4]
.text$mn:0000FC13                 cdq
.text$mn:0000FC14                 mov     ecx, 1Ch
.text$mn:0000FC19                 idiv    ecx
.text$mn:0000FC1B                 mov     esp, ebp
.text$mn:0000FC1D                 pop     ebp
.text$mn:0000FC1E                 retn
.text$mn:0000FC1E ?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ endp
.text$mn:0000FC1E
.text$mn:0000FC1E ; ---------------------------------------------------------------------------
.text$mn:0000FC1F                 align 10h
.text$mn:0000FC1F _text$mn        ends
.text$mn:0000FC1F
.text$mn:0000FC20 ; ===========================================================================
.text$mn:0000FC20
.text$mn:0000FC20 ; Segment type: Pure code
.text$mn:0000FC20 ; Segment permissions: Read/Execute
.text$mn:0000FC20 _text$mn        segment para public 'CODE' use32
.text$mn:0000FC20                 assume cs:_text$mn
.text$mn:0000FC20                 ;org 0FC20h
.text$mn:0000FC20 ; COMDAT (pick any)
.text$mn:0000FC20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FC20
.text$mn:0000FC20 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FC20
.text$mn:0000FC20 ; Attributes: bp-based frame
.text$mn:0000FC20
.text$mn:0000FC20 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:0000FC20                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:0000FC20 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000FC20                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:0000FC20
.text$mn:0000FC20 var_4           = dword ptr -4
.text$mn:0000FC20
.text$mn:0000FC20                 push    ebp
.text$mn:0000FC21                 mov     ebp, esp
.text$mn:0000FC23                 push    ecx
.text$mn:0000FC24                 mov     [ebp+var_4], ecx
.text$mn:0000FC27                 mov     eax, [ebp+var_4]
.text$mn:0000FC2A                 mov     eax, [eax+4]
.text$mn:0000FC2D                 mov     esp, ebp
.text$mn:0000FC2F                 pop     ebp
.text$mn:0000FC30                 retn
.text$mn:0000FC30 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000FC30
.text$mn:0000FC30 ; ---------------------------------------------------------------------------
.text$mn:0000FC31                 align 4
.text$mn:0000FC31 _text$mn        ends
.text$mn:0000FC31
.text$mn:0000FC34 ; ===========================================================================
.text$mn:0000FC34
.text$mn:0000FC34 ; Segment type: Pure code
.text$mn:0000FC34 ; Segment permissions: Read/Execute
.text$mn:0000FC34 _text$mn        segment para public 'CODE' use32
.text$mn:0000FC34                 assume cs:_text$mn
.text$mn:0000FC34                 ;org 0FC34h
.text$mn:0000FC34 ; COMDAT (pick any)
.text$mn:0000FC34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FC34
.text$mn:0000FC34 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FC34
.text$mn:0000FC34 ; Attributes: bp-based frame
.text$mn:0000FC34
.text$mn:0000FC34 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:0000FC34                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:0000FC34 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000FC34                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:0000FC34                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:0000FC34
.text$mn:0000FC34 var_4           = dword ptr -4
.text$mn:0000FC34
.text$mn:0000FC34                 push    ebp
.text$mn:0000FC35                 mov     ebp, esp
.text$mn:0000FC37                 push    ecx
.text$mn:0000FC38                 mov     [ebp+var_4], ecx
.text$mn:0000FC3B                 mov     eax, [ebp+var_4]
.text$mn:0000FC3E                 mov     eax, [eax+4]
.text$mn:0000FC41                 mov     esp, ebp
.text$mn:0000FC43                 pop     ebp
.text$mn:0000FC44                 retn
.text$mn:0000FC44 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000FC44
.text$mn:0000FC44 ; ---------------------------------------------------------------------------
.text$mn:0000FC45                 align 4
.text$mn:0000FC45 _text$mn        ends
.text$mn:0000FC45
.text$mn:0000FC48 ; ===========================================================================
.text$mn:0000FC48
.text$mn:0000FC48 ; Segment type: Pure code
.text$mn:0000FC48 ; Segment permissions: Read/Execute
.text$mn:0000FC48 _text$mn        segment para public 'CODE' use32
.text$mn:0000FC48                 assume cs:_text$mn
.text$mn:0000FC48                 ;org 0FC48h
.text$mn:0000FC48 ; COMDAT (pick any)
.text$mn:0000FC48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FC48
.text$mn:0000FC48 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FC48
.text$mn:0000FC48 ; Attributes: bp-based frame
.text$mn:0000FC48
.text$mn:0000FC48 ; public: void __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::clear(void)
.text$mn:0000FC48                 public ?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ
.text$mn:0000FC48 ?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ proc near
.text$mn:0000FC48                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+9Fp
.text$mn:0000FC48
.text$mn:0000FC48 var_4           = dword ptr -4
.text$mn:0000FC48
.text$mn:0000FC48                 push    ebp
.text$mn:0000FC49                 mov     ebp, esp
.text$mn:0000FC4B                 push    ecx
.text$mn:0000FC4C                 mov     [ebp+var_4], ecx
.text$mn:0000FC4F                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000FC52                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000FC57                 mov     eax, [ebp+var_4]
.text$mn:0000FC5A                 mov     ecx, [eax+8]
.text$mn:0000FC5D                 push    ecx
.text$mn:0000FC5E                 mov     edx, [ebp+var_4]
.text$mn:0000FC61                 mov     eax, [edx+4]
.text$mn:0000FC64                 push    eax
.text$mn:0000FC65                 mov     ecx, [ebp+var_4]
.text$mn:0000FC68                 call    ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<uint,std::allocator<uint>>::_Destroy(uint *,uint *)
.text$mn:0000FC6D                 mov     ecx, [ebp+var_4]
.text$mn:0000FC70                 mov     edx, [ebp+var_4]
.text$mn:0000FC73                 mov     eax, [edx+4]
.text$mn:0000FC76                 mov     [ecx+8], eax
.text$mn:0000FC79                 mov     esp, ebp
.text$mn:0000FC7B                 pop     ebp
.text$mn:0000FC7C                 retn
.text$mn:0000FC7C ?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ endp
.text$mn:0000FC7C
.text$mn:0000FC7C ; ---------------------------------------------------------------------------
.text$mn:0000FC7D                 align 10h
.text$mn:0000FC7D _text$mn        ends
.text$mn:0000FC7D
.text$mn:0000FC80 ; ===========================================================================
.text$mn:0000FC80
.text$mn:0000FC80 ; Segment type: Pure code
.text$mn:0000FC80 ; Segment permissions: Read/Execute
.text$mn:0000FC80 _text$mn        segment para public 'CODE' use32
.text$mn:0000FC80                 assume cs:_text$mn
.text$mn:0000FC80                 ;org 0FC80h
.text$mn:0000FC80 ; COMDAT (pick any)
.text$mn:0000FC80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FC80
.text$mn:0000FC80 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FC80
.text$mn:0000FC80 ; Attributes: bp-based frame
.text$mn:0000FC80
.text$mn:0000FC80 ; int __thiscall VerticalFileSwitcher::closeItem(VerticalFileSwitcher *this, int, int)
.text$mn:0000FC80                 public ?closeItem@VerticalFileSwitcher@@QAEHHH@Z
.text$mn:0000FC80 ?closeItem@VerticalFileSwitcher@@QAEHHH@Z proc near
.text$mn:0000FC80                                         ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+1F6p
.text$mn:0000FC80                                         ; Notepad_plus::doClose(Buffer *,int,bool)+212p
.text$mn:0000FC80
.text$mn:0000FC80 var_4           = dword ptr -4
.text$mn:0000FC80 arg_0           = dword ptr  8
.text$mn:0000FC80 arg_4           = dword ptr  0Ch
.text$mn:0000FC80
.text$mn:0000FC80                 push    ebp
.text$mn:0000FC81                 mov     ebp, esp
.text$mn:0000FC83                 push    ecx
.text$mn:0000FC84                 mov     [ebp+var_4], ecx
.text$mn:0000FC87                 mov     eax, [ebp+arg_4]
.text$mn:0000FC8A                 push    eax             ; int
.text$mn:0000FC8B                 mov     ecx, [ebp+arg_0]
.text$mn:0000FC8E                 push    ecx             ; int
.text$mn:0000FC8F                 mov     ecx, [ebp+var_4]
.text$mn:0000FC92                 add     ecx, 6Ch ; 'l'  ; this
.text$mn:0000FC95                 call    ?closeItem@VerticalFileSwitcherListView@@QAEHHH@Z ; VerticalFileSwitcherListView::closeItem(int,int)
.text$mn:0000FC9A                 mov     esp, ebp
.text$mn:0000FC9C                 pop     ebp
.text$mn:0000FC9D                 retn    8
.text$mn:0000FC9D ?closeItem@VerticalFileSwitcher@@QAEHHH@Z endp
.text$mn:0000FC9D
.text$mn:0000FC9D _text$mn        ends
.text$mn:0000FC9D
.text$mn:0000FCA0 ; ===========================================================================
.text$mn:0000FCA0
.text$mn:0000FCA0 ; Segment type: Pure code
.text$mn:0000FCA0 ; Segment permissions: Read/Execute
.text$mn:0000FCA0 _text$mn        segment para public 'CODE' use32
.text$mn:0000FCA0                 assume cs:_text$mn
.text$mn:0000FCA0                 ;org 0FCA0h
.text$mn:0000FCA0 ; COMDAT (pick any)
.text$mn:0000FCA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FCA0
.text$mn:0000FCA0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FCA0
.text$mn:0000FCA0 ; Attributes: bp-based frame
.text$mn:0000FCA0
.text$mn:0000FCA0 ; public: int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::compare(unsigned int, unsigned int, wchar_t const *, unsigned int)const
.text$mn:0000FCA0                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z
.text$mn:0000FCA0 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z proc near
.text$mn:0000FCA0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)+3Ap
.text$mn:0000FCA0
.text$mn:0000FCA0 var_18          = dword ptr -18h
.text$mn:0000FCA0 var_14          = dword ptr -14h
.text$mn:0000FCA0 var_10          = dword ptr -10h
.text$mn:0000FCA0 var_C           = dword ptr -0Ch
.text$mn:0000FCA0 var_8           = dword ptr -8
.text$mn:0000FCA0 var_4           = dword ptr -4
.text$mn:0000FCA0 arg_0           = dword ptr  8
.text$mn:0000FCA0 arg_4           = dword ptr  0Ch
.text$mn:0000FCA0 arg_8           = dword ptr  10h
.text$mn:0000FCA0 arg_C           = dword ptr  14h
.text$mn:0000FCA0
.text$mn:0000FCA0                 push    ebp
.text$mn:0000FCA1                 mov     ebp, esp
.text$mn:0000FCA3                 sub     esp, 18h
.text$mn:0000FCA6                 mov     [ebp+var_4], ecx
.text$mn:0000FCA9                 cmp     [ebp+arg_C], 0
.text$mn:0000FCAD                 jz      short loc_FCC5
.text$mn:0000FCAF                 push    87Dh            ; unsigned int
.text$mn:0000FCB4                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000FCB9                 mov     eax, [ebp+arg_8]
.text$mn:0000FCBC                 push    eax             ; int
.text$mn:0000FCBD                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000FCC2                 add     esp, 0Ch
.text$mn:0000FCC5
.text$mn:0000FCC5 loc_FCC5:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+Dj
.text$mn:0000FCC5                 mov     ecx, [ebp+var_4]
.text$mn:0000FCC8                 mov     edx, [ecx+14h]
.text$mn:0000FCCB                 cmp     edx, [ebp+arg_0]
.text$mn:0000FCCE                 jnb     short loc_FCD8
.text$mn:0000FCD0                 mov     ecx, [ebp+var_4]
.text$mn:0000FCD3                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000FCD8
.text$mn:0000FCD8 loc_FCD8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+2Ej
.text$mn:0000FCD8                 mov     eax, [ebp+var_4]
.text$mn:0000FCDB                 mov     ecx, [eax+14h]
.text$mn:0000FCDE                 sub     ecx, [ebp+arg_0]
.text$mn:0000FCE1                 cmp     ecx, [ebp+arg_4]
.text$mn:0000FCE4                 jnb     short loc_FCF2
.text$mn:0000FCE6                 mov     edx, [ebp+var_4]
.text$mn:0000FCE9                 mov     eax, [edx+14h]
.text$mn:0000FCEC                 sub     eax, [ebp+arg_0]
.text$mn:0000FCEF                 mov     [ebp+arg_4], eax
.text$mn:0000FCF2
.text$mn:0000FCF2 loc_FCF2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+44j
.text$mn:0000FCF2                 mov     ecx, [ebp+arg_4]
.text$mn:0000FCF5                 cmp     ecx, [ebp+arg_C]
.text$mn:0000FCF8                 jnb     short loc_FD02
.text$mn:0000FCFA                 mov     edx, [ebp+arg_4]
.text$mn:0000FCFD                 mov     [ebp+var_8], edx
.text$mn:0000FD00                 jmp     short loc_FD08
.text$mn:0000FD02 ; ---------------------------------------------------------------------------
.text$mn:0000FD02
.text$mn:0000FD02 loc_FD02:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+58j
.text$mn:0000FD02                 mov     eax, [ebp+arg_C]
.text$mn:0000FD05                 mov     [ebp+var_8], eax
.text$mn:0000FD08
.text$mn:0000FD08 loc_FD08:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+60j
.text$mn:0000FD08                 mov     ecx, [ebp+var_8]
.text$mn:0000FD0B                 push    ecx
.text$mn:0000FD0C                 mov     edx, [ebp+arg_8]
.text$mn:0000FD0F                 push    edx
.text$mn:0000FD10                 mov     ecx, [ebp+var_4]
.text$mn:0000FD13                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000FD18                 mov     ecx, [ebp+arg_0]
.text$mn:0000FD1B                 lea     edx, [eax+ecx*2]
.text$mn:0000FD1E                 push    edx
.text$mn:0000FD1F                 call    ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z ; std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)
.text$mn:0000FD24                 add     esp, 0Ch
.text$mn:0000FD27                 mov     [ebp+var_C], eax
.text$mn:0000FD2A                 cmp     [ebp+var_C], 0
.text$mn:0000FD2E                 jz      short loc_FD38
.text$mn:0000FD30                 mov     eax, [ebp+var_C]
.text$mn:0000FD33                 mov     [ebp+var_18], eax
.text$mn:0000FD36                 jmp     short loc_FD6D
.text$mn:0000FD38 ; ---------------------------------------------------------------------------
.text$mn:0000FD38
.text$mn:0000FD38 loc_FD38:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+8Ej
.text$mn:0000FD38                 mov     ecx, [ebp+arg_4]
.text$mn:0000FD3B                 cmp     ecx, [ebp+arg_C]
.text$mn:0000FD3E                 jnb     short loc_FD49
.text$mn:0000FD40                 mov     [ebp+var_14], 0FFFFFFFFh
.text$mn:0000FD47                 jmp     short loc_FD67
.text$mn:0000FD49 ; ---------------------------------------------------------------------------
.text$mn:0000FD49
.text$mn:0000FD49 loc_FD49:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+9Ej
.text$mn:0000FD49                 mov     edx, [ebp+arg_4]
.text$mn:0000FD4C                 cmp     edx, [ebp+arg_C]
.text$mn:0000FD4F                 jnz     short loc_FD5A
.text$mn:0000FD51                 mov     [ebp+var_10], 0
.text$mn:0000FD58                 jmp     short loc_FD61
.text$mn:0000FD5A ; ---------------------------------------------------------------------------
.text$mn:0000FD5A
.text$mn:0000FD5A loc_FD5A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+AFj
.text$mn:0000FD5A                 mov     [ebp+var_10], 1
.text$mn:0000FD61
.text$mn:0000FD61 loc_FD61:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+B8j
.text$mn:0000FD61                 mov     eax, [ebp+var_10]
.text$mn:0000FD64                 mov     [ebp+var_14], eax
.text$mn:0000FD67
.text$mn:0000FD67 loc_FD67:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+A7j
.text$mn:0000FD67                 mov     ecx, [ebp+var_14]
.text$mn:0000FD6A                 mov     [ebp+var_18], ecx
.text$mn:0000FD6D
.text$mn:0000FD6D loc_FD6D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+96j
.text$mn:0000FD6D                 mov     eax, [ebp+var_18]
.text$mn:0000FD70                 mov     esp, ebp
.text$mn:0000FD72                 pop     ebp
.text$mn:0000FD73                 retn    10h
.text$mn:0000FD73 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z endp
.text$mn:0000FD73
.text$mn:0000FD73 ; ---------------------------------------------------------------------------
.text$mn:0000FD76                 align 4
.text$mn:0000FD76 _text$mn        ends
.text$mn:0000FD76
.text$mn:0000FD78 ; ===========================================================================
.text$mn:0000FD78
.text$mn:0000FD78 ; Segment type: Pure code
.text$mn:0000FD78 ; Segment permissions: Read/Execute
.text$mn:0000FD78 _text$mn        segment para public 'CODE' use32
.text$mn:0000FD78                 assume cs:_text$mn
.text$mn:0000FD78                 ;org 0FD78h
.text$mn:0000FD78 ; COMDAT (pick any)
.text$mn:0000FD78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FD78
.text$mn:0000FD78 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FD78
.text$mn:0000FD78 ; Attributes: bp-based frame
.text$mn:0000FD78
.text$mn:0000FD78 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t *Str)
.text$mn:0000FD78                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z
.text$mn:0000FD78 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z proc near
.text$mn:0000FD78                                         ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+Bp
.text$mn:0000FD78
.text$mn:0000FD78 var_4           = dword ptr -4
.text$mn:0000FD78 Str             = dword ptr  8
.text$mn:0000FD78
.text$mn:0000FD78                 push    ebp
.text$mn:0000FD79                 mov     ebp, esp
.text$mn:0000FD7B                 push    ecx
.text$mn:0000FD7C                 mov     [ebp+var_4], ecx
.text$mn:0000FD7F                 push    86Eh            ; unsigned int
.text$mn:0000FD84                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000FD89                 mov     eax, [ebp+Str]
.text$mn:0000FD8C                 push    eax             ; int
.text$mn:0000FD8D                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000FD92                 add     esp, 0Ch
.text$mn:0000FD95                 mov     ecx, [ebp+Str]
.text$mn:0000FD98                 push    ecx             ; Str
.text$mn:0000FD99                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000FD9E                 add     esp, 4
.text$mn:0000FDA1                 push    eax
.text$mn:0000FDA2                 mov     edx, [ebp+Str]
.text$mn:0000FDA5                 push    edx
.text$mn:0000FDA6                 mov     eax, [ebp+var_4]
.text$mn:0000FDA9                 mov     ecx, [eax+14h]
.text$mn:0000FDAC                 push    ecx
.text$mn:0000FDAD                 push    0
.text$mn:0000FDAF                 mov     ecx, [ebp+var_4]
.text$mn:0000FDB2                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)
.text$mn:0000FDB7                 mov     esp, ebp
.text$mn:0000FDB9                 pop     ebp
.text$mn:0000FDBA                 retn    4
.text$mn:0000FDBA ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z endp
.text$mn:0000FDBA
.text$mn:0000FDBA ; ---------------------------------------------------------------------------
.text$mn:0000FDBD                 align 10h
.text$mn:0000FDBD _text$mn        ends
.text$mn:0000FDBD
.text$mn:0000FDC0 ; ===========================================================================
.text$mn:0000FDC0
.text$mn:0000FDC0 ; Segment type: Pure code
.text$mn:0000FDC0 ; Segment permissions: Read/Execute
.text$mn:0000FDC0 _text$mn        segment para public 'CODE' use32
.text$mn:0000FDC0                 assume cs:_text$mn
.text$mn:0000FDC0                 ;org 0FDC0h
.text$mn:0000FDC0 ; COMDAT (pick any)
.text$mn:0000FDC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FDC0
.text$mn:0000FDC0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FDC0
.text$mn:0000FDC0 ; Attributes: bp-based frame
.text$mn:0000FDC0
.text$mn:0000FDC0 ; public: static int __cdecl std::char_traits<wchar_t>::compare(wchar_t const *, wchar_t const *, unsigned int)
.text$mn:0000FDC0                 public ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z
.text$mn:0000FDC0 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z proc near
.text$mn:0000FDC0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+7Fp
.text$mn:0000FDC0
.text$mn:0000FDC0 var_4           = dword ptr -4
.text$mn:0000FDC0 arg_0           = dword ptr  8
.text$mn:0000FDC0 arg_4           = dword ptr  0Ch
.text$mn:0000FDC0 arg_8           = dword ptr  10h
.text$mn:0000FDC0
.text$mn:0000FDC0                 push    ebp
.text$mn:0000FDC1                 mov     ebp, esp
.text$mn:0000FDC3                 push    ecx
.text$mn:0000FDC4                 cmp     [ebp+arg_8], 0
.text$mn:0000FDC8                 jnz     short loc_FDD3
.text$mn:0000FDCA                 mov     [ebp+var_4], 0
.text$mn:0000FDD1                 jmp     short loc_FDEA
.text$mn:0000FDD3 ; ---------------------------------------------------------------------------
.text$mn:0000FDD3
.text$mn:0000FDD3 loc_FDD3:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+8j
.text$mn:0000FDD3                 mov     eax, [ebp+arg_8]
.text$mn:0000FDD6                 push    eax
.text$mn:0000FDD7                 mov     ecx, [ebp+arg_4]
.text$mn:0000FDDA                 push    ecx
.text$mn:0000FDDB                 mov     edx, [ebp+arg_0]
.text$mn:0000FDDE                 push    edx
.text$mn:0000FDDF                 call    _wmemcmp
.text$mn:0000FDE4                 add     esp, 0Ch
.text$mn:0000FDE7                 mov     [ebp+var_4], eax
.text$mn:0000FDEA
.text$mn:0000FDEA loc_FDEA:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+11j
.text$mn:0000FDEA                 mov     eax, [ebp+var_4]
.text$mn:0000FDED                 mov     esp, ebp
.text$mn:0000FDEF                 pop     ebp
.text$mn:0000FDF0                 retn
.text$mn:0000FDF0 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z endp
.text$mn:0000FDF0
.text$mn:0000FDF0 ; ---------------------------------------------------------------------------
.text$mn:0000FDF1                 align 4
.text$mn:0000FDF1 _text$mn        ends
.text$mn:0000FDF1
.text$mn:0000FDF4 ; ===========================================================================
.text$mn:0000FDF4
.text$mn:0000FDF4 ; Segment type: Pure code
.text$mn:0000FDF4 ; Segment permissions: Read/Execute
.text$mn:0000FDF4 _text$mn        segment para public 'CODE' use32
.text$mn:0000FDF4                 assume cs:_text$mn
.text$mn:0000FDF4                 ;org 0FDF4h
.text$mn:0000FDF4 ; COMDAT (pick any)
.text$mn:0000FDF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FDF4
.text$mn:0000FDF4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FDF4
.text$mn:0000FDF4 ; Attributes: bp-based frame
.text$mn:0000FDF4
.text$mn:0000FDF4 ; int __stdcall std::allocator<int>::construct(void *, int)
.text$mn:0000FDF4                 public ?construct@?$allocator@H@std@@QAEXPAHABH@Z
.text$mn:0000FDF4 ?construct@?$allocator@H@std@@QAEXPAHABH@Z proc near
.text$mn:0000FDF4                                         ; CODE XREF: std::allocator_traits<std::allocator<int>>::construct<int,int const &>(std::allocator<int> &,int *,int const &)+17p
.text$mn:0000FDF4
.text$mn:0000FDF4 var_C           = dword ptr -0Ch
.text$mn:0000FDF4 var_8           = dword ptr -8
.text$mn:0000FDF4 var_4           = dword ptr -4
.text$mn:0000FDF4 arg_0           = dword ptr  8
.text$mn:0000FDF4 arg_4           = dword ptr  0Ch
.text$mn:0000FDF4
.text$mn:0000FDF4                 push    ebp
.text$mn:0000FDF5                 mov     ebp, esp
.text$mn:0000FDF7                 sub     esp, 0Ch
.text$mn:0000FDFA                 mov     [ebp+var_C], ecx
.text$mn:0000FDFD                 mov     eax, [ebp+arg_0]
.text$mn:0000FE00                 push    eax             ; void *
.text$mn:0000FE01                 push    4               ; unsigned int
.text$mn:0000FE03                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000FE08                 add     esp, 8
.text$mn:0000FE0B                 mov     [ebp+var_4], eax
.text$mn:0000FE0E                 cmp     [ebp+var_4], 0
.text$mn:0000FE12                 jz      short loc_FE26
.text$mn:0000FE14                 mov     ecx, [ebp+var_4]
.text$mn:0000FE17                 mov     edx, [ebp+arg_4]
.text$mn:0000FE1A                 mov     eax, [edx]
.text$mn:0000FE1C                 mov     [ecx], eax
.text$mn:0000FE1E                 mov     ecx, [ebp+var_4]
.text$mn:0000FE21                 mov     [ebp+var_8], ecx
.text$mn:0000FE24                 jmp     short loc_FE2D
.text$mn:0000FE26 ; ---------------------------------------------------------------------------
.text$mn:0000FE26
.text$mn:0000FE26 loc_FE26:                               ; CODE XREF: std::allocator<int>::construct(int *,int const &)+1Ej
.text$mn:0000FE26                 mov     [ebp+var_8], 0
.text$mn:0000FE2D
.text$mn:0000FE2D loc_FE2D:                               ; CODE XREF: std::allocator<int>::construct(int *,int const &)+30j
.text$mn:0000FE2D                 mov     esp, ebp
.text$mn:0000FE2F                 pop     ebp
.text$mn:0000FE30                 retn    8
.text$mn:0000FE30 ?construct@?$allocator@H@std@@QAEXPAHABH@Z endp
.text$mn:0000FE30
.text$mn:0000FE30 ; ---------------------------------------------------------------------------
.text$mn:0000FE33                 align 4
.text$mn:0000FE33 _text$mn        ends
.text$mn:0000FE33
.text$mn:0000FE34 ; ===========================================================================
.text$mn:0000FE34
.text$mn:0000FE34 ; Segment type: Pure code
.text$mn:0000FE34 ; Segment permissions: Read/Execute
.text$mn:0000FE34 _text$mn        segment para public 'CODE' use32
.text$mn:0000FE34                 assume cs:_text$mn
.text$mn:0000FE34                 ;org 0FE34h
.text$mn:0000FE34 ; COMDAT (pick any)
.text$mn:0000FE34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FE34
.text$mn:0000FE34 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FE34
.text$mn:0000FE34 ; Attributes: bp-based frame
.text$mn:0000FE34
.text$mn:0000FE34 ; int __stdcall std::allocator<sessionFileInfo>::construct(void *, int)
.text$mn:0000FE34                 public ?construct@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@ABU3@@Z
.text$mn:0000FE34 ?construct@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@ABU3@@Z proc near
.text$mn:0000FE34                                         ; CODE XREF: std::allocator_traits<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo const &>(std::allocator<sessionFileInfo> &,sessionFileInfo *,sessionFileInfo const &)+17p
.text$mn:0000FE34
.text$mn:0000FE34 var_1C          = dword ptr -1Ch
.text$mn:0000FE34 var_18          = dword ptr -18h
.text$mn:0000FE34 var_14          = dword ptr -14h
.text$mn:0000FE34 var_10          = dword ptr -10h
.text$mn:0000FE34 var_C           = dword ptr -0Ch
.text$mn:0000FE34 var_4           = dword ptr -4
.text$mn:0000FE34 arg_0           = dword ptr  8
.text$mn:0000FE34 arg_4           = dword ptr  0Ch
.text$mn:0000FE34
.text$mn:0000FE34                 push    ebp
.text$mn:0000FE35                 mov     ebp, esp
.text$mn:0000FE37                 push    0FFFFFFFFh
.text$mn:0000FE39                 push    offset __ehhandler$?construct@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@ABU3@@Z
.text$mn:0000FE3E                 mov     eax, large fs:0
.text$mn:0000FE44                 push    eax
.text$mn:0000FE45                 sub     esp, 10h
.text$mn:0000FE48                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000FE4D                 xor     eax, ebp
.text$mn:0000FE4F                 push    eax
.text$mn:0000FE50                 lea     eax, [ebp+var_C]
.text$mn:0000FE53                 mov     large fs:0, eax
.text$mn:0000FE59                 mov     [ebp+var_18], ecx
.text$mn:0000FE5C                 mov     eax, [ebp+arg_0]
.text$mn:0000FE5F                 push    eax             ; void *
.text$mn:0000FE60                 push    98h ; 'ÿ'       ; unsigned int
.text$mn:0000FE65                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000FE6A                 add     esp, 8
.text$mn:0000FE6D                 mov     [ebp+var_10], eax
.text$mn:0000FE70                 mov     [ebp+var_4], 0
.text$mn:0000FE77                 cmp     [ebp+var_10], 0
.text$mn:0000FE7B                 jz      short loc_FE8E
.text$mn:0000FE7D                 mov     ecx, [ebp+arg_4]
.text$mn:0000FE80                 push    ecx
.text$mn:0000FE81                 mov     ecx, [ebp+var_10]
.text$mn:0000FE84                 call    ??0sessionFileInfo@@QAE@ABU0@@Z ; sessionFileInfo::sessionFileInfo(sessionFileInfo const &)
.text$mn:0000FE89                 mov     [ebp+var_14], eax
.text$mn:0000FE8C                 jmp     short loc_FE95
.text$mn:0000FE8E ; ---------------------------------------------------------------------------
.text$mn:0000FE8E
.text$mn:0000FE8E loc_FE8E:                               ; CODE XREF: std::allocator<sessionFileInfo>::construct(sessionFileInfo *,sessionFileInfo const &)+47j
.text$mn:0000FE8E                 mov     [ebp+var_14], 0
.text$mn:0000FE95
.text$mn:0000FE95 loc_FE95:                               ; CODE XREF: std::allocator<sessionFileInfo>::construct(sessionFileInfo *,sessionFileInfo const &)+58j
.text$mn:0000FE95                 mov     edx, [ebp+var_14]
.text$mn:0000FE98                 mov     [ebp+var_1C], edx
.text$mn:0000FE9B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000FEA2                 mov     ecx, [ebp+var_C]
.text$mn:0000FEA5                 mov     large fs:0, ecx
.text$mn:0000FEAC                 pop     ecx
.text$mn:0000FEAD                 mov     esp, ebp
.text$mn:0000FEAF                 pop     ebp
.text$mn:0000FEB0                 retn    8
.text$mn:0000FEB0 ?construct@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@ABU3@@Z endp
.text$mn:0000FEB0
.text$mn:0000FEB0 ; ---------------------------------------------------------------------------
.text$mn:0000FEB3                 align 4
.text$mn:0000FEB3 _text$mn        ends
.text$mn:0000FEB3
.text$x:0000FEB4 ; ===========================================================================
.text$x:0000FEB4
.text$x:0000FEB4 ; Segment type: Pure code
.text$x:0000FEB4 ; Segment permissions: Read/Execute
.text$x:0000FEB4 _text$x         segment para public 'CODE' use32
.text$x:0000FEB4                 assume cs:_text$x
.text$x:0000FEB4                 ;org 0FEB4h
.text$x:0000FEB4 ; COMDAT (pick associative to section at FE34)
.text$x:0000FEB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000FEB4
.text$x:0000FEB4 ; =============== S U B R O U T I N E =======================================
.text$x:0000FEB4
.text$x:0000FEB4
.text$x:0000FEB4 __unwindfunclet$?construct@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@ABU3@@Z$0 proc near
.text$x:0000FEB4                                         ; DATA XREF: .xdata$x:00013030o
.text$x:0000FEB4                 mov     eax, [ebp+8]
.text$x:0000FEB7                 push    eax
.text$x:0000FEB8                 mov     eax, [ebp-10h]
.text$x:0000FEBB                 push    eax             ; void *
.text$x:0000FEBC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000FEC1                 add     esp, 8
.text$x:0000FEC4                 retn
.text$x:0000FEC4 __unwindfunclet$?construct@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@ABU3@@Z$0 endp
.text$x:0000FEC4
.text$x:0000FEC5
.text$x:0000FEC5 ; =============== S U B R O U T I N E =======================================
.text$x:0000FEC5
.text$x:0000FEC5
.text$x:0000FEC5 __ehhandler$?construct@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@ABU3@@Z proc near
.text$x:0000FEC5                                         ; DATA XREF: std::allocator<sessionFileInfo>::construct(sessionFileInfo *,sessionFileInfo const &)+5o
.text$x:0000FEC5
.text$x:0000FEC5 arg_4           = dword ptr  8
.text$x:0000FEC5
.text$x:0000FEC5                 mov     edx, [esp+arg_4]
.text$x:0000FEC9                 lea     eax, [edx+0Ch]
.text$x:0000FECC                 mov     ecx, [edx-14h]
.text$x:0000FECF                 xor     ecx, eax
.text$x:0000FED1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000FED6                 mov     eax, offset __ehfuncinfo$?construct@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@ABU3@@Z
.text$x:0000FEDB                 jmp     ___CxxFrameHandler3
.text$x:0000FEDB __ehhandler$?construct@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@ABU3@@Z endp
.text$x:0000FEDB
.text$x:0000FEDB _text$x         ends
.text$x:0000FEDB
.text$mn:0000FEE0 ; ===========================================================================
.text$mn:0000FEE0
.text$mn:0000FEE0 ; Segment type: Pure code
.text$mn:0000FEE0 ; Segment permissions: Read/Execute
.text$mn:0000FEE0 _text$mn        segment para public 'CODE' use32
.text$mn:0000FEE0                 assume cs:_text$mn
.text$mn:0000FEE0                 ;org 0FEE0h
.text$mn:0000FEE0 ; COMDAT (pick any)
.text$mn:0000FEE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FEE0
.text$mn:0000FEE0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FEE0
.text$mn:0000FEE0 ; Attributes: bp-based frame
.text$mn:0000FEE0
.text$mn:0000FEE0 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:0000FEE0                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:0000FEE0 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:0000FEE0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:0000FEE0
.text$mn:0000FEE0 var_4           = dword ptr -4
.text$mn:0000FEE0 Dst             = dword ptr  8
.text$mn:0000FEE0 Src             = dword ptr  0Ch
.text$mn:0000FEE0 Size            = dword ptr  10h
.text$mn:0000FEE0
.text$mn:0000FEE0                 push    ebp
.text$mn:0000FEE1                 mov     ebp, esp
.text$mn:0000FEE3                 push    ecx
.text$mn:0000FEE4                 cmp     [ebp+Size], 0
.text$mn:0000FEE8                 jnz     short loc_FEF2
.text$mn:0000FEEA                 mov     eax, [ebp+Dst]
.text$mn:0000FEED                 mov     [ebp+var_4], eax
.text$mn:0000FEF0                 jmp     short loc_FF09
.text$mn:0000FEF2 ; ---------------------------------------------------------------------------
.text$mn:0000FEF2
.text$mn:0000FEF2 loc_FEF2:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:0000FEF2                 mov     ecx, [ebp+Size]
.text$mn:0000FEF5                 push    ecx             ; Size
.text$mn:0000FEF6                 mov     edx, [ebp+Src]
.text$mn:0000FEF9                 push    edx             ; Src
.text$mn:0000FEFA                 mov     eax, [ebp+Dst]
.text$mn:0000FEFD                 push    eax             ; Dst
.text$mn:0000FEFE                 call    _memcpy
.text$mn:0000FF03                 add     esp, 0Ch
.text$mn:0000FF06                 mov     [ebp+var_4], eax
.text$mn:0000FF09
.text$mn:0000FF09 loc_FF09:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:0000FF09                 mov     eax, [ebp+var_4]
.text$mn:0000FF0C                 mov     esp, ebp
.text$mn:0000FF0E                 pop     ebp
.text$mn:0000FF0F                 retn
.text$mn:0000FF0F ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000FF0F
.text$mn:0000FF0F _text$mn        ends
.text$mn:0000FF0F
.text$mn:0000FF10 ; ===========================================================================
.text$mn:0000FF10
.text$mn:0000FF10 ; Segment type: Pure code
.text$mn:0000FF10 ; Segment permissions: Read/Execute
.text$mn:0000FF10 _text$mn        segment para public 'CODE' use32
.text$mn:0000FF10                 assume cs:_text$mn
.text$mn:0000FF10                 ;org 0FF10h
.text$mn:0000FF10 ; COMDAT (pick any)
.text$mn:0000FF10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FF10
.text$mn:0000FF10 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FF10
.text$mn:0000FF10 ; Attributes: bp-based frame
.text$mn:0000FF10
.text$mn:0000FF10 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:0000FF10                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:0000FF10 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:0000FF10                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:0000FF10                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:0000FF10
.text$mn:0000FF10 var_4           = dword ptr -4
.text$mn:0000FF10 Dst             = dword ptr  8
.text$mn:0000FF10 Src             = dword ptr  0Ch
.text$mn:0000FF10 arg_8           = dword ptr  10h
.text$mn:0000FF10
.text$mn:0000FF10                 push    ebp
.text$mn:0000FF11                 mov     ebp, esp
.text$mn:0000FF13                 push    ecx
.text$mn:0000FF14                 cmp     [ebp+arg_8], 0
.text$mn:0000FF18                 jnz     short loc_FF22
.text$mn:0000FF1A                 mov     eax, [ebp+Dst]
.text$mn:0000FF1D                 mov     [ebp+var_4], eax
.text$mn:0000FF20                 jmp     short loc_FF39
.text$mn:0000FF22 ; ---------------------------------------------------------------------------
.text$mn:0000FF22
.text$mn:0000FF22 loc_FF22:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:0000FF22                 mov     ecx, [ebp+arg_8]
.text$mn:0000FF25                 push    ecx             ; int
.text$mn:0000FF26                 mov     edx, [ebp+Src]
.text$mn:0000FF29                 push    edx             ; Src
.text$mn:0000FF2A                 mov     eax, [ebp+Dst]
.text$mn:0000FF2D                 push    eax             ; Dst
.text$mn:0000FF2E                 call    _wmemcpy
.text$mn:0000FF33                 add     esp, 0Ch
.text$mn:0000FF36                 mov     [ebp+var_4], eax
.text$mn:0000FF39
.text$mn:0000FF39 loc_FF39:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:0000FF39                 mov     eax, [ebp+var_4]
.text$mn:0000FF3C                 mov     esp, ebp
.text$mn:0000FF3E                 pop     ebp
.text$mn:0000FF3F                 retn
.text$mn:0000FF3F ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000FF3F
.text$mn:0000FF3F _text$mn        ends
.text$mn:0000FF3F
.text$mn:0000FF40 ; ===========================================================================
.text$mn:0000FF40
.text$mn:0000FF40 ; Segment type: Pure code
.text$mn:0000FF40 ; Segment permissions: Read/Execute
.text$mn:0000FF40 _text$mn        segment para public 'CODE' use32
.text$mn:0000FF40                 assume cs:_text$mn
.text$mn:0000FF40                 ;org 0FF40h
.text$mn:0000FF40 ; COMDAT (pick any)
.text$mn:0000FF40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FF40
.text$mn:0000FF40 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FF40
.text$mn:0000FF40 ; Attributes: bp-based frame
.text$mn:0000FF40
.text$mn:0000FF40 ; int __thiscall Notepad_plus::currentView(Notepad_plus *__hidden this)
.text$mn:0000FF40                 public ?currentView@Notepad_plus@@AAEHXZ
.text$mn:0000FF40 ?currentView@Notepad_plus@@AAEHXZ proc near
.text$mn:0000FF40                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+75Dp
.text$mn:0000FF40                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+854p ...
.text$mn:0000FF40
.text$mn:0000FF40 var_4           = dword ptr -4
.text$mn:0000FF40
.text$mn:0000FF40                 push    ebp
.text$mn:0000FF41                 mov     ebp, esp
.text$mn:0000FF43                 push    ecx
.text$mn:0000FF44                 mov     [ebp+var_4], ecx
.text$mn:0000FF47                 mov     eax, [ebp+var_4]
.text$mn:0000FF4A                 mov     eax, [eax+551C8h]
.text$mn:0000FF50                 mov     esp, ebp
.text$mn:0000FF52                 pop     ebp
.text$mn:0000FF53                 retn
.text$mn:0000FF53 ?currentView@Notepad_plus@@AAEHXZ endp
.text$mn:0000FF53
.text$mn:0000FF53 _text$mn        ends
.text$mn:0000FF53
.text$mn:0000FF54 ; ===========================================================================
.text$mn:0000FF54
.text$mn:0000FF54 ; Segment type: Pure code
.text$mn:0000FF54 ; Segment permissions: Read/Execute
.text$mn:0000FF54 _text$mn        segment para public 'CODE' use32
.text$mn:0000FF54                 assume cs:_text$mn
.text$mn:0000FF54                 ;org 0FF54h
.text$mn:0000FF54 ; COMDAT (pick any)
.text$mn:0000FF54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FF54
.text$mn:0000FF54 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FF54
.text$mn:0000FF54 ; Attributes: bp-based frame
.text$mn:0000FF54
.text$mn:0000FF54 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:0000FF54                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:0000FF54 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:0000FF54                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:0000FF54
.text$mn:0000FF54 var_4           = dword ptr -4
.text$mn:0000FF54 arg_0           = dword ptr  8
.text$mn:0000FF54 arg_4           = dword ptr  0Ch
.text$mn:0000FF54
.text$mn:0000FF54                 push    ebp
.text$mn:0000FF55                 mov     ebp, esp
.text$mn:0000FF57                 push    ecx
.text$mn:0000FF58                 mov     [ebp+var_4], ecx
.text$mn:0000FF5B                 mov     eax, [ebp+arg_4]
.text$mn:0000FF5E                 push    eax             ; int
.text$mn:0000FF5F                 mov     ecx, [ebp+arg_0]
.text$mn:0000FF62                 push    ecx             ; void *
.text$mn:0000FF63                 mov     ecx, [ebp+var_4]
.text$mn:0000FF66                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000FF6B                 mov     esp, ebp
.text$mn:0000FF6D                 pop     ebp
.text$mn:0000FF6E                 retn    8
.text$mn:0000FF6E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000FF6E
.text$mn:0000FF6E ; ---------------------------------------------------------------------------
.text$mn:0000FF71                 align 4
.text$mn:0000FF71 _text$mn        ends
.text$mn:0000FF71
.text$mn:0000FF74 ; ===========================================================================
.text$mn:0000FF74
.text$mn:0000FF74 ; Segment type: Pure code
.text$mn:0000FF74 ; Segment permissions: Read/Execute
.text$mn:0000FF74 _text$mn        segment para public 'CODE' use32
.text$mn:0000FF74                 assume cs:_text$mn
.text$mn:0000FF74                 ;org 0FF74h
.text$mn:0000FF74 ; COMDAT (pick any)
.text$mn:0000FF74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FF74
.text$mn:0000FF74 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FF74
.text$mn:0000FF74 ; Attributes: bp-based frame
.text$mn:0000FF74
.text$mn:0000FF74 ; int __stdcall std::_Wrap_alloc<std::allocator<int>>::deallocate(void *, int)
.text$mn:0000FF74                 public ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z
.text$mn:0000FF74 ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z proc near
.text$mn:0000FF74                                         ; CODE XREF: __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0+16p
.text$mn:0000FF74                                         ; std::vector<int,std::allocator<int>>::_Reallocate(uint)+F5p ...
.text$mn:0000FF74
.text$mn:0000FF74 var_4           = dword ptr -4
.text$mn:0000FF74 arg_0           = dword ptr  8
.text$mn:0000FF74 arg_4           = dword ptr  0Ch
.text$mn:0000FF74
.text$mn:0000FF74                 push    ebp
.text$mn:0000FF75                 mov     ebp, esp
.text$mn:0000FF77                 push    ecx
.text$mn:0000FF78                 mov     [ebp+var_4], ecx
.text$mn:0000FF7B                 mov     eax, [ebp+arg_4]
.text$mn:0000FF7E                 push    eax             ; int
.text$mn:0000FF7F                 mov     ecx, [ebp+arg_0]
.text$mn:0000FF82                 push    ecx             ; void *
.text$mn:0000FF83                 mov     ecx, [ebp+var_4]
.text$mn:0000FF86                 call    ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate(int *,uint)
.text$mn:0000FF8B                 mov     esp, ebp
.text$mn:0000FF8D                 pop     ebp
.text$mn:0000FF8E                 retn    8
.text$mn:0000FF8E ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z endp
.text$mn:0000FF8E
.text$mn:0000FF8E ; ---------------------------------------------------------------------------
.text$mn:0000FF91                 align 4
.text$mn:0000FF91 _text$mn        ends
.text$mn:0000FF91
.text$mn:0000FF94 ; ===========================================================================
.text$mn:0000FF94
.text$mn:0000FF94 ; Segment type: Pure code
.text$mn:0000FF94 ; Segment permissions: Read/Execute
.text$mn:0000FF94 _text$mn        segment para public 'CODE' use32
.text$mn:0000FF94                 assume cs:_text$mn
.text$mn:0000FF94                 ;org 0FF94h
.text$mn:0000FF94 ; COMDAT (pick any)
.text$mn:0000FF94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FF94
.text$mn:0000FF94 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FF94
.text$mn:0000FF94 ; Attributes: bp-based frame
.text$mn:0000FF94
.text$mn:0000FF94 ; int __stdcall std::_Wrap_alloc<std::allocator<unsigned int>>::deallocate(void *, int)
.text$mn:0000FF94                 public ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z
.text$mn:0000FF94 ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z proc near
.text$mn:0000FF94                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+1BBp
.text$mn:0000FF94                                         ; std::vector<uint,std::allocator<uint>>::_Tidy(void)+55p
.text$mn:0000FF94
.text$mn:0000FF94 var_4           = dword ptr -4
.text$mn:0000FF94 arg_0           = dword ptr  8
.text$mn:0000FF94 arg_4           = dword ptr  0Ch
.text$mn:0000FF94
.text$mn:0000FF94                 push    ebp
.text$mn:0000FF95                 mov     ebp, esp
.text$mn:0000FF97                 push    ecx
.text$mn:0000FF98                 mov     [ebp+var_4], ecx
.text$mn:0000FF9B                 mov     eax, [ebp+arg_4]
.text$mn:0000FF9E                 push    eax             ; int
.text$mn:0000FF9F                 mov     ecx, [ebp+arg_0]
.text$mn:0000FFA2                 push    ecx             ; void *
.text$mn:0000FFA3                 mov     ecx, [ebp+var_4]
.text$mn:0000FFA6                 call    ?deallocate@?$allocator@I@std@@QAEXPAII@Z ; std::allocator<uint>::deallocate(uint *,uint)
.text$mn:0000FFAB                 mov     esp, ebp
.text$mn:0000FFAD                 pop     ebp
.text$mn:0000FFAE                 retn    8
.text$mn:0000FFAE ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z endp
.text$mn:0000FFAE
.text$mn:0000FFAE ; ---------------------------------------------------------------------------
.text$mn:0000FFB1                 align 4
.text$mn:0000FFB1 _text$mn        ends
.text$mn:0000FFB1
.text$mn:0000FFB4 ; ===========================================================================
.text$mn:0000FFB4
.text$mn:0000FFB4 ; Segment type: Pure code
.text$mn:0000FFB4 ; Segment permissions: Read/Execute
.text$mn:0000FFB4 _text$mn        segment para public 'CODE' use32
.text$mn:0000FFB4                 assume cs:_text$mn
.text$mn:0000FFB4                 ;org 0FFB4h
.text$mn:0000FFB4 ; COMDAT (pick any)
.text$mn:0000FFB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FFB4
.text$mn:0000FFB4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FFB4
.text$mn:0000FFB4 ; Attributes: bp-based frame
.text$mn:0000FFB4
.text$mn:0000FFB4 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:0000FFB4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000FFB4 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000FFB4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Free_proxy(void)+32p
.text$mn:0000FFB4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Free_proxy(void)+32p ...
.text$mn:0000FFB4
.text$mn:0000FFB4 var_4           = dword ptr -4
.text$mn:0000FFB4 arg_0           = dword ptr  8
.text$mn:0000FFB4 arg_4           = dword ptr  0Ch
.text$mn:0000FFB4
.text$mn:0000FFB4                 push    ebp
.text$mn:0000FFB5                 mov     ebp, esp
.text$mn:0000FFB7                 push    ecx
.text$mn:0000FFB8                 mov     [ebp+var_4], ecx
.text$mn:0000FFBB                 mov     eax, [ebp+arg_4]
.text$mn:0000FFBE                 push    eax             ; int
.text$mn:0000FFBF                 mov     ecx, [ebp+arg_0]
.text$mn:0000FFC2                 push    ecx             ; void *
.text$mn:0000FFC3                 mov     ecx, [ebp+var_4]
.text$mn:0000FFC6                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000FFCB                 mov     esp, ebp
.text$mn:0000FFCD                 pop     ebp
.text$mn:0000FFCE                 retn    8
.text$mn:0000FFCE ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000FFCE
.text$mn:0000FFCE ; ---------------------------------------------------------------------------
.text$mn:0000FFD1                 align 4
.text$mn:0000FFD1 _text$mn        ends
.text$mn:0000FFD1
.text$mn:0000FFD4 ; ===========================================================================
.text$mn:0000FFD4
.text$mn:0000FFD4 ; Segment type: Pure code
.text$mn:0000FFD4 ; Segment permissions: Read/Execute
.text$mn:0000FFD4 _text$mn        segment para public 'CODE' use32
.text$mn:0000FFD4                 assume cs:_text$mn
.text$mn:0000FFD4                 ;org 0FFD4h
.text$mn:0000FFD4 ; COMDAT (pick any)
.text$mn:0000FFD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FFD4
.text$mn:0000FFD4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FFD4
.text$mn:0000FFD4 ; Attributes: bp-based frame
.text$mn:0000FFD4
.text$mn:0000FFD4 ; int __stdcall std::_Wrap_alloc<std::allocator<sessionFileInfo>>::deallocate(void *, int)
.text$mn:0000FFD4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@I@Z
.text$mn:0000FFD4 ?deallocate@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@I@Z proc near
.text$mn:0000FFD4                                         ; CODE XREF: __catch$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:0000FFD4                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reallocate(uint)+FAp ...
.text$mn:0000FFD4
.text$mn:0000FFD4 var_4           = dword ptr -4
.text$mn:0000FFD4 arg_0           = dword ptr  8
.text$mn:0000FFD4 arg_4           = dword ptr  0Ch
.text$mn:0000FFD4
.text$mn:0000FFD4                 push    ebp
.text$mn:0000FFD5                 mov     ebp, esp
.text$mn:0000FFD7                 push    ecx
.text$mn:0000FFD8                 mov     [ebp+var_4], ecx
.text$mn:0000FFDB                 mov     eax, [ebp+arg_4]
.text$mn:0000FFDE                 push    eax             ; int
.text$mn:0000FFDF                 mov     ecx, [ebp+arg_0]
.text$mn:0000FFE2                 push    ecx             ; void *
.text$mn:0000FFE3                 mov     ecx, [ebp+var_4]
.text$mn:0000FFE6                 call    ?deallocate@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@I@Z ; std::allocator<sessionFileInfo>::deallocate(sessionFileInfo *,uint)
.text$mn:0000FFEB                 mov     esp, ebp
.text$mn:0000FFED                 pop     ebp
.text$mn:0000FFEE                 retn    8
.text$mn:0000FFEE ?deallocate@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@I@Z endp
.text$mn:0000FFEE
.text$mn:0000FFEE ; ---------------------------------------------------------------------------
.text$mn:0000FFF1                 align 4
.text$mn:0000FFF1 _text$mn        ends
.text$mn:0000FFF1
.text$mn:0000FFF4 ; ===========================================================================
.text$mn:0000FFF4
.text$mn:0000FFF4 ; Segment type: Pure code
.text$mn:0000FFF4 ; Segment permissions: Read/Execute
.text$mn:0000FFF4 _text$mn        segment para public 'CODE' use32
.text$mn:0000FFF4                 assume cs:_text$mn
.text$mn:0000FFF4                 ;org 0FFF4h
.text$mn:0000FFF4 ; COMDAT (pick any)
.text$mn:0000FFF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000FFF4
.text$mn:0000FFF4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000FFF4
.text$mn:0000FFF4 ; Attributes: bp-based frame
.text$mn:0000FFF4
.text$mn:0000FFF4 ; int __stdcall std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::deallocate(void *, int)
.text$mn:0000FFF4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:0000FFF4 ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$mn:0000FFF4                                         ; CODE XREF: __catch$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$0+16p
.text$mn:0000FFF4                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+FAp ...
.text$mn:0000FFF4
.text$mn:0000FFF4 var_4           = dword ptr -4
.text$mn:0000FFF4 arg_0           = dword ptr  8
.text$mn:0000FFF4 arg_4           = dword ptr  0Ch
.text$mn:0000FFF4
.text$mn:0000FFF4                 push    ebp
.text$mn:0000FFF5                 mov     ebp, esp
.text$mn:0000FFF7                 push    ecx
.text$mn:0000FFF8                 mov     [ebp+var_4], ecx
.text$mn:0000FFFB                 mov     eax, [ebp+arg_4]
.text$mn:0000FFFE                 push    eax             ; int
.text$mn:0000FFFF                 mov     ecx, [ebp+arg_0]
.text$mn:00010002                 push    ecx             ; void *
.text$mn:00010003                 mov     ecx, [ebp+var_4]
.text$mn:00010006                 call    ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::deallocate(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,uint)
.text$mn:0001000B                 mov     esp, ebp
.text$mn:0001000D                 pop     ebp
.text$mn:0001000E                 retn    8
.text$mn:0001000E ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp
.text$mn:0001000E
.text$mn:0001000E ; ---------------------------------------------------------------------------
.text$mn:00010011                 align 4
.text$mn:00010011 _text$mn        ends
.text$mn:00010011
.text$mn:00010014 ; ===========================================================================
.text$mn:00010014
.text$mn:00010014 ; Segment type: Pure code
.text$mn:00010014 ; Segment permissions: Read/Execute
.text$mn:00010014 _text$mn        segment para public 'CODE' use32
.text$mn:00010014                 assume cs:_text$mn
.text$mn:00010014                 ;org 10014h
.text$mn:00010014 ; COMDAT (pick any)
.text$mn:00010014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010014
.text$mn:00010014 ; =============== S U B R O U T I N E =======================================
.text$mn:00010014
.text$mn:00010014 ; Attributes: bp-based frame
.text$mn:00010014
.text$mn:00010014 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:00010014                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:00010014 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:00010014                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:00010014
.text$mn:00010014 var_4           = dword ptr -4
.text$mn:00010014 arg_0           = dword ptr  8
.text$mn:00010014 arg_4           = dword ptr  0Ch
.text$mn:00010014
.text$mn:00010014                 push    ebp
.text$mn:00010015                 mov     ebp, esp
.text$mn:00010017                 push    ecx
.text$mn:00010018                 mov     [ebp+var_4], ecx
.text$mn:0001001B                 mov     eax, [ebp+arg_4]
.text$mn:0001001E                 push    eax             ; int
.text$mn:0001001F                 mov     ecx, [ebp+arg_0]
.text$mn:00010022                 push    ecx             ; void *
.text$mn:00010023                 mov     ecx, [ebp+var_4]
.text$mn:00010026                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:0001002B                 mov     esp, ebp
.text$mn:0001002D                 pop     ebp
.text$mn:0001002E                 retn    8
.text$mn:0001002E ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:0001002E
.text$mn:0001002E ; ---------------------------------------------------------------------------
.text$mn:00010031                 align 4
.text$mn:00010031 _text$mn        ends
.text$mn:00010031
.text$mn:00010034 ; ===========================================================================
.text$mn:00010034
.text$mn:00010034 ; Segment type: Pure code
.text$mn:00010034 ; Segment permissions: Read/Execute
.text$mn:00010034 _text$mn        segment para public 'CODE' use32
.text$mn:00010034                 assume cs:_text$mn
.text$mn:00010034                 ;org 10034h
.text$mn:00010034 ; COMDAT (pick any)
.text$mn:00010034                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010034
.text$mn:00010034 ; =============== S U B R O U T I N E =======================================
.text$mn:00010034
.text$mn:00010034 ; Attributes: bp-based frame
.text$mn:00010034
.text$mn:00010034 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00010034                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00010034 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00010034                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00010034
.text$mn:00010034 var_4           = dword ptr -4
.text$mn:00010034 arg_0           = dword ptr  8
.text$mn:00010034
.text$mn:00010034                 push    ebp
.text$mn:00010035                 mov     ebp, esp
.text$mn:00010037                 push    ecx
.text$mn:00010038                 mov     [ebp+var_4], ecx
.text$mn:0001003B                 mov     eax, [ebp+arg_0]
.text$mn:0001003E                 push    eax             ; void *
.text$mn:0001003F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00010044                 add     esp, 4
.text$mn:00010047                 mov     esp, ebp
.text$mn:00010049                 pop     ebp
.text$mn:0001004A                 retn    8
.text$mn:0001004A ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0001004A
.text$mn:0001004A ; ---------------------------------------------------------------------------
.text$mn:0001004D                 align 10h
.text$mn:0001004D _text$mn        ends
.text$mn:0001004D
.text$mn:00010050 ; ===========================================================================
.text$mn:00010050
.text$mn:00010050 ; Segment type: Pure code
.text$mn:00010050 ; Segment permissions: Read/Execute
.text$mn:00010050 _text$mn        segment para public 'CODE' use32
.text$mn:00010050                 assume cs:_text$mn
.text$mn:00010050                 ;org 10050h
.text$mn:00010050 ; COMDAT (pick any)
.text$mn:00010050                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010050
.text$mn:00010050 ; =============== S U B R O U T I N E =======================================
.text$mn:00010050
.text$mn:00010050 ; Attributes: bp-based frame
.text$mn:00010050
.text$mn:00010050 ; int __stdcall std::allocator<int>::deallocate(void *, int)
.text$mn:00010050                 public ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
.text$mn:00010050 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z proc near
.text$mn:00010050                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::deallocate(int *,uint)+12p
.text$mn:00010050
.text$mn:00010050 var_4           = dword ptr -4
.text$mn:00010050 arg_0           = dword ptr  8
.text$mn:00010050
.text$mn:00010050                 push    ebp
.text$mn:00010051                 mov     ebp, esp
.text$mn:00010053                 push    ecx
.text$mn:00010054                 mov     [ebp+var_4], ecx
.text$mn:00010057                 mov     eax, [ebp+arg_0]
.text$mn:0001005A                 push    eax             ; void *
.text$mn:0001005B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00010060                 add     esp, 4
.text$mn:00010063                 mov     esp, ebp
.text$mn:00010065                 pop     ebp
.text$mn:00010066                 retn    8
.text$mn:00010066 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z endp
.text$mn:00010066
.text$mn:00010066 ; ---------------------------------------------------------------------------
.text$mn:00010069                 align 4
.text$mn:00010069 _text$mn        ends
.text$mn:00010069
.text$mn:0001006C ; ===========================================================================
.text$mn:0001006C
.text$mn:0001006C ; Segment type: Pure code
.text$mn:0001006C ; Segment permissions: Read/Execute
.text$mn:0001006C _text$mn        segment para public 'CODE' use32
.text$mn:0001006C                 assume cs:_text$mn
.text$mn:0001006C                 ;org 1006Ch
.text$mn:0001006C ; COMDAT (pick any)
.text$mn:0001006C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0001006C
.text$mn:0001006C ; =============== S U B R O U T I N E =======================================
.text$mn:0001006C
.text$mn:0001006C ; Attributes: bp-based frame
.text$mn:0001006C
.text$mn:0001006C ; int __stdcall std::allocator<unsigned int>::deallocate(void *, int)
.text$mn:0001006C                 public ?deallocate@?$allocator@I@std@@QAEXPAII@Z
.text$mn:0001006C ?deallocate@?$allocator@I@std@@QAEXPAII@Z proc near
.text$mn:0001006C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::deallocate(uint *,uint)+12p
.text$mn:0001006C
.text$mn:0001006C var_4           = dword ptr -4
.text$mn:0001006C arg_0           = dword ptr  8
.text$mn:0001006C
.text$mn:0001006C                 push    ebp
.text$mn:0001006D                 mov     ebp, esp
.text$mn:0001006F                 push    ecx
.text$mn:00010070                 mov     [ebp+var_4], ecx
.text$mn:00010073                 mov     eax, [ebp+arg_0]
.text$mn:00010076                 push    eax             ; void *
.text$mn:00010077                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0001007C                 add     esp, 4
.text$mn:0001007F                 mov     esp, ebp
.text$mn:00010081                 pop     ebp
.text$mn:00010082                 retn    8
.text$mn:00010082 ?deallocate@?$allocator@I@std@@QAEXPAII@Z endp
.text$mn:00010082
.text$mn:00010082 ; ---------------------------------------------------------------------------
.text$mn:00010085                 align 4
.text$mn:00010085 _text$mn        ends
.text$mn:00010085
.text$mn:00010088 ; ===========================================================================
.text$mn:00010088
.text$mn:00010088 ; Segment type: Pure code
.text$mn:00010088 ; Segment permissions: Read/Execute
.text$mn:00010088 _text$mn        segment para public 'CODE' use32
.text$mn:00010088                 assume cs:_text$mn
.text$mn:00010088                 ;org 10088h
.text$mn:00010088 ; COMDAT (pick any)
.text$mn:00010088                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010088
.text$mn:00010088 ; =============== S U B R O U T I N E =======================================
.text$mn:00010088
.text$mn:00010088 ; Attributes: bp-based frame
.text$mn:00010088
.text$mn:00010088 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00010088                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00010088 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00010088                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00010088                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p ...
.text$mn:00010088
.text$mn:00010088 var_4           = dword ptr -4
.text$mn:00010088 arg_0           = dword ptr  8
.text$mn:00010088
.text$mn:00010088                 push    ebp
.text$mn:00010089                 mov     ebp, esp
.text$mn:0001008B                 push    ecx
.text$mn:0001008C                 mov     [ebp+var_4], ecx
.text$mn:0001008F                 mov     eax, [ebp+arg_0]
.text$mn:00010092                 push    eax             ; void *
.text$mn:00010093                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00010098                 add     esp, 4
.text$mn:0001009B                 mov     esp, ebp
.text$mn:0001009D                 pop     ebp
.text$mn:0001009E                 retn    8
.text$mn:0001009E ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0001009E
.text$mn:0001009E ; ---------------------------------------------------------------------------
.text$mn:000100A1                 align 4
.text$mn:000100A1 _text$mn        ends
.text$mn:000100A1
.text$mn:000100A4 ; ===========================================================================
.text$mn:000100A4
.text$mn:000100A4 ; Segment type: Pure code
.text$mn:000100A4 ; Segment permissions: Read/Execute
.text$mn:000100A4 _text$mn        segment para public 'CODE' use32
.text$mn:000100A4                 assume cs:_text$mn
.text$mn:000100A4                 ;org 100A4h
.text$mn:000100A4 ; COMDAT (pick any)
.text$mn:000100A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000100A4
.text$mn:000100A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000100A4
.text$mn:000100A4 ; Attributes: bp-based frame
.text$mn:000100A4
.text$mn:000100A4 ; int __stdcall std::allocator<sessionFileInfo>::deallocate(void *, int)
.text$mn:000100A4                 public ?deallocate@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@I@Z
.text$mn:000100A4 ?deallocate@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@I@Z proc near
.text$mn:000100A4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<sessionFileInfo>>::deallocate(sessionFileInfo *,uint)+12p
.text$mn:000100A4
.text$mn:000100A4 var_4           = dword ptr -4
.text$mn:000100A4 arg_0           = dword ptr  8
.text$mn:000100A4
.text$mn:000100A4                 push    ebp
.text$mn:000100A5                 mov     ebp, esp
.text$mn:000100A7                 push    ecx
.text$mn:000100A8                 mov     [ebp+var_4], ecx
.text$mn:000100AB                 mov     eax, [ebp+arg_0]
.text$mn:000100AE                 push    eax             ; void *
.text$mn:000100AF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000100B4                 add     esp, 4
.text$mn:000100B7                 mov     esp, ebp
.text$mn:000100B9                 pop     ebp
.text$mn:000100BA                 retn    8
.text$mn:000100BA ?deallocate@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@I@Z endp
.text$mn:000100BA
.text$mn:000100BA ; ---------------------------------------------------------------------------
.text$mn:000100BD                 align 10h
.text$mn:000100BD _text$mn        ends
.text$mn:000100BD
.text$mn:000100C0 ; ===========================================================================
.text$mn:000100C0
.text$mn:000100C0 ; Segment type: Pure code
.text$mn:000100C0 ; Segment permissions: Read/Execute
.text$mn:000100C0 _text$mn        segment para public 'CODE' use32
.text$mn:000100C0                 assume cs:_text$mn
.text$mn:000100C0                 ;org 100C0h
.text$mn:000100C0 ; COMDAT (pick any)
.text$mn:000100C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000100C0
.text$mn:000100C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000100C0
.text$mn:000100C0 ; Attributes: bp-based frame
.text$mn:000100C0
.text$mn:000100C0 ; int __stdcall std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::deallocate(void *, int)
.text$mn:000100C0                 public ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:000100C0 ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$mn:000100C0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::deallocate(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,uint)+12p
.text$mn:000100C0
.text$mn:000100C0 var_4           = dword ptr -4
.text$mn:000100C0 arg_0           = dword ptr  8
.text$mn:000100C0
.text$mn:000100C0                 push    ebp
.text$mn:000100C1                 mov     ebp, esp
.text$mn:000100C3                 push    ecx
.text$mn:000100C4                 mov     [ebp+var_4], ecx
.text$mn:000100C7                 mov     eax, [ebp+arg_0]
.text$mn:000100CA                 push    eax             ; void *
.text$mn:000100CB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000100D0                 add     esp, 4
.text$mn:000100D3                 mov     esp, ebp
.text$mn:000100D5                 pop     ebp
.text$mn:000100D6                 retn    8
.text$mn:000100D6 ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp
.text$mn:000100D6
.text$mn:000100D6 ; ---------------------------------------------------------------------------
.text$mn:000100D9                 align 4
.text$mn:000100D9 _text$mn        ends
.text$mn:000100D9
.text$mn:000100DC ; ===========================================================================
.text$mn:000100DC
.text$mn:000100DC ; Segment type: Pure code
.text$mn:000100DC ; Segment permissions: Read/Execute
.text$mn:000100DC _text$mn        segment para public 'CODE' use32
.text$mn:000100DC                 assume cs:_text$mn
.text$mn:000100DC                 ;org 100DCh
.text$mn:000100DC ; COMDAT (pick any)
.text$mn:000100DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000100DC
.text$mn:000100DC ; =============== S U B R O U T I N E =======================================
.text$mn:000100DC
.text$mn:000100DC ; Attributes: bp-based frame
.text$mn:000100DC
.text$mn:000100DC ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:000100DC                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:000100DC ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:000100DC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:000100DC
.text$mn:000100DC var_4           = dword ptr -4
.text$mn:000100DC arg_0           = dword ptr  8
.text$mn:000100DC
.text$mn:000100DC                 push    ebp
.text$mn:000100DD                 mov     ebp, esp
.text$mn:000100DF                 push    ecx
.text$mn:000100E0                 mov     [ebp+var_4], ecx
.text$mn:000100E3                 mov     eax, [ebp+arg_0]
.text$mn:000100E6                 push    eax             ; void *
.text$mn:000100E7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000100EC                 add     esp, 4
.text$mn:000100EF                 mov     esp, ebp
.text$mn:000100F1                 pop     ebp
.text$mn:000100F2                 retn    8
.text$mn:000100F2 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:000100F2
.text$mn:000100F2 ; ---------------------------------------------------------------------------
.text$mn:000100F5                 align 4
.text$mn:000100F5 _text$mn        ends
.text$mn:000100F5
.text$mn:000100F8 ; ===========================================================================
.text$mn:000100F8
.text$mn:000100F8 ; Segment type: Pure code
.text$mn:000100F8 ; Segment permissions: Read/Execute
.text$mn:000100F8 _text$mn        segment para public 'CODE' use32
.text$mn:000100F8                 assume cs:_text$mn
.text$mn:000100F8                 ;org 100F8h
.text$mn:000100F8 ; COMDAT (pick any)
.text$mn:000100F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000100F8
.text$mn:000100F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000100F8
.text$mn:000100F8 ; Attributes: bp-based frame
.text$mn:000100F8
.text$mn:000100F8 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:000100F8                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000100F8 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000100F8                                         ; DATA XREF: .rdata:000144A8o
.text$mn:000100F8
.text$mn:000100F8 var_4           = dword ptr -4
.text$mn:000100F8 arg_0           = dword ptr  8
.text$mn:000100F8 arg_4           = dword ptr  0Ch
.text$mn:000100F8
.text$mn:000100F8                 push    ebp
.text$mn:000100F9                 mov     ebp, esp
.text$mn:000100FB                 push    ecx
.text$mn:000100FC                 mov     [ebp+var_4], ecx
.text$mn:000100FF                 mov     eax, [ebp+arg_4]
.text$mn:00010102                 push    eax             ; int
.text$mn:00010103                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00010108                 add     esp, 4
.text$mn:0001010B                 test    eax, eax
.text$mn:0001010D                 jz      short loc_10128
.text$mn:0001010F                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00010114                 push    eax             ; struct std::error_category *
.text$mn:00010115                 mov     ecx, [ebp+arg_4]
.text$mn:00010118                 push    ecx             ; int
.text$mn:00010119                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0001011C                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00010121                 mov     eax, [ebp+arg_0]
.text$mn:00010124                 jmp     short loc_1013D
.text$mn:00010126 ; ---------------------------------------------------------------------------
.text$mn:00010126                 jmp     short loc_1013D
.text$mn:00010128 ; ---------------------------------------------------------------------------
.text$mn:00010128
.text$mn:00010128 loc_10128:                              ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00010128                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:0001012D                 push    eax             ; struct std::error_category *
.text$mn:0001012E                 mov     edx, [ebp+arg_4]
.text$mn:00010131                 push    edx             ; int
.text$mn:00010132                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00010135                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0001013A                 mov     eax, [ebp+arg_0]
.text$mn:0001013D
.text$mn:0001013D loc_1013D:                              ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:0001013D                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:0001013D                 mov     esp, ebp
.text$mn:0001013F                 pop     ebp
.text$mn:00010140                 retn    8
.text$mn:00010140 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00010140
.text$mn:00010140 ; ---------------------------------------------------------------------------
.text$mn:00010143                 align 4
.text$mn:00010143 _text$mn        ends
.text$mn:00010143
.text$mn:00010144 ; ===========================================================================
.text$mn:00010144
.text$mn:00010144 ; Segment type: Pure code
.text$mn:00010144 ; Segment permissions: Read/Execute
.text$mn:00010144 _text$mn        segment para public 'CODE' use32
.text$mn:00010144                 assume cs:_text$mn
.text$mn:00010144                 ;org 10144h
.text$mn:00010144 ; COMDAT (pick any)
.text$mn:00010144                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010144
.text$mn:00010144 ; =============== S U B R O U T I N E =======================================
.text$mn:00010144
.text$mn:00010144 ; Attributes: bp-based frame
.text$mn:00010144
.text$mn:00010144 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00010144                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00010144 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00010144                                         ; DATA XREF: .rdata:00014418o
.text$mn:00010144                                         ; .rdata:00014434o ...
.text$mn:00010144
.text$mn:00010144 var_4           = dword ptr -4
.text$mn:00010144 arg_0           = dword ptr  8
.text$mn:00010144 arg_4           = dword ptr  0Ch
.text$mn:00010144
.text$mn:00010144                 push    ebp
.text$mn:00010145                 mov     ebp, esp
.text$mn:00010147                 push    ecx
.text$mn:00010148                 mov     [ebp+var_4], ecx
.text$mn:0001014B                 mov     eax, [ebp+var_4]
.text$mn:0001014E                 push    eax             ; struct std::error_category *
.text$mn:0001014F                 mov     ecx, [ebp+arg_4]
.text$mn:00010152                 push    ecx             ; int
.text$mn:00010153                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00010156                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0001015B                 mov     eax, [ebp+arg_0]
.text$mn:0001015E                 mov     esp, ebp
.text$mn:00010160                 pop     ebp
.text$mn:00010161                 retn    8
.text$mn:00010161 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00010161
.text$mn:00010161 _text$mn        ends
.text$mn:00010161
.text$mn:00010164 ; ===========================================================================
.text$mn:00010164
.text$mn:00010164 ; Segment type: Pure code
.text$mn:00010164 ; Segment permissions: Read/Execute
.text$mn:00010164 _text$mn        segment para public 'CODE' use32
.text$mn:00010164                 assume cs:_text$mn
.text$mn:00010164                 ;org 10164h
.text$mn:00010164 ; COMDAT (pick any)
.text$mn:00010164                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010164
.text$mn:00010164 ; =============== S U B R O U T I N E =======================================
.text$mn:00010164
.text$mn:00010164 ; Attributes: bp-based frame
.text$mn:00010164
.text$mn:00010164 ; void __thiscall VerticalFileSwitcherListView::deleteColumn(VerticalFileSwitcherListView *this, unsigned int)
.text$mn:00010164                 public ?deleteColumn@VerticalFileSwitcherListView@@QAEXI@Z
.text$mn:00010164 ?deleteColumn@VerticalFileSwitcherListView@@QAEXI@Z proc near
.text$mn:00010164                                         ; CODE XREF: VerticalFileSwitcher::reload(void)+Fp
.text$mn:00010164                                         ; VerticalFileSwitcher::reload(void)+1Cp
.text$mn:00010164
.text$mn:00010164 var_4           = dword ptr -4
.text$mn:00010164 wParam          = dword ptr  8
.text$mn:00010164
.text$mn:00010164                 push    ebp
.text$mn:00010165                 mov     ebp, esp
.text$mn:00010167                 push    ecx
.text$mn:00010168                 mov     [ebp+var_4], ecx
.text$mn:0001016B                 push    0               ; lParam
.text$mn:0001016D                 mov     eax, [ebp+wParam]
.text$mn:00010170                 push    eax             ; wParam
.text$mn:00010171                 push    101Ch           ; Msg
.text$mn:00010176                 mov     ecx, [ebp+var_4]
.text$mn:00010179                 mov     edx, [ecx+0Ch]
.text$mn:0001017C                 push    edx             ; hWnd
.text$mn:0001017D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00010183                 mov     esp, ebp
.text$mn:00010185                 pop     ebp
.text$mn:00010186                 retn    4
.text$mn:00010186 ?deleteColumn@VerticalFileSwitcherListView@@QAEXI@Z endp
.text$mn:00010186
.text$mn:00010186 ; ---------------------------------------------------------------------------
.text$mn:00010189                 align 4
.text$mn:00010189 _text$mn        ends
.text$mn:00010189
.text$mn:0001018C ; ===========================================================================
.text$mn:0001018C
.text$mn:0001018C ; Segment type: Pure code
.text$mn:0001018C ; Segment permissions: Read/Execute
.text$mn:0001018C _text$mn        segment para public 'CODE' use32
.text$mn:0001018C                 assume cs:_text$mn
.text$mn:0001018C                 ;org 1018Ch
.text$mn:0001018C ; COMDAT (pick any)
.text$mn:0001018C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0001018C
.text$mn:0001018C ; =============== S U B R O U T I N E =======================================
.text$mn:0001018C
.text$mn:0001018C ; Attributes: bp-based frame
.text$mn:0001018C
.text$mn:0001018C ; void __thiscall Buffer::doNotify(Buffer *this, int)
.text$mn:0001018C                 public ?doNotify@Buffer@@AAEXH@Z
.text$mn:0001018C ?doNotify@Buffer@@AAEXH@Z proc near     ; CODE XREF: Buffer::setDirty(bool)+15p
.text$mn:0001018C                                         ; Buffer::setEncoding(int)+15p ...
.text$mn:0001018C
.text$mn:0001018C var_4           = dword ptr -4
.text$mn:0001018C arg_0           = dword ptr  8
.text$mn:0001018C
.text$mn:0001018C                 push    ebp
.text$mn:0001018D                 mov     ebp, esp
.text$mn:0001018F                 push    ecx
.text$mn:00010190                 mov     [ebp+var_4], ecx
.text$mn:00010193                 mov     eax, [ebp+var_4]
.text$mn:00010196                 movzx   ecx, byte ptr [eax+4]
.text$mn:0001019A                 test    ecx, ecx
.text$mn:0001019C                 jz      short loc_101B0
.text$mn:0001019E                 mov     edx, [ebp+arg_0]
.text$mn:000101A1                 push    edx             ; int
.text$mn:000101A2                 mov     eax, [ebp+var_4]
.text$mn:000101A5                 push    eax             ; struct Buffer *
.text$mn:000101A6                 mov     ecx, [ebp+var_4]
.text$mn:000101A9                 mov     ecx, [ecx]      ; this
.text$mn:000101AB                 call    ?beNotifiedOfBufferChange@FileManager@@QAEXPAVBuffer@@H@Z ; FileManager::beNotifiedOfBufferChange(Buffer *,int)
.text$mn:000101B0
.text$mn:000101B0 loc_101B0:                              ; CODE XREF: Buffer::doNotify(int)+10j
.text$mn:000101B0                 mov     esp, ebp
.text$mn:000101B2                 pop     ebp
.text$mn:000101B3                 retn    4
.text$mn:000101B3 ?doNotify@Buffer@@AAEXH@Z endp
.text$mn:000101B3
.text$mn:000101B3 ; ---------------------------------------------------------------------------
.text$mn:000101B6                 align 4
.text$mn:000101B6 _text$mn        ends
.text$mn:000101B6
.text$mn:000101B8 ; ===========================================================================
.text$mn:000101B8
.text$mn:000101B8 ; Segment type: Pure code
.text$mn:000101B8 ; Segment permissions: Read/Execute
.text$mn:000101B8 _text$mn        segment para public 'CODE' use32
.text$mn:000101B8                 assume cs:_text$mn
.text$mn:000101B8                 ;org 101B8h
.text$mn:000101B8 ; COMDAT (pick any)
.text$mn:000101B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000101B8
.text$mn:000101B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000101B8
.text$mn:000101B8 ; Attributes: bp-based frame
.text$mn:000101B8
.text$mn:000101B8 ; int __thiscall Buffer::docLength(Buffer *__hidden this)
.text$mn:000101B8                 public ?docLength@Buffer@@QBEHXZ
.text$mn:000101B8 ?docLength@Buffer@@QBEHXZ proc near     ; CODE XREF: Notepad_plus::fileClose(Buffer *,int)+56p
.text$mn:000101B8                                         ; Notepad_plus::fileCloseAll(bool,bool)+C4p ...
.text$mn:000101B8
.text$mn:000101B8 var_4           = dword ptr -4
.text$mn:000101B8
.text$mn:000101B8                 push    ebp
.text$mn:000101B9                 mov     ebp, esp
.text$mn:000101BB                 push    ecx
.text$mn:000101BC                 mov     [ebp+var_4], ecx
.text$mn:000101BF                 mov     eax, [ebp+var_4]
.text$mn:000101C2                 mov     ecx, [eax+0Ch]
.text$mn:000101C5                 push    ecx             ; struct Buffer *
.text$mn:000101C6                 mov     edx, [ebp+var_4]
.text$mn:000101C9                 mov     ecx, [edx]      ; this
.text$mn:000101CB                 call    ?docLength@FileManager@@QBEHPAVBuffer@@@Z ; FileManager::docLength(Buffer *)
.text$mn:000101D0                 mov     esp, ebp
.text$mn:000101D2                 pop     ebp
.text$mn:000101D3                 retn
.text$mn:000101D3 ?docLength@Buffer@@QBEHXZ endp
.text$mn:000101D3
.text$mn:000101D3 _text$mn        ends
.text$mn:000101D3
.text$mn:000101D4 ; ===========================================================================
.text$mn:000101D4
.text$mn:000101D4 ; Segment type: Pure code
.text$mn:000101D4 ; Segment permissions: Read/Execute
.text$mn:000101D4 _text$mn        segment para public 'CODE' use32
.text$mn:000101D4                 assume cs:_text$mn
.text$mn:000101D4                 ;org 101D4h
.text$mn:000101D4 ; COMDAT (pick any)
.text$mn:000101D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000101D4
.text$mn:000101D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000101D4
.text$mn:000101D4 ; Attributes: bp-based frame
.text$mn:000101D4
.text$mn:000101D4 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::empty(void)const
.text$mn:000101D4                 public ?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NXZ
.text$mn:000101D4 ?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NXZ proc near
.text$mn:000101D4                                         ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+3D6p
.text$mn:000101D4
.text$mn:000101D4 var_8           = dword ptr -8
.text$mn:000101D4 var_4           = dword ptr -4
.text$mn:000101D4
.text$mn:000101D4                 push    ebp
.text$mn:000101D5                 mov     ebp, esp
.text$mn:000101D7                 sub     esp, 8
.text$mn:000101DA                 mov     [ebp+var_8], ecx
.text$mn:000101DD                 mov     eax, [ebp+var_8]
.text$mn:000101E0                 cmp     dword ptr [eax+14h], 0
.text$mn:000101E4                 jnz     short loc_101EF
.text$mn:000101E6                 mov     [ebp+var_4], 1
.text$mn:000101ED                 jmp     short loc_101F6
.text$mn:000101EF ; ---------------------------------------------------------------------------
.text$mn:000101EF
.text$mn:000101EF loc_101EF:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::empty(void)+10j
.text$mn:000101EF                 mov     [ebp+var_4], 0
.text$mn:000101F6
.text$mn:000101F6 loc_101F6:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::empty(void)+19j
.text$mn:000101F6                 mov     al, byte ptr [ebp+var_4]
.text$mn:000101F9                 mov     esp, ebp
.text$mn:000101FB                 pop     ebp
.text$mn:000101FC                 retn
.text$mn:000101FC ?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NXZ endp
.text$mn:000101FC
.text$mn:000101FC ; ---------------------------------------------------------------------------
.text$mn:000101FD                 align 10h
.text$mn:000101FD _text$mn        ends
.text$mn:000101FD
.text$mn:00010200 ; ===========================================================================
.text$mn:00010200
.text$mn:00010200 ; Segment type: Pure code
.text$mn:00010200 ; Segment permissions: Read/Execute
.text$mn:00010200 _text$mn        segment para public 'CODE' use32
.text$mn:00010200                 assume cs:_text$mn
.text$mn:00010200                 ;org 10200h
.text$mn:00010200 ; COMDAT (pick any)
.text$mn:00010200                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010200
.text$mn:00010200 ; =============== S U B R O U T I N E =======================================
.text$mn:00010200
.text$mn:00010200 ; Attributes: bp-based frame
.text$mn:00010200
.text$mn:00010200 ; public: bool __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::empty(void)const
.text$mn:00010200                 public ?empty@?$vector@IV?$allocator@I@std@@@std@@QBE_NXZ
.text$mn:00010200 ?empty@?$vector@IV?$allocator@I@std@@@std@@QBE_NXZ proc near
.text$mn:00010200                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator=(std::vector<uint,std::allocator<uint>> const &)+90p
.text$mn:00010200
.text$mn:00010200 var_8           = dword ptr -8
.text$mn:00010200 var_4           = dword ptr -4
.text$mn:00010200
.text$mn:00010200                 push    ebp
.text$mn:00010201                 mov     ebp, esp
.text$mn:00010203                 sub     esp, 8
.text$mn:00010206                 mov     [ebp+var_4], ecx
.text$mn:00010209                 mov     eax, [ebp+var_4]
.text$mn:0001020C                 mov     ecx, [ebp+var_4]
.text$mn:0001020F                 mov     edx, [eax+4]
.text$mn:00010212                 cmp     edx, [ecx+8]
.text$mn:00010215                 jnz     short loc_10220
.text$mn:00010217                 mov     [ebp+var_8], 1
.text$mn:0001021E                 jmp     short loc_10227
.text$mn:00010220 ; ---------------------------------------------------------------------------
.text$mn:00010220
.text$mn:00010220 loc_10220:                              ; CODE XREF: std::vector<uint,std::allocator<uint>>::empty(void)+15j
.text$mn:00010220                 mov     [ebp+var_8], 0
.text$mn:00010227
.text$mn:00010227 loc_10227:                              ; CODE XREF: std::vector<uint,std::allocator<uint>>::empty(void)+1Ej
.text$mn:00010227                 mov     al, byte ptr [ebp+var_8]
.text$mn:0001022A                 mov     esp, ebp
.text$mn:0001022C                 pop     ebp
.text$mn:0001022D                 retn
.text$mn:0001022D ?empty@?$vector@IV?$allocator@I@std@@@std@@QBE_NXZ endp
.text$mn:0001022D
.text$mn:0001022D ; ---------------------------------------------------------------------------
.text$mn:0001022E                 align 10h
.text$mn:0001022E _text$mn        ends
.text$mn:0001022E
.text$mn:00010230 ; ===========================================================================
.text$mn:00010230
.text$mn:00010230 ; Segment type: Pure code
.text$mn:00010230 ; Segment permissions: Read/Execute
.text$mn:00010230 _text$mn        segment para public 'CODE' use32
.text$mn:00010230                 assume cs:_text$mn
.text$mn:00010230                 ;org 10230h
.text$mn:00010230 ; COMDAT (pick any)
.text$mn:00010230                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010230
.text$mn:00010230 ; =============== S U B R O U T I N E =======================================
.text$mn:00010230
.text$mn:00010230 ; Attributes: bp-based frame
.text$mn:00010230
.text$mn:00010230 ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::end(void)
.text$mn:00010230                 public ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:00010230 ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$mn:00010230                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+72p
.text$mn:00010230                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+8Ep
.text$mn:00010230
.text$mn:00010230 var_14          = dword ptr -14h
.text$mn:00010230 var_10          = dword ptr -10h
.text$mn:00010230 var_C           = dword ptr -0Ch
.text$mn:00010230 var_4           = dword ptr -4
.text$mn:00010230 arg_0           = dword ptr  8
.text$mn:00010230
.text$mn:00010230                 push    ebp
.text$mn:00010231                 mov     ebp, esp
.text$mn:00010233                 push    0FFFFFFFFh
.text$mn:00010235                 push    offset __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0001023A                 mov     eax, large fs:0
.text$mn:00010240                 push    eax
.text$mn:00010241                 sub     esp, 8
.text$mn:00010244                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00010249                 xor     eax, ebp
.text$mn:0001024B                 push    eax
.text$mn:0001024C                 lea     eax, [ebp+var_C]
.text$mn:0001024F                 mov     large fs:0, eax
.text$mn:00010255                 mov     [ebp+var_10], ecx
.text$mn:00010258                 mov     [ebp+var_14], 0
.text$mn:0001025F                 mov     eax, [ebp+var_10]
.text$mn:00010262                 push    eax             ; struct std::_Container_base12 *
.text$mn:00010263                 mov     ecx, [ebp+var_10]
.text$mn:00010266                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0001026B                 mov     ecx, [ebp+var_10]
.text$mn:0001026E                 mov     edx, [ecx+14h]
.text$mn:00010271                 lea     eax, [eax+edx*2]
.text$mn:00010274                 push    eax             ; int
.text$mn:00010275                 mov     ecx, [ebp+arg_0]
.text$mn:00010278                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)
.text$mn:0001027D                 mov     [ebp+var_4], 0
.text$mn:00010284                 mov     ecx, [ebp+var_14]
.text$mn:00010287                 or      ecx, 1
.text$mn:0001028A                 mov     [ebp+var_14], ecx
.text$mn:0001028D                 mov     eax, [ebp+arg_0]
.text$mn:00010290                 mov     ecx, [ebp+var_C]
.text$mn:00010293                 mov     large fs:0, ecx
.text$mn:0001029A                 pop     ecx
.text$mn:0001029B                 mov     esp, ebp
.text$mn:0001029D                 pop     ebp
.text$mn:0001029E                 retn    4
.text$mn:0001029E ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$mn:0001029E
.text$mn:0001029E ; ---------------------------------------------------------------------------
.text$mn:000102A1                 align 4
.text$mn:000102A1 _text$mn        ends
.text$mn:000102A1
.text$x:000102A4 ; ===========================================================================
.text$x:000102A4
.text$x:000102A4 ; Segment type: Pure code
.text$x:000102A4 ; Segment permissions: Read/Execute
.text$x:000102A4 _text$x         segment para public 'CODE' use32
.text$x:000102A4                 assume cs:_text$x
.text$x:000102A4                 ;org 102A4h
.text$x:000102A4 ; COMDAT (pick associative to section at 10230)
.text$x:000102A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000102A4
.text$x:000102A4 ; =============== S U B R O U T I N E =======================================
.text$x:000102A4
.text$x:000102A4
.text$x:000102A4 __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 proc near
.text$x:000102A4                                         ; DATA XREF: .xdata$x:00012A20o
.text$x:000102A4                 mov     eax, [ebp-14h]
.text$x:000102A7                 and     eax, 1
.text$x:000102AA                 jz      $LN4_0
.text$x:000102B0                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:000102B4                 mov     ecx, [ebp+8]
.text$x:000102B7                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000102BC ; ---------------------------------------------------------------------------
.text$x:000102BC
.text$x:000102BC $LN4_0:                                 ; CODE XREF: __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0+6j
.text$x:000102BC                 retn
.text$x:000102BC __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 endp
.text$x:000102BC
.text$x:000102BD
.text$x:000102BD ; =============== S U B R O U T I N E =======================================
.text$x:000102BD
.text$x:000102BD
.text$x:000102BD __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$x:000102BD                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)+5o
.text$x:000102BD
.text$x:000102BD arg_4           = dword ptr  8
.text$x:000102BD
.text$x:000102BD                 mov     edx, [esp+arg_4]
.text$x:000102C1                 lea     eax, [edx+0Ch]
.text$x:000102C4                 mov     ecx, [edx-0Ch]
.text$x:000102C7                 xor     ecx, eax
.text$x:000102C9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000102CE                 mov     eax, offset __ehfuncinfo$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$x:000102D3                 jmp     ___CxxFrameHandler3
.text$x:000102D3 __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$x:000102D3
.text$x:000102D3 _text$x         ends
.text$x:000102D3
.text$mn:000102D8 ; ===========================================================================
.text$mn:000102D8
.text$mn:000102D8 ; Segment type: Pure code
.text$mn:000102D8 ; Segment permissions: Read/Execute
.text$mn:000102D8 _text$mn        segment para public 'CODE' use32
.text$mn:000102D8                 assume cs:_text$mn
.text$mn:000102D8                 ;org 102D8h
.text$mn:000102D8 ; COMDAT (pick any)
.text$mn:000102D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000102D8
.text$mn:000102D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000102D8
.text$mn:000102D8 ; Attributes: bp-based frame
.text$mn:000102D8
.text$mn:000102D8 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> __thiscall std::vector<int, class std::allocator<int>>::end(void)const
.text$mn:000102D8                 public ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$mn:000102D8 ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ proc near
.text$mn:000102D8                                         ; CODE XREF: Notepad_plus::fileCloseAllGiven(std::vector<int,std::allocator<int>> const &)+2Fp
.text$mn:000102D8
.text$mn:000102D8 var_14          = dword ptr -14h
.text$mn:000102D8 var_10          = dword ptr -10h
.text$mn:000102D8 var_C           = dword ptr -0Ch
.text$mn:000102D8 var_4           = dword ptr -4
.text$mn:000102D8 arg_0           = dword ptr  8
.text$mn:000102D8
.text$mn:000102D8                 push    ebp
.text$mn:000102D9                 mov     ebp, esp
.text$mn:000102DB                 push    0FFFFFFFFh
.text$mn:000102DD                 push    offset __ehhandler$?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$mn:000102E2                 mov     eax, large fs:0
.text$mn:000102E8                 push    eax
.text$mn:000102E9                 sub     esp, 8
.text$mn:000102EC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000102F1                 xor     eax, ebp
.text$mn:000102F3                 push    eax
.text$mn:000102F4                 lea     eax, [ebp+var_C]
.text$mn:000102F7                 mov     large fs:0, eax
.text$mn:000102FD                 mov     [ebp+var_10], ecx
.text$mn:00010300                 mov     [ebp+var_14], 0
.text$mn:00010307                 mov     eax, [ebp+var_10]
.text$mn:0001030A                 push    eax             ; struct std::_Container_base12 *
.text$mn:0001030B                 mov     ecx, [ebp+var_10]
.text$mn:0001030E                 mov     edx, [ecx+8]
.text$mn:00010311                 push    edx             ; int
.text$mn:00010312                 mov     ecx, [ebp+arg_0]
.text$mn:00010315                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)
.text$mn:0001031A                 mov     [ebp+var_4], 0
.text$mn:00010321                 mov     eax, [ebp+var_14]
.text$mn:00010324                 or      eax, 1
.text$mn:00010327                 mov     [ebp+var_14], eax
.text$mn:0001032A                 mov     eax, [ebp+arg_0]
.text$mn:0001032D                 mov     ecx, [ebp+var_C]
.text$mn:00010330                 mov     large fs:0, ecx
.text$mn:00010337                 pop     ecx
.text$mn:00010338                 mov     esp, ebp
.text$mn:0001033A                 pop     ebp
.text$mn:0001033B                 retn    4
.text$mn:0001033B ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ endp
.text$mn:0001033B
.text$mn:0001033B ; ---------------------------------------------------------------------------
.text$mn:0001033E                 align 10h
.text$mn:0001033E _text$mn        ends
.text$mn:0001033E
.text$x:00010340 ; ===========================================================================
.text$x:00010340
.text$x:00010340 ; Segment type: Pure code
.text$x:00010340 ; Segment permissions: Read/Execute
.text$x:00010340 _text$x         segment para public 'CODE' use32
.text$x:00010340                 assume cs:_text$x
.text$x:00010340                 ;org 10340h
.text$x:00010340 ; COMDAT (pick associative to section at 102D8)
.text$x:00010340                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00010340
.text$x:00010340 ; =============== S U B R O U T I N E =======================================
.text$x:00010340
.text$x:00010340
.text$x:00010340 __unwindfunclet$?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0 proc near
.text$x:00010340                                         ; DATA XREF: .xdata$x:00012C6Co
.text$x:00010340                 mov     eax, [ebp-14h]
.text$x:00010343                 and     eax, 1
.text$x:00010346                 jz      $LN4_3
.text$x:0001034C                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00010350                 mov     ecx, [ebp+8]
.text$x:00010353                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00010358 ; ---------------------------------------------------------------------------
.text$x:00010358
.text$x:00010358 $LN4_3:                                 ; CODE XREF: __unwindfunclet$?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0+6j
.text$x:00010358                 retn
.text$x:00010358 __unwindfunclet$?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0 endp
.text$x:00010358
.text$x:00010359
.text$x:00010359 ; =============== S U B R O U T I N E =======================================
.text$x:00010359
.text$x:00010359
.text$x:00010359 __ehhandler$?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ proc near
.text$x:00010359                                         ; DATA XREF: std::vector<int,std::allocator<int>>::end(void)+5o
.text$x:00010359
.text$x:00010359 arg_4           = dword ptr  8
.text$x:00010359
.text$x:00010359                 mov     edx, [esp+arg_4]
.text$x:0001035D                 lea     eax, [edx+0Ch]
.text$x:00010360                 mov     ecx, [edx-0Ch]
.text$x:00010363                 xor     ecx, eax
.text$x:00010365                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0001036A                 mov     eax, offset __ehfuncinfo$?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$x:0001036F                 jmp     ___CxxFrameHandler3
.text$x:0001036F __ehhandler$?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ endp
.text$x:0001036F
.text$x:0001036F _text$x         ends
.text$x:0001036F
.text$mn:00010374 ; ===========================================================================
.text$mn:00010374
.text$mn:00010374 ; Segment type: Pure code
.text$mn:00010374 ; Segment permissions: Read/Execute
.text$mn:00010374 _text$mn        segment para public 'CODE' use32
.text$mn:00010374                 assume cs:_text$mn
.text$mn:00010374                 ;org 10374h
.text$mn:00010374 ; COMDAT (pick any)
.text$mn:00010374                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010374
.text$mn:00010374 ; =============== S U B R O U T I N E =======================================
.text$mn:00010374
.text$mn:00010374 ; Attributes: bp-based frame
.text$mn:00010374
.text$mn:00010374 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned int>>> __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::end(void)const
.text$mn:00010374                 public ?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
.text$mn:00010374 ?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ proc near
.text$mn:00010374                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(std::vector<uint,std::allocator<uint>> const &)+89p
.text$mn:00010374
.text$mn:00010374 var_14          = dword ptr -14h
.text$mn:00010374 var_10          = dword ptr -10h
.text$mn:00010374 var_C           = dword ptr -0Ch
.text$mn:00010374 var_4           = dword ptr -4
.text$mn:00010374 arg_0           = dword ptr  8
.text$mn:00010374
.text$mn:00010374                 push    ebp
.text$mn:00010375                 mov     ebp, esp
.text$mn:00010377                 push    0FFFFFFFFh
.text$mn:00010379                 push    offset __ehhandler$?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
.text$mn:0001037E                 mov     eax, large fs:0
.text$mn:00010384                 push    eax
.text$mn:00010385                 sub     esp, 8
.text$mn:00010388                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0001038D                 xor     eax, ebp
.text$mn:0001038F                 push    eax
.text$mn:00010390                 lea     eax, [ebp+var_C]
.text$mn:00010393                 mov     large fs:0, eax
.text$mn:00010399                 mov     [ebp+var_10], ecx
.text$mn:0001039C                 mov     [ebp+var_14], 0
.text$mn:000103A3                 mov     eax, [ebp+var_10]
.text$mn:000103A6                 push    eax             ; struct std::_Container_base12 *
.text$mn:000103A7                 mov     ecx, [ebp+var_10]
.text$mn:000103AA                 mov     edx, [ecx+8]
.text$mn:000103AD                 push    edx             ; int
.text$mn:000103AE                 mov     ecx, [ebp+arg_0]
.text$mn:000103B1                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(uint *,std::_Container_base12 const *)
.text$mn:000103B6                 mov     [ebp+var_4], 0
.text$mn:000103BD                 mov     eax, [ebp+var_14]
.text$mn:000103C0                 or      eax, 1
.text$mn:000103C3                 mov     [ebp+var_14], eax
.text$mn:000103C6                 mov     eax, [ebp+arg_0]
.text$mn:000103C9                 mov     ecx, [ebp+var_C]
.text$mn:000103CC                 mov     large fs:0, ecx
.text$mn:000103D3                 pop     ecx
.text$mn:000103D4                 mov     esp, ebp
.text$mn:000103D6                 pop     ebp
.text$mn:000103D7                 retn    4
.text$mn:000103D7 ?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ endp
.text$mn:000103D7
.text$mn:000103D7 ; ---------------------------------------------------------------------------
.text$mn:000103DA                 align 4
.text$mn:000103DA _text$mn        ends
.text$mn:000103DA
.text$x:000103DC ; ===========================================================================
.text$x:000103DC
.text$x:000103DC ; Segment type: Pure code
.text$x:000103DC ; Segment permissions: Read/Execute
.text$x:000103DC _text$x         segment para public 'CODE' use32
.text$x:000103DC                 assume cs:_text$x
.text$x:000103DC                 ;org 103DCh
.text$x:000103DC ; COMDAT (pick associative to section at 10374)
.text$x:000103DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000103DC
.text$x:000103DC ; =============== S U B R O U T I N E =======================================
.text$x:000103DC
.text$x:000103DC
.text$x:000103DC __unwindfunclet$?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ$0 proc near
.text$x:000103DC                                         ; DATA XREF: .xdata$x:00012F6Co
.text$x:000103DC                 mov     eax, [ebp-14h]
.text$x:000103DF                 and     eax, 1
.text$x:000103E2                 jz      $LN4_5
.text$x:000103E8                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:000103EC                 mov     ecx, [ebp+8]
.text$x:000103EF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uint>>>(void)
.text$x:000103F4 ; ---------------------------------------------------------------------------
.text$x:000103F4
.text$x:000103F4 $LN4_5:                                 ; CODE XREF: __unwindfunclet$?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ$0+6j
.text$x:000103F4                 retn
.text$x:000103F4 __unwindfunclet$?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ$0 endp
.text$x:000103F4
.text$x:000103F5
.text$x:000103F5 ; =============== S U B R O U T I N E =======================================
.text$x:000103F5
.text$x:000103F5
.text$x:000103F5 __ehhandler$?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ proc near
.text$x:000103F5                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::end(void)+5o
.text$x:000103F5
.text$x:000103F5 arg_4           = dword ptr  8
.text$x:000103F5
.text$x:000103F5                 mov     edx, [esp+arg_4]
.text$x:000103F9                 lea     eax, [edx+0Ch]
.text$x:000103FC                 mov     ecx, [edx-0Ch]
.text$x:000103FF                 xor     ecx, eax
.text$x:00010401                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00010406                 mov     eax, offset __ehfuncinfo$?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
.text$x:0001040B                 jmp     ___CxxFrameHandler3
.text$x:0001040B __ehhandler$?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ endp
.text$x:0001040B
.text$x:0001040B _text$x         ends
.text$x:0001040B
.text$mn:00010410 ; ===========================================================================
.text$mn:00010410
.text$mn:00010410 ; Segment type: Pure code
.text$mn:00010410 ; Segment permissions: Read/Execute
.text$mn:00010410 _text$mn        segment para public 'CODE' use32
.text$mn:00010410                 assume cs:_text$mn
.text$mn:00010410                 ;org 10410h
.text$mn:00010410 ; COMDAT (pick any)
.text$mn:00010410                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010410
.text$mn:00010410 ; =============== S U B R O U T I N E =======================================
.text$mn:00010410
.text$mn:00010410 ; Attributes: bp-based frame
.text$mn:00010410
.text$mn:00010410 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>> __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::end(void)const
.text$mn:00010410                 public ?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ
.text$mn:00010410 ?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ proc near
.text$mn:00010410                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(std::vector<sessionFileInfo,std::allocator<sessionFileInfo>> const &)+89p
.text$mn:00010410
.text$mn:00010410 var_14          = dword ptr -14h
.text$mn:00010410 var_10          = dword ptr -10h
.text$mn:00010410 var_C           = dword ptr -0Ch
.text$mn:00010410 var_4           = dword ptr -4
.text$mn:00010410 arg_0           = dword ptr  8
.text$mn:00010410
.text$mn:00010410                 push    ebp
.text$mn:00010411                 mov     ebp, esp
.text$mn:00010413                 push    0FFFFFFFFh
.text$mn:00010415                 push    offset __ehhandler$?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ
.text$mn:0001041A                 mov     eax, large fs:0
.text$mn:00010420                 push    eax
.text$mn:00010421                 sub     esp, 8
.text$mn:00010424                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00010429                 xor     eax, ebp
.text$mn:0001042B                 push    eax
.text$mn:0001042C                 lea     eax, [ebp+var_C]
.text$mn:0001042F                 mov     large fs:0, eax
.text$mn:00010435                 mov     [ebp+var_10], ecx
.text$mn:00010438                 mov     [ebp+var_14], 0
.text$mn:0001043F                 mov     eax, [ebp+var_10]
.text$mn:00010442                 push    eax             ; struct std::_Container_base12 *
.text$mn:00010443                 mov     ecx, [ebp+var_10]
.text$mn:00010446                 mov     edx, [ecx+8]
.text$mn:00010449                 push    edx             ; int
.text$mn:0001044A                 mov     ecx, [ebp+arg_0]
.text$mn:0001044D                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(sessionFileInfo *,std::_Container_base12 const *)
.text$mn:00010452                 mov     [ebp+var_4], 0
.text$mn:00010459                 mov     eax, [ebp+var_14]
.text$mn:0001045C                 or      eax, 1
.text$mn:0001045F                 mov     [ebp+var_14], eax
.text$mn:00010462                 mov     eax, [ebp+arg_0]
.text$mn:00010465                 mov     ecx, [ebp+var_C]
.text$mn:00010468                 mov     large fs:0, ecx
.text$mn:0001046F                 pop     ecx
.text$mn:00010470                 mov     esp, ebp
.text$mn:00010472                 pop     ebp
.text$mn:00010473                 retn    4
.text$mn:00010473 ?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ endp
.text$mn:00010473
.text$mn:00010473 ; ---------------------------------------------------------------------------
.text$mn:00010476                 align 4
.text$mn:00010476 _text$mn        ends
.text$mn:00010476
.text$x:00010478 ; ===========================================================================
.text$x:00010478
.text$x:00010478 ; Segment type: Pure code
.text$x:00010478 ; Segment permissions: Read/Execute
.text$x:00010478 _text$x         segment para public 'CODE' use32
.text$x:00010478                 assume cs:_text$x
.text$x:00010478                 ;org 10478h
.text$x:00010478 ; COMDAT (pick associative to section at 10410)
.text$x:00010478                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00010478
.text$x:00010478 ; =============== S U B R O U T I N E =======================================
.text$x:00010478
.text$x:00010478
.text$x:00010478 __unwindfunclet$?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ$0 proc near
.text$x:00010478                                         ; DATA XREF: .xdata$x:0001322Co
.text$x:00010478                 mov     eax, [ebp-14h]
.text$x:0001047B                 and     eax, 1
.text$x:0001047E                 jz      $LN4_8
.text$x:00010484                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00010488                 mov     ecx, [ebp+8]
.text$x:0001048B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:00010490 ; ---------------------------------------------------------------------------
.text$x:00010490
.text$x:00010490 $LN4_8:                                 ; CODE XREF: __unwindfunclet$?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ$0+6j
.text$x:00010490                 retn
.text$x:00010490 __unwindfunclet$?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ$0 endp
.text$x:00010490
.text$x:00010491
.text$x:00010491 ; =============== S U B R O U T I N E =======================================
.text$x:00010491
.text$x:00010491
.text$x:00010491 __ehhandler$?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ proc near
.text$x:00010491                                         ; DATA XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::end(void)+5o
.text$x:00010491
.text$x:00010491 arg_4           = dword ptr  8
.text$x:00010491
.text$x:00010491                 mov     edx, [esp+arg_4]
.text$x:00010495                 lea     eax, [edx+0Ch]
.text$x:00010498                 mov     ecx, [edx-0Ch]
.text$x:0001049B                 xor     ecx, eax
.text$x:0001049D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000104A2                 mov     eax, offset __ehfuncinfo$?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ
.text$x:000104A7                 jmp     ___CxxFrameHandler3
.text$x:000104A7 __ehhandler$?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ endp
.text$x:000104A7
.text$x:000104A7 _text$x         ends
.text$x:000104A7
.text$mn:000104AC ; ===========================================================================
.text$mn:000104AC
.text$mn:000104AC ; Segment type: Pure code
.text$mn:000104AC ; Segment permissions: Read/Execute
.text$mn:000104AC _text$mn        segment para public 'CODE' use32
.text$mn:000104AC                 assume cs:_text$mn
.text$mn:000104AC                 ;org 104ACh
.text$mn:000104AC ; COMDAT (pick any)
.text$mn:000104AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000104AC
.text$mn:000104AC ; =============== S U B R O U T I N E =======================================
.text$mn:000104AC
.text$mn:000104AC ; Attributes: bp-based frame
.text$mn:000104AC
.text$mn:000104AC ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:000104AC                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:000104AC ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:000104AC                                         ; DATA XREF: .rdata:0001441Co
.text$mn:000104AC                                         ; .rdata:00014438o ...
.text$mn:000104AC
.text$mn:000104AC var_8           = dword ptr -8
.text$mn:000104AC var_4           = dword ptr -4
.text$mn:000104AC arg_0           = dword ptr  8
.text$mn:000104AC arg_4           = dword ptr  0Ch
.text$mn:000104AC
.text$mn:000104AC                 push    ebp
.text$mn:000104AD                 mov     ebp, esp
.text$mn:000104AF                 sub     esp, 8
.text$mn:000104B2                 mov     [ebp+var_8], ecx
.text$mn:000104B5                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000104B8                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:000104BD                 push    eax
.text$mn:000104BE                 mov     ecx, [ebp+var_8]
.text$mn:000104C1                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000104C6                 movzx   eax, al
.text$mn:000104C9                 test    eax, eax
.text$mn:000104CB                 jz      short loc_104E3
.text$mn:000104CD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000104D0                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:000104D5                 cmp     eax, [ebp+arg_4]
.text$mn:000104D8                 jnz     short loc_104E3
.text$mn:000104DA                 mov     [ebp+var_4], 1
.text$mn:000104E1                 jmp     short loc_104EA
.text$mn:000104E3 ; ---------------------------------------------------------------------------
.text$mn:000104E3
.text$mn:000104E3 loc_104E3:                              ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:000104E3                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:000104E3                 mov     [ebp+var_4], 0
.text$mn:000104EA
.text$mn:000104EA loc_104EA:                              ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:000104EA                 mov     al, byte ptr [ebp+var_4]
.text$mn:000104ED                 mov     esp, ebp
.text$mn:000104EF                 pop     ebp
.text$mn:000104F0                 retn    8
.text$mn:000104F0 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:000104F0
.text$mn:000104F0 ; ---------------------------------------------------------------------------
.text$mn:000104F3                 align 4
.text$mn:000104F3 _text$mn        ends
.text$mn:000104F3
.text$mn:000104F4 ; ===========================================================================
.text$mn:000104F4
.text$mn:000104F4 ; Segment type: Pure code
.text$mn:000104F4 ; Segment permissions: Read/Execute
.text$mn:000104F4 _text$mn        segment para public 'CODE' use32
.text$mn:000104F4                 assume cs:_text$mn
.text$mn:000104F4                 ;org 104F4h
.text$mn:000104F4 ; COMDAT (pick any)
.text$mn:000104F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000104F4
.text$mn:000104F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000104F4
.text$mn:000104F4 ; Attributes: bp-based frame
.text$mn:000104F4
.text$mn:000104F4 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:000104F4                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:000104F4 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:000104F4                                         ; DATA XREF: .rdata:00014420o
.text$mn:000104F4                                         ; .rdata:0001443Co ...
.text$mn:000104F4
.text$mn:000104F4 var_C           = byte ptr -0Ch
.text$mn:000104F4 var_4           = dword ptr -4
.text$mn:000104F4 arg_0           = dword ptr  8
.text$mn:000104F4 arg_4           = dword ptr  0Ch
.text$mn:000104F4
.text$mn:000104F4                 push    ebp
.text$mn:000104F5                 mov     ebp, esp
.text$mn:000104F7                 sub     esp, 0Ch
.text$mn:000104FA                 mov     [ebp+var_4], ecx
.text$mn:000104FD                 mov     eax, [ebp+arg_4]
.text$mn:00010500                 push    eax             ; std::error_condition *
.text$mn:00010501                 mov     ecx, [ebp+arg_0]
.text$mn:00010504                 push    ecx
.text$mn:00010505                 lea     edx, [ebp+var_C]
.text$mn:00010508                 push    edx
.text$mn:00010509                 mov     eax, [ebp+var_4]
.text$mn:0001050C                 mov     edx, [eax]
.text$mn:0001050E                 mov     ecx, [ebp+var_4]
.text$mn:00010511                 mov     eax, [edx+0Ch]
.text$mn:00010514                 call    eax
.text$mn:00010516                 mov     ecx, eax
.text$mn:00010518                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:0001051D                 mov     esp, ebp
.text$mn:0001051F                 pop     ebp
.text$mn:00010520                 retn    8
.text$mn:00010520 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00010520
.text$mn:00010520 ; ---------------------------------------------------------------------------
.text$mn:00010523                 align 4
.text$mn:00010523 _text$mn        ends
.text$mn:00010523
.text$mn:00010524 ; ===========================================================================
.text$mn:00010524
.text$mn:00010524 ; Segment type: Pure code
.text$mn:00010524 ; Segment permissions: Read/Execute
.text$mn:00010524 _text$mn        segment para public 'CODE' use32
.text$mn:00010524                 assume cs:_text$mn
.text$mn:00010524                 ;org 10524h
.text$mn:00010524 ; COMDAT (pick any)
.text$mn:00010524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010524
.text$mn:00010524 ; =============== S U B R O U T I N E =======================================
.text$mn:00010524
.text$mn:00010524 ; Attributes: bp-based frame
.text$mn:00010524
.text$mn:00010524 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00010524                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00010524 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00010524                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00010524
.text$mn:00010524 var_4           = dword ptr -4
.text$mn:00010524 arg_0           = dword ptr  8
.text$mn:00010524
.text$mn:00010524                 push    ebp
.text$mn:00010525                 mov     ebp, esp
.text$mn:00010527                 push    ecx
.text$mn:00010528                 mov     [ebp+var_4], ecx
.text$mn:0001052B                 mov     eax, [ebp+var_4]
.text$mn:0001052E                 mov     ecx, [eax+14h]
.text$mn:00010531                 cmp     ecx, [ebp+arg_0]
.text$mn:00010534                 jnb     short loc_1053E
.text$mn:00010536                 mov     ecx, [ebp+var_4]
.text$mn:00010539                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0001053E
.text$mn:0001053E loc_1053E:                              ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:0001053E                 mov     edx, [ebp+arg_0]
.text$mn:00010541                 push    edx
.text$mn:00010542                 mov     ecx, [ebp+var_4]
.text$mn:00010545                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0001054A                 mov     eax, [ebp+var_4]
.text$mn:0001054D                 mov     esp, ebp
.text$mn:0001054F                 pop     ebp
.text$mn:00010550                 retn    4
.text$mn:00010550 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00010550
.text$mn:00010550 ; ---------------------------------------------------------------------------
.text$mn:00010553                 align 4
.text$mn:00010553 _text$mn        ends
.text$mn:00010553
.text$mn:00010554 ; ===========================================================================
.text$mn:00010554
.text$mn:00010554 ; Segment type: Pure code
.text$mn:00010554 ; Segment permissions: Read/Execute
.text$mn:00010554 _text$mn        segment para public 'CODE' use32
.text$mn:00010554                 assume cs:_text$mn
.text$mn:00010554                 ;org 10554h
.text$mn:00010554 ; COMDAT (pick any)
.text$mn:00010554                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010554
.text$mn:00010554 ; =============== S U B R O U T I N E =======================================
.text$mn:00010554
.text$mn:00010554 ; Attributes: bp-based frame
.text$mn:00010554
.text$mn:00010554 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00010554                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00010554 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00010554                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00010554
.text$mn:00010554 var_C           = dword ptr -0Ch
.text$mn:00010554 Dst             = dword ptr -8
.text$mn:00010554 var_4           = dword ptr -4
.text$mn:00010554 arg_0           = dword ptr  8
.text$mn:00010554 arg_4           = dword ptr  0Ch
.text$mn:00010554
.text$mn:00010554                 push    ebp
.text$mn:00010555                 mov     ebp, esp
.text$mn:00010557                 sub     esp, 0Ch
.text$mn:0001055A                 mov     [ebp+var_4], ecx
.text$mn:0001055D                 mov     eax, [ebp+var_4]
.text$mn:00010560                 mov     ecx, [eax+14h]
.text$mn:00010563                 cmp     ecx, [ebp+arg_0]
.text$mn:00010566                 jnb     short loc_10570
.text$mn:00010568                 mov     ecx, [ebp+var_4]
.text$mn:0001056B                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00010570
.text$mn:00010570 loc_10570:                              ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00010570                 mov     edx, [ebp+var_4]
.text$mn:00010573                 mov     eax, [edx+14h]
.text$mn:00010576                 sub     eax, [ebp+arg_0]
.text$mn:00010579                 cmp     eax, [ebp+arg_4]
.text$mn:0001057C                 ja      short loc_1058C
.text$mn:0001057E                 mov     ecx, [ebp+arg_0]
.text$mn:00010581                 push    ecx
.text$mn:00010582                 mov     ecx, [ebp+var_4]
.text$mn:00010585                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0001058A                 jmp     short loc_105D2
.text$mn:0001058C ; ---------------------------------------------------------------------------
.text$mn:0001058C
.text$mn:0001058C loc_1058C:                              ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:0001058C                 cmp     [ebp+arg_4], 0
.text$mn:00010590                 jbe     short loc_105D2
.text$mn:00010592                 mov     ecx, [ebp+var_4]
.text$mn:00010595                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0001059A                 add     eax, [ebp+arg_0]
.text$mn:0001059D                 mov     [ebp+Dst], eax
.text$mn:000105A0                 mov     edx, [ebp+var_4]
.text$mn:000105A3                 mov     eax, [edx+14h]
.text$mn:000105A6                 sub     eax, [ebp+arg_4]
.text$mn:000105A9                 mov     [ebp+var_C], eax
.text$mn:000105AC                 mov     ecx, [ebp+var_C]
.text$mn:000105AF                 sub     ecx, [ebp+arg_0]
.text$mn:000105B2                 push    ecx             ; Size
.text$mn:000105B3                 mov     edx, [ebp+Dst]
.text$mn:000105B6                 add     edx, [ebp+arg_4]
.text$mn:000105B9                 push    edx             ; Src
.text$mn:000105BA                 mov     eax, [ebp+Dst]
.text$mn:000105BD                 push    eax             ; Dst
.text$mn:000105BE                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:000105C3                 add     esp, 0Ch
.text$mn:000105C6                 mov     ecx, [ebp+var_C]
.text$mn:000105C9                 push    ecx
.text$mn:000105CA                 mov     ecx, [ebp+var_4]
.text$mn:000105CD                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000105D2
.text$mn:000105D2 loc_105D2:                              ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:000105D2                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:000105D2                 mov     eax, [ebp+var_4]
.text$mn:000105D5                 mov     esp, ebp
.text$mn:000105D7                 pop     ebp
.text$mn:000105D8                 retn    8
.text$mn:000105D8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:000105D8
.text$mn:000105D8 ; ---------------------------------------------------------------------------
.text$mn:000105DB                 align 4
.text$mn:000105DB _text$mn        ends
.text$mn:000105DB
.text$mn:000105DC ; ===========================================================================
.text$mn:000105DC
.text$mn:000105DC ; Segment type: Pure code
.text$mn:000105DC ; Segment permissions: Read/Execute
.text$mn:000105DC _text$mn        segment para public 'CODE' use32
.text$mn:000105DC                 assume cs:_text$mn
.text$mn:000105DC                 ;org 105DCh
.text$mn:000105DC ; COMDAT (pick any)
.text$mn:000105DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000105DC
.text$mn:000105DC ; =============== S U B R O U T I N E =======================================
.text$mn:000105DC
.text$mn:000105DC ; Attributes: bp-based frame
.text$mn:000105DC
.text$mn:000105DC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:000105DC                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:000105DC ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000105DC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:000105DC
.text$mn:000105DC var_4           = dword ptr -4
.text$mn:000105DC arg_0           = dword ptr  8
.text$mn:000105DC
.text$mn:000105DC                 push    ebp
.text$mn:000105DD                 mov     ebp, esp
.text$mn:000105DF                 push    ecx
.text$mn:000105E0                 mov     [ebp+var_4], ecx
.text$mn:000105E3                 mov     eax, [ebp+var_4]
.text$mn:000105E6                 mov     ecx, [eax+14h]
.text$mn:000105E9                 cmp     ecx, [ebp+arg_0]
.text$mn:000105EC                 jnb     short loc_105F6
.text$mn:000105EE                 mov     ecx, [ebp+var_4]
.text$mn:000105F1                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:000105F6
.text$mn:000105F6 loc_105F6:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:000105F6                 mov     edx, [ebp+arg_0]
.text$mn:000105F9                 push    edx
.text$mn:000105FA                 mov     ecx, [ebp+var_4]
.text$mn:000105FD                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00010602                 mov     eax, [ebp+var_4]
.text$mn:00010605                 mov     esp, ebp
.text$mn:00010607                 pop     ebp
.text$mn:00010608                 retn    4
.text$mn:00010608 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:00010608
.text$mn:00010608 ; ---------------------------------------------------------------------------
.text$mn:0001060B                 align 4
.text$mn:0001060B _text$mn        ends
.text$mn:0001060B
.text$mn:0001060C ; ===========================================================================
.text$mn:0001060C
.text$mn:0001060C ; Segment type: Pure code
.text$mn:0001060C ; Segment permissions: Read/Execute
.text$mn:0001060C _text$mn        segment para public 'CODE' use32
.text$mn:0001060C                 assume cs:_text$mn
.text$mn:0001060C                 ;org 1060Ch
.text$mn:0001060C ; COMDAT (pick any)
.text$mn:0001060C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0001060C
.text$mn:0001060C ; =============== S U B R O U T I N E =======================================
.text$mn:0001060C
.text$mn:0001060C ; Attributes: bp-based frame
.text$mn:0001060C
.text$mn:0001060C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:0001060C                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:0001060C ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0001060C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:0001060C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+10Cp
.text$mn:0001060C
.text$mn:0001060C var_C           = dword ptr -0Ch
.text$mn:0001060C Dst             = dword ptr -8
.text$mn:0001060C var_4           = dword ptr -4
.text$mn:0001060C arg_0           = dword ptr  8
.text$mn:0001060C arg_4           = dword ptr  0Ch
.text$mn:0001060C
.text$mn:0001060C                 push    ebp
.text$mn:0001060D                 mov     ebp, esp
.text$mn:0001060F                 sub     esp, 0Ch
.text$mn:00010612                 mov     [ebp+var_4], ecx
.text$mn:00010615                 mov     eax, [ebp+var_4]
.text$mn:00010618                 mov     ecx, [eax+14h]
.text$mn:0001061B                 cmp     ecx, [ebp+arg_0]
.text$mn:0001061E                 jnb     short loc_10628
.text$mn:00010620                 mov     ecx, [ebp+var_4]
.text$mn:00010623                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00010628
.text$mn:00010628 loc_10628:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:00010628                 mov     edx, [ebp+var_4]
.text$mn:0001062B                 mov     eax, [edx+14h]
.text$mn:0001062E                 sub     eax, [ebp+arg_0]
.text$mn:00010631                 cmp     eax, [ebp+arg_4]
.text$mn:00010634                 ja      short loc_10644
.text$mn:00010636                 mov     ecx, [ebp+arg_0]
.text$mn:00010639                 push    ecx
.text$mn:0001063A                 mov     ecx, [ebp+var_4]
.text$mn:0001063D                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00010642                 jmp     short loc_10690
.text$mn:00010644 ; ---------------------------------------------------------------------------
.text$mn:00010644
.text$mn:00010644 loc_10644:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:00010644                 cmp     [ebp+arg_4], 0
.text$mn:00010648                 jbe     short loc_10690
.text$mn:0001064A                 mov     ecx, [ebp+var_4]
.text$mn:0001064D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00010652                 mov     edx, [ebp+arg_0]
.text$mn:00010655                 lea     eax, [eax+edx*2]
.text$mn:00010658                 mov     [ebp+Dst], eax
.text$mn:0001065B                 mov     ecx, [ebp+var_4]
.text$mn:0001065E                 mov     edx, [ecx+14h]
.text$mn:00010661                 sub     edx, [ebp+arg_4]
.text$mn:00010664                 mov     [ebp+var_C], edx
.text$mn:00010667                 mov     eax, [ebp+var_C]
.text$mn:0001066A                 sub     eax, [ebp+arg_0]
.text$mn:0001066D                 push    eax             ; int
.text$mn:0001066E                 mov     ecx, [ebp+arg_4]
.text$mn:00010671                 mov     edx, [ebp+Dst]
.text$mn:00010674                 lea     eax, [edx+ecx*2]
.text$mn:00010677                 push    eax             ; Src
.text$mn:00010678                 mov     ecx, [ebp+Dst]
.text$mn:0001067B                 push    ecx             ; Dst
.text$mn:0001067C                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00010681                 add     esp, 0Ch
.text$mn:00010684                 mov     edx, [ebp+var_C]
.text$mn:00010687                 push    edx
.text$mn:00010688                 mov     ecx, [ebp+var_4]
.text$mn:0001068B                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00010690
.text$mn:00010690 loc_10690:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:00010690                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:00010690                 mov     eax, [ebp+var_4]
.text$mn:00010693                 mov     esp, ebp
.text$mn:00010695                 pop     ebp
.text$mn:00010696                 retn    8
.text$mn:00010696 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:00010696
.text$mn:00010696 ; ---------------------------------------------------------------------------
.text$mn:00010699                 align 4
.text$mn:00010699 _text$mn        ends
.text$mn:00010699
.text$mn:0001069C ; ===========================================================================
.text$mn:0001069C
.text$mn:0001069C ; Segment type: Pure code
.text$mn:0001069C ; Segment permissions: Read/Execute
.text$mn:0001069C _text$mn        segment para public 'CODE' use32
.text$mn:0001069C                 assume cs:_text$mn
.text$mn:0001069C                 ;org 1069Ch
.text$mn:0001069C ; COMDAT (pick any)
.text$mn:0001069C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0001069C
.text$mn:0001069C ; =============== S U B R O U T I N E =======================================
.text$mn:0001069C
.text$mn:0001069C ; Attributes: bp-based frame
.text$mn:0001069C
.text$mn:0001069C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>> __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::erase(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct sessionFileInfo>>>)
.text$mn:0001069C                 public ?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z
.text$mn:0001069C ?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z proc near
.text$mn:0001069C                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+126p
.text$mn:0001069C                                         ; Notepad_plus::loadSession(Session &,bool)+5EBp ...
.text$mn:0001069C
.text$mn:0001069C var_24          = dword ptr -24h
.text$mn:0001069C var_20          = dword ptr -20h
.text$mn:0001069C var_1C          = dword ptr -1Ch
.text$mn:0001069C var_18          = dword ptr -18h
.text$mn:0001069C var_14          = dword ptr -14h
.text$mn:0001069C var_10          = dword ptr -10h
.text$mn:0001069C var_C           = dword ptr -0Ch
.text$mn:0001069C var_4           = dword ptr -4
.text$mn:0001069C arg_0           = dword ptr  8
.text$mn:0001069C arg_4           = byte ptr  0Ch
.text$mn:0001069C arg_C           = dword ptr  14h
.text$mn:0001069C
.text$mn:0001069C                 push    ebp
.text$mn:0001069D                 mov     ebp, esp
.text$mn:0001069F                 push    0FFFFFFFFh
.text$mn:000106A1                 push    offset __ehhandler$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z
.text$mn:000106A6                 mov     eax, large fs:0
.text$mn:000106AC                 push    eax
.text$mn:000106AD                 sub     esp, 18h
.text$mn:000106B0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000106B5                 xor     eax, ebp
.text$mn:000106B7                 push    eax
.text$mn:000106B8                 lea     eax, [ebp+var_C]
.text$mn:000106BB                 mov     large fs:0, eax
.text$mn:000106C1                 mov     [ebp+var_10], ecx
.text$mn:000106C4                 mov     [ebp+var_14], 0
.text$mn:000106CB                 mov     [ebp+var_4], 1
.text$mn:000106D2                 lea     ecx, [ebp+arg_4] ; this
.text$mn:000106D5                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000106DA                 cmp     eax, [ebp+var_10]
.text$mn:000106DD                 jnz     short loc_106F5
.text$mn:000106DF                 mov     eax, [ebp+var_10]
.text$mn:000106E2                 mov     ecx, [ebp+arg_C]
.text$mn:000106E5                 cmp     ecx, [eax+4]
.text$mn:000106E8                 jb      short loc_106F5
.text$mn:000106EA                 mov     edx, [ebp+var_10]
.text$mn:000106ED                 mov     eax, [edx+8]
.text$mn:000106F0                 cmp     eax, [ebp+arg_C]
.text$mn:000106F3                 ja      short loc_1070C
.text$mn:000106F5
.text$mn:000106F5 loc_106F5:                              ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)+41j
.text$mn:000106F5                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)+4Cj
.text$mn:000106F5                 push    5A2h            ; unsigned int
.text$mn:000106FA                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000106FF                 push    offset ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ ; "vector erase iterator outside range"
.text$mn:00010704                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00010709                 add     esp, 0Ch
.text$mn:0001070C
.text$mn:0001070C loc_1070C:                              ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)+57j
.text$mn:0001070C                 mov     ecx, [ebp+arg_C]
.text$mn:0001070F                 push    ecx
.text$mn:00010710                 mov     edx, [ebp+var_10]
.text$mn:00010713                 mov     eax, [edx+8]
.text$mn:00010716                 push    eax
.text$mn:00010717                 mov     ecx, [ebp+arg_C]
.text$mn:0001071A                 add     ecx, 98h ; 'ÿ'
.text$mn:00010720                 push    ecx
.text$mn:00010721                 call    ??$_Move@PAUsessionFileInfo@@PAU1@@std@@YAPAUsessionFileInfo@@PAU1@00@Z ; std::_Move<sessionFileInfo *,sessionFileInfo *>(sessionFileInfo *,sessionFileInfo *,sessionFileInfo *)
.text$mn:00010726                 add     esp, 0Ch
.text$mn:00010729                 mov     edx, [ebp+var_10]
.text$mn:0001072C                 mov     eax, [edx+8]
.text$mn:0001072F                 push    eax
.text$mn:00010730                 mov     ecx, [ebp+var_10]
.text$mn:00010733                 mov     edx, [ecx+8]
.text$mn:00010736                 sub     edx, 98h ; 'ÿ'
.text$mn:0001073C                 push    edx
.text$mn:0001073D                 mov     ecx, [ebp+var_10]
.text$mn:00010740                 call    ?_Destroy@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXPAUsessionFileInfo@@0@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Destroy(sessionFileInfo *,sessionFileInfo *)
.text$mn:00010745                 mov     eax, [ebp+var_10]
.text$mn:00010748                 mov     ecx, [eax+8]
.text$mn:0001074B                 push    ecx
.text$mn:0001074C                 mov     edx, [ebp+arg_C]
.text$mn:0001074F                 push    edx
.text$mn:00010750                 mov     ecx, [ebp+var_10]
.text$mn:00010753                 call    ?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Orphan_range(sessionFileInfo *,sessionFileInfo *)
.text$mn:00010758                 mov     eax, [ebp+var_10]
.text$mn:0001075B                 mov     ecx, [eax+8]
.text$mn:0001075E                 sub     ecx, 98h ; 'ÿ'
.text$mn:00010764                 mov     edx, [ebp+var_10]
.text$mn:00010767                 mov     [edx+8], ecx
.text$mn:0001076A                 sub     esp, 0Ch
.text$mn:0001076D                 mov     ecx, esp
.text$mn:0001076F                 mov     [ebp+var_1C], esp
.text$mn:00010772                 lea     eax, [ebp+arg_4]
.text$mn:00010775                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00010776                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>> const &)
.text$mn:0001077B                 mov     [ebp+var_18], eax
.text$mn:0001077E                 mov     ecx, [ebp+var_18]
.text$mn:00010781                 mov     [ebp+var_20], ecx
.text$mn:00010784                 mov     byte ptr [ebp+var_4], 2
.text$mn:00010788                 mov     edx, [ebp+arg_0]
.text$mn:0001078B                 push    edx
.text$mn:0001078C                 mov     byte ptr [ebp+var_4], 1
.text$mn:00010790                 mov     ecx, [ebp+var_10]
.text$mn:00010793                 call    ?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)
.text$mn:00010798                 mov     [ebp+var_24], eax
.text$mn:0001079B                 mov     eax, [ebp+var_14]
.text$mn:0001079E                 or      eax, 1
.text$mn:000107A1                 mov     [ebp+var_14], eax
.text$mn:000107A4                 mov     byte ptr [ebp+var_4], 0
.text$mn:000107A8                 lea     ecx, [ebp+arg_4]
.text$mn:000107AB                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$mn:000107B0                 mov     eax, [ebp+arg_0]
.text$mn:000107B3                 mov     ecx, [ebp+var_C]
.text$mn:000107B6                 mov     large fs:0, ecx
.text$mn:000107BD                 pop     ecx
.text$mn:000107BE                 mov     esp, ebp
.text$mn:000107C0                 pop     ebp
.text$mn:000107C1                 retn    10h
.text$mn:000107C1 ?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z endp
.text$mn:000107C1
.text$mn:000107C1 _text$mn        ends
.text$mn:000107C1
.text$x:000107C4 ; ===========================================================================
.text$x:000107C4
.text$x:000107C4 ; Segment type: Pure code
.text$x:000107C4 ; Segment permissions: Read/Execute
.text$x:000107C4 _text$x         segment para public 'CODE' use32
.text$x:000107C4                 assume cs:_text$x
.text$x:000107C4                 ;org 107C4h
.text$x:000107C4 ; COMDAT (pick associative to section at 1069C)
.text$x:000107C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000107C4
.text$x:000107C4 ; =============== S U B R O U T I N E =======================================
.text$x:000107C4
.text$x:000107C4
.text$x:000107C4 __unwindfunclet$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$0 proc near
.text$x:000107C4                                         ; DATA XREF: .xdata$x:00013294o
.text$x:000107C4                 lea     ecx, [ebp+0Ch]
.text$x:000107C7                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:000107C7 __unwindfunclet$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$0 endp
.text$x:000107C7
.text$x:000107CC
.text$x:000107CC ; =============== S U B R O U T I N E =======================================
.text$x:000107CC
.text$x:000107CC
.text$x:000107CC __unwindfunclet$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$1 proc near
.text$x:000107CC                                         ; DATA XREF: .xdata$x:0001329Co
.text$x:000107CC                 mov     ecx, [ebp-1Ch]
.text$x:000107CF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:000107CF __unwindfunclet$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$1 endp
.text$x:000107CF
.text$x:000107D4
.text$x:000107D4 ; =============== S U B R O U T I N E =======================================
.text$x:000107D4
.text$x:000107D4
.text$x:000107D4 __unwindfunclet$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$2 proc near
.text$x:000107D4                                         ; DATA XREF: .xdata$x:0001328Co
.text$x:000107D4                 mov     eax, [ebp-14h]
.text$x:000107D7                 and     eax, 1
.text$x:000107DA                 jz      $LN8_0
.text$x:000107E0                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:000107E4                 mov     ecx, [ebp+8]
.text$x:000107E7                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>(void)
.text$x:000107EC ; ---------------------------------------------------------------------------
.text$x:000107EC
.text$x:000107EC $LN8_0:                                 ; CODE XREF: __unwindfunclet$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$2+6j
.text$x:000107EC                 retn
.text$x:000107EC __unwindfunclet$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$2 endp
.text$x:000107EC
.text$x:000107ED
.text$x:000107ED ; =============== S U B R O U T I N E =======================================
.text$x:000107ED
.text$x:000107ED
.text$x:000107ED __ehhandler$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z proc near
.text$x:000107ED                                         ; DATA XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)+5o
.text$x:000107ED
.text$x:000107ED arg_4           = dword ptr  8
.text$x:000107ED
.text$x:000107ED                 mov     edx, [esp+arg_4]
.text$x:000107F1                 lea     eax, [edx+0Ch]
.text$x:000107F4                 mov     ecx, [edx-1Ch]
.text$x:000107F7                 xor     ecx, eax
.text$x:000107F9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000107FE                 mov     eax, offset __ehfuncinfo$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z
.text$x:00010803                 jmp     ___CxxFrameHandler3
.text$x:00010803 __ehhandler$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z endp
.text$x:00010803
.text$x:00010803 _text$x         ends
.text$x:00010803
.text$mn:00010808 ; ===========================================================================
.text$mn:00010808
.text$mn:00010808 ; Segment type: Pure code
.text$mn:00010808 ; Segment permissions: Read/Execute
.text$mn:00010808 _text$mn        segment para public 'CODE' use32
.text$mn:00010808                 assume cs:_text$mn
.text$mn:00010808                 ;org 10808h
.text$mn:00010808 ; COMDAT (pick any)
.text$mn:00010808                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010808
.text$mn:00010808 ; =============== S U B R O U T I N E =======================================
.text$mn:00010808
.text$mn:00010808 ; Attributes: bp-based frame
.text$mn:00010808
.text$mn:00010808 ; __int32 __thiscall ScintillaEditView::execute(ScintillaEditView *this, unsigned int, unsigned int, __int32)
.text$mn:00010808                 public ?execute@ScintillaEditView@@QBEJIIJ@Z
.text$mn:00010808 ?execute@ScintillaEditView@@QBEJIIJ@Z proc near
.text$mn:00010808                                         ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+CAp
.text$mn:00010808                                         ; Notepad_plus::doReload(Buffer *,bool)+F7p ...
.text$mn:00010808
.text$mn:00010808 var_4           = dword ptr -4
.text$mn:00010808 arg_0           = dword ptr  8
.text$mn:00010808 arg_4           = dword ptr  0Ch
.text$mn:00010808 arg_8           = dword ptr  10h
.text$mn:00010808
.text$mn:00010808                 push    ebp
.text$mn:00010809                 mov     ebp, esp
.text$mn:0001080B                 push    ecx
.text$mn:0001080C                 mov     [ebp+var_4], ecx
.text$mn:0001080F                 mov     eax, [ebp+arg_8]
.text$mn:00010812                 push    eax
.text$mn:00010813                 mov     ecx, [ebp+arg_4]
.text$mn:00010816                 push    ecx
.text$mn:00010817                 mov     edx, [ebp+arg_0]
.text$mn:0001081A                 push    edx
.text$mn:0001081B                 mov     eax, [ebp+var_4]
.text$mn:0001081E                 mov     ecx, [eax+14h]
.text$mn:00010821                 push    ecx
.text$mn:00010822                 mov     edx, [ebp+var_4]
.text$mn:00010825                 mov     eax, [edx+10h]
.text$mn:00010828                 call    eax
.text$mn:0001082A                 add     esp, 10h
.text$mn:0001082D                 mov     esp, ebp
.text$mn:0001082F                 pop     ebp
.text$mn:00010830                 retn    0Ch
.text$mn:00010830 ?execute@ScintillaEditView@@QBEJIIJ@Z endp
.text$mn:00010830
.text$mn:00010830 ; ---------------------------------------------------------------------------
.text$mn:00010833                 align 4
.text$mn:00010833 _text$mn        ends
.text$mn:00010833
.text$mn:00010834 ; ===========================================================================
.text$mn:00010834
.text$mn:00010834 ; Segment type: Pure code
.text$mn:00010834 ; Segment permissions: Read/Execute
.text$mn:00010834 _text$mn        segment para public 'CODE' use32
.text$mn:00010834                 assume cs:_text$mn
.text$mn:00010834                 ;org 10834h
.text$mn:00010834 ; COMDAT (pick any)
.text$mn:00010834                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010834
.text$mn:00010834 ; =============== S U B R O U T I N E =======================================
.text$mn:00010834
.text$mn:00010834 ; Attributes: bp-based frame
.text$mn:00010834
.text$mn:00010834 ; public: static wchar_t const * __cdecl std::char_traits<wchar_t>::find(wchar_t const *, unsigned int, wchar_t const &)
.text$mn:00010834                 public ?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z
.text$mn:00010834 ?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z proc near
.text$mn:00010834                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_of(wchar_t const *,uint,uint)+7Ap
.text$mn:00010834
.text$mn:00010834 var_4           = dword ptr -4
.text$mn:00010834 arg_0           = dword ptr  8
.text$mn:00010834 arg_4           = dword ptr  0Ch
.text$mn:00010834 arg_8           = dword ptr  10h
.text$mn:00010834
.text$mn:00010834                 push    ebp
.text$mn:00010835                 mov     ebp, esp
.text$mn:00010837                 push    ecx
.text$mn:00010838                 cmp     [ebp+arg_4], 0
.text$mn:0001083C                 jnz     short loc_10847
.text$mn:0001083E                 mov     [ebp+var_4], 0
.text$mn:00010845                 jmp     short loc_10861
.text$mn:00010847 ; ---------------------------------------------------------------------------
.text$mn:00010847
.text$mn:00010847 loc_10847:                              ; CODE XREF: std::char_traits<wchar_t>::find(wchar_t const *,uint,wchar_t const &)+8j
.text$mn:00010847                 mov     eax, [ebp+arg_4]
.text$mn:0001084A                 push    eax
.text$mn:0001084B                 mov     ecx, [ebp+arg_8]
.text$mn:0001084E                 movzx   edx, word ptr [ecx]
.text$mn:00010851                 push    edx
.text$mn:00010852                 mov     eax, [ebp+arg_0]
.text$mn:00010855                 push    eax
.text$mn:00010856                 call    _wmemchr
.text$mn:0001085B                 add     esp, 0Ch
.text$mn:0001085E                 mov     [ebp+var_4], eax
.text$mn:00010861
.text$mn:00010861 loc_10861:                              ; CODE XREF: std::char_traits<wchar_t>::find(wchar_t const *,uint,wchar_t const &)+11j
.text$mn:00010861                 mov     eax, [ebp+var_4]
.text$mn:00010864                 mov     esp, ebp
.text$mn:00010866                 pop     ebp
.text$mn:00010867                 retn
.text$mn:00010867 ?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z endp
.text$mn:00010867
.text$mn:00010867 _text$mn        ends
.text$mn:00010867
.text$mn:00010868 ; ===========================================================================
.text$mn:00010868
.text$mn:00010868 ; Segment type: Pure code
.text$mn:00010868 ; Segment permissions: Read/Execute
.text$mn:00010868 _text$mn        segment para public 'CODE' use32
.text$mn:00010868                 assume cs:_text$mn
.text$mn:00010868                 ;org 10868h
.text$mn:00010868 ; COMDAT (pick any)
.text$mn:00010868                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010868
.text$mn:00010868 ; =============== S U B R O U T I N E =======================================
.text$mn:00010868
.text$mn:00010868 ; Attributes: bp-based frame
.text$mn:00010868
.text$mn:00010868 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_of(wchar_t *Str, int)
.text$mn:00010868                 public ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WI@Z
.text$mn:00010868 ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WI@Z proc near
.text$mn:00010868                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+169p
.text$mn:00010868
.text$mn:00010868 var_4           = dword ptr -4
.text$mn:00010868 Str             = dword ptr  8
.text$mn:00010868 arg_4           = dword ptr  0Ch
.text$mn:00010868
.text$mn:00010868                 push    ebp
.text$mn:00010869                 mov     ebp, esp
.text$mn:0001086B                 push    ecx
.text$mn:0001086C                 mov     [ebp+var_4], ecx
.text$mn:0001086F                 push    7CFh            ; unsigned int
.text$mn:00010874                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00010879                 mov     eax, [ebp+Str]
.text$mn:0001087C                 push    eax             ; int
.text$mn:0001087D                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00010882                 add     esp, 0Ch
.text$mn:00010885                 mov     ecx, [ebp+Str]
.text$mn:00010888                 push    ecx             ; Str
.text$mn:00010889                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0001088E                 add     esp, 4
.text$mn:00010891                 push    eax
.text$mn:00010892                 mov     edx, [ebp+arg_4]
.text$mn:00010895                 push    edx
.text$mn:00010896                 mov     eax, [ebp+Str]
.text$mn:00010899                 push    eax
.text$mn:0001089A                 mov     ecx, [ebp+var_4]
.text$mn:0001089D                 call    ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_of(wchar_t const *,uint,uint)
.text$mn:000108A2                 mov     esp, ebp
.text$mn:000108A4                 pop     ebp
.text$mn:000108A5                 retn    8
.text$mn:000108A5 ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WI@Z endp
.text$mn:000108A5
.text$mn:000108A5 _text$mn        ends
.text$mn:000108A5
.text$mn:000108A8 ; ===========================================================================
.text$mn:000108A8
.text$mn:000108A8 ; Segment type: Pure code
.text$mn:000108A8 ; Segment permissions: Read/Execute
.text$mn:000108A8 _text$mn        segment para public 'CODE' use32
.text$mn:000108A8                 assume cs:_text$mn
.text$mn:000108A8                 ;org 108A8h
.text$mn:000108A8 ; COMDAT (pick any)
.text$mn:000108A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000108A8
.text$mn:000108A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000108A8
.text$mn:000108A8 ; Attributes: bp-based frame
.text$mn:000108A8
.text$mn:000108A8 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::find_first_of(wchar_t const *, unsigned int, unsigned int)const
.text$mn:000108A8                 public ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z
.text$mn:000108A8 ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z proc near
.text$mn:000108A8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_of(wchar_t const *,uint)+35p
.text$mn:000108A8
.text$mn:000108A8 var_C           = dword ptr -0Ch
.text$mn:000108A8 var_8           = dword ptr -8
.text$mn:000108A8 var_4           = dword ptr -4
.text$mn:000108A8 arg_0           = dword ptr  8
.text$mn:000108A8 arg_4           = dword ptr  0Ch
.text$mn:000108A8 arg_8           = dword ptr  10h
.text$mn:000108A8
.text$mn:000108A8                 push    ebp
.text$mn:000108A9                 mov     ebp, esp
.text$mn:000108AB                 sub     esp, 0Ch
.text$mn:000108AE                 mov     [ebp+var_4], ecx
.text$mn:000108B1                 cmp     [ebp+arg_8], 0
.text$mn:000108B5                 jz      short loc_108CD
.text$mn:000108B7                 push    7BDh            ; unsigned int
.text$mn:000108BC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000108C1                 mov     eax, [ebp+arg_0]
.text$mn:000108C4                 push    eax             ; int
.text$mn:000108C5                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000108CA                 add     esp, 0Ch
.text$mn:000108CD
.text$mn:000108CD loc_108CD:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_of(wchar_t const *,uint,uint)+Dj
.text$mn:000108CD                 cmp     [ebp+arg_8], 0
.text$mn:000108D1                 jbe     short loc_10943
.text$mn:000108D3                 mov     ecx, [ebp+var_4]
.text$mn:000108D6                 mov     edx, [ebp+arg_4]
.text$mn:000108D9                 cmp     edx, [ecx+14h]
.text$mn:000108DC                 jnb     short loc_10943
.text$mn:000108DE                 mov     ecx, [ebp+var_4]
.text$mn:000108E1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000108E6                 mov     ecx, [ebp+var_4]
.text$mn:000108E9                 mov     edx, [ecx+14h]
.text$mn:000108EC                 lea     eax, [eax+edx*2]
.text$mn:000108EF                 mov     [ebp+var_C], eax
.text$mn:000108F2                 mov     ecx, [ebp+var_4]
.text$mn:000108F5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000108FA                 mov     ecx, [ebp+arg_4]
.text$mn:000108FD                 lea     edx, [eax+ecx*2]
.text$mn:00010900                 mov     [ebp+var_8], edx
.text$mn:00010903                 jmp     short loc_1090E
.text$mn:00010905 ; ---------------------------------------------------------------------------
.text$mn:00010905
.text$mn:00010905 loc_10905:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_of(wchar_t const *,uint,uint):loc_10941j
.text$mn:00010905                 mov     eax, [ebp+var_8]
.text$mn:00010908                 add     eax, 2
.text$mn:0001090B                 mov     [ebp+var_8], eax
.text$mn:0001090E
.text$mn:0001090E loc_1090E:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_of(wchar_t const *,uint,uint)+5Bj
.text$mn:0001090E                 mov     ecx, [ebp+var_8]
.text$mn:00010911                 cmp     ecx, [ebp+var_C]
.text$mn:00010914                 jnb     short loc_10943
.text$mn:00010916                 mov     edx, [ebp+var_8]
.text$mn:00010919                 push    edx
.text$mn:0001091A                 mov     eax, [ebp+arg_8]
.text$mn:0001091D                 push    eax
.text$mn:0001091E                 mov     ecx, [ebp+arg_0]
.text$mn:00010921                 push    ecx
.text$mn:00010922                 call    ?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z ; std::char_traits<wchar_t>::find(wchar_t const *,uint,wchar_t const &)
.text$mn:00010927                 add     esp, 0Ch
.text$mn:0001092A                 test    eax, eax
.text$mn:0001092C                 jz      short loc_10941
.text$mn:0001092E                 mov     ecx, [ebp+var_4]
.text$mn:00010931                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00010936                 mov     edx, [ebp+var_8]
.text$mn:00010939                 sub     edx, eax
.text$mn:0001093B                 sar     edx, 1
.text$mn:0001093D                 mov     eax, edx
.text$mn:0001093F                 jmp     short loc_10948
.text$mn:00010941 ; ---------------------------------------------------------------------------
.text$mn:00010941
.text$mn:00010941 loc_10941:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_of(wchar_t const *,uint,uint)+84j
.text$mn:00010941                 jmp     short loc_10905
.text$mn:00010943 ; ---------------------------------------------------------------------------
.text$mn:00010943
.text$mn:00010943 loc_10943:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_of(wchar_t const *,uint,uint)+29j
.text$mn:00010943                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_of(wchar_t const *,uint,uint)+34j ...
.text$mn:00010943                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00010948
.text$mn:00010948 loc_10948:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_of(wchar_t const *,uint,uint)+97j
.text$mn:00010948                 mov     esp, ebp
.text$mn:0001094A                 pop     ebp
.text$mn:0001094B                 retn    0Ch
.text$mn:0001094B ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z endp
.text$mn:0001094B
.text$mn:0001094B ; ---------------------------------------------------------------------------
.text$mn:0001094E                 align 10h
.text$mn:0001094E _text$mn        ends
.text$mn:0001094E
.text$mn:00010950 ; ===========================================================================
.text$mn:00010950
.text$mn:00010950 ; Segment type: Pure code
.text$mn:00010950 ; Segment permissions: Read/Execute
.text$mn:00010950 _text$mn        segment para public 'CODE' use32
.text$mn:00010950                 assume cs:_text$mn
.text$mn:00010950                 ;org 10950h
.text$mn:00010950 ; COMDAT (pick any)
.text$mn:00010950                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010950
.text$mn:00010950 ; =============== S U B R O U T I N E =======================================
.text$mn:00010950
.text$mn:00010950 ; Attributes: bp-based frame
.text$mn:00010950
.text$mn:00010950 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00010950                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00010950 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00010950                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00010950                 push    ebp
.text$mn:00010951                 mov     ebp, esp
.text$mn:00010953                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00010958                 pop     ebp
.text$mn:00010959                 retn
.text$mn:00010959 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00010959
.text$mn:00010959 ; ---------------------------------------------------------------------------
.text$mn:0001095A                 align 4
.text$mn:0001095A _text$mn        ends
.text$mn:0001095A
.text$mn:0001095C ; ===========================================================================
.text$mn:0001095C
.text$mn:0001095C ; Segment type: Pure code
.text$mn:0001095C ; Segment permissions: Read/Execute
.text$mn:0001095C _text$mn        segment para public 'CODE' use32
.text$mn:0001095C                 assume cs:_text$mn
.text$mn:0001095C                 ;org 1095Ch
.text$mn:0001095C ; COMDAT (pick any)
.text$mn:0001095C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0001095C
.text$mn:0001095C ; =============== S U B R O U T I N E =======================================
.text$mn:0001095C
.text$mn:0001095C ; Attributes: bp-based frame
.text$mn:0001095C
.text$mn:0001095C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall Buffer::getBackupFileName(void)const
.text$mn:0001095C                 public ?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
.text$mn:0001095C ?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ proc near
.text$mn:0001095C                                         ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+106p
.text$mn:0001095C                                         ; Notepad_plus::fileCloseAll(bool,bool)+156p ...
.text$mn:0001095C
.text$mn:0001095C var_14          = dword ptr -14h
.text$mn:0001095C var_10          = dword ptr -10h
.text$mn:0001095C var_C           = dword ptr -0Ch
.text$mn:0001095C var_4           = dword ptr -4
.text$mn:0001095C arg_0           = dword ptr  8
.text$mn:0001095C
.text$mn:0001095C                 push    ebp
.text$mn:0001095D                 mov     ebp, esp
.text$mn:0001095F                 push    0FFFFFFFFh
.text$mn:00010961                 push    offset __ehhandler$?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
.text$mn:00010966                 mov     eax, large fs:0
.text$mn:0001096C                 push    eax
.text$mn:0001096D                 sub     esp, 8
.text$mn:00010970                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00010975                 xor     eax, ebp
.text$mn:00010977                 push    eax
.text$mn:00010978                 lea     eax, [ebp+var_C]
.text$mn:0001097B                 mov     large fs:0, eax
.text$mn:00010981                 mov     [ebp+var_14], ecx
.text$mn:00010984                 mov     [ebp+var_10], 0
.text$mn:0001098B                 mov     eax, [ebp+var_14]
.text$mn:0001098E                 add     eax, 0B4h ; '¦'
.text$mn:00010993                 push    eax
.text$mn:00010994                 mov     ecx, [ebp+arg_0]
.text$mn:00010997                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0001099C                 mov     [ebp+var_4], 0
.text$mn:000109A3                 mov     ecx, [ebp+var_10]
.text$mn:000109A6                 or      ecx, 1
.text$mn:000109A9                 mov     [ebp+var_10], ecx
.text$mn:000109AC                 mov     eax, [ebp+arg_0]
.text$mn:000109AF                 mov     ecx, [ebp+var_C]
.text$mn:000109B2                 mov     large fs:0, ecx
.text$mn:000109B9                 pop     ecx
.text$mn:000109BA                 mov     esp, ebp
.text$mn:000109BC                 pop     ebp
.text$mn:000109BD                 retn    4
.text$mn:000109BD ?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ endp
.text$mn:000109BD
.text$mn:000109BD _text$mn        ends
.text$mn:000109BD
.text$x:000109C0 ; ===========================================================================
.text$x:000109C0
.text$x:000109C0 ; Segment type: Pure code
.text$x:000109C0 ; Segment permissions: Read/Execute
.text$x:000109C0 _text$x         segment para public 'CODE' use32
.text$x:000109C0                 assume cs:_text$x
.text$x:000109C0                 ;org 109C0h
.text$x:000109C0 ; COMDAT (pick associative to section at 1095C)
.text$x:000109C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000109C0
.text$x:000109C0 ; =============== S U B R O U T I N E =======================================
.text$x:000109C0
.text$x:000109C0
.text$x:000109C0 __unwindfunclet$?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$0 proc near
.text$x:000109C0                                         ; DATA XREF: .xdata$x:00013574o
.text$x:000109C0                 mov     eax, [ebp-10h]
.text$x:000109C3                 and     eax, 1
.text$x:000109C6                 jz      $LN4_9
.text$x:000109CC                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000109D0                 mov     ecx, [ebp+8]
.text$x:000109D3                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000109D8 ; ---------------------------------------------------------------------------
.text$x:000109D8
.text$x:000109D8 $LN4_9:                                 ; CODE XREF: __unwindfunclet$?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$0+6j
.text$x:000109D8                 retn
.text$x:000109D8 __unwindfunclet$?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$0 endp
.text$x:000109D8
.text$x:000109D9
.text$x:000109D9 ; =============== S U B R O U T I N E =======================================
.text$x:000109D9
.text$x:000109D9
.text$x:000109D9 __ehhandler$?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ proc near
.text$x:000109D9                                         ; DATA XREF: Buffer::getBackupFileName(void)+5o
.text$x:000109D9
.text$x:000109D9 arg_4           = dword ptr  8
.text$x:000109D9
.text$x:000109D9                 mov     edx, [esp+arg_4]
.text$x:000109DD                 lea     eax, [edx+0Ch]
.text$x:000109E0                 mov     ecx, [edx-0Ch]
.text$x:000109E3                 xor     ecx, eax
.text$x:000109E5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000109EA                 mov     eax, offset __ehfuncinfo$?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
.text$x:000109EF                 jmp     ___CxxFrameHandler3
.text$x:000109EF __ehhandler$?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ endp
.text$x:000109EF
.text$x:000109EF _text$x         ends
.text$x:000109EF
.text$mn:000109F4 ; ===========================================================================
.text$mn:000109F4
.text$mn:000109F4 ; Segment type: Pure code
.text$mn:000109F4 ; Segment permissions: Read/Execute
.text$mn:000109F4 _text$mn        segment para public 'CODE' use32
.text$mn:000109F4                 assume cs:_text$mn
.text$mn:000109F4                 ;org 109F4h
.text$mn:000109F4 ; COMDAT (pick any)
.text$mn:000109F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000109F4
.text$mn:000109F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000109F4
.text$mn:000109F4 ; Attributes: bp-based frame
.text$mn:000109F4
.text$mn:000109F4 ; struct Buffer *__thiscall FileManager::getBufferByID(FileManager *this, struct Buffer *)
.text$mn:000109F4                 public ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z
.text$mn:000109F4 ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z proc near
.text$mn:000109F4                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+68Bp
.text$mn:000109F4                                         ; Notepad_plus::doReload(Buffer *,bool)+13Fp ...
.text$mn:000109F4
.text$mn:000109F4 var_4           = dword ptr -4
.text$mn:000109F4 arg_0           = dword ptr  8
.text$mn:000109F4
.text$mn:000109F4                 push    ebp
.text$mn:000109F5                 mov     ebp, esp
.text$mn:000109F7                 push    ecx
.text$mn:000109F8                 mov     [ebp+var_4], ecx
.text$mn:000109FB                 mov     eax, [ebp+arg_0]
.text$mn:000109FE                 mov     esp, ebp
.text$mn:00010A00                 pop     ebp
.text$mn:00010A01                 retn    4
.text$mn:00010A01 ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z endp
.text$mn:00010A01
.text$mn:00010A01 _text$mn        ends
.text$mn:00010A01
.text$mn:00010A04 ; ===========================================================================
.text$mn:00010A04
.text$mn:00010A04 ; Segment type: Pure code
.text$mn:00010A04 ; Segment permissions: Read/Execute
.text$mn:00010A04 _text$mn        segment para public 'CODE' use32
.text$mn:00010A04                 assume cs:_text$mn
.text$mn:00010A04                 ;org 10A04h
.text$mn:00010A04 ; COMDAT (pick any)
.text$mn:00010A04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010A04
.text$mn:00010A04 ; =============== S U B R O U T I N E =======================================
.text$mn:00010A04
.text$mn:00010A04 ; Attributes: bp-based frame
.text$mn:00010A04
.text$mn:00010A04 ; struct Buffer *__thiscall ScintillaEditView::getCurrentBuffer(ScintillaEditView *__hidden this)
.text$mn:00010A04                 public ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ
.text$mn:00010A04 ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ proc near
.text$mn:00010A04                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+3A2p
.text$mn:00010A04                                         ; Notepad_plus::loadSession(Session &,bool)+9DAp
.text$mn:00010A04
.text$mn:00010A04 var_4           = dword ptr -4
.text$mn:00010A04
.text$mn:00010A04                 push    ebp
.text$mn:00010A05                 mov     ebp, esp
.text$mn:00010A07                 push    ecx
.text$mn:00010A08                 mov     [ebp+var_4], ecx
.text$mn:00010A0B                 mov     eax, [ebp+var_4]
.text$mn:00010A0E                 mov     eax, [eax+20h]
.text$mn:00010A11                 mov     esp, ebp
.text$mn:00010A13                 pop     ebp
.text$mn:00010A14                 retn
.text$mn:00010A14 ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ endp
.text$mn:00010A14
.text$mn:00010A14 ; ---------------------------------------------------------------------------
.text$mn:00010A15                 align 4
.text$mn:00010A15 _text$mn        ends
.text$mn:00010A15
.text$mn:00010A18 ; ===========================================================================
.text$mn:00010A18
.text$mn:00010A18 ; Segment type: Pure code
.text$mn:00010A18 ; Segment permissions: Read/Execute
.text$mn:00010A18 _text$mn        segment para public 'CODE' use32
.text$mn:00010A18                 assume cs:_text$mn
.text$mn:00010A18                 ;org 10A18h
.text$mn:00010A18 ; COMDAT (pick any)
.text$mn:00010A18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010A18
.text$mn:00010A18 ; =============== S U B R O U T I N E =======================================
.text$mn:00010A18
.text$mn:00010A18 ; Attributes: bp-based frame
.text$mn:00010A18
.text$mn:00010A18 ; struct Buffer *__thiscall ScintillaEditView::getCurrentBufferID(ScintillaEditView *__hidden this)
.text$mn:00010A18                 public ?getCurrentBufferID@ScintillaEditView@@QAEPAVBuffer@@XZ
.text$mn:00010A18 ?getCurrentBufferID@ScintillaEditView@@QAEPAVBuffer@@XZ proc near
.text$mn:00010A18                                         ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+59p
.text$mn:00010A18                                         ; Notepad_plus::doReload(Buffer *,bool)+82p ...
.text$mn:00010A18
.text$mn:00010A18 var_4           = dword ptr -4
.text$mn:00010A18
.text$mn:00010A18                 push    ebp
.text$mn:00010A19                 mov     ebp, esp
.text$mn:00010A1B                 push    ecx
.text$mn:00010A1C                 mov     [ebp+var_4], ecx
.text$mn:00010A1F                 mov     eax, [ebp+var_4]
.text$mn:00010A22                 mov     eax, [eax+1Ch]
.text$mn:00010A25                 mov     esp, ebp
.text$mn:00010A27                 pop     ebp
.text$mn:00010A28                 retn
.text$mn:00010A28 ?getCurrentBufferID@ScintillaEditView@@QAEPAVBuffer@@XZ endp
.text$mn:00010A28
.text$mn:00010A28 ; ---------------------------------------------------------------------------
.text$mn:00010A29                 align 4
.text$mn:00010A29 _text$mn        ends
.text$mn:00010A29
.text$mn:00010A2C ; ===========================================================================
.text$mn:00010A2C
.text$mn:00010A2C ; Segment type: Pure code
.text$mn:00010A2C ; Segment permissions: Read/Execute
.text$mn:00010A2C _text$mn        segment para public 'CODE' use32
.text$mn:00010A2C                 assume cs:_text$mn
.text$mn:00010A2C                 ;org 10A2Ch
.text$mn:00010A2C ; COMDAT (pick any)
.text$mn:00010A2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010A2C
.text$mn:00010A2C ; =============== S U B R O U T I N E =======================================
.text$mn:00010A2C
.text$mn:00010A2C ; Attributes: bp-based frame
.text$mn:00010A2C
.text$mn:00010A2C ; int __thiscall TabBar::getCurrentTabIndex(TabBar *__hidden this)
.text$mn:00010A2C                 public ?getCurrentTabIndex@TabBar@@QBEHXZ
.text$mn:00010A2C ?getCurrentTabIndex@TabBar@@QBEHXZ proc near
.text$mn:00010A2C                                         ; CODE XREF: Notepad_plus::fileCloseAllButCurrent(void)+23p
.text$mn:00010A2C                                         ; Notepad_plus::fileCloseAllToLeft(void)+40p ...
.text$mn:00010A2C
.text$mn:00010A2C var_4           = dword ptr -4
.text$mn:00010A2C
.text$mn:00010A2C                 push    ebp
.text$mn:00010A2D                 mov     ebp, esp
.text$mn:00010A2F                 push    ecx
.text$mn:00010A30                 mov     [ebp+var_4], ecx
.text$mn:00010A33                 push    0               ; lParam
.text$mn:00010A35                 push    0               ; wParam
.text$mn:00010A37                 push    130Bh           ; Msg
.text$mn:00010A3C                 mov     eax, [ebp+var_4]
.text$mn:00010A3F                 mov     ecx, [eax+0Ch]
.text$mn:00010A42                 push    ecx             ; hWnd
.text$mn:00010A43                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00010A49                 mov     esp, ebp
.text$mn:00010A4B                 pop     ebp
.text$mn:00010A4C                 retn
.text$mn:00010A4C ?getCurrentTabIndex@TabBar@@QBEHXZ endp
.text$mn:00010A4C
.text$mn:00010A4C ; ---------------------------------------------------------------------------
.text$mn:00010A4D                 align 10h
.text$mn:00010A4D _text$mn        ends
.text$mn:00010A4D
.text$mn:00010A50 ; ===========================================================================
.text$mn:00010A50
.text$mn:00010A50 ; Segment type: Pure code
.text$mn:00010A50 ; Segment permissions: Read/Execute
.text$mn:00010A50 _text$mn        segment para public 'CODE' use32
.text$mn:00010A50                 assume cs:_text$mn
.text$mn:00010A50                 ;org 10A50h
.text$mn:00010A50 ; COMDAT (pick any)
.text$mn:00010A50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010A50
.text$mn:00010A50 ; =============== S U B R O U T I N E =======================================
.text$mn:00010A50
.text$mn:00010A50 ; Attributes: bp-based frame
.text$mn:00010A50
.text$mn:00010A50 ; const wchar_t *__thiscall Lang::getDefaultExtList(Lang *__hidden this)
.text$mn:00010A50                 public ?getDefaultExtList@Lang@@QBEPB_WXZ
.text$mn:00010A50 ?getDefaultExtList@Lang@@QBEPB_WXZ proc near
.text$mn:00010A50                                         ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+101p
.text$mn:00010A50
.text$mn:00010A50 var_4           = dword ptr -4
.text$mn:00010A50
.text$mn:00010A50                 push    ebp
.text$mn:00010A51                 mov     ebp, esp
.text$mn:00010A53                 push    ecx
.text$mn:00010A54                 mov     [ebp+var_4], ecx
.text$mn:00010A57                 mov     eax, [ebp+var_4]
.text$mn:00010A5A                 mov     eax, [eax+20h]
.text$mn:00010A5D                 mov     esp, ebp
.text$mn:00010A5F                 pop     ebp
.text$mn:00010A60                 retn
.text$mn:00010A60 ?getDefaultExtList@Lang@@QBEPB_WXZ endp
.text$mn:00010A60
.text$mn:00010A60 ; ---------------------------------------------------------------------------
.text$mn:00010A61                 align 4
.text$mn:00010A61 _text$mn        ends
.text$mn:00010A61
.text$mn:00010A64 ; ===========================================================================
.text$mn:00010A64
.text$mn:00010A64 ; Segment type: Pure code
.text$mn:00010A64 ; Segment permissions: Read/Execute
.text$mn:00010A64 _text$mn        segment para public 'CODE' use32
.text$mn:00010A64                 assume cs:_text$mn
.text$mn:00010A64                 ;org 10A64h
.text$mn:00010A64 ; COMDAT (pick any)
.text$mn:00010A64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010A64
.text$mn:00010A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00010A64
.text$mn:00010A64 ; Attributes: bp-based frame
.text$mn:00010A64
.text$mn:00010A64 ; __int32 __thiscall Buffer::getDocument(Buffer *__hidden this)
.text$mn:00010A64                 public ?getDocument@Buffer@@QAEJXZ
.text$mn:00010A64 ?getDocument@Buffer@@QAEJXZ proc near   ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+152p
.text$mn:00010A64                                         ; Notepad_plus::doReload(Buffer *,bool)+186p ...
.text$mn:00010A64
.text$mn:00010A64 var_4           = dword ptr -4
.text$mn:00010A64
.text$mn:00010A64                 push    ebp
.text$mn:00010A65                 mov     ebp, esp
.text$mn:00010A67                 push    ecx
.text$mn:00010A68                 mov     [ebp+var_4], ecx
.text$mn:00010A6B                 mov     eax, [ebp+var_4]
.text$mn:00010A6E                 mov     eax, [eax+10h]
.text$mn:00010A71                 mov     esp, ebp
.text$mn:00010A73                 pop     ebp
.text$mn:00010A74                 retn
.text$mn:00010A74 ?getDocument@Buffer@@QAEJXZ endp
.text$mn:00010A74
.text$mn:00010A74 ; ---------------------------------------------------------------------------
.text$mn:00010A75                 align 4
.text$mn:00010A75 _text$mn        ends
.text$mn:00010A75
.text$mn:00010A78 ; ===========================================================================
.text$mn:00010A78
.text$mn:00010A78 ; Segment type: Pure code
.text$mn:00010A78 ; Segment permissions: Read/Execute
.text$mn:00010A78 _text$mn        segment para public 'CODE' use32
.text$mn:00010A78                 assume cs:_text$mn
.text$mn:00010A78                 ;org 10A78h
.text$mn:00010A78 ; COMDAT (pick any)
.text$mn:00010A78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010A78
.text$mn:00010A78 ; =============== S U B R O U T I N E =======================================
.text$mn:00010A78
.text$mn:00010A78 ; Attributes: bp-based frame
.text$mn:00010A78
.text$mn:00010A78 ; const wchar_t *__thiscall Buffer::getFileName(Buffer *__hidden this)
.text$mn:00010A78                 public ?getFileName@Buffer@@QBEPB_WXZ
.text$mn:00010A78 ?getFileName@Buffer@@QBEPB_WXZ proc near
.text$mn:00010A78                                         ; CODE XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+E9p
.text$mn:00010A78                                         ; Notepad_plus::fileRename(Buffer *)+11Bp
.text$mn:00010A78
.text$mn:00010A78 var_4           = dword ptr -4
.text$mn:00010A78
.text$mn:00010A78                 push    ebp
.text$mn:00010A79                 mov     ebp, esp
.text$mn:00010A7B                 push    ecx
.text$mn:00010A7C                 mov     [ebp+var_4], ecx
.text$mn:00010A7F                 mov     eax, [ebp+var_4]
.text$mn:00010A82                 mov     eax, [eax+0A8h]
.text$mn:00010A88                 mov     esp, ebp
.text$mn:00010A8A                 pop     ebp
.text$mn:00010A8B                 retn
.text$mn:00010A8B ?getFileName@Buffer@@QBEPB_WXZ endp
.text$mn:00010A8B
.text$mn:00010A8B _text$mn        ends
.text$mn:00010A8B
.text$mn:00010A8C ; ===========================================================================
.text$mn:00010A8C
.text$mn:00010A8C ; Segment type: Pure code
.text$mn:00010A8C ; Segment permissions: Read/Execute
.text$mn:00010A8C _text$mn        segment para public 'CODE' use32
.text$mn:00010A8C                 assume cs:_text$mn
.text$mn:00010A8C                 ;org 10A8Ch
.text$mn:00010A8C ; COMDAT (pick any)
.text$mn:00010A8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010A8C
.text$mn:00010A8C ; =============== S U B R O U T I N E =======================================
.text$mn:00010A8C
.text$mn:00010A8C ; Attributes: bp-based frame
.text$mn:00010A8C
.text$mn:00010A8C ; bool __thiscall Buffer::getFileReadOnly(Buffer *__hidden this)
.text$mn:00010A8C                 public ?getFileReadOnly@Buffer@@QBE_NXZ
.text$mn:00010A8C ?getFileReadOnly@Buffer@@QBE_NXZ proc near
.text$mn:00010A8C                                         ; CODE XREF: Notepad_plus::fileSave(Buffer *)+76p
.text$mn:00010A8C
.text$mn:00010A8C var_4           = dword ptr -4
.text$mn:00010A8C
.text$mn:00010A8C                 push    ebp
.text$mn:00010A8D                 mov     ebp, esp
.text$mn:00010A8F                 push    ecx
.text$mn:00010A90                 mov     [ebp+var_4], ecx
.text$mn:00010A93                 mov     eax, [ebp+var_4]
.text$mn:00010A96                 mov     al, [eax+88h]
.text$mn:00010A9C                 mov     esp, ebp
.text$mn:00010A9E                 pop     ebp
.text$mn:00010A9F                 retn
.text$mn:00010A9F ?getFileReadOnly@Buffer@@QBE_NXZ endp
.text$mn:00010A9F
.text$mn:00010A9F _text$mn        ends
.text$mn:00010A9F
.text$mn:00010AA0 ; ===========================================================================
.text$mn:00010AA0
.text$mn:00010AA0 ; Segment type: Pure code
.text$mn:00010AA0 ; Segment permissions: Read/Execute
.text$mn:00010AA0 _text$mn        segment para public 'CODE' use32
.text$mn:00010AA0                 assume cs:_text$mn
.text$mn:00010AA0                 ;org 10AA0h
.text$mn:00010AA0 ; COMDAT (pick any)
.text$mn:00010AA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010AA0
.text$mn:00010AA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00010AA0
.text$mn:00010AA0 ; Attributes: bp-based frame
.text$mn:00010AA0
.text$mn:00010AA0 ; const wchar_t *__thiscall Buffer::getFullPathName(Buffer *__hidden this)
.text$mn:00010AA0                 public ?getFullPathName@Buffer@@QBEPB_WXZ
.text$mn:00010AA0 ?getFullPathName@Buffer@@QBEPB_WXZ proc near
.text$mn:00010AA0                                         ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+2DDp
.text$mn:00010AA0                                         ; Notepad_plus::doClose(Buffer *,int,bool)+C6p ...
.text$mn:00010AA0
.text$mn:00010AA0 var_4           = dword ptr -4
.text$mn:00010AA0
.text$mn:00010AA0                 push    ebp
.text$mn:00010AA1                 mov     ebp, esp
.text$mn:00010AA3                 push    ecx
.text$mn:00010AA4                 mov     [ebp+var_4], ecx
.text$mn:00010AA7                 mov     ecx, [ebp+var_4]
.text$mn:00010AAA                 add     ecx, 8Ch ; 'î'
.text$mn:00010AB0                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00010AB5                 mov     esp, ebp
.text$mn:00010AB7                 pop     ebp
.text$mn:00010AB8                 retn
.text$mn:00010AB8 ?getFullPathName@Buffer@@QBEPB_WXZ endp
.text$mn:00010AB8
.text$mn:00010AB8 ; ---------------------------------------------------------------------------
.text$mn:00010AB9                 align 4
.text$mn:00010AB9 _text$mn        ends
.text$mn:00010AB9
.text$mn:00010ABC ; ===========================================================================
.text$mn:00010ABC
.text$mn:00010ABC ; Segment type: Pure code
.text$mn:00010ABC ; Segment permissions: Read/Execute
.text$mn:00010ABC _text$mn        segment para public 'CODE' use32
.text$mn:00010ABC                 assume cs:_text$mn
.text$mn:00010ABC                 ;org 10ABCh
.text$mn:00010ABC ; COMDAT (pick any)
.text$mn:00010ABC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010ABC
.text$mn:00010ABC ; =============== S U B R O U T I N E =======================================
.text$mn:00010ABC
.text$mn:00010ABC ; Attributes: bp-based frame
.text$mn:00010ABC
.text$mn:00010ABC ; HWND __thiscall Window::getHSelf(Window *__hidden this)
.text$mn:00010ABC                 public ?getHSelf@Window@@QBEPAUHWND__@@XZ
.text$mn:00010ABC ?getHSelf@Window@@QBEPAUHWND__@@XZ proc near
.text$mn:00010ABC                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+209p
.text$mn:00010ABC                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+24Cp ...
.text$mn:00010ABC
.text$mn:00010ABC var_4           = dword ptr -4
.text$mn:00010ABC
.text$mn:00010ABC                 push    ebp
.text$mn:00010ABD                 mov     ebp, esp
.text$mn:00010ABF                 push    ecx
.text$mn:00010AC0                 mov     [ebp+var_4], ecx
.text$mn:00010AC3                 mov     eax, [ebp+var_4]
.text$mn:00010AC6                 mov     eax, [eax+0Ch]
.text$mn:00010AC9                 mov     esp, ebp
.text$mn:00010ACB                 pop     ebp
.text$mn:00010ACC                 retn
.text$mn:00010ACC ?getHSelf@Window@@QBEPAUHWND__@@XZ endp
.text$mn:00010ACC
.text$mn:00010ACC ; ---------------------------------------------------------------------------
.text$mn:00010ACD                 align 10h
.text$mn:00010ACD _text$mn        ends
.text$mn:00010ACD
.text$mn:00010AD0 ; ===========================================================================
.text$mn:00010AD0
.text$mn:00010AD0 ; Segment type: Pure code
.text$mn:00010AD0 ; Segment permissions: Read/Execute
.text$mn:00010AD0 _text$mn        segment para public 'CODE' use32
.text$mn:00010AD0                 assume cs:_text$mn
.text$mn:00010AD0                 ;org 10AD0h
.text$mn:00010AD0 ; COMDAT (pick any)
.text$mn:00010AD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010AD0
.text$mn:00010AD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00010AD0
.text$mn:00010AD0 ; Attributes: bp-based frame
.text$mn:00010AD0
.text$mn:00010AD0 ; HINSTANCE __thiscall Window::getHinst(Window *__hidden this)
.text$mn:00010AD0                 public ?getHinst@Window@@QBEPAUHINSTANCE__@@XZ
.text$mn:00010AD0 ?getHinst@Window@@QBEPAUHINSTANCE__@@XZ proc near
.text$mn:00010AD0                                         ; CODE XREF: Notepad_plus::fileOpen(void)+3Ep
.text$mn:00010AD0                                         ; Notepad_plus::fileSaveAs(Buffer *,bool)+7Dp ...
.text$mn:00010AD0
.text$mn:00010AD0 var_4           = dword ptr -4
.text$mn:00010AD0
.text$mn:00010AD0                 push    ebp
.text$mn:00010AD1                 mov     ebp, esp
.text$mn:00010AD3                 push    ecx
.text$mn:00010AD4                 mov     [ebp+var_4], ecx
.text$mn:00010AD7                 mov     eax, [ebp+var_4]
.text$mn:00010ADA                 mov     eax, [eax+4]
.text$mn:00010ADD                 mov     esp, ebp
.text$mn:00010ADF                 pop     ebp
.text$mn:00010AE0                 retn
.text$mn:00010AE0 ?getHinst@Window@@QBEPAUHINSTANCE__@@XZ endp
.text$mn:00010AE0
.text$mn:00010AE0 ; ---------------------------------------------------------------------------
.text$mn:00010AE1                 align 4
.text$mn:00010AE1 _text$mn        ends
.text$mn:00010AE1
.text$mn:00010AE4 ; ===========================================================================
.text$mn:00010AE4
.text$mn:00010AE4 ; Segment type: Pure code
.text$mn:00010AE4 ; Segment permissions: Read/Execute
.text$mn:00010AE4 _text$mn        segment para public 'CODE' use32
.text$mn:00010AE4                 assume cs:_text$mn
.text$mn:00010AE4                 ;org 10AE4h
.text$mn:00010AE4 ; COMDAT (pick any)
.text$mn:00010AE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010AE4
.text$mn:00010AE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00010AE4
.text$mn:00010AE4 ; Attributes: bp-based frame
.text$mn:00010AE4
.text$mn:00010AE4 ; struct FileManager *__cdecl FileManager::getInstance()
.text$mn:00010AE4                 public ?getInstance@FileManager@@SAPAV1@XZ
.text$mn:00010AE4 ?getInstance@FileManager@@SAPAV1@XZ proc near
.text$mn:00010AE4                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+1A9p
.text$mn:00010AE4                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+439p ...
.text$mn:00010AE4                 push    ebp
.text$mn:00010AE5                 mov     ebp, esp
.text$mn:00010AE7                 mov     eax, dword ptr ds:?_pSelf@FileManager@@0PAV1@A ; FileManager * FileManager::_pSelf
.text$mn:00010AEC                 pop     ebp
.text$mn:00010AED                 retn
.text$mn:00010AED ?getInstance@FileManager@@SAPAV1@XZ endp
.text$mn:00010AED
.text$mn:00010AED ; ---------------------------------------------------------------------------
.text$mn:00010AEE                 align 10h
.text$mn:00010AEE _text$mn        ends
.text$mn:00010AEE
.text$mn:00010AF0 ; ===========================================================================
.text$mn:00010AF0
.text$mn:00010AF0 ; Segment type: Pure code
.text$mn:00010AF0 ; Segment permissions: Read/Execute
.text$mn:00010AF0 _text$mn        segment para public 'CODE' use32
.text$mn:00010AF0                 assume cs:_text$mn
.text$mn:00010AF0                 ;org 10AF0h
.text$mn:00010AF0 ; COMDAT (pick any)
.text$mn:00010AF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010AF0
.text$mn:00010AF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00010AF0
.text$mn:00010AF0 ; Attributes: bp-based frame
.text$mn:00010AF0
.text$mn:00010AF0 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:00010AF0                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:00010AF0 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:00010AF0                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+3Bp
.text$mn:00010AF0                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+6B6p ...
.text$mn:00010AF0                 push    ebp
.text$mn:00010AF1                 mov     ebp, esp
.text$mn:00010AF3                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:00010AF8                 pop     ebp
.text$mn:00010AF9                 retn
.text$mn:00010AF9 ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:00010AF9
.text$mn:00010AF9 ; ---------------------------------------------------------------------------
.text$mn:00010AFA                 align 4
.text$mn:00010AFA _text$mn        ends
.text$mn:00010AFA
.text$mn:00010AFC ; ===========================================================================
.text$mn:00010AFC
.text$mn:00010AFC ; Segment type: Pure code
.text$mn:00010AFC ; Segment permissions: Read/Execute
.text$mn:00010AFC _text$mn        segment para public 'CODE' use32
.text$mn:00010AFC                 assume cs:_text$mn
.text$mn:00010AFC                 ;org 10AFCh
.text$mn:00010AFC ; COMDAT (pick any)
.text$mn:00010AFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010AFC
.text$mn:00010AFC ; =============== S U B R O U T I N E =======================================
.text$mn:00010AFC
.text$mn:00010AFC ; Attributes: bp-based frame
.text$mn:00010AFC
.text$mn:00010AFC ; struct LexerStylerArray *__thiscall NppParameters::getLStylerArray(NppParameters *__hidden this)
.text$mn:00010AFC                 public ?getLStylerArray@NppParameters@@QAEAAULexerStylerArray@@XZ
.text$mn:00010AFC ?getLStylerArray@NppParameters@@QAEAAULexerStylerArray@@XZ proc near
.text$mn:00010AFC                                         ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+11Ap
.text$mn:00010AFC
.text$mn:00010AFC var_4           = dword ptr -4
.text$mn:00010AFC
.text$mn:00010AFC                 push    ebp
.text$mn:00010AFD                 mov     ebp, esp
.text$mn:00010AFF                 push    ecx
.text$mn:00010B00                 mov     [ebp+var_4], ecx
.text$mn:00010B03                 mov     eax, [ebp+var_4]
.text$mn:00010B06                 add     eax, 0B94h
.text$mn:00010B0B                 mov     esp, ebp
.text$mn:00010B0D                 pop     ebp
.text$mn:00010B0E                 retn
.text$mn:00010B0E ?getLStylerArray@NppParameters@@QAEAAULexerStylerArray@@XZ endp
.text$mn:00010B0E
.text$mn:00010B0E ; ---------------------------------------------------------------------------
.text$mn:00010B0F                 align 10h
.text$mn:00010B0F _text$mn        ends
.text$mn:00010B0F
.text$mn:00010B10 ; ===========================================================================
.text$mn:00010B10
.text$mn:00010B10 ; Segment type: Pure code
.text$mn:00010B10 ; Segment permissions: Read/Execute
.text$mn:00010B10 _text$mn        segment para public 'CODE' use32
.text$mn:00010B10                 assume cs:_text$mn
.text$mn:00010B10                 ;org 10B10h
.text$mn:00010B10 ; COMDAT (pick any)
.text$mn:00010B10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010B10
.text$mn:00010B10 ; =============== S U B R O U T I N E =======================================
.text$mn:00010B10
.text$mn:00010B10 ; Attributes: bp-based frame
.text$mn:00010B10
.text$mn:00010B10 ; struct Lang *__thiscall NppParameters::getLangFromIndex(NppParameters *this, int)
.text$mn:00010B10                 public ?getLangFromIndex@NppParameters@@QBEPAULang@@H@Z
.text$mn:00010B10 ?getLangFromIndex@NppParameters@@QBEPAULang@@H@Z proc near
.text$mn:00010B10                                         ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+6Bp
.text$mn:00010B10                                         ; Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+2ECp
.text$mn:00010B10
.text$mn:00010B10 var_4           = dword ptr -4
.text$mn:00010B10 arg_0           = dword ptr  8
.text$mn:00010B10
.text$mn:00010B10                 push    ebp
.text$mn:00010B11                 mov     ebp, esp
.text$mn:00010B13                 push    ecx
.text$mn:00010B14                 mov     [ebp+var_4], ecx
.text$mn:00010B17                 mov     eax, [ebp+var_4]
.text$mn:00010B1A                 mov     ecx, [ebp+arg_0]
.text$mn:00010B1D                 cmp     ecx, [eax+92Ch]
.text$mn:00010B23                 jl      short loc_10B29
.text$mn:00010B25                 xor     eax, eax
.text$mn:00010B27                 jmp     short loc_10B36
.text$mn:00010B29 ; ---------------------------------------------------------------------------
.text$mn:00010B29
.text$mn:00010B29 loc_10B29:                              ; CODE XREF: NppParameters::getLangFromIndex(int)+13j
.text$mn:00010B29                 mov     edx, [ebp+arg_0]
.text$mn:00010B2C                 mov     eax, [ebp+var_4]
.text$mn:00010B2F                 mov     eax, [eax+edx*4+7ECh]
.text$mn:00010B36
.text$mn:00010B36 loc_10B36:                              ; CODE XREF: NppParameters::getLangFromIndex(int)+17j
.text$mn:00010B36                 mov     esp, ebp
.text$mn:00010B38                 pop     ebp
.text$mn:00010B39                 retn    4
.text$mn:00010B39 ?getLangFromIndex@NppParameters@@QBEPAULang@@H@Z endp
.text$mn:00010B39
.text$mn:00010B39 _text$mn        ends
.text$mn:00010B39
.text$mn:00010B3C ; ===========================================================================
.text$mn:00010B3C
.text$mn:00010B3C ; Segment type: Pure code
.text$mn:00010B3C ; Segment permissions: Read/Execute
.text$mn:00010B3C _text$mn        segment para public 'CODE' use32
.text$mn:00010B3C                 assume cs:_text$mn
.text$mn:00010B3C                 ;org 10B3Ch
.text$mn:00010B3C ; COMDAT (pick any)
.text$mn:00010B3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010B3C
.text$mn:00010B3C ; =============== S U B R O U T I N E =======================================
.text$mn:00010B3C
.text$mn:00010B3C ; Attributes: bp-based frame
.text$mn:00010B3C
.text$mn:00010B3C ; public: enum  LangType __thiscall Lang::getLangID(void)const
.text$mn:00010B3C                 public ?getLangID@Lang@@QBE?AW4LangType@@XZ
.text$mn:00010B3C ?getLangID@Lang@@QBE?AW4LangType@@XZ proc near
.text$mn:00010B3C                                         ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+94p
.text$mn:00010B3C
.text$mn:00010B3C var_4           = dword ptr -4
.text$mn:00010B3C
.text$mn:00010B3C                 push    ebp
.text$mn:00010B3D                 mov     ebp, esp
.text$mn:00010B3F                 push    ecx
.text$mn:00010B40                 mov     [ebp+var_4], ecx
.text$mn:00010B43                 mov     eax, [ebp+var_4]
.text$mn:00010B46                 mov     eax, [eax]
.text$mn:00010B48                 mov     esp, ebp
.text$mn:00010B4A                 pop     ebp
.text$mn:00010B4B                 retn
.text$mn:00010B4B ?getLangID@Lang@@QBE?AW4LangType@@XZ endp
.text$mn:00010B4B
.text$mn:00010B4B _text$mn        ends
.text$mn:00010B4B
.text$mn:00010B4C ; ===========================================================================
.text$mn:00010B4C
.text$mn:00010B4C ; Segment type: Pure code
.text$mn:00010B4C ; Segment permissions: Read/Execute
.text$mn:00010B4C _text$mn        segment para public 'CODE' use32
.text$mn:00010B4C                 assume cs:_text$mn
.text$mn:00010B4C                 ;org 10B4Ch
.text$mn:00010B4C ; COMDAT (pick any)
.text$mn:00010B4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010B4C
.text$mn:00010B4C ; =============== S U B R O U T I N E =======================================
.text$mn:00010B4C
.text$mn:00010B4C ; Attributes: bp-based frame
.text$mn:00010B4C
.text$mn:00010B4C ; const wchar_t *__thiscall Lang::getLangName(Lang *__hidden this)
.text$mn:00010B4C                 public ?getLangName@Lang@@QBEPB_WXZ
.text$mn:00010B4C ?getLangName@Lang@@QBEPB_WXZ proc near  ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+128p
.text$mn:00010B4C
.text$mn:00010B4C var_4           = dword ptr -4
.text$mn:00010B4C
.text$mn:00010B4C                 push    ebp
.text$mn:00010B4D                 mov     ebp, esp
.text$mn:00010B4F                 push    ecx
.text$mn:00010B50                 mov     [ebp+var_4], ecx
.text$mn:00010B53                 mov     ecx, [ebp+var_4]
.text$mn:00010B56                 add     ecx, 4
.text$mn:00010B59                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00010B5E                 mov     esp, ebp
.text$mn:00010B60                 pop     ebp
.text$mn:00010B61                 retn
.text$mn:00010B61 ?getLangName@Lang@@QBEPB_WXZ endp
.text$mn:00010B61
.text$mn:00010B61 ; ---------------------------------------------------------------------------
.text$mn:00010B62                 align 4
.text$mn:00010B62 _text$mn        ends
.text$mn:00010B62
.text$mn:00010B64 ; ===========================================================================
.text$mn:00010B64
.text$mn:00010B64 ; Segment type: Pure code
.text$mn:00010B64 ; Segment permissions: Read/Execute
.text$mn:00010B64 _text$mn        segment para public 'CODE' use32
.text$mn:00010B64                 assume cs:_text$mn
.text$mn:00010B64                 ;org 10B64h
.text$mn:00010B64 ; COMDAT (pick any)
.text$mn:00010B64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010B64
.text$mn:00010B64 ; =============== S U B R O U T I N E =======================================
.text$mn:00010B64
.text$mn:00010B64 ; Attributes: bp-based frame
.text$mn:00010B64
.text$mn:00010B64 ; public: enum  LangType __thiscall Buffer::getLangType(void)const
.text$mn:00010B64                 public ?getLangType@Buffer@@QBE?AW4LangType@@XZ
.text$mn:00010B64 ?getLangType@Buffer@@QBE?AW4LangType@@XZ proc near
.text$mn:00010B64                                         ; CODE XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+C5p
.text$mn:00010B64
.text$mn:00010B64 var_4           = dword ptr -4
.text$mn:00010B64
.text$mn:00010B64                 push    ebp
.text$mn:00010B65                 mov     ebp, esp
.text$mn:00010B67                 push    ecx
.text$mn:00010B68                 mov     [ebp+var_4], ecx
.text$mn:00010B6B                 mov     eax, [ebp+var_4]
.text$mn:00010B6E                 mov     eax, [eax+14h]
.text$mn:00010B71                 mov     esp, ebp
.text$mn:00010B73                 pop     ebp
.text$mn:00010B74                 retn
.text$mn:00010B74 ?getLangType@Buffer@@QBE?AW4LangType@@XZ endp
.text$mn:00010B74
.text$mn:00010B74 ; ---------------------------------------------------------------------------
.text$mn:00010B75                 align 4
.text$mn:00010B75 _text$mn        ends
.text$mn:00010B75
.text$mn:00010B78 ; ===========================================================================
.text$mn:00010B78
.text$mn:00010B78 ; Segment type: Pure code
.text$mn:00010B78 ; Segment permissions: Read/Execute
.text$mn:00010B78 _text$mn        segment para public 'CODE' use32
.text$mn:00010B78                 assume cs:_text$mn
.text$mn:00010B78                 ;org 10B78h
.text$mn:00010B78 ; COMDAT (pick any)
.text$mn:00010B78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010B78
.text$mn:00010B78 ; =============== S U B R O U T I N E =======================================
.text$mn:00010B78
.text$mn:00010B78 ; Attributes: bp-based frame
.text$mn:00010B78
.text$mn:00010B78 ; const wchar_t *__thiscall LexerStyler::getLexerName(LexerStyler *__hidden this)
.text$mn:00010B78                 public ?getLexerName@LexerStyler@@QBEPB_WXZ
.text$mn:00010B78 ?getLexerName@LexerStyler@@QBEPB_WXZ proc near
.text$mn:00010B78                                         ; CODE XREF: LexerStylerArray::getLexerStylerByName(wchar_t const *)+41p
.text$mn:00010B78
.text$mn:00010B78 var_4           = dword ptr -4
.text$mn:00010B78
.text$mn:00010B78                 push    ebp
.text$mn:00010B79                 mov     ebp, esp
.text$mn:00010B7B                 push    ecx
.text$mn:00010B7C                 mov     [ebp+var_4], ecx
.text$mn:00010B7F                 mov     ecx, [ebp+var_4]
.text$mn:00010B82                 add     ecx, 52Ch
.text$mn:00010B88                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00010B8D                 mov     esp, ebp
.text$mn:00010B8F                 pop     ebp
.text$mn:00010B90                 retn
.text$mn:00010B90 ?getLexerName@LexerStyler@@QBEPB_WXZ endp
.text$mn:00010B90
.text$mn:00010B90 ; ---------------------------------------------------------------------------
.text$mn:00010B91                 align 4
.text$mn:00010B91 _text$mn        ends
.text$mn:00010B91
.text$mn:00010B94 ; ===========================================================================
.text$mn:00010B94
.text$mn:00010B94 ; Segment type: Pure code
.text$mn:00010B94 ; Segment permissions: Read/Execute
.text$mn:00010B94 _text$mn        segment para public 'CODE' use32
.text$mn:00010B94                 assume cs:_text$mn
.text$mn:00010B94                 ;org 10B94h
.text$mn:00010B94 ; COMDAT (pick any)
.text$mn:00010B94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010B94
.text$mn:00010B94 ; =============== S U B R O U T I N E =======================================
.text$mn:00010B94
.text$mn:00010B94 ; Attributes: bp-based frame
.text$mn:00010B94
.text$mn:00010B94 ; struct LexerStyler *__thiscall LexerStylerArray::getLexerStylerByName(LexerStylerArray *this, const wchar_t *)
.text$mn:00010B94                 public ?getLexerStylerByName@LexerStylerArray@@QAEPAULexerStyler@@PB_W@Z
.text$mn:00010B94 ?getLexerStylerByName@LexerStylerArray@@QAEPAULexerStyler@@PB_W@Z proc near
.text$mn:00010B94                                         ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+140p
.text$mn:00010B94
.text$mn:00010B94 var_8           = dword ptr -8
.text$mn:00010B94 var_4           = dword ptr -4
.text$mn:00010B94 lpString2       = dword ptr  8
.text$mn:00010B94
.text$mn:00010B94                 push    ebp
.text$mn:00010B95                 mov     ebp, esp
.text$mn:00010B97                 sub     esp, 8
.text$mn:00010B9A                 mov     [ebp+var_8], ecx
.text$mn:00010B9D                 cmp     [ebp+lpString2], 0
.text$mn:00010BA1                 jnz     short loc_10BA7
.text$mn:00010BA3                 xor     eax, eax
.text$mn:00010BA5                 jmp     short loc_10BF5
.text$mn:00010BA7 ; ---------------------------------------------------------------------------
.text$mn:00010BA7
.text$mn:00010BA7 loc_10BA7:                              ; CODE XREF: LexerStylerArray::getLexerStylerByName(wchar_t const *)+Dj
.text$mn:00010BA7                 mov     [ebp+var_4], 0
.text$mn:00010BAE                 jmp     short loc_10BB9
.text$mn:00010BB0 ; ---------------------------------------------------------------------------
.text$mn:00010BB0
.text$mn:00010BB0 loc_10BB0:                              ; CODE XREF: LexerStylerArray::getLexerStylerByName(wchar_t const *):loc_10BF1j
.text$mn:00010BB0                 mov     eax, [ebp+var_4]
.text$mn:00010BB3                 add     eax, 1
.text$mn:00010BB6                 mov     [ebp+var_4], eax
.text$mn:00010BB9
.text$mn:00010BB9 loc_10BB9:                              ; CODE XREF: LexerStylerArray::getLexerStylerByName(wchar_t const *)+1Aj
.text$mn:00010BB9                 mov     ecx, [ebp+var_8]
.text$mn:00010BBC                 mov     edx, [ebp+var_4]
.text$mn:00010BBF                 cmp     edx, [ecx+1B800h]
.text$mn:00010BC5                 jge     short loc_10BF3
.text$mn:00010BC7                 mov     eax, [ebp+lpString2]
.text$mn:00010BCA                 push    eax             ; lpString2
.text$mn:00010BCB                 imul    ecx, [ebp+var_4], 580h
.text$mn:00010BD2                 add     ecx, [ebp+var_8] ; this
.text$mn:00010BD5                 call    ?getLexerName@LexerStyler@@QBEPB_WXZ ; LexerStyler::getLexerName(void)
.text$mn:00010BDA                 push    eax             ; lpString1
.text$mn:00010BDB                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:00010BE1                 test    eax, eax
.text$mn:00010BE3                 jnz     short loc_10BF1
.text$mn:00010BE5                 imul    eax, [ebp+var_4], 580h
.text$mn:00010BEC                 add     eax, [ebp+var_8]
.text$mn:00010BEF                 jmp     short loc_10BF5
.text$mn:00010BF1 ; ---------------------------------------------------------------------------
.text$mn:00010BF1
.text$mn:00010BF1 loc_10BF1:                              ; CODE XREF: LexerStylerArray::getLexerStylerByName(wchar_t const *)+4Fj
.text$mn:00010BF1                 jmp     short loc_10BB0
.text$mn:00010BF3 ; ---------------------------------------------------------------------------
.text$mn:00010BF3
.text$mn:00010BF3 loc_10BF3:                              ; CODE XREF: LexerStylerArray::getLexerStylerByName(wchar_t const *)+31j
.text$mn:00010BF3                 xor     eax, eax
.text$mn:00010BF5
.text$mn:00010BF5 loc_10BF5:                              ; CODE XREF: LexerStylerArray::getLexerStylerByName(wchar_t const *)+11j
.text$mn:00010BF5                                         ; LexerStylerArray::getLexerStylerByName(wchar_t const *)+5Bj
.text$mn:00010BF5                 mov     esp, ebp
.text$mn:00010BF7                 pop     ebp
.text$mn:00010BF8                 retn    4
.text$mn:00010BF8 ?getLexerStylerByName@LexerStylerArray@@QAEPAULexerStyler@@PB_W@Z endp
.text$mn:00010BF8
.text$mn:00010BF8 ; ---------------------------------------------------------------------------
.text$mn:00010BFB                 align 4
.text$mn:00010BFB _text$mn        ends
.text$mn:00010BFB
.text$mn:00010BFC ; ===========================================================================
.text$mn:00010BFC
.text$mn:00010BFC ; Segment type: Pure code
.text$mn:00010BFC ; Segment permissions: Read/Execute
.text$mn:00010BFC _text$mn        segment para public 'CODE' use32
.text$mn:00010BFC                 assume cs:_text$mn
.text$mn:00010BFC                 ;org 10BFCh
.text$mn:00010BFC ; COMDAT (pick any)
.text$mn:00010BFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010BFC
.text$mn:00010BFC ; =============== S U B R O U T I N E =======================================
.text$mn:00010BFC
.text$mn:00010BFC ; Attributes: bp-based frame
.text$mn:00010BFC
.text$mn:00010BFC ; const wchar_t *__thiscall LexerStyler::getLexerUserExt(LexerStyler *__hidden this)
.text$mn:00010BFC                 public ?getLexerUserExt@LexerStyler@@QBEPB_WXZ
.text$mn:00010BFC ?getLexerUserExt@LexerStyler@@QBEPB_WXZ proc near
.text$mn:00010BFC                                         ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+15Ap
.text$mn:00010BFC
.text$mn:00010BFC var_4           = dword ptr -4
.text$mn:00010BFC
.text$mn:00010BFC                 push    ebp
.text$mn:00010BFD                 mov     ebp, esp
.text$mn:00010BFF                 push    ecx
.text$mn:00010C00                 mov     [ebp+var_4], ecx
.text$mn:00010C03                 mov     ecx, [ebp+var_4]
.text$mn:00010C06                 add     ecx, 564h
.text$mn:00010C0C                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00010C11                 mov     esp, ebp
.text$mn:00010C13                 pop     ebp
.text$mn:00010C14                 retn
.text$mn:00010C14 ?getLexerUserExt@LexerStyler@@QBEPB_WXZ endp
.text$mn:00010C14
.text$mn:00010C14 ; ---------------------------------------------------------------------------
.text$mn:00010C15                 align 4
.text$mn:00010C15 _text$mn        ends
.text$mn:00010C15
.text$mn:00010C18 ; ===========================================================================
.text$mn:00010C18
.text$mn:00010C18 ; Segment type: Pure code
.text$mn:00010C18 ; Segment permissions: Read/Execute
.text$mn:00010C18 _text$mn        segment para public 'CODE' use32
.text$mn:00010C18                 assume cs:_text$mn
.text$mn:00010C18                 ;org 10C18h
.text$mn:00010C18 ; COMDAT (pick any)
.text$mn:00010C18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010C18
.text$mn:00010C18 ; =============== S U B R O U T I N E =======================================
.text$mn:00010C18
.text$mn:00010C18 ; Attributes: bp-based frame
.text$mn:00010C18
.text$mn:00010C18 ; const struct NewDocDefaultSettings *__thiscall NppGUI::getNewDocDefaultSettings(NppGUI *__hidden this)
.text$mn:00010C18                 public ?getNewDocDefaultSettings@NppGUI@@QBEABUNewDocDefaultSettings@@XZ
.text$mn:00010C18 ?getNewDocDefaultSettings@NppGUI@@QBEABUNewDocDefaultSettings@@XZ proc near
.text$mn:00010C18                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+6C4p
.text$mn:00010C18
.text$mn:00010C18 var_4           = dword ptr -4
.text$mn:00010C18
.text$mn:00010C18                 push    ebp
.text$mn:00010C19                 mov     ebp, esp
.text$mn:00010C1B                 push    ecx
.text$mn:00010C1C                 mov     [ebp+var_4], ecx
.text$mn:00010C1F                 mov     eax, [ebp+var_4]
.text$mn:00010C22                 add     eax, 50h ; 'P'
.text$mn:00010C25                 mov     esp, ebp
.text$mn:00010C27                 pop     ebp
.text$mn:00010C28                 retn
.text$mn:00010C28 ?getNewDocDefaultSettings@NppGUI@@QBEABUNewDocDefaultSettings@@XZ endp
.text$mn:00010C28
.text$mn:00010C28 ; ---------------------------------------------------------------------------
.text$mn:00010C29                 align 4
.text$mn:00010C29 _text$mn        ends
.text$mn:00010C29
.text$mn:00010C2C ; ===========================================================================
.text$mn:00010C2C
.text$mn:00010C2C ; Segment type: Pure code
.text$mn:00010C2C ; Segment permissions: Read/Execute
.text$mn:00010C2C _text$mn        segment para public 'CODE' use32
.text$mn:00010C2C                 assume cs:_text$mn
.text$mn:00010C2C                 ;org 10C2Ch
.text$mn:00010C2C ; COMDAT (pick any)
.text$mn:00010C2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010C2C
.text$mn:00010C2C ; =============== S U B R O U T I N E =======================================
.text$mn:00010C2C
.text$mn:00010C2C ; Attributes: bp-based frame
.text$mn:00010C2C
.text$mn:00010C2C ; const struct NppGUI *__thiscall NppParameters::getNppGUI(NppParameters *__hidden this)
.text$mn:00010C2C                 public ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ
.text$mn:00010C2C ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ proc near
.text$mn:00010C2C                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+6BDp
.text$mn:00010C2C                                         ; Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+105p ...
.text$mn:00010C2C
.text$mn:00010C2C var_4           = dword ptr -4
.text$mn:00010C2C
.text$mn:00010C2C                 push    ebp
.text$mn:00010C2D                 mov     ebp, esp
.text$mn:00010C2F                 push    ecx
.text$mn:00010C30                 mov     [ebp+var_4], ecx
.text$mn:00010C33                 mov     eax, [ebp+var_4]
.text$mn:00010C36                 add     eax, 118h
.text$mn:00010C3B                 mov     esp, ebp
.text$mn:00010C3D                 pop     ebp
.text$mn:00010C3E                 retn
.text$mn:00010C3E ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ endp
.text$mn:00010C3E
.text$mn:00010C3E ; ---------------------------------------------------------------------------
.text$mn:00010C3F                 align 10h
.text$mn:00010C3F _text$mn        ends
.text$mn:00010C3F
.text$mn:00010C40 ; ===========================================================================
.text$mn:00010C40
.text$mn:00010C40 ; Segment type: Pure code
.text$mn:00010C40 ; Segment permissions: Read/Execute
.text$mn:00010C40 _text$mn        segment para public 'CODE' use32
.text$mn:00010C40                 assume cs:_text$mn
.text$mn:00010C40                 ;org 10C40h
.text$mn:00010C40 ; COMDAT (pick any)
.text$mn:00010C40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010C40
.text$mn:00010C40 ; =============== S U B R O U T I N E =======================================
.text$mn:00010C40
.text$mn:00010C40 ; Attributes: bp-based frame
.text$mn:00010C40
.text$mn:00010C40 ; const struct Session *__thiscall NppParameters::getSession(NppParameters *__hidden this)
.text$mn:00010C40                 public ?getSession@NppParameters@@QBEABUSession@@XZ
.text$mn:00010C40 ?getSession@NppParameters@@QBEABUSession@@XZ proc near
.text$mn:00010C40                                         ; CODE XREF: Notepad_plus::loadLastSession(void)+3Ep
.text$mn:00010C40
.text$mn:00010C40 var_4           = dword ptr -4
.text$mn:00010C40
.text$mn:00010C40                 push    ebp
.text$mn:00010C41                 mov     ebp, esp
.text$mn:00010C43                 push    ecx
.text$mn:00010C44                 mov     [ebp+var_4], ecx
.text$mn:00010C47                 mov     eax, [ebp+var_4]
.text$mn:00010C4A                 add     eax, 1CA24h
.text$mn:00010C4F                 mov     esp, ebp
.text$mn:00010C51                 pop     ebp
.text$mn:00010C52                 retn
.text$mn:00010C52 ?getSession@NppParameters@@QBEABUSession@@XZ endp
.text$mn:00010C52
.text$mn:00010C52 ; ---------------------------------------------------------------------------
.text$mn:00010C53                 align 4
.text$mn:00010C53 _text$mn        ends
.text$mn:00010C53
.text$mn:00010C54 ; ===========================================================================
.text$mn:00010C54
.text$mn:00010C54 ; Segment type: Pure code
.text$mn:00010C54 ; Segment permissions: Read/Execute
.text$mn:00010C54 _text$mn        segment para public 'CODE' use32
.text$mn:00010C54                 assume cs:_text$mn
.text$mn:00010C54                 ;org 10C54h
.text$mn:00010C54 ; COMDAT (pick any)
.text$mn:00010C54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010C54
.text$mn:00010C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00010C54
.text$mn:00010C54 ; Attributes: bp-based frame
.text$mn:00010C54
.text$mn:00010C54 ; public: enum  winVer __thiscall NppParameters::getWinVersion(void)
.text$mn:00010C54                 public ?getWinVersion@NppParameters@@QAE?AW4winVer@@XZ
.text$mn:00010C54 ?getWinVersion@NppParameters@@QAE?AW4winVer@@XZ proc near
.text$mn:00010C54                                         ; CODE XREF: Notepad_plus::fileDelete(Buffer *)+4Bp
.text$mn:00010C54
.text$mn:00010C54 var_4           = dword ptr -4
.text$mn:00010C54
.text$mn:00010C54                 push    ebp
.text$mn:00010C55                 mov     ebp, esp
.text$mn:00010C57                 push    ecx
.text$mn:00010C58                 mov     [ebp+var_4], ecx
.text$mn:00010C5B                 mov     eax, [ebp+var_4]
.text$mn:00010C5E                 mov     eax, [eax+1CC1Ch]
.text$mn:00010C64                 mov     esp, ebp
.text$mn:00010C66                 pop     ebp
.text$mn:00010C67                 retn
.text$mn:00010C67 ?getWinVersion@NppParameters@@QAE?AW4winVer@@XZ endp
.text$mn:00010C67
.text$mn:00010C67 _text$mn        ends
.text$mn:00010C67
.text$mn:00010C68 ; ===========================================================================
.text$mn:00010C68
.text$mn:00010C68 ; Segment type: Pure code
.text$mn:00010C68 ; Segment permissions: Read/Execute
.text$mn:00010C68 _text$mn        segment para public 'CODE' use32
.text$mn:00010C68                 assume cs:_text$mn
.text$mn:00010C68                 ;org 10C68h
.text$mn:00010C68 ; COMDAT (pick any)
.text$mn:00010C68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010C68
.text$mn:00010C68 ; =============== S U B R O U T I N E =======================================
.text$mn:00010C68
.text$mn:00010C68 ; Attributes: bp-based frame
.text$mn:00010C68
.text$mn:00010C68 ; public: class std::allocator<wchar_t> __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::get_allocator(void)const
.text$mn:00010C68                 public ?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ
.text$mn:00010C68 ?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ proc near
.text$mn:00010C68                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::substr(uint,uint)+36p
.text$mn:00010C68
.text$mn:00010C68 var_8           = dword ptr -8
.text$mn:00010C68 var_1           = byte ptr -1
.text$mn:00010C68 arg_0           = dword ptr  8
.text$mn:00010C68
.text$mn:00010C68                 push    ebp
.text$mn:00010C69                 mov     ebp, esp
.text$mn:00010C6B                 sub     esp, 8
.text$mn:00010C6E                 mov     [ebp+var_8], ecx
.text$mn:00010C71                 lea     eax, [ebp+var_1]
.text$mn:00010C74                 push    eax
.text$mn:00010C75                 mov     ecx, [ebp+var_8]
.text$mn:00010C78                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00010C7D                 push    eax
.text$mn:00010C7E                 mov     ecx, [ebp+arg_0]
.text$mn:00010C81                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00010C86                 mov     eax, [ebp+arg_0]
.text$mn:00010C89                 mov     esp, ebp
.text$mn:00010C8B                 pop     ebp
.text$mn:00010C8C                 retn    4
.text$mn:00010C8C ?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ endp
.text$mn:00010C8C
.text$mn:00010C8C ; ---------------------------------------------------------------------------
.text$mn:00010C8F                 align 10h
.text$mn:00010C8F _text$mn        ends
.text$mn:00010C8F
.text$mn:00010C90 ; ===========================================================================
.text$mn:00010C90
.text$mn:00010C90 ; Segment type: Pure code
.text$mn:00010C90 ; Segment permissions: Read/Execute
.text$mn:00010C90 _text$mn        segment para public 'CODE' use32
.text$mn:00010C90                 assume cs:_text$mn
.text$mn:00010C90                 ;org 10C90h
.text$mn:00010C90 ; COMDAT (pick any)
.text$mn:00010C90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010C90
.text$mn:00010C90 ; =============== S U B R O U T I N E =======================================
.text$mn:00010C90
.text$mn:00010C90 ; Attributes: bp-based frame
.text$mn:00010C90
.text$mn:00010C90 ; bool __thiscall DockingDlgInterface::isClosed(DockingDlgInterface *__hidden this)
.text$mn:00010C90                 public ?isClosed@DockingDlgInterface@@QBE_NXZ
.text$mn:00010C90 ?isClosed@DockingDlgInterface@@QBE_NXZ proc near
.text$mn:00010C90                                         ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+467p
.text$mn:00010C90
.text$mn:00010C90 var_4           = dword ptr -4
.text$mn:00010C90
.text$mn:00010C90                 push    ebp
.text$mn:00010C91                 mov     ebp, esp
.text$mn:00010C93                 push    ecx
.text$mn:00010C94                 mov     [ebp+var_4], ecx
.text$mn:00010C97                 mov     eax, [ebp+var_4]
.text$mn:00010C9A                 mov     al, [eax+68h]
.text$mn:00010C9D                 mov     esp, ebp
.text$mn:00010C9F                 pop     ebp
.text$mn:00010CA0                 retn
.text$mn:00010CA0 ?isClosed@DockingDlgInterface@@QBE_NXZ endp
.text$mn:00010CA0
.text$mn:00010CA0 ; ---------------------------------------------------------------------------
.text$mn:00010CA1                 align 4
.text$mn:00010CA1 _text$mn        ends
.text$mn:00010CA1
.text$mn:00010CA4 ; ===========================================================================
.text$mn:00010CA4
.text$mn:00010CA4 ; Segment type: Pure code
.text$mn:00010CA4 ; Segment permissions: Read/Execute
.text$mn:00010CA4 _text$mn        segment para public 'CODE' use32
.text$mn:00010CA4                 assume cs:_text$mn
.text$mn:00010CA4                 ;org 10CA4h
.text$mn:00010CA4 ; COMDAT (pick any)
.text$mn:00010CA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010CA4
.text$mn:00010CA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00010CA4
.text$mn:00010CA4 ; Attributes: bp-based frame
.text$mn:00010CA4
.text$mn:00010CA4 ; bool __thiscall Buffer::isDirty(Buffer *__hidden this)
.text$mn:00010CA4                 public ?isDirty@Buffer@@QBE_NXZ
.text$mn:00010CA4 ?isDirty@Buffer@@QBE_NXZ proc near      ; CODE XREF: Notepad_plus::fileClose(Buffer *,int)+64p
.text$mn:00010CA4                                         ; Notepad_plus::fileCloseAll(bool,bool)+D8p ...
.text$mn:00010CA4
.text$mn:00010CA4 var_4           = dword ptr -4
.text$mn:00010CA4
.text$mn:00010CA4                 push    ebp
.text$mn:00010CA5                 mov     ebp, esp
.text$mn:00010CA7                 push    ecx
.text$mn:00010CA8                 mov     [ebp+var_4], ecx
.text$mn:00010CAB                 mov     eax, [ebp+var_4]
.text$mn:00010CAE                 mov     al, [eax+34h]
.text$mn:00010CB1                 mov     esp, ebp
.text$mn:00010CB3                 pop     ebp
.text$mn:00010CB4                 retn
.text$mn:00010CB4 ?isDirty@Buffer@@QBE_NXZ endp
.text$mn:00010CB4
.text$mn:00010CB4 ; ---------------------------------------------------------------------------
.text$mn:00010CB5                 align 4
.text$mn:00010CB5 _text$mn        ends
.text$mn:00010CB5
.text$mn:00010CB8 ; ===========================================================================
.text$mn:00010CB8
.text$mn:00010CB8 ; Segment type: Pure code
.text$mn:00010CB8 ; Segment permissions: Read/Execute
.text$mn:00010CB8 _text$mn        segment para public 'CODE' use32
.text$mn:00010CB8                 assume cs:_text$mn
.text$mn:00010CB8                 ;org 10CB8h
.text$mn:00010CB8 ; COMDAT (pick any)
.text$mn:00010CB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010CB8
.text$mn:00010CB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00010CB8
.text$mn:00010CB8 ; Attributes: bp-based frame
.text$mn:00010CB8
.text$mn:00010CB8 ; bool __thiscall trayIconControler::isInTray(trayIconControler *__hidden this)
.text$mn:00010CB8                 public ?isInTray@trayIconControler@@QBE_NXZ
.text$mn:00010CB8 ?isInTray@trayIconControler@@QBE_NXZ proc near
.text$mn:00010CB8                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+1F2p
.text$mn:00010CB8                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+790p
.text$mn:00010CB8
.text$mn:00010CB8 var_4           = dword ptr -4
.text$mn:00010CB8
.text$mn:00010CB8                 push    ebp
.text$mn:00010CB9                 mov     ebp, esp
.text$mn:00010CBB                 push    ecx
.text$mn:00010CBC                 mov     [ebp+var_4], ecx
.text$mn:00010CBF                 mov     eax, [ebp+var_4]
.text$mn:00010CC2                 mov     al, [eax+3B8h]
.text$mn:00010CC8                 mov     esp, ebp
.text$mn:00010CCA                 pop     ebp
.text$mn:00010CCB                 retn
.text$mn:00010CCB ?isInTray@trayIconControler@@QBE_NXZ endp
.text$mn:00010CCB
.text$mn:00010CCB _text$mn        ends
.text$mn:00010CCB
.text$mn:00010CCC ; ===========================================================================
.text$mn:00010CCC
.text$mn:00010CCC ; Segment type: Pure code
.text$mn:00010CCC ; Segment permissions: Read/Execute
.text$mn:00010CCC _text$mn        segment para public 'CODE' use32
.text$mn:00010CCC                 assume cs:_text$mn
.text$mn:00010CCC                 ;org 10CCCh
.text$mn:00010CCC ; COMDAT (pick any)
.text$mn:00010CCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010CCC
.text$mn:00010CCC ; =============== S U B R O U T I N E =======================================
.text$mn:00010CCC
.text$mn:00010CCC ; Attributes: bp-based frame
.text$mn:00010CCC
.text$mn:00010CCC ; bool __thiscall Notepad_plus_Window::isPrelaunch(Notepad_plus_Window *__hidden this)
.text$mn:00010CCC                 public ?isPrelaunch@Notepad_plus_Window@@QBE_NXZ
.text$mn:00010CCC ?isPrelaunch@Notepad_plus_Window@@QBE_NXZ proc near
.text$mn:00010CCC                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+21Ep
.text$mn:00010CCC                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+7BCp
.text$mn:00010CCC
.text$mn:00010CCC var_4           = dword ptr -4
.text$mn:00010CCC
.text$mn:00010CCC                 push    ebp
.text$mn:00010CCD                 mov     ebp, esp
.text$mn:00010CCF                 push    ecx
.text$mn:00010CD0                 mov     [ebp+var_4], ecx
.text$mn:00010CD3                 mov     eax, [ebp+var_4]
.text$mn:00010CD6                 mov     al, [eax+551DCh]
.text$mn:00010CDC                 mov     esp, ebp
.text$mn:00010CDE                 pop     ebp
.text$mn:00010CDF                 retn
.text$mn:00010CDF ?isPrelaunch@Notepad_plus_Window@@QBE_NXZ endp
.text$mn:00010CDF
.text$mn:00010CDF _text$mn        ends
.text$mn:00010CDF
.text$mn:00010CE0 ; ===========================================================================
.text$mn:00010CE0
.text$mn:00010CE0 ; Segment type: Pure code
.text$mn:00010CE0 ; Segment permissions: Read/Execute
.text$mn:00010CE0 _text$mn        segment para public 'CODE' use32
.text$mn:00010CE0                 assume cs:_text$mn
.text$mn:00010CE0                 ;org 10CE0h
.text$mn:00010CE0 ; COMDAT (pick any)
.text$mn:00010CE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010CE0
.text$mn:00010CE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00010CE0
.text$mn:00010CE0 ; Attributes: bp-based frame
.text$mn:00010CE0
.text$mn:00010CE0 ; bool __thiscall FileDialog::isReadOnly(FileDialog *__hidden this)
.text$mn:00010CE0                 public ?isReadOnly@FileDialog@@QAE_NXZ
.text$mn:00010CE0 ?isReadOnly@FileDialog@@QAE_NXZ proc near
.text$mn:00010CE0                                         ; CODE XREF: Notepad_plus::fileOpen(void)+106p
.text$mn:00010CE0
.text$mn:00010CE0 var_4           = dword ptr -4
.text$mn:00010CE0
.text$mn:00010CE0                 push    ebp
.text$mn:00010CE1                 mov     ebp, esp
.text$mn:00010CE3                 push    ecx
.text$mn:00010CE4                 mov     [ebp+var_4], ecx
.text$mn:00010CE7                 mov     eax, [ebp+var_4]
.text$mn:00010CEA                 mov     eax, [eax+108Ch]
.text$mn:00010CF0                 and     eax, 1
.text$mn:00010CF3                 mov     esp, ebp
.text$mn:00010CF5                 pop     ebp
.text$mn:00010CF6                 retn
.text$mn:00010CF6 ?isReadOnly@FileDialog@@QAE_NXZ endp
.text$mn:00010CF6
.text$mn:00010CF6 ; ---------------------------------------------------------------------------
.text$mn:00010CF7                 align 4
.text$mn:00010CF7 _text$mn        ends
.text$mn:00010CF7
.text$mn:00010CF8 ; ===========================================================================
.text$mn:00010CF8
.text$mn:00010CF8 ; Segment type: Pure code
.text$mn:00010CF8 ; Segment permissions: Read/Execute
.text$mn:00010CF8 _text$mn        segment para public 'CODE' use32
.text$mn:00010CF8                 assume cs:_text$mn
.text$mn:00010CF8                 ;org 10CF8h
.text$mn:00010CF8 ; COMDAT (pick any)
.text$mn:00010CF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010CF8
.text$mn:00010CF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00010CF8
.text$mn:00010CF8 ; Attributes: bp-based frame
.text$mn:00010CF8
.text$mn:00010CF8 ; bool __thiscall NppGUI::isSnapshotMode(NppGUI *__hidden this)
.text$mn:00010CF8                 public ?isSnapshotMode@NppGUI@@QBE_NXZ
.text$mn:00010CF8 ?isSnapshotMode@NppGUI@@QBE_NXZ proc near
.text$mn:00010CF8                                         ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+10Cp
.text$mn:00010CF8                                         ; Notepad_plus::fileClose(Buffer *,int)+CDp ...
.text$mn:00010CF8
.text$mn:00010CF8 var_8           = dword ptr -8
.text$mn:00010CF8 var_4           = dword ptr -4
.text$mn:00010CF8
.text$mn:00010CF8                 push    ebp
.text$mn:00010CF9                 mov     ebp, esp
.text$mn:00010CFB                 sub     esp, 8
.text$mn:00010CFE                 mov     [ebp+var_4], ecx
.text$mn:00010D01                 mov     eax, [ebp+var_4]
.text$mn:00010D04                 movzx   ecx, byte ptr [eax+695h]
.text$mn:00010D0B                 test    ecx, ecx
.text$mn:00010D0D                 jz      short loc_10D2E
.text$mn:00010D0F                 mov     edx, [ebp+var_4]
.text$mn:00010D12                 movzx   eax, byte ptr [edx+3Ah]
.text$mn:00010D16                 test    eax, eax
.text$mn:00010D18                 jz      short loc_10D2E
.text$mn:00010D1A                 mov     ecx, [ebp+var_4]
.text$mn:00010D1D                 movzx   edx, byte ptr [ecx+3Bh]
.text$mn:00010D21                 test    edx, edx
.text$mn:00010D23                 jnz     short loc_10D2E
.text$mn:00010D25                 mov     [ebp+var_8], 1
.text$mn:00010D2C                 jmp     short loc_10D35
.text$mn:00010D2E ; ---------------------------------------------------------------------------
.text$mn:00010D2E
.text$mn:00010D2E loc_10D2E:                              ; CODE XREF: NppGUI::isSnapshotMode(void)+15j
.text$mn:00010D2E                                         ; NppGUI::isSnapshotMode(void)+20j ...
.text$mn:00010D2E                 mov     [ebp+var_8], 0
.text$mn:00010D35
.text$mn:00010D35 loc_10D35:                              ; CODE XREF: NppGUI::isSnapshotMode(void)+34j
.text$mn:00010D35                 mov     al, byte ptr [ebp+var_8]
.text$mn:00010D38                 mov     esp, ebp
.text$mn:00010D3A                 pop     ebp
.text$mn:00010D3B                 retn
.text$mn:00010D3B ?isSnapshotMode@NppGUI@@QBE_NXZ endp
.text$mn:00010D3B
.text$mn:00010D3B _text$mn        ends
.text$mn:00010D3B
.text$mn:00010D3C ; ===========================================================================
.text$mn:00010D3C
.text$mn:00010D3C ; Segment type: Pure code
.text$mn:00010D3C ; Segment permissions: Read/Execute
.text$mn:00010D3C _text$mn        segment para public 'CODE' use32
.text$mn:00010D3C                 assume cs:_text$mn
.text$mn:00010D3C                 ;org 10D3Ch
.text$mn:00010D3C ; COMDAT (pick any)
.text$mn:00010D3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010D3C
.text$mn:00010D3C ; =============== S U B R O U T I N E =======================================
.text$mn:00010D3C
.text$mn:00010D3C ; Attributes: bp-based frame
.text$mn:00010D3C
.text$mn:00010D3C ; bool __thiscall Buffer::isUntitled(Buffer *__hidden this)
.text$mn:00010D3C                 public ?isUntitled@Buffer@@QBE_NXZ
.text$mn:00010D3C ?isUntitled@Buffer@@QBE_NXZ proc near   ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+ABp
.text$mn:00010D3C                                         ; Notepad_plus::fileClose(Buffer *,int)+47p ...
.text$mn:00010D3C
.text$mn:00010D3C var_8           = dword ptr -8
.text$mn:00010D3C var_4           = dword ptr -4
.text$mn:00010D3C
.text$mn:00010D3C                 push    ebp
.text$mn:00010D3D                 mov     ebp, esp
.text$mn:00010D3F                 sub     esp, 8
.text$mn:00010D42                 mov     [ebp+var_8], ecx
.text$mn:00010D45                 mov     eax, [ebp+var_8]
.text$mn:00010D48                 cmp     dword ptr [eax+78h], 2
.text$mn:00010D4C                 jnz     short loc_10D57
.text$mn:00010D4E                 mov     [ebp+var_4], 1
.text$mn:00010D55                 jmp     short loc_10D5E
.text$mn:00010D57 ; ---------------------------------------------------------------------------
.text$mn:00010D57
.text$mn:00010D57 loc_10D57:                              ; CODE XREF: Buffer::isUntitled(void)+10j
.text$mn:00010D57                 mov     [ebp+var_4], 0
.text$mn:00010D5E
.text$mn:00010D5E loc_10D5E:                              ; CODE XREF: Buffer::isUntitled(void)+19j
.text$mn:00010D5E                 mov     al, byte ptr [ebp+var_4]
.text$mn:00010D61                 mov     esp, ebp
.text$mn:00010D63                 pop     ebp
.text$mn:00010D64                 retn
.text$mn:00010D64 ?isUntitled@Buffer@@QBE_NXZ endp
.text$mn:00010D64
.text$mn:00010D64 ; ---------------------------------------------------------------------------
.text$mn:00010D65                 align 4
.text$mn:00010D65 _text$mn        ends
.text$mn:00010D65
.text$mn:00010D68 ; ===========================================================================
.text$mn:00010D68
.text$mn:00010D68 ; Segment type: Pure code
.text$mn:00010D68 ; Segment permissions: Read/Execute
.text$mn:00010D68 _text$mn        segment para public 'CODE' use32
.text$mn:00010D68                 assume cs:_text$mn
.text$mn:00010D68                 ;org 10D68h
.text$mn:00010D68 ; COMDAT (pick any)
.text$mn:00010D68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010D68
.text$mn:00010D68 ; =============== S U B R O U T I N E =======================================
.text$mn:00010D68
.text$mn:00010D68 ; Attributes: bp-based frame
.text$mn:00010D68
.text$mn:00010D68 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::length(void)const
.text$mn:00010D68                 public ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00010D68 ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00010D68                                         ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+82p
.text$mn:00010D68                                         ; Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+221p
.text$mn:00010D68
.text$mn:00010D68 var_4           = dword ptr -4
.text$mn:00010D68
.text$mn:00010D68                 push    ebp
.text$mn:00010D69                 mov     ebp, esp
.text$mn:00010D6B                 push    ecx
.text$mn:00010D6C                 mov     [ebp+var_4], ecx
.text$mn:00010D6F                 mov     eax, [ebp+var_4]
.text$mn:00010D72                 mov     eax, [eax+14h]
.text$mn:00010D75                 mov     esp, ebp
.text$mn:00010D77                 pop     ebp
.text$mn:00010D78                 retn
.text$mn:00010D78 ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00010D78
.text$mn:00010D78 ; ---------------------------------------------------------------------------
.text$mn:00010D79                 align 4
.text$mn:00010D79 _text$mn        ends
.text$mn:00010D79
.text$mn:00010D7C ; ===========================================================================
.text$mn:00010D7C
.text$mn:00010D7C ; Segment type: Pure code
.text$mn:00010D7C ; Segment permissions: Read/Execute
.text$mn:00010D7C _text$mn        segment para public 'CODE' use32
.text$mn:00010D7C                 assume cs:_text$mn
.text$mn:00010D7C                 ;org 10D7Ch
.text$mn:00010D7C ; COMDAT (pick any)
.text$mn:00010D7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010D7C
.text$mn:00010D7C ; =============== S U B R O U T I N E =======================================
.text$mn:00010D7C
.text$mn:00010D7C ; Attributes: bp-based frame
.text$mn:00010D7C
.text$mn:00010D7C ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00010D7C                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00010D7C ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00010D7C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00010D7C
.text$mn:00010D7C var_4           = dword ptr -4
.text$mn:00010D7C Str             = dword ptr  8
.text$mn:00010D7C
.text$mn:00010D7C                 push    ebp
.text$mn:00010D7D                 mov     ebp, esp
.text$mn:00010D7F                 push    ecx
.text$mn:00010D80                 mov     eax, [ebp+Str]
.text$mn:00010D83                 movsx   ecx, byte ptr [eax]
.text$mn:00010D86                 test    ecx, ecx
.text$mn:00010D88                 jnz     short loc_10D93
.text$mn:00010D8A                 mov     [ebp+var_4], 0
.text$mn:00010D91                 jmp     short loc_10DA2
.text$mn:00010D93 ; ---------------------------------------------------------------------------
.text$mn:00010D93
.text$mn:00010D93 loc_10D93:                              ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00010D93                 mov     edx, [ebp+Str]
.text$mn:00010D96                 push    edx             ; Str
.text$mn:00010D97                 call    _strlen
.text$mn:00010D9C                 add     esp, 4
.text$mn:00010D9F                 mov     [ebp+var_4], eax
.text$mn:00010DA2
.text$mn:00010DA2 loc_10DA2:                              ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00010DA2                 mov     eax, [ebp+var_4]
.text$mn:00010DA5                 mov     esp, ebp
.text$mn:00010DA7                 pop     ebp
.text$mn:00010DA8                 retn
.text$mn:00010DA8 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00010DA8
.text$mn:00010DA8 ; ---------------------------------------------------------------------------
.text$mn:00010DA9                 align 4
.text$mn:00010DA9 _text$mn        ends
.text$mn:00010DA9
.text$mn:00010DAC ; ===========================================================================
.text$mn:00010DAC
.text$mn:00010DAC ; Segment type: Pure code
.text$mn:00010DAC ; Segment permissions: Read/Execute
.text$mn:00010DAC _text$mn        segment para public 'CODE' use32
.text$mn:00010DAC                 assume cs:_text$mn
.text$mn:00010DAC                 ;org 10DACh
.text$mn:00010DAC ; COMDAT (pick any)
.text$mn:00010DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010DAC
.text$mn:00010DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00010DAC
.text$mn:00010DAC ; Attributes: bp-based frame
.text$mn:00010DAC
.text$mn:00010DAC ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:00010DAC                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:00010DAC ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:00010DAC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+21p
.text$mn:00010DAC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p ...
.text$mn:00010DAC
.text$mn:00010DAC var_4           = dword ptr -4
.text$mn:00010DAC Str             = dword ptr  8
.text$mn:00010DAC
.text$mn:00010DAC                 push    ebp
.text$mn:00010DAD                 mov     ebp, esp
.text$mn:00010DAF                 push    ecx
.text$mn:00010DB0                 mov     eax, [ebp+Str]
.text$mn:00010DB3                 movzx   ecx, word ptr [eax]
.text$mn:00010DB6                 test    ecx, ecx
.text$mn:00010DB8                 jnz     short loc_10DC3
.text$mn:00010DBA                 mov     [ebp+var_4], 0
.text$mn:00010DC1                 jmp     short loc_10DD2
.text$mn:00010DC3 ; ---------------------------------------------------------------------------
.text$mn:00010DC3
.text$mn:00010DC3 loc_10DC3:                              ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:00010DC3                 mov     edx, [ebp+Str]
.text$mn:00010DC6                 push    edx             ; Str
.text$mn:00010DC7                 call    _wcslen
.text$mn:00010DCC                 add     esp, 4
.text$mn:00010DCF                 mov     [ebp+var_4], eax
.text$mn:00010DD2
.text$mn:00010DD2 loc_10DD2:                              ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:00010DD2                 mov     eax, [ebp+var_4]
.text$mn:00010DD5                 mov     esp, ebp
.text$mn:00010DD7                 pop     ebp
.text$mn:00010DD8                 retn
.text$mn:00010DD8 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:00010DD8
.text$mn:00010DD8 ; ---------------------------------------------------------------------------
.text$mn:00010DD9                 align 4
.text$mn:00010DD9 _text$mn        ends
.text$mn:00010DD9
.text$mn:00010DDC ; ===========================================================================
.text$mn:00010DDC
.text$mn:00010DDC ; Segment type: Pure code
.text$mn:00010DDC ; Segment permissions: Read/Execute
.text$mn:00010DDC _text$mn        segment para public 'CODE' use32
.text$mn:00010DDC                 assume cs:_text$mn
.text$mn:00010DDC                 ;org 10DDCh
.text$mn:00010DDC ; COMDAT (pick any)
.text$mn:00010DDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010DDC
.text$mn:00010DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00010DDC
.text$mn:00010DDC ; Attributes: bp-based frame
.text$mn:00010DDC
.text$mn:00010DDC ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00010DDC                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00010DDC ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00010DDC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00010DDC
.text$mn:00010DDC var_4           = dword ptr -4
.text$mn:00010DDC
.text$mn:00010DDC                 push    ebp
.text$mn:00010DDD                 mov     ebp, esp
.text$mn:00010DDF                 push    ecx
.text$mn:00010DE0                 mov     [ebp+var_4], ecx
.text$mn:00010DE3                 mov     eax, [ebp+var_4]
.text$mn:00010DE6                 push    eax
.text$mn:00010DE7                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00010DEC                 add     esp, 4
.text$mn:00010DEF                 mov     esp, ebp
.text$mn:00010DF1                 pop     ebp
.text$mn:00010DF2                 retn
.text$mn:00010DF2 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00010DF2
.text$mn:00010DF2 ; ---------------------------------------------------------------------------
.text$mn:00010DF3                 align 4
.text$mn:00010DF3 _text$mn        ends
.text$mn:00010DF3
.text$mn:00010DF4 ; ===========================================================================
.text$mn:00010DF4
.text$mn:00010DF4 ; Segment type: Pure code
.text$mn:00010DF4 ; Segment permissions: Read/Execute
.text$mn:00010DF4 _text$mn        segment para public 'CODE' use32
.text$mn:00010DF4                 assume cs:_text$mn
.text$mn:00010DF4                 ;org 10DF4h
.text$mn:00010DF4 ; COMDAT (pick any)
.text$mn:00010DF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010DF4
.text$mn:00010DF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00010DF4
.text$mn:00010DF4 ; Attributes: bp-based frame
.text$mn:00010DF4
.text$mn:00010DF4 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<int>>::max_size(void)const
.text$mn:00010DF4                 public ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ
.text$mn:00010DF4 ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:00010DF4                                         ; CODE XREF: std::vector<int,std::allocator<int>>::max_size(void)+17p
.text$mn:00010DF4
.text$mn:00010DF4 var_4           = dword ptr -4
.text$mn:00010DF4
.text$mn:00010DF4                 push    ebp
.text$mn:00010DF5                 mov     ebp, esp
.text$mn:00010DF7                 push    ecx
.text$mn:00010DF8                 mov     [ebp+var_4], ecx
.text$mn:00010DFB                 mov     eax, [ebp+var_4]
.text$mn:00010DFE                 push    eax
.text$mn:00010DFF                 call    ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::allocator_traits<std::allocator<int>>::max_size(std::allocator<int> const &)
.text$mn:00010E04                 add     esp, 4
.text$mn:00010E07                 mov     esp, ebp
.text$mn:00010E09                 pop     ebp
.text$mn:00010E0A                 retn
.text$mn:00010E0A ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:00010E0A
.text$mn:00010E0A ; ---------------------------------------------------------------------------
.text$mn:00010E0B                 align 4
.text$mn:00010E0B _text$mn        ends
.text$mn:00010E0B
.text$mn:00010E0C ; ===========================================================================
.text$mn:00010E0C
.text$mn:00010E0C ; Segment type: Pure code
.text$mn:00010E0C ; Segment permissions: Read/Execute
.text$mn:00010E0C _text$mn        segment para public 'CODE' use32
.text$mn:00010E0C                 assume cs:_text$mn
.text$mn:00010E0C                 ;org 10E0Ch
.text$mn:00010E0C ; COMDAT (pick any)
.text$mn:00010E0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010E0C
.text$mn:00010E0C ; =============== S U B R O U T I N E =======================================
.text$mn:00010E0C
.text$mn:00010E0C ; Attributes: bp-based frame
.text$mn:00010E0C
.text$mn:00010E0C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<unsigned int>>::max_size(void)const
.text$mn:00010E0C                 public ?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIXZ
.text$mn:00010E0C ?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIXZ proc near
.text$mn:00010E0C                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::max_size(void)+17p
.text$mn:00010E0C
.text$mn:00010E0C var_4           = dword ptr -4
.text$mn:00010E0C
.text$mn:00010E0C                 push    ebp
.text$mn:00010E0D                 mov     ebp, esp
.text$mn:00010E0F                 push    ecx
.text$mn:00010E10                 mov     [ebp+var_4], ecx
.text$mn:00010E13                 mov     eax, [ebp+var_4]
.text$mn:00010E16                 push    eax
.text$mn:00010E17                 call    ?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z ; std::allocator_traits<std::allocator<uint>>::max_size(std::allocator<uint> const &)
.text$mn:00010E1C                 add     esp, 4
.text$mn:00010E1F                 mov     esp, ebp
.text$mn:00010E21                 pop     ebp
.text$mn:00010E22                 retn
.text$mn:00010E22 ?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIXZ endp
.text$mn:00010E22
.text$mn:00010E22 ; ---------------------------------------------------------------------------
.text$mn:00010E23                 align 4
.text$mn:00010E23 _text$mn        ends
.text$mn:00010E23
.text$mn:00010E24 ; ===========================================================================
.text$mn:00010E24
.text$mn:00010E24 ; Segment type: Pure code
.text$mn:00010E24 ; Segment permissions: Read/Execute
.text$mn:00010E24 _text$mn        segment para public 'CODE' use32
.text$mn:00010E24                 assume cs:_text$mn
.text$mn:00010E24                 ;org 10E24h
.text$mn:00010E24 ; COMDAT (pick any)
.text$mn:00010E24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010E24
.text$mn:00010E24 ; =============== S U B R O U T I N E =======================================
.text$mn:00010E24
.text$mn:00010E24 ; Attributes: bp-based frame
.text$mn:00010E24
.text$mn:00010E24 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>>::max_size(void)const
.text$mn:00010E24                 public ?max_size@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ
.text$mn:00010E24 ?max_size@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:00010E24                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::max_size(void)+17p
.text$mn:00010E24
.text$mn:00010E24 var_4           = dword ptr -4
.text$mn:00010E24
.text$mn:00010E24                 push    ebp
.text$mn:00010E25                 mov     ebp, esp
.text$mn:00010E27                 push    ecx
.text$mn:00010E28                 mov     [ebp+var_4], ecx
.text$mn:00010E2B                 mov     eax, [ebp+var_4]
.text$mn:00010E2E                 push    eax
.text$mn:00010E2F                 call    ?max_size@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAIABV?$allocator@UsessionFileInfo@@@2@@Z ; std::allocator_traits<std::allocator<sessionFileInfo>>::max_size(std::allocator<sessionFileInfo> const &)
.text$mn:00010E34                 add     esp, 4
.text$mn:00010E37                 mov     esp, ebp
.text$mn:00010E39                 pop     ebp
.text$mn:00010E3A                 retn
.text$mn:00010E3A ?max_size@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ endp
.text$mn:00010E3A
.text$mn:00010E3A ; ---------------------------------------------------------------------------
.text$mn:00010E3B                 align 4
.text$mn:00010E3B _text$mn        ends
.text$mn:00010E3B
.text$mn:00010E3C ; ===========================================================================
.text$mn:00010E3C
.text$mn:00010E3C ; Segment type: Pure code
.text$mn:00010E3C ; Segment permissions: Read/Execute
.text$mn:00010E3C _text$mn        segment para public 'CODE' use32
.text$mn:00010E3C                 assume cs:_text$mn
.text$mn:00010E3C                 ;org 10E3Ch
.text$mn:00010E3C ; COMDAT (pick any)
.text$mn:00010E3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010E3C
.text$mn:00010E3C ; =============== S U B R O U T I N E =======================================
.text$mn:00010E3C
.text$mn:00010E3C ; Attributes: bp-based frame
.text$mn:00010E3C
.text$mn:00010E3C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::max_size(void)const
.text$mn:00010E3C                 public ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEIXZ
.text$mn:00010E3C ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEIXZ proc near
.text$mn:00010E3C                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(void)+17p
.text$mn:00010E3C
.text$mn:00010E3C var_4           = dword ptr -4
.text$mn:00010E3C
.text$mn:00010E3C                 push    ebp
.text$mn:00010E3D                 mov     ebp, esp
.text$mn:00010E3F                 push    ecx
.text$mn:00010E40                 mov     [ebp+var_4], ecx
.text$mn:00010E43                 mov     eax, [ebp+var_4]
.text$mn:00010E46                 push    eax
.text$mn:00010E47                 call    ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)
.text$mn:00010E4C                 add     esp, 4
.text$mn:00010E4F                 mov     esp, ebp
.text$mn:00010E51                 pop     ebp
.text$mn:00010E52                 retn
.text$mn:00010E52 ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEIXZ endp
.text$mn:00010E52
.text$mn:00010E52 ; ---------------------------------------------------------------------------
.text$mn:00010E53                 align 4
.text$mn:00010E53 _text$mn        ends
.text$mn:00010E53
.text$mn:00010E54 ; ===========================================================================
.text$mn:00010E54
.text$mn:00010E54 ; Segment type: Pure code
.text$mn:00010E54 ; Segment permissions: Read/Execute
.text$mn:00010E54 _text$mn        segment para public 'CODE' use32
.text$mn:00010E54                 assume cs:_text$mn
.text$mn:00010E54                 ;org 10E54h
.text$mn:00010E54 ; COMDAT (pick any)
.text$mn:00010E54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010E54
.text$mn:00010E54 ; =============== S U B R O U T I N E =======================================
.text$mn:00010E54
.text$mn:00010E54 ; Attributes: bp-based frame
.text$mn:00010E54
.text$mn:00010E54 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:00010E54                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:00010E54 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:00010E54                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:00010E54
.text$mn:00010E54 var_4           = dword ptr -4
.text$mn:00010E54
.text$mn:00010E54                 push    ebp
.text$mn:00010E55                 mov     ebp, esp
.text$mn:00010E57                 push    ecx
.text$mn:00010E58                 mov     [ebp+var_4], ecx
.text$mn:00010E5B                 mov     eax, [ebp+var_4]
.text$mn:00010E5E                 push    eax
.text$mn:00010E5F                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:00010E64                 add     esp, 4
.text$mn:00010E67                 mov     esp, ebp
.text$mn:00010E69                 pop     ebp
.text$mn:00010E6A                 retn
.text$mn:00010E6A ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:00010E6A
.text$mn:00010E6A ; ---------------------------------------------------------------------------
.text$mn:00010E6B                 align 4
.text$mn:00010E6B _text$mn        ends
.text$mn:00010E6B
.text$mn:00010E6C ; ===========================================================================
.text$mn:00010E6C
.text$mn:00010E6C ; Segment type: Pure code
.text$mn:00010E6C ; Segment permissions: Read/Execute
.text$mn:00010E6C _text$mn        segment para public 'CODE' use32
.text$mn:00010E6C                 assume cs:_text$mn
.text$mn:00010E6C                 ;org 10E6Ch
.text$mn:00010E6C ; COMDAT (pick any)
.text$mn:00010E6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010E6C
.text$mn:00010E6C ; =============== S U B R O U T I N E =======================================
.text$mn:00010E6C
.text$mn:00010E6C ; Attributes: bp-based frame
.text$mn:00010E6C
.text$mn:00010E6C ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00010E6C                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00010E6C ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00010E6C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00010E6C
.text$mn:00010E6C var_4           = dword ptr -4
.text$mn:00010E6C
.text$mn:00010E6C                 push    ebp
.text$mn:00010E6D                 mov     ebp, esp
.text$mn:00010E6F                 push    ecx
.text$mn:00010E70                 mov     [ebp+var_4], ecx
.text$mn:00010E73                 or      eax, 0FFFFFFFFh
.text$mn:00010E76                 mov     esp, ebp
.text$mn:00010E78                 pop     ebp
.text$mn:00010E79                 retn
.text$mn:00010E79 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00010E79
.text$mn:00010E79 ; ---------------------------------------------------------------------------
.text$mn:00010E7A                 align 4
.text$mn:00010E7A _text$mn        ends
.text$mn:00010E7A
.text$mn:00010E7C ; ===========================================================================
.text$mn:00010E7C
.text$mn:00010E7C ; Segment type: Pure code
.text$mn:00010E7C ; Segment permissions: Read/Execute
.text$mn:00010E7C _text$mn        segment para public 'CODE' use32
.text$mn:00010E7C                 assume cs:_text$mn
.text$mn:00010E7C                 ;org 10E7Ch
.text$mn:00010E7C ; COMDAT (pick any)
.text$mn:00010E7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010E7C
.text$mn:00010E7C ; =============== S U B R O U T I N E =======================================
.text$mn:00010E7C
.text$mn:00010E7C ; Attributes: bp-based frame
.text$mn:00010E7C
.text$mn:00010E7C ; public: unsigned int __thiscall std::allocator<int>::max_size(void)const
.text$mn:00010E7C                 public ?max_size@?$allocator@H@std@@QBEIXZ
.text$mn:00010E7C ?max_size@?$allocator@H@std@@QBEIXZ proc near
.text$mn:00010E7C                                         ; CODE XREF: std::allocator_traits<std::allocator<int>>::max_size(std::allocator<int> const &)+6p
.text$mn:00010E7C
.text$mn:00010E7C var_4           = dword ptr -4
.text$mn:00010E7C
.text$mn:00010E7C                 push    ebp
.text$mn:00010E7D                 mov     ebp, esp
.text$mn:00010E7F                 push    ecx
.text$mn:00010E80                 mov     [ebp+var_4], ecx
.text$mn:00010E83                 mov     eax, 3FFFFFFFh
.text$mn:00010E88                 mov     esp, ebp
.text$mn:00010E8A                 pop     ebp
.text$mn:00010E8B                 retn
.text$mn:00010E8B ?max_size@?$allocator@H@std@@QBEIXZ endp
.text$mn:00010E8B
.text$mn:00010E8B _text$mn        ends
.text$mn:00010E8B
.text$mn:00010E8C ; ===========================================================================
.text$mn:00010E8C
.text$mn:00010E8C ; Segment type: Pure code
.text$mn:00010E8C ; Segment permissions: Read/Execute
.text$mn:00010E8C _text$mn        segment para public 'CODE' use32
.text$mn:00010E8C                 assume cs:_text$mn
.text$mn:00010E8C                 ;org 10E8Ch
.text$mn:00010E8C ; COMDAT (pick any)
.text$mn:00010E8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010E8C
.text$mn:00010E8C ; =============== S U B R O U T I N E =======================================
.text$mn:00010E8C
.text$mn:00010E8C ; Attributes: bp-based frame
.text$mn:00010E8C
.text$mn:00010E8C ; public: unsigned int __thiscall std::allocator<unsigned int>::max_size(void)const
.text$mn:00010E8C                 public ?max_size@?$allocator@I@std@@QBEIXZ
.text$mn:00010E8C ?max_size@?$allocator@I@std@@QBEIXZ proc near
.text$mn:00010E8C                                         ; CODE XREF: std::allocator_traits<std::allocator<uint>>::max_size(std::allocator<uint> const &)+6p
.text$mn:00010E8C
.text$mn:00010E8C var_4           = dword ptr -4
.text$mn:00010E8C
.text$mn:00010E8C                 push    ebp
.text$mn:00010E8D                 mov     ebp, esp
.text$mn:00010E8F                 push    ecx
.text$mn:00010E90                 mov     [ebp+var_4], ecx
.text$mn:00010E93                 mov     eax, 3FFFFFFFh
.text$mn:00010E98                 mov     esp, ebp
.text$mn:00010E9A                 pop     ebp
.text$mn:00010E9B                 retn
.text$mn:00010E9B ?max_size@?$allocator@I@std@@QBEIXZ endp
.text$mn:00010E9B
.text$mn:00010E9B _text$mn        ends
.text$mn:00010E9B
.text$mn:00010E9C ; ===========================================================================
.text$mn:00010E9C
.text$mn:00010E9C ; Segment type: Pure code
.text$mn:00010E9C ; Segment permissions: Read/Execute
.text$mn:00010E9C _text$mn        segment para public 'CODE' use32
.text$mn:00010E9C                 assume cs:_text$mn
.text$mn:00010E9C                 ;org 10E9Ch
.text$mn:00010E9C ; COMDAT (pick any)
.text$mn:00010E9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010E9C
.text$mn:00010E9C ; =============== S U B R O U T I N E =======================================
.text$mn:00010E9C
.text$mn:00010E9C ; Attributes: bp-based frame
.text$mn:00010E9C
.text$mn:00010E9C ; public: unsigned int __thiscall std::allocator<struct sessionFileInfo>::max_size(void)const
.text$mn:00010E9C                 public ?max_size@?$allocator@UsessionFileInfo@@@std@@QBEIXZ
.text$mn:00010E9C ?max_size@?$allocator@UsessionFileInfo@@@std@@QBEIXZ proc near
.text$mn:00010E9C                                         ; CODE XREF: std::allocator_traits<std::allocator<sessionFileInfo>>::max_size(std::allocator<sessionFileInfo> const &)+6p
.text$mn:00010E9C
.text$mn:00010E9C var_4           = dword ptr -4
.text$mn:00010E9C
.text$mn:00010E9C                 push    ebp
.text$mn:00010E9D                 mov     ebp, esp
.text$mn:00010E9F                 push    ecx
.text$mn:00010EA0                 mov     [ebp+var_4], ecx
.text$mn:00010EA3                 mov     eax, 1AF286Bh
.text$mn:00010EA8                 mov     esp, ebp
.text$mn:00010EAA                 pop     ebp
.text$mn:00010EAB                 retn
.text$mn:00010EAB ?max_size@?$allocator@UsessionFileInfo@@@std@@QBEIXZ endp
.text$mn:00010EAB
.text$mn:00010EAB _text$mn        ends
.text$mn:00010EAB
.text$mn:00010EAC ; ===========================================================================
.text$mn:00010EAC
.text$mn:00010EAC ; Segment type: Pure code
.text$mn:00010EAC ; Segment permissions: Read/Execute
.text$mn:00010EAC _text$mn        segment para public 'CODE' use32
.text$mn:00010EAC                 assume cs:_text$mn
.text$mn:00010EAC                 ;org 10EACh
.text$mn:00010EAC ; COMDAT (pick any)
.text$mn:00010EAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010EAC
.text$mn:00010EAC ; =============== S U B R O U T I N E =======================================
.text$mn:00010EAC
.text$mn:00010EAC ; Attributes: bp-based frame
.text$mn:00010EAC
.text$mn:00010EAC ; public: unsigned int __thiscall std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>::max_size(void)const
.text$mn:00010EAC                 public ?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ
.text$mn:00010EAC ?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ proc near
.text$mn:00010EAC                                         ; CODE XREF: std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)+6p
.text$mn:00010EAC
.text$mn:00010EAC var_4           = dword ptr -4
.text$mn:00010EAC
.text$mn:00010EAC                 push    ebp
.text$mn:00010EAD                 mov     ebp, esp
.text$mn:00010EAF                 push    ecx
.text$mn:00010EB0                 mov     [ebp+var_4], ecx
.text$mn:00010EB3                 mov     eax, 9249249h
.text$mn:00010EB8                 mov     esp, ebp
.text$mn:00010EBA                 pop     ebp
.text$mn:00010EBB                 retn
.text$mn:00010EBB ?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ endp
.text$mn:00010EBB
.text$mn:00010EBB _text$mn        ends
.text$mn:00010EBB
.text$mn:00010EBC ; ===========================================================================
.text$mn:00010EBC
.text$mn:00010EBC ; Segment type: Pure code
.text$mn:00010EBC ; Segment permissions: Read/Execute
.text$mn:00010EBC _text$mn        segment para public 'CODE' use32
.text$mn:00010EBC                 assume cs:_text$mn
.text$mn:00010EBC                 ;org 10EBCh
.text$mn:00010EBC ; COMDAT (pick any)
.text$mn:00010EBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010EBC
.text$mn:00010EBC ; =============== S U B R O U T I N E =======================================
.text$mn:00010EBC
.text$mn:00010EBC ; Attributes: bp-based frame
.text$mn:00010EBC
.text$mn:00010EBC ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:00010EBC                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:00010EBC ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:00010EBC                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:00010EBC
.text$mn:00010EBC var_4           = dword ptr -4
.text$mn:00010EBC
.text$mn:00010EBC                 push    ebp
.text$mn:00010EBD                 mov     ebp, esp
.text$mn:00010EBF                 push    ecx
.text$mn:00010EC0                 mov     [ebp+var_4], ecx
.text$mn:00010EC3                 mov     eax, 7FFFFFFFh
.text$mn:00010EC8                 mov     esp, ebp
.text$mn:00010ECA                 pop     ebp
.text$mn:00010ECB                 retn
.text$mn:00010ECB ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:00010ECB
.text$mn:00010ECB _text$mn        ends
.text$mn:00010ECB
.text$mn:00010ECC ; ===========================================================================
.text$mn:00010ECC
.text$mn:00010ECC ; Segment type: Pure code
.text$mn:00010ECC ; Segment permissions: Read/Execute
.text$mn:00010ECC _text$mn        segment para public 'CODE' use32
.text$mn:00010ECC                 assume cs:_text$mn
.text$mn:00010ECC                 ;org 10ECCh
.text$mn:00010ECC ; COMDAT (pick any)
.text$mn:00010ECC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010ECC
.text$mn:00010ECC ; =============== S U B R O U T I N E =======================================
.text$mn:00010ECC
.text$mn:00010ECC ; Attributes: bp-based frame
.text$mn:00010ECC
.text$mn:00010ECC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00010ECC                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00010ECC ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00010ECC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00010ECC
.text$mn:00010ECC arg_0           = dword ptr  8
.text$mn:00010ECC
.text$mn:00010ECC                 push    ebp
.text$mn:00010ECD                 mov     ebp, esp
.text$mn:00010ECF                 mov     ecx, [ebp+arg_0]
.text$mn:00010ED2                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00010ED7                 pop     ebp
.text$mn:00010ED8                 retn
.text$mn:00010ED8 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00010ED8
.text$mn:00010ED8 ; ---------------------------------------------------------------------------
.text$mn:00010ED9                 align 4
.text$mn:00010ED9 _text$mn        ends
.text$mn:00010ED9
.text$mn:00010EDC ; ===========================================================================
.text$mn:00010EDC
.text$mn:00010EDC ; Segment type: Pure code
.text$mn:00010EDC ; Segment permissions: Read/Execute
.text$mn:00010EDC _text$mn        segment para public 'CODE' use32
.text$mn:00010EDC                 assume cs:_text$mn
.text$mn:00010EDC                 ;org 10EDCh
.text$mn:00010EDC ; COMDAT (pick any)
.text$mn:00010EDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010EDC
.text$mn:00010EDC ; =============== S U B R O U T I N E =======================================
.text$mn:00010EDC
.text$mn:00010EDC ; Attributes: bp-based frame
.text$mn:00010EDC
.text$mn:00010EDC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<int>>::max_size(class std::allocator<int> const &)
.text$mn:00010EDC                 public ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z
.text$mn:00010EDC ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z proc near
.text$mn:00010EDC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::max_size(void)+Bp
.text$mn:00010EDC
.text$mn:00010EDC arg_0           = dword ptr  8
.text$mn:00010EDC
.text$mn:00010EDC                 push    ebp
.text$mn:00010EDD                 mov     ebp, esp
.text$mn:00010EDF                 mov     ecx, [ebp+arg_0]
.text$mn:00010EE2                 call    ?max_size@?$allocator@H@std@@QBEIXZ ; std::allocator<int>::max_size(void)
.text$mn:00010EE7                 pop     ebp
.text$mn:00010EE8                 retn
.text$mn:00010EE8 ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z endp
.text$mn:00010EE8
.text$mn:00010EE8 ; ---------------------------------------------------------------------------
.text$mn:00010EE9                 align 4
.text$mn:00010EE9 _text$mn        ends
.text$mn:00010EE9
.text$mn:00010EEC ; ===========================================================================
.text$mn:00010EEC
.text$mn:00010EEC ; Segment type: Pure code
.text$mn:00010EEC ; Segment permissions: Read/Execute
.text$mn:00010EEC _text$mn        segment para public 'CODE' use32
.text$mn:00010EEC                 assume cs:_text$mn
.text$mn:00010EEC                 ;org 10EECh
.text$mn:00010EEC ; COMDAT (pick any)
.text$mn:00010EEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010EEC
.text$mn:00010EEC ; =============== S U B R O U T I N E =======================================
.text$mn:00010EEC
.text$mn:00010EEC ; Attributes: bp-based frame
.text$mn:00010EEC
.text$mn:00010EEC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<unsigned int>>::max_size(class std::allocator<unsigned int> const &)
.text$mn:00010EEC                 public ?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z
.text$mn:00010EEC ?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z proc near
.text$mn:00010EEC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::max_size(void)+Bp
.text$mn:00010EEC
.text$mn:00010EEC arg_0           = dword ptr  8
.text$mn:00010EEC
.text$mn:00010EEC                 push    ebp
.text$mn:00010EED                 mov     ebp, esp
.text$mn:00010EEF                 mov     ecx, [ebp+arg_0]
.text$mn:00010EF2                 call    ?max_size@?$allocator@I@std@@QBEIXZ ; std::allocator<uint>::max_size(void)
.text$mn:00010EF7                 pop     ebp
.text$mn:00010EF8                 retn
.text$mn:00010EF8 ?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z endp
.text$mn:00010EF8
.text$mn:00010EF8 ; ---------------------------------------------------------------------------
.text$mn:00010EF9                 align 4
.text$mn:00010EF9 _text$mn        ends
.text$mn:00010EF9
.text$mn:00010EFC ; ===========================================================================
.text$mn:00010EFC
.text$mn:00010EFC ; Segment type: Pure code
.text$mn:00010EFC ; Segment permissions: Read/Execute
.text$mn:00010EFC _text$mn        segment para public 'CODE' use32
.text$mn:00010EFC                 assume cs:_text$mn
.text$mn:00010EFC                 ;org 10EFCh
.text$mn:00010EFC ; COMDAT (pick any)
.text$mn:00010EFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010EFC
.text$mn:00010EFC ; =============== S U B R O U T I N E =======================================
.text$mn:00010EFC
.text$mn:00010EFC ; Attributes: bp-based frame
.text$mn:00010EFC
.text$mn:00010EFC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct sessionFileInfo>>::max_size(class std::allocator<struct sessionFileInfo> const &)
.text$mn:00010EFC                 public ?max_size@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAIABV?$allocator@UsessionFileInfo@@@2@@Z
.text$mn:00010EFC ?max_size@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAIABV?$allocator@UsessionFileInfo@@@2@@Z proc near
.text$mn:00010EFC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<sessionFileInfo>>::max_size(void)+Bp
.text$mn:00010EFC
.text$mn:00010EFC arg_0           = dword ptr  8
.text$mn:00010EFC
.text$mn:00010EFC                 push    ebp
.text$mn:00010EFD                 mov     ebp, esp
.text$mn:00010EFF                 mov     ecx, [ebp+arg_0]
.text$mn:00010F02                 call    ?max_size@?$allocator@UsessionFileInfo@@@std@@QBEIXZ ; std::allocator<sessionFileInfo>::max_size(void)
.text$mn:00010F07                 pop     ebp
.text$mn:00010F08                 retn
.text$mn:00010F08 ?max_size@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SAIABV?$allocator@UsessionFileInfo@@@2@@Z endp
.text$mn:00010F08
.text$mn:00010F08 ; ---------------------------------------------------------------------------
.text$mn:00010F09                 align 4
.text$mn:00010F09 _text$mn        ends
.text$mn:00010F09
.text$mn:00010F0C ; ===========================================================================
.text$mn:00010F0C
.text$mn:00010F0C ; Segment type: Pure code
.text$mn:00010F0C ; Segment permissions: Read/Execute
.text$mn:00010F0C _text$mn        segment para public 'CODE' use32
.text$mn:00010F0C                 assume cs:_text$mn
.text$mn:00010F0C                 ;org 10F0Ch
.text$mn:00010F0C ; COMDAT (pick any)
.text$mn:00010F0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010F0C
.text$mn:00010F0C ; =============== S U B R O U T I N E =======================================
.text$mn:00010F0C
.text$mn:00010F0C ; Attributes: bp-based frame
.text$mn:00010F0C
.text$mn:00010F0C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::max_size(class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>> const &)
.text$mn:00010F0C                 public ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z
.text$mn:00010F0C ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z proc near
.text$mn:00010F0C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(void)+Bp
.text$mn:00010F0C
.text$mn:00010F0C arg_0           = dword ptr  8
.text$mn:00010F0C
.text$mn:00010F0C                 push    ebp
.text$mn:00010F0D                 mov     ebp, esp
.text$mn:00010F0F                 mov     ecx, [ebp+arg_0]
.text$mn:00010F12                 call    ?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::max_size(void)
.text$mn:00010F17                 pop     ebp
.text$mn:00010F18                 retn
.text$mn:00010F18 ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z endp
.text$mn:00010F18
.text$mn:00010F18 ; ---------------------------------------------------------------------------
.text$mn:00010F19                 align 4
.text$mn:00010F19 _text$mn        ends
.text$mn:00010F19
.text$mn:00010F1C ; ===========================================================================
.text$mn:00010F1C
.text$mn:00010F1C ; Segment type: Pure code
.text$mn:00010F1C ; Segment permissions: Read/Execute
.text$mn:00010F1C _text$mn        segment para public 'CODE' use32
.text$mn:00010F1C                 assume cs:_text$mn
.text$mn:00010F1C                 ;org 10F1Ch
.text$mn:00010F1C ; COMDAT (pick any)
.text$mn:00010F1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010F1C
.text$mn:00010F1C ; =============== S U B R O U T I N E =======================================
.text$mn:00010F1C
.text$mn:00010F1C ; Attributes: bp-based frame
.text$mn:00010F1C
.text$mn:00010F1C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:00010F1C                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:00010F1C ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:00010F1C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:00010F1C
.text$mn:00010F1C arg_0           = dword ptr  8
.text$mn:00010F1C
.text$mn:00010F1C                 push    ebp
.text$mn:00010F1D                 mov     ebp, esp
.text$mn:00010F1F                 mov     ecx, [ebp+arg_0]
.text$mn:00010F22                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:00010F27                 pop     ebp
.text$mn:00010F28                 retn
.text$mn:00010F28 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:00010F28
.text$mn:00010F28 ; ---------------------------------------------------------------------------
.text$mn:00010F29                 align 4
.text$mn:00010F29 _text$mn        ends
.text$mn:00010F29
.text$mn:00010F2C ; ===========================================================================
.text$mn:00010F2C
.text$mn:00010F2C ; Segment type: Pure code
.text$mn:00010F2C ; Segment permissions: Read/Execute
.text$mn:00010F2C _text$mn        segment para public 'CODE' use32
.text$mn:00010F2C                 assume cs:_text$mn
.text$mn:00010F2C                 ;org 10F2Ch
.text$mn:00010F2C ; COMDAT (pick any)
.text$mn:00010F2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010F2C
.text$mn:00010F2C ; =============== S U B R O U T I N E =======================================
.text$mn:00010F2C
.text$mn:00010F2C ; Attributes: bp-based frame
.text$mn:00010F2C
.text$mn:00010F2C ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00010F2C                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00010F2C ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00010F2C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00010F2C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00010F2C
.text$mn:00010F2C var_10          = dword ptr -10h
.text$mn:00010F2C var_C           = dword ptr -0Ch
.text$mn:00010F2C var_8           = dword ptr -8
.text$mn:00010F2C var_1           = byte ptr -1
.text$mn:00010F2C
.text$mn:00010F2C                 push    ebp
.text$mn:00010F2D                 mov     ebp, esp
.text$mn:00010F2F                 sub     esp, 10h
.text$mn:00010F32                 mov     [ebp+var_10], ecx
.text$mn:00010F35                 lea     eax, [ebp+var_1]
.text$mn:00010F38                 push    eax
.text$mn:00010F39                 mov     ecx, [ebp+var_10]
.text$mn:00010F3C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00010F41                 mov     ecx, eax
.text$mn:00010F43                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00010F48                 mov     [ebp+var_8], eax
.text$mn:00010F4B                 cmp     [ebp+var_8], 1
.text$mn:00010F4F                 ja      short loc_10F5A
.text$mn:00010F51                 mov     [ebp+var_C], 1
.text$mn:00010F58                 jmp     short loc_10F63
.text$mn:00010F5A ; ---------------------------------------------------------------------------
.text$mn:00010F5A
.text$mn:00010F5A loc_10F5A:                              ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00010F5A                 mov     ecx, [ebp+var_8]
.text$mn:00010F5D                 sub     ecx, 1
.text$mn:00010F60                 mov     [ebp+var_C], ecx
.text$mn:00010F63
.text$mn:00010F63 loc_10F63:                              ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00010F63                 mov     eax, [ebp+var_C]
.text$mn:00010F66                 mov     esp, ebp
.text$mn:00010F68                 pop     ebp
.text$mn:00010F69                 retn
.text$mn:00010F69 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00010F69
.text$mn:00010F69 ; ---------------------------------------------------------------------------
.text$mn:00010F6A                 align 4
.text$mn:00010F6A _text$mn        ends
.text$mn:00010F6A
.text$mn:00010F6C ; ===========================================================================
.text$mn:00010F6C
.text$mn:00010F6C ; Segment type: Pure code
.text$mn:00010F6C ; Segment permissions: Read/Execute
.text$mn:00010F6C _text$mn        segment para public 'CODE' use32
.text$mn:00010F6C                 assume cs:_text$mn
.text$mn:00010F6C                 ;org 10F6Ch
.text$mn:00010F6C ; COMDAT (pick any)
.text$mn:00010F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010F6C
.text$mn:00010F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00010F6C
.text$mn:00010F6C ; Attributes: bp-based frame
.text$mn:00010F6C
.text$mn:00010F6C ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:00010F6C                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00010F6C ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00010F6C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:00010F6C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:00010F6C
.text$mn:00010F6C var_10          = dword ptr -10h
.text$mn:00010F6C var_C           = dword ptr -0Ch
.text$mn:00010F6C var_8           = dword ptr -8
.text$mn:00010F6C var_1           = byte ptr -1
.text$mn:00010F6C
.text$mn:00010F6C                 push    ebp
.text$mn:00010F6D                 mov     ebp, esp
.text$mn:00010F6F                 sub     esp, 10h
.text$mn:00010F72                 mov     [ebp+var_10], ecx
.text$mn:00010F75                 lea     eax, [ebp+var_1]
.text$mn:00010F78                 push    eax
.text$mn:00010F79                 mov     ecx, [ebp+var_10]
.text$mn:00010F7C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00010F81                 mov     ecx, eax
.text$mn:00010F83                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:00010F88                 mov     [ebp+var_8], eax
.text$mn:00010F8B                 cmp     [ebp+var_8], 1
.text$mn:00010F8F                 ja      short loc_10F9A
.text$mn:00010F91                 mov     [ebp+var_C], 1
.text$mn:00010F98                 jmp     short loc_10FA3
.text$mn:00010F9A ; ---------------------------------------------------------------------------
.text$mn:00010F9A
.text$mn:00010F9A loc_10F9A:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:00010F9A                 mov     ecx, [ebp+var_8]
.text$mn:00010F9D                 sub     ecx, 1
.text$mn:00010FA0                 mov     [ebp+var_C], ecx
.text$mn:00010FA3
.text$mn:00010FA3 loc_10FA3:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:00010FA3                 mov     eax, [ebp+var_C]
.text$mn:00010FA6                 mov     esp, ebp
.text$mn:00010FA8                 pop     ebp
.text$mn:00010FA9                 retn
.text$mn:00010FA9 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00010FA9
.text$mn:00010FA9 ; ---------------------------------------------------------------------------
.text$mn:00010FAA                 align 4
.text$mn:00010FAA _text$mn        ends
.text$mn:00010FAA
.text$mn:00010FAC ; ===========================================================================
.text$mn:00010FAC
.text$mn:00010FAC ; Segment type: Pure code
.text$mn:00010FAC ; Segment permissions: Read/Execute
.text$mn:00010FAC _text$mn        segment para public 'CODE' use32
.text$mn:00010FAC                 assume cs:_text$mn
.text$mn:00010FAC                 ;org 10FACh
.text$mn:00010FAC ; COMDAT (pick any)
.text$mn:00010FAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010FAC
.text$mn:00010FAC ; =============== S U B R O U T I N E =======================================
.text$mn:00010FAC
.text$mn:00010FAC ; Attributes: bp-based frame
.text$mn:00010FAC
.text$mn:00010FAC ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::max_size(void)const
.text$mn:00010FAC                 public ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:00010FAC ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:00010FAC                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+17p
.text$mn:00010FAC                                         ; std::vector<int,std::allocator<int>>::_Reserve(uint)+18p
.text$mn:00010FAC
.text$mn:00010FAC var_8           = dword ptr -8
.text$mn:00010FAC var_1           = byte ptr -1
.text$mn:00010FAC
.text$mn:00010FAC                 push    ebp
.text$mn:00010FAD                 mov     ebp, esp
.text$mn:00010FAF                 sub     esp, 8
.text$mn:00010FB2                 mov     [ebp+var_8], ecx
.text$mn:00010FB5                 lea     eax, [ebp+var_1]
.text$mn:00010FB8                 push    eax
.text$mn:00010FB9                 mov     ecx, [ebp+var_8]
.text$mn:00010FBC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00010FC1                 mov     ecx, eax
.text$mn:00010FC3                 call    ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<int>>::max_size(void)
.text$mn:00010FC8                 mov     esp, ebp
.text$mn:00010FCA                 pop     ebp
.text$mn:00010FCB                 retn
.text$mn:00010FCB ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:00010FCB
.text$mn:00010FCB _text$mn        ends
.text$mn:00010FCB
.text$mn:00010FCC ; ===========================================================================
.text$mn:00010FCC
.text$mn:00010FCC ; Segment type: Pure code
.text$mn:00010FCC ; Segment permissions: Read/Execute
.text$mn:00010FCC _text$mn        segment para public 'CODE' use32
.text$mn:00010FCC                 assume cs:_text$mn
.text$mn:00010FCC                 ;org 10FCCh
.text$mn:00010FCC ; COMDAT (pick any)
.text$mn:00010FCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010FCC
.text$mn:00010FCC ; =============== S U B R O U T I N E =======================================
.text$mn:00010FCC
.text$mn:00010FCC ; Attributes: bp-based frame
.text$mn:00010FCC
.text$mn:00010FCC ; public: unsigned int __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::max_size(void)const
.text$mn:00010FCC                 public ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
.text$mn:00010FCC ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ proc near
.text$mn:00010FCC                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Buy(uint)+36p
.text$mn:00010FCC
.text$mn:00010FCC var_8           = dword ptr -8
.text$mn:00010FCC var_1           = byte ptr -1
.text$mn:00010FCC
.text$mn:00010FCC                 push    ebp
.text$mn:00010FCD                 mov     ebp, esp
.text$mn:00010FCF                 sub     esp, 8
.text$mn:00010FD2                 mov     [ebp+var_8], ecx
.text$mn:00010FD5                 lea     eax, [ebp+var_1]
.text$mn:00010FD8                 push    eax
.text$mn:00010FD9                 mov     ecx, [ebp+var_8]
.text$mn:00010FDC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:00010FE1                 mov     ecx, eax
.text$mn:00010FE3                 call    ?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<uint>>::max_size(void)
.text$mn:00010FE8                 mov     esp, ebp
.text$mn:00010FEA                 pop     ebp
.text$mn:00010FEB                 retn
.text$mn:00010FEB ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ endp
.text$mn:00010FEB
.text$mn:00010FEB _text$mn        ends
.text$mn:00010FEB
.text$mn:00010FEC ; ===========================================================================
.text$mn:00010FEC
.text$mn:00010FEC ; Segment type: Pure code
.text$mn:00010FEC ; Segment permissions: Read/Execute
.text$mn:00010FEC _text$mn        segment para public 'CODE' use32
.text$mn:00010FEC                 assume cs:_text$mn
.text$mn:00010FEC                 ;org 10FECh
.text$mn:00010FEC ; COMDAT (pick any)
.text$mn:00010FEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00010FEC
.text$mn:00010FEC ; =============== S U B R O U T I N E =======================================
.text$mn:00010FEC
.text$mn:00010FEC ; Attributes: bp-based frame
.text$mn:00010FEC
.text$mn:00010FEC ; public: unsigned int __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::max_size(void)const
.text$mn:00010FEC                 public ?max_size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ
.text$mn:00010FEC ?max_size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:00010FEC                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Buy(uint)+36p
.text$mn:00010FEC                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Grow_to(uint)+17p ...
.text$mn:00010FEC
.text$mn:00010FEC var_8           = dword ptr -8
.text$mn:00010FEC var_1           = byte ptr -1
.text$mn:00010FEC
.text$mn:00010FEC                 push    ebp
.text$mn:00010FED                 mov     ebp, esp
.text$mn:00010FEF                 sub     esp, 8
.text$mn:00010FF2                 mov     [ebp+var_8], ecx
.text$mn:00010FF5                 lea     eax, [ebp+var_1]
.text$mn:00010FF8                 push    eax
.text$mn:00010FF9                 mov     ecx, [ebp+var_8]
.text$mn:00010FFC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Getal(void)
.text$mn:00011001                 mov     ecx, eax
.text$mn:00011003                 call    ?max_size@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::max_size(void)
.text$mn:00011008                 mov     esp, ebp
.text$mn:0001100A                 pop     ebp
.text$mn:0001100B                 retn
.text$mn:0001100B ?max_size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ endp
.text$mn:0001100B
.text$mn:0001100B _text$mn        ends
.text$mn:0001100B
.text$mn:0001100C ; ===========================================================================
.text$mn:0001100C
.text$mn:0001100C ; Segment type: Pure code
.text$mn:0001100C ; Segment permissions: Read/Execute
.text$mn:0001100C _text$mn        segment para public 'CODE' use32
.text$mn:0001100C                 assume cs:_text$mn
.text$mn:0001100C                 ;org 1100Ch
.text$mn:0001100C ; COMDAT (pick any)
.text$mn:0001100C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0001100C
.text$mn:0001100C ; =============== S U B R O U T I N E =======================================
.text$mn:0001100C
.text$mn:0001100C ; Attributes: bp-based frame
.text$mn:0001100C
.text$mn:0001100C ; public: unsigned int __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::max_size(void)const
.text$mn:0001100C                 public ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ
.text$mn:0001100C ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ proc near
.text$mn:0001100C                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)+17p
.text$mn:0001100C                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+18p
.text$mn:0001100C
.text$mn:0001100C var_8           = dword ptr -8
.text$mn:0001100C var_1           = byte ptr -1
.text$mn:0001100C
.text$mn:0001100C                 push    ebp
.text$mn:0001100D                 mov     ebp, esp
.text$mn:0001100F                 sub     esp, 8
.text$mn:00011012                 mov     [ebp+var_8], ecx
.text$mn:00011015                 lea     eax, [ebp+var_1]
.text$mn:00011018                 push    eax
.text$mn:00011019                 mov     ecx, [ebp+var_8]
.text$mn:0001101C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:00011021                 mov     ecx, eax
.text$mn:00011023                 call    ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(void)
.text$mn:00011028                 mov     esp, ebp
.text$mn:0001102A                 pop     ebp
.text$mn:0001102B                 retn
.text$mn:0001102B ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ endp
.text$mn:0001102B
.text$mn:0001102B _text$mn        ends
.text$mn:0001102B
.text$mn:0001102C ; ===========================================================================
.text$mn:0001102C
.text$mn:0001102C ; Segment type: Pure code
.text$mn:0001102C ; Segment permissions: Read/Execute
.text$mn:0001102C _text$mn        segment para public 'CODE' use32
.text$mn:0001102C                 assume cs:_text$mn
.text$mn:0001102C                 ;org 1102Ch
.text$mn:0001102C ; COMDAT (pick any)
.text$mn:0001102C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0001102C
.text$mn:0001102C ; =============== S U B R O U T I N E =======================================
.text$mn:0001102C
.text$mn:0001102C ; Attributes: bp-based frame
.text$mn:0001102C
.text$mn:0001102C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:0001102C                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0001102C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0001102C                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:0001102C                                         ; DATA XREF: .rdata:00014430o
.text$mn:0001102C
.text$mn:0001102C var_1C          = dword ptr -1Ch
.text$mn:0001102C var_18          = dword ptr -18h
.text$mn:0001102C Str             = dword ptr -14h
.text$mn:0001102C var_10          = dword ptr -10h
.text$mn:0001102C var_C           = dword ptr -0Ch
.text$mn:0001102C var_4           = dword ptr -4
.text$mn:0001102C arg_0           = dword ptr  8
.text$mn:0001102C arg_4           = dword ptr  0Ch
.text$mn:0001102C
.text$mn:0001102C                 push    ebp
.text$mn:0001102D                 mov     ebp, esp
.text$mn:0001102F                 push    0FFFFFFFFh
.text$mn:00011031                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00011036                 mov     eax, large fs:0
.text$mn:0001103C                 push    eax
.text$mn:0001103D                 sub     esp, 10h
.text$mn:00011040                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00011045                 xor     eax, ebp
.text$mn:00011047                 push    eax
.text$mn:00011048                 lea     eax, [ebp+var_C]
.text$mn:0001104B                 mov     large fs:0, eax
.text$mn:00011051                 mov     [ebp+var_1C], ecx
.text$mn:00011054                 mov     [ebp+var_18], 0
.text$mn:0001105B                 mov     eax, [ebp+arg_4]
.text$mn:0001105E                 push    eax             ; int
.text$mn:0001105F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00011064                 add     esp, 4
.text$mn:00011067                 mov     [ebp+var_10], eax
.text$mn:0001106A                 cmp     [ebp+var_10], 0
.text$mn:0001106E                 jz      short loc_11078
.text$mn:00011070                 mov     ecx, [ebp+var_10]
.text$mn:00011073                 mov     [ebp+Str], ecx
.text$mn:00011076                 jmp     short loc_1107F
.text$mn:00011078 ; ---------------------------------------------------------------------------
.text$mn:00011078
.text$mn:00011078 loc_11078:                              ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00011078                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0001107F
.text$mn:0001107F loc_1107F:                              ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0001107F                 mov     edx, [ebp+Str]
.text$mn:00011082                 push    edx             ; Str
.text$mn:00011083                 mov     ecx, [ebp+arg_0]
.text$mn:00011086                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0001108B                 mov     [ebp+var_4], 0
.text$mn:00011092                 mov     eax, [ebp+var_18]
.text$mn:00011095                 or      eax, 1
.text$mn:00011098                 mov     [ebp+var_18], eax
.text$mn:0001109B                 mov     eax, [ebp+arg_0]
.text$mn:0001109E                 mov     ecx, [ebp+var_C]
.text$mn:000110A1                 mov     large fs:0, ecx
.text$mn:000110A8                 pop     ecx
.text$mn:000110A9                 mov     esp, ebp
.text$mn:000110AB                 pop     ebp
.text$mn:000110AC                 retn    8
.text$mn:000110AC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000110AC
.text$mn:000110AC ; ---------------------------------------------------------------------------
.text$mn:000110AF                 align 10h
.text$mn:000110AF _text$mn        ends
.text$mn:000110AF
.text$x:000110B0 ; ===========================================================================
.text$x:000110B0
.text$x:000110B0 ; Segment type: Pure code
.text$x:000110B0 ; Segment permissions: Read/Execute
.text$x:000110B0 _text$x         segment para public 'CODE' use32
.text$x:000110B0                 assume cs:_text$x
.text$x:000110B0                 ;org 110B0h
.text$x:000110B0 ; COMDAT (pick associative to section at 1102C)
.text$x:000110B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000110B0
.text$x:000110B0 ; =============== S U B R O U T I N E =======================================
.text$x:000110B0
.text$x:000110B0
.text$x:000110B0 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000110B0                                         ; DATA XREF: .xdata$x:000125E8o
.text$x:000110B0                 mov     eax, [ebp-18h]
.text$x:000110B3                 and     eax, 1
.text$x:000110B6                 jz      $LN6
.text$x:000110BC                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000110C0                 mov     ecx, [ebp+8]
.text$x:000110C3                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000110C8 ; ---------------------------------------------------------------------------
.text$x:000110C8
.text$x:000110C8 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000110C8                 retn
.text$x:000110C8 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000110C8
.text$x:000110C9
.text$x:000110C9 ; =============== S U B R O U T I N E =======================================
.text$x:000110C9
.text$x:000110C9
.text$x:000110C9 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000110C9                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:000110C9
.text$x:000110C9 arg_4           = dword ptr  8
.text$x:000110C9
.text$x:000110C9                 mov     edx, [esp+arg_4]
.text$x:000110CD                 lea     eax, [edx+0Ch]
.text$x:000110D0                 mov     ecx, [edx-14h]
.text$x:000110D3                 xor     ecx, eax
.text$x:000110D5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000110DA                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000110DF                 jmp     ___CxxFrameHandler3
.text$x:000110DF __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000110DF
.text$x:000110DF _text$x         ends
.text$x:000110DF
.text$mn:000110E4 ; ===========================================================================
.text$mn:000110E4
.text$mn:000110E4 ; Segment type: Pure code
.text$mn:000110E4 ; Segment permissions: Read/Execute
.text$mn:000110E4 _text$mn        segment para public 'CODE' use32
.text$mn:000110E4                 assume cs:_text$mn
.text$mn:000110E4                 ;org 110E4h
.text$mn:000110E4 ; COMDAT (pick any)
.text$mn:000110E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000110E4
.text$mn:000110E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000110E4
.text$mn:000110E4 ; Attributes: bp-based frame
.text$mn:000110E4
.text$mn:000110E4 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:000110E4                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000110E4 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000110E4                                         ; DATA XREF: .rdata:00014464o
.text$mn:000110E4
.text$mn:000110E4 var_14          = dword ptr -14h
.text$mn:000110E4 var_10          = dword ptr -10h
.text$mn:000110E4 var_C           = dword ptr -0Ch
.text$mn:000110E4 var_4           = dword ptr -4
.text$mn:000110E4 arg_0           = dword ptr  8
.text$mn:000110E4 arg_4           = dword ptr  0Ch
.text$mn:000110E4
.text$mn:000110E4                 push    ebp
.text$mn:000110E5                 mov     ebp, esp
.text$mn:000110E7                 push    0FFFFFFFFh
.text$mn:000110E9                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000110EE                 mov     eax, large fs:0
.text$mn:000110F4                 push    eax
.text$mn:000110F5                 sub     esp, 8
.text$mn:000110F8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000110FD                 xor     eax, ebp
.text$mn:000110FF                 push    eax
.text$mn:00011100                 lea     eax, [ebp+var_C]
.text$mn:00011103                 mov     large fs:0, eax
.text$mn:00011109                 mov     [ebp+var_14], ecx
.text$mn:0001110C                 mov     [ebp+var_10], 0
.text$mn:00011113                 cmp     [ebp+arg_4], 1
.text$mn:00011117                 jnz     short loc_1113D
.text$mn:00011119                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:0001111E                 mov     ecx, [ebp+arg_0]
.text$mn:00011121                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00011126                 mov     [ebp+var_4], 0
.text$mn:0001112D                 mov     eax, [ebp+var_10]
.text$mn:00011130                 or      eax, 1
.text$mn:00011133                 mov     [ebp+var_10], eax
.text$mn:00011136                 mov     eax, [ebp+arg_0]
.text$mn:00011139                 jmp     short loc_11160
.text$mn:0001113B ; ---------------------------------------------------------------------------
.text$mn:0001113B                 jmp     short loc_11160
.text$mn:0001113D ; ---------------------------------------------------------------------------
.text$mn:0001113D
.text$mn:0001113D loc_1113D:                              ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:0001113D                 mov     ecx, [ebp+arg_4]
.text$mn:00011140                 push    ecx
.text$mn:00011141                 mov     edx, [ebp+arg_0]
.text$mn:00011144                 push    edx
.text$mn:00011145                 mov     ecx, [ebp+var_14]
.text$mn:00011148                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:0001114D                 mov     [ebp+var_4], 0
.text$mn:00011154                 mov     eax, [ebp+var_10]
.text$mn:00011157                 or      eax, 1
.text$mn:0001115A                 mov     [ebp+var_10], eax
.text$mn:0001115D                 mov     eax, [ebp+arg_0]
.text$mn:00011160
.text$mn:00011160 loc_11160:                              ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00011160                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00011160                 mov     ecx, [ebp+var_C]
.text$mn:00011163                 mov     large fs:0, ecx
.text$mn:0001116A                 pop     ecx
.text$mn:0001116B                 mov     esp, ebp
.text$mn:0001116D                 pop     ebp
.text$mn:0001116E                 retn    8
.text$mn:0001116E ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0001116E
.text$mn:0001116E ; ---------------------------------------------------------------------------
.text$mn:00011171                 align 4
.text$mn:00011171 _text$mn        ends
.text$mn:00011171
.text$x:00011174 ; ===========================================================================
.text$x:00011174
.text$x:00011174 ; Segment type: Pure code
.text$x:00011174 ; Segment permissions: Read/Execute
.text$x:00011174 _text$x         segment para public 'CODE' use32
.text$x:00011174                 assume cs:_text$x
.text$x:00011174                 ;org 11174h
.text$x:00011174 ; COMDAT (pick associative to section at 110E4)
.text$x:00011174                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00011174
.text$x:00011174 ; =============== S U B R O U T I N E =======================================
.text$x:00011174
.text$x:00011174
.text$x:00011174 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00011174                                         ; DATA XREF: .xdata$x:0001266Co
.text$x:00011174                 mov     eax, [ebp-10h]
.text$x:00011177                 and     eax, 1
.text$x:0001117A                 jz      $LN6_0
.text$x:00011180                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00011184                 mov     ecx, [ebp+8]
.text$x:00011187                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0001118C ; ---------------------------------------------------------------------------
.text$x:0001118C
.text$x:0001118C $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0001118C                 retn
.text$x:0001118C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0001118C
.text$x:0001118D
.text$x:0001118D ; =============== S U B R O U T I N E =======================================
.text$x:0001118D
.text$x:0001118D
.text$x:0001118D __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0001118D                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:0001118D
.text$x:0001118D arg_4           = dword ptr  8
.text$x:0001118D
.text$x:0001118D                 mov     edx, [esp+arg_4]
.text$x:00011191                 lea     eax, [edx+0Ch]
.text$x:00011194                 mov     ecx, [edx-0Ch]
.text$x:00011197                 xor     ecx, eax
.text$x:00011199                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0001119E                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000111A3                 jmp     ___CxxFrameHandler3
.text$x:000111A3 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000111A3
.text$x:000111A3 _text$x         ends
.text$x:000111A3
.text$mn:000111A8 ; ===========================================================================
.text$mn:000111A8
.text$mn:000111A8 ; Segment type: Pure code
.text$mn:000111A8 ; Segment permissions: Read/Execute
.text$mn:000111A8 _text$mn        segment para public 'CODE' use32
.text$mn:000111A8                 assume cs:_text$mn
.text$mn:000111A8                 ;org 111A8h
.text$mn:000111A8 ; COMDAT (pick any)
.text$mn:000111A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000111A8
.text$mn:000111A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000111A8
.text$mn:000111A8 ; Attributes: bp-based frame
.text$mn:000111A8
.text$mn:000111A8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:000111A8                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000111A8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000111A8                                         ; DATA XREF: .rdata:000144A4o
.text$mn:000111A8
.text$mn:000111A8 var_1C          = dword ptr -1Ch
.text$mn:000111A8 var_18          = dword ptr -18h
.text$mn:000111A8 Str             = dword ptr -14h
.text$mn:000111A8 var_10          = dword ptr -10h
.text$mn:000111A8 var_C           = dword ptr -0Ch
.text$mn:000111A8 var_4           = dword ptr -4
.text$mn:000111A8 arg_0           = dword ptr  8
.text$mn:000111A8 arg_4           = dword ptr  0Ch
.text$mn:000111A8
.text$mn:000111A8                 push    ebp
.text$mn:000111A9                 mov     ebp, esp
.text$mn:000111AB                 push    0FFFFFFFFh
.text$mn:000111AD                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000111B2                 mov     eax, large fs:0
.text$mn:000111B8                 push    eax
.text$mn:000111B9                 sub     esp, 10h
.text$mn:000111BC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000111C1                 xor     eax, ebp
.text$mn:000111C3                 push    eax
.text$mn:000111C4                 lea     eax, [ebp+var_C]
.text$mn:000111C7                 mov     large fs:0, eax
.text$mn:000111CD                 mov     [ebp+var_1C], ecx
.text$mn:000111D0                 mov     [ebp+var_18], 0
.text$mn:000111D7                 mov     eax, [ebp+arg_4]
.text$mn:000111DA                 push    eax             ; int
.text$mn:000111DB                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:000111E0                 add     esp, 4
.text$mn:000111E3                 mov     [ebp+var_10], eax
.text$mn:000111E6                 cmp     [ebp+var_10], 0
.text$mn:000111EA                 jz      short loc_111F4
.text$mn:000111EC                 mov     ecx, [ebp+var_10]
.text$mn:000111EF                 mov     [ebp+Str], ecx
.text$mn:000111F2                 jmp     short loc_111FB
.text$mn:000111F4 ; ---------------------------------------------------------------------------
.text$mn:000111F4
.text$mn:000111F4 loc_111F4:                              ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:000111F4                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000111FB
.text$mn:000111FB loc_111FB:                              ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:000111FB                 mov     edx, [ebp+Str]
.text$mn:000111FE                 push    edx             ; Str
.text$mn:000111FF                 mov     ecx, [ebp+arg_0]
.text$mn:00011202                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00011207                 mov     [ebp+var_4], 0
.text$mn:0001120E                 mov     eax, [ebp+var_18]
.text$mn:00011211                 or      eax, 1
.text$mn:00011214                 mov     [ebp+var_18], eax
.text$mn:00011217                 mov     eax, [ebp+arg_0]
.text$mn:0001121A                 mov     ecx, [ebp+var_C]
.text$mn:0001121D                 mov     large fs:0, ecx
.text$mn:00011224                 pop     ecx
.text$mn:00011225                 mov     esp, ebp
.text$mn:00011227                 pop     ebp
.text$mn:00011228                 retn    8
.text$mn:00011228 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00011228
.text$mn:00011228 ; ---------------------------------------------------------------------------
.text$mn:0001122B                 align 4
.text$mn:0001122B _text$mn        ends
.text$mn:0001122B
.text$x:0001122C ; ===========================================================================
.text$x:0001122C
.text$x:0001122C ; Segment type: Pure code
.text$x:0001122C ; Segment permissions: Read/Execute
.text$x:0001122C _text$x         segment para public 'CODE' use32
.text$x:0001122C                 assume cs:_text$x
.text$x:0001122C                 ;org 1122Ch
.text$x:0001122C ; COMDAT (pick associative to section at 111A8)
.text$x:0001122C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0001122C
.text$x:0001122C ; =============== S U B R O U T I N E =======================================
.text$x:0001122C
.text$x:0001122C
.text$x:0001122C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0001122C                                         ; DATA XREF: .xdata$x:000126F0o
.text$x:0001122C                 mov     eax, [ebp-18h]
.text$x:0001122F                 and     eax, 1
.text$x:00011232                 jz      $LN6_1
.text$x:00011238                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0001123C                 mov     ecx, [ebp+8]
.text$x:0001123F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00011244 ; ---------------------------------------------------------------------------
.text$x:00011244
.text$x:00011244 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00011244                 retn
.text$x:00011244 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00011244
.text$x:00011245
.text$x:00011245 ; =============== S U B R O U T I N E =======================================
.text$x:00011245
.text$x:00011245
.text$x:00011245 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00011245                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00011245
.text$x:00011245 arg_4           = dword ptr  8
.text$x:00011245
.text$x:00011245                 mov     edx, [esp+arg_4]
.text$x:00011249                 lea     eax, [edx+0Ch]
.text$x:0001124C                 mov     ecx, [edx-14h]
.text$x:0001124F                 xor     ecx, eax
.text$x:00011251                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00011256                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0001125B                 jmp     ___CxxFrameHandler3
.text$x:0001125B __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0001125B
.text$x:0001125B _text$x         ends
.text$x:0001125B
.text$mn:00011260 ; ===========================================================================
.text$mn:00011260
.text$mn:00011260 ; Segment type: Pure code
.text$mn:00011260 ; Segment permissions: Read/Execute
.text$mn:00011260 _text$mn        segment para public 'CODE' use32
.text$mn:00011260                 assume cs:_text$mn
.text$mn:00011260                 ;org 11260h
.text$mn:00011260 ; COMDAT (pick any)
.text$mn:00011260                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011260
.text$mn:00011260 ; =============== S U B R O U T I N E =======================================
.text$mn:00011260
.text$mn:00011260 ; Attributes: bp-based frame
.text$mn:00011260
.text$mn:00011260 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00011260                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00011260 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00011260                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00011260
.text$mn:00011260 var_4           = dword ptr -4
.text$mn:00011260 Dst             = dword ptr  8
.text$mn:00011260 Src             = dword ptr  0Ch
.text$mn:00011260 Size            = dword ptr  10h
.text$mn:00011260
.text$mn:00011260                 push    ebp
.text$mn:00011261                 mov     ebp, esp
.text$mn:00011263                 push    ecx
.text$mn:00011264                 cmp     [ebp+Size], 0
.text$mn:00011268                 jnz     short loc_11272
.text$mn:0001126A                 mov     eax, [ebp+Dst]
.text$mn:0001126D                 mov     [ebp+var_4], eax
.text$mn:00011270                 jmp     short loc_11289
.text$mn:00011272 ; ---------------------------------------------------------------------------
.text$mn:00011272
.text$mn:00011272 loc_11272:                              ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00011272                 mov     ecx, [ebp+Size]
.text$mn:00011275                 push    ecx             ; Size
.text$mn:00011276                 mov     edx, [ebp+Src]
.text$mn:00011279                 push    edx             ; Src
.text$mn:0001127A                 mov     eax, [ebp+Dst]
.text$mn:0001127D                 push    eax             ; Dst
.text$mn:0001127E                 call    _memmove
.text$mn:00011283                 add     esp, 0Ch
.text$mn:00011286                 mov     [ebp+var_4], eax
.text$mn:00011289
.text$mn:00011289 loc_11289:                              ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00011289                 mov     eax, [ebp+var_4]
.text$mn:0001128C                 mov     esp, ebp
.text$mn:0001128E                 pop     ebp
.text$mn:0001128F                 retn
.text$mn:0001128F ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0001128F
.text$mn:0001128F _text$mn        ends
.text$mn:0001128F
.text$mn:00011290 ; ===========================================================================
.text$mn:00011290
.text$mn:00011290 ; Segment type: Pure code
.text$mn:00011290 ; Segment permissions: Read/Execute
.text$mn:00011290 _text$mn        segment para public 'CODE' use32
.text$mn:00011290                 assume cs:_text$mn
.text$mn:00011290                 ;org 11290h
.text$mn:00011290 ; COMDAT (pick any)
.text$mn:00011290                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011290
.text$mn:00011290 ; =============== S U B R O U T I N E =======================================
.text$mn:00011290
.text$mn:00011290 ; Attributes: bp-based frame
.text$mn:00011290
.text$mn:00011290 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:00011290                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00011290 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00011290                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+2Ap
.text$mn:00011290                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p ...
.text$mn:00011290
.text$mn:00011290 var_4           = dword ptr -4
.text$mn:00011290 Dst             = dword ptr  8
.text$mn:00011290 Src             = dword ptr  0Ch
.text$mn:00011290 arg_8           = dword ptr  10h
.text$mn:00011290
.text$mn:00011290                 push    ebp
.text$mn:00011291                 mov     ebp, esp
.text$mn:00011293                 push    ecx
.text$mn:00011294                 cmp     [ebp+arg_8], 0
.text$mn:00011298                 jnz     short loc_112A2
.text$mn:0001129A                 mov     eax, [ebp+Dst]
.text$mn:0001129D                 mov     [ebp+var_4], eax
.text$mn:000112A0                 jmp     short loc_112B9
.text$mn:000112A2 ; ---------------------------------------------------------------------------
.text$mn:000112A2
.text$mn:000112A2 loc_112A2:                              ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:000112A2                 mov     ecx, [ebp+arg_8]
.text$mn:000112A5                 push    ecx             ; int
.text$mn:000112A6                 mov     edx, [ebp+Src]
.text$mn:000112A9                 push    edx             ; Src
.text$mn:000112AA                 mov     eax, [ebp+Dst]
.text$mn:000112AD                 push    eax             ; Dst
.text$mn:000112AE                 call    _wmemmove
.text$mn:000112B3                 add     esp, 0Ch
.text$mn:000112B6                 mov     [ebp+var_4], eax
.text$mn:000112B9
.text$mn:000112B9 loc_112B9:                              ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:000112B9                 mov     eax, [ebp+var_4]
.text$mn:000112BC                 mov     esp, ebp
.text$mn:000112BE                 pop     ebp
.text$mn:000112BF                 retn
.text$mn:000112BF ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:000112BF
.text$mn:000112BF _text$mn        ends
.text$mn:000112BF
.text$mn:000112C0 ; ===========================================================================
.text$mn:000112C0
.text$mn:000112C0 ; Segment type: Pure code
.text$mn:000112C0 ; Segment permissions: Read/Execute
.text$mn:000112C0 _text$mn        segment para public 'CODE' use32
.text$mn:000112C0                 assume cs:_text$mn
.text$mn:000112C0                 ;org 112C0h
.text$mn:000112C0 ; COMDAT (pick any)
.text$mn:000112C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000112C0
.text$mn:000112C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000112C0
.text$mn:000112C0 ; Attributes: bp-based frame
.text$mn:000112C0
.text$mn:000112C0 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:000112C0                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:000112C0 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:000112C0                                         ; DATA XREF: .rdata:0001442Co
.text$mn:000112C0
.text$mn:000112C0 var_4           = dword ptr -4
.text$mn:000112C0
.text$mn:000112C0                 push    ebp
.text$mn:000112C1                 mov     ebp, esp
.text$mn:000112C3                 push    ecx
.text$mn:000112C4                 mov     [ebp+var_4], ecx
.text$mn:000112C7                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:000112CC                 mov     esp, ebp
.text$mn:000112CE                 pop     ebp
.text$mn:000112CF                 retn
.text$mn:000112CF ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:000112CF
.text$mn:000112CF _text$mn        ends
.text$mn:000112CF
.text$mn:000112D0 ; ===========================================================================
.text$mn:000112D0
.text$mn:000112D0 ; Segment type: Pure code
.text$mn:000112D0 ; Segment permissions: Read/Execute
.text$mn:000112D0 _text$mn        segment para public 'CODE' use32
.text$mn:000112D0                 assume cs:_text$mn
.text$mn:000112D0                 ;org 112D0h
.text$mn:000112D0 ; COMDAT (pick any)
.text$mn:000112D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000112D0
.text$mn:000112D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000112D0
.text$mn:000112D0 ; Attributes: bp-based frame
.text$mn:000112D0
.text$mn:000112D0 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:000112D0                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:000112D0 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:000112D0                                         ; DATA XREF: .rdata:00014460o
.text$mn:000112D0
.text$mn:000112D0 var_4           = dword ptr -4
.text$mn:000112D0
.text$mn:000112D0                 push    ebp
.text$mn:000112D1                 mov     ebp, esp
.text$mn:000112D3                 push    ecx
.text$mn:000112D4                 mov     [ebp+var_4], ecx
.text$mn:000112D7                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:000112DC                 mov     esp, ebp
.text$mn:000112DE                 pop     ebp
.text$mn:000112DF                 retn
.text$mn:000112DF ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:000112DF
.text$mn:000112DF _text$mn        ends
.text$mn:000112DF
.text$mn:000112E0 ; ===========================================================================
.text$mn:000112E0
.text$mn:000112E0 ; Segment type: Pure code
.text$mn:000112E0 ; Segment permissions: Read/Execute
.text$mn:000112E0 _text$mn        segment para public 'CODE' use32
.text$mn:000112E0                 assume cs:_text$mn
.text$mn:000112E0                 ;org 112E0h
.text$mn:000112E0 ; COMDAT (pick any)
.text$mn:000112E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000112E0
.text$mn:000112E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000112E0
.text$mn:000112E0 ; Attributes: bp-based frame
.text$mn:000112E0
.text$mn:000112E0 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:000112E0                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:000112E0 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:000112E0                                         ; DATA XREF: .rdata:000144A0o
.text$mn:000112E0
.text$mn:000112E0 var_4           = dword ptr -4
.text$mn:000112E0
.text$mn:000112E0                 push    ebp
.text$mn:000112E1                 mov     ebp, esp
.text$mn:000112E3                 push    ecx
.text$mn:000112E4                 mov     [ebp+var_4], ecx
.text$mn:000112E7                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:000112EC                 mov     esp, ebp
.text$mn:000112EE                 pop     ebp
.text$mn:000112EF                 retn
.text$mn:000112EF ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:000112EF
.text$mn:000112EF _text$mn        ends
.text$mn:000112EF
.text$mn:000112F0 ; ===========================================================================
.text$mn:000112F0
.text$mn:000112F0 ; Segment type: Pure code
.text$mn:000112F0 ; Segment permissions: Read/Execute
.text$mn:000112F0 _text$mn        segment para public 'CODE' use32
.text$mn:000112F0                 assume cs:_text$mn
.text$mn:000112F0                 ;org 112F0h
.text$mn:000112F0 ; COMDAT (pick any)
.text$mn:000112F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000112F0
.text$mn:000112F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000112F0
.text$mn:000112F0 ; Attributes: bp-based frame
.text$mn:000112F0
.text$mn:000112F0 ; int __thiscall TabBar::nbItem(TabBar *__hidden this)
.text$mn:000112F0                 public ?nbItem@TabBar@@QBEHXZ
.text$mn:000112F0 ?nbItem@TabBar@@QBEHXZ proc near        ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+135p
.text$mn:000112F0                                         ; Notepad_plus::doClose(Buffer *,int,bool)+148p ...
.text$mn:000112F0
.text$mn:000112F0 var_4           = dword ptr -4
.text$mn:000112F0
.text$mn:000112F0                 push    ebp
.text$mn:000112F1                 mov     ebp, esp
.text$mn:000112F3                 push    ecx
.text$mn:000112F4                 mov     [ebp+var_4], ecx
.text$mn:000112F7                 mov     eax, [ebp+var_4]
.text$mn:000112FA                 mov     eax, [eax+10h]
.text$mn:000112FD                 mov     esp, ebp
.text$mn:000112FF                 pop     ebp
.text$mn:00011300                 retn
.text$mn:00011300 ?nbItem@TabBar@@QBEHXZ endp
.text$mn:00011300
.text$mn:00011300 ; ---------------------------------------------------------------------------
.text$mn:00011301                 align 4
.text$mn:00011301 _text$mn        ends
.text$mn:00011301
.text$mn:00011304 ; ===========================================================================
.text$mn:00011304
.text$mn:00011304 ; Segment type: Pure code
.text$mn:00011304 ; Segment permissions: Read/Execute
.text$mn:00011304 _text$mn        segment para public 'CODE' use32
.text$mn:00011304                 assume cs:_text$mn
.text$mn:00011304                 ;org 11304h
.text$mn:00011304 ; COMDAT (pick any)
.text$mn:00011304                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011304
.text$mn:00011304 ; =============== S U B R O U T I N E =======================================
.text$mn:00011304
.text$mn:00011304 ; Attributes: bp-based frame
.text$mn:00011304
.text$mn:00011304 ; unsigned int __thiscall Session::nbMainFiles(Session *__hidden this)
.text$mn:00011304                 public ?nbMainFiles@Session@@QBEIXZ
.text$mn:00011304 ?nbMainFiles@Session@@QBEIXZ proc near  ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+63p
.text$mn:00011304
.text$mn:00011304 var_4           = dword ptr -4
.text$mn:00011304
.text$mn:00011304                 push    ebp
.text$mn:00011305                 mov     ebp, esp
.text$mn:00011307                 push    ecx
.text$mn:00011308                 mov     [ebp+var_4], ecx
.text$mn:0001130B                 mov     ecx, [ebp+var_4]
.text$mn:0001130E                 add     ecx, 0Ch
.text$mn:00011311                 call    ?size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::size(void)
.text$mn:00011316                 mov     esp, ebp
.text$mn:00011318                 pop     ebp
.text$mn:00011319                 retn
.text$mn:00011319 ?nbMainFiles@Session@@QBEIXZ endp
.text$mn:00011319
.text$mn:00011319 ; ---------------------------------------------------------------------------
.text$mn:0001131A                 align 4
.text$mn:0001131A _text$mn        ends
.text$mn:0001131A
.text$mn:0001131C ; ===========================================================================
.text$mn:0001131C
.text$mn:0001131C ; Segment type: Pure code
.text$mn:0001131C ; Segment permissions: Read/Execute
.text$mn:0001131C _text$mn        segment para public 'CODE' use32
.text$mn:0001131C                 assume cs:_text$mn
.text$mn:0001131C                 ;org 1131Ch
.text$mn:0001131C ; COMDAT (pick any)
.text$mn:0001131C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0001131C
.text$mn:0001131C ; =============== S U B R O U T I N E =======================================
.text$mn:0001131C
.text$mn:0001131C ; Attributes: bp-based frame
.text$mn:0001131C
.text$mn:0001131C ; unsigned int __thiscall Session::nbSubFiles(Session *__hidden this)
.text$mn:0001131C                 public ?nbSubFiles@Session@@QBEIXZ
.text$mn:0001131C ?nbSubFiles@Session@@QBEIXZ proc near   ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+668p
.text$mn:0001131C                                         ; Notepad_plus::loadSession(Session &,bool)+D1Dp
.text$mn:0001131C
.text$mn:0001131C var_4           = dword ptr -4
.text$mn:0001131C
.text$mn:0001131C                 push    ebp
.text$mn:0001131D                 mov     ebp, esp
.text$mn:0001131F                 push    ecx
.text$mn:00011320                 mov     [ebp+var_4], ecx
.text$mn:00011323                 mov     ecx, [ebp+var_4]
.text$mn:00011326                 add     ecx, 1Ch
.text$mn:00011329                 call    ?size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::size(void)
.text$mn:0001132E                 mov     esp, ebp
.text$mn:00011330                 pop     ebp
.text$mn:00011331                 retn
.text$mn:00011331 ?nbSubFiles@Session@@QBEIXZ endp
.text$mn:00011331
.text$mn:00011331 ; ---------------------------------------------------------------------------
.text$mn:00011332                 align 4
.text$mn:00011332 _text$mn        ends
.text$mn:00011332
.text$mn:00011334 ; ===========================================================================
.text$mn:00011334
.text$mn:00011334 ; Segment type: Pure code
.text$mn:00011334 ; Segment permissions: Read/Execute
.text$mn:00011334 _text$mn        segment para public 'CODE' use32
.text$mn:00011334                 assume cs:_text$mn
.text$mn:00011334                 ;org 11334h
.text$mn:00011334 ; COMDAT (pick any)
.text$mn:00011334                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011334
.text$mn:00011334 ; =============== S U B R O U T I N E =======================================
.text$mn:00011334
.text$mn:00011334 ; Attributes: bp-based frame
.text$mn:00011334
.text$mn:00011334 ; int __thiscall VerticalFileSwitcher::newItem(VerticalFileSwitcher *this, int, int)
.text$mn:00011334                 public ?newItem@VerticalFileSwitcher@@QAEHHH@Z
.text$mn:00011334 ?newItem@VerticalFileSwitcher@@QAEHHH@Z proc near
.text$mn:00011334                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+86Dp
.text$mn:00011334
.text$mn:00011334 var_4           = dword ptr -4
.text$mn:00011334 arg_0           = dword ptr  8
.text$mn:00011334 arg_4           = dword ptr  0Ch
.text$mn:00011334
.text$mn:00011334                 push    ebp
.text$mn:00011335                 mov     ebp, esp
.text$mn:00011337                 push    ecx
.text$mn:00011338                 mov     [ebp+var_4], ecx
.text$mn:0001133B                 mov     eax, [ebp+arg_4]
.text$mn:0001133E                 push    eax             ; int
.text$mn:0001133F                 mov     ecx, [ebp+arg_0]
.text$mn:00011342                 push    ecx             ; int
.text$mn:00011343                 mov     ecx, [ebp+var_4]
.text$mn:00011346                 add     ecx, 6Ch ; 'l'  ; this
.text$mn:00011349                 call    ?newItem@VerticalFileSwitcherListView@@QAEHHH@Z ; VerticalFileSwitcherListView::newItem(int,int)
.text$mn:0001134E                 mov     esp, ebp
.text$mn:00011350                 pop     ebp
.text$mn:00011351                 retn    8
.text$mn:00011351 ?newItem@VerticalFileSwitcher@@QAEHHH@Z endp
.text$mn:00011351
.text$mn:00011351 _text$mn        ends
.text$mn:00011351
.text$mn:00011354 ; ===========================================================================
.text$mn:00011354
.text$mn:00011354 ; Segment type: Pure code
.text$mn:00011354 ; Segment permissions: Read/Execute
.text$mn:00011354 _text$mn        segment para public 'CODE' use32
.text$mn:00011354                 assume cs:_text$mn
.text$mn:00011354                 ;org 11354h
.text$mn:00011354 ; COMDAT (pick any)
.text$mn:00011354                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011354
.text$mn:00011354 ; =============== S U B R O U T I N E =======================================
.text$mn:00011354
.text$mn:00011354 ; Attributes: bp-based frame
.text$mn:00011354
.text$mn:00011354 ; int __thiscall Notepad_plus::otherView(Notepad_plus *__hidden this)
.text$mn:00011354                 public ?otherView@Notepad_plus@@AAEHXZ
.text$mn:00011354 ?otherView@Notepad_plus@@AAEHXZ proc near
.text$mn:00011354                                         ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+6CDp
.text$mn:00011354                                         ; Notepad_plus::fileCloseAll(bool,bool)+731p ...
.text$mn:00011354
.text$mn:00011354 var_8           = dword ptr -8
.text$mn:00011354 var_4           = dword ptr -4
.text$mn:00011354
.text$mn:00011354                 push    ebp
.text$mn:00011355                 mov     ebp, esp
.text$mn:00011357                 sub     esp, 8
.text$mn:0001135A                 mov     [ebp+var_8], ecx
.text$mn:0001135D                 mov     eax, [ebp+var_8]
.text$mn:00011360                 cmp     dword ptr [eax+551C8h], 0
.text$mn:00011367                 jnz     short loc_11372
.text$mn:00011369                 mov     [ebp+var_4], 1
.text$mn:00011370                 jmp     short loc_11379
.text$mn:00011372 ; ---------------------------------------------------------------------------
.text$mn:00011372
.text$mn:00011372 loc_11372:                              ; CODE XREF: Notepad_plus::otherView(void)+13j
.text$mn:00011372                 mov     [ebp+var_4], 0
.text$mn:00011379
.text$mn:00011379 loc_11379:                              ; CODE XREF: Notepad_plus::otherView(void)+1Cj
.text$mn:00011379                 mov     eax, [ebp+var_4]
.text$mn:0001137C                 mov     esp, ebp
.text$mn:0001137E                 pop     ebp
.text$mn:0001137F                 retn
.text$mn:0001137F ?otherView@Notepad_plus@@AAEHXZ endp
.text$mn:0001137F
.text$mn:0001137F _text$mn        ends
.text$mn:0001137F
.text$mn:00011380 ; ===========================================================================
.text$mn:00011380
.text$mn:00011380 ; Segment type: Pure code
.text$mn:00011380 ; Segment permissions: Read/Execute
.text$mn:00011380 _text$mn        segment para public 'CODE' use32
.text$mn:00011380                 assume cs:_text$mn
.text$mn:00011380                 ;org 11380h
.text$mn:00011380 ; COMDAT (pick any)
.text$mn:00011380                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011380
.text$mn:00011380 ; =============== S U B R O U T I N E =======================================
.text$mn:00011380
.text$mn:00011380 ; Attributes: bp-based frame
.text$mn:00011380
.text$mn:00011380 ; public: void __thiscall std::vector<int, class std::allocator<int>>::push_back(int const &)
.text$mn:00011380                 public ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
.text$mn:00011380 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z proc near
.text$mn:00011380                                         ; CODE XREF: Notepad_plus::fileCloseAllToLeft(void)+63p
.text$mn:00011380                                         ; Notepad_plus::fileCloseAllToRight(void)+76p
.text$mn:00011380
.text$mn:00011380 var_C           = dword ptr -0Ch
.text$mn:00011380 var_8           = dword ptr -8
.text$mn:00011380 var_2           = byte ptr -2
.text$mn:00011380 var_1           = byte ptr -1
.text$mn:00011380 arg_0           = dword ptr  8
.text$mn:00011380
.text$mn:00011380                 push    ebp
.text$mn:00011381                 mov     ebp, esp
.text$mn:00011383                 sub     esp, 0Ch
.text$mn:00011386                 mov     [ebp+var_8], ecx
.text$mn:00011389                 mov     eax, [ebp+arg_0]
.text$mn:0001138C                 push    eax
.text$mn:0001138D                 call    ??$addressof@$$CBH@std@@YAPBHABH@Z ; std::addressof<int const>(int const &)
.text$mn:00011392                 add     esp, 4
.text$mn:00011395                 push    eax
.text$mn:00011396                 mov     ecx, [ebp+var_8]
.text$mn:00011399                 call    ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ; std::vector<int,std::allocator<int>>::_Inside(int const *)
.text$mn:0001139E                 movzx   ecx, al
.text$mn:000113A1                 test    ecx, ecx
.text$mn:000113A3                 jz      short loc_11423
.text$mn:000113A5                 mov     edx, [ebp+arg_0]
.text$mn:000113A8                 push    edx
.text$mn:000113A9                 call    ??$addressof@$$CBH@std@@YAPBHABH@Z ; std::addressof<int const>(int const &)
.text$mn:000113AE                 add     esp, 4
.text$mn:000113B1                 mov     ecx, [ebp+var_8]
.text$mn:000113B4                 sub     eax, [ecx+4]
.text$mn:000113B7                 sar     eax, 2
.text$mn:000113BA                 mov     [ebp+var_C], eax
.text$mn:000113BD                 mov     edx, [ebp+var_8]
.text$mn:000113C0                 mov     eax, [ebp+var_8]
.text$mn:000113C3                 mov     ecx, [edx+8]
.text$mn:000113C6                 cmp     ecx, [eax+0Ch]
.text$mn:000113C9                 jnz     short loc_113D5
.text$mn:000113CB                 push    1
.text$mn:000113CD                 mov     ecx, [ebp+var_8]
.text$mn:000113D0                 call    ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int>>::_Reserve(uint)
.text$mn:000113D5
.text$mn:000113D5 loc_113D5:                              ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+49j
.text$mn:000113D5                 mov     edx, [ebp+var_8]
.text$mn:000113D8                 mov     eax, [edx+8]
.text$mn:000113DB                 push    eax
.text$mn:000113DC                 mov     ecx, [ebp+var_8]
.text$mn:000113DF                 mov     edx, [ecx+8]
.text$mn:000113E2                 push    edx
.text$mn:000113E3                 mov     ecx, [ebp+var_8]
.text$mn:000113E6                 call    ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)
.text$mn:000113EB                 mov     eax, [ebp+var_8]
.text$mn:000113EE                 mov     ecx, [eax+4]
.text$mn:000113F1                 mov     edx, [ebp+var_C]
.text$mn:000113F4                 lea     eax, [ecx+edx*4]
.text$mn:000113F7                 push    eax             ; int
.text$mn:000113F8                 mov     ecx, [ebp+var_8]
.text$mn:000113FB                 mov     edx, [ecx+8]
.text$mn:000113FE                 push    edx             ; void *
.text$mn:000113FF                 lea     eax, [ebp+var_1]
.text$mn:00011402                 push    eax
.text$mn:00011403                 mov     ecx, [ebp+var_8]
.text$mn:00011406                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:0001140B                 mov     ecx, eax
.text$mn:0001140D                 call    ??$construct@HAAH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHAAH@Z ; std::_Wrap_alloc<std::allocator<int>>::construct<int,int &>(int *,int &)
.text$mn:00011412                 mov     ecx, [ebp+var_8]
.text$mn:00011415                 mov     edx, [ecx+8]
.text$mn:00011418                 add     edx, 4
.text$mn:0001141B                 mov     eax, [ebp+var_8]
.text$mn:0001141E                 mov     [eax+8], edx
.text$mn:00011421                 jmp     short loc_1147E
.text$mn:00011423 ; ---------------------------------------------------------------------------
.text$mn:00011423
.text$mn:00011423 loc_11423:                              ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+23j
.text$mn:00011423                 mov     ecx, [ebp+var_8]
.text$mn:00011426                 mov     edx, [ebp+var_8]
.text$mn:00011429                 mov     eax, [ecx+8]
.text$mn:0001142C                 cmp     eax, [edx+0Ch]
.text$mn:0001142F                 jnz     short loc_1143B
.text$mn:00011431                 push    1
.text$mn:00011433                 mov     ecx, [ebp+var_8]
.text$mn:00011436                 call    ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int>>::_Reserve(uint)
.text$mn:0001143B
.text$mn:0001143B loc_1143B:                              ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+AFj
.text$mn:0001143B                 mov     ecx, [ebp+var_8]
.text$mn:0001143E                 mov     edx, [ecx+8]
.text$mn:00011441                 push    edx
.text$mn:00011442                 mov     eax, [ebp+var_8]
.text$mn:00011445                 mov     ecx, [eax+8]
.text$mn:00011448                 push    ecx
.text$mn:00011449                 mov     ecx, [ebp+var_8]
.text$mn:0001144C                 call    ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)
.text$mn:00011451                 mov     edx, [ebp+arg_0]
.text$mn:00011454                 push    edx             ; int
.text$mn:00011455                 mov     eax, [ebp+var_8]
.text$mn:00011458                 mov     ecx, [eax+8]
.text$mn:0001145B                 push    ecx             ; void *
.text$mn:0001145C                 lea     edx, [ebp+var_2]
.text$mn:0001145F                 push    edx
.text$mn:00011460                 mov     ecx, [ebp+var_8]
.text$mn:00011463                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00011468                 mov     ecx, eax
.text$mn:0001146A                 call    ??$construct@HABH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHABH@Z ; std::_Wrap_alloc<std::allocator<int>>::construct<int,int const &>(int *,int const &)
.text$mn:0001146F                 mov     eax, [ebp+var_8]
.text$mn:00011472                 mov     ecx, [eax+8]
.text$mn:00011475                 add     ecx, 4
.text$mn:00011478                 mov     edx, [ebp+var_8]
.text$mn:0001147B                 mov     [edx+8], ecx
.text$mn:0001147E
.text$mn:0001147E loc_1147E:                              ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+A1j
.text$mn:0001147E                 mov     esp, ebp
.text$mn:00011480                 pop     ebp
.text$mn:00011481                 retn    4
.text$mn:00011481 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z endp
.text$mn:00011481
.text$mn:00011481 _text$mn        ends
.text$mn:00011481
.text$mn:00011484 ; ===========================================================================
.text$mn:00011484
.text$mn:00011484 ; Segment type: Pure code
.text$mn:00011484 ; Segment permissions: Read/Execute
.text$mn:00011484 _text$mn        segment para public 'CODE' use32
.text$mn:00011484                 assume cs:_text$mn
.text$mn:00011484                 ;org 11484h
.text$mn:00011484 ; COMDAT (pick any)
.text$mn:00011484                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011484
.text$mn:00011484 ; =============== S U B R O U T I N E =======================================
.text$mn:00011484
.text$mn:00011484 ; Attributes: bp-based frame
.text$mn:00011484
.text$mn:00011484 ; public: void __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::push_back(struct sessionFileInfo &&)
.text$mn:00011484                 public ?push_back@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEX$$QAUsessionFileInfo@@@Z
.text$mn:00011484 ?push_back@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEX$$QAUsessionFileInfo@@@Z proc near
.text$mn:00011484                                         ; CODE XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *)+FBp
.text$mn:00011484
.text$mn:00011484 var_C           = dword ptr -0Ch
.text$mn:00011484 var_8           = dword ptr -8
.text$mn:00011484 var_2           = byte ptr -2
.text$mn:00011484 var_1           = byte ptr -1
.text$mn:00011484 arg_0           = dword ptr  8
.text$mn:00011484
.text$mn:00011484                 push    ebp
.text$mn:00011485                 mov     ebp, esp
.text$mn:00011487                 sub     esp, 0Ch
.text$mn:0001148A                 mov     [ebp+var_8], ecx
.text$mn:0001148D                 mov     eax, [ebp+arg_0]
.text$mn:00011490                 push    eax
.text$mn:00011491                 call    ??$addressof@UsessionFileInfo@@@std@@YAPAUsessionFileInfo@@AAU1@@Z ; std::addressof<sessionFileInfo>(sessionFileInfo &)
.text$mn:00011496                 add     esp, 4
.text$mn:00011499                 push    eax
.text$mn:0001149A                 mov     ecx, [ebp+var_8]
.text$mn:0001149D                 call    ?_Inside@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBE_NPBUsessionFileInfo@@@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Inside(sessionFileInfo const *)
.text$mn:000114A2                 movzx   ecx, al
.text$mn:000114A5                 test    ecx, ecx
.text$mn:000114A7                 jz      loc_1153C
.text$mn:000114AD                 mov     edx, [ebp+arg_0]
.text$mn:000114B0                 push    edx
.text$mn:000114B1                 call    ??$addressof@UsessionFileInfo@@@std@@YAPAUsessionFileInfo@@AAU1@@Z ; std::addressof<sessionFileInfo>(sessionFileInfo &)
.text$mn:000114B6                 add     esp, 4
.text$mn:000114B9                 mov     ecx, [ebp+var_8]
.text$mn:000114BC                 sub     eax, [ecx+4]
.text$mn:000114BF                 cdq
.text$mn:000114C0                 mov     ecx, 98h ; 'ÿ'
.text$mn:000114C5                 idiv    ecx
.text$mn:000114C7                 mov     [ebp+var_C], eax
.text$mn:000114CA                 mov     edx, [ebp+var_8]
.text$mn:000114CD                 mov     eax, [ebp+var_8]
.text$mn:000114D0                 mov     ecx, [edx+8]
.text$mn:000114D3                 cmp     ecx, [eax+0Ch]
.text$mn:000114D6                 jnz     short loc_114E2
.text$mn:000114D8                 push    1
.text$mn:000114DA                 mov     ecx, [ebp+var_8]
.text$mn:000114DD                 call    ?_Reserve@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reserve(uint)
.text$mn:000114E2
.text$mn:000114E2 loc_114E2:                              ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::push_back(sessionFileInfo &&)+52j
.text$mn:000114E2                 mov     edx, [ebp+var_8]
.text$mn:000114E5                 mov     eax, [edx+8]
.text$mn:000114E8                 push    eax
.text$mn:000114E9                 mov     ecx, [ebp+var_8]
.text$mn:000114EC                 mov     edx, [ecx+8]
.text$mn:000114EF                 push    edx
.text$mn:000114F0                 mov     ecx, [ebp+var_8]
.text$mn:000114F3                 call    ?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Orphan_range(sessionFileInfo *,sessionFileInfo *)
.text$mn:000114F8                 imul    eax, [ebp+var_C], 98h
.text$mn:000114FF                 mov     ecx, [ebp+var_8]
.text$mn:00011502                 add     eax, [ecx+4]
.text$mn:00011505                 push    eax
.text$mn:00011506                 call    ??$forward@UsessionFileInfo@@@std@@YA$$QAUsessionFileInfo@@AAU1@@Z ; std::forward<sessionFileInfo>(sessionFileInfo &)
.text$mn:0001150B                 add     esp, 4
.text$mn:0001150E                 push    eax             ; int
.text$mn:0001150F                 mov     edx, [ebp+var_8]
.text$mn:00011512                 mov     eax, [edx+8]
.text$mn:00011515                 push    eax             ; void *
.text$mn:00011516                 lea     ecx, [ebp+var_1]
.text$mn:00011519                 push    ecx
.text$mn:0001151A                 mov     ecx, [ebp+var_8]
.text$mn:0001151D                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Getal(void)
.text$mn:00011522                 mov     ecx, eax
.text$mn:00011524                 call    ??$construct@UsessionFileInfo@@U1@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo>(sessionFileInfo *,sessionFileInfo &&)
.text$mn:00011529                 mov     edx, [ebp+var_8]
.text$mn:0001152C                 mov     eax, [edx+8]
.text$mn:0001152F                 add     eax, 98h ; 'ÿ'
.text$mn:00011534                 mov     ecx, [ebp+var_8]
.text$mn:00011537                 mov     [ecx+8], eax
.text$mn:0001153A                 jmp     short loc_115A3
.text$mn:0001153C ; ---------------------------------------------------------------------------
.text$mn:0001153C
.text$mn:0001153C loc_1153C:                              ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::push_back(sessionFileInfo &&)+23j
.text$mn:0001153C                 mov     edx, [ebp+var_8]
.text$mn:0001153F                 mov     eax, [ebp+var_8]
.text$mn:00011542                 mov     ecx, [edx+8]
.text$mn:00011545                 cmp     ecx, [eax+0Ch]
.text$mn:00011548                 jnz     short loc_11554
.text$mn:0001154A                 push    1
.text$mn:0001154C                 mov     ecx, [ebp+var_8]
.text$mn:0001154F                 call    ?_Reserve@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Reserve(uint)
.text$mn:00011554
.text$mn:00011554 loc_11554:                              ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::push_back(sessionFileInfo &&)+C4j
.text$mn:00011554                 mov     edx, [ebp+var_8]
.text$mn:00011557                 mov     eax, [edx+8]
.text$mn:0001155A                 push    eax
.text$mn:0001155B                 mov     ecx, [ebp+var_8]
.text$mn:0001155E                 mov     edx, [ecx+8]
.text$mn:00011561                 push    edx
.text$mn:00011562                 mov     ecx, [ebp+var_8]
.text$mn:00011565                 call    ?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::_Orphan_range(sessionFileInfo *,sessionFileInfo *)
.text$mn:0001156A                 mov     eax, [ebp+arg_0]
.text$mn:0001156D                 push    eax
.text$mn:0001156E                 call    ??$forward@UsessionFileInfo@@@std@@YA$$QAUsessionFileInfo@@AAU1@@Z ; std::forward<sessionFileInfo>(sessionFileInfo &)
.text$mn:00011573                 add     esp, 4
.text$mn:00011576                 push    eax             ; int
.text$mn:00011577                 mov     ecx, [ebp+var_8]
.text$mn:0001157A                 mov     edx, [ecx+8]
.text$mn:0001157D                 push    edx             ; void *
.text$mn:0001157E                 lea     eax, [ebp+var_2]
.text$mn:00011581                 push    eax
.text$mn:00011582                 mov     ecx, [ebp+var_8]
.text$mn:00011585                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<sessionFileInfo,std::allocator<sessionFileInfo>>>::_Getal(void)
.text$mn:0001158A                 mov     ecx, eax
.text$mn:0001158C                 call    ??$construct@UsessionFileInfo@@U1@@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::construct<sessionFileInfo,sessionFileInfo>(sessionFileInfo *,sessionFileInfo &&)
.text$mn:00011591                 mov     ecx, [ebp+var_8]
.text$mn:00011594                 mov     edx, [ecx+8]
.text$mn:00011597                 add     edx, 98h ; 'ÿ'
.text$mn:0001159D                 mov     eax, [ebp+var_8]
.text$mn:000115A0                 mov     [eax+8], edx
.text$mn:000115A3
.text$mn:000115A3 loc_115A3:                              ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::push_back(sessionFileInfo &&)+B6j
.text$mn:000115A3                 mov     esp, ebp
.text$mn:000115A5                 pop     ebp
.text$mn:000115A6                 retn    4
.text$mn:000115A6 ?push_back@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAEX$$QAUsessionFileInfo@@@Z endp
.text$mn:000115A6
.text$mn:000115A6 ; ---------------------------------------------------------------------------
.text$mn:000115A9                 align 4
.text$mn:000115A9 _text$mn        ends
.text$mn:000115A9
.text$mn:000115AC ; ===========================================================================
.text$mn:000115AC
.text$mn:000115AC ; Segment type: Pure code
.text$mn:000115AC ; Segment permissions: Read/Execute
.text$mn:000115AC _text$mn        segment para public 'CODE' use32
.text$mn:000115AC                 assume cs:_text$mn
.text$mn:000115AC                 ;org 115ACh
.text$mn:000115AC ; COMDAT (pick any)
.text$mn:000115AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000115AC
.text$mn:000115AC ; =============== S U B R O U T I N E =======================================
.text$mn:000115AC
.text$mn:000115AC ; Attributes: bp-based frame
.text$mn:000115AC
.text$mn:000115AC ; public: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::push_back(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &&)
.text$mn:000115AC                 public ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
.text$mn:000115AC ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z proc near
.text$mn:000115AC                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+90Cp
.text$mn:000115AC                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+9D8p
.text$mn:000115AC
.text$mn:000115AC var_C           = dword ptr -0Ch
.text$mn:000115AC var_8           = dword ptr -8
.text$mn:000115AC var_2           = byte ptr -2
.text$mn:000115AC var_1           = byte ptr -1
.text$mn:000115AC arg_0           = dword ptr  8
.text$mn:000115AC
.text$mn:000115AC                 push    ebp
.text$mn:000115AD                 mov     ebp, esp
.text$mn:000115AF                 sub     esp, 0Ch
.text$mn:000115B2                 mov     [ebp+var_8], ecx
.text$mn:000115B5                 mov     eax, [ebp+arg_0]
.text$mn:000115B8                 push    eax
.text$mn:000115B9                 call    ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:000115BE                 add     esp, 4
.text$mn:000115C1                 push    eax
.text$mn:000115C2                 mov     ecx, [ebp+var_8]
.text$mn:000115C5                 call    ?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBE_NPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Inside(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const *)
.text$mn:000115CA                 movzx   ecx, al
.text$mn:000115CD                 test    ecx, ecx
.text$mn:000115CF                 jz      loc_1165F
.text$mn:000115D5                 mov     edx, [ebp+arg_0]
.text$mn:000115D8                 push    edx
.text$mn:000115D9                 call    ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:000115DE                 add     esp, 4
.text$mn:000115E1                 mov     ecx, [ebp+var_8]
.text$mn:000115E4                 sub     eax, [ecx+4]
.text$mn:000115E7                 cdq
.text$mn:000115E8                 mov     ecx, 1Ch
.text$mn:000115ED                 idiv    ecx
.text$mn:000115EF                 mov     [ebp+var_C], eax
.text$mn:000115F2                 mov     edx, [ebp+var_8]
.text$mn:000115F5                 mov     eax, [ebp+var_8]
.text$mn:000115F8                 mov     ecx, [edx+8]
.text$mn:000115FB                 cmp     ecx, [eax+0Ch]
.text$mn:000115FE                 jnz     short loc_1160A
.text$mn:00011600                 push    1
.text$mn:00011602                 mov     ecx, [ebp+var_8]
.text$mn:00011605                 call    ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)
.text$mn:0001160A
.text$mn:0001160A loc_1160A:                              ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+52j
.text$mn:0001160A                 mov     edx, [ebp+var_8]
.text$mn:0001160D                 mov     eax, [edx+8]
.text$mn:00011610                 push    eax
.text$mn:00011611                 mov     ecx, [ebp+var_8]
.text$mn:00011614                 mov     edx, [ecx+8]
.text$mn:00011617                 push    edx
.text$mn:00011618                 mov     ecx, [ebp+var_8]
.text$mn:0001161B                 call    ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00011620                 imul    eax, [ebp+var_C], 1Ch
.text$mn:00011624                 mov     ecx, [ebp+var_8]
.text$mn:00011627                 add     eax, [ecx+4]
.text$mn:0001162A                 push    eax
.text$mn:0001162B                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00011630                 add     esp, 4
.text$mn:00011633                 push    eax             ; int
.text$mn:00011634                 mov     edx, [ebp+var_8]
.text$mn:00011637                 mov     eax, [edx+8]
.text$mn:0001163A                 push    eax             ; void *
.text$mn:0001163B                 lea     ecx, [ebp+var_1]
.text$mn:0001163E                 push    ecx
.text$mn:0001163F                 mov     ecx, [ebp+var_8]
.text$mn:00011642                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:00011647                 mov     ecx, eax
.text$mn:00011649                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:0001164E                 mov     edx, [ebp+var_8]
.text$mn:00011651                 mov     eax, [edx+8]
.text$mn:00011654                 add     eax, 1Ch
.text$mn:00011657                 mov     ecx, [ebp+var_8]
.text$mn:0001165A                 mov     [ecx+8], eax
.text$mn:0001165D                 jmp     short loc_116C3
.text$mn:0001165F ; ---------------------------------------------------------------------------
.text$mn:0001165F
.text$mn:0001165F loc_1165F:                              ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+23j
.text$mn:0001165F                 mov     edx, [ebp+var_8]
.text$mn:00011662                 mov     eax, [ebp+var_8]
.text$mn:00011665                 mov     ecx, [edx+8]
.text$mn:00011668                 cmp     ecx, [eax+0Ch]
.text$mn:0001166B                 jnz     short loc_11677
.text$mn:0001166D                 push    1
.text$mn:0001166F                 mov     ecx, [ebp+var_8]
.text$mn:00011672                 call    ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)
.text$mn:00011677
.text$mn:00011677 loc_11677:                              ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+BFj
.text$mn:00011677                 mov     edx, [ebp+var_8]
.text$mn:0001167A                 mov     eax, [edx+8]
.text$mn:0001167D                 push    eax
.text$mn:0001167E                 mov     ecx, [ebp+var_8]
.text$mn:00011681                 mov     edx, [ecx+8]
.text$mn:00011684                 push    edx
.text$mn:00011685                 mov     ecx, [ebp+var_8]
.text$mn:00011688                 call    ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0001168D                 mov     eax, [ebp+arg_0]
.text$mn:00011690                 push    eax
.text$mn:00011691                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00011696                 add     esp, 4
.text$mn:00011699                 push    eax             ; int
.text$mn:0001169A                 mov     ecx, [ebp+var_8]
.text$mn:0001169D                 mov     edx, [ecx+8]
.text$mn:000116A0                 push    edx             ; void *
.text$mn:000116A1                 lea     eax, [ebp+var_2]
.text$mn:000116A4                 push    eax
.text$mn:000116A5                 mov     ecx, [ebp+var_8]
.text$mn:000116A8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:000116AD                 mov     ecx, eax
.text$mn:000116AF                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:000116B4                 mov     ecx, [ebp+var_8]
.text$mn:000116B7                 mov     edx, [ecx+8]
.text$mn:000116BA                 add     edx, 1Ch
.text$mn:000116BD                 mov     eax, [ebp+var_8]
.text$mn:000116C0                 mov     [eax+8], edx
.text$mn:000116C3
.text$mn:000116C3 loc_116C3:                              ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+B1j
.text$mn:000116C3                 mov     esp, ebp
.text$mn:000116C5                 pop     ebp
.text$mn:000116C6                 retn    4
.text$mn:000116C6 ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z endp
.text$mn:000116C6
.text$mn:000116C6 ; ---------------------------------------------------------------------------
.text$mn:000116C9                 align 4
.text$mn:000116C9 _text$mn        ends
.text$mn:000116C9
.text$mn:000116CC ; ===========================================================================
.text$mn:000116CC
.text$mn:000116CC ; Segment type: Pure code
.text$mn:000116CC ; Segment permissions: Read/Execute
.text$mn:000116CC _text$mn        segment para public 'CODE' use32
.text$mn:000116CC                 assume cs:_text$mn
.text$mn:000116CC                 ;org 116CCh
.text$mn:000116CC ; COMDAT (pick any)
.text$mn:000116CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000116CC
.text$mn:000116CC ; =============== S U B R O U T I N E =======================================
.text$mn:000116CC
.text$mn:000116CC ; Attributes: bp-based frame
.text$mn:000116CC
.text$mn:000116CC ; void __thiscall VerticalFileSwitcher::reload(VerticalFileSwitcher *__hidden this)
.text$mn:000116CC                 public ?reload@VerticalFileSwitcher@@QAEXXZ
.text$mn:000116CC ?reload@VerticalFileSwitcher@@QAEXXZ proc near
.text$mn:000116CC                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+DB9p
.text$mn:000116CC
.text$mn:000116CC var_4           = dword ptr -4
.text$mn:000116CC
.text$mn:000116CC                 push    ebp
.text$mn:000116CD                 mov     ebp, esp
.text$mn:000116CF                 push    ecx
.text$mn:000116D0                 mov     [ebp+var_4], ecx
.text$mn:000116D3                 push    1               ; unsigned int
.text$mn:000116D5                 mov     ecx, [ebp+var_4]
.text$mn:000116D8                 add     ecx, 6Ch ; 'l'  ; this
.text$mn:000116DB                 call    ?deleteColumn@VerticalFileSwitcherListView@@QAEXI@Z ; VerticalFileSwitcherListView::deleteColumn(uint)
.text$mn:000116E0                 push    0               ; unsigned int
.text$mn:000116E2                 mov     ecx, [ebp+var_4]
.text$mn:000116E5                 add     ecx, 6Ch ; 'l'  ; this
.text$mn:000116E8                 call    ?deleteColumn@VerticalFileSwitcherListView@@QAEXI@Z ; VerticalFileSwitcherListView::deleteColumn(uint)
.text$mn:000116ED                 mov     ecx, [ebp+var_4]
.text$mn:000116F0                 add     ecx, 6Ch ; 'l'  ; this
.text$mn:000116F3                 call    ?reload@VerticalFileSwitcherListView@@QAEXXZ ; VerticalFileSwitcherListView::reload(void)
.text$mn:000116F8                 mov     esp, ebp
.text$mn:000116FA                 pop     ebp
.text$mn:000116FB                 retn
.text$mn:000116FB ?reload@VerticalFileSwitcher@@QAEXXZ endp
.text$mn:000116FB
.text$mn:000116FB _text$mn        ends
.text$mn:000116FB
.text$mn:000116FC ; ===========================================================================
.text$mn:000116FC
.text$mn:000116FC ; Segment type: Pure code
.text$mn:000116FC ; Segment permissions: Read/Execute
.text$mn:000116FC _text$mn        segment para public 'CODE' use32
.text$mn:000116FC                 assume cs:_text$mn
.text$mn:000116FC                 ;org 116FCh
.text$mn:000116FC ; COMDAT (pick any)
.text$mn:000116FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000116FC
.text$mn:000116FC ; =============== S U B R O U T I N E =======================================
.text$mn:000116FC
.text$mn:000116FC ; Attributes: bp-based frame
.text$mn:000116FC
.text$mn:000116FC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::replace(unsigned int, unsigned int, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:000116FC                 public ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z
.text$mn:000116FC ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z proc near
.text$mn:000116FC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+5Bp
.text$mn:000116FC
.text$mn:000116FC var_10          = dword ptr -10h
.text$mn:000116FC var_C           = dword ptr -0Ch
.text$mn:000116FC var_8           = dword ptr -8
.text$mn:000116FC var_4           = dword ptr -4
.text$mn:000116FC arg_0           = dword ptr  8
.text$mn:000116FC arg_4           = dword ptr  0Ch
.text$mn:000116FC arg_8           = dword ptr  10h
.text$mn:000116FC arg_C           = dword ptr  14h
.text$mn:000116FC arg_10          = dword ptr  18h
.text$mn:000116FC
.text$mn:000116FC                 push    ebp
.text$mn:000116FD                 mov     ebp, esp
.text$mn:000116FF                 sub     esp, 10h
.text$mn:00011702                 mov     [ebp+var_4], ecx
.text$mn:00011705                 mov     eax, [ebp+var_4]
.text$mn:00011708                 mov     ecx, [eax+14h]
.text$mn:0001170B                 cmp     ecx, [ebp+arg_0]
.text$mn:0001170E                 jb      short loc_1171D
.text$mn:00011710                 mov     ecx, [ebp+arg_8]
.text$mn:00011713                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00011718                 cmp     eax, [ebp+arg_C]
.text$mn:0001171B                 jnb     short loc_11725
.text$mn:0001171D
.text$mn:0001171D loc_1171D:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+12j
.text$mn:0001171D                 mov     ecx, [ebp+var_4]
.text$mn:00011720                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00011725
.text$mn:00011725 loc_11725:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+1Fj
.text$mn:00011725                 mov     edx, [ebp+var_4]
.text$mn:00011728                 mov     eax, [edx+14h]
.text$mn:0001172B                 sub     eax, [ebp+arg_0]
.text$mn:0001172E                 cmp     eax, [ebp+arg_4]
.text$mn:00011731                 jnb     short loc_1173F
.text$mn:00011733                 mov     ecx, [ebp+var_4]
.text$mn:00011736                 mov     edx, [ecx+14h]
.text$mn:00011739                 sub     edx, [ebp+arg_0]
.text$mn:0001173C                 mov     [ebp+arg_4], edx
.text$mn:0001173F
.text$mn:0001173F loc_1173F:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+35j
.text$mn:0001173F                 mov     ecx, [ebp+arg_8]
.text$mn:00011742                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00011747                 sub     eax, [ebp+arg_C]
.text$mn:0001174A                 mov     [ebp+var_10], eax
.text$mn:0001174D                 mov     eax, [ebp+var_10]
.text$mn:00011750                 cmp     eax, [ebp+arg_10]
.text$mn:00011753                 jnb     short loc_1175B
.text$mn:00011755                 mov     ecx, [ebp+var_10]
.text$mn:00011758                 mov     [ebp+arg_10], ecx
.text$mn:0001175B
.text$mn:0001175B loc_1175B:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+57j
.text$mn:0001175B                 or      edx, 0FFFFFFFFh
.text$mn:0001175E                 sub     edx, [ebp+arg_10]
.text$mn:00011761                 mov     eax, [ebp+var_4]
.text$mn:00011764                 mov     ecx, [eax+14h]
.text$mn:00011767                 sub     ecx, [ebp+arg_4]
.text$mn:0001176A                 cmp     edx, ecx
.text$mn:0001176C                 ja      short loc_11776
.text$mn:0001176E                 mov     ecx, [ebp+var_4]
.text$mn:00011771                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00011776
.text$mn:00011776 loc_11776:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+70j
.text$mn:00011776                 mov     edx, [ebp+var_4]
.text$mn:00011779                 mov     eax, [edx+14h]
.text$mn:0001177C                 sub     eax, [ebp+arg_4]
.text$mn:0001177F                 sub     eax, [ebp+arg_0]
.text$mn:00011782                 mov     [ebp+var_8], eax
.text$mn:00011785                 mov     ecx, [ebp+var_4]
.text$mn:00011788                 mov     edx, [ecx+14h]
.text$mn:0001178B                 add     edx, [ebp+arg_10]
.text$mn:0001178E                 sub     edx, [ebp+arg_4]
.text$mn:00011791                 mov     [ebp+var_C], edx
.text$mn:00011794                 mov     eax, [ebp+var_4]
.text$mn:00011797                 mov     ecx, [eax+14h]
.text$mn:0001179A                 cmp     ecx, [ebp+var_C]
.text$mn:0001179D                 jnb     short loc_117AD
.text$mn:0001179F                 push    0
.text$mn:000117A1                 mov     edx, [ebp+var_C]
.text$mn:000117A4                 push    edx
.text$mn:000117A5                 mov     ecx, [ebp+var_4]
.text$mn:000117A8                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:000117AD
.text$mn:000117AD loc_117AD:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+A1j
.text$mn:000117AD                 mov     eax, [ebp+var_4]
.text$mn:000117B0                 cmp     eax, [ebp+arg_8]
.text$mn:000117B3                 jz      short loc_1181A
.text$mn:000117B5                 mov     ecx, [ebp+var_8]
.text$mn:000117B8                 push    ecx             ; int
.text$mn:000117B9                 mov     ecx, [ebp+var_4]
.text$mn:000117BC                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000117C1                 mov     edx, [ebp+arg_0]
.text$mn:000117C4                 lea     eax, [eax+edx*2]
.text$mn:000117C7                 mov     ecx, [ebp+arg_4]
.text$mn:000117CA                 lea     edx, [eax+ecx*2]
.text$mn:000117CD                 push    edx             ; Src
.text$mn:000117CE                 mov     ecx, [ebp+var_4]
.text$mn:000117D1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000117D6                 mov     ecx, [ebp+arg_0]
.text$mn:000117D9                 lea     edx, [eax+ecx*2]
.text$mn:000117DC                 mov     eax, [ebp+arg_10]
.text$mn:000117DF                 lea     ecx, [edx+eax*2]
.text$mn:000117E2                 push    ecx             ; Dst
.text$mn:000117E3                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000117E8                 add     esp, 0Ch
.text$mn:000117EB                 mov     edx, [ebp+arg_10]
.text$mn:000117EE                 push    edx             ; int
.text$mn:000117EF                 mov     ecx, [ebp+arg_8]
.text$mn:000117F2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000117F7                 mov     ecx, [ebp+arg_C]
.text$mn:000117FA                 lea     edx, [eax+ecx*2]
.text$mn:000117FD                 push    edx             ; Src
.text$mn:000117FE                 mov     ecx, [ebp+var_4]
.text$mn:00011801                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00011806                 mov     ecx, [ebp+arg_0]
.text$mn:00011809                 lea     edx, [eax+ecx*2]
.text$mn:0001180C                 push    edx             ; Dst
.text$mn:0001180D                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00011812                 add     esp, 0Ch
.text$mn:00011815                 jmp     loc_11A03
.text$mn:0001181A ; ---------------------------------------------------------------------------
.text$mn:0001181A
.text$mn:0001181A loc_1181A:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+B7j
.text$mn:0001181A                 mov     eax, [ebp+arg_10]
.text$mn:0001181D                 cmp     eax, [ebp+arg_4]
.text$mn:00011820                 ja      short loc_11887
.text$mn:00011822                 mov     ecx, [ebp+arg_10]
.text$mn:00011825                 push    ecx             ; int
.text$mn:00011826                 mov     ecx, [ebp+var_4]
.text$mn:00011829                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0001182E                 mov     edx, [ebp+arg_C]
.text$mn:00011831                 lea     eax, [eax+edx*2]
.text$mn:00011834                 push    eax             ; Src
.text$mn:00011835                 mov     ecx, [ebp+var_4]
.text$mn:00011838                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0001183D                 mov     ecx, [ebp+arg_0]
.text$mn:00011840                 lea     edx, [eax+ecx*2]
.text$mn:00011843                 push    edx             ; Dst
.text$mn:00011844                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00011849                 add     esp, 0Ch
.text$mn:0001184C                 mov     eax, [ebp+var_8]
.text$mn:0001184F                 push    eax             ; int
.text$mn:00011850                 mov     ecx, [ebp+var_4]
.text$mn:00011853                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00011858                 mov     ecx, [ebp+arg_0]
.text$mn:0001185B                 lea     edx, [eax+ecx*2]
.text$mn:0001185E                 mov     eax, [ebp+arg_4]
.text$mn:00011861                 lea     ecx, [edx+eax*2]
.text$mn:00011864                 push    ecx             ; Src
.text$mn:00011865                 mov     ecx, [ebp+var_4]
.text$mn:00011868                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0001186D                 mov     edx, [ebp+arg_0]
.text$mn:00011870                 lea     eax, [eax+edx*2]
.text$mn:00011873                 mov     ecx, [ebp+arg_10]
.text$mn:00011876                 lea     edx, [eax+ecx*2]
.text$mn:00011879                 push    edx             ; Dst
.text$mn:0001187A                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0001187F                 add     esp, 0Ch
.text$mn:00011882                 jmp     loc_11A03
.text$mn:00011887 ; ---------------------------------------------------------------------------
.text$mn:00011887
.text$mn:00011887 loc_11887:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+124j
.text$mn:00011887                 mov     eax, [ebp+arg_C]
.text$mn:0001188A                 cmp     eax, [ebp+arg_0]
.text$mn:0001188D                 ja      short loc_118F4
.text$mn:0001188F                 mov     ecx, [ebp+var_8]
.text$mn:00011892                 push    ecx             ; int
.text$mn:00011893                 mov     ecx, [ebp+var_4]
.text$mn:00011896                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0001189B                 mov     edx, [ebp+arg_0]
.text$mn:0001189E                 lea     eax, [eax+edx*2]
.text$mn:000118A1                 mov     ecx, [ebp+arg_4]
.text$mn:000118A4                 lea     edx, [eax+ecx*2]
.text$mn:000118A7                 push    edx             ; Src
.text$mn:000118A8                 mov     ecx, [ebp+var_4]
.text$mn:000118AB                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000118B0                 mov     ecx, [ebp+arg_0]
.text$mn:000118B3                 lea     edx, [eax+ecx*2]
.text$mn:000118B6                 mov     eax, [ebp+arg_10]
.text$mn:000118B9                 lea     ecx, [edx+eax*2]
.text$mn:000118BC                 push    ecx             ; Dst
.text$mn:000118BD                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000118C2                 add     esp, 0Ch
.text$mn:000118C5                 mov     edx, [ebp+arg_10]
.text$mn:000118C8                 push    edx             ; int
.text$mn:000118C9                 mov     ecx, [ebp+var_4]
.text$mn:000118CC                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000118D1                 mov     ecx, [ebp+arg_C]
.text$mn:000118D4                 lea     edx, [eax+ecx*2]
.text$mn:000118D7                 push    edx             ; Src
.text$mn:000118D8                 mov     ecx, [ebp+var_4]
.text$mn:000118DB                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000118E0                 mov     ecx, [ebp+arg_0]
.text$mn:000118E3                 lea     edx, [eax+ecx*2]
.text$mn:000118E6                 push    edx             ; Dst
.text$mn:000118E7                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000118EC                 add     esp, 0Ch
.text$mn:000118EF                 jmp     loc_11A03
.text$mn:000118F4 ; ---------------------------------------------------------------------------
.text$mn:000118F4
.text$mn:000118F4 loc_118F4:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+191j
.text$mn:000118F4                 mov     eax, [ebp+arg_0]
.text$mn:000118F7                 add     eax, [ebp+arg_4]
.text$mn:000118FA                 cmp     eax, [ebp+arg_C]
.text$mn:000118FD                 ja      short loc_1196A
.text$mn:000118FF                 mov     ecx, [ebp+var_8]
.text$mn:00011902                 push    ecx             ; int
.text$mn:00011903                 mov     ecx, [ebp+var_4]
.text$mn:00011906                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0001190B                 mov     edx, [ebp+arg_0]
.text$mn:0001190E                 lea     eax, [eax+edx*2]
.text$mn:00011911                 mov     ecx, [ebp+arg_4]
.text$mn:00011914                 lea     edx, [eax+ecx*2]
.text$mn:00011917                 push    edx             ; Src
.text$mn:00011918                 mov     ecx, [ebp+var_4]
.text$mn:0001191B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00011920                 mov     ecx, [ebp+arg_0]
.text$mn:00011923                 lea     edx, [eax+ecx*2]
.text$mn:00011926                 mov     eax, [ebp+arg_10]
.text$mn:00011929                 lea     ecx, [edx+eax*2]
.text$mn:0001192C                 push    ecx             ; Dst
.text$mn:0001192D                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00011932                 add     esp, 0Ch
.text$mn:00011935                 mov     edx, [ebp+arg_10]
.text$mn:00011938                 push    edx             ; int
.text$mn:00011939                 mov     ecx, [ebp+var_4]
.text$mn:0001193C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00011941                 mov     ecx, [ebp+arg_C]
.text$mn:00011944                 add     ecx, [ebp+arg_10]
.text$mn:00011947                 sub     ecx, [ebp+arg_4]
.text$mn:0001194A                 lea     edx, [eax+ecx*2]
.text$mn:0001194D                 push    edx             ; Src
.text$mn:0001194E                 mov     ecx, [ebp+var_4]
.text$mn:00011951                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00011956                 mov     ecx, [ebp+arg_0]
.text$mn:00011959                 lea     edx, [eax+ecx*2]
.text$mn:0001195C                 push    edx             ; Dst
.text$mn:0001195D                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00011962                 add     esp, 0Ch
.text$mn:00011965                 jmp     loc_11A03
.text$mn:0001196A ; ---------------------------------------------------------------------------
.text$mn:0001196A
.text$mn:0001196A loc_1196A:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+201j
.text$mn:0001196A                 mov     eax, [ebp+arg_4]
.text$mn:0001196D                 push    eax             ; int
.text$mn:0001196E                 mov     ecx, [ebp+var_4]
.text$mn:00011971                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00011976                 mov     ecx, [ebp+arg_C]
.text$mn:00011979                 lea     edx, [eax+ecx*2]
.text$mn:0001197C                 push    edx             ; Src
.text$mn:0001197D                 mov     ecx, [ebp+var_4]
.text$mn:00011980                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00011985                 mov     ecx, [ebp+arg_0]
.text$mn:00011988                 lea     edx, [eax+ecx*2]
.text$mn:0001198B                 push    edx             ; Dst
.text$mn:0001198C                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00011991                 add     esp, 0Ch
.text$mn:00011994                 mov     eax, [ebp+var_8]
.text$mn:00011997                 push    eax             ; int
.text$mn:00011998                 mov     ecx, [ebp+var_4]
.text$mn:0001199B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000119A0                 mov     ecx, [ebp+arg_0]
.text$mn:000119A3                 lea     edx, [eax+ecx*2]
.text$mn:000119A6                 mov     eax, [ebp+arg_4]
.text$mn:000119A9                 lea     ecx, [edx+eax*2]
.text$mn:000119AC                 push    ecx             ; Src
.text$mn:000119AD                 mov     ecx, [ebp+var_4]
.text$mn:000119B0                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000119B5                 mov     edx, [ebp+arg_0]
.text$mn:000119B8                 lea     eax, [eax+edx*2]
.text$mn:000119BB                 mov     ecx, [ebp+arg_10]
.text$mn:000119BE                 lea     edx, [eax+ecx*2]
.text$mn:000119C1                 push    edx             ; Dst
.text$mn:000119C2                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000119C7                 add     esp, 0Ch
.text$mn:000119CA                 mov     eax, [ebp+arg_10]
.text$mn:000119CD                 sub     eax, [ebp+arg_4]
.text$mn:000119D0                 push    eax             ; int
.text$mn:000119D1                 mov     ecx, [ebp+var_4]
.text$mn:000119D4                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000119D9                 mov     ecx, [ebp+arg_C]
.text$mn:000119DC                 lea     edx, [eax+ecx*2]
.text$mn:000119DF                 mov     eax, [ebp+arg_10]
.text$mn:000119E2                 lea     ecx, [edx+eax*2]
.text$mn:000119E5                 push    ecx             ; Src
.text$mn:000119E6                 mov     ecx, [ebp+var_4]
.text$mn:000119E9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000119EE                 mov     edx, [ebp+arg_0]
.text$mn:000119F1                 lea     eax, [eax+edx*2]
.text$mn:000119F4                 mov     ecx, [ebp+arg_4]
.text$mn:000119F7                 lea     edx, [eax+ecx*2]
.text$mn:000119FA                 push    edx             ; Dst
.text$mn:000119FB                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00011A00                 add     esp, 0Ch
.text$mn:00011A03
.text$mn:00011A03 loc_11A03:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+119j
.text$mn:00011A03                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+186j ...
.text$mn:00011A03                 mov     eax, [ebp+var_C]
.text$mn:00011A06                 push    eax
.text$mn:00011A07                 mov     ecx, [ebp+var_4]
.text$mn:00011A0A                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00011A0F                 mov     eax, [ebp+var_4]
.text$mn:00011A12                 mov     esp, ebp
.text$mn:00011A14                 pop     ebp
.text$mn:00011A15                 retn    14h
.text$mn:00011A15 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z endp
.text$mn:00011A15
.text$mn:00011A15 _text$mn        ends
.text$mn:00011A15
.text$mn:00011A18 ; ===========================================================================
.text$mn:00011A18
.text$mn:00011A18 ; Segment type: Pure code
.text$mn:00011A18 ; Segment permissions: Read/Execute
.text$mn:00011A18 _text$mn        segment para public 'CODE' use32
.text$mn:00011A18                 assume cs:_text$mn
.text$mn:00011A18                 ;org 11A18h
.text$mn:00011A18 ; COMDAT (pick any)
.text$mn:00011A18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011A18
.text$mn:00011A18 ; =============== S U B R O U T I N E =======================================
.text$mn:00011A18
.text$mn:00011A18 ; Attributes: bp-based frame
.text$mn:00011A18
.text$mn:00011A18 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(int, int, void *Src, int)
.text$mn:00011A18                 public ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z
.text$mn:00011A18 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z proc near
.text$mn:00011A18                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+201p
.text$mn:00011A18
.text$mn:00011A18 var_C           = dword ptr -0Ch
.text$mn:00011A18 var_8           = dword ptr -8
.text$mn:00011A18 var_4           = dword ptr -4
.text$mn:00011A18 arg_0           = dword ptr  8
.text$mn:00011A18 arg_4           = dword ptr  0Ch
.text$mn:00011A18 Src             = dword ptr  10h
.text$mn:00011A18 arg_C           = dword ptr  14h
.text$mn:00011A18
.text$mn:00011A18                 push    ebp
.text$mn:00011A19                 mov     ebp, esp
.text$mn:00011A1B                 sub     esp, 0Ch
.text$mn:00011A1E                 mov     [ebp+var_4], ecx
.text$mn:00011A21                 cmp     [ebp+arg_C], 0
.text$mn:00011A25                 jz      short loc_11A3D
.text$mn:00011A27                 push    5A9h            ; unsigned int
.text$mn:00011A2C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00011A31                 mov     eax, [ebp+Src]
.text$mn:00011A34                 push    eax             ; int
.text$mn:00011A35                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00011A3A                 add     esp, 0Ch
.text$mn:00011A3D
.text$mn:00011A3D loc_11A3D:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+Dj
.text$mn:00011A3D                 mov     ecx, [ebp+Src]
.text$mn:00011A40                 push    ecx
.text$mn:00011A41                 mov     ecx, [ebp+var_4]
.text$mn:00011A44                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00011A49                 movzx   edx, al
.text$mn:00011A4C                 test    edx, edx
.text$mn:00011A4E                 jz      short loc_11A7D
.text$mn:00011A50                 mov     eax, [ebp+arg_C]
.text$mn:00011A53                 push    eax
.text$mn:00011A54                 mov     ecx, [ebp+var_4]
.text$mn:00011A57                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00011A5C                 mov     ecx, [ebp+Src]
.text$mn:00011A5F                 sub     ecx, eax
.text$mn:00011A61                 sar     ecx, 1
.text$mn:00011A63                 push    ecx
.text$mn:00011A64                 mov     edx, [ebp+var_4]
.text$mn:00011A67                 push    edx
.text$mn:00011A68                 mov     eax, [ebp+arg_4]
.text$mn:00011A6B                 push    eax
.text$mn:00011A6C                 mov     ecx, [ebp+arg_0]
.text$mn:00011A6F                 push    ecx
.text$mn:00011A70                 mov     ecx, [ebp+var_4]
.text$mn:00011A73                 call    ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00011A78                 jmp     loc_11BB2
.text$mn:00011A7D ; ---------------------------------------------------------------------------
.text$mn:00011A7D
.text$mn:00011A7D loc_11A7D:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+36j
.text$mn:00011A7D                 mov     edx, [ebp+var_4]
.text$mn:00011A80                 mov     eax, [edx+14h]
.text$mn:00011A83                 cmp     eax, [ebp+arg_0]
.text$mn:00011A86                 jnb     short loc_11A90
.text$mn:00011A88                 mov     ecx, [ebp+var_4]
.text$mn:00011A8B                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00011A90
.text$mn:00011A90 loc_11A90:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+6Ej
.text$mn:00011A90                 mov     ecx, [ebp+var_4]
.text$mn:00011A93                 mov     edx, [ecx+14h]
.text$mn:00011A96                 sub     edx, [ebp+arg_0]
.text$mn:00011A99                 cmp     edx, [ebp+arg_4]
.text$mn:00011A9C                 jnb     short loc_11AAA
.text$mn:00011A9E                 mov     eax, [ebp+var_4]
.text$mn:00011AA1                 mov     ecx, [eax+14h]
.text$mn:00011AA4                 sub     ecx, [ebp+arg_0]
.text$mn:00011AA7                 mov     [ebp+arg_4], ecx
.text$mn:00011AAA
.text$mn:00011AAA loc_11AAA:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+84j
.text$mn:00011AAA                 or      edx, 0FFFFFFFFh
.text$mn:00011AAD                 sub     edx, [ebp+arg_C]
.text$mn:00011AB0                 mov     eax, [ebp+var_4]
.text$mn:00011AB3                 mov     ecx, [eax+14h]
.text$mn:00011AB6                 sub     ecx, [ebp+arg_4]
.text$mn:00011AB9                 cmp     edx, ecx
.text$mn:00011ABB                 ja      short loc_11AC5
.text$mn:00011ABD                 mov     ecx, [ebp+var_4]
.text$mn:00011AC0                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00011AC5
.text$mn:00011AC5 loc_11AC5:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+A3j
.text$mn:00011AC5                 mov     edx, [ebp+var_4]
.text$mn:00011AC8                 mov     eax, [edx+14h]
.text$mn:00011ACB                 sub     eax, [ebp+arg_4]
.text$mn:00011ACE                 sub     eax, [ebp+arg_0]
.text$mn:00011AD1                 mov     [ebp+var_8], eax
.text$mn:00011AD4                 mov     ecx, [ebp+arg_C]
.text$mn:00011AD7                 cmp     ecx, [ebp+arg_4]
.text$mn:00011ADA                 jnb     short loc_11B12
.text$mn:00011ADC                 mov     edx, [ebp+var_8]
.text$mn:00011ADF                 push    edx             ; int
.text$mn:00011AE0                 mov     ecx, [ebp+var_4]
.text$mn:00011AE3                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00011AE8                 mov     ecx, [ebp+arg_0]
.text$mn:00011AEB                 lea     edx, [eax+ecx*2]
.text$mn:00011AEE                 mov     eax, [ebp+arg_4]
.text$mn:00011AF1                 lea     ecx, [edx+eax*2]
.text$mn:00011AF4                 push    ecx             ; Src
.text$mn:00011AF5                 mov     ecx, [ebp+var_4]
.text$mn:00011AF8                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00011AFD                 mov     edx, [ebp+arg_0]
.text$mn:00011B00                 lea     eax, [eax+edx*2]
.text$mn:00011B03                 mov     ecx, [ebp+arg_C]
.text$mn:00011B06                 lea     edx, [eax+ecx*2]
.text$mn:00011B09                 push    edx             ; Dst
.text$mn:00011B0A                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00011B0F                 add     esp, 0Ch
.text$mn:00011B12
.text$mn:00011B12 loc_11B12:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+C2j
.text$mn:00011B12                 cmp     [ebp+arg_C], 0
.text$mn:00011B16                 ja      short loc_11B22
.text$mn:00011B18                 cmp     [ebp+arg_4], 0
.text$mn:00011B1C                 jbe     loc_11BAF
.text$mn:00011B22
.text$mn:00011B22 loc_11B22:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+FEj
.text$mn:00011B22                 mov     eax, [ebp+var_4]
.text$mn:00011B25                 mov     ecx, [eax+14h]
.text$mn:00011B28                 add     ecx, [ebp+arg_C]
.text$mn:00011B2B                 sub     ecx, [ebp+arg_4]
.text$mn:00011B2E                 mov     [ebp+var_C], ecx
.text$mn:00011B31                 push    0
.text$mn:00011B33                 mov     edx, [ebp+var_C]
.text$mn:00011B36                 push    edx
.text$mn:00011B37                 mov     ecx, [ebp+var_4]
.text$mn:00011B3A                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00011B3F                 movzx   eax, al
.text$mn:00011B42                 test    eax, eax
.text$mn:00011B44                 jz      short loc_11BAF
.text$mn:00011B46                 mov     ecx, [ebp+arg_4]
.text$mn:00011B49                 cmp     ecx, [ebp+arg_C]
.text$mn:00011B4C                 jnb     short loc_11B84
.text$mn:00011B4E                 mov     edx, [ebp+var_8]
.text$mn:00011B51                 push    edx             ; int
.text$mn:00011B52                 mov     ecx, [ebp+var_4]
.text$mn:00011B55                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00011B5A                 mov     ecx, [ebp+arg_0]
.text$mn:00011B5D                 lea     edx, [eax+ecx*2]
.text$mn:00011B60                 mov     eax, [ebp+arg_4]
.text$mn:00011B63                 lea     ecx, [edx+eax*2]
.text$mn:00011B66                 push    ecx             ; Src
.text$mn:00011B67                 mov     ecx, [ebp+var_4]
.text$mn:00011B6A                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00011B6F                 mov     edx, [ebp+arg_0]
.text$mn:00011B72                 lea     eax, [eax+edx*2]
.text$mn:00011B75                 mov     ecx, [ebp+arg_C]
.text$mn:00011B78                 lea     edx, [eax+ecx*2]
.text$mn:00011B7B                 push    edx             ; Dst
.text$mn:00011B7C                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00011B81                 add     esp, 0Ch
.text$mn:00011B84
.text$mn:00011B84 loc_11B84:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+134j
.text$mn:00011B84                 mov     eax, [ebp+arg_C]
.text$mn:00011B87                 push    eax             ; int
.text$mn:00011B88                 mov     ecx, [ebp+Src]
.text$mn:00011B8B                 push    ecx             ; Src
.text$mn:00011B8C                 mov     ecx, [ebp+var_4]
.text$mn:00011B8F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00011B94                 mov     edx, [ebp+arg_0]
.text$mn:00011B97                 lea     eax, [eax+edx*2]
.text$mn:00011B9A                 push    eax             ; Dst
.text$mn:00011B9B                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00011BA0                 add     esp, 0Ch
.text$mn:00011BA3                 mov     ecx, [ebp+var_C]
.text$mn:00011BA6                 push    ecx
.text$mn:00011BA7                 mov     ecx, [ebp+var_4]
.text$mn:00011BAA                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00011BAF
.text$mn:00011BAF loc_11BAF:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+104j
.text$mn:00011BAF                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+12Cj
.text$mn:00011BAF                 mov     eax, [ebp+var_4]
.text$mn:00011BB2
.text$mn:00011BB2 loc_11BB2:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+60j
.text$mn:00011BB2                 mov     esp, ebp
.text$mn:00011BB4                 pop     ebp
.text$mn:00011BB5                 retn    10h
.text$mn:00011BB5 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z endp
.text$mn:00011BB5
.text$mn:00011BB5 _text$mn        ends
.text$mn:00011BB5
.text$mn:00011BB8 ; ===========================================================================
.text$mn:00011BB8
.text$mn:00011BB8 ; Segment type: Pure code
.text$mn:00011BB8 ; Segment permissions: Read/Execute
.text$mn:00011BB8 _text$mn        segment para public 'CODE' use32
.text$mn:00011BB8                 assume cs:_text$mn
.text$mn:00011BB8                 ;org 11BB8h
.text$mn:00011BB8 ; COMDAT (pick any)
.text$mn:00011BB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011BB8
.text$mn:00011BB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00011BB8
.text$mn:00011BB8 ; Attributes: bp-based frame
.text$mn:00011BB8
.text$mn:00011BB8 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::replace(class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:00011BB8                 public ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z
.text$mn:00011BB8 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z proc near
.text$mn:00011BB8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+E0p
.text$mn:00011BB8
.text$mn:00011BB8 var_AC          = byte ptr -0ACh
.text$mn:00011BB8 var_A0          = byte ptr -0A0h
.text$mn:00011BB8 var_94          = dword ptr -94h
.text$mn:00011BB8 var_90          = dword ptr -90h
.text$mn:00011BB8 var_8C          = dword ptr -8Ch
.text$mn:00011BB8 var_88          = dword ptr -88h
.text$mn:00011BB8 var_84          = dword ptr -84h
.text$mn:00011BB8 var_80          = dword ptr -80h
.text$mn:00011BB8 var_7C          = dword ptr -7Ch
.text$mn:00011BB8 var_78          = dword ptr -78h
.text$mn:00011BB8 var_74          = dword ptr -74h
.text$mn:00011BB8 var_70          = dword ptr -70h
.text$mn:00011BB8 var_6C          = dword ptr -6Ch
.text$mn:00011BB8 var_68          = dword ptr -68h
.text$mn:00011BB8 var_64          = dword ptr -64h
.text$mn:00011BB8 var_60          = dword ptr -60h
.text$mn:00011BB8 var_5C          = dword ptr -5Ch
.text$mn:00011BB8 var_58          = dword ptr -58h
.text$mn:00011BB8 var_54          = dword ptr -54h
.text$mn:00011BB8 var_50          = dword ptr -50h
.text$mn:00011BB8 var_4C          = dword ptr -4Ch
.text$mn:00011BB8 var_48          = dword ptr -48h
.text$mn:00011BB8 var_44          = dword ptr -44h
.text$mn:00011BB8 var_40          = dword ptr -40h
.text$mn:00011BB8 var_3C          = dword ptr -3Ch
.text$mn:00011BB8 var_38          = dword ptr -38h
.text$mn:00011BB8 var_34          = dword ptr -34h
.text$mn:00011BB8 var_30          = dword ptr -30h
.text$mn:00011BB8 var_2C          = dword ptr -2Ch
.text$mn:00011BB8 var_28          = dword ptr -28h
.text$mn:00011BB8 var_24          = dword ptr -24h
.text$mn:00011BB8 var_20          = dword ptr -20h
.text$mn:00011BB8 var_1C          = dword ptr -1Ch
.text$mn:00011BB8 var_18          = dword ptr -18h
.text$mn:00011BB8 var_14          = dword ptr -14h
.text$mn:00011BB8 var_10          = dword ptr -10h
.text$mn:00011BB8 var_C           = dword ptr -0Ch
.text$mn:00011BB8 var_4           = dword ptr -4
.text$mn:00011BB8 arg_0           = byte ptr  8
.text$mn:00011BB8 arg_C           = byte ptr  14h
.text$mn:00011BB8 arg_18          = byte ptr  20h
.text$mn:00011BB8 arg_24          = byte ptr  2Ch
.text$mn:00011BB8
.text$mn:00011BB8                 push    ebp
.text$mn:00011BB9                 mov     ebp, esp
.text$mn:00011BBB                 push    0FFFFFFFFh
.text$mn:00011BBD                 push    offset __ehhandler$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z
.text$mn:00011BC2                 mov     eax, large fs:0
.text$mn:00011BC8                 push    eax
.text$mn:00011BC9                 sub     esp, 0A0h
.text$mn:00011BCF                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00011BD4                 xor     eax, ebp
.text$mn:00011BD6                 push    eax
.text$mn:00011BD7                 lea     eax, [ebp+var_C]
.text$mn:00011BDA                 mov     large fs:0, eax
.text$mn:00011BE0                 mov     [ebp+var_10], ecx
.text$mn:00011BE3                 mov     [ebp+var_4], 3
.text$mn:00011BEA                 lea     eax, [ebp+arg_24]
.text$mn:00011BED                 push    eax             ; std::_Iterator_base12 *
.text$mn:00011BEE                 lea     ecx, [ebp+arg_18]
.text$mn:00011BF1                 call    ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00011BF6                 movzx   ecx, al
.text$mn:00011BF9                 test    ecx, ecx
.text$mn:00011BFB                 jz      loc_11CDD
.text$mn:00011C01                 sub     esp, 0Ch
.text$mn:00011C04                 mov     ecx, esp
.text$mn:00011C06                 mov     [ebp+var_58], esp
.text$mn:00011C09                 lea     edx, [ebp+arg_0]
.text$mn:00011C0C                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00011C0D                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00011C12                 mov     [ebp+var_54], eax
.text$mn:00011C15                 mov     eax, [ebp+var_54]
.text$mn:00011C18                 mov     [ebp+var_60], eax
.text$mn:00011C1B                 mov     byte ptr [ebp+var_4], 4
.text$mn:00011C1F                 sub     esp, 0Ch
.text$mn:00011C22                 mov     ecx, esp
.text$mn:00011C24                 mov     [ebp+var_80], esp
.text$mn:00011C27                 lea     edx, [ebp+arg_C]
.text$mn:00011C2A                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00011C2B                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00011C30                 mov     [ebp+var_38], eax
.text$mn:00011C33                 mov     eax, [ebp+var_38]
.text$mn:00011C36                 mov     [ebp+var_68], eax
.text$mn:00011C39                 mov     byte ptr [ebp+var_4], 5
.text$mn:00011C3D                 mov     byte ptr [ebp+var_4], 3
.text$mn:00011C41                 call    ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00011C46                 add     esp, 18h
.text$mn:00011C49                 mov     [ebp+var_20], eax
.text$mn:00011C4C                 mov     ecx, [ebp+var_20]
.text$mn:00011C4F                 push    ecx
.text$mn:00011C50                 lea     edx, [ebp+var_A0]
.text$mn:00011C56                 push    edx
.text$mn:00011C57                 mov     ecx, [ebp+var_10]
.text$mn:00011C5A                 call    ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)
.text$mn:00011C5F                 mov     [ebp+var_48], eax
.text$mn:00011C62                 mov     eax, [ebp+var_48]
.text$mn:00011C65                 mov     [ebp+var_28], eax
.text$mn:00011C68                 mov     byte ptr [ebp+var_4], 6
.text$mn:00011C6C                 sub     esp, 0Ch
.text$mn:00011C6F                 mov     ecx, esp
.text$mn:00011C71                 mov     [ebp+var_90], esp
.text$mn:00011C77                 mov     edx, [ebp+var_28]
.text$mn:00011C7A                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00011C7B                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00011C80                 mov     [ebp+var_40], eax
.text$mn:00011C83                 mov     eax, [ebp+var_40]
.text$mn:00011C86                 mov     [ebp+var_70], eax
.text$mn:00011C89                 mov     byte ptr [ebp+var_4], 7
.text$mn:00011C8D                 sub     esp, 0Ch
.text$mn:00011C90                 mov     ecx, esp
.text$mn:00011C92                 mov     [ebp+var_88], esp
.text$mn:00011C98                 lea     edx, [ebp+arg_0]
.text$mn:00011C9B                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00011C9C                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00011CA1                 mov     [ebp+var_30], eax
.text$mn:00011CA4                 mov     eax, [ebp+var_30]
.text$mn:00011CA7                 mov     [ebp+var_78], eax
.text$mn:00011CAA                 mov     byte ptr [ebp+var_4], 8
.text$mn:00011CAE                 mov     byte ptr [ebp+var_4], 6
.text$mn:00011CB2                 call    ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00011CB7                 add     esp, 18h
.text$mn:00011CBA                 mov     [ebp+var_50], eax
.text$mn:00011CBD                 mov     ecx, [ebp+var_50]
.text$mn:00011CC0                 push    ecx
.text$mn:00011CC1                 mov     ecx, [ebp+var_10]
.text$mn:00011CC4                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:00011CC9                 mov     byte ptr [ebp+var_4], 3
.text$mn:00011CCD                 lea     ecx, [ebp+var_A0]
.text$mn:00011CD3                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00011CD8                 jmp     loc_11DCD
.text$mn:00011CDD ; ---------------------------------------------------------------------------
.text$mn:00011CDD
.text$mn:00011CDD loc_11CDD:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+43j
.text$mn:00011CDD                 lea     edx, [ebp+arg_18]
.text$mn:00011CE0                 push    edx             ; std::_Iterator_base12 *
.text$mn:00011CE1                 lea     ecx, [ebp+arg_24]
.text$mn:00011CE4                 call    ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00011CE9                 push    eax             ; int
.text$mn:00011CEA                 lea     ecx, [ebp+arg_18]
.text$mn:00011CED                 call    ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)
.text$mn:00011CF2                 push    eax             ; Src
.text$mn:00011CF3                 sub     esp, 0Ch
.text$mn:00011CF6                 mov     ecx, esp
.text$mn:00011CF8                 mov     [ebp+var_94], esp
.text$mn:00011CFE                 lea     eax, [ebp+arg_0]
.text$mn:00011D01                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00011D02                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00011D07                 mov     [ebp+var_18], eax
.text$mn:00011D0A                 mov     ecx, [ebp+var_18]
.text$mn:00011D0D                 mov     [ebp+var_5C], ecx
.text$mn:00011D10                 mov     byte ptr [ebp+var_4], 9
.text$mn:00011D14                 sub     esp, 0Ch
.text$mn:00011D17                 mov     ecx, esp
.text$mn:00011D19                 mov     [ebp+var_64], esp
.text$mn:00011D1C                 lea     edx, [ebp+arg_C]
.text$mn:00011D1F                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00011D20                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00011D25                 mov     [ebp+var_1C], eax
.text$mn:00011D28                 mov     eax, [ebp+var_1C]
.text$mn:00011D2B                 mov     [ebp+var_6C], eax
.text$mn:00011D2E                 mov     byte ptr [ebp+var_4], 0Ah
.text$mn:00011D32                 mov     byte ptr [ebp+var_4], 3
.text$mn:00011D36                 call    ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00011D3B                 add     esp, 18h
.text$mn:00011D3E                 mov     [ebp+var_24], eax
.text$mn:00011D41                 mov     ecx, [ebp+var_24]
.text$mn:00011D44                 push    ecx             ; int
.text$mn:00011D45                 lea     edx, [ebp+var_AC]
.text$mn:00011D4B                 push    edx
.text$mn:00011D4C                 mov     ecx, [ebp+var_10]
.text$mn:00011D4F                 call    ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)
.text$mn:00011D54                 mov     [ebp+var_2C], eax
.text$mn:00011D57                 mov     eax, [ebp+var_2C]
.text$mn:00011D5A                 mov     [ebp+var_34], eax
.text$mn:00011D5D                 mov     byte ptr [ebp+var_4], 0Bh
.text$mn:00011D61                 sub     esp, 0Ch
.text$mn:00011D64                 mov     ecx, esp
.text$mn:00011D66                 mov     [ebp+var_74], esp
.text$mn:00011D69                 mov     edx, [ebp+var_34]
.text$mn:00011D6C                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00011D6D                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00011D72                 mov     [ebp+var_3C], eax
.text$mn:00011D75                 mov     eax, [ebp+var_3C]
.text$mn:00011D78                 mov     [ebp+var_7C], eax
.text$mn:00011D7B                 mov     byte ptr [ebp+var_4], 0Ch
.text$mn:00011D7F                 sub     esp, 0Ch
.text$mn:00011D82                 mov     ecx, esp
.text$mn:00011D84                 mov     [ebp+var_84], esp
.text$mn:00011D8A                 lea     edx, [ebp+arg_0]
.text$mn:00011D8D                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00011D8E                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00011D93                 mov     [ebp+var_44], eax
.text$mn:00011D96                 mov     eax, [ebp+var_44]
.text$mn:00011D99                 mov     [ebp+var_8C], eax
.text$mn:00011D9F                 mov     byte ptr [ebp+var_4], 0Dh
.text$mn:00011DA3                 mov     byte ptr [ebp+var_4], 0Bh
.text$mn:00011DA7                 call    ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00011DAC                 add     esp, 18h
.text$mn:00011DAF                 mov     [ebp+var_4C], eax
.text$mn:00011DB2                 mov     ecx, [ebp+var_4C]
.text$mn:00011DB5                 push    ecx             ; int
.text$mn:00011DB6                 mov     ecx, [ebp+var_10]
.text$mn:00011DB9                 call    ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)
.text$mn:00011DBE                 mov     byte ptr [ebp+var_4], 3
.text$mn:00011DC2                 lea     ecx, [ebp+var_AC]
.text$mn:00011DC8                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00011DCD
.text$mn:00011DCD loc_11DCD:                              ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+120j
.text$mn:00011DCD                 mov     edx, [ebp+var_10]
.text$mn:00011DD0                 mov     [ebp+var_14], edx
.text$mn:00011DD3                 mov     byte ptr [ebp+var_4], 2
.text$mn:00011DD7                 lea     ecx, [ebp+arg_0]
.text$mn:00011DDA                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00011DDF                 mov     byte ptr [ebp+var_4], 1
.text$mn:00011DE3                 lea     ecx, [ebp+arg_C]
.text$mn:00011DE6                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00011DEB                 mov     byte ptr [ebp+var_4], 0
.text$mn:00011DEF                 lea     ecx, [ebp+arg_18]
.text$mn:00011DF2                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00011DF7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00011DFE                 lea     ecx, [ebp+arg_24]
.text$mn:00011E01                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00011E06                 mov     eax, [ebp+var_14]
.text$mn:00011E09                 mov     ecx, [ebp+var_C]
.text$mn:00011E0C                 mov     large fs:0, ecx
.text$mn:00011E13                 pop     ecx
.text$mn:00011E14                 mov     esp, ebp
.text$mn:00011E16                 pop     ebp
.text$mn:00011E17                 retn    30h
.text$mn:00011E17 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z endp
.text$mn:00011E17
.text$mn:00011E17 ; ---------------------------------------------------------------------------
.text$mn:00011E1A                 align 4
.text$mn:00011E1A _text$mn        ends
.text$mn:00011E1A
.text$x:00011E1C ; ===========================================================================
.text$x:00011E1C
.text$x:00011E1C ; Segment type: Pure code
.text$x:00011E1C ; Segment permissions: Read/Execute
.text$x:00011E1C _text$x         segment para public 'CODE' use32
.text$x:00011E1C                 assume cs:_text$x
.text$x:00011E1C                 ;org 11E1Ch
.text$x:00011E1C ; COMDAT (pick associative to section at 11BB8)
.text$x:00011E1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00011E1C
.text$x:00011E1C ; =============== S U B R O U T I N E =======================================
.text$x:00011E1C
.text$x:00011E1C
.text$x:00011E1C __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$0 proc near
.text$x:00011E1C                                         ; DATA XREF: .xdata$x:00012984o
.text$x:00011E1C                 lea     ecx, [ebp+2Ch]
.text$x:00011E1F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00011E1F __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$0 endp
.text$x:00011E1F
.text$x:00011E24
.text$x:00011E24 ; =============== S U B R O U T I N E =======================================
.text$x:00011E24
.text$x:00011E24
.text$x:00011E24 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$1 proc near
.text$x:00011E24                                         ; DATA XREF: .xdata$x:0001298Co
.text$x:00011E24                 lea     ecx, [ebp+20h]
.text$x:00011E27                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00011E27 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$1 endp
.text$x:00011E27
.text$x:00011E2C
.text$x:00011E2C ; =============== S U B R O U T I N E =======================================
.text$x:00011E2C
.text$x:00011E2C
.text$x:00011E2C __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$2 proc near
.text$x:00011E2C                                         ; DATA XREF: .xdata$x:00012994o
.text$x:00011E2C                 lea     ecx, [ebp+14h]
.text$x:00011E2F                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00011E2F __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$2 endp
.text$x:00011E2F
.text$x:00011E34
.text$x:00011E34 ; =============== S U B R O U T I N E =======================================
.text$x:00011E34
.text$x:00011E34
.text$x:00011E34 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$3 proc near
.text$x:00011E34                                         ; DATA XREF: .xdata$x:0001299Co
.text$x:00011E34                 lea     ecx, [ebp+8]
.text$x:00011E37                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00011E37 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$3 endp
.text$x:00011E37
.text$x:00011E3C
.text$x:00011E3C ; =============== S U B R O U T I N E =======================================
.text$x:00011E3C
.text$x:00011E3C
.text$x:00011E3C __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$4 proc near
.text$x:00011E3C                                         ; DATA XREF: .xdata$x:000129A4o
.text$x:00011E3C                 mov     ecx, [ebp-58h]
.text$x:00011E3F                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00011E3F __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$4 endp
.text$x:00011E3F
.text$x:00011E44
.text$x:00011E44 ; =============== S U B R O U T I N E =======================================
.text$x:00011E44
.text$x:00011E44
.text$x:00011E44 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$5 proc near
.text$x:00011E44                                         ; DATA XREF: .xdata$x:000129ACo
.text$x:00011E44                 mov     ecx, [ebp-80h]
.text$x:00011E47                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00011E47 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$5 endp
.text$x:00011E47
.text$x:00011E4C
.text$x:00011E4C ; =============== S U B R O U T I N E =======================================
.text$x:00011E4C
.text$x:00011E4C
.text$x:00011E4C __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$6 proc near
.text$x:00011E4C                                         ; DATA XREF: .xdata$x:000129B4o
.text$x:00011E4C                 lea     ecx, [ebp-0A0h]
.text$x:00011E52                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00011E52 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$6 endp
.text$x:00011E52
.text$x:00011E57
.text$x:00011E57 ; =============== S U B R O U T I N E =======================================
.text$x:00011E57
.text$x:00011E57
.text$x:00011E57 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$7 proc near
.text$x:00011E57                                         ; DATA XREF: .xdata$x:000129BCo
.text$x:00011E57                 mov     ecx, [ebp-90h]
.text$x:00011E5D                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00011E5D __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$7 endp
.text$x:00011E5D
.text$x:00011E62
.text$x:00011E62 ; =============== S U B R O U T I N E =======================================
.text$x:00011E62
.text$x:00011E62
.text$x:00011E62 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$8 proc near
.text$x:00011E62                                         ; DATA XREF: .xdata$x:000129C4o
.text$x:00011E62                 mov     ecx, [ebp-88h]
.text$x:00011E68                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00011E68 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$8 endp
.text$x:00011E68
.text$x:00011E6D
.text$x:00011E6D ; =============== S U B R O U T I N E =======================================
.text$x:00011E6D
.text$x:00011E6D
.text$x:00011E6D __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$9 proc near
.text$x:00011E6D                                         ; DATA XREF: .xdata$x:000129CCo
.text$x:00011E6D                 mov     ecx, [ebp-94h]
.text$x:00011E73                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00011E73 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$9 endp
.text$x:00011E73
.text$x:00011E78
.text$x:00011E78 ; =============== S U B R O U T I N E =======================================
.text$x:00011E78
.text$x:00011E78
.text$x:00011E78 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$10 proc near
.text$x:00011E78                                         ; DATA XREF: .xdata$x:000129D4o
.text$x:00011E78                 mov     ecx, [ebp-64h]
.text$x:00011E7B                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00011E7B __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$10 endp
.text$x:00011E7B
.text$x:00011E80
.text$x:00011E80 ; =============== S U B R O U T I N E =======================================
.text$x:00011E80
.text$x:00011E80
.text$x:00011E80 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$11 proc near
.text$x:00011E80                                         ; DATA XREF: .xdata$x:000129DCo
.text$x:00011E80                 lea     ecx, [ebp-0ACh]
.text$x:00011E86                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00011E86 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$11 endp
.text$x:00011E86
.text$x:00011E8B
.text$x:00011E8B ; =============== S U B R O U T I N E =======================================
.text$x:00011E8B
.text$x:00011E8B
.text$x:00011E8B __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$12 proc near
.text$x:00011E8B                                         ; DATA XREF: .xdata$x:000129E4o
.text$x:00011E8B                 mov     ecx, [ebp-74h]
.text$x:00011E8E                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00011E8E __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$12 endp
.text$x:00011E8E
.text$x:00011E93
.text$x:00011E93 ; =============== S U B R O U T I N E =======================================
.text$x:00011E93
.text$x:00011E93
.text$x:00011E93 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$13 proc near
.text$x:00011E93                                         ; DATA XREF: .xdata$x:000129ECo
.text$x:00011E93                 mov     ecx, [ebp-84h]
.text$x:00011E99                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00011E99 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$13 endp
.text$x:00011E99
.text$x:00011E9E
.text$x:00011E9E ; =============== S U B R O U T I N E =======================================
.text$x:00011E9E
.text$x:00011E9E
.text$x:00011E9E __ehhandler$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z proc near
.text$x:00011E9E                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:00011E9E
.text$x:00011E9E arg_4           = dword ptr  8
.text$x:00011E9E
.text$x:00011E9E                 mov     edx, [esp+arg_4]
.text$x:00011EA2                 lea     eax, [edx+0Ch]
.text$x:00011EA5                 mov     ecx, [edx-0A4h]
.text$x:00011EAB                 xor     ecx, eax
.text$x:00011EAD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00011EB2                 mov     eax, offset __ehfuncinfo$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z
.text$x:00011EB7                 jmp     ___CxxFrameHandler3
.text$x:00011EB7 __ehhandler$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z endp
.text$x:00011EB7
.text$x:00011EB7 _text$x         ends
.text$x:00011EB7
.text$mn:00011EBC ; ===========================================================================
.text$mn:00011EBC
.text$mn:00011EBC ; Segment type: Pure code
.text$mn:00011EBC ; Segment permissions: Read/Execute
.text$mn:00011EBC _text$mn        segment para public 'CODE' use32
.text$mn:00011EBC                 assume cs:_text$mn
.text$mn:00011EBC                 ;org 11EBCh
.text$mn:00011EBC ; COMDAT (pick any)
.text$mn:00011EBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011EBC
.text$mn:00011EBC ; =============== S U B R O U T I N E =======================================
.text$mn:00011EBC
.text$mn:00011EBC ; Attributes: bp-based frame
.text$mn:00011EBC
.text$mn:00011EBC ; public: struct std::_Wrap_alloc<class std::allocator<unsigned int>> __thiscall std::_Wrap_alloc<class std::allocator<unsigned int>>::select_on_container_copy_construction(void)const
.text$mn:00011EBC                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBE?AU12@XZ
.text$mn:00011EBC ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBE?AU12@XZ proc near
.text$mn:00011EBC                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(std::vector<uint,std::allocator<uint>> const &)+41p
.text$mn:00011EBC
.text$mn:00011EBC var_8           = dword ptr -8
.text$mn:00011EBC var_1           = byte ptr -1
.text$mn:00011EBC arg_0           = dword ptr  8
.text$mn:00011EBC
.text$mn:00011EBC                 push    ebp
.text$mn:00011EBD                 mov     ebp, esp
.text$mn:00011EBF                 sub     esp, 8
.text$mn:00011EC2                 mov     [ebp+var_8], ecx
.text$mn:00011EC5                 mov     eax, [ebp+var_8]
.text$mn:00011EC8                 push    eax
.text$mn:00011EC9                 lea     ecx, [ebp+var_1]
.text$mn:00011ECC                 push    ecx
.text$mn:00011ECD                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z ; std::allocator_traits<std::allocator<uint>>::select_on_container_copy_construction(std::allocator<uint> const &)
.text$mn:00011ED2                 add     esp, 8
.text$mn:00011ED5                 push    eax
.text$mn:00011ED6                 mov     ecx, [ebp+arg_0]
.text$mn:00011ED9                 call    ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::_Wrap_alloc<std::allocator<uint>>::_Wrap_alloc<std::allocator<uint>>(std::allocator<uint> const &)
.text$mn:00011EDE                 mov     eax, [ebp+arg_0]
.text$mn:00011EE1                 mov     esp, ebp
.text$mn:00011EE3                 pop     ebp
.text$mn:00011EE4                 retn    4
.text$mn:00011EE4 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBE?AU12@XZ endp
.text$mn:00011EE4
.text$mn:00011EE4 ; ---------------------------------------------------------------------------
.text$mn:00011EE7                 align 4
.text$mn:00011EE7 _text$mn        ends
.text$mn:00011EE7
.text$mn:00011EE8 ; ===========================================================================
.text$mn:00011EE8
.text$mn:00011EE8 ; Segment type: Pure code
.text$mn:00011EE8 ; Segment permissions: Read/Execute
.text$mn:00011EE8 _text$mn        segment para public 'CODE' use32
.text$mn:00011EE8                 assume cs:_text$mn
.text$mn:00011EE8                 ;org 11EE8h
.text$mn:00011EE8 ; COMDAT (pick any)
.text$mn:00011EE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011EE8
.text$mn:00011EE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00011EE8
.text$mn:00011EE8 ; Attributes: bp-based frame
.text$mn:00011EE8
.text$mn:00011EE8 ; public: struct std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>> __thiscall std::_Wrap_alloc<class std::allocator<struct sessionFileInfo>>::select_on_container_copy_construction(void)const
.text$mn:00011EE8                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AU12@XZ
.text$mn:00011EE8 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AU12@XZ proc near
.text$mn:00011EE8                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(std::vector<sessionFileInfo,std::allocator<sessionFileInfo>> const &)+41p
.text$mn:00011EE8
.text$mn:00011EE8 var_8           = dword ptr -8
.text$mn:00011EE8 var_1           = byte ptr -1
.text$mn:00011EE8 arg_0           = dword ptr  8
.text$mn:00011EE8
.text$mn:00011EE8                 push    ebp
.text$mn:00011EE9                 mov     ebp, esp
.text$mn:00011EEB                 sub     esp, 8
.text$mn:00011EEE                 mov     [ebp+var_8], ecx
.text$mn:00011EF1                 mov     eax, [ebp+var_8]
.text$mn:00011EF4                 push    eax
.text$mn:00011EF5                 lea     ecx, [ebp+var_1]
.text$mn:00011EF8                 push    ecx
.text$mn:00011EF9                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SA?AV?$allocator@UsessionFileInfo@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<sessionFileInfo>>::select_on_container_copy_construction(std::allocator<sessionFileInfo> const &)
.text$mn:00011EFE                 add     esp, 8
.text$mn:00011F01                 push    eax
.text$mn:00011F02                 mov     ecx, [ebp+arg_0]
.text$mn:00011F05                 call    ??0?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z ; std::_Wrap_alloc<std::allocator<sessionFileInfo>>::_Wrap_alloc<std::allocator<sessionFileInfo>>(std::allocator<sessionFileInfo> const &)
.text$mn:00011F0A                 mov     eax, [ebp+arg_0]
.text$mn:00011F0D                 mov     esp, ebp
.text$mn:00011F0F                 pop     ebp
.text$mn:00011F10                 retn    4
.text$mn:00011F10 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AU12@XZ endp
.text$mn:00011F10
.text$mn:00011F10 ; ---------------------------------------------------------------------------
.text$mn:00011F13                 align 4
.text$mn:00011F13 _text$mn        ends
.text$mn:00011F13
.text$mn:00011F14 ; ===========================================================================
.text$mn:00011F14
.text$mn:00011F14 ; Segment type: Pure code
.text$mn:00011F14 ; Segment permissions: Read/Execute
.text$mn:00011F14 _text$mn        segment para public 'CODE' use32
.text$mn:00011F14                 assume cs:_text$mn
.text$mn:00011F14                 ;org 11F14h
.text$mn:00011F14 ; COMDAT (pick any)
.text$mn:00011F14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011F14
.text$mn:00011F14 ; =============== S U B R O U T I N E =======================================
.text$mn:00011F14
.text$mn:00011F14 ; Attributes: bp-based frame
.text$mn:00011F14
.text$mn:00011F14 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::select_on_container_copy_construction(void)const
.text$mn:00011F14                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ
.text$mn:00011F14 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ proc near
.text$mn:00011F14                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Ap
.text$mn:00011F14
.text$mn:00011F14 var_8           = dword ptr -8
.text$mn:00011F14 var_1           = byte ptr -1
.text$mn:00011F14 arg_0           = dword ptr  8
.text$mn:00011F14
.text$mn:00011F14                 push    ebp
.text$mn:00011F15                 mov     ebp, esp
.text$mn:00011F17                 sub     esp, 8
.text$mn:00011F1A                 mov     [ebp+var_8], ecx
.text$mn:00011F1D                 mov     eax, [ebp+var_8]
.text$mn:00011F20                 push    eax
.text$mn:00011F21                 lea     ecx, [ebp+var_1]
.text$mn:00011F24                 push    ecx
.text$mn:00011F25                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ; std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)
.text$mn:00011F2A                 add     esp, 8
.text$mn:00011F2D                 push    eax
.text$mn:00011F2E                 mov     ecx, [ebp+arg_0]
.text$mn:00011F31                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(std::allocator<wchar_t> const &)
.text$mn:00011F36                 mov     eax, [ebp+arg_0]
.text$mn:00011F39                 mov     esp, ebp
.text$mn:00011F3B                 pop     ebp
.text$mn:00011F3C                 retn    4
.text$mn:00011F3C ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ endp
.text$mn:00011F3C
.text$mn:00011F3C ; ---------------------------------------------------------------------------
.text$mn:00011F3F                 align 10h
.text$mn:00011F3F _text$mn        ends
.text$mn:00011F3F
.text$mn:00011F40 ; ===========================================================================
.text$mn:00011F40
.text$mn:00011F40 ; Segment type: Pure code
.text$mn:00011F40 ; Segment permissions: Read/Execute
.text$mn:00011F40 _text$mn        segment para public 'CODE' use32
.text$mn:00011F40                 assume cs:_text$mn
.text$mn:00011F40                 ;org 11F40h
.text$mn:00011F40 ; COMDAT (pick any)
.text$mn:00011F40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011F40
.text$mn:00011F40 ; =============== S U B R O U T I N E =======================================
.text$mn:00011F40
.text$mn:00011F40 ; Attributes: bp-based frame
.text$mn:00011F40
.text$mn:00011F40 ; public: class std::allocator<unsigned int> __thiscall std::allocator<unsigned int>::select_on_container_copy_construction(void)const
.text$mn:00011F40                 public ?select_on_container_copy_construction@?$allocator@I@std@@QBE?AV12@XZ
.text$mn:00011F40 ?select_on_container_copy_construction@?$allocator@I@std@@QBE?AV12@XZ proc near
.text$mn:00011F40                                         ; CODE XREF: std::allocator_traits<std::allocator<uint>>::select_on_container_copy_construction(std::allocator<uint> const &)+Ap
.text$mn:00011F40
.text$mn:00011F40 var_4           = dword ptr -4
.text$mn:00011F40 arg_0           = dword ptr  8
.text$mn:00011F40
.text$mn:00011F40                 push    ebp
.text$mn:00011F41                 mov     ebp, esp
.text$mn:00011F43                 push    ecx
.text$mn:00011F44                 mov     [ebp+var_4], ecx
.text$mn:00011F47                 mov     eax, [ebp+var_4]
.text$mn:00011F4A                 push    eax
.text$mn:00011F4B                 mov     ecx, [ebp+arg_0]
.text$mn:00011F4E                 call    ??0?$allocator@I@std@@QAE@ABV01@@Z ; std::allocator<uint>::allocator<uint>(std::allocator<uint> const &)
.text$mn:00011F53                 mov     eax, [ebp+arg_0]
.text$mn:00011F56                 mov     esp, ebp
.text$mn:00011F58                 pop     ebp
.text$mn:00011F59                 retn    4
.text$mn:00011F59 ?select_on_container_copy_construction@?$allocator@I@std@@QBE?AV12@XZ endp
.text$mn:00011F59
.text$mn:00011F59 _text$mn        ends
.text$mn:00011F59
.text$mn:00011F5C ; ===========================================================================
.text$mn:00011F5C
.text$mn:00011F5C ; Segment type: Pure code
.text$mn:00011F5C ; Segment permissions: Read/Execute
.text$mn:00011F5C _text$mn        segment para public 'CODE' use32
.text$mn:00011F5C                 assume cs:_text$mn
.text$mn:00011F5C                 ;org 11F5Ch
.text$mn:00011F5C ; COMDAT (pick any)
.text$mn:00011F5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011F5C
.text$mn:00011F5C ; =============== S U B R O U T I N E =======================================
.text$mn:00011F5C
.text$mn:00011F5C ; Attributes: bp-based frame
.text$mn:00011F5C
.text$mn:00011F5C ; public: class std::allocator<struct sessionFileInfo> __thiscall std::allocator<struct sessionFileInfo>::select_on_container_copy_construction(void)const
.text$mn:00011F5C                 public ?select_on_container_copy_construction@?$allocator@UsessionFileInfo@@@std@@QBE?AV12@XZ
.text$mn:00011F5C ?select_on_container_copy_construction@?$allocator@UsessionFileInfo@@@std@@QBE?AV12@XZ proc near
.text$mn:00011F5C                                         ; CODE XREF: std::allocator_traits<std::allocator<sessionFileInfo>>::select_on_container_copy_construction(std::allocator<sessionFileInfo> const &)+Ap
.text$mn:00011F5C
.text$mn:00011F5C var_4           = dword ptr -4
.text$mn:00011F5C arg_0           = dword ptr  8
.text$mn:00011F5C
.text$mn:00011F5C                 push    ebp
.text$mn:00011F5D                 mov     ebp, esp
.text$mn:00011F5F                 push    ecx
.text$mn:00011F60                 mov     [ebp+var_4], ecx
.text$mn:00011F63                 mov     eax, [ebp+var_4]
.text$mn:00011F66                 push    eax
.text$mn:00011F67                 mov     ecx, [ebp+arg_0]
.text$mn:00011F6A                 call    ??0?$allocator@UsessionFileInfo@@@std@@QAE@ABV01@@Z ; std::allocator<sessionFileInfo>::allocator<sessionFileInfo>(std::allocator<sessionFileInfo> const &)
.text$mn:00011F6F                 mov     eax, [ebp+arg_0]
.text$mn:00011F72                 mov     esp, ebp
.text$mn:00011F74                 pop     ebp
.text$mn:00011F75                 retn    4
.text$mn:00011F75 ?select_on_container_copy_construction@?$allocator@UsessionFileInfo@@@std@@QBE?AV12@XZ endp
.text$mn:00011F75
.text$mn:00011F75 _text$mn        ends
.text$mn:00011F75
.text$mn:00011F78 ; ===========================================================================
.text$mn:00011F78
.text$mn:00011F78 ; Segment type: Pure code
.text$mn:00011F78 ; Segment permissions: Read/Execute
.text$mn:00011F78 _text$mn        segment para public 'CODE' use32
.text$mn:00011F78                 assume cs:_text$mn
.text$mn:00011F78                 ;org 11F78h
.text$mn:00011F78 ; COMDAT (pick any)
.text$mn:00011F78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011F78
.text$mn:00011F78 ; =============== S U B R O U T I N E =======================================
.text$mn:00011F78
.text$mn:00011F78 ; Attributes: bp-based frame
.text$mn:00011F78
.text$mn:00011F78 ; public: class std::allocator<wchar_t> __thiscall std::allocator<wchar_t>::select_on_container_copy_construction(void)const
.text$mn:00011F78                 public ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ
.text$mn:00011F78 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ proc near
.text$mn:00011F78                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)+Ap
.text$mn:00011F78
.text$mn:00011F78 var_4           = dword ptr -4
.text$mn:00011F78 arg_0           = dword ptr  8
.text$mn:00011F78
.text$mn:00011F78                 push    ebp
.text$mn:00011F79                 mov     ebp, esp
.text$mn:00011F7B                 push    ecx
.text$mn:00011F7C                 mov     [ebp+var_4], ecx
.text$mn:00011F7F                 mov     eax, [ebp+var_4]
.text$mn:00011F82                 push    eax
.text$mn:00011F83                 mov     ecx, [ebp+arg_0]
.text$mn:00011F86                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00011F8B                 mov     eax, [ebp+arg_0]
.text$mn:00011F8E                 mov     esp, ebp
.text$mn:00011F90                 pop     ebp
.text$mn:00011F91                 retn    4
.text$mn:00011F91 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ endp
.text$mn:00011F91
.text$mn:00011F91 _text$mn        ends
.text$mn:00011F91
.text$mn:00011F94 ; ===========================================================================
.text$mn:00011F94
.text$mn:00011F94 ; Segment type: Pure code
.text$mn:00011F94 ; Segment permissions: Read/Execute
.text$mn:00011F94 _text$mn        segment para public 'CODE' use32
.text$mn:00011F94                 assume cs:_text$mn
.text$mn:00011F94                 ;org 11F94h
.text$mn:00011F94 ; COMDAT (pick any)
.text$mn:00011F94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011F94
.text$mn:00011F94 ; =============== S U B R O U T I N E =======================================
.text$mn:00011F94
.text$mn:00011F94 ; Attributes: bp-based frame
.text$mn:00011F94
.text$mn:00011F94 ; public: static class std::allocator<unsigned int> __cdecl std::allocator_traits<class std::allocator<unsigned int>>::select_on_container_copy_construction(class std::allocator<unsigned int> const &)
.text$mn:00011F94                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z
.text$mn:00011F94 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z proc near
.text$mn:00011F94                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::select_on_container_copy_construction(void)+11p
.text$mn:00011F94
.text$mn:00011F94 arg_0           = dword ptr  8
.text$mn:00011F94 arg_4           = dword ptr  0Ch
.text$mn:00011F94
.text$mn:00011F94                 push    ebp
.text$mn:00011F95                 mov     ebp, esp
.text$mn:00011F97                 mov     eax, [ebp+arg_0]
.text$mn:00011F9A                 push    eax
.text$mn:00011F9B                 mov     ecx, [ebp+arg_4]
.text$mn:00011F9E                 call    ?select_on_container_copy_construction@?$allocator@I@std@@QBE?AV12@XZ ; std::allocator<uint>::select_on_container_copy_construction(void)
.text$mn:00011FA3                 mov     eax, [ebp+arg_0]
.text$mn:00011FA6                 pop     ebp
.text$mn:00011FA7                 retn
.text$mn:00011FA7 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z endp
.text$mn:00011FA7
.text$mn:00011FA7 _text$mn        ends
.text$mn:00011FA7
.text$mn:00011FA8 ; ===========================================================================
.text$mn:00011FA8
.text$mn:00011FA8 ; Segment type: Pure code
.text$mn:00011FA8 ; Segment permissions: Read/Execute
.text$mn:00011FA8 _text$mn        segment para public 'CODE' use32
.text$mn:00011FA8                 assume cs:_text$mn
.text$mn:00011FA8                 ;org 11FA8h
.text$mn:00011FA8 ; COMDAT (pick any)
.text$mn:00011FA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011FA8
.text$mn:00011FA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00011FA8
.text$mn:00011FA8 ; Attributes: bp-based frame
.text$mn:00011FA8
.text$mn:00011FA8 ; public: static class std::allocator<struct sessionFileInfo> __cdecl std::allocator_traits<class std::allocator<struct sessionFileInfo>>::select_on_container_copy_construction(class std::allocator<struct sessionFileInfo> const &)
.text$mn:00011FA8                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SA?AV?$allocator@UsessionFileInfo@@@2@ABV32@@Z
.text$mn:00011FA8 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SA?AV?$allocator@UsessionFileInfo@@@2@ABV32@@Z proc near
.text$mn:00011FA8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<sessionFileInfo>>::select_on_container_copy_construction(void)+11p
.text$mn:00011FA8
.text$mn:00011FA8 arg_0           = dword ptr  8
.text$mn:00011FA8 arg_4           = dword ptr  0Ch
.text$mn:00011FA8
.text$mn:00011FA8                 push    ebp
.text$mn:00011FA9                 mov     ebp, esp
.text$mn:00011FAB                 mov     eax, [ebp+arg_0]
.text$mn:00011FAE                 push    eax
.text$mn:00011FAF                 mov     ecx, [ebp+arg_4]
.text$mn:00011FB2                 call    ?select_on_container_copy_construction@?$allocator@UsessionFileInfo@@@std@@QBE?AV12@XZ ; std::allocator<sessionFileInfo>::select_on_container_copy_construction(void)
.text$mn:00011FB7                 mov     eax, [ebp+arg_0]
.text$mn:00011FBA                 pop     ebp
.text$mn:00011FBB                 retn
.text$mn:00011FBB ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UsessionFileInfo@@@std@@@std@@SA?AV?$allocator@UsessionFileInfo@@@2@ABV32@@Z endp
.text$mn:00011FBB
.text$mn:00011FBB _text$mn        ends
.text$mn:00011FBB
.text$mn:00011FBC ; ===========================================================================
.text$mn:00011FBC
.text$mn:00011FBC ; Segment type: Pure code
.text$mn:00011FBC ; Segment permissions: Read/Execute
.text$mn:00011FBC _text$mn        segment para public 'CODE' use32
.text$mn:00011FBC                 assume cs:_text$mn
.text$mn:00011FBC                 ;org 11FBCh
.text$mn:00011FBC ; COMDAT (pick any)
.text$mn:00011FBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011FBC
.text$mn:00011FBC ; =============== S U B R O U T I N E =======================================
.text$mn:00011FBC
.text$mn:00011FBC ; Attributes: bp-based frame
.text$mn:00011FBC
.text$mn:00011FBC ; public: static class std::allocator<wchar_t> __cdecl std::allocator_traits<class std::allocator<wchar_t>>::select_on_container_copy_construction(class std::allocator<wchar_t> const &)
.text$mn:00011FBC                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
.text$mn:00011FBC ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z proc near
.text$mn:00011FBC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+11p
.text$mn:00011FBC
.text$mn:00011FBC arg_0           = dword ptr  8
.text$mn:00011FBC arg_4           = dword ptr  0Ch
.text$mn:00011FBC
.text$mn:00011FBC                 push    ebp
.text$mn:00011FBD                 mov     ebp, esp
.text$mn:00011FBF                 mov     eax, [ebp+arg_0]
.text$mn:00011FC2                 push    eax
.text$mn:00011FC3                 mov     ecx, [ebp+arg_4]
.text$mn:00011FC6                 call    ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ ; std::allocator<wchar_t>::select_on_container_copy_construction(void)
.text$mn:00011FCB                 mov     eax, [ebp+arg_0]
.text$mn:00011FCE                 pop     ebp
.text$mn:00011FCF                 retn
.text$mn:00011FCF ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z endp
.text$mn:00011FCF
.text$mn:00011FCF _text$mn        ends
.text$mn:00011FCF
.text$mn:00011FD0 ; ===========================================================================
.text$mn:00011FD0
.text$mn:00011FD0 ; Segment type: Pure code
.text$mn:00011FD0 ; Segment permissions: Read/Execute
.text$mn:00011FD0 _text$mn        segment para public 'CODE' use32
.text$mn:00011FD0                 assume cs:_text$mn
.text$mn:00011FD0                 ;org 11FD0h
.text$mn:00011FD0 ; COMDAT (pick any)
.text$mn:00011FD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011FD0
.text$mn:00011FD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00011FD0
.text$mn:00011FD0 ; Attributes: bp-based frame
.text$mn:00011FD0
.text$mn:00011FD0 ; void __thiscall FileDialog::setDefFileName(FileDialog *this, const wchar_t *)
.text$mn:00011FD0                 public ?setDefFileName@FileDialog@@QAEXPB_W@Z
.text$mn:00011FD0 ?setDefFileName@FileDialog@@QAEXPB_W@Z proc near
.text$mn:00011FD0                                         ; CODE XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+F5p
.text$mn:00011FD0                                         ; Notepad_plus::fileRename(Buffer *)+127p
.text$mn:00011FD0
.text$mn:00011FD0 lpString1       = dword ptr -4
.text$mn:00011FD0 lpString2       = dword ptr  8
.text$mn:00011FD0
.text$mn:00011FD0                 push    ebp
.text$mn:00011FD1                 mov     ebp, esp
.text$mn:00011FD3                 push    ecx
.text$mn:00011FD4                 mov     [ebp+lpString1], ecx
.text$mn:00011FD7                 mov     eax, [ebp+lpString2]
.text$mn:00011FDA                 push    eax             ; lpString2
.text$mn:00011FDB                 mov     ecx, [ebp+lpString1]
.text$mn:00011FDE                 push    ecx             ; lpString1
.text$mn:00011FDF                 call    dword ptr ds:__imp__lstrcpyW@8 ; lstrcpyW(x,x)
.text$mn:00011FE5                 mov     esp, ebp
.text$mn:00011FE7                 pop     ebp
.text$mn:00011FE8                 retn    4
.text$mn:00011FE8 ?setDefFileName@FileDialog@@QAEXPB_W@Z endp
.text$mn:00011FE8
.text$mn:00011FE8 ; ---------------------------------------------------------------------------
.text$mn:00011FEB                 align 4
.text$mn:00011FEB _text$mn        ends
.text$mn:00011FEB
.text$mn:00011FEC ; ===========================================================================
.text$mn:00011FEC
.text$mn:00011FEC ; Segment type: Pure code
.text$mn:00011FEC ; Segment permissions: Read/Execute
.text$mn:00011FEC _text$mn        segment para public 'CODE' use32
.text$mn:00011FEC                 assume cs:_text$mn
.text$mn:00011FEC                 ;org 11FECh
.text$mn:00011FEC ; COMDAT (pick any)
.text$mn:00011FEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00011FEC
.text$mn:00011FEC ; =============== S U B R O U T I N E =======================================
.text$mn:00011FEC
.text$mn:00011FEC ; Attributes: bp-based frame
.text$mn:00011FEC
.text$mn:00011FEC ; void __thiscall Buffer::setDirty(Buffer *this, bool)
.text$mn:00011FEC                 public ?setDirty@Buffer@@QAEX_N@Z
.text$mn:00011FEC ?setDirty@Buffer@@QAEX_N@Z proc near    ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+492p
.text$mn:00011FEC                                         ; Notepad_plus::loadSession(Session &,bool)+AD5p
.text$mn:00011FEC
.text$mn:00011FEC var_4           = dword ptr -4
.text$mn:00011FEC arg_0           = byte ptr  8
.text$mn:00011FEC
.text$mn:00011FEC                 push    ebp
.text$mn:00011FED                 mov     ebp, esp
.text$mn:00011FEF                 push    ecx
.text$mn:00011FF0                 mov     [ebp+var_4], ecx
.text$mn:00011FF3                 mov     eax, [ebp+var_4]
.text$mn:00011FF6                 mov     cl, [ebp+arg_0]
.text$mn:00011FF9                 mov     [eax+34h], cl
.text$mn:00011FFC                 push    2               ; int
.text$mn:00011FFE                 mov     ecx, [ebp+var_4] ; this
.text$mn:00012001                 call    ?doNotify@Buffer@@AAEXH@Z ; Buffer::doNotify(int)
.text$mn:00012006                 mov     esp, ebp
.text$mn:00012008                 pop     ebp
.text$mn:00012009                 retn    4
.text$mn:00012009 ?setDirty@Buffer@@QAEX_N@Z endp
.text$mn:00012009
.text$mn:00012009 _text$mn        ends
.text$mn:00012009
.text$mn:0001200C ; ===========================================================================
.text$mn:0001200C
.text$mn:0001200C ; Segment type: Pure code
.text$mn:0001200C ; Segment permissions: Read/Execute
.text$mn:0001200C _text$mn        segment para public 'CODE' use32
.text$mn:0001200C                 assume cs:_text$mn
.text$mn:0001200C                 ;org 1200Ch
.text$mn:0001200C ; COMDAT (pick any)
.text$mn:0001200C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0001200C
.text$mn:0001200C ; =============== S U B R O U T I N E =======================================
.text$mn:0001200C
.text$mn:0001200C ; Attributes: bp-based frame
.text$mn:0001200C
.text$mn:0001200C ; void __thiscall Buffer::setEncoding(Buffer *this, int)
.text$mn:0001200C                 public ?setEncoding@Buffer@@QAEXH@Z
.text$mn:0001200C ?setEncoding@Buffer@@QAEXH@Z proc near  ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+6DFp
.text$mn:0001200C                                         ; Notepad_plus::loadSession(Session &,bool)+435p ...
.text$mn:0001200C
.text$mn:0001200C var_4           = dword ptr -4
.text$mn:0001200C arg_0           = dword ptr  8
.text$mn:0001200C
.text$mn:0001200C                 push    ebp
.text$mn:0001200D                 mov     ebp, esp
.text$mn:0001200F                 push    ecx
.text$mn:00012010                 mov     [ebp+var_4], ecx
.text$mn:00012013                 mov     eax, [ebp+var_4]
.text$mn:00012016                 mov     ecx, [ebp+arg_0]
.text$mn:00012019                 mov     [eax+40h], ecx
.text$mn:0001201C                 push    0Ah             ; int
.text$mn:0001201E                 mov     ecx, [ebp+var_4] ; this
.text$mn:00012021                 call    ?doNotify@Buffer@@AAEXH@Z ; Buffer::doNotify(int)
.text$mn:00012026                 mov     esp, ebp
.text$mn:00012028                 pop     ebp
.text$mn:00012029                 retn    4
.text$mn:00012029 ?setEncoding@Buffer@@QAEXH@Z endp
.text$mn:00012029
.text$mn:00012029 _text$mn        ends
.text$mn:00012029
.text$mn:0001202C ; ===========================================================================
.text$mn:0001202C
.text$mn:0001202C ; Segment type: Pure code
.text$mn:0001202C ; Segment permissions: Read/Execute
.text$mn:0001202C _text$mn        segment para public 'CODE' use32
.text$mn:0001202C                 assume cs:_text$mn
.text$mn:0001202C                 ;org 1202Ch
.text$mn:0001202C ; COMDAT (pick any)
.text$mn:0001202C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0001202C
.text$mn:0001202C ; =============== S U B R O U T I N E =======================================
.text$mn:0001202C
.text$mn:0001202C ; Attributes: bp-based frame
.text$mn:0001202C
.text$mn:0001202C ; void __thiscall FileDialog::setExtIndex(FileDialog *this, int)
.text$mn:0001202C                 public ?setExtIndex@FileDialog@@QAEXH@Z
.text$mn:0001202C ?setExtIndex@FileDialog@@QAEXH@Z proc near
.text$mn:0001202C                                         ; CODE XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+10Ap
.text$mn:0001202C
.text$mn:0001202C var_4           = dword ptr -4
.text$mn:0001202C arg_0           = dword ptr  8
.text$mn:0001202C
.text$mn:0001202C                 push    ebp
.text$mn:0001202D                 mov     ebp, esp
.text$mn:0001202F                 push    ecx
.text$mn:00012030                 mov     [ebp+var_4], ecx
.text$mn:00012033                 mov     eax, [ebp+var_4]
.text$mn:00012036                 mov     ecx, [ebp+arg_0]
.text$mn:00012039                 mov     [eax+10B8h], ecx
.text$mn:0001203F                 mov     esp, ebp
.text$mn:00012041                 pop     ebp
.text$mn:00012042                 retn    4
.text$mn:00012042 ?setExtIndex@FileDialog@@QAEXH@Z endp
.text$mn:00012042
.text$mn:00012042 ; ---------------------------------------------------------------------------
.text$mn:00012045                 align 4
.text$mn:00012045 _text$mn        ends
.text$mn:00012045
.text$mn:00012048 ; ===========================================================================
.text$mn:00012048
.text$mn:00012048 ; Segment type: Pure code
.text$mn:00012048 ; Segment permissions: Read/Execute
.text$mn:00012048 _text$mn        segment para public 'CODE' use32
.text$mn:00012048                 assume cs:_text$mn
.text$mn:00012048                 ;org 12048h
.text$mn:00012048 ; COMDAT (pick any)
.text$mn:00012048                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00012048
.text$mn:00012048 ; =============== S U B R O U T I N E =======================================
.text$mn:00012048
.text$mn:00012048 ; Attributes: bp-based frame
.text$mn:00012048
.text$mn:00012048 ; public: void __thiscall Buffer::setFormat(enum  formatType)
.text$mn:00012048                 public ?setFormat@Buffer@@QAEXW4formatType@@@Z
.text$mn:00012048 ?setFormat@Buffer@@QAEXW4formatType@@@Z proc near
.text$mn:00012048                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+6F3p
.text$mn:00012048
.text$mn:00012048 var_4           = dword ptr -4
.text$mn:00012048 arg_0           = dword ptr  8
.text$mn:00012048
.text$mn:00012048                 push    ebp
.text$mn:00012049                 mov     ebp, esp
.text$mn:0001204B                 push    ecx
.text$mn:0001204C                 mov     [ebp+var_4], ecx
.text$mn:0001204F                 mov     eax, [ebp+var_4]
.text$mn:00012052                 mov     ecx, [ebp+arg_0]
.text$mn:00012055                 mov     [eax+38h], ecx
.text$mn:00012058                 push    4               ; int
.text$mn:0001205A                 mov     ecx, [ebp+var_4] ; this
.text$mn:0001205D                 call    ?doNotify@Buffer@@AAEXH@Z ; Buffer::doNotify(int)
.text$mn:00012062                 mov     esp, ebp
.text$mn:00012064                 pop     ebp
.text$mn:00012065                 retn    4
.text$mn:00012065 ?setFormat@Buffer@@QAEXW4formatType@@@Z endp
.text$mn:00012065
.text$mn:00012065 _text$mn        ends
.text$mn:00012065
.text$mn:00012068 ; ===========================================================================
.text$mn:00012068
.text$mn:00012068 ; Segment type: Pure code
.text$mn:00012068 ; Segment permissions: Read/Execute
.text$mn:00012068 _text$mn        segment para public 'CODE' use32
.text$mn:00012068                 assume cs:_text$mn
.text$mn:00012068                 ;org 12068h
.text$mn:00012068 ; COMDAT (pick any)
.text$mn:00012068                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00012068
.text$mn:00012068 ; =============== S U B R O U T I N E =======================================
.text$mn:00012068
.text$mn:00012068 ; Attributes: bp-based frame
.text$mn:00012068
.text$mn:00012068 ; void __thiscall Buffer::setLoadedDirty(Buffer *this, bool)
.text$mn:00012068                 public ?setLoadedDirty@Buffer@@QAEX_N@Z
.text$mn:00012068 ?setLoadedDirty@Buffer@@QAEX_N@Z proc near
.text$mn:00012068                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+637p
.text$mn:00012068
.text$mn:00012068 var_4           = dword ptr -4
.text$mn:00012068 arg_0           = byte ptr  8
.text$mn:00012068
.text$mn:00012068                 push    ebp
.text$mn:00012069                 mov     ebp, esp
.text$mn:0001206B                 push    ecx
.text$mn:0001206C                 mov     [ebp+var_4], ecx
.text$mn:0001206F                 mov     eax, [ebp+var_4]
.text$mn:00012072                 mov     cl, [ebp+arg_0]
.text$mn:00012075                 mov     [eax+0D1h], cl
.text$mn:0001207B                 mov     esp, ebp
.text$mn:0001207D                 pop     ebp
.text$mn:0001207E                 retn    4
.text$mn:0001207E ?setLoadedDirty@Buffer@@QAEX_N@Z endp
.text$mn:0001207E
.text$mn:0001207E ; ---------------------------------------------------------------------------
.text$mn:00012081                 align 4
.text$mn:00012081 _text$mn        ends
.text$mn:00012081
.text$mn:00012084 ; ===========================================================================
.text$mn:00012084
.text$mn:00012084 ; Segment type: Pure code
.text$mn:00012084 ; Segment permissions: Read/Execute
.text$mn:00012084 _text$mn        segment para public 'CODE' use32
.text$mn:00012084                 assume cs:_text$mn
.text$mn:00012084                 ;org 12084h
.text$mn:00012084 ; COMDAT (pick any)
.text$mn:00012084                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00012084
.text$mn:00012084 ; =============== S U B R O U T I N E =======================================
.text$mn:00012084
.text$mn:00012084 ; Attributes: bp-based frame
.text$mn:00012084
.text$mn:00012084 ; public: void __thiscall Buffer::setUnicodeMode(enum  UniMode)
.text$mn:00012084                 public ?setUnicodeMode@Buffer@@QAEXW4UniMode@@@Z
.text$mn:00012084 ?setUnicodeMode@Buffer@@QAEXW4UniMode@@@Z proc near
.text$mn:00012084                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+708p
.text$mn:00012084
.text$mn:00012084 var_4           = dword ptr -4
.text$mn:00012084 arg_0           = dword ptr  8
.text$mn:00012084
.text$mn:00012084                 push    ebp
.text$mn:00012085                 mov     ebp, esp
.text$mn:00012087                 push    ecx
.text$mn:00012088                 mov     [ebp+var_4], ecx
.text$mn:0001208B                 mov     eax, [ebp+var_4]
.text$mn:0001208E                 mov     ecx, [ebp+arg_0]
.text$mn:00012091                 mov     [eax+3Ch], ecx
.text$mn:00012094                 push    0Ah             ; int
.text$mn:00012096                 mov     ecx, [ebp+var_4] ; this
.text$mn:00012099                 call    ?doNotify@Buffer@@AAEXH@Z ; Buffer::doNotify(int)
.text$mn:0001209E                 mov     esp, ebp
.text$mn:000120A0                 pop     ebp
.text$mn:000120A1                 retn    4
.text$mn:000120A1 ?setUnicodeMode@Buffer@@QAEXW4UniMode@@@Z endp
.text$mn:000120A1
.text$mn:000120A1 _text$mn        ends
.text$mn:000120A1
.text$mn:000120A4 ; ===========================================================================
.text$mn:000120A4
.text$mn:000120A4 ; Segment type: Pure code
.text$mn:000120A4 ; Segment permissions: Read/Execute
.text$mn:000120A4 _text$mn        segment para public 'CODE' use32
.text$mn:000120A4                 assume cs:_text$mn
.text$mn:000120A4                 ;org 120A4h
.text$mn:000120A4 ; COMDAT (pick any)
.text$mn:000120A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000120A4
.text$mn:000120A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000120A4
.text$mn:000120A4 ; Attributes: bp-based frame
.text$mn:000120A4
.text$mn:000120A4 ; void __thiscall Buffer::setUserReadOnly(Buffer *this, bool)
.text$mn:000120A4                 public ?setUserReadOnly@Buffer@@QAEX_N@Z
.text$mn:000120A4 ?setUserReadOnly@Buffer@@QAEX_N@Z proc near
.text$mn:000120A4                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+6A6p
.text$mn:000120A4
.text$mn:000120A4 var_4           = dword ptr -4
.text$mn:000120A4 arg_0           = byte ptr  8
.text$mn:000120A4
.text$mn:000120A4                 push    ebp
.text$mn:000120A5                 mov     ebp, esp
.text$mn:000120A7                 push    ecx
.text$mn:000120A8                 mov     [ebp+var_4], ecx
.text$mn:000120AB                 mov     eax, [ebp+var_4]
.text$mn:000120AE                 mov     cl, [ebp+arg_0]
.text$mn:000120B1                 mov     [eax+44h], cl
.text$mn:000120B4                 push    10h             ; int
.text$mn:000120B6                 mov     ecx, [ebp+var_4] ; this
.text$mn:000120B9                 call    ?doNotify@Buffer@@AAEXH@Z ; Buffer::doNotify(int)
.text$mn:000120BE                 mov     esp, ebp
.text$mn:000120C0                 pop     ebp
.text$mn:000120C1                 retn    4
.text$mn:000120C1 ?setUserReadOnly@Buffer@@QAEX_N@Z endp
.text$mn:000120C1
.text$mn:000120C1 _text$mn        ends
.text$mn:000120C1
.text$mn:000120C4 ; ===========================================================================
.text$mn:000120C4
.text$mn:000120C4 ; Segment type: Pure code
.text$mn:000120C4 ; Segment permissions: Read/Execute
.text$mn:000120C4 _text$mn        segment para public 'CODE' use32
.text$mn:000120C4                 assume cs:_text$mn
.text$mn:000120C4                 ;org 120C4h
.text$mn:000120C4 ; COMDAT (pick any)
.text$mn:000120C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000120C4
.text$mn:000120C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000120C4
.text$mn:000120C4 ; Attributes: bp-based frame
.text$mn:000120C4
.text$mn:000120C4 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:000120C4                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000120C4 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000120C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:000120C4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:000120C4
.text$mn:000120C4 var_4           = dword ptr -4
.text$mn:000120C4
.text$mn:000120C4                 push    ebp
.text$mn:000120C5                 mov     ebp, esp
.text$mn:000120C7                 push    ecx
.text$mn:000120C8                 mov     [ebp+var_4], ecx
.text$mn:000120CB                 mov     eax, [ebp+var_4]
.text$mn:000120CE                 mov     eax, [eax+14h]
.text$mn:000120D1                 mov     esp, ebp
.text$mn:000120D3                 pop     ebp
.text$mn:000120D4                 retn
.text$mn:000120D4 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:000120D4
.text$mn:000120D4 ; ---------------------------------------------------------------------------
.text$mn:000120D5                 align 4
.text$mn:000120D5 _text$mn        ends
.text$mn:000120D5
.text$mn:000120D8 ; ===========================================================================
.text$mn:000120D8
.text$mn:000120D8 ; Segment type: Pure code
.text$mn:000120D8 ; Segment permissions: Read/Execute
.text$mn:000120D8 _text$mn        segment para public 'CODE' use32
.text$mn:000120D8                 assume cs:_text$mn
.text$mn:000120D8                 ;org 120D8h
.text$mn:000120D8 ; COMDAT (pick any)
.text$mn:000120D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000120D8
.text$mn:000120D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000120D8
.text$mn:000120D8 ; Attributes: bp-based frame
.text$mn:000120D8
.text$mn:000120D8 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:000120D8                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:000120D8 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:000120D8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:000120D8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p ...
.text$mn:000120D8
.text$mn:000120D8 var_4           = dword ptr -4
.text$mn:000120D8
.text$mn:000120D8                 push    ebp
.text$mn:000120D9                 mov     ebp, esp
.text$mn:000120DB                 push    ecx
.text$mn:000120DC                 mov     [ebp+var_4], ecx
.text$mn:000120DF                 mov     eax, [ebp+var_4]
.text$mn:000120E2                 mov     eax, [eax+14h]
.text$mn:000120E5                 mov     esp, ebp
.text$mn:000120E7                 pop     ebp
.text$mn:000120E8                 retn
.text$mn:000120E8 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:000120E8
.text$mn:000120E8 ; ---------------------------------------------------------------------------
.text$mn:000120E9                 align 4
.text$mn:000120E9 _text$mn        ends
.text$mn:000120E9
.text$mn:000120EC ; ===========================================================================
.text$mn:000120EC
.text$mn:000120EC ; Segment type: Pure code
.text$mn:000120EC ; Segment permissions: Read/Execute
.text$mn:000120EC _text$mn        segment para public 'CODE' use32
.text$mn:000120EC                 assume cs:_text$mn
.text$mn:000120EC                 ;org 120ECh
.text$mn:000120EC ; COMDAT (pick any)
.text$mn:000120EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000120EC
.text$mn:000120EC ; =============== S U B R O U T I N E =======================================
.text$mn:000120EC
.text$mn:000120EC ; Attributes: bp-based frame
.text$mn:000120EC
.text$mn:000120EC ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::size(void)const
.text$mn:000120EC                 public ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:000120EC ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:000120EC                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+A9p
.text$mn:000120EC                                         ; std::vector<int,std::allocator<int>>::_Reserve(uint)+22p ...
.text$mn:000120EC
.text$mn:000120EC var_4           = dword ptr -4
.text$mn:000120EC
.text$mn:000120EC                 push    ebp
.text$mn:000120ED                 mov     ebp, esp
.text$mn:000120EF                 push    ecx
.text$mn:000120F0                 mov     [ebp+var_4], ecx
.text$mn:000120F3                 mov     eax, [ebp+var_4]
.text$mn:000120F6                 mov     ecx, [ebp+var_4]
.text$mn:000120F9                 mov     eax, [eax+8]
.text$mn:000120FC                 sub     eax, [ecx+4]
.text$mn:000120FF                 sar     eax, 2
.text$mn:00012102                 mov     esp, ebp
.text$mn:00012104                 pop     ebp
.text$mn:00012105                 retn
.text$mn:00012105 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:00012105
.text$mn:00012105 ; ---------------------------------------------------------------------------
.text$mn:00012106                 align 4
.text$mn:00012106 _text$mn        ends
.text$mn:00012106
.text$mn:00012108 ; ===========================================================================
.text$mn:00012108
.text$mn:00012108 ; Segment type: Pure code
.text$mn:00012108 ; Segment permissions: Read/Execute
.text$mn:00012108 _text$mn        segment para public 'CODE' use32
.text$mn:00012108                 assume cs:_text$mn
.text$mn:00012108                 ;org 12108h
.text$mn:00012108 ; COMDAT (pick any)
.text$mn:00012108                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00012108
.text$mn:00012108 ; =============== S U B R O U T I N E =======================================
.text$mn:00012108
.text$mn:00012108 ; Attributes: bp-based frame
.text$mn:00012108
.text$mn:00012108 ; public: unsigned int __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::size(void)const
.text$mn:00012108                 public ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
.text$mn:00012108 ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ proc near
.text$mn:00012108                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+390p
.text$mn:00012108                                         ; Notepad_plus::loadSession(Session &,bool)+4EDp ...
.text$mn:00012108
.text$mn:00012108 var_4           = dword ptr -4
.text$mn:00012108
.text$mn:00012108                 push    ebp
.text$mn:00012109                 mov     ebp, esp
.text$mn:0001210B                 push    ecx
.text$mn:0001210C                 mov     [ebp+var_4], ecx
.text$mn:0001210F                 mov     eax, [ebp+var_4]
.text$mn:00012112                 mov     ecx, [ebp+var_4]
.text$mn:00012115                 mov     eax, [eax+8]
.text$mn:00012118                 sub     eax, [ecx+4]
.text$mn:0001211B                 sar     eax, 2
.text$mn:0001211E                 mov     esp, ebp
.text$mn:00012120                 pop     ebp
.text$mn:00012121                 retn
.text$mn:00012121 ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ endp
.text$mn:00012121
.text$mn:00012121 ; ---------------------------------------------------------------------------
.text$mn:00012122                 align 4
.text$mn:00012122 _text$mn        ends
.text$mn:00012122
.text$mn:00012124 ; ===========================================================================
.text$mn:00012124
.text$mn:00012124 ; Segment type: Pure code
.text$mn:00012124 ; Segment permissions: Read/Execute
.text$mn:00012124 _text$mn        segment para public 'CODE' use32
.text$mn:00012124                 assume cs:_text$mn
.text$mn:00012124                 ;org 12124h
.text$mn:00012124 ; COMDAT (pick any)
.text$mn:00012124                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00012124
.text$mn:00012124 ; =============== S U B R O U T I N E =======================================
.text$mn:00012124
.text$mn:00012124 ; Attributes: bp-based frame
.text$mn:00012124
.text$mn:00012124 ; public: unsigned int __thiscall std::vector<struct LangMenuItem, class std::allocator<struct LangMenuItem>>::size(void)const
.text$mn:00012124                 public ?size@?$vector@ULangMenuItem@@V?$allocator@ULangMenuItem@@@std@@@std@@QBEIXZ
.text$mn:00012124 ?size@?$vector@ULangMenuItem@@V?$allocator@ULangMenuItem@@@std@@@std@@QBEIXZ proc near
.text$mn:00012124                                         ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+B0p
.text$mn:00012124                                         ; std::vector<LangMenuItem,std::allocator<LangMenuItem>>::operator[](uint)+Ap
.text$mn:00012124
.text$mn:00012124 var_4           = dword ptr -4
.text$mn:00012124
.text$mn:00012124                 push    ebp
.text$mn:00012125                 mov     ebp, esp
.text$mn:00012127                 push    ecx
.text$mn:00012128                 mov     [ebp+var_4], ecx
.text$mn:0001212B                 mov     eax, [ebp+var_4]
.text$mn:0001212E                 mov     ecx, [ebp+var_4]
.text$mn:00012131                 mov     eax, [eax+8]
.text$mn:00012134                 sub     eax, [ecx+4]
.text$mn:00012137                 cdq
.text$mn:00012138                 mov     ecx, 24h ; '$'
.text$mn:0001213D                 idiv    ecx
.text$mn:0001213F                 mov     esp, ebp
.text$mn:00012141                 pop     ebp
.text$mn:00012142                 retn
.text$mn:00012142 ?size@?$vector@ULangMenuItem@@V?$allocator@ULangMenuItem@@@std@@@std@@QBEIXZ endp
.text$mn:00012142
.text$mn:00012142 ; ---------------------------------------------------------------------------
.text$mn:00012143                 align 4
.text$mn:00012143 _text$mn        ends
.text$mn:00012143
.text$mn:00012144 ; ===========================================================================
.text$mn:00012144
.text$mn:00012144 ; Segment type: Pure code
.text$mn:00012144 ; Segment permissions: Read/Execute
.text$mn:00012144 _text$mn        segment para public 'CODE' use32
.text$mn:00012144                 assume cs:_text$mn
.text$mn:00012144                 ;org 12144h
.text$mn:00012144 ; COMDAT (pick any)
.text$mn:00012144                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00012144
.text$mn:00012144 ; =============== S U B R O U T I N E =======================================
.text$mn:00012144
.text$mn:00012144 ; Attributes: bp-based frame
.text$mn:00012144
.text$mn:00012144 ; public: unsigned int __thiscall std::vector<struct sessionFileInfo, class std::allocator<struct sessionFileInfo>>::size(void)const
.text$mn:00012144                 public ?size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ
.text$mn:00012144 ?size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:00012144                                         ; CODE XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::vector<sessionFileInfo,std::allocator<sessionFileInfo>>(std::vector<sessionFileInfo,std::allocator<sessionFileInfo>> const &)+59p
.text$mn:00012144                                         ; std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)+Ap ...
.text$mn:00012144
.text$mn:00012144 var_4           = dword ptr -4
.text$mn:00012144
.text$mn:00012144                 push    ebp
.text$mn:00012145                 mov     ebp, esp
.text$mn:00012147                 push    ecx
.text$mn:00012148                 mov     [ebp+var_4], ecx
.text$mn:0001214B                 mov     eax, [ebp+var_4]
.text$mn:0001214E                 mov     ecx, [ebp+var_4]
.text$mn:00012151                 mov     eax, [eax+8]
.text$mn:00012154                 sub     eax, [ecx+4]
.text$mn:00012157                 cdq
.text$mn:00012158                 mov     ecx, 98h ; 'ÿ'
.text$mn:0001215D                 idiv    ecx
.text$mn:0001215F                 mov     esp, ebp
.text$mn:00012161                 pop     ebp
.text$mn:00012162                 retn
.text$mn:00012162 ?size@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBEIXZ endp
.text$mn:00012162
.text$mn:00012162 ; ---------------------------------------------------------------------------
.text$mn:00012163                 align 4
.text$mn:00012163 _text$mn        ends
.text$mn:00012163
.text$mn:00012164 ; ===========================================================================
.text$mn:00012164
.text$mn:00012164 ; Segment type: Pure code
.text$mn:00012164 ; Segment permissions: Read/Execute
.text$mn:00012164 _text$mn        segment para public 'CODE' use32
.text$mn:00012164                 assume cs:_text$mn
.text$mn:00012164                 ;org 12164h
.text$mn:00012164 ; COMDAT (pick any)
.text$mn:00012164                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00012164
.text$mn:00012164 ; =============== S U B R O U T I N E =======================================
.text$mn:00012164
.text$mn:00012164 ; Attributes: bp-based frame
.text$mn:00012164
.text$mn:00012164 ; public: unsigned int __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::size(void)const
.text$mn:00012164                 public ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ
.text$mn:00012164 ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ proc near
.text$mn:00012164                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+A31p
.text$mn:00012164                                         ; Notepad_plus::fileOpen(void)+C2p ...
.text$mn:00012164
.text$mn:00012164 var_4           = dword ptr -4
.text$mn:00012164
.text$mn:00012164                 push    ebp
.text$mn:00012165                 mov     ebp, esp
.text$mn:00012167                 push    ecx
.text$mn:00012168                 mov     [ebp+var_4], ecx
.text$mn:0001216B                 mov     eax, [ebp+var_4]
.text$mn:0001216E                 mov     ecx, [ebp+var_4]
.text$mn:00012171                 mov     eax, [eax+8]
.text$mn:00012174                 sub     eax, [ecx+4]
.text$mn:00012177                 cdq
.text$mn:00012178                 mov     ecx, 1Ch
.text$mn:0001217D                 idiv    ecx
.text$mn:0001217F                 mov     esp, ebp
.text$mn:00012181                 pop     ebp
.text$mn:00012182                 retn
.text$mn:00012182 ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ endp
.text$mn:00012182
.text$mn:00012182 ; ---------------------------------------------------------------------------
.text$mn:00012183                 align 4
.text$mn:00012183 _text$mn        ends
.text$mn:00012183
.text$mn:00012184 ; ===========================================================================
.text$mn:00012184
.text$mn:00012184 ; Segment type: Pure code
.text$mn:00012184 ; Segment permissions: Read/Execute
.text$mn:00012184 _text$mn        segment para public 'CODE' use32
.text$mn:00012184                 assume cs:_text$mn
.text$mn:00012184                 ;org 12184h
.text$mn:00012184 ; COMDAT (pick any)
.text$mn:00012184                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00012184
.text$mn:00012184 ; =============== S U B R O U T I N E =======================================
.text$mn:00012184
.text$mn:00012184 ; Attributes: bp-based frame
.text$mn:00012184
.text$mn:00012184 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::substr(unsigned int, unsigned int)const
.text$mn:00012184                 public ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z
.text$mn:00012184 ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z proc near
.text$mn:00012184                                         ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+239p
.text$mn:00012184
.text$mn:00012184 var_18          = dword ptr -18h
.text$mn:00012184 var_14          = dword ptr -14h
.text$mn:00012184 var_D           = byte ptr -0Dh
.text$mn:00012184 var_C           = dword ptr -0Ch
.text$mn:00012184 var_4           = dword ptr -4
.text$mn:00012184 arg_0           = dword ptr  8
.text$mn:00012184 arg_4           = dword ptr  0Ch
.text$mn:00012184 arg_8           = dword ptr  10h
.text$mn:00012184
.text$mn:00012184                 push    ebp
.text$mn:00012185                 mov     ebp, esp
.text$mn:00012187                 push    0FFFFFFFFh
.text$mn:00012189                 push    offset __ehhandler$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z
.text$mn:0001218E                 mov     eax, large fs:0
.text$mn:00012194                 push    eax
.text$mn:00012195                 sub     esp, 0Ch
.text$mn:00012198                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0001219D                 xor     eax, ebp
.text$mn:0001219F                 push    eax
.text$mn:000121A0                 lea     eax, [ebp+var_C]
.text$mn:000121A3                 mov     large fs:0, eax
.text$mn:000121A9                 mov     [ebp+var_14], ecx
.text$mn:000121AC                 mov     [ebp+var_18], 0
.text$mn:000121B3                 lea     eax, [ebp+var_D]
.text$mn:000121B6                 push    eax
.text$mn:000121B7                 mov     ecx, [ebp+var_14]
.text$mn:000121BA                 call    ?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::get_allocator(void)
.text$mn:000121BF                 push    eax
.text$mn:000121C0                 mov     ecx, [ebp+arg_8]
.text$mn:000121C3                 push    ecx
.text$mn:000121C4                 mov     edx, [ebp+arg_4]
.text$mn:000121C7                 push    edx
.text$mn:000121C8                 mov     eax, [ebp+var_14]
.text$mn:000121CB                 push    eax
.text$mn:000121CC                 mov     ecx, [ebp+arg_0]
.text$mn:000121CF                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint,std::allocator<wchar_t> const &)
.text$mn:000121D4                 mov     [ebp+var_4], 0
.text$mn:000121DB                 mov     ecx, [ebp+var_18]
.text$mn:000121DE                 or      ecx, 1
.text$mn:000121E1                 mov     [ebp+var_18], ecx
.text$mn:000121E4                 mov     eax, [ebp+arg_0]
.text$mn:000121E7                 mov     ecx, [ebp+var_C]
.text$mn:000121EA                 mov     large fs:0, ecx
.text$mn:000121F1                 pop     ecx
.text$mn:000121F2                 mov     esp, ebp
.text$mn:000121F4                 pop     ebp
.text$mn:000121F5                 retn    0Ch
.text$mn:000121F5 ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z endp
.text$mn:000121F5
.text$mn:000121F5 _text$mn        ends
.text$mn:000121F5
.text$x:000121F8 ; ===========================================================================
.text$x:000121F8
.text$x:000121F8 ; Segment type: Pure code
.text$x:000121F8 ; Segment permissions: Read/Execute
.text$x:000121F8 _text$x         segment para public 'CODE' use32
.text$x:000121F8                 assume cs:_text$x
.text$x:000121F8                 ;org 121F8h
.text$x:000121F8 ; COMDAT (pick associative to section at 12184)
.text$x:000121F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000121F8
.text$x:000121F8 ; =============== S U B R O U T I N E =======================================
.text$x:000121F8
.text$x:000121F8
.text$x:000121F8 __unwindfunclet$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z$0 proc near
.text$x:000121F8                                         ; DATA XREF: .xdata$x:00012A4Co
.text$x:000121F8                 mov     eax, [ebp-18h]
.text$x:000121FB                 and     eax, 1
.text$x:000121FE                 jz      $LN4_1
.text$x:00012204                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00012208                 mov     ecx, [ebp+8]
.text$x:0001220B                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00012210 ; ---------------------------------------------------------------------------
.text$x:00012210
.text$x:00012210 $LN4_1:                                 ; CODE XREF: __unwindfunclet$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z$0+6j
.text$x:00012210                 retn
.text$x:00012210 __unwindfunclet$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z$0 endp
.text$x:00012210
.text$x:00012211
.text$x:00012211 ; =============== S U B R O U T I N E =======================================
.text$x:00012211
.text$x:00012211
.text$x:00012211 __ehhandler$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z proc near
.text$x:00012211                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::substr(uint,uint)+5o
.text$x:00012211
.text$x:00012211 arg_4           = dword ptr  8
.text$x:00012211
.text$x:00012211                 mov     edx, [esp+arg_4]
.text$x:00012215                 lea     eax, [edx+0Ch]
.text$x:00012218                 mov     ecx, [edx-10h]
.text$x:0001221B                 xor     ecx, eax
.text$x:0001221D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00012222                 mov     eax, offset __ehfuncinfo$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z
.text$x:00012227                 jmp     ___CxxFrameHandler3
.text$x:00012227 __ehhandler$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z endp
.text$x:00012227
.text$x:00012227 _text$x         ends
.text$x:00012227
.text$mn:0001222C ; ===========================================================================
.text$mn:0001222C
.text$mn:0001222C ; Segment type: Pure code
.text$mn:0001222C ; Segment permissions: Read/Execute
.text$mn:0001222C _text$mn        segment para public 'CODE' use32
.text$mn:0001222C                 assume cs:_text$mn
.text$mn:0001222C                 ;org 1222Ch
.text$mn:0001222C ; COMDAT (pick any)
.text$mn:0001222C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0001222C
.text$mn:0001222C ; =============== S U B R O U T I N E =======================================
.text$mn:0001222C
.text$mn:0001222C ; Attributes: bp-based frame
.text$mn:0001222C
.text$mn:0001222C ; const struct std::error_category *__cdecl std::system_category()
.text$mn:0001222C                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:0001222C ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:0001222C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_10128p
.text$mn:0001222C                 push    ebp
.text$mn:0001222D                 mov     ebp, esp
.text$mn:0001222F                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00012234                 pop     ebp
.text$mn:00012235                 retn
.text$mn:00012235 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00012235
.text$mn:00012235 ; ---------------------------------------------------------------------------
.text$mn:00012236                 align 4
.text$mn:00012236 _text$mn        ends
.text$mn:00012236
.text$mn:00012238 ; ===========================================================================
.text$mn:00012238
.text$mn:00012238 ; Segment type: Pure code
.text$mn:00012238 ; Segment permissions: Read/Execute
.text$mn:00012238 _text$mn        segment para public 'CODE' use32
.text$mn:00012238                 assume cs:_text$mn
.text$mn:00012238                 ;org 12238h
.text$mn:00012238 ; COMDAT (pick any)
.text$mn:00012238                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00012238
.text$mn:00012238 ; =============== S U B R O U T I N E =======================================
.text$mn:00012238
.text$mn:00012238 ; Attributes: bp-based frame
.text$mn:00012238
.text$mn:00012238 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00012238                 public ?value@error_code@std@@QBEHXZ
.text$mn:00012238 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00012238
.text$mn:00012238 var_4           = dword ptr -4
.text$mn:00012238
.text$mn:00012238                 push    ebp
.text$mn:00012239                 mov     ebp, esp
.text$mn:0001223B                 push    ecx
.text$mn:0001223C                 mov     [ebp+var_4], ecx
.text$mn:0001223F                 mov     eax, [ebp+var_4]
.text$mn:00012242                 mov     eax, [eax]
.text$mn:00012244                 mov     esp, ebp
.text$mn:00012246                 pop     ebp
.text$mn:00012247                 retn
.text$mn:00012247 ?value@error_code@std@@QBEHXZ endp
.text$mn:00012247
.text$mn:00012247 _text$mn        ends
.text$mn:00012247
.text$mn:00012248 ; ===========================================================================
.text$mn:00012248
.text$mn:00012248 ; Segment type: Pure code
.text$mn:00012248 ; Segment permissions: Read/Execute
.text$mn:00012248 _text$mn        segment para public 'CODE' use32
.text$mn:00012248                 assume cs:_text$mn
.text$mn:00012248                 ;org 12248h
.text$mn:00012248 ; COMDAT (pick any)
.text$mn:00012248                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00012248
.text$mn:00012248 ; =============== S U B R O U T I N E =======================================
.text$mn:00012248
.text$mn:00012248 ; Attributes: bp-based frame
.text$mn:00012248
.text$mn:00012248 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00012248                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00012248 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00012248                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00012248                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00012248
.text$mn:00012248 var_4           = dword ptr -4
.text$mn:00012248
.text$mn:00012248                 push    ebp
.text$mn:00012249                 mov     ebp, esp
.text$mn:0001224B                 push    ecx
.text$mn:0001224C                 mov     [ebp+var_4], ecx
.text$mn:0001224F                 mov     eax, [ebp+var_4]
.text$mn:00012252                 mov     eax, [eax]
.text$mn:00012254                 mov     esp, ebp
.text$mn:00012256                 pop     ebp
.text$mn:00012257                 retn
.text$mn:00012257 ?value@error_condition@std@@QBEHXZ endp
.text$mn:00012257
.text$mn:00012257 _text$mn        ends
.text$mn:00012257
.text$mn:00012258 ; ===========================================================================
.text$mn:00012258
.text$mn:00012258 ; Segment type: Pure code
.text$mn:00012258 ; Segment permissions: Read/Execute
.text$mn:00012258 _text$mn        segment para public 'CODE' use32
.text$mn:00012258                 assume cs:_text$mn
.text$mn:00012258                 ;org 12258h
.text$mn:00012258 ; COMDAT (pick any)
.text$mn:00012258                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00012258
.text$mn:00012258 ; =============== S U B R O U T I N E =======================================
.text$mn:00012258
.text$mn:00012258 ; Attributes: bp-based frame
.text$mn:00012258
.text$mn:00012258 ; wchar_t *__cdecl wcsrchr(wchar_t *Str, wchar_t)
.text$mn:00012258                 public ?wcsrchr@@YAPA_WPA_W_W@Z
.text$mn:00012258 ?wcsrchr@@YAPA_WPA_W_W@Z proc near      ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+319p
.text$mn:00012258                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+32Ep
.text$mn:00012258
.text$mn:00012258 Str             = dword ptr  8
.text$mn:00012258 arg_4           = word ptr  0Ch
.text$mn:00012258
.text$mn:00012258                 push    ebp
.text$mn:00012259                 mov     ebp, esp
.text$mn:0001225B                 movzx   eax, [ebp+arg_4]
.text$mn:0001225F                 push    eax             ; Ch
.text$mn:00012260                 mov     ecx, [ebp+Str]
.text$mn:00012263                 push    ecx             ; Str
.text$mn:00012264                 call    _wcsrchr
.text$mn:00012269                 add     esp, 8
.text$mn:0001226C                 pop     ebp
.text$mn:0001226D                 retn
.text$mn:0001226D ?wcsrchr@@YAPA_WPA_W_W@Z endp
.text$mn:0001226D
.text$mn:0001226D ; ---------------------------------------------------------------------------
.text$mn:0001226E                 align 10h
.text$mn:0001226E _text$mn        ends
.text$mn:0001226E
.text$mn:00012270 ; ===========================================================================
.text$mn:00012270
.text$mn:00012270 ; Segment type: Pure code
.text$mn:00012270 ; Segment permissions: Read/Execute
.text$mn:00012270 _text$mn        segment para public 'CODE' use32
.text$mn:00012270                 assume cs:_text$mn
.text$mn:00012270                 ;org 12270h
.text$mn:00012270 ; COMDAT (pick any)
.text$mn:00012270                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00012270
.text$mn:00012270 ; =============== S U B R O U T I N E =======================================
.text$mn:00012270
.text$mn:00012270 ; Attributes: bp-based frame
.text$mn:00012270
.text$mn:00012270                 public _hypot
.text$mn:00012270 _hypot          proc near
.text$mn:00012270
.text$mn:00012270 var_10          = qword ptr -10h
.text$mn:00012270 var_8           = qword ptr -8
.text$mn:00012270 arg_0           = qword ptr  8
.text$mn:00012270 arg_8           = qword ptr  10h
.text$mn:00012270
.text$mn:00012270                 push    ebp
.text$mn:00012271                 mov     ebp, esp
.text$mn:00012273                 sub     esp, 8
.text$mn:00012276                 movsd   xmm0, [ebp+arg_8]
.text$mn:0001227B                 movsd   [esp+8+var_8], xmm0
.text$mn:00012280                 sub     esp, 8
.text$mn:00012283                 movsd   xmm0, [ebp+arg_0]
.text$mn:00012288                 movsd   [esp+10h+var_10], xmm0
.text$mn:0001228D                 call    __hypot
.text$mn:00012292                 add     esp, 10h
.text$mn:00012295                 pop     ebp
.text$mn:00012296                 retn
.text$mn:00012296 _hypot          endp
.text$mn:00012296
.text$mn:00012296 ; ---------------------------------------------------------------------------
.text$mn:00012297                 align 4
.text$mn:00012297 _text$mn        ends
.text$mn:00012297
.text$mn:00012298 ; ===========================================================================
.text$mn:00012298
.text$mn:00012298 ; Segment type: Pure code
.text$mn:00012298 ; Segment permissions: Read/Execute
.text$mn:00012298 _text$mn        segment para public 'CODE' use32
.text$mn:00012298                 assume cs:_text$mn
.text$mn:00012298                 ;org 12298h
.text$mn:00012298 ; COMDAT (pick any)
.text$mn:00012298                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00012298
.text$mn:00012298 ; =============== S U B R O U T I N E =======================================
.text$mn:00012298
.text$mn:00012298 ; Attributes: bp-based frame
.text$mn:00012298
.text$mn:00012298                 public _wmemchr
.text$mn:00012298 _wmemchr        proc near               ; CODE XREF: std::char_traits<wchar_t>::find(wchar_t const *,uint,wchar_t const &)+22p
.text$mn:00012298
.text$mn:00012298 arg_0           = dword ptr  8
.text$mn:00012298 arg_4           = word ptr  0Ch
.text$mn:00012298 arg_8           = dword ptr  10h
.text$mn:00012298
.text$mn:00012298                 push    ebp
.text$mn:00012299                 mov     ebp, esp
.text$mn:0001229B                 jmp     short loc_122AF
.text$mn:0001229D ; ---------------------------------------------------------------------------
.text$mn:0001229D
.text$mn:0001229D loc_1229D:                              ; CODE XREF: _wmemchr:loc_122C8j
.text$mn:0001229D                 mov     eax, [ebp+arg_0]
.text$mn:000122A0                 add     eax, 2
.text$mn:000122A3                 mov     [ebp+arg_0], eax
.text$mn:000122A6                 mov     ecx, [ebp+arg_8]
.text$mn:000122A9                 sub     ecx, 1
.text$mn:000122AC                 mov     [ebp+arg_8], ecx
.text$mn:000122AF
.text$mn:000122AF loc_122AF:                              ; CODE XREF: _wmemchr+3j
.text$mn:000122AF                 cmp     [ebp+arg_8], 0
.text$mn:000122B3                 jbe     short loc_122CA
.text$mn:000122B5                 mov     edx, [ebp+arg_0]
.text$mn:000122B8                 movzx   eax, word ptr [edx]
.text$mn:000122BB                 movzx   ecx, [ebp+arg_4]
.text$mn:000122BF                 cmp     eax, ecx
.text$mn:000122C1                 jnz     short loc_122C8
.text$mn:000122C3                 mov     eax, [ebp+arg_0]
.text$mn:000122C6                 jmp     short loc_122CC
.text$mn:000122C8 ; ---------------------------------------------------------------------------
.text$mn:000122C8
.text$mn:000122C8 loc_122C8:                              ; CODE XREF: _wmemchr+29j
.text$mn:000122C8                 jmp     short loc_1229D
.text$mn:000122CA ; ---------------------------------------------------------------------------
.text$mn:000122CA
.text$mn:000122CA loc_122CA:                              ; CODE XREF: _wmemchr+1Bj
.text$mn:000122CA                 xor     eax, eax
.text$mn:000122CC
.text$mn:000122CC loc_122CC:                              ; CODE XREF: _wmemchr+2Ej
.text$mn:000122CC                 pop     ebp
.text$mn:000122CD                 retn
.text$mn:000122CD _wmemchr        endp
.text$mn:000122CD
.text$mn:000122CD ; ---------------------------------------------------------------------------
.text$mn:000122CE                 align 10h
.text$mn:000122CE _text$mn        ends
.text$mn:000122CE
.text$mn:000122D0 ; ===========================================================================
.text$mn:000122D0
.text$mn:000122D0 ; Segment type: Pure code
.text$mn:000122D0 ; Segment permissions: Read/Execute
.text$mn:000122D0 _text$mn        segment para public 'CODE' use32
.text$mn:000122D0                 assume cs:_text$mn
.text$mn:000122D0                 ;org 122D0h
.text$mn:000122D0 ; COMDAT (pick any)
.text$mn:000122D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000122D0
.text$mn:000122D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000122D0
.text$mn:000122D0 ; Attributes: bp-based frame
.text$mn:000122D0
.text$mn:000122D0                 public _wmemcmp
.text$mn:000122D0 _wmemcmp        proc near               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+1Fp
.text$mn:000122D0
.text$mn:000122D0 var_4           = dword ptr -4
.text$mn:000122D0 arg_0           = dword ptr  8
.text$mn:000122D0 arg_4           = dword ptr  0Ch
.text$mn:000122D0 arg_8           = dword ptr  10h
.text$mn:000122D0
.text$mn:000122D0                 push    ebp
.text$mn:000122D1                 mov     ebp, esp
.text$mn:000122D3                 push    ecx
.text$mn:000122D4                 jmp     short loc_122F1
.text$mn:000122D6 ; ---------------------------------------------------------------------------
.text$mn:000122D6
.text$mn:000122D6 loc_122D6:                              ; CODE XREF: _wmemcmp:loc_1232Cj
.text$mn:000122D6                 mov     eax, [ebp+arg_0]
.text$mn:000122D9                 add     eax, 2
.text$mn:000122DC                 mov     [ebp+arg_0], eax
.text$mn:000122DF                 mov     ecx, [ebp+arg_4]
.text$mn:000122E2                 add     ecx, 2
.text$mn:000122E5                 mov     [ebp+arg_4], ecx
.text$mn:000122E8                 mov     edx, [ebp+arg_8]
.text$mn:000122EB                 sub     edx, 1
.text$mn:000122EE                 mov     [ebp+arg_8], edx
.text$mn:000122F1
.text$mn:000122F1 loc_122F1:                              ; CODE XREF: _wmemcmp+4j
.text$mn:000122F1                 cmp     [ebp+arg_8], 0
.text$mn:000122F5                 jbe     short loc_1232E
.text$mn:000122F7                 mov     eax, [ebp+arg_0]
.text$mn:000122FA                 movzx   ecx, word ptr [eax]
.text$mn:000122FD                 mov     edx, [ebp+arg_4]
.text$mn:00012300                 movzx   eax, word ptr [edx]
.text$mn:00012303                 cmp     ecx, eax
.text$mn:00012305                 jz      short loc_1232C
.text$mn:00012307                 mov     ecx, [ebp+arg_0]
.text$mn:0001230A                 movzx   edx, word ptr [ecx]
.text$mn:0001230D                 mov     eax, [ebp+arg_4]
.text$mn:00012310                 movzx   ecx, word ptr [eax]
.text$mn:00012313                 cmp     edx, ecx
.text$mn:00012315                 jge     short loc_12320
.text$mn:00012317                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0001231E                 jmp     short loc_12327
.text$mn:00012320 ; ---------------------------------------------------------------------------
.text$mn:00012320
.text$mn:00012320 loc_12320:                              ; CODE XREF: _wmemcmp+45j
.text$mn:00012320                 mov     [ebp+var_4], 1
.text$mn:00012327
.text$mn:00012327 loc_12327:                              ; CODE XREF: _wmemcmp+4Ej
.text$mn:00012327                 mov     eax, [ebp+var_4]
.text$mn:0001232A                 jmp     short loc_12330
.text$mn:0001232C ; ---------------------------------------------------------------------------
.text$mn:0001232C
.text$mn:0001232C loc_1232C:                              ; CODE XREF: _wmemcmp+35j
.text$mn:0001232C                 jmp     short loc_122D6
.text$mn:0001232E ; ---------------------------------------------------------------------------
.text$mn:0001232E
.text$mn:0001232E loc_1232E:                              ; CODE XREF: _wmemcmp+25j
.text$mn:0001232E                 xor     eax, eax
.text$mn:00012330
.text$mn:00012330 loc_12330:                              ; CODE XREF: _wmemcmp+5Aj
.text$mn:00012330                 mov     esp, ebp
.text$mn:00012332                 pop     ebp
.text$mn:00012333                 retn
.text$mn:00012333 _wmemcmp        endp
.text$mn:00012333
.text$mn:00012333 _text$mn        ends
.text$mn:00012333
.text$mn:00012334 ; ===========================================================================
.text$mn:00012334
.text$mn:00012334 ; Segment type: Pure code
.text$mn:00012334 ; Segment permissions: Read/Execute
.text$mn:00012334 _text$mn        segment para public 'CODE' use32
.text$mn:00012334                 assume cs:_text$mn
.text$mn:00012334                 ;org 12334h
.text$mn:00012334 ; COMDAT (pick any)
.text$mn:00012334                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00012334
.text$mn:00012334 ; =============== S U B R O U T I N E =======================================
.text$mn:00012334
.text$mn:00012334 ; Attributes: bp-based frame
.text$mn:00012334
.text$mn:00012334 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:00012334                 public _wmemcpy
.text$mn:00012334 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00012334
.text$mn:00012334 Dst             = dword ptr  8
.text$mn:00012334 Src             = dword ptr  0Ch
.text$mn:00012334 arg_8           = dword ptr  10h
.text$mn:00012334
.text$mn:00012334                 push    ebp
.text$mn:00012335                 mov     ebp, esp
.text$mn:00012337                 mov     eax, [ebp+arg_8]
.text$mn:0001233A                 shl     eax, 1
.text$mn:0001233C                 push    eax             ; Size
.text$mn:0001233D                 mov     ecx, [ebp+Src]
.text$mn:00012340                 push    ecx             ; Src
.text$mn:00012341                 mov     edx, [ebp+Dst]
.text$mn:00012344                 push    edx             ; Dst
.text$mn:00012345                 call    _memcpy
.text$mn:0001234A                 add     esp, 0Ch
.text$mn:0001234D                 pop     ebp
.text$mn:0001234E                 retn
.text$mn:0001234E _wmemcpy        endp
.text$mn:0001234E
.text$mn:0001234E ; ---------------------------------------------------------------------------
.text$mn:0001234F                 align 10h
.text$mn:0001234F _text$mn        ends
.text$mn:0001234F
.text$mn:00012350 ; ===========================================================================
.text$mn:00012350
.text$mn:00012350 ; Segment type: Pure code
.text$mn:00012350 ; Segment permissions: Read/Execute
.text$mn:00012350 _text$mn        segment para public 'CODE' use32
.text$mn:00012350                 assume cs:_text$mn
.text$mn:00012350                 ;org 12350h
.text$mn:00012350 ; COMDAT (pick any)
.text$mn:00012350                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00012350
.text$mn:00012350 ; =============== S U B R O U T I N E =======================================
.text$mn:00012350
.text$mn:00012350 ; Attributes: bp-based frame
.text$mn:00012350
.text$mn:00012350 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:00012350                 public _wmemmove
.text$mn:00012350 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00012350
.text$mn:00012350 Dst             = dword ptr  8
.text$mn:00012350 Src             = dword ptr  0Ch
.text$mn:00012350 arg_8           = dword ptr  10h
.text$mn:00012350
.text$mn:00012350                 push    ebp
.text$mn:00012351                 mov     ebp, esp
.text$mn:00012353                 mov     eax, [ebp+arg_8]
.text$mn:00012356                 shl     eax, 1
.text$mn:00012358                 push    eax             ; Size
.text$mn:00012359                 mov     ecx, [ebp+Src]
.text$mn:0001235C                 push    ecx             ; Src
.text$mn:0001235D                 mov     edx, [ebp+Dst]
.text$mn:00012360                 push    edx             ; Dst
.text$mn:00012361                 call    _memmove
.text$mn:00012366                 add     esp, 0Ch
.text$mn:00012369                 pop     ebp
.text$mn:0001236A                 retn
.text$mn:0001236A _wmemmove       endp
.text$mn:0001236A
.text$mn:0001236A ; ---------------------------------------------------------------------------
.text$mn:0001236B                 align 4
.text$mn:0001236B _text$mn        ends
.text$mn:0001236B
.xdata$x:0001236C ; ===========================================================================
.xdata$x:0001236C
.xdata$x:0001236C ; Segment type: Pure data
.xdata$x:0001236C ; Segment permissions: Read
.xdata$x:0001236C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0001236C                 assume cs:_xdata$x
.xdata$x:0001236C                 ;org 1236Ch
.xdata$x:0001236C ; COMDAT (pick associative to section at E318)
.xdata$x:0001236C __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:0001236C                                         ; DATA XREF: .xdata$x:0001237Co
.xdata$x:0001236D                 db 0FFh
.xdata$x:0001236E                 db 0FFh
.xdata$x:0001236F                 db 0FFh
.xdata$x:00012370                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00012374 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00012374                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00012375                 db    5
.xdata$x:00012376                 db  93h ; ô
.xdata$x:00012377                 db  19h
.xdata$x:00012378                 db    1
.xdata$x:00012379                 db    0
.xdata$x:0001237A                 db    0
.xdata$x:0001237B                 db    0
.xdata$x:0001237C                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00012380                 db    0
.xdata$x:00012381                 db    0
.xdata$x:00012382                 db    0
.xdata$x:00012383                 db    0
.xdata$x:00012384                 db    0
.xdata$x:00012385                 db    0
.xdata$x:00012386                 db    0
.xdata$x:00012387                 db    0
.xdata$x:00012388                 db    0
.xdata$x:00012389                 db    0
.xdata$x:0001238A                 db    0
.xdata$x:0001238B                 db    0
.xdata$x:0001238C                 db    0
.xdata$x:0001238D                 db    0
.xdata$x:0001238E                 db    0
.xdata$x:0001238F                 db    0
.xdata$x:00012390                 db    0
.xdata$x:00012391                 db    0
.xdata$x:00012392                 db    0
.xdata$x:00012393                 db    0
.xdata$x:00012394                 db    0
.xdata$x:00012395                 db    0
.xdata$x:00012396                 db    0
.xdata$x:00012397                 db    0
.xdata$x:00012397 _xdata$x        ends
.xdata$x:00012397
.xdata$x:00012398 ; ===========================================================================
.xdata$x:00012398
.xdata$x:00012398 ; Segment type: Pure data
.xdata$x:00012398 ; Segment permissions: Read
.xdata$x:00012398 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012398                 assume cs:_xdata$x
.xdata$x:00012398                 ;org 12398h
.xdata$x:00012398 ; COMDAT (pick associative to section at C544)
.xdata$x:00012398 __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:00012398                                         ; DATA XREF: .xdata$x:000123A8o
.xdata$x:00012399                 db 0FFh
.xdata$x:0001239A                 db 0FFh
.xdata$x:0001239B                 db 0FFh
.xdata$x:0001239C                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:000123A0 __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:000123A0                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:000123A1                 db    5
.xdata$x:000123A2                 db  93h ; ô
.xdata$x:000123A3                 db  19h
.xdata$x:000123A4                 db    1
.xdata$x:000123A5                 db    0
.xdata$x:000123A6                 db    0
.xdata$x:000123A7                 db    0
.xdata$x:000123A8                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:000123AC                 db    0
.xdata$x:000123AD                 db    0
.xdata$x:000123AE                 db    0
.xdata$x:000123AF                 db    0
.xdata$x:000123B0                 db    0
.xdata$x:000123B1                 db    0
.xdata$x:000123B2                 db    0
.xdata$x:000123B3                 db    0
.xdata$x:000123B4                 db    0
.xdata$x:000123B5                 db    0
.xdata$x:000123B6                 db    0
.xdata$x:000123B7                 db    0
.xdata$x:000123B8                 db    0
.xdata$x:000123B9                 db    0
.xdata$x:000123BA                 db    0
.xdata$x:000123BB                 db    0
.xdata$x:000123BC                 db    0
.xdata$x:000123BD                 db    0
.xdata$x:000123BE                 db    0
.xdata$x:000123BF                 db    0
.xdata$x:000123C0                 db    0
.xdata$x:000123C1                 db    0
.xdata$x:000123C2                 db    0
.xdata$x:000123C3                 db    0
.xdata$x:000123C3 _xdata$x        ends
.xdata$x:000123C3
.xdata$x:000123C4 ; ===========================================================================
.xdata$x:000123C4
.xdata$x:000123C4 ; Segment type: Pure data
.xdata$x:000123C4 ; Segment permissions: Read
.xdata$x:000123C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000123C4                 assume cs:_xdata$x
.xdata$x:000123C4                 ;org 123C4h
.xdata$x:000123C4 ; COMDAT (pick associative to section at BF34)
.xdata$x:000123C4 __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:000123C4                                         ; DATA XREF: .xdata$x:000123D4o
.xdata$x:000123C5                 db 0FFh
.xdata$x:000123C6                 db 0FFh
.xdata$x:000123C7                 db 0FFh
.xdata$x:000123C8                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:000123CC __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:000123CC                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:000123CD                 db    5
.xdata$x:000123CE                 db  93h ; ô
.xdata$x:000123CF                 db  19h
.xdata$x:000123D0                 db    1
.xdata$x:000123D1                 db    0
.xdata$x:000123D2                 db    0
.xdata$x:000123D3                 db    0
.xdata$x:000123D4                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:000123D8                 db    0
.xdata$x:000123D9                 db    0
.xdata$x:000123DA                 db    0
.xdata$x:000123DB                 db    0
.xdata$x:000123DC                 db    0
.xdata$x:000123DD                 db    0
.xdata$x:000123DE                 db    0
.xdata$x:000123DF                 db    0
.xdata$x:000123E0                 db    0
.xdata$x:000123E1                 db    0
.xdata$x:000123E2                 db    0
.xdata$x:000123E3                 db    0
.xdata$x:000123E4                 db    0
.xdata$x:000123E5                 db    0
.xdata$x:000123E6                 db    0
.xdata$x:000123E7                 db    0
.xdata$x:000123E8                 db    0
.xdata$x:000123E9                 db    0
.xdata$x:000123EA                 db    0
.xdata$x:000123EB                 db    0
.xdata$x:000123EC                 db    0
.xdata$x:000123ED                 db    0
.xdata$x:000123EE                 db    0
.xdata$x:000123EF                 db    0
.xdata$x:000123EF _xdata$x        ends
.xdata$x:000123EF
.xdata$x:000123F0 ; ===========================================================================
.xdata$x:000123F0
.xdata$x:000123F0 ; Segment type: Pure data
.xdata$x:000123F0 ; Segment permissions: Read
.xdata$x:000123F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000123F0                 assume cs:_xdata$x
.xdata$x:000123F0                 ;org 123F0h
.xdata$x:000123F0 ; COMDAT (pick associative to section at D10C)
.xdata$x:000123F0 __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:000123F0                                         ; DATA XREF: .xdata$x:00012408o
.xdata$x:000123F1                 db 0FFh
.xdata$x:000123F2                 db 0FFh
.xdata$x:000123F3                 db 0FFh
.xdata$x:000123F4                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:000123F8                 db 0FFh
.xdata$x:000123F9                 db 0FFh
.xdata$x:000123FA                 db 0FFh
.xdata$x:000123FB                 db 0FFh
.xdata$x:000123FC                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:00012400 __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:00012400                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:00012401                 db    5
.xdata$x:00012402                 db  93h ; ô
.xdata$x:00012403                 db  19h
.xdata$x:00012404                 db    2
.xdata$x:00012405                 db    0
.xdata$x:00012406                 db    0
.xdata$x:00012407                 db    0
.xdata$x:00012408                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:0001240C                 db    0
.xdata$x:0001240D                 db    0
.xdata$x:0001240E                 db    0
.xdata$x:0001240F                 db    0
.xdata$x:00012410                 db    0
.xdata$x:00012411                 db    0
.xdata$x:00012412                 db    0
.xdata$x:00012413                 db    0
.xdata$x:00012414                 db    0
.xdata$x:00012415                 db    0
.xdata$x:00012416                 db    0
.xdata$x:00012417                 db    0
.xdata$x:00012418                 db    0
.xdata$x:00012419                 db    0
.xdata$x:0001241A                 db    0
.xdata$x:0001241B                 db    0
.xdata$x:0001241C                 db    0
.xdata$x:0001241D                 db    0
.xdata$x:0001241E                 db    0
.xdata$x:0001241F                 db    0
.xdata$x:00012420                 db    0
.xdata$x:00012421                 db    0
.xdata$x:00012422                 db    0
.xdata$x:00012423                 db    0
.xdata$x:00012423 _xdata$x        ends
.xdata$x:00012423
.xdata$x:00012424 ; ===========================================================================
.xdata$x:00012424
.xdata$x:00012424 ; Segment type: Pure data
.xdata$x:00012424 ; Segment permissions: Read
.xdata$x:00012424 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012424                 assume cs:_xdata$x
.xdata$x:00012424                 ;org 12424h
.xdata$x:00012424 ; COMDAT (pick associative to section at 9734)
.xdata$x:00012424 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00012424                                         ; DATA XREF: .xdata$x:00012434o
.xdata$x:00012425                 db 0FFh
.xdata$x:00012426                 db 0FFh
.xdata$x:00012427                 db 0FFh
.xdata$x:00012428                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0001242C __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0001242C                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0001242D                 db    5
.xdata$x:0001242E                 db  93h ; ô
.xdata$x:0001242F                 db  19h
.xdata$x:00012430                 db    1
.xdata$x:00012431                 db    0
.xdata$x:00012432                 db    0
.xdata$x:00012433                 db    0
.xdata$x:00012434                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00012438                 db    0
.xdata$x:00012439                 db    0
.xdata$x:0001243A                 db    0
.xdata$x:0001243B                 db    0
.xdata$x:0001243C                 db    0
.xdata$x:0001243D                 db    0
.xdata$x:0001243E                 db    0
.xdata$x:0001243F                 db    0
.xdata$x:00012440                 db    0
.xdata$x:00012441                 db    0
.xdata$x:00012442                 db    0
.xdata$x:00012443                 db    0
.xdata$x:00012444                 db    0
.xdata$x:00012445                 db    0
.xdata$x:00012446                 db    0
.xdata$x:00012447                 db    0
.xdata$x:00012448                 db    0
.xdata$x:00012449                 db    0
.xdata$x:0001244A                 db    0
.xdata$x:0001244B                 db    0
.xdata$x:0001244C                 db    0
.xdata$x:0001244D                 db    0
.xdata$x:0001244E                 db    0
.xdata$x:0001244F                 db    0
.xdata$x:0001244F _xdata$x        ends
.xdata$x:0001244F
.xdata$x:00012450 ; ===========================================================================
.xdata$x:00012450
.xdata$x:00012450 ; Segment type: Pure data
.xdata$x:00012450 ; Segment permissions: Read
.xdata$x:00012450 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012450                 assume cs:_xdata$x
.xdata$x:00012450                 ;org 12450h
.xdata$x:00012450 ; COMDAT (pick associative to section at B494)
.xdata$x:00012450 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00012450                                         ; DATA XREF: .xdata$x:00012460o
.xdata$x:00012451                 db 0FFh
.xdata$x:00012452                 db 0FFh
.xdata$x:00012453                 db 0FFh
.xdata$x:00012454                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00012458 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00012458                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00012459                 db    5
.xdata$x:0001245A                 db  93h ; ô
.xdata$x:0001245B                 db  19h
.xdata$x:0001245C                 db    1
.xdata$x:0001245D                 db    0
.xdata$x:0001245E                 db    0
.xdata$x:0001245F                 db    0
.xdata$x:00012460                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00012464                 db    0
.xdata$x:00012465                 db    0
.xdata$x:00012466                 db    0
.xdata$x:00012467                 db    0
.xdata$x:00012468                 db    0
.xdata$x:00012469                 db    0
.xdata$x:0001246A                 db    0
.xdata$x:0001246B                 db    0
.xdata$x:0001246C                 db    0
.xdata$x:0001246D                 db    0
.xdata$x:0001246E                 db    0
.xdata$x:0001246F                 db    0
.xdata$x:00012470                 db    0
.xdata$x:00012471                 db    0
.xdata$x:00012472                 db    0
.xdata$x:00012473                 db    0
.xdata$x:00012474                 db    0
.xdata$x:00012475                 db    0
.xdata$x:00012476                 db    0
.xdata$x:00012477                 db    0
.xdata$x:00012478                 db    0
.xdata$x:00012479                 db    0
.xdata$x:0001247A                 db    0
.xdata$x:0001247B                 db    0
.xdata$x:0001247B _xdata$x        ends
.xdata$x:0001247B
.xdata$x:0001247C ; ===========================================================================
.xdata$x:0001247C
.xdata$x:0001247C ; Segment type: Pure data
.xdata$x:0001247C ; Segment permissions: Read
.xdata$x:0001247C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0001247C                 assume cs:_xdata$x
.xdata$x:0001247C                 ;org 1247Ch
.xdata$x:0001247C ; COMDAT (pick associative to section at 9438)
.xdata$x:0001247C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:0001247C                                         ; DATA XREF: .xdata$x:0001248Co
.xdata$x:0001247D                 db 0FFh
.xdata$x:0001247E                 db 0FFh
.xdata$x:0001247F                 db 0FFh
.xdata$x:00012480                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00012484 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00012484                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00012485                 db    5
.xdata$x:00012486                 db  93h ; ô
.xdata$x:00012487                 db  19h
.xdata$x:00012488                 db    1
.xdata$x:00012489                 db    0
.xdata$x:0001248A                 db    0
.xdata$x:0001248B                 db    0
.xdata$x:0001248C                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00012490                 db    0
.xdata$x:00012491                 db    0
.xdata$x:00012492                 db    0
.xdata$x:00012493                 db    0
.xdata$x:00012494                 db    0
.xdata$x:00012495                 db    0
.xdata$x:00012496                 db    0
.xdata$x:00012497                 db    0
.xdata$x:00012498                 db    0
.xdata$x:00012499                 db    0
.xdata$x:0001249A                 db    0
.xdata$x:0001249B                 db    0
.xdata$x:0001249C                 db    0
.xdata$x:0001249D                 db    0
.xdata$x:0001249E                 db    0
.xdata$x:0001249F                 db    0
.xdata$x:000124A0                 db    0
.xdata$x:000124A1                 db    0
.xdata$x:000124A2                 db    0
.xdata$x:000124A3                 db    0
.xdata$x:000124A4                 db    0
.xdata$x:000124A5                 db    0
.xdata$x:000124A6                 db    0
.xdata$x:000124A7                 db    0
.xdata$x:000124A7 _xdata$x        ends
.xdata$x:000124A7
.xdata$x:000124A8 ; ===========================================================================
.xdata$x:000124A8
.xdata$x:000124A8 ; Segment type: Pure data
.xdata$x:000124A8 ; Segment permissions: Read
.xdata$x:000124A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000124A8                 assume cs:_xdata$x
.xdata$x:000124A8                 ;org 124A8h
.xdata$x:000124A8 ; COMDAT (pick associative to section at B2C4)
.xdata$x:000124A8 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000124A8                                         ; DATA XREF: .xdata$x:000124B8o
.xdata$x:000124A9                 db 0FFh
.xdata$x:000124AA                 db 0FFh
.xdata$x:000124AB                 db 0FFh
.xdata$x:000124AC                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000124B0 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000124B0                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000124B1                 db    5
.xdata$x:000124B2                 db  93h ; ô
.xdata$x:000124B3                 db  19h
.xdata$x:000124B4                 db    1
.xdata$x:000124B5                 db    0
.xdata$x:000124B6                 db    0
.xdata$x:000124B7                 db    0
.xdata$x:000124B8                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:000124BC                 db    0
.xdata$x:000124BD                 db    0
.xdata$x:000124BE                 db    0
.xdata$x:000124BF                 db    0
.xdata$x:000124C0                 db    0
.xdata$x:000124C1                 db    0
.xdata$x:000124C2                 db    0
.xdata$x:000124C3                 db    0
.xdata$x:000124C4                 db    0
.xdata$x:000124C5                 db    0
.xdata$x:000124C6                 db    0
.xdata$x:000124C7                 db    0
.xdata$x:000124C8                 db    0
.xdata$x:000124C9                 db    0
.xdata$x:000124CA                 db    0
.xdata$x:000124CB                 db    0
.xdata$x:000124CC                 db    0
.xdata$x:000124CD                 db    0
.xdata$x:000124CE                 db    0
.xdata$x:000124CF                 db    0
.xdata$x:000124D0                 db    0
.xdata$x:000124D1                 db    0
.xdata$x:000124D2                 db    0
.xdata$x:000124D3                 db    0
.xdata$x:000124D3 _xdata$x        ends
.xdata$x:000124D3
.xdata$x:000124D4 ; ===========================================================================
.xdata$x:000124D4
.xdata$x:000124D4 ; Segment type: Pure data
.xdata$x:000124D4 ; Segment permissions: Read
.xdata$x:000124D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000124D4                 assume cs:_xdata$x
.xdata$x:000124D4                 ;org 124D4h
.xdata$x:000124D4 ; COMDAT (pick associative to section at A1B0)
.xdata$x:000124D4 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:000124D4                                         ; DATA XREF: .xdata$x:000124E4o
.xdata$x:000124D5                 db 0FFh
.xdata$x:000124D6                 db 0FFh
.xdata$x:000124D7                 db 0FFh
.xdata$x:000124D8                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:000124DC __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:000124DC                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:000124DD                 db    5
.xdata$x:000124DE                 db  93h ; ô
.xdata$x:000124DF                 db  19h
.xdata$x:000124E0                 db    1
.xdata$x:000124E1                 db    0
.xdata$x:000124E2                 db    0
.xdata$x:000124E3                 db    0
.xdata$x:000124E4                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:000124E8                 align 20h
.xdata$x:000124E8 _xdata$x        ends
.xdata$x:000124E8
.xdata$x:00012500 ; ===========================================================================
.xdata$x:00012500
.xdata$x:00012500 ; Segment type: Pure data
.xdata$x:00012500 ; Segment permissions: Read
.xdata$x:00012500 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012500                 assume cs:_xdata$x
.xdata$x:00012500                 ;org 12500h
.xdata$x:00012500 ; COMDAT (pick associative to section at BAD4)
.xdata$x:00012500 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00012500                                         ; DATA XREF: .xdata$x:00012510o
.xdata$x:00012501                 db 0FFh
.xdata$x:00012502                 db 0FFh
.xdata$x:00012503                 db 0FFh
.xdata$x:00012504                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00012508 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00012508                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00012509                 db    5
.xdata$x:0001250A                 db  93h ; ô
.xdata$x:0001250B                 db  19h
.xdata$x:0001250C                 db    1
.xdata$x:0001250D                 db    0
.xdata$x:0001250E                 db    0
.xdata$x:0001250F                 db    0
.xdata$x:00012510                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00012514                 db    0
.xdata$x:00012515                 db    0
.xdata$x:00012516                 db    0
.xdata$x:00012517                 db    0
.xdata$x:00012518                 db    0
.xdata$x:00012519                 db    0
.xdata$x:0001251A                 db    0
.xdata$x:0001251B                 db    0
.xdata$x:0001251C                 db    0
.xdata$x:0001251D                 db    0
.xdata$x:0001251E                 db    0
.xdata$x:0001251F                 db    0
.xdata$x:00012520                 db    0
.xdata$x:00012521                 db    0
.xdata$x:00012522                 db    0
.xdata$x:00012523                 db    0
.xdata$x:00012524                 db    0
.xdata$x:00012525                 db    0
.xdata$x:00012526                 db    0
.xdata$x:00012527                 db    0
.xdata$x:00012528                 db    0
.xdata$x:00012529                 db    0
.xdata$x:0001252A                 db    0
.xdata$x:0001252B                 db    0
.xdata$x:0001252B _xdata$x        ends
.xdata$x:0001252B
.xdata$x:0001252C ; ===========================================================================
.xdata$x:0001252C
.xdata$x:0001252C ; Segment type: Pure data
.xdata$x:0001252C ; Segment permissions: Read
.xdata$x:0001252C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0001252C                 assume cs:_xdata$x
.xdata$x:0001252C                 ;org 1252Ch
.xdata$x:0001252C ; COMDAT (pick associative to section at D6C0)
.xdata$x:0001252C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0001252C                                         ; DATA XREF: .xdata$x:000125B4o
.xdata$x:0001252D                 db    0
.xdata$x:0001252E                 db    0
.xdata$x:0001252F                 db    0
.xdata$x:00012530                 db    0
.xdata$x:00012531                 db    0
.xdata$x:00012532                 db    0
.xdata$x:00012533                 db    0
.xdata$x:00012534                 db    0
.xdata$x:00012535                 db    0
.xdata$x:00012536                 db    0
.xdata$x:00012537                 db    0
.xdata$x:00012538                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:0001253C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0001253C                                         ; DATA XREF: .xdata$x:000125A0o
.xdata$x:0001253D                 db    0
.xdata$x:0001253E                 db    0
.xdata$x:0001253F                 db    0
.xdata$x:00012540                 db    0
.xdata$x:00012541                 db    0
.xdata$x:00012542                 db    0
.xdata$x:00012543                 db    0
.xdata$x:00012544                 db    0
.xdata$x:00012545                 db    0
.xdata$x:00012546                 db    0
.xdata$x:00012547                 db    0
.xdata$x:00012548                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:0001254C __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0001254C                                         ; DATA XREF: .xdata$x:00012574o
.xdata$x:0001254D                 db 0FFh
.xdata$x:0001254E                 db 0FFh
.xdata$x:0001254F                 db 0FFh
.xdata$x:00012550                 db    0
.xdata$x:00012551                 db    0
.xdata$x:00012552                 db    0
.xdata$x:00012553                 db    0
.xdata$x:00012554                 db 0FFh
.xdata$x:00012555                 db 0FFh
.xdata$x:00012556                 db 0FFh
.xdata$x:00012557                 db 0FFh
.xdata$x:00012558                 db    0
.xdata$x:00012559                 db    0
.xdata$x:0001255A                 db    0
.xdata$x:0001255B                 db    0
.xdata$x:0001255C                 db    1
.xdata$x:0001255D                 db    0
.xdata$x:0001255E                 db    0
.xdata$x:0001255F                 db    0
.xdata$x:00012560                 db    0
.xdata$x:00012561                 db    0
.xdata$x:00012562                 db    0
.xdata$x:00012563                 db    0
.xdata$x:00012564                 db    1
.xdata$x:00012565                 db    0
.xdata$x:00012566                 db    0
.xdata$x:00012567                 db    0
.xdata$x:00012568                 db    0
.xdata$x:00012569                 db    0
.xdata$x:0001256A                 db    0
.xdata$x:0001256B                 db    0
.xdata$x:0001256C __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0001256C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:0001256D                 db    5
.xdata$x:0001256E                 db  93h ; ô
.xdata$x:0001256F                 db  19h
.xdata$x:00012570                 db    4
.xdata$x:00012571                 db    0
.xdata$x:00012572                 db    0
.xdata$x:00012573                 db    0
.xdata$x:00012574                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00012578                 db    2
.xdata$x:00012579                 db    0
.xdata$x:0001257A                 db    0
.xdata$x:0001257B                 db    0
.xdata$x:0001257C                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00012580                 db    0
.xdata$x:00012581                 db    0
.xdata$x:00012582                 db    0
.xdata$x:00012583                 db    0
.xdata$x:00012584                 db    0
.xdata$x:00012585                 db    0
.xdata$x:00012586                 db    0
.xdata$x:00012587                 db    0
.xdata$x:00012588                 db    0
.xdata$x:00012589                 db    0
.xdata$x:0001258A                 db    0
.xdata$x:0001258B                 db    0
.xdata$x:0001258C                 db    0
.xdata$x:0001258D                 db    0
.xdata$x:0001258E                 db    0
.xdata$x:0001258F                 db    0
.xdata$x:00012590 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00012590                                         ; DATA XREF: .xdata$x:0001257Co
.xdata$x:00012591                 db    0
.xdata$x:00012592                 db    0
.xdata$x:00012593                 db    0
.xdata$x:00012594                 db    2
.xdata$x:00012595                 db    0
.xdata$x:00012596                 db    0
.xdata$x:00012597                 db    0
.xdata$x:00012598                 db    3
.xdata$x:00012599                 db    0
.xdata$x:0001259A                 db    0
.xdata$x:0001259B                 db    0
.xdata$x:0001259C                 db    1
.xdata$x:0001259D                 db    0
.xdata$x:0001259E                 db    0
.xdata$x:0001259F                 db    0
.xdata$x:000125A0                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:000125A4                 db    0
.xdata$x:000125A5                 db    0
.xdata$x:000125A6                 db    0
.xdata$x:000125A7                 db    0
.xdata$x:000125A8                 db    0
.xdata$x:000125A9                 db    0
.xdata$x:000125AA                 db    0
.xdata$x:000125AB                 db    0
.xdata$x:000125AC                 db    3
.xdata$x:000125AD                 db    0
.xdata$x:000125AE                 db    0
.xdata$x:000125AF                 db    0
.xdata$x:000125B0                 db    1
.xdata$x:000125B1                 db    0
.xdata$x:000125B2                 db    0
.xdata$x:000125B3                 db    0
.xdata$x:000125B4                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:000125B4 _xdata$x        ends
.xdata$x:000125B4
.xdata$x:000125B8 ; ===========================================================================
.xdata$x:000125B8
.xdata$x:000125B8 ; Segment type: Pure data
.xdata$x:000125B8 ; Segment permissions: Read
.xdata$x:000125B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000125B8                 assume cs:_xdata$x
.xdata$x:000125B8                 ;org 125B8h
.xdata$x:000125B8 ; COMDAT (pick associative to section at AC70)
.xdata$x:000125B8 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000125B8                                         ; DATA XREF: .xdata$x:000125C8o
.xdata$x:000125B9                 db 0FFh
.xdata$x:000125BA                 db 0FFh
.xdata$x:000125BB                 db 0FFh
.xdata$x:000125BC                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:000125C0 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000125C0                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:000125C1                 db    5
.xdata$x:000125C2                 db  93h ; ô
.xdata$x:000125C3                 db  19h
.xdata$x:000125C4                 db    1
.xdata$x:000125C5                 db    0
.xdata$x:000125C6                 db    0
.xdata$x:000125C7                 db    0
.xdata$x:000125C8                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:000125CC                 db    0
.xdata$x:000125CD                 db    0
.xdata$x:000125CE                 db    0
.xdata$x:000125CF                 db    0
.xdata$x:000125D0                 db    0
.xdata$x:000125D1                 db    0
.xdata$x:000125D2                 db    0
.xdata$x:000125D3                 db    0
.xdata$x:000125D4                 db    0
.xdata$x:000125D5                 db    0
.xdata$x:000125D6                 db    0
.xdata$x:000125D7                 db    0
.xdata$x:000125D8                 db    0
.xdata$x:000125D9                 db    0
.xdata$x:000125DA                 db    0
.xdata$x:000125DB                 db    0
.xdata$x:000125DC                 db    0
.xdata$x:000125DD                 db    0
.xdata$x:000125DE                 db    0
.xdata$x:000125DF                 db    0
.xdata$x:000125E0                 db    0
.xdata$x:000125E1                 db    0
.xdata$x:000125E2                 db    0
.xdata$x:000125E3                 db    0
.xdata$x:000125E3 _xdata$x        ends
.xdata$x:000125E3
.xdata$x:000125E4 ; ===========================================================================
.xdata$x:000125E4
.xdata$x:000125E4 ; Segment type: Pure data
.xdata$x:000125E4 ; Segment permissions: Read
.xdata$x:000125E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000125E4                 assume cs:_xdata$x
.xdata$x:000125E4                 ;org 125E4h
.xdata$x:000125E4 ; COMDAT (pick associative to section at 1102C)
.xdata$x:000125E4 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000125E4                                         ; DATA XREF: .xdata$x:000125F4o
.xdata$x:000125E5                 db 0FFh
.xdata$x:000125E6                 db 0FFh
.xdata$x:000125E7                 db 0FFh
.xdata$x:000125E8                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000125EC __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000125EC                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000125ED                 db    5
.xdata$x:000125EE                 db  93h ; ô
.xdata$x:000125EF                 db  19h
.xdata$x:000125F0                 db    1
.xdata$x:000125F1                 db    0
.xdata$x:000125F2                 db    0
.xdata$x:000125F3                 db    0
.xdata$x:000125F4                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000125F8                 db    0
.xdata$x:000125F9                 db    0
.xdata$x:000125FA                 db    0
.xdata$x:000125FB                 db    0
.xdata$x:000125FC                 db    0
.xdata$x:000125FD                 db    0
.xdata$x:000125FE                 db    0
.xdata$x:000125FF                 db    0
.xdata$x:00012600                 db    0
.xdata$x:00012601                 db    0
.xdata$x:00012602                 db    0
.xdata$x:00012603                 db    0
.xdata$x:00012604                 db    0
.xdata$x:00012605                 db    0
.xdata$x:00012606                 db    0
.xdata$x:00012607                 db    0
.xdata$x:00012608                 db    0
.xdata$x:00012609                 db    0
.xdata$x:0001260A                 db    0
.xdata$x:0001260B                 db    0
.xdata$x:0001260C                 db    0
.xdata$x:0001260D                 db    0
.xdata$x:0001260E                 db    0
.xdata$x:0001260F                 db    0
.xdata$x:0001260F _xdata$x        ends
.xdata$x:0001260F
.xdata$x:00012610 ; ===========================================================================
.xdata$x:00012610
.xdata$x:00012610 ; Segment type: Pure data
.xdata$x:00012610 ; Segment permissions: Read
.xdata$x:00012610 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012610                 assume cs:_xdata$x
.xdata$x:00012610                 ;org 12610h
.xdata$x:00012610 ; COMDAT (pick associative to section at BE54)
.xdata$x:00012610 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00012610                                         ; DATA XREF: .xdata$x:00012620o
.xdata$x:00012611                 db 0FFh
.xdata$x:00012612                 db 0FFh
.xdata$x:00012613                 db 0FFh
.xdata$x:00012614                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00012618 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00012618                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00012619                 db    5
.xdata$x:0001261A                 db  93h ; ô
.xdata$x:0001261B                 db  19h
.xdata$x:0001261C                 db    1
.xdata$x:0001261D                 db    0
.xdata$x:0001261E                 db    0
.xdata$x:0001261F                 db    0
.xdata$x:00012620                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00012624                 db    0
.xdata$x:00012625                 db    0
.xdata$x:00012626                 db    0
.xdata$x:00012627                 db    0
.xdata$x:00012628                 db    0
.xdata$x:00012629                 db    0
.xdata$x:0001262A                 db    0
.xdata$x:0001262B                 db    0
.xdata$x:0001262C                 db    0
.xdata$x:0001262D                 db    0
.xdata$x:0001262E                 db    0
.xdata$x:0001262F                 db    0
.xdata$x:00012630                 db    0
.xdata$x:00012631                 db    0
.xdata$x:00012632                 db    0
.xdata$x:00012633                 db    0
.xdata$x:00012634                 db    0
.xdata$x:00012635                 db    0
.xdata$x:00012636                 db    0
.xdata$x:00012637                 db    0
.xdata$x:00012638                 db    0
.xdata$x:00012639                 db    0
.xdata$x:0001263A                 db    0
.xdata$x:0001263B                 db    0
.xdata$x:0001263B _xdata$x        ends
.xdata$x:0001263B
.xdata$x:0001263C ; ===========================================================================
.xdata$x:0001263C
.xdata$x:0001263C ; Segment type: Pure data
.xdata$x:0001263C ; Segment permissions: Read
.xdata$x:0001263C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0001263C                 assume cs:_xdata$x
.xdata$x:0001263C                 ;org 1263Ch
.xdata$x:0001263C ; COMDAT (pick associative to section at ACFC)
.xdata$x:0001263C __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0001263C                                         ; DATA XREF: .xdata$x:0001264Co
.xdata$x:0001263D                 db 0FFh
.xdata$x:0001263E                 db 0FFh
.xdata$x:0001263F                 db 0FFh
.xdata$x:00012640                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00012644 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00012644                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00012645                 db    5
.xdata$x:00012646                 db  93h ; ô
.xdata$x:00012647                 db  19h
.xdata$x:00012648                 db    1
.xdata$x:00012649                 db    0
.xdata$x:0001264A                 db    0
.xdata$x:0001264B                 db    0
.xdata$x:0001264C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00012650                 db    0
.xdata$x:00012651                 db    0
.xdata$x:00012652                 db    0
.xdata$x:00012653                 db    0
.xdata$x:00012654                 db    0
.xdata$x:00012655                 db    0
.xdata$x:00012656                 db    0
.xdata$x:00012657                 db    0
.xdata$x:00012658                 db    0
.xdata$x:00012659                 db    0
.xdata$x:0001265A                 db    0
.xdata$x:0001265B                 db    0
.xdata$x:0001265C                 db    0
.xdata$x:0001265D                 db    0
.xdata$x:0001265E                 db    0
.xdata$x:0001265F                 db    0
.xdata$x:00012660                 db    0
.xdata$x:00012661                 db    0
.xdata$x:00012662                 db    0
.xdata$x:00012663                 db    0
.xdata$x:00012664                 db    0
.xdata$x:00012665                 db    0
.xdata$x:00012666                 db    0
.xdata$x:00012667                 db    0
.xdata$x:00012667 _xdata$x        ends
.xdata$x:00012667
.xdata$x:00012668 ; ===========================================================================
.xdata$x:00012668
.xdata$x:00012668 ; Segment type: Pure data
.xdata$x:00012668 ; Segment permissions: Read
.xdata$x:00012668 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012668                 assume cs:_xdata$x
.xdata$x:00012668                 ;org 12668h
.xdata$x:00012668 ; COMDAT (pick associative to section at 110E4)
.xdata$x:00012668 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00012668                                         ; DATA XREF: .xdata$x:00012678o
.xdata$x:00012669                 db 0FFh
.xdata$x:0001266A                 db 0FFh
.xdata$x:0001266B                 db 0FFh
.xdata$x:0001266C                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00012670 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00012670                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00012671                 db    5
.xdata$x:00012672                 db  93h ; ô
.xdata$x:00012673                 db  19h
.xdata$x:00012674                 db    1
.xdata$x:00012675                 db    0
.xdata$x:00012676                 db    0
.xdata$x:00012677                 db    0
.xdata$x:00012678                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0001267C                 db    0
.xdata$x:0001267D                 db    0
.xdata$x:0001267E                 db    0
.xdata$x:0001267F                 db    0
.xdata$x:00012680                 db    0
.xdata$x:00012681                 db    0
.xdata$x:00012682                 db    0
.xdata$x:00012683                 db    0
.xdata$x:00012684                 db    0
.xdata$x:00012685                 db    0
.xdata$x:00012686                 db    0
.xdata$x:00012687                 db    0
.xdata$x:00012688                 db    0
.xdata$x:00012689                 db    0
.xdata$x:0001268A                 db    0
.xdata$x:0001268B                 db    0
.xdata$x:0001268C                 db    0
.xdata$x:0001268D                 db    0
.xdata$x:0001268E                 db    0
.xdata$x:0001268F                 db    0
.xdata$x:00012690                 db    0
.xdata$x:00012691                 db    0
.xdata$x:00012692                 db    0
.xdata$x:00012693                 db    0
.xdata$x:00012693 _xdata$x        ends
.xdata$x:00012693
.xdata$x:00012694 ; ===========================================================================
.xdata$x:00012694
.xdata$x:00012694 ; Segment type: Pure data
.xdata$x:00012694 ; Segment permissions: Read
.xdata$x:00012694 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012694                 assume cs:_xdata$x
.xdata$x:00012694                 ;org 12694h
.xdata$x:00012694 ; COMDAT (pick associative to section at BEC4)
.xdata$x:00012694 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00012694                                         ; DATA XREF: .xdata$x:000126A4o
.xdata$x:00012695                 db 0FFh
.xdata$x:00012696                 db 0FFh
.xdata$x:00012697                 db 0FFh
.xdata$x:00012698                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:0001269C __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0001269C                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:0001269D                 db    5
.xdata$x:0001269E                 db  93h ; ô
.xdata$x:0001269F                 db  19h
.xdata$x:000126A0                 db    1
.xdata$x:000126A1                 db    0
.xdata$x:000126A2                 db    0
.xdata$x:000126A3                 db    0
.xdata$x:000126A4                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:000126A8                 align 20h
.xdata$x:000126A8 _xdata$x        ends
.xdata$x:000126A8
.xdata$x:000126C0 ; ===========================================================================
.xdata$x:000126C0
.xdata$x:000126C0 ; Segment type: Pure data
.xdata$x:000126C0 ; Segment permissions: Read
.xdata$x:000126C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000126C0                 assume cs:_xdata$x
.xdata$x:000126C0                 ;org 126C0h
.xdata$x:000126C0 ; COMDAT (pick associative to section at ADCC)
.xdata$x:000126C0 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000126C0                                         ; DATA XREF: .xdata$x:000126D0o
.xdata$x:000126C1                 db 0FFh
.xdata$x:000126C2                 db 0FFh
.xdata$x:000126C3                 db 0FFh
.xdata$x:000126C4                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:000126C8 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000126C8                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:000126C9                 db    5
.xdata$x:000126CA                 db  93h ; ô
.xdata$x:000126CB                 db  19h
.xdata$x:000126CC                 db    1
.xdata$x:000126CD                 db    0
.xdata$x:000126CE                 db    0
.xdata$x:000126CF                 db    0
.xdata$x:000126D0                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:000126D4                 db    0
.xdata$x:000126D5                 db    0
.xdata$x:000126D6                 db    0
.xdata$x:000126D7                 db    0
.xdata$x:000126D8                 db    0
.xdata$x:000126D9                 db    0
.xdata$x:000126DA                 db    0
.xdata$x:000126DB                 db    0
.xdata$x:000126DC                 db    0
.xdata$x:000126DD                 db    0
.xdata$x:000126DE                 db    0
.xdata$x:000126DF                 db    0
.xdata$x:000126E0                 db    0
.xdata$x:000126E1                 db    0
.xdata$x:000126E2                 db    0
.xdata$x:000126E3                 db    0
.xdata$x:000126E4                 db    0
.xdata$x:000126E5                 db    0
.xdata$x:000126E6                 db    0
.xdata$x:000126E7                 db    0
.xdata$x:000126E8                 db    0
.xdata$x:000126E9                 db    0
.xdata$x:000126EA                 db    0
.xdata$x:000126EB                 db    0
.xdata$x:000126EB _xdata$x        ends
.xdata$x:000126EB
.xdata$x:000126EC ; ===========================================================================
.xdata$x:000126EC
.xdata$x:000126EC ; Segment type: Pure data
.xdata$x:000126EC ; Segment permissions: Read
.xdata$x:000126EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000126EC                 assume cs:_xdata$x
.xdata$x:000126EC                 ;org 126ECh
.xdata$x:000126EC ; COMDAT (pick associative to section at 111A8)
.xdata$x:000126EC __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000126EC                                         ; DATA XREF: .xdata$x:000126FCo
.xdata$x:000126ED                 db 0FFh
.xdata$x:000126EE                 db 0FFh
.xdata$x:000126EF                 db 0FFh
.xdata$x:000126F0                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000126F4 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000126F4                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000126F5                 db    5
.xdata$x:000126F6                 db  93h ; ô
.xdata$x:000126F7                 db  19h
.xdata$x:000126F8                 db    1
.xdata$x:000126F9                 db    0
.xdata$x:000126FA                 db    0
.xdata$x:000126FB                 db    0
.xdata$x:000126FC                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00012700                 db    0
.xdata$x:00012701                 db    0
.xdata$x:00012702                 db    0
.xdata$x:00012703                 db    0
.xdata$x:00012704                 db    0
.xdata$x:00012705                 db    0
.xdata$x:00012706                 db    0
.xdata$x:00012707                 db    0
.xdata$x:00012708                 db    0
.xdata$x:00012709                 db    0
.xdata$x:0001270A                 db    0
.xdata$x:0001270B                 db    0
.xdata$x:0001270C                 db    0
.xdata$x:0001270D                 db    0
.xdata$x:0001270E                 db    0
.xdata$x:0001270F                 db    0
.xdata$x:00012710                 db    0
.xdata$x:00012711                 db    0
.xdata$x:00012712                 db    0
.xdata$x:00012713                 db    0
.xdata$x:00012714                 db    0
.xdata$x:00012715                 db    0
.xdata$x:00012716                 db    0
.xdata$x:00012717                 db    0
.xdata$x:00012717 _xdata$x        ends
.xdata$x:00012717
.xdata$x:00012718 ; ===========================================================================
.xdata$x:00012718
.xdata$x:00012718 ; Segment type: Pure data
.xdata$x:00012718 ; Segment permissions: Read
.xdata$x:00012718 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012718                 assume cs:_xdata$x
.xdata$x:00012718                 ;org 12718h
.xdata$x:00012718 ; COMDAT (pick associative to section at BFB8)
.xdata$x:00012718 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00012718                                         ; DATA XREF: .xdata$x:00012728o
.xdata$x:00012719                 db 0FFh
.xdata$x:0001271A                 db 0FFh
.xdata$x:0001271B                 db 0FFh
.xdata$x:0001271C                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00012720 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00012720                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00012721                 db    5
.xdata$x:00012722                 db  93h ; ô
.xdata$x:00012723                 db  19h
.xdata$x:00012724                 db    1
.xdata$x:00012725                 db    0
.xdata$x:00012726                 db    0
.xdata$x:00012727                 db    0
.xdata$x:00012728                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:0001272C                 db    0
.xdata$x:0001272D                 db    0
.xdata$x:0001272E                 db    0
.xdata$x:0001272F                 db    0
.xdata$x:00012730                 db    0
.xdata$x:00012731                 db    0
.xdata$x:00012732                 db    0
.xdata$x:00012733                 db    0
.xdata$x:00012734                 db    0
.xdata$x:00012735                 db    0
.xdata$x:00012736                 db    0
.xdata$x:00012737                 db    0
.xdata$x:00012738                 db    0
.xdata$x:00012739                 db    0
.xdata$x:0001273A                 db    0
.xdata$x:0001273B                 db    0
.xdata$x:0001273C                 db    0
.xdata$x:0001273D                 db    0
.xdata$x:0001273E                 db    0
.xdata$x:0001273F                 db    0
.xdata$x:00012740                 db    0
.xdata$x:00012741                 db    0
.xdata$x:00012742                 db    0
.xdata$x:00012743                 db    0
.xdata$x:00012743 _xdata$x        ends
.xdata$x:00012743
.xdata$x:00012744 ; ===========================================================================
.xdata$x:00012744
.xdata$x:00012744 ; Segment type: Pure data
.xdata$x:00012744 ; Segment permissions: Read
.xdata$x:00012744 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012744                 assume cs:_xdata$x
.xdata$x:00012744                 ;org 12744h
.xdata$x:00012744 ; COMDAT (pick associative to section at 97BC)
.xdata$x:00012744 __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00012744                                         ; DATA XREF: .xdata$x:00012754o
.xdata$x:00012745                 db 0FFh
.xdata$x:00012746                 db 0FFh
.xdata$x:00012747                 db 0FFh
.xdata$x:00012748                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0001274C __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0001274C                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0001274D                 db    5
.xdata$x:0001274E                 db  93h ; ô
.xdata$x:0001274F                 db  19h
.xdata$x:00012750                 db    1
.xdata$x:00012751                 db    0
.xdata$x:00012752                 db    0
.xdata$x:00012753                 db    0
.xdata$x:00012754                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00012758                 db    0
.xdata$x:00012759                 db    0
.xdata$x:0001275A                 db    0
.xdata$x:0001275B                 db    0
.xdata$x:0001275C                 db    0
.xdata$x:0001275D                 db    0
.xdata$x:0001275E                 db    0
.xdata$x:0001275F                 db    0
.xdata$x:00012760                 db    0
.xdata$x:00012761                 db    0
.xdata$x:00012762                 db    0
.xdata$x:00012763                 db    0
.xdata$x:00012764                 db    0
.xdata$x:00012765                 db    0
.xdata$x:00012766                 db    0
.xdata$x:00012767                 db    0
.xdata$x:00012768                 db    0
.xdata$x:00012769                 db    0
.xdata$x:0001276A                 db    0
.xdata$x:0001276B                 db    0
.xdata$x:0001276C                 db    0
.xdata$x:0001276D                 db    0
.xdata$x:0001276E                 db    0
.xdata$x:0001276F                 db    0
.xdata$x:0001276F _xdata$x        ends
.xdata$x:0001276F
.xdata$x:00012770 ; ===========================================================================
.xdata$x:00012770
.xdata$x:00012770 ; Segment type: Pure data
.xdata$x:00012770 ; Segment permissions: Read
.xdata$x:00012770 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012770                 assume cs:_xdata$x
.xdata$x:00012770                 ;org 12770h
.xdata$x:00012770 ; COMDAT (pick associative to section at B504)
.xdata$x:00012770 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00012770                                         ; DATA XREF: .xdata$x:00012780o
.xdata$x:00012771                 db 0FFh
.xdata$x:00012772                 db 0FFh
.xdata$x:00012773                 db 0FFh
.xdata$x:00012774                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:00012778 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00012778                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:00012779                 db    5
.xdata$x:0001277A                 db  93h ; ô
.xdata$x:0001277B                 db  19h
.xdata$x:0001277C                 db    1
.xdata$x:0001277D                 db    0
.xdata$x:0001277E                 db    0
.xdata$x:0001277F                 db    0
.xdata$x:00012780                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00012784                 db    0
.xdata$x:00012785                 db    0
.xdata$x:00012786                 db    0
.xdata$x:00012787                 db    0
.xdata$x:00012788                 db    0
.xdata$x:00012789                 db    0
.xdata$x:0001278A                 db    0
.xdata$x:0001278B                 db    0
.xdata$x:0001278C                 db    0
.xdata$x:0001278D                 db    0
.xdata$x:0001278E                 db    0
.xdata$x:0001278F                 db    0
.xdata$x:00012790                 db    0
.xdata$x:00012791                 db    0
.xdata$x:00012792                 db    0
.xdata$x:00012793                 db    0
.xdata$x:00012794                 db    0
.xdata$x:00012795                 db    0
.xdata$x:00012796                 db    0
.xdata$x:00012797                 db    0
.xdata$x:00012798                 db    0
.xdata$x:00012799                 db    0
.xdata$x:0001279A                 db    0
.xdata$x:0001279B                 db    0
.xdata$x:0001279B _xdata$x        ends
.xdata$x:0001279B
.xdata$x:0001279C ; ===========================================================================
.xdata$x:0001279C
.xdata$x:0001279C ; Segment type: Pure data
.xdata$x:0001279C ; Segment permissions: Read
.xdata$x:0001279C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0001279C                 assume cs:_xdata$x
.xdata$x:0001279C                 ;org 1279Ch
.xdata$x:0001279C ; COMDAT (pick associative to section at 94B4)
.xdata$x:0001279C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:0001279C                                         ; DATA XREF: .xdata$x:000127ACo
.xdata$x:0001279D                 db 0FFh
.xdata$x:0001279E                 db 0FFh
.xdata$x:0001279F                 db 0FFh
.xdata$x:000127A0                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:000127A4 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:000127A4                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:000127A5                 db    5
.xdata$x:000127A6                 db  93h ; ô
.xdata$x:000127A7                 db  19h
.xdata$x:000127A8                 db    1
.xdata$x:000127A9                 db    0
.xdata$x:000127AA                 db    0
.xdata$x:000127AB                 db    0
.xdata$x:000127AC                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:000127B0                 db    0
.xdata$x:000127B1                 db    0
.xdata$x:000127B2                 db    0
.xdata$x:000127B3                 db    0
.xdata$x:000127B4                 db    0
.xdata$x:000127B5                 db    0
.xdata$x:000127B6                 db    0
.xdata$x:000127B7                 db    0
.xdata$x:000127B8                 db    0
.xdata$x:000127B9                 db    0
.xdata$x:000127BA                 db    0
.xdata$x:000127BB                 db    0
.xdata$x:000127BC                 db    0
.xdata$x:000127BD                 db    0
.xdata$x:000127BE                 db    0
.xdata$x:000127BF                 db    0
.xdata$x:000127C0                 db    0
.xdata$x:000127C1                 db    0
.xdata$x:000127C2                 db    0
.xdata$x:000127C3                 db    0
.xdata$x:000127C4                 db    0
.xdata$x:000127C5                 db    0
.xdata$x:000127C6                 db    0
.xdata$x:000127C7                 db    0
.xdata$x:000127C7 _xdata$x        ends
.xdata$x:000127C7
.xdata$x:000127C8 ; ===========================================================================
.xdata$x:000127C8
.xdata$x:000127C8 ; Segment type: Pure data
.xdata$x:000127C8 ; Segment permissions: Read
.xdata$x:000127C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000127C8                 assume cs:_xdata$x
.xdata$x:000127C8                 ;org 127C8h
.xdata$x:000127C8 ; COMDAT (pick associative to section at B33C)
.xdata$x:000127C8 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000127C8                                         ; DATA XREF: .xdata$x:000127D8o
.xdata$x:000127C9                 db 0FFh
.xdata$x:000127CA                 db 0FFh
.xdata$x:000127CB                 db 0FFh
.xdata$x:000127CC                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000127D0 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000127D0                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000127D1                 db    5
.xdata$x:000127D2                 db  93h ; ô
.xdata$x:000127D3                 db  19h
.xdata$x:000127D4                 db    1
.xdata$x:000127D5                 db    0
.xdata$x:000127D6                 db    0
.xdata$x:000127D7                 db    0
.xdata$x:000127D8                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:000127DC                 db    0
.xdata$x:000127DD                 db    0
.xdata$x:000127DE                 db    0
.xdata$x:000127DF                 db    0
.xdata$x:000127E0                 db    0
.xdata$x:000127E1                 db    0
.xdata$x:000127E2                 db    0
.xdata$x:000127E3                 db    0
.xdata$x:000127E4                 db    0
.xdata$x:000127E5                 db    0
.xdata$x:000127E6                 db    0
.xdata$x:000127E7                 db    0
.xdata$x:000127E8                 db    0
.xdata$x:000127E9                 db    0
.xdata$x:000127EA                 db    0
.xdata$x:000127EB                 db    0
.xdata$x:000127EC                 db    0
.xdata$x:000127ED                 db    0
.xdata$x:000127EE                 db    0
.xdata$x:000127EF                 db    0
.xdata$x:000127F0                 db    0
.xdata$x:000127F1                 db    0
.xdata$x:000127F2                 db    0
.xdata$x:000127F3                 db    0
.xdata$x:000127F3 _xdata$x        ends
.xdata$x:000127F3
.xdata$x:000127F4 ; ===========================================================================
.xdata$x:000127F4
.xdata$x:000127F4 ; Segment type: Pure data
.xdata$x:000127F4 ; Segment permissions: Read
.xdata$x:000127F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000127F4                 assume cs:_xdata$x
.xdata$x:000127F4                 ;org 127F4h
.xdata$x:000127F4 ; COMDAT (pick associative to section at A2EC)
.xdata$x:000127F4 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:000127F4                                         ; DATA XREF: .xdata$x:00012804o
.xdata$x:000127F5                 db 0FFh
.xdata$x:000127F6                 db 0FFh
.xdata$x:000127F7                 db 0FFh
.xdata$x:000127F8                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0
.xdata$x:000127FC __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:000127FC                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z+11o
.xdata$x:000127FD                 db    5
.xdata$x:000127FE                 db  93h ; ô
.xdata$x:000127FF                 db  19h
.xdata$x:00012800                 db    1
.xdata$x:00012801                 db    0
.xdata$x:00012802                 db    0
.xdata$x:00012803                 db    0
.xdata$x:00012804                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.xdata$x:00012808                 align 20h
.xdata$x:00012808 _xdata$x        ends
.xdata$x:00012808
.xdata$x:00012820 ; ===========================================================================
.xdata$x:00012820
.xdata$x:00012820 ; Segment type: Pure data
.xdata$x:00012820 ; Segment permissions: Read
.xdata$x:00012820 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012820                 assume cs:_xdata$x
.xdata$x:00012820                 ;org 12820h
.xdata$x:00012820 ; COMDAT (pick associative to section at A568)
.xdata$x:00012820 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:00012820                                         ; DATA XREF: .xdata$x:00012830o
.xdata$x:00012821                 db 0FFh
.xdata$x:00012822                 db 0FFh
.xdata$x:00012823                 db 0FFh
.xdata$x:00012824                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:00012828 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00012828                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:00012829                 db    5
.xdata$x:0001282A                 db  93h ; ô
.xdata$x:0001282B                 db  19h
.xdata$x:0001282C                 db    1
.xdata$x:0001282D                 db    0
.xdata$x:0001282E                 db    0
.xdata$x:0001282F                 db    0
.xdata$x:00012830                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:00012834                 db    0
.xdata$x:00012835                 db    0
.xdata$x:00012836                 db    0
.xdata$x:00012837                 db    0
.xdata$x:00012838                 db    0
.xdata$x:00012839                 db    0
.xdata$x:0001283A                 db    0
.xdata$x:0001283B                 db    0
.xdata$x:0001283C                 db    0
.xdata$x:0001283D                 db    0
.xdata$x:0001283E                 db    0
.xdata$x:0001283F                 db    0
.xdata$x:00012840                 db    0
.xdata$x:00012841                 db    0
.xdata$x:00012842                 db    0
.xdata$x:00012843                 db    0
.xdata$x:00012844                 db    0
.xdata$x:00012845                 db    0
.xdata$x:00012846                 db    0
.xdata$x:00012847                 db    0
.xdata$x:00012848                 db    0
.xdata$x:00012849                 db    0
.xdata$x:0001284A                 db    0
.xdata$x:0001284B                 db    0
.xdata$x:0001284B _xdata$x        ends
.xdata$x:0001284B
.xdata$x:0001284C ; ===========================================================================
.xdata$x:0001284C
.xdata$x:0001284C ; Segment type: Pure data
.xdata$x:0001284C ; Segment permissions: Read
.xdata$x:0001284C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0001284C                 assume cs:_xdata$x
.xdata$x:0001284C                 ;org 1284Ch
.xdata$x:0001284C ; COMDAT (pick associative to section at A39C)
.xdata$x:0001284C __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:0001284C                                         ; DATA XREF: .xdata$x:0001285Co
.xdata$x:0001284D                 db 0FFh
.xdata$x:0001284E                 db 0FFh
.xdata$x:0001284F                 db 0FFh
.xdata$x:00012850                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z$0
.xdata$x:00012854 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:00012854                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z+11o
.xdata$x:00012855                 db    5
.xdata$x:00012856                 db  93h ; ô
.xdata$x:00012857                 db  19h
.xdata$x:00012858                 db    1
.xdata$x:00012859                 db    0
.xdata$x:0001285A                 db    0
.xdata$x:0001285B                 db    0
.xdata$x:0001285C                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z
.xdata$x:00012860                 db    0
.xdata$x:00012861                 db    0
.xdata$x:00012862                 db    0
.xdata$x:00012863                 db    0
.xdata$x:00012864                 db    0
.xdata$x:00012865                 db    0
.xdata$x:00012866                 db    0
.xdata$x:00012867                 db    0
.xdata$x:00012868                 db    0
.xdata$x:00012869                 db    0
.xdata$x:0001286A                 db    0
.xdata$x:0001286B                 db    0
.xdata$x:0001286C                 db    0
.xdata$x:0001286D                 db    0
.xdata$x:0001286E                 db    0
.xdata$x:0001286F                 db    0
.xdata$x:00012870                 db    0
.xdata$x:00012871                 db    0
.xdata$x:00012872                 db    0
.xdata$x:00012873                 db    0
.xdata$x:00012874                 db    0
.xdata$x:00012875                 db    0
.xdata$x:00012876                 db    0
.xdata$x:00012877                 db    0
.xdata$x:00012877 _xdata$x        ends
.xdata$x:00012877
.xdata$x:00012878 ; ===========================================================================
.xdata$x:00012878
.xdata$x:00012878 ; Segment type: Pure data
.xdata$x:00012878 ; Segment permissions: Read
.xdata$x:00012878 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012878                 assume cs:_xdata$x
.xdata$x:00012878                 ;org 12878h
.xdata$x:00012878 ; COMDAT (pick associative to section at A4CC)
.xdata$x:00012878 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z db 0FFh
.xdata$x:00012878                                         ; DATA XREF: .xdata$x:00012888o
.xdata$x:00012879                 db 0FFh
.xdata$x:0001287A                 db 0FFh
.xdata$x:0001287B                 db 0FFh
.xdata$x:0001287C                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z$0
.xdata$x:00012880 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z db  22h ; "
.xdata$x:00012880                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z+11o
.xdata$x:00012881                 db    5
.xdata$x:00012882                 db  93h ; ô
.xdata$x:00012883                 db  19h
.xdata$x:00012884                 db    1
.xdata$x:00012885                 db    0
.xdata$x:00012886                 db    0
.xdata$x:00012887                 db    0
.xdata$x:00012888                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z
.xdata$x:0001288C                 db    0
.xdata$x:0001288D                 db    0
.xdata$x:0001288E                 db    0
.xdata$x:0001288F                 db    0
.xdata$x:00012890                 db    0
.xdata$x:00012891                 db    0
.xdata$x:00012892                 db    0
.xdata$x:00012893                 db    0
.xdata$x:00012894                 db    0
.xdata$x:00012895                 db    0
.xdata$x:00012896                 db    0
.xdata$x:00012897                 db    0
.xdata$x:00012898                 db    0
.xdata$x:00012899                 db    0
.xdata$x:0001289A                 db    0
.xdata$x:0001289B                 db    0
.xdata$x:0001289C                 db    0
.xdata$x:0001289D                 db    0
.xdata$x:0001289E                 db    0
.xdata$x:0001289F                 db    0
.xdata$x:000128A0                 db    0
.xdata$x:000128A1                 db    0
.xdata$x:000128A2                 db    0
.xdata$x:000128A3                 db    0
.xdata$x:000128A3 _xdata$x        ends
.xdata$x:000128A3
.xdata$x:000128A4 ; ===========================================================================
.xdata$x:000128A4
.xdata$x:000128A4 ; Segment type: Pure data
.xdata$x:000128A4 ; Segment permissions: Read
.xdata$x:000128A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000128A4                 assume cs:_xdata$x
.xdata$x:000128A4                 ;org 128A4h
.xdata$x:000128A4 ; COMDAT (pick associative to section at A434)
.xdata$x:000128A4 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db 0FFh
.xdata$x:000128A4                                         ; DATA XREF: .xdata$x:000128B4o
.xdata$x:000128A5                 db 0FFh
.xdata$x:000128A6                 db 0FFh
.xdata$x:000128A7                 db 0FFh
.xdata$x:000128A8                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0
.xdata$x:000128AC __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db  22h ; "
.xdata$x:000128AC                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z+11o
.xdata$x:000128AD                 db    5
.xdata$x:000128AE                 db  93h ; ô
.xdata$x:000128AF                 db  19h
.xdata$x:000128B0                 db    1
.xdata$x:000128B1                 db    0
.xdata$x:000128B2                 db    0
.xdata$x:000128B3                 db    0
.xdata$x:000128B4                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.xdata$x:000128B8                 db    0
.xdata$x:000128B9                 db    0
.xdata$x:000128BA                 db    0
.xdata$x:000128BB                 db    0
.xdata$x:000128BC                 db    0
.xdata$x:000128BD                 db    0
.xdata$x:000128BE                 db    0
.xdata$x:000128BF                 db    0
.xdata$x:000128C0                 db    0
.xdata$x:000128C1                 db    0
.xdata$x:000128C2                 db    0
.xdata$x:000128C3                 db    0
.xdata$x:000128C4                 db    0
.xdata$x:000128C5                 db    0
.xdata$x:000128C6                 db    0
.xdata$x:000128C7                 db    0
.xdata$x:000128C8                 db    0
.xdata$x:000128C9                 db    0
.xdata$x:000128CA                 db    0
.xdata$x:000128CB                 db    0
.xdata$x:000128CC                 db    0
.xdata$x:000128CD                 db    0
.xdata$x:000128CE                 db    0
.xdata$x:000128CF                 db    0
.xdata$x:000128CF _xdata$x        ends
.xdata$x:000128CF
.xdata$x:000128D0 ; ===========================================================================
.xdata$x:000128D0
.xdata$x:000128D0 ; Segment type: Pure data
.xdata$x:000128D0 ; Segment permissions: Read
.xdata$x:000128D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000128D0                 assume cs:_xdata$x
.xdata$x:000128D0                 ;org 128D0h
.xdata$x:000128D0 ; COMDAT (pick associative to section at A248)
.xdata$x:000128D0 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z db 0FFh
.xdata$x:000128D0                                         ; DATA XREF: .xdata$x:000128E0o
.xdata$x:000128D1                 db 0FFh
.xdata$x:000128D2                 db 0FFh
.xdata$x:000128D3                 db 0FFh
.xdata$x:000128D4                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0
.xdata$x:000128D8 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z db  22h ; "
.xdata$x:000128D8                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z+11o
.xdata$x:000128D9                 db    5
.xdata$x:000128DA                 db  93h ; ô
.xdata$x:000128DB                 db  19h
.xdata$x:000128DC                 db    1
.xdata$x:000128DD                 db    0
.xdata$x:000128DE                 db    0
.xdata$x:000128DF                 db    0
.xdata$x:000128E0                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.xdata$x:000128E4                 db    0
.xdata$x:000128E5                 db    0
.xdata$x:000128E6                 db    0
.xdata$x:000128E7                 db    0
.xdata$x:000128E8                 db    0
.xdata$x:000128E9                 db    0
.xdata$x:000128EA                 db    0
.xdata$x:000128EB                 db    0
.xdata$x:000128EC                 db    0
.xdata$x:000128ED                 db    0
.xdata$x:000128EE                 db    0
.xdata$x:000128EF                 db    0
.xdata$x:000128F0                 db    0
.xdata$x:000128F1                 db    0
.xdata$x:000128F2                 db    0
.xdata$x:000128F3                 db    0
.xdata$x:000128F4                 db    0
.xdata$x:000128F5                 db    0
.xdata$x:000128F6                 db    0
.xdata$x:000128F7                 db    0
.xdata$x:000128F8                 db    0
.xdata$x:000128F9                 db    0
.xdata$x:000128FA                 db    0
.xdata$x:000128FB                 db    0
.xdata$x:000128FB _xdata$x        ends
.xdata$x:000128FB
.xdata$x:000128FC ; ===========================================================================
.xdata$x:000128FC
.xdata$x:000128FC ; Segment type: Pure data
.xdata$x:000128FC ; Segment permissions: Read
.xdata$x:000128FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000128FC                 assume cs:_xdata$x
.xdata$x:000128FC                 ;org 128FCh
.xdata$x:000128FC ; COMDAT (pick associative to section at C12C)
.xdata$x:000128FC __unwindtable$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z db 0FFh
.xdata$x:000128FC                                         ; DATA XREF: .xdata$x:00012914o
.xdata$x:000128FD                 db 0FFh
.xdata$x:000128FE                 db 0FFh
.xdata$x:000128FF                 db 0FFh
.xdata$x:00012900                 dd offset __unwindfunclet$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z$0
.xdata$x:00012904                 align 8
.xdata$x:00012908                 dd offset __unwindfunclet$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z$1
.xdata$x:0001290C __ehfuncinfo$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z db  22h ; "
.xdata$x:0001290C                                         ; DATA XREF: __ehhandler$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z+11o
.xdata$x:0001290D                 db    5
.xdata$x:0001290E                 db  93h ; ô
.xdata$x:0001290F                 db  19h
.xdata$x:00012910                 db    2
.xdata$x:00012911                 db    0
.xdata$x:00012912                 db    0
.xdata$x:00012913                 db    0
.xdata$x:00012914                 dd offset __unwindtable$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
.xdata$x:00012918                 db    0
.xdata$x:00012919                 db    0
.xdata$x:0001291A                 db    0
.xdata$x:0001291B                 db    0
.xdata$x:0001291C                 db    0
.xdata$x:0001291D                 db    0
.xdata$x:0001291E                 db    0
.xdata$x:0001291F                 db    0
.xdata$x:00012920                 db    0
.xdata$x:00012921                 db    0
.xdata$x:00012922                 db    0
.xdata$x:00012923                 db    0
.xdata$x:00012924                 db    0
.xdata$x:00012925                 db    0
.xdata$x:00012926                 db    0
.xdata$x:00012927                 db    0
.xdata$x:00012928                 db    0
.xdata$x:00012929                 db    0
.xdata$x:0001292A                 db    0
.xdata$x:0001292B                 db    0
.xdata$x:0001292C                 db    0
.xdata$x:0001292D                 db    0
.xdata$x:0001292E                 db    0
.xdata$x:0001292F                 db    0
.xdata$x:0001292F _xdata$x        ends
.xdata$x:0001292F
.xdata$x:00012930 ; ===========================================================================
.xdata$x:00012930
.xdata$x:00012930 ; Segment type: Pure data
.xdata$x:00012930 ; Segment permissions: Read
.xdata$x:00012930 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012930                 assume cs:_xdata$x
.xdata$x:00012930                 ;org 12930h
.xdata$x:00012930 ; COMDAT (pick associative to section at BB50)
.xdata$x:00012930 __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:00012930                                         ; DATA XREF: .xdata$x:00012940o
.xdata$x:00012931                 db 0FFh
.xdata$x:00012932                 db 0FFh
.xdata$x:00012933                 db 0FFh
.xdata$x:00012934                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:00012938 __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00012938                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:00012939                 db    5
.xdata$x:0001293A                 db  93h ; ô
.xdata$x:0001293B                 db  19h
.xdata$x:0001293C                 db    1
.xdata$x:0001293D                 db    0
.xdata$x:0001293E                 db    0
.xdata$x:0001293F                 db    0
.xdata$x:00012940                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:00012944                 db    0
.xdata$x:00012945                 db    0
.xdata$x:00012946                 db    0
.xdata$x:00012947                 db    0
.xdata$x:00012948                 db    0
.xdata$x:00012949                 db    0
.xdata$x:0001294A                 db    0
.xdata$x:0001294B                 db    0
.xdata$x:0001294C                 db    0
.xdata$x:0001294D                 db    0
.xdata$x:0001294E                 db    0
.xdata$x:0001294F                 db    0
.xdata$x:00012950                 db    0
.xdata$x:00012951                 db    0
.xdata$x:00012952                 db    0
.xdata$x:00012953                 db    0
.xdata$x:00012954                 db    0
.xdata$x:00012955                 db    0
.xdata$x:00012956                 db    0
.xdata$x:00012957                 db    0
.xdata$x:00012958                 db    0
.xdata$x:00012959                 db    0
.xdata$x:0001295A                 db    0
.xdata$x:0001295B                 db    0
.xdata$x:0001295B _xdata$x        ends
.xdata$x:0001295B
.xdata$x:0001295C ; ===========================================================================
.xdata$x:0001295C
.xdata$x:0001295C ; Segment type: Pure data
.xdata$x:0001295C ; Segment permissions: Read
.xdata$x:0001295C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0001295C                 assume cs:_xdata$x
.xdata$x:0001295C                 ;org 1295Ch
.xdata$x:0001295C ; COMDAT (pick associative to section at 11BB8)
.xdata$x:0001295C __ehfuncinfo$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z db  22h ; "
.xdata$x:0001295C                                         ; DATA XREF: __ehhandler$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z+14o
.xdata$x:0001295D                 db    5
.xdata$x:0001295E                 db  93h ; ô
.xdata$x:0001295F                 db  19h
.xdata$x:00012960                 db  0Eh
.xdata$x:00012961                 db    0
.xdata$x:00012962                 db    0
.xdata$x:00012963                 db    0
.xdata$x:00012964                 dd offset __unwindtable$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z
.xdata$x:00012968                 align 20h
.xdata$x:00012980 __unwindtable$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z db 0FFh
.xdata$x:00012980                                         ; DATA XREF: .xdata$x:00012964o
.xdata$x:00012981                 db 0FFh
.xdata$x:00012982                 db 0FFh
.xdata$x:00012983                 db 0FFh
.xdata$x:00012984                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$0
.xdata$x:00012988                 db    0
.xdata$x:00012989                 db    0
.xdata$x:0001298A                 db    0
.xdata$x:0001298B                 db    0
.xdata$x:0001298C                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$1
.xdata$x:00012990                 db    1
.xdata$x:00012991                 db    0
.xdata$x:00012992                 db    0
.xdata$x:00012993                 db    0
.xdata$x:00012994                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$2
.xdata$x:00012998                 db    2
.xdata$x:00012999                 db    0
.xdata$x:0001299A                 db    0
.xdata$x:0001299B                 db    0
.xdata$x:0001299C                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$3
.xdata$x:000129A0                 db    3
.xdata$x:000129A1                 db    0
.xdata$x:000129A2                 db    0
.xdata$x:000129A3                 db    0
.xdata$x:000129A4                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$4
.xdata$x:000129A8                 db    4
.xdata$x:000129A9                 db    0
.xdata$x:000129AA                 db    0
.xdata$x:000129AB                 db    0
.xdata$x:000129AC                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$5
.xdata$x:000129B0                 db    3
.xdata$x:000129B1                 db    0
.xdata$x:000129B2                 db    0
.xdata$x:000129B3                 db    0
.xdata$x:000129B4                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$6
.xdata$x:000129B8                 db    6
.xdata$x:000129B9                 db    0
.xdata$x:000129BA                 db    0
.xdata$x:000129BB                 db    0
.xdata$x:000129BC                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$7
.xdata$x:000129C0                 db    7
.xdata$x:000129C1                 db    0
.xdata$x:000129C2                 db    0
.xdata$x:000129C3                 db    0
.xdata$x:000129C4                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$8
.xdata$x:000129C8                 db    3
.xdata$x:000129C9                 db    0
.xdata$x:000129CA                 db    0
.xdata$x:000129CB                 db    0
.xdata$x:000129CC                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$9
.xdata$x:000129D0                 db    9
.xdata$x:000129D1                 db    0
.xdata$x:000129D2                 db    0
.xdata$x:000129D3                 db    0
.xdata$x:000129D4                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$10
.xdata$x:000129D8                 db    3
.xdata$x:000129D9                 db    0
.xdata$x:000129DA                 db    0
.xdata$x:000129DB                 db    0
.xdata$x:000129DC                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$11
.xdata$x:000129E0                 db  0Bh
.xdata$x:000129E1                 db    0
.xdata$x:000129E2                 db    0
.xdata$x:000129E3                 db    0
.xdata$x:000129E4                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$12
.xdata$x:000129E8                 db  0Ch
.xdata$x:000129E9                 db    0
.xdata$x:000129EA                 db    0
.xdata$x:000129EB                 db    0
.xdata$x:000129EC                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$13
.xdata$x:000129EC _xdata$x        ends
.xdata$x:000129EC
.xdata$x:000129F0 ; ===========================================================================
.xdata$x:000129F0
.xdata$x:000129F0 ; Segment type: Pure data
.xdata$x:000129F0 ; Segment permissions: Read
.xdata$x:000129F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000129F0                 assume cs:_xdata$x
.xdata$x:000129F0                 ;org 129F0h
.xdata$x:000129F0 ; COMDAT (pick associative to section at F854)
.xdata$x:000129F0 __unwindtable$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db 0FFh
.xdata$x:000129F0                                         ; DATA XREF: .xdata$x:00012A00o
.xdata$x:000129F1                 db 0FFh
.xdata$x:000129F2                 db 0FFh
.xdata$x:000129F3                 db 0FFh
.xdata$x:000129F4                 dd offset __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0
.xdata$x:000129F8 __ehfuncinfo$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db  22h ; "
.xdata$x:000129F8                                         ; DATA XREF: __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ+11o
.xdata$x:000129F9                 db    5
.xdata$x:000129FA                 db  93h ; ô
.xdata$x:000129FB                 db  19h
.xdata$x:000129FC                 db    1
.xdata$x:000129FD                 db    0
.xdata$x:000129FE                 db    0
.xdata$x:000129FF                 db    0
.xdata$x:00012A00                 dd offset __unwindtable$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.xdata$x:00012A04                 db    0
.xdata$x:00012A05                 db    0
.xdata$x:00012A06                 db    0
.xdata$x:00012A07                 db    0
.xdata$x:00012A08                 db    0
.xdata$x:00012A09                 db    0
.xdata$x:00012A0A                 db    0
.xdata$x:00012A0B                 db    0
.xdata$x:00012A0C                 db    0
.xdata$x:00012A0D                 db    0
.xdata$x:00012A0E                 db    0
.xdata$x:00012A0F                 db    0
.xdata$x:00012A10                 db    0
.xdata$x:00012A11                 db    0
.xdata$x:00012A12                 db    0
.xdata$x:00012A13                 db    0
.xdata$x:00012A14                 db    0
.xdata$x:00012A15                 db    0
.xdata$x:00012A16                 db    0
.xdata$x:00012A17                 db    0
.xdata$x:00012A18                 db    0
.xdata$x:00012A19                 db    0
.xdata$x:00012A1A                 db    0
.xdata$x:00012A1B                 db    0
.xdata$x:00012A1B _xdata$x        ends
.xdata$x:00012A1B
.xdata$x:00012A1C ; ===========================================================================
.xdata$x:00012A1C
.xdata$x:00012A1C ; Segment type: Pure data
.xdata$x:00012A1C ; Segment permissions: Read
.xdata$x:00012A1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012A1C                 assume cs:_xdata$x
.xdata$x:00012A1C                 ;org 12A1Ch
.xdata$x:00012A1C ; COMDAT (pick associative to section at 10230)
.xdata$x:00012A1C __unwindtable$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db 0FFh
.xdata$x:00012A1C                                         ; DATA XREF: .xdata$x:00012A2Co
.xdata$x:00012A1D                 db 0FFh
.xdata$x:00012A1E                 db 0FFh
.xdata$x:00012A1F                 db 0FFh
.xdata$x:00012A20                 dd offset __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0
.xdata$x:00012A24 __ehfuncinfo$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00012A24                                         ; DATA XREF: __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ+11o
.xdata$x:00012A25                 db    5
.xdata$x:00012A26                 db  93h ; ô
.xdata$x:00012A27                 db  19h
.xdata$x:00012A28                 db    1
.xdata$x:00012A29                 db    0
.xdata$x:00012A2A                 db    0
.xdata$x:00012A2B                 db    0
.xdata$x:00012A2C                 dd offset __unwindtable$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.xdata$x:00012A30                 db    0
.xdata$x:00012A31                 db    0
.xdata$x:00012A32                 db    0
.xdata$x:00012A33                 db    0
.xdata$x:00012A34                 db    0
.xdata$x:00012A35                 db    0
.xdata$x:00012A36                 db    0
.xdata$x:00012A37                 db    0
.xdata$x:00012A38                 db    0
.xdata$x:00012A39                 db    0
.xdata$x:00012A3A                 db    0
.xdata$x:00012A3B                 db    0
.xdata$x:00012A3C                 db    0
.xdata$x:00012A3D                 db    0
.xdata$x:00012A3E                 db    0
.xdata$x:00012A3F                 db    0
.xdata$x:00012A40                 db    0
.xdata$x:00012A41                 db    0
.xdata$x:00012A42                 db    0
.xdata$x:00012A43                 db    0
.xdata$x:00012A44                 db    0
.xdata$x:00012A45                 db    0
.xdata$x:00012A46                 db    0
.xdata$x:00012A47                 db    0
.xdata$x:00012A47 _xdata$x        ends
.xdata$x:00012A47
.xdata$x:00012A48 ; ===========================================================================
.xdata$x:00012A48
.xdata$x:00012A48 ; Segment type: Pure data
.xdata$x:00012A48 ; Segment permissions: Read
.xdata$x:00012A48 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012A48                 assume cs:_xdata$x
.xdata$x:00012A48                 ;org 12A48h
.xdata$x:00012A48 ; COMDAT (pick associative to section at 12184)
.xdata$x:00012A48 __unwindtable$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z db 0FFh
.xdata$x:00012A48                                         ; DATA XREF: .xdata$x:00012A58o
.xdata$x:00012A49                 db 0FFh
.xdata$x:00012A4A                 db 0FFh
.xdata$x:00012A4B                 db 0FFh
.xdata$x:00012A4C                 dd offset __unwindfunclet$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z$0
.xdata$x:00012A50 __ehfuncinfo$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z db  22h ; "
.xdata$x:00012A50                                         ; DATA XREF: __ehhandler$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z+11o
.xdata$x:00012A51                 db    5
.xdata$x:00012A52                 db  93h ; ô
.xdata$x:00012A53                 db  19h
.xdata$x:00012A54                 db    1
.xdata$x:00012A55                 db    0
.xdata$x:00012A56                 db    0
.xdata$x:00012A57                 db    0
.xdata$x:00012A58                 dd offset __unwindtable$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z
.xdata$x:00012A5C                 db    0
.xdata$x:00012A5D                 db    0
.xdata$x:00012A5E                 db    0
.xdata$x:00012A5F                 db    0
.xdata$x:00012A60                 db    0
.xdata$x:00012A61                 db    0
.xdata$x:00012A62                 db    0
.xdata$x:00012A63                 db    0
.xdata$x:00012A64                 db    0
.xdata$x:00012A65                 db    0
.xdata$x:00012A66                 db    0
.xdata$x:00012A67                 db    0
.xdata$x:00012A68                 db    0
.xdata$x:00012A69                 db    0
.xdata$x:00012A6A                 db    0
.xdata$x:00012A6B                 db    0
.xdata$x:00012A6C                 db    0
.xdata$x:00012A6D                 db    0
.xdata$x:00012A6E                 db    0
.xdata$x:00012A6F                 db    0
.xdata$x:00012A70                 db    0
.xdata$x:00012A71                 db    0
.xdata$x:00012A72                 db    0
.xdata$x:00012A73                 db    0
.xdata$x:00012A73 _xdata$x        ends
.xdata$x:00012A73
.xdata$x:00012A74 ; ===========================================================================
.xdata$x:00012A74
.xdata$x:00012A74 ; Segment type: Pure data
.xdata$x:00012A74 ; Segment permissions: Read
.xdata$x:00012A74 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012A74                 assume cs:_xdata$x
.xdata$x:00012A74                 ;org 12A74h
.xdata$x:00012A74 ; COMDAT (pick associative to section at D880)
.xdata$x:00012A74 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00012A74                                         ; DATA XREF: .xdata$x:00012AFCo
.xdata$x:00012A75                 db    0
.xdata$x:00012A76                 db    0
.xdata$x:00012A77                 db    0
.xdata$x:00012A78                 db    0
.xdata$x:00012A79                 db    0
.xdata$x:00012A7A                 db    0
.xdata$x:00012A7B                 db    0
.xdata$x:00012A7C                 db    0
.xdata$x:00012A7D                 db    0
.xdata$x:00012A7E                 db    0
.xdata$x:00012A7F                 db    0
.xdata$x:00012A80                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:00012A84 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00012A84                                         ; DATA XREF: .xdata$x:00012AE8o
.xdata$x:00012A85                 db    0
.xdata$x:00012A86                 db    0
.xdata$x:00012A87                 db    0
.xdata$x:00012A88                 db    0
.xdata$x:00012A89                 db    0
.xdata$x:00012A8A                 db    0
.xdata$x:00012A8B                 db    0
.xdata$x:00012A8C                 db    0
.xdata$x:00012A8D                 db    0
.xdata$x:00012A8E                 db    0
.xdata$x:00012A8F                 db    0
.xdata$x:00012A90                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:00012A94 __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00012A94                                         ; DATA XREF: .xdata$x:00012ABCo
.xdata$x:00012A95                 db 0FFh
.xdata$x:00012A96                 db 0FFh
.xdata$x:00012A97                 db 0FFh
.xdata$x:00012A98                 db    0
.xdata$x:00012A99                 db    0
.xdata$x:00012A9A                 db    0
.xdata$x:00012A9B                 db    0
.xdata$x:00012A9C                 db 0FFh
.xdata$x:00012A9D                 db 0FFh
.xdata$x:00012A9E                 db 0FFh
.xdata$x:00012A9F                 db 0FFh
.xdata$x:00012AA0                 db    0
.xdata$x:00012AA1                 db    0
.xdata$x:00012AA2                 db    0
.xdata$x:00012AA3                 db    0
.xdata$x:00012AA4                 db    1
.xdata$x:00012AA5                 db    0
.xdata$x:00012AA6                 db    0
.xdata$x:00012AA7                 db    0
.xdata$x:00012AA8                 db    0
.xdata$x:00012AA9                 db    0
.xdata$x:00012AAA                 db    0
.xdata$x:00012AAB                 db    0
.xdata$x:00012AAC                 db    1
.xdata$x:00012AAD                 db    0
.xdata$x:00012AAE                 db    0
.xdata$x:00012AAF                 db    0
.xdata$x:00012AB0                 db    0
.xdata$x:00012AB1                 db    0
.xdata$x:00012AB2                 db    0
.xdata$x:00012AB3                 db    0
.xdata$x:00012AB4 __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00012AB4                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:00012AB5                 db    5
.xdata$x:00012AB6                 db  93h ; ô
.xdata$x:00012AB7                 db  19h
.xdata$x:00012AB8                 db    4
.xdata$x:00012AB9                 db    0
.xdata$x:00012ABA                 db    0
.xdata$x:00012ABB                 db    0
.xdata$x:00012ABC                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00012AC0                 db    2
.xdata$x:00012AC1                 db    0
.xdata$x:00012AC2                 db    0
.xdata$x:00012AC3                 db    0
.xdata$x:00012AC4                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00012AC8                 db    0
.xdata$x:00012AC9                 db    0
.xdata$x:00012ACA                 db    0
.xdata$x:00012ACB                 db    0
.xdata$x:00012ACC                 db    0
.xdata$x:00012ACD                 db    0
.xdata$x:00012ACE                 db    0
.xdata$x:00012ACF                 db    0
.xdata$x:00012AD0                 db    0
.xdata$x:00012AD1                 db    0
.xdata$x:00012AD2                 db    0
.xdata$x:00012AD3                 db    0
.xdata$x:00012AD4                 db    0
.xdata$x:00012AD5                 db    0
.xdata$x:00012AD6                 db    0
.xdata$x:00012AD7                 db    0
.xdata$x:00012AD8 __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:00012AD8                                         ; DATA XREF: .xdata$x:00012AC4o
.xdata$x:00012AD9                 db    0
.xdata$x:00012ADA                 db    0
.xdata$x:00012ADB                 db    0
.xdata$x:00012ADC                 db    2
.xdata$x:00012ADD                 db    0
.xdata$x:00012ADE                 db    0
.xdata$x:00012ADF                 db    0
.xdata$x:00012AE0                 db    3
.xdata$x:00012AE1                 db    0
.xdata$x:00012AE2                 db    0
.xdata$x:00012AE3                 db    0
.xdata$x:00012AE4                 db    1
.xdata$x:00012AE5                 db    0
.xdata$x:00012AE6                 db    0
.xdata$x:00012AE7                 db    0
.xdata$x:00012AE8                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:00012AEC                 db    0
.xdata$x:00012AED                 db    0
.xdata$x:00012AEE                 db    0
.xdata$x:00012AEF                 db    0
.xdata$x:00012AF0                 db    0
.xdata$x:00012AF1                 db    0
.xdata$x:00012AF2                 db    0
.xdata$x:00012AF3                 db    0
.xdata$x:00012AF4                 db    3
.xdata$x:00012AF5                 db    0
.xdata$x:00012AF6                 db    0
.xdata$x:00012AF7                 db    0
.xdata$x:00012AF8                 db    1
.xdata$x:00012AF9                 db    0
.xdata$x:00012AFA                 db    0
.xdata$x:00012AFB                 db    0
.xdata$x:00012AFC                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:00012AFC _xdata$x        ends
.xdata$x:00012AFC
.xdata$x:00012B00 ; ===========================================================================
.xdata$x:00012B00
.xdata$x:00012B00 ; Segment type: Pure data
.xdata$x:00012B00 ; Segment permissions: Read
.xdata$x:00012B00 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012B00                 assume cs:_xdata$x
.xdata$x:00012B00                 ;org 12B00h
.xdata$x:00012B00 ; COMDAT (pick associative to section at E6E0)
.xdata$x:00012B00 __unwindtable$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z db 0FFh
.xdata$x:00012B00                                         ; DATA XREF: .xdata$x:00012B18o
.xdata$x:00012B01                 db 0FFh
.xdata$x:00012B02                 db 0FFh
.xdata$x:00012B03                 db 0FFh
.xdata$x:00012B04                 dd offset __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$0
.xdata$x:00012B08                 db    0
.xdata$x:00012B09                 db    0
.xdata$x:00012B0A                 db    0
.xdata$x:00012B0B                 db    0
.xdata$x:00012B0C                 dd offset __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$1
.xdata$x:00012B10 __ehfuncinfo$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z db  22h ; "
.xdata$x:00012B10                                         ; DATA XREF: __ehhandler$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z+11o
.xdata$x:00012B11                 db    5
.xdata$x:00012B12                 db  93h ; ô
.xdata$x:00012B13                 db  19h
.xdata$x:00012B14                 db    2
.xdata$x:00012B15                 db    0
.xdata$x:00012B16                 db    0
.xdata$x:00012B17                 db    0
.xdata$x:00012B18                 dd offset __unwindtable$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z
.xdata$x:00012B1C                 db    0
.xdata$x:00012B1D                 db    0
.xdata$x:00012B1E                 db    0
.xdata$x:00012B1F                 db    0
.xdata$x:00012B20                 db    0
.xdata$x:00012B21                 db    0
.xdata$x:00012B22                 db    0
.xdata$x:00012B23                 db    0
.xdata$x:00012B24                 db    0
.xdata$x:00012B25                 db    0
.xdata$x:00012B26                 db    0
.xdata$x:00012B27                 db    0
.xdata$x:00012B28                 db    0
.xdata$x:00012B29                 db    0
.xdata$x:00012B2A                 db    0
.xdata$x:00012B2B                 db    0
.xdata$x:00012B2C                 db    0
.xdata$x:00012B2D                 db    0
.xdata$x:00012B2E                 db    0
.xdata$x:00012B2F                 db    0
.xdata$x:00012B30                 db    0
.xdata$x:00012B31                 db    0
.xdata$x:00012B32                 db    0
.xdata$x:00012B33                 db    0
.xdata$x:00012B33 _xdata$x        ends
.xdata$x:00012B33
.xdata$x:00012B34 ; ===========================================================================
.xdata$x:00012B34
.xdata$x:00012B34 ; Segment type: Pure data
.xdata$x:00012B34 ; Segment permissions: Read
.xdata$x:00012B34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012B34                 assume cs:_xdata$x
.xdata$x:00012B34                 ;org 12B34h
.xdata$x:00012B34 ; COMDAT (pick associative to section at 9DD4)
.xdata$x:00012B34 __unwindtable$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00012B34                                         ; DATA XREF: .xdata$x:00012B44o
.xdata$x:00012B35                 db 0FFh
.xdata$x:00012B36                 db 0FFh
.xdata$x:00012B37                 db 0FFh
.xdata$x:00012B38                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0
.xdata$x:00012B3C __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00012B3C                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ+11o
.xdata$x:00012B3D                 db    5
.xdata$x:00012B3E                 db  93h ; ô
.xdata$x:00012B3F                 db  19h
.xdata$x:00012B40                 db    1
.xdata$x:00012B41                 db    0
.xdata$x:00012B42                 db    0
.xdata$x:00012B43                 db    0
.xdata$x:00012B44                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.xdata$x:00012B48                 align 20h
.xdata$x:00012B48 _xdata$x        ends
.xdata$x:00012B48
.xdata$x:00012B60 ; ===========================================================================
.xdata$x:00012B60
.xdata$x:00012B60 ; Segment type: Pure data
.xdata$x:00012B60 ; Segment permissions: Read
.xdata$x:00012B60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012B60                 assume cs:_xdata$x
.xdata$x:00012B60                 ;org 12B60h
.xdata$x:00012B60 ; COMDAT (pick associative to section at B914)
.xdata$x:00012B60 __unwindtable$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00012B60                                         ; DATA XREF: .xdata$x:00012B70o
.xdata$x:00012B61                 db 0FFh
.xdata$x:00012B62                 db 0FFh
.xdata$x:00012B63                 db 0FFh
.xdata$x:00012B64                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0
.xdata$x:00012B68 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00012B68                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ+11o
.xdata$x:00012B69                 db    5
.xdata$x:00012B6A                 db  93h ; ô
.xdata$x:00012B6B                 db  19h
.xdata$x:00012B6C                 db    1
.xdata$x:00012B6D                 db    0
.xdata$x:00012B6E                 db    0
.xdata$x:00012B6F                 db    0
.xdata$x:00012B70                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.xdata$x:00012B74                 db    0
.xdata$x:00012B75                 db    0
.xdata$x:00012B76                 db    0
.xdata$x:00012B77                 db    0
.xdata$x:00012B78                 db    0
.xdata$x:00012B79                 db    0
.xdata$x:00012B7A                 db    0
.xdata$x:00012B7B                 db    0
.xdata$x:00012B7C                 db    0
.xdata$x:00012B7D                 db    0
.xdata$x:00012B7E                 db    0
.xdata$x:00012B7F                 db    0
.xdata$x:00012B80                 db    0
.xdata$x:00012B81                 db    0
.xdata$x:00012B82                 db    0
.xdata$x:00012B83                 db    0
.xdata$x:00012B84                 db    0
.xdata$x:00012B85                 db    0
.xdata$x:00012B86                 db    0
.xdata$x:00012B87                 db    0
.xdata$x:00012B88                 db    0
.xdata$x:00012B89                 db    0
.xdata$x:00012B8A                 db    0
.xdata$x:00012B8B                 db    0
.xdata$x:00012B8B _xdata$x        ends
.xdata$x:00012B8B
.xdata$x:00012B8C ; ===========================================================================
.xdata$x:00012B8C
.xdata$x:00012B8C ; Segment type: Pure data
.xdata$x:00012B8C ; Segment permissions: Read
.xdata$x:00012B8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012B8C                 assume cs:_xdata$x
.xdata$x:00012B8C                 ;org 12B8Ch
.xdata$x:00012B8C ; COMDAT (pick associative to section at 9844)
.xdata$x:00012B8C __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z db 0FFh
.xdata$x:00012B8C                                         ; DATA XREF: .xdata$x:00012B9Co
.xdata$x:00012B8D                 db 0FFh
.xdata$x:00012B8E                 db 0FFh
.xdata$x:00012B8F                 db 0FFh
.xdata$x:00012B90                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z$0
.xdata$x:00012B94 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z db  22h ; "
.xdata$x:00012B94                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z+11o
.xdata$x:00012B95                 db    5
.xdata$x:00012B96                 db  93h ; ô
.xdata$x:00012B97                 db  19h
.xdata$x:00012B98                 db    1
.xdata$x:00012B99                 db    0
.xdata$x:00012B9A                 db    0
.xdata$x:00012B9B                 db    0
.xdata$x:00012B9C                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.xdata$x:00012BA0                 db    0
.xdata$x:00012BA1                 db    0
.xdata$x:00012BA2                 db    0
.xdata$x:00012BA3                 db    0
.xdata$x:00012BA4                 db    0
.xdata$x:00012BA5                 db    0
.xdata$x:00012BA6                 db    0
.xdata$x:00012BA7                 db    0
.xdata$x:00012BA8                 db    0
.xdata$x:00012BA9                 db    0
.xdata$x:00012BAA                 db    0
.xdata$x:00012BAB                 db    0
.xdata$x:00012BAC                 db    0
.xdata$x:00012BAD                 db    0
.xdata$x:00012BAE                 db    0
.xdata$x:00012BAF                 db    0
.xdata$x:00012BB0                 db    0
.xdata$x:00012BB1                 db    0
.xdata$x:00012BB2                 db    0
.xdata$x:00012BB3                 db    0
.xdata$x:00012BB4                 db    0
.xdata$x:00012BB5                 db    0
.xdata$x:00012BB6                 db    0
.xdata$x:00012BB7                 db    0
.xdata$x:00012BB7 _xdata$x        ends
.xdata$x:00012BB7
.xdata$x:00012BB8 ; ===========================================================================
.xdata$x:00012BB8
.xdata$x:00012BB8 ; Segment type: Pure data
.xdata$x:00012BB8 ; Segment permissions: Read
.xdata$x:00012BB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012BB8                 assume cs:_xdata$x
.xdata$x:00012BB8                 ;org 12BB8h
.xdata$x:00012BB8 ; COMDAT (pick associative to section at B574)
.xdata$x:00012BB8 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00012BB8                                         ; DATA XREF: .xdata$x:00012BC8o
.xdata$x:00012BB9                 db 0FFh
.xdata$x:00012BBA                 db 0FFh
.xdata$x:00012BBB                 db 0FFh
.xdata$x:00012BBC                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00012BC0 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00012BC0                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00012BC1                 db    5
.xdata$x:00012BC2                 db  93h ; ô
.xdata$x:00012BC3                 db  19h
.xdata$x:00012BC4                 db    1
.xdata$x:00012BC5                 db    0
.xdata$x:00012BC6                 db    0
.xdata$x:00012BC7                 db    0
.xdata$x:00012BC8                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
.xdata$x:00012BCC                 db    0
.xdata$x:00012BCD                 db    0
.xdata$x:00012BCE                 db    0
.xdata$x:00012BCF                 db    0
.xdata$x:00012BD0                 db    0
.xdata$x:00012BD1                 db    0
.xdata$x:00012BD2                 db    0
.xdata$x:00012BD3                 db    0
.xdata$x:00012BD4                 db    0
.xdata$x:00012BD5                 db    0
.xdata$x:00012BD6                 db    0
.xdata$x:00012BD7                 db    0
.xdata$x:00012BD8                 db    0
.xdata$x:00012BD9                 db    0
.xdata$x:00012BDA                 db    0
.xdata$x:00012BDB                 db    0
.xdata$x:00012BDC                 db    0
.xdata$x:00012BDD                 db    0
.xdata$x:00012BDE                 db    0
.xdata$x:00012BDF                 db    0
.xdata$x:00012BE0                 db    0
.xdata$x:00012BE1                 db    0
.xdata$x:00012BE2                 db    0
.xdata$x:00012BE3                 db    0
.xdata$x:00012BE3 _xdata$x        ends
.xdata$x:00012BE3
.xdata$x:00012BE4 ; ===========================================================================
.xdata$x:00012BE4
.xdata$x:00012BE4 ; Segment type: Pure data
.xdata$x:00012BE4 ; Segment permissions: Read
.xdata$x:00012BE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012BE4                 assume cs:_xdata$x
.xdata$x:00012BE4                 ;org 12BE4h
.xdata$x:00012BE4 ; COMDAT (pick associative to section at A5F4)
.xdata$x:00012BE4 __unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00012BE4                                         ; DATA XREF: .xdata$x:00012BF4o
.xdata$x:00012BE5                 db 0FFh
.xdata$x:00012BE6                 db 0FFh
.xdata$x:00012BE7                 db 0FFh
.xdata$x:00012BE8                 dd offset __unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
.xdata$x:00012BEC __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00012BEC                                         ; DATA XREF: __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ+11o
.xdata$x:00012BED                 db    5
.xdata$x:00012BEE                 db  93h ; ô
.xdata$x:00012BEF                 db  19h
.xdata$x:00012BF0                 db    1
.xdata$x:00012BF1                 db    0
.xdata$x:00012BF2                 db    0
.xdata$x:00012BF3                 db    0
.xdata$x:00012BF4                 dd offset __unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.xdata$x:00012BF8                 db    0
.xdata$x:00012BF9                 db    0
.xdata$x:00012BFA                 db    0
.xdata$x:00012BFB                 db    0
.xdata$x:00012BFC                 db    0
.xdata$x:00012BFD                 db    0
.xdata$x:00012BFE                 db    0
.xdata$x:00012BFF                 db    0
.xdata$x:00012C00                 db    0
.xdata$x:00012C01                 db    0
.xdata$x:00012C02                 db    0
.xdata$x:00012C03                 db    0
.xdata$x:00012C04                 db    0
.xdata$x:00012C05                 db    0
.xdata$x:00012C06                 db    0
.xdata$x:00012C07                 db    0
.xdata$x:00012C08                 db    0
.xdata$x:00012C09                 db    0
.xdata$x:00012C0A                 db    0
.xdata$x:00012C0B                 db    0
.xdata$x:00012C0C                 db    0
.xdata$x:00012C0D                 db    0
.xdata$x:00012C0E                 db    0
.xdata$x:00012C0F                 db    0
.xdata$x:00012C0F _xdata$x        ends
.xdata$x:00012C0F
.xdata$x:00012C10 ; ===========================================================================
.xdata$x:00012C10
.xdata$x:00012C10 ; Segment type: Pure data
.xdata$x:00012C10 ; Segment permissions: Read
.xdata$x:00012C10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012C10                 assume cs:_xdata$x
.xdata$x:00012C10                 ;org 12C10h
.xdata$x:00012C10 ; COMDAT (pick associative to section at BBCC)
.xdata$x:00012C10 __unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00012C10                                         ; DATA XREF: .xdata$x:00012C20o
.xdata$x:00012C11                 db 0FFh
.xdata$x:00012C12                 db 0FFh
.xdata$x:00012C13                 db 0FFh
.xdata$x:00012C14                 dd offset __unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
.xdata$x:00012C18 __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00012C18                                         ; DATA XREF: __ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ+11o
.xdata$x:00012C19                 db    5
.xdata$x:00012C1A                 db  93h ; ô
.xdata$x:00012C1B                 db  19h
.xdata$x:00012C1C                 db    1
.xdata$x:00012C1D                 db    0
.xdata$x:00012C1E                 db    0
.xdata$x:00012C1F                 db    0
.xdata$x:00012C20                 dd offset __unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.xdata$x:00012C24                 db    0
.xdata$x:00012C25                 db    0
.xdata$x:00012C26                 db    0
.xdata$x:00012C27                 db    0
.xdata$x:00012C28                 db    0
.xdata$x:00012C29                 db    0
.xdata$x:00012C2A                 db    0
.xdata$x:00012C2B                 db    0
.xdata$x:00012C2C                 db    0
.xdata$x:00012C2D                 db    0
.xdata$x:00012C2E                 db    0
.xdata$x:00012C2F                 db    0
.xdata$x:00012C30                 db    0
.xdata$x:00012C31                 db    0
.xdata$x:00012C32                 db    0
.xdata$x:00012C33                 db    0
.xdata$x:00012C34                 db    0
.xdata$x:00012C35                 db    0
.xdata$x:00012C36                 db    0
.xdata$x:00012C37                 db    0
.xdata$x:00012C38                 db    0
.xdata$x:00012C39                 db    0
.xdata$x:00012C3A                 db    0
.xdata$x:00012C3B                 db    0
.xdata$x:00012C3B _xdata$x        ends
.xdata$x:00012C3B
.xdata$x:00012C3C ; ===========================================================================
.xdata$x:00012C3C
.xdata$x:00012C3C ; Segment type: Pure data
.xdata$x:00012C3C ; Segment permissions: Read
.xdata$x:00012C3C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012C3C                 assume cs:_xdata$x
.xdata$x:00012C3C                 ;org 12C3Ch
.xdata$x:00012C3C ; COMDAT (pick associative to section at F8F0)
.xdata$x:00012C3C __unwindtable$?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ db 0FFh
.xdata$x:00012C3C                                         ; DATA XREF: .xdata$x:00012C4Co
.xdata$x:00012C3D                 db 0FFh
.xdata$x:00012C3E                 db 0FFh
.xdata$x:00012C3F                 db 0FFh
.xdata$x:00012C40                 dd offset __unwindfunclet$?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0
.xdata$x:00012C44 __ehfuncinfo$?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00012C44                                         ; DATA XREF: __ehhandler$?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ+11o
.xdata$x:00012C45                 db    5
.xdata$x:00012C46                 db  93h ; ô
.xdata$x:00012C47                 db  19h
.xdata$x:00012C48                 db    1
.xdata$x:00012C49                 db    0
.xdata$x:00012C4A                 db    0
.xdata$x:00012C4B                 db    0
.xdata$x:00012C4C                 dd offset __unwindtable$?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.xdata$x:00012C50                 db    0
.xdata$x:00012C51                 db    0
.xdata$x:00012C52                 db    0
.xdata$x:00012C53                 db    0
.xdata$x:00012C54                 db    0
.xdata$x:00012C55                 db    0
.xdata$x:00012C56                 db    0
.xdata$x:00012C57                 db    0
.xdata$x:00012C58                 db    0
.xdata$x:00012C59                 db    0
.xdata$x:00012C5A                 db    0
.xdata$x:00012C5B                 db    0
.xdata$x:00012C5C                 db    0
.xdata$x:00012C5D                 db    0
.xdata$x:00012C5E                 db    0
.xdata$x:00012C5F                 db    0
.xdata$x:00012C60                 db    0
.xdata$x:00012C61                 db    0
.xdata$x:00012C62                 db    0
.xdata$x:00012C63                 db    0
.xdata$x:00012C64                 db    0
.xdata$x:00012C65                 db    0
.xdata$x:00012C66                 db    0
.xdata$x:00012C67                 db    0
.xdata$x:00012C67 _xdata$x        ends
.xdata$x:00012C67
.xdata$x:00012C68 ; ===========================================================================
.xdata$x:00012C68
.xdata$x:00012C68 ; Segment type: Pure data
.xdata$x:00012C68 ; Segment permissions: Read
.xdata$x:00012C68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012C68                 assume cs:_xdata$x
.xdata$x:00012C68                 ;org 12C68h
.xdata$x:00012C68 ; COMDAT (pick associative to section at 102D8)
.xdata$x:00012C68 __unwindtable$?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ db 0FFh
.xdata$x:00012C68                                         ; DATA XREF: .xdata$x:00012C78o
.xdata$x:00012C69                 db 0FFh
.xdata$x:00012C6A                 db 0FFh
.xdata$x:00012C6B                 db 0FFh
.xdata$x:00012C6C                 dd offset __unwindfunclet$?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0
.xdata$x:00012C70 __ehfuncinfo$?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00012C70                                         ; DATA XREF: __ehhandler$?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ+11o
.xdata$x:00012C71                 db    5
.xdata$x:00012C72                 db  93h ; ô
.xdata$x:00012C73                 db  19h
.xdata$x:00012C74                 db    1
.xdata$x:00012C75                 db    0
.xdata$x:00012C76                 db    0
.xdata$x:00012C77                 db    0
.xdata$x:00012C78                 dd offset __unwindtable$?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.xdata$x:00012C7C                 db    0
.xdata$x:00012C7D                 db    0
.xdata$x:00012C7E                 db    0
.xdata$x:00012C7F                 db    0
.xdata$x:00012C80                 db    0
.xdata$x:00012C81                 db    0
.xdata$x:00012C82                 db    0
.xdata$x:00012C83                 db    0
.xdata$x:00012C84                 db    0
.xdata$x:00012C85                 db    0
.xdata$x:00012C86                 db    0
.xdata$x:00012C87                 db    0
.xdata$x:00012C88                 db    0
.xdata$x:00012C89                 db    0
.xdata$x:00012C8A                 db    0
.xdata$x:00012C8B                 db    0
.xdata$x:00012C8C                 db    0
.xdata$x:00012C8D                 db    0
.xdata$x:00012C8E                 db    0
.xdata$x:00012C8F                 db    0
.xdata$x:00012C90                 db    0
.xdata$x:00012C91                 db    0
.xdata$x:00012C92                 db    0
.xdata$x:00012C93                 db    0
.xdata$x:00012C93 _xdata$x        ends
.xdata$x:00012C93
.xdata$x:00012C94 ; ===========================================================================
.xdata$x:00012C94
.xdata$x:00012C94 ; Segment type: Pure data
.xdata$x:00012C94 ; Segment permissions: Read
.xdata$x:00012C94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012C94                 assume cs:_xdata$x
.xdata$x:00012C94                 ;org 12C94h
.xdata$x:00012C94 ; COMDAT (pick associative to section at E78C)
.xdata$x:00012C94 __catchsym$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:00012C94                                         ; DATA XREF: .xdata$x:00012CC4o
.xdata$x:00012C95                 db    0
.xdata$x:00012C96                 db    0
.xdata$x:00012C97                 db    0
.xdata$x:00012C98                 db    0
.xdata$x:00012C99                 db    0
.xdata$x:00012C9A                 db    0
.xdata$x:00012C9B                 db    0
.xdata$x:00012C9C                 db    0
.xdata$x:00012C9D                 db    0
.xdata$x:00012C9E                 db    0
.xdata$x:00012C9F                 db    0
.xdata$x:00012CA0                 dd offset __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0
.xdata$x:00012CA4 __unwindtable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:00012CA4                                         ; DATA XREF: .xdata$x:00012CD0o
.xdata$x:00012CA5                 db 0FFh
.xdata$x:00012CA6                 db 0FFh
.xdata$x:00012CA7                 db 0FFh
.xdata$x:00012CA8                 db    0
.xdata$x:00012CA9                 db    0
.xdata$x:00012CAA                 db    0
.xdata$x:00012CAB                 db    0
.xdata$x:00012CAC                 db 0FFh
.xdata$x:00012CAD                 db 0FFh
.xdata$x:00012CAE                 db 0FFh
.xdata$x:00012CAF                 db 0FFh
.xdata$x:00012CB0                 db    0
.xdata$x:00012CB1                 db    0
.xdata$x:00012CB2                 db    0
.xdata$x:00012CB3                 db    0
.xdata$x:00012CB4 __tryblocktable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z db    0
.xdata$x:00012CB4                                         ; DATA XREF: .xdata$x:00012CD8o
.xdata$x:00012CB5                 db    0
.xdata$x:00012CB6                 db    0
.xdata$x:00012CB7                 db    0
.xdata$x:00012CB8                 db    0
.xdata$x:00012CB9                 db    0
.xdata$x:00012CBA                 db    0
.xdata$x:00012CBB                 db    0
.xdata$x:00012CBC                 db    1
.xdata$x:00012CBD                 db    0
.xdata$x:00012CBE                 db    0
.xdata$x:00012CBF                 db    0
.xdata$x:00012CC0                 db    1
.xdata$x:00012CC1                 db    0
.xdata$x:00012CC2                 db    0
.xdata$x:00012CC3                 db    0
.xdata$x:00012CC4                 dd offset __catchsym$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$2
.xdata$x:00012CC8 __ehfuncinfo$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:00012CC8                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z+11o
.xdata$x:00012CC9                 db    5
.xdata$x:00012CCA                 db  93h ; ô
.xdata$x:00012CCB                 db  19h
.xdata$x:00012CCC                 db    2
.xdata$x:00012CCD                 db    0
.xdata$x:00012CCE                 db    0
.xdata$x:00012CCF                 db    0
.xdata$x:00012CD0                 dd offset __unwindtable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.xdata$x:00012CD4                 db    1
.xdata$x:00012CD5                 db    0
.xdata$x:00012CD6                 db    0
.xdata$x:00012CD7                 db    0
.xdata$x:00012CD8                 dd offset __tryblocktable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.xdata$x:00012CDC                 db    0
.xdata$x:00012CDD                 db    0
.xdata$x:00012CDE                 db    0
.xdata$x:00012CDF                 db    0
.xdata$x:00012CE0                 db    0
.xdata$x:00012CE1                 db    0
.xdata$x:00012CE2                 db    0
.xdata$x:00012CE3                 db    0
.xdata$x:00012CE4                 db    0
.xdata$x:00012CE5                 db    0
.xdata$x:00012CE6                 db    0
.xdata$x:00012CE7                 db    0
.xdata$x:00012CE8                 db    0
.xdata$x:00012CE9                 db    0
.xdata$x:00012CEA                 db    0
.xdata$x:00012CEB                 db    0
.xdata$x:00012CEB _xdata$x        ends
.xdata$x:00012CEB
.xdata$x:00012CEC ; ===========================================================================
.xdata$x:00012CEC
.xdata$x:00012CEC ; Segment type: Pure data
.xdata$x:00012CEC ; Segment permissions: Read
.xdata$x:00012CEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012CEC                 assume cs:_xdata$x
.xdata$x:00012CEC                 ;org 12CECh
.xdata$x:00012CEC ; COMDAT (pick associative to section at E44C)
.xdata$x:00012CEC __unwindtable$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z db 0FFh
.xdata$x:00012CEC                                         ; DATA XREF: .xdata$x:00012CFCo
.xdata$x:00012CED                 db 0FFh
.xdata$x:00012CEE                 db 0FFh
.xdata$x:00012CEF                 db 0FFh
.xdata$x:00012CF0                 dd offset __unwindfunclet$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z$0
.xdata$x:00012CF4 __ehfuncinfo$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z db  22h ; "
.xdata$x:00012CF4                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z+11o
.xdata$x:00012CF5                 db    5
.xdata$x:00012CF6                 db  93h ; ô
.xdata$x:00012CF7                 db  19h
.xdata$x:00012CF8                 db    1
.xdata$x:00012CF9                 db    0
.xdata$x:00012CFA                 db    0
.xdata$x:00012CFB                 db    0
.xdata$x:00012CFC                 dd offset __unwindtable$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.xdata$x:00012D00                 db    0
.xdata$x:00012D01                 db    0
.xdata$x:00012D02                 db    0
.xdata$x:00012D03                 db    0
.xdata$x:00012D04                 db    0
.xdata$x:00012D05                 db    0
.xdata$x:00012D06                 db    0
.xdata$x:00012D07                 db    0
.xdata$x:00012D08                 db    0
.xdata$x:00012D09                 db    0
.xdata$x:00012D0A                 db    0
.xdata$x:00012D0B                 db    0
.xdata$x:00012D0C                 db    0
.xdata$x:00012D0D                 db    0
.xdata$x:00012D0E                 db    0
.xdata$x:00012D0F                 db    0
.xdata$x:00012D10                 db    0
.xdata$x:00012D11                 db    0
.xdata$x:00012D12                 db    0
.xdata$x:00012D13                 db    0
.xdata$x:00012D14                 db    0
.xdata$x:00012D15                 db    0
.xdata$x:00012D16                 db    0
.xdata$x:00012D17                 db    0
.xdata$x:00012D17 _xdata$x        ends
.xdata$x:00012D17
.xdata$x:00012D18 ; ===========================================================================
.xdata$x:00012D18
.xdata$x:00012D18 ; Segment type: Pure data
.xdata$x:00012D18 ; Segment permissions: Read
.xdata$x:00012D18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012D18                 assume cs:_xdata$x
.xdata$x:00012D18                 ;org 12D18h
.xdata$x:00012D18 ; COMDAT (pick associative to section at AFF4)
.xdata$x:00012D18 __ehfuncinfo$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z db  22h ; "
.xdata$x:00012D18                                         ; DATA XREF: __ehhandler$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z+11o
.xdata$x:00012D19                 db    5
.xdata$x:00012D1A                 db  93h ; ô
.xdata$x:00012D1B                 db  19h
.xdata$x:00012D1C                 db    6
.xdata$x:00012D1D                 db    0
.xdata$x:00012D1E                 db    0
.xdata$x:00012D1F                 db    0
.xdata$x:00012D20                 dd offset __unwindtable$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
.xdata$x:00012D24                 db    0
.xdata$x:00012D25                 db    0
.xdata$x:00012D26                 db    0
.xdata$x:00012D27                 db    0
.xdata$x:00012D28                 db    0
.xdata$x:00012D29                 db    0
.xdata$x:00012D2A                 db    0
.xdata$x:00012D2B                 db    0
.xdata$x:00012D2C                 db    0
.xdata$x:00012D2D                 db    0
.xdata$x:00012D2E                 db    0
.xdata$x:00012D2F                 db    0
.xdata$x:00012D30                 db    0
.xdata$x:00012D31                 db    0
.xdata$x:00012D32                 db    0
.xdata$x:00012D33                 db    0
.xdata$x:00012D34                 db    0
.xdata$x:00012D35                 db    0
.xdata$x:00012D36                 db    0
.xdata$x:00012D37                 db    0
.xdata$x:00012D38                 db    0
.xdata$x:00012D39                 db    0
.xdata$x:00012D3A                 db    0
.xdata$x:00012D3B                 db    0
.xdata$x:00012D3C __unwindtable$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z db 0FFh
.xdata$x:00012D3C                                         ; DATA XREF: .xdata$x:00012D20o
.xdata$x:00012D3D                 db 0FFh
.xdata$x:00012D3E                 db 0FFh
.xdata$x:00012D3F                 db 0FFh
.xdata$x:00012D40                 dd offset __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$0
.xdata$x:00012D44                 align 8
.xdata$x:00012D48                 dd offset __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$1
.xdata$x:00012D4C                 db    1
.xdata$x:00012D4D                 db    0
.xdata$x:00012D4E                 db    0
.xdata$x:00012D4F                 db    0
.xdata$x:00012D50                 dd offset __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$2
.xdata$x:00012D54                 db    2
.xdata$x:00012D55                 db    0
.xdata$x:00012D56                 db    0
.xdata$x:00012D57                 db    0
.xdata$x:00012D58                 dd offset __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$3
.xdata$x:00012D5C                 db    3
.xdata$x:00012D5D                 db    0
.xdata$x:00012D5E                 db    0
.xdata$x:00012D5F                 db    0
.xdata$x:00012D60                 dd offset __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$4
.xdata$x:00012D64                 db    4
.xdata$x:00012D65                 db    0
.xdata$x:00012D66                 db    0
.xdata$x:00012D67                 db    0
.xdata$x:00012D68                 dd offset __unwindfunclet$??0sessionFileInfo@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$5
.xdata$x:00012D68 _xdata$x        ends
.xdata$x:00012D68
.xdata$x:00012D6C ; ===========================================================================
.xdata$x:00012D6C
.xdata$x:00012D6C ; Segment type: Pure data
.xdata$x:00012D6C ; Segment permissions: Read
.xdata$x:00012D6C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012D6C                 assume cs:_xdata$x
.xdata$x:00012D6C                 ;org 12D6Ch
.xdata$x:00012D6C ; COMDAT (pick associative to section at 9E64)
.xdata$x:00012D6C __unwindtable$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00012D6C                                         ; DATA XREF: .xdata$x:00012D7Co
.xdata$x:00012D6D                 db 0FFh
.xdata$x:00012D6E                 db 0FFh
.xdata$x:00012D6F                 db 0FFh
.xdata$x:00012D70                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ$0
.xdata$x:00012D74 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00012D74                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ+11o
.xdata$x:00012D75                 db    5
.xdata$x:00012D76                 db  93h ; ô
.xdata$x:00012D77                 db  19h
.xdata$x:00012D78                 db    1
.xdata$x:00012D79                 db    0
.xdata$x:00012D7A                 db    0
.xdata$x:00012D7B                 db    0
.xdata$x:00012D7C                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.xdata$x:00012D80                 db    0
.xdata$x:00012D81                 db    0
.xdata$x:00012D82                 db    0
.xdata$x:00012D83                 db    0
.xdata$x:00012D84                 db    0
.xdata$x:00012D85                 db    0
.xdata$x:00012D86                 db    0
.xdata$x:00012D87                 db    0
.xdata$x:00012D88                 db    0
.xdata$x:00012D89                 db    0
.xdata$x:00012D8A                 db    0
.xdata$x:00012D8B                 db    0
.xdata$x:00012D8C                 db    0
.xdata$x:00012D8D                 db    0
.xdata$x:00012D8E                 db    0
.xdata$x:00012D8F                 db    0
.xdata$x:00012D90                 db    0
.xdata$x:00012D91                 db    0
.xdata$x:00012D92                 db    0
.xdata$x:00012D93                 db    0
.xdata$x:00012D94                 db    0
.xdata$x:00012D95                 db    0
.xdata$x:00012D96                 db    0
.xdata$x:00012D97                 db    0
.xdata$x:00012D97 _xdata$x        ends
.xdata$x:00012D97
.xdata$x:00012D98 ; ===========================================================================
.xdata$x:00012D98
.xdata$x:00012D98 ; Segment type: Pure data
.xdata$x:00012D98 ; Segment permissions: Read
.xdata$x:00012D98 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012D98                 assume cs:_xdata$x
.xdata$x:00012D98                 ;org 12D98h
.xdata$x:00012D98 ; COMDAT (pick associative to section at B984)
.xdata$x:00012D98 __unwindtable$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00012D98                                         ; DATA XREF: .xdata$x:00012DA8o
.xdata$x:00012D99                 db 0FFh
.xdata$x:00012D9A                 db 0FFh
.xdata$x:00012D9B                 db 0FFh
.xdata$x:00012D9C                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ$0
.xdata$x:00012DA0 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00012DA0                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ+11o
.xdata$x:00012DA1                 db    5
.xdata$x:00012DA2                 db  93h ; ô
.xdata$x:00012DA3                 db  19h
.xdata$x:00012DA4                 db    1
.xdata$x:00012DA5                 db    0
.xdata$x:00012DA6                 db    0
.xdata$x:00012DA7                 db    0
.xdata$x:00012DA8                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.xdata$x:00012DAC                 db    0
.xdata$x:00012DAD                 db    0
.xdata$x:00012DAE                 db    0
.xdata$x:00012DAF                 db    0
.xdata$x:00012DB0                 db    0
.xdata$x:00012DB1                 db    0
.xdata$x:00012DB2                 db    0
.xdata$x:00012DB3                 db    0
.xdata$x:00012DB4                 db    0
.xdata$x:00012DB5                 db    0
.xdata$x:00012DB6                 db    0
.xdata$x:00012DB7                 db    0
.xdata$x:00012DB8                 db    0
.xdata$x:00012DB9                 db    0
.xdata$x:00012DBA                 db    0
.xdata$x:00012DBB                 db    0
.xdata$x:00012DBC                 db    0
.xdata$x:00012DBD                 db    0
.xdata$x:00012DBE                 db    0
.xdata$x:00012DBF                 db    0
.xdata$x:00012DC0                 db    0
.xdata$x:00012DC1                 db    0
.xdata$x:00012DC2                 db    0
.xdata$x:00012DC3                 db    0
.xdata$x:00012DC3 _xdata$x        ends
.xdata$x:00012DC3
.xdata$x:00012DC4 ; ===========================================================================
.xdata$x:00012DC4
.xdata$x:00012DC4 ; Segment type: Pure data
.xdata$x:00012DC4 ; Segment permissions: Read
.xdata$x:00012DC4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012DC4                 assume cs:_xdata$x
.xdata$x:00012DC4                 ;org 12DC4h
.xdata$x:00012DC4 ; COMDAT (pick associative to section at 98C0)
.xdata$x:00012DC4 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z db 0FFh
.xdata$x:00012DC4                                         ; DATA XREF: .xdata$x:00012DD4o
.xdata$x:00012DC5                 db 0FFh
.xdata$x:00012DC6                 db 0FFh
.xdata$x:00012DC7                 db 0FFh
.xdata$x:00012DC8                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z$0
.xdata$x:00012DCC __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z db  22h ; "
.xdata$x:00012DCC                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z+11o
.xdata$x:00012DCD                 db    5
.xdata$x:00012DCE                 db  93h ; ô
.xdata$x:00012DCF                 db  19h
.xdata$x:00012DD0                 db    1
.xdata$x:00012DD1                 db    0
.xdata$x:00012DD2                 db    0
.xdata$x:00012DD3                 db    0
.xdata$x:00012DD4                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
.xdata$x:00012DD8                 db    0
.xdata$x:00012DD9                 db    0
.xdata$x:00012DDA                 db    0
.xdata$x:00012DDB                 db    0
.xdata$x:00012DDC                 db    0
.xdata$x:00012DDD                 db    0
.xdata$x:00012DDE                 db    0
.xdata$x:00012DDF                 db    0
.xdata$x:00012DE0                 db    0
.xdata$x:00012DE1                 db    0
.xdata$x:00012DE2                 db    0
.xdata$x:00012DE3                 db    0
.xdata$x:00012DE4                 db    0
.xdata$x:00012DE5                 db    0
.xdata$x:00012DE6                 db    0
.xdata$x:00012DE7                 db    0
.xdata$x:00012DE8                 db    0
.xdata$x:00012DE9                 db    0
.xdata$x:00012DEA                 db    0
.xdata$x:00012DEB                 db    0
.xdata$x:00012DEC                 db    0
.xdata$x:00012DED                 db    0
.xdata$x:00012DEE                 db    0
.xdata$x:00012DEF                 db    0
.xdata$x:00012DEF _xdata$x        ends
.xdata$x:00012DEF
.xdata$x:00012DF0 ; ===========================================================================
.xdata$x:00012DF0
.xdata$x:00012DF0 ; Segment type: Pure data
.xdata$x:00012DF0 ; Segment permissions: Read
.xdata$x:00012DF0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012DF0                 assume cs:_xdata$x
.xdata$x:00012DF0                 ;org 12DF0h
.xdata$x:00012DF0 ; COMDAT (pick associative to section at B5EC)
.xdata$x:00012DF0 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00012DF0                                         ; DATA XREF: .xdata$x:00012E00o
.xdata$x:00012DF1                 db 0FFh
.xdata$x:00012DF2                 db 0FFh
.xdata$x:00012DF3                 db 0FFh
.xdata$x:00012DF4                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00012DF8 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00012DF8                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00012DF9                 db    5
.xdata$x:00012DFA                 db  93h ; ô
.xdata$x:00012DFB                 db  19h
.xdata$x:00012DFC                 db    1
.xdata$x:00012DFD                 db    0
.xdata$x:00012DFE                 db    0
.xdata$x:00012DFF                 db    0
.xdata$x:00012E00                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.xdata$x:00012E04                 db    0
.xdata$x:00012E05                 db    0
.xdata$x:00012E06                 db    0
.xdata$x:00012E07                 db    0
.xdata$x:00012E08                 db    0
.xdata$x:00012E09                 db    0
.xdata$x:00012E0A                 db    0
.xdata$x:00012E0B                 db    0
.xdata$x:00012E0C                 db    0
.xdata$x:00012E0D                 db    0
.xdata$x:00012E0E                 db    0
.xdata$x:00012E0F                 db    0
.xdata$x:00012E10                 db    0
.xdata$x:00012E11                 db    0
.xdata$x:00012E12                 db    0
.xdata$x:00012E13                 db    0
.xdata$x:00012E14                 db    0
.xdata$x:00012E15                 db    0
.xdata$x:00012E16                 db    0
.xdata$x:00012E17                 db    0
.xdata$x:00012E18                 db    0
.xdata$x:00012E19                 db    0
.xdata$x:00012E1A                 db    0
.xdata$x:00012E1B                 db    0
.xdata$x:00012E1B _xdata$x        ends
.xdata$x:00012E1B
.xdata$x:00012E1C ; ===========================================================================
.xdata$x:00012E1C
.xdata$x:00012E1C ; Segment type: Pure data
.xdata$x:00012E1C ; Segment permissions: Read
.xdata$x:00012E1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012E1C                 assume cs:_xdata$x
.xdata$x:00012E1C                 ;org 12E1Ch
.xdata$x:00012E1C ; COMDAT (pick associative to section at A7C0)
.xdata$x:00012E1C __unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00012E1C                                         ; DATA XREF: .xdata$x:00012E2Co
.xdata$x:00012E1D                 db 0FFh
.xdata$x:00012E1E                 db 0FFh
.xdata$x:00012E1F                 db 0FFh
.xdata$x:00012E20                 dd offset __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0
.xdata$x:00012E24 __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00012E24                                         ; DATA XREF: __ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ+11o
.xdata$x:00012E25                 db    5
.xdata$x:00012E26                 db  93h ; ô
.xdata$x:00012E27                 db  19h
.xdata$x:00012E28                 db    1
.xdata$x:00012E29                 db    0
.xdata$x:00012E2A                 db    0
.xdata$x:00012E2B                 db    0
.xdata$x:00012E2C                 dd offset __unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.xdata$x:00012E30                 db    0
.xdata$x:00012E31                 db    0
.xdata$x:00012E32                 db    0
.xdata$x:00012E33                 db    0
.xdata$x:00012E34                 db    0
.xdata$x:00012E35                 db    0
.xdata$x:00012E36                 db    0
.xdata$x:00012E37                 db    0
.xdata$x:00012E38                 db    0
.xdata$x:00012E39                 db    0
.xdata$x:00012E3A                 db    0
.xdata$x:00012E3B                 db    0
.xdata$x:00012E3C                 db    0
.xdata$x:00012E3D                 db    0
.xdata$x:00012E3E                 db    0
.xdata$x:00012E3F                 db    0
.xdata$x:00012E40                 db    0
.xdata$x:00012E41                 db    0
.xdata$x:00012E42                 db    0
.xdata$x:00012E43                 db    0
.xdata$x:00012E44                 db    0
.xdata$x:00012E45                 db    0
.xdata$x:00012E46                 db    0
.xdata$x:00012E47                 db    0
.xdata$x:00012E47 _xdata$x        ends
.xdata$x:00012E47
.xdata$x:00012E48 ; ===========================================================================
.xdata$x:00012E48
.xdata$x:00012E48 ; Segment type: Pure data
.xdata$x:00012E48 ; Segment permissions: Read
.xdata$x:00012E48 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012E48                 assume cs:_xdata$x
.xdata$x:00012E48                 ;org 12E48h
.xdata$x:00012E48 ; COMDAT (pick associative to section at A674)
.xdata$x:00012E48 __catchsym$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$5 db    0
.xdata$x:00012E48                                         ; DATA XREF: .xdata$x:00012E68o
.xdata$x:00012E49                 db    0
.xdata$x:00012E4A                 db    0
.xdata$x:00012E4B                 db    0
.xdata$x:00012E4C                 db    0
.xdata$x:00012E4D                 db    0
.xdata$x:00012E4E                 db    0
.xdata$x:00012E4F                 db    0
.xdata$x:00012E50                 db    0
.xdata$x:00012E51                 db    0
.xdata$x:00012E52                 db    0
.xdata$x:00012E53                 db    0
.xdata$x:00012E54                 dd offset __catch$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00012E58 __tryblocktable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z db    1
.xdata$x:00012E58                                         ; DATA XREF: .xdata$x:00012E7Co
.xdata$x:00012E59                 db    0
.xdata$x:00012E5A                 db    0
.xdata$x:00012E5B                 db    0
.xdata$x:00012E5C                 db    3
.xdata$x:00012E5D                 db    0
.xdata$x:00012E5E                 db    0
.xdata$x:00012E5F                 db    0
.xdata$x:00012E60                 db    4
.xdata$x:00012E61                 db    0
.xdata$x:00012E62                 db    0
.xdata$x:00012E63                 db    0
.xdata$x:00012E64                 db    1
.xdata$x:00012E65                 db    0
.xdata$x:00012E66                 db    0
.xdata$x:00012E67                 db    0
.xdata$x:00012E68                 dd offset __catchsym$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$5
.xdata$x:00012E6C __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00012E6C                                         ; DATA XREF: __ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00012E6D                 db    5
.xdata$x:00012E6E                 db  93h ; ô
.xdata$x:00012E6F                 db  19h
.xdata$x:00012E70                 db    5
.xdata$x:00012E71                 db    0
.xdata$x:00012E72                 db    0
.xdata$x:00012E73                 db    0
.xdata$x:00012E74                 dd offset __unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
.xdata$x:00012E78                 db    1
.xdata$x:00012E79                 db    0
.xdata$x:00012E7A                 db    0
.xdata$x:00012E7B                 db    0
.xdata$x:00012E7C                 dd offset __tryblocktable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
.xdata$x:00012E80                 db    0
.xdata$x:00012E81                 db    0
.xdata$x:00012E82                 db    0
.xdata$x:00012E83                 db    0
.xdata$x:00012E84                 db    0
.xdata$x:00012E85                 db    0
.xdata$x:00012E86                 db    0
.xdata$x:00012E87                 db    0
.xdata$x:00012E88                 db    0
.xdata$x:00012E89                 db    0
.xdata$x:00012E8A                 db    0
.xdata$x:00012E8B                 db    0
.xdata$x:00012E8C                 db    0
.xdata$x:00012E8D                 db    0
.xdata$x:00012E8E                 db    0
.xdata$x:00012E8F                 db    0
.xdata$x:00012E90 __unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00012E90                                         ; DATA XREF: .xdata$x:00012E74o
.xdata$x:00012E91                 db 0FFh
.xdata$x:00012E92                 db 0FFh
.xdata$x:00012E93                 db 0FFh
.xdata$x:00012E94                 dd offset __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$2
.xdata$x:00012E98                 align 10h
.xdata$x:00012EA0                 db    1
.xdata$x:00012EA1                 db    0
.xdata$x:00012EA2                 db    0
.xdata$x:00012EA3                 db    0
.xdata$x:00012EA4                 dd offset __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$3
.xdata$x:00012EA8                 db    2
.xdata$x:00012EA9                 db    0
.xdata$x:00012EAA                 db    0
.xdata$x:00012EAB                 db    0
.xdata$x:00012EAC                 dd offset __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$4
.xdata$x:00012EB0                 db    0
.xdata$x:00012EB1                 db    0
.xdata$x:00012EB2                 db    0
.xdata$x:00012EB3                 db    0
.xdata$x:00012EB4                 db    0
.xdata$x:00012EB5                 db    0
.xdata$x:00012EB6                 db    0
.xdata$x:00012EB7                 db    0
.xdata$x:00012EB7 _xdata$x        ends
.xdata$x:00012EB7
.xdata$x:00012EB8 ; ===========================================================================
.xdata$x:00012EB8
.xdata$x:00012EB8 ; Segment type: Pure data
.xdata$x:00012EB8 ; Segment permissions: Read
.xdata$x:00012EB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012EB8                 assume cs:_xdata$x
.xdata$x:00012EB8                 ;org 12EB8h
.xdata$x:00012EB8 ; COMDAT (pick associative to section at BC44)
.xdata$x:00012EB8 __unwindtable$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00012EB8                                         ; DATA XREF: .xdata$x:00012EC8o
.xdata$x:00012EB9                 db 0FFh
.xdata$x:00012EBA                 db 0FFh
.xdata$x:00012EBB                 db 0FFh
.xdata$x:00012EBC                 dd offset __unwindfunclet$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0
.xdata$x:00012EC0 __ehfuncinfo$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00012EC0                                         ; DATA XREF: __ehhandler$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ+11o
.xdata$x:00012EC1                 db    5
.xdata$x:00012EC2                 db  93h ; ô
.xdata$x:00012EC3                 db  19h
.xdata$x:00012EC4                 db    1
.xdata$x:00012EC5                 db    0
.xdata$x:00012EC6                 db    0
.xdata$x:00012EC7                 db    0
.xdata$x:00012EC8                 dd offset __unwindtable$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.xdata$x:00012ECC                 db    0
.xdata$x:00012ECD                 db    0
.xdata$x:00012ECE                 db    0
.xdata$x:00012ECF                 db    0
.xdata$x:00012ED0                 db    0
.xdata$x:00012ED1                 db    0
.xdata$x:00012ED2                 db    0
.xdata$x:00012ED3                 db    0
.xdata$x:00012ED4                 db    0
.xdata$x:00012ED5                 db    0
.xdata$x:00012ED6                 db    0
.xdata$x:00012ED7                 db    0
.xdata$x:00012ED8                 db    0
.xdata$x:00012ED9                 db    0
.xdata$x:00012EDA                 db    0
.xdata$x:00012EDB                 db    0
.xdata$x:00012EDC                 db    0
.xdata$x:00012EDD                 db    0
.xdata$x:00012EDE                 db    0
.xdata$x:00012EDF                 db    0
.xdata$x:00012EE0                 db    0
.xdata$x:00012EE1                 db    0
.xdata$x:00012EE2                 db    0
.xdata$x:00012EE3                 db    0
.xdata$x:00012EE3 _xdata$x        ends
.xdata$x:00012EE3
.xdata$x:00012EE4 ; ===========================================================================
.xdata$x:00012EE4
.xdata$x:00012EE4 ; Segment type: Pure data
.xdata$x:00012EE4 ; Segment permissions: Read
.xdata$x:00012EE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012EE4                 assume cs:_xdata$x
.xdata$x:00012EE4                 ;org 12EE4h
.xdata$x:00012EE4 ; COMDAT (pick associative to section at C2E4)
.xdata$x:00012EE4 __catchsym$??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z$2 db    0
.xdata$x:00012EE4                                         ; DATA XREF: .xdata$x:00012F14o
.xdata$x:00012EE5                 db    0
.xdata$x:00012EE6                 db    0
.xdata$x:00012EE7                 db    0
.xdata$x:00012EE8                 db    0
.xdata$x:00012EE9                 db    0
.xdata$x:00012EEA                 db    0
.xdata$x:00012EEB                 db    0
.xdata$x:00012EEC                 db    0
.xdata$x:00012EED                 db    0
.xdata$x:00012EEE                 db    0
.xdata$x:00012EEF                 db    0
.xdata$x:00012EF0                 dd offset __catch$??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z$0
.xdata$x:00012EF4 __unwindtable$??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z db 0FFh
.xdata$x:00012EF4                                         ; DATA XREF: .xdata$x:00012F20o
.xdata$x:00012EF5                 db 0FFh
.xdata$x:00012EF6                 db 0FFh
.xdata$x:00012EF7                 db 0FFh
.xdata$x:00012EF8                 db    0
.xdata$x:00012EF9                 db    0
.xdata$x:00012EFA                 db    0
.xdata$x:00012EFB                 db    0
.xdata$x:00012EFC                 db 0FFh
.xdata$x:00012EFD                 db 0FFh
.xdata$x:00012EFE                 db 0FFh
.xdata$x:00012EFF                 db 0FFh
.xdata$x:00012F00                 db    0
.xdata$x:00012F01                 db    0
.xdata$x:00012F02                 db    0
.xdata$x:00012F03                 db    0
.xdata$x:00012F04 __tryblocktable$??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z db    0
.xdata$x:00012F04                                         ; DATA XREF: .xdata$x:00012F28o
.xdata$x:00012F05                 db    0
.xdata$x:00012F06                 db    0
.xdata$x:00012F07                 db    0
.xdata$x:00012F08                 db    0
.xdata$x:00012F09                 db    0
.xdata$x:00012F0A                 db    0
.xdata$x:00012F0B                 db    0
.xdata$x:00012F0C                 db    1
.xdata$x:00012F0D                 db    0
.xdata$x:00012F0E                 db    0
.xdata$x:00012F0F                 db    0
.xdata$x:00012F10                 db    1
.xdata$x:00012F11                 db    0
.xdata$x:00012F12                 db    0
.xdata$x:00012F13                 db    0
.xdata$x:00012F14                 dd offset __catchsym$??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z$2
.xdata$x:00012F18 __ehfuncinfo$??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z db  22h ; "
.xdata$x:00012F18                                         ; DATA XREF: __ehhandler$??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z+11o
.xdata$x:00012F19                 db    5
.xdata$x:00012F1A                 db  93h ; ô
.xdata$x:00012F1B                 db  19h
.xdata$x:00012F1C                 db    2
.xdata$x:00012F1D                 db    0
.xdata$x:00012F1E                 db    0
.xdata$x:00012F1F                 db    0
.xdata$x:00012F20                 dd offset __unwindtable$??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
.xdata$x:00012F24                 db    1
.xdata$x:00012F25                 db    0
.xdata$x:00012F26                 db    0
.xdata$x:00012F27                 db    0
.xdata$x:00012F28                 dd offset __tryblocktable$??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
.xdata$x:00012F2C                 db    0
.xdata$x:00012F2D                 db    0
.xdata$x:00012F2E                 db    0
.xdata$x:00012F2F                 db    0
.xdata$x:00012F30                 db    0
.xdata$x:00012F31                 db    0
.xdata$x:00012F32                 db    0
.xdata$x:00012F33                 db    0
.xdata$x:00012F34                 db    0
.xdata$x:00012F35                 db    0
.xdata$x:00012F36                 db    0
.xdata$x:00012F37                 db    0
.xdata$x:00012F38                 db    0
.xdata$x:00012F39                 db    0
.xdata$x:00012F3A                 db    0
.xdata$x:00012F3B                 db    0
.xdata$x:00012F3B _xdata$x        ends
.xdata$x:00012F3B
.xdata$x:00012F3C ; ===========================================================================
.xdata$x:00012F3C
.xdata$x:00012F3C ; Segment type: Pure data
.xdata$x:00012F3C ; Segment permissions: Read
.xdata$x:00012F3C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012F3C                 assume cs:_xdata$x
.xdata$x:00012F3C                 ;org 12F3Ch
.xdata$x:00012F3C ; COMDAT (pick associative to section at F98C)
.xdata$x:00012F3C __unwindtable$?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ db 0FFh
.xdata$x:00012F3C                                         ; DATA XREF: .xdata$x:00012F4Co
.xdata$x:00012F3D                 db 0FFh
.xdata$x:00012F3E                 db 0FFh
.xdata$x:00012F3F                 db 0FFh
.xdata$x:00012F40                 dd offset __unwindfunclet$?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ$0
.xdata$x:00012F44 __ehfuncinfo$?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00012F44                                         ; DATA XREF: __ehhandler$?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ+11o
.xdata$x:00012F45                 db    5
.xdata$x:00012F46                 db  93h ; ô
.xdata$x:00012F47                 db  19h
.xdata$x:00012F48                 db    1
.xdata$x:00012F49                 db    0
.xdata$x:00012F4A                 db    0
.xdata$x:00012F4B                 db    0
.xdata$x:00012F4C                 dd offset __unwindtable$?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
.xdata$x:00012F50                 db    0
.xdata$x:00012F51                 db    0
.xdata$x:00012F52                 db    0
.xdata$x:00012F53                 db    0
.xdata$x:00012F54                 db    0
.xdata$x:00012F55                 db    0
.xdata$x:00012F56                 db    0
.xdata$x:00012F57                 db    0
.xdata$x:00012F58                 db    0
.xdata$x:00012F59                 db    0
.xdata$x:00012F5A                 db    0
.xdata$x:00012F5B                 db    0
.xdata$x:00012F5C                 db    0
.xdata$x:00012F5D                 db    0
.xdata$x:00012F5E                 db    0
.xdata$x:00012F5F                 db    0
.xdata$x:00012F60                 db    0
.xdata$x:00012F61                 db    0
.xdata$x:00012F62                 db    0
.xdata$x:00012F63                 db    0
.xdata$x:00012F64                 db    0
.xdata$x:00012F65                 db    0
.xdata$x:00012F66                 db    0
.xdata$x:00012F67                 db    0
.xdata$x:00012F67 _xdata$x        ends
.xdata$x:00012F67
.xdata$x:00012F68 ; ===========================================================================
.xdata$x:00012F68
.xdata$x:00012F68 ; Segment type: Pure data
.xdata$x:00012F68 ; Segment permissions: Read
.xdata$x:00012F68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012F68                 assume cs:_xdata$x
.xdata$x:00012F68                 ;org 12F68h
.xdata$x:00012F68 ; COMDAT (pick associative to section at 10374)
.xdata$x:00012F68 __unwindtable$?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ db 0FFh
.xdata$x:00012F68                                         ; DATA XREF: .xdata$x:00012F78o
.xdata$x:00012F69                 db 0FFh
.xdata$x:00012F6A                 db 0FFh
.xdata$x:00012F6B                 db 0FFh
.xdata$x:00012F6C                 dd offset __unwindfunclet$?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ$0
.xdata$x:00012F70 __ehfuncinfo$?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00012F70                                         ; DATA XREF: __ehhandler$?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ+11o
.xdata$x:00012F71                 db    5
.xdata$x:00012F72                 db  93h ; ô
.xdata$x:00012F73                 db  19h
.xdata$x:00012F74                 db    1
.xdata$x:00012F75                 db    0
.xdata$x:00012F76                 db    0
.xdata$x:00012F77                 db    0
.xdata$x:00012F78                 dd offset __unwindtable$?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
.xdata$x:00012F7C                 db    0
.xdata$x:00012F7D                 db    0
.xdata$x:00012F7E                 db    0
.xdata$x:00012F7F                 db    0
.xdata$x:00012F80                 db    0
.xdata$x:00012F81                 db    0
.xdata$x:00012F82                 db    0
.xdata$x:00012F83                 db    0
.xdata$x:00012F84                 db    0
.xdata$x:00012F85                 db    0
.xdata$x:00012F86                 db    0
.xdata$x:00012F87                 db    0
.xdata$x:00012F88                 db    0
.xdata$x:00012F89                 db    0
.xdata$x:00012F8A                 db    0
.xdata$x:00012F8B                 db    0
.xdata$x:00012F8C                 db    0
.xdata$x:00012F8D                 db    0
.xdata$x:00012F8E                 db    0
.xdata$x:00012F8F                 db    0
.xdata$x:00012F90                 db    0
.xdata$x:00012F91                 db    0
.xdata$x:00012F92                 db    0
.xdata$x:00012F93                 db    0
.xdata$x:00012F93 _xdata$x        ends
.xdata$x:00012F93
.xdata$x:00012F94 ; ===========================================================================
.xdata$x:00012F94
.xdata$x:00012F94 ; Segment type: Pure data
.xdata$x:00012F94 ; Segment permissions: Read
.xdata$x:00012F94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012F94                 assume cs:_xdata$x
.xdata$x:00012F94                 ;org 12F94h
.xdata$x:00012F94 ; COMDAT (pick associative to section at C03C)
.xdata$x:00012F94 __ehfuncinfo$??1sessionFileInfo@@QAE@XZ db  22h ; "
.xdata$x:00012F94                                         ; DATA XREF: __ehhandler$??1sessionFileInfo@@QAE@XZ+11o
.xdata$x:00012F95                 db    5
.xdata$x:00012F96                 db  93h ; ô
.xdata$x:00012F97                 db  19h
.xdata$x:00012F98                 db    5
.xdata$x:00012F99                 db    0
.xdata$x:00012F9A                 db    0
.xdata$x:00012F9B                 db    0
.xdata$x:00012F9C                 dd offset __unwindtable$??1sessionFileInfo@@QAE@XZ
.xdata$x:00012FA0                 db    0
.xdata$x:00012FA1                 db    0
.xdata$x:00012FA2                 db    0
.xdata$x:00012FA3                 db    0
.xdata$x:00012FA4                 db    0
.xdata$x:00012FA5                 db    0
.xdata$x:00012FA6                 db    0
.xdata$x:00012FA7                 db    0
.xdata$x:00012FA8                 db    0
.xdata$x:00012FA9                 db    0
.xdata$x:00012FAA                 db    0
.xdata$x:00012FAB                 db    0
.xdata$x:00012FAC                 db    0
.xdata$x:00012FAD                 db    0
.xdata$x:00012FAE                 db    0
.xdata$x:00012FAF                 db    0
.xdata$x:00012FB0                 db    0
.xdata$x:00012FB1                 db    0
.xdata$x:00012FB2                 db    0
.xdata$x:00012FB3                 db    0
.xdata$x:00012FB4                 db    0
.xdata$x:00012FB5                 db    0
.xdata$x:00012FB6                 db    0
.xdata$x:00012FB7                 db    0
.xdata$x:00012FB8 __unwindtable$??1sessionFileInfo@@QAE@XZ db 0FFh
.xdata$x:00012FB8                                         ; DATA XREF: .xdata$x:00012F9Co
.xdata$x:00012FB9                 db 0FFh
.xdata$x:00012FBA                 db 0FFh
.xdata$x:00012FBB                 db 0FFh
.xdata$x:00012FBC                 dd offset __unwindfunclet$??1sessionFileInfo@@QAE@XZ$0
.xdata$x:00012FC0                 db    0
.xdata$x:00012FC1                 db    0
.xdata$x:00012FC2                 db    0
.xdata$x:00012FC3                 db    0
.xdata$x:00012FC4                 dd offset __unwindfunclet$??1sessionFileInfo@@QAE@XZ$1
.xdata$x:00012FC8                 db    1
.xdata$x:00012FC9                 db    0
.xdata$x:00012FCA                 db    0
.xdata$x:00012FCB                 db    0
.xdata$x:00012FCC                 dd offset __unwindfunclet$??1sessionFileInfo@@QAE@XZ$2
.xdata$x:00012FD0                 db    2
.xdata$x:00012FD1                 db    0
.xdata$x:00012FD2                 db    0
.xdata$x:00012FD3                 db    0
.xdata$x:00012FD4                 dd offset __unwindfunclet$??1sessionFileInfo@@QAE@XZ$3
.xdata$x:00012FD8                 db    3
.xdata$x:00012FD9                 db    0
.xdata$x:00012FDA                 db    0
.xdata$x:00012FDB                 db    0
.xdata$x:00012FDC                 dd offset __unwindfunclet$??1sessionFileInfo@@QAE@XZ$4
.xdata$x:00012FDC _xdata$x        ends
.xdata$x:00012FDC
.xdata$x:00012FE0 ; ===========================================================================
.xdata$x:00012FE0
.xdata$x:00012FE0 ; Segment type: Pure data
.xdata$x:00012FE0 ; Segment permissions: Read
.xdata$x:00012FE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00012FE0                 assume cs:_xdata$x
.xdata$x:00012FE0                 ;org 12FE0h
.xdata$x:00012FE0 ; COMDAT (pick associative to section at AE9C)
.xdata$x:00012FE0 __ehfuncinfo$??0sessionFileInfo@@QAE@ABU0@@Z db  22h ; "
.xdata$x:00012FE0                                         ; DATA XREF: __ehhandler$??0sessionFileInfo@@QAE@ABU0@@Z+11o
.xdata$x:00012FE1                 db    5
.xdata$x:00012FE2                 db  93h ; ô
.xdata$x:00012FE3                 db  19h
.xdata$x:00012FE4                 db    5
.xdata$x:00012FE5                 db    0
.xdata$x:00012FE6                 db    0
.xdata$x:00012FE7                 db    0
.xdata$x:00012FE8                 dd offset __unwindtable$??0sessionFileInfo@@QAE@ABU0@@Z
.xdata$x:00012FEC                 db    0
.xdata$x:00012FED                 db    0
.xdata$x:00012FEE                 db    0
.xdata$x:00012FEF                 db    0
.xdata$x:00012FF0                 db    0
.xdata$x:00012FF1                 db    0
.xdata$x:00012FF2                 db    0
.xdata$x:00012FF3                 db    0
.xdata$x:00012FF4                 db    0
.xdata$x:00012FF5                 db    0
.xdata$x:00012FF6                 db    0
.xdata$x:00012FF7                 db    0
.xdata$x:00012FF8                 db    0
.xdata$x:00012FF9                 db    0
.xdata$x:00012FFA                 db    0
.xdata$x:00012FFB                 db    0
.xdata$x:00012FFC                 db    0
.xdata$x:00012FFD                 db    0
.xdata$x:00012FFE                 db    0
.xdata$x:00012FFF                 db    0
.xdata$x:00013000                 db    0
.xdata$x:00013001                 db    0
.xdata$x:00013002                 db    0
.xdata$x:00013003                 db    0
.xdata$x:00013004 __unwindtable$??0sessionFileInfo@@QAE@ABU0@@Z db 0FFh
.xdata$x:00013004                                         ; DATA XREF: .xdata$x:00012FE8o
.xdata$x:00013005                 db 0FFh
.xdata$x:00013006                 db 0FFh
.xdata$x:00013007                 db 0FFh
.xdata$x:00013008                 dd offset __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$0
.xdata$x:0001300C                 align 10h
.xdata$x:00013010                 dd offset __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$1
.xdata$x:00013014                 db    1
.xdata$x:00013015                 db    0
.xdata$x:00013016                 db    0
.xdata$x:00013017                 db    0
.xdata$x:00013018                 dd offset __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$2
.xdata$x:0001301C                 db    2
.xdata$x:0001301D                 db    0
.xdata$x:0001301E                 db    0
.xdata$x:0001301F                 db    0
.xdata$x:00013020                 dd offset __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$3
.xdata$x:00013024                 db    3
.xdata$x:00013025                 db    0
.xdata$x:00013026                 db    0
.xdata$x:00013027                 db    0
.xdata$x:00013028                 dd offset __unwindfunclet$??0sessionFileInfo@@QAE@ABU0@@Z$4
.xdata$x:00013028 _xdata$x        ends
.xdata$x:00013028
.xdata$x:0001302C ; ===========================================================================
.xdata$x:0001302C
.xdata$x:0001302C ; Segment type: Pure data
.xdata$x:0001302C ; Segment permissions: Read
.xdata$x:0001302C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0001302C                 assume cs:_xdata$x
.xdata$x:0001302C                 ;org 1302Ch
.xdata$x:0001302C ; COMDAT (pick associative to section at FE34)
.xdata$x:0001302C __unwindtable$?construct@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@ABU3@@Z db 0FFh
.xdata$x:0001302C                                         ; DATA XREF: .xdata$x:0001303Co
.xdata$x:0001302D                 db 0FFh
.xdata$x:0001302E                 db 0FFh
.xdata$x:0001302F                 db 0FFh
.xdata$x:00013030                 dd offset __unwindfunclet$?construct@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@ABU3@@Z$0
.xdata$x:00013034 __ehfuncinfo$?construct@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@ABU3@@Z db  22h ; "
.xdata$x:00013034                                         ; DATA XREF: __ehhandler$?construct@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@ABU3@@Z+11o
.xdata$x:00013035                 db    5
.xdata$x:00013036                 db  93h ; ô
.xdata$x:00013037                 db  19h
.xdata$x:00013038                 db    1
.xdata$x:00013039                 db    0
.xdata$x:0001303A                 db    0
.xdata$x:0001303B                 db    0
.xdata$x:0001303C                 dd offset __unwindtable$?construct@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@ABU3@@Z
.xdata$x:00013040                 db    0
.xdata$x:00013041                 db    0
.xdata$x:00013042                 db    0
.xdata$x:00013043                 db    0
.xdata$x:00013044                 db    0
.xdata$x:00013045                 db    0
.xdata$x:00013046                 db    0
.xdata$x:00013047                 db    0
.xdata$x:00013048                 db    0
.xdata$x:00013049                 db    0
.xdata$x:0001304A                 db    0
.xdata$x:0001304B                 db    0
.xdata$x:0001304C                 db    0
.xdata$x:0001304D                 db    0
.xdata$x:0001304E                 db    0
.xdata$x:0001304F                 db    0
.xdata$x:00013050                 db    0
.xdata$x:00013051                 db    0
.xdata$x:00013052                 db    0
.xdata$x:00013053                 db    0
.xdata$x:00013054                 db    0
.xdata$x:00013055                 db    0
.xdata$x:00013056                 db    0
.xdata$x:00013057                 db    0
.xdata$x:00013057 _xdata$x        ends
.xdata$x:00013057
.xdata$x:00013058 ; ===========================================================================
.xdata$x:00013058
.xdata$x:00013058 ; Segment type: Pure data
.xdata$x:00013058 ; Segment permissions: Read
.xdata$x:00013058 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013058                 assume cs:_xdata$x
.xdata$x:00013058                 ;org 13058h
.xdata$x:00013058 ; COMDAT (pick associative to section at 9EF4)
.xdata$x:00013058 __unwindtable$??0?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00013058                                         ; DATA XREF: .xdata$x:00013068o
.xdata$x:00013059                 db 0FFh
.xdata$x:0001305A                 db 0FFh
.xdata$x:0001305B                 db 0FFh
.xdata$x:0001305C                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ$0
.xdata$x:00013060 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00013060                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ+11o
.xdata$x:00013061                 db    5
.xdata$x:00013062                 db  93h ; ô
.xdata$x:00013063                 db  19h
.xdata$x:00013064                 db    1
.xdata$x:00013065                 db    0
.xdata$x:00013066                 db    0
.xdata$x:00013067                 db    0
.xdata$x:00013068                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ
.xdata$x:0001306C                 db    0
.xdata$x:0001306D                 db    0
.xdata$x:0001306E                 db    0
.xdata$x:0001306F                 db    0
.xdata$x:00013070                 db    0
.xdata$x:00013071                 db    0
.xdata$x:00013072                 db    0
.xdata$x:00013073                 db    0
.xdata$x:00013074                 db    0
.xdata$x:00013075                 db    0
.xdata$x:00013076                 db    0
.xdata$x:00013077                 db    0
.xdata$x:00013078                 db    0
.xdata$x:00013079                 db    0
.xdata$x:0001307A                 db    0
.xdata$x:0001307B                 db    0
.xdata$x:0001307C                 db    0
.xdata$x:0001307D                 db    0
.xdata$x:0001307E                 db    0
.xdata$x:0001307F                 db    0
.xdata$x:00013080                 db    0
.xdata$x:00013081                 db    0
.xdata$x:00013082                 db    0
.xdata$x:00013083                 db    0
.xdata$x:00013083 _xdata$x        ends
.xdata$x:00013083
.xdata$x:00013084 ; ===========================================================================
.xdata$x:00013084
.xdata$x:00013084 ; Segment type: Pure data
.xdata$x:00013084 ; Segment permissions: Read
.xdata$x:00013084 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013084                 assume cs:_xdata$x
.xdata$x:00013084                 ;org 13084h
.xdata$x:00013084 ; COMDAT (pick associative to section at B9F4)
.xdata$x:00013084 __unwindtable$??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00013084                                         ; DATA XREF: .xdata$x:00013094o
.xdata$x:00013085                 db 0FFh
.xdata$x:00013086                 db 0FFh
.xdata$x:00013087                 db 0FFh
.xdata$x:00013088                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ$0
.xdata$x:0001308C __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0001308C                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ+11o
.xdata$x:0001308D                 db    5
.xdata$x:0001308E                 db  93h ; ô
.xdata$x:0001308F                 db  19h
.xdata$x:00013090                 db    1
.xdata$x:00013091                 db    0
.xdata$x:00013092                 db    0
.xdata$x:00013093                 db    0
.xdata$x:00013094                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@QAE@XZ
.xdata$x:00013098                 db    0
.xdata$x:00013099                 db    0
.xdata$x:0001309A                 db    0
.xdata$x:0001309B                 db    0
.xdata$x:0001309C                 db    0
.xdata$x:0001309D                 db    0
.xdata$x:0001309E                 db    0
.xdata$x:0001309F                 db    0
.xdata$x:000130A0                 db    0
.xdata$x:000130A1                 db    0
.xdata$x:000130A2                 db    0
.xdata$x:000130A3                 db    0
.xdata$x:000130A4                 db    0
.xdata$x:000130A5                 db    0
.xdata$x:000130A6                 db    0
.xdata$x:000130A7                 db    0
.xdata$x:000130A8                 db    0
.xdata$x:000130A9                 db    0
.xdata$x:000130AA                 db    0
.xdata$x:000130AB                 db    0
.xdata$x:000130AC                 db    0
.xdata$x:000130AD                 db    0
.xdata$x:000130AE                 db    0
.xdata$x:000130AF                 db    0
.xdata$x:000130AF _xdata$x        ends
.xdata$x:000130AF
.xdata$x:000130B0 ; ===========================================================================
.xdata$x:000130B0
.xdata$x:000130B0 ; Segment type: Pure data
.xdata$x:000130B0 ; Segment permissions: Read
.xdata$x:000130B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000130B0                 assume cs:_xdata$x
.xdata$x:000130B0                 ;org 130B0h
.xdata$x:000130B0 ; COMDAT (pick associative to section at 993C)
.xdata$x:000130B0 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z db 0FFh
.xdata$x:000130B0                                         ; DATA XREF: .xdata$x:000130C0o
.xdata$x:000130B1                 db 0FFh
.xdata$x:000130B2                 db 0FFh
.xdata$x:000130B3                 db 0FFh
.xdata$x:000130B4                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z$0
.xdata$x:000130B8 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z db  22h ; "
.xdata$x:000130B8                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z+11o
.xdata$x:000130B9                 db    5
.xdata$x:000130BA                 db  93h ; ô
.xdata$x:000130BB                 db  19h
.xdata$x:000130BC                 db    1
.xdata$x:000130BD                 db    0
.xdata$x:000130BE                 db    0
.xdata$x:000130BF                 db    0
.xdata$x:000130C0                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UsessionFileInfo@@@1@@Z
.xdata$x:000130C4                 db    0
.xdata$x:000130C5                 db    0
.xdata$x:000130C6                 db    0
.xdata$x:000130C7                 db    0
.xdata$x:000130C8                 db    0
.xdata$x:000130C9                 db    0
.xdata$x:000130CA                 db    0
.xdata$x:000130CB                 db    0
.xdata$x:000130CC                 db    0
.xdata$x:000130CD                 db    0
.xdata$x:000130CE                 db    0
.xdata$x:000130CF                 db    0
.xdata$x:000130D0                 db    0
.xdata$x:000130D1                 db    0
.xdata$x:000130D2                 db    0
.xdata$x:000130D3                 db    0
.xdata$x:000130D4                 db    0
.xdata$x:000130D5                 db    0
.xdata$x:000130D6                 db    0
.xdata$x:000130D7                 db    0
.xdata$x:000130D8                 db    0
.xdata$x:000130D9                 db    0
.xdata$x:000130DA                 db    0
.xdata$x:000130DB                 db    0
.xdata$x:000130DB _xdata$x        ends
.xdata$x:000130DB
.xdata$x:000130DC ; ===========================================================================
.xdata$x:000130DC
.xdata$x:000130DC ; Segment type: Pure data
.xdata$x:000130DC ; Segment permissions: Read
.xdata$x:000130DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000130DC                 assume cs:_xdata$x
.xdata$x:000130DC                 ;org 130DCh
.xdata$x:000130DC ; COMDAT (pick associative to section at B664)
.xdata$x:000130DC __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000130DC                                         ; DATA XREF: .xdata$x:000130ECo
.xdata$x:000130DD                 db 0FFh
.xdata$x:000130DE                 db 0FFh
.xdata$x:000130DF                 db 0FFh
.xdata$x:000130E0                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000130E4 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000130E4                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000130E5                 db    5
.xdata$x:000130E6                 db  93h ; ô
.xdata$x:000130E7                 db  19h
.xdata$x:000130E8                 db    1
.xdata$x:000130E9                 db    0
.xdata$x:000130EA                 db    0
.xdata$x:000130EB                 db    0
.xdata$x:000130EC                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ
.xdata$x:000130F0                 db    0
.xdata$x:000130F1                 db    0
.xdata$x:000130F2                 db    0
.xdata$x:000130F3                 db    0
.xdata$x:000130F4                 db    0
.xdata$x:000130F5                 db    0
.xdata$x:000130F6                 db    0
.xdata$x:000130F7                 db    0
.xdata$x:000130F8                 db    0
.xdata$x:000130F9                 db    0
.xdata$x:000130FA                 db    0
.xdata$x:000130FB                 db    0
.xdata$x:000130FC                 db    0
.xdata$x:000130FD                 db    0
.xdata$x:000130FE                 db    0
.xdata$x:000130FF                 db    0
.xdata$x:00013100                 db    0
.xdata$x:00013101                 db    0
.xdata$x:00013102                 db    0
.xdata$x:00013103                 db    0
.xdata$x:00013104                 db    0
.xdata$x:00013105                 db    0
.xdata$x:00013106                 db    0
.xdata$x:00013107                 db    0
.xdata$x:00013107 _xdata$x        ends
.xdata$x:00013107
.xdata$x:00013108 ; ===========================================================================
.xdata$x:00013108
.xdata$x:00013108 ; Segment type: Pure data
.xdata$x:00013108 ; Segment permissions: Read
.xdata$x:00013108 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013108                 assume cs:_xdata$x
.xdata$x:00013108                 ;org 13108h
.xdata$x:00013108 ; COMDAT (pick associative to section at A98C)
.xdata$x:00013108 __unwindtable$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00013108                                         ; DATA XREF: .xdata$x:00013118o
.xdata$x:00013109                 db 0FFh
.xdata$x:0001310A                 db 0FFh
.xdata$x:0001310B                 db 0FFh
.xdata$x:0001310C                 dd offset __unwindfunclet$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ$0
.xdata$x:00013110 __ehfuncinfo$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00013110                                         ; DATA XREF: __ehhandler$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ+11o
.xdata$x:00013111                 db    5
.xdata$x:00013112                 db  93h ; ô
.xdata$x:00013113                 db  19h
.xdata$x:00013114                 db    1
.xdata$x:00013115                 db    0
.xdata$x:00013116                 db    0
.xdata$x:00013117                 db    0
.xdata$x:00013118                 dd offset __unwindtable$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ
.xdata$x:0001311C                 db    0
.xdata$x:0001311D                 db    0
.xdata$x:0001311E                 db    0
.xdata$x:0001311F                 db    0
.xdata$x:00013120                 db    0
.xdata$x:00013121                 db    0
.xdata$x:00013122                 db    0
.xdata$x:00013123                 db    0
.xdata$x:00013124                 db    0
.xdata$x:00013125                 db    0
.xdata$x:00013126                 db    0
.xdata$x:00013127                 db    0
.xdata$x:00013128                 db    0
.xdata$x:00013129                 db    0
.xdata$x:0001312A                 db    0
.xdata$x:0001312B                 db    0
.xdata$x:0001312C                 db    0
.xdata$x:0001312D                 db    0
.xdata$x:0001312E                 db    0
.xdata$x:0001312F                 db    0
.xdata$x:00013130                 db    0
.xdata$x:00013131                 db    0
.xdata$x:00013132                 db    0
.xdata$x:00013133                 db    0
.xdata$x:00013133 _xdata$x        ends
.xdata$x:00013133
.xdata$x:00013134 ; ===========================================================================
.xdata$x:00013134
.xdata$x:00013134 ; Segment type: Pure data
.xdata$x:00013134 ; Segment permissions: Read
.xdata$x:00013134 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013134                 assume cs:_xdata$x
.xdata$x:00013134                 ;org 13134h
.xdata$x:00013134 ; COMDAT (pick associative to section at A840)
.xdata$x:00013134 __catchsym$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$5 db    0
.xdata$x:00013134                                         ; DATA XREF: .xdata$x:00013154o
.xdata$x:00013135                 db    0
.xdata$x:00013136                 db    0
.xdata$x:00013137                 db    0
.xdata$x:00013138                 db    0
.xdata$x:00013139                 db    0
.xdata$x:0001313A                 db    0
.xdata$x:0001313B                 db    0
.xdata$x:0001313C                 db    0
.xdata$x:0001313D                 db    0
.xdata$x:0001313E                 db    0
.xdata$x:0001313F                 db    0
.xdata$x:00013140                 dd offset __catch$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00013144 __tryblocktable$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z db    1
.xdata$x:00013144                                         ; DATA XREF: .xdata$x:00013168o
.xdata$x:00013145                 db    0
.xdata$x:00013146                 db    0
.xdata$x:00013147                 db    0
.xdata$x:00013148                 db    3
.xdata$x:00013149                 db    0
.xdata$x:0001314A                 db    0
.xdata$x:0001314B                 db    0
.xdata$x:0001314C                 db    4
.xdata$x:0001314D                 db    0
.xdata$x:0001314E                 db    0
.xdata$x:0001314F                 db    0
.xdata$x:00013150                 db    1
.xdata$x:00013151                 db    0
.xdata$x:00013152                 db    0
.xdata$x:00013153                 db    0
.xdata$x:00013154                 dd offset __catchsym$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$5
.xdata$x:00013158 __ehfuncinfo$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00013158                                         ; DATA XREF: __ehhandler$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00013159                 db    5
.xdata$x:0001315A                 db  93h ; ô
.xdata$x:0001315B                 db  19h
.xdata$x:0001315C                 db    5
.xdata$x:0001315D                 db    0
.xdata$x:0001315E                 db    0
.xdata$x:0001315F                 db    0
.xdata$x:00013160                 dd offset __unwindtable$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00013164                 db    1
.xdata$x:00013165                 db    0
.xdata$x:00013166                 db    0
.xdata$x:00013167                 db    0
.xdata$x:00013168                 dd offset __tryblocktable$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0001316C                 db    0
.xdata$x:0001316D                 db    0
.xdata$x:0001316E                 db    0
.xdata$x:0001316F                 db    0
.xdata$x:00013170                 db    0
.xdata$x:00013171                 db    0
.xdata$x:00013172                 db    0
.xdata$x:00013173                 db    0
.xdata$x:00013174                 db    0
.xdata$x:00013175                 db    0
.xdata$x:00013176                 db    0
.xdata$x:00013177                 db    0
.xdata$x:00013178                 db    0
.xdata$x:00013179                 db    0
.xdata$x:0001317A                 db    0
.xdata$x:0001317B                 db    0
.xdata$x:0001317C __unwindtable$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0001317C                                         ; DATA XREF: .xdata$x:00013160o
.xdata$x:0001317D                 db 0FFh
.xdata$x:0001317E                 db 0FFh
.xdata$x:0001317F                 db 0FFh
.xdata$x:00013180                 dd offset __unwindfunclet$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$2
.xdata$x:00013184                 db    0
.xdata$x:00013185                 db    0
.xdata$x:00013186                 db    0
.xdata$x:00013187                 db    0
.xdata$x:00013188                 db    0
.xdata$x:00013189                 db    0
.xdata$x:0001318A                 db    0
.xdata$x:0001318B                 db    0
.xdata$x:0001318C                 db    1
.xdata$x:0001318D                 db    0
.xdata$x:0001318E                 db    0
.xdata$x:0001318F                 db    0
.xdata$x:00013190                 dd offset __unwindfunclet$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$3
.xdata$x:00013194                 db    2
.xdata$x:00013195                 db    0
.xdata$x:00013196                 db    0
.xdata$x:00013197                 db    0
.xdata$x:00013198                 dd offset __unwindfunclet$??0?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@ABV01@@Z$4
.xdata$x:0001319C                 db    0
.xdata$x:0001319D                 db    0
.xdata$x:0001319E                 db    0
.xdata$x:0001319F                 db    0
.xdata$x:000131A0                 db    0
.xdata$x:000131A1                 db    0
.xdata$x:000131A2                 db    0
.xdata$x:000131A3                 db    0
.xdata$x:000131A3 _xdata$x        ends
.xdata$x:000131A3
.xdata$x:000131A4 ; ===========================================================================
.xdata$x:000131A4
.xdata$x:000131A4 ; Segment type: Pure data
.xdata$x:000131A4 ; Segment permissions: Read
.xdata$x:000131A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000131A4                 assume cs:_xdata$x
.xdata$x:000131A4                 ;org 131A4h
.xdata$x:000131A4 ; COMDAT (pick associative to section at BCBC)
.xdata$x:000131A4 __unwindtable$??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000131A4                                         ; DATA XREF: .xdata$x:000131B4o
.xdata$x:000131A5                 db 0FFh
.xdata$x:000131A6                 db 0FFh
.xdata$x:000131A7                 db 0FFh
.xdata$x:000131A8                 dd offset __unwindfunclet$??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ$0
.xdata$x:000131AC __ehfuncinfo$??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000131AC                                         ; DATA XREF: __ehhandler$??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ+11o
.xdata$x:000131AD                 db    5
.xdata$x:000131AE                 db  93h ; ô
.xdata$x:000131AF                 db  19h
.xdata$x:000131B0                 db    1
.xdata$x:000131B1                 db    0
.xdata$x:000131B2                 db    0
.xdata$x:000131B3                 db    0
.xdata$x:000131B4                 dd offset __unwindtable$??1?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE@XZ
.xdata$x:000131B8                 db    0
.xdata$x:000131B9                 db    0
.xdata$x:000131BA                 db    0
.xdata$x:000131BB                 db    0
.xdata$x:000131BC                 db    0
.xdata$x:000131BD                 db    0
.xdata$x:000131BE                 db    0
.xdata$x:000131BF                 db    0
.xdata$x:000131C0                 db    0
.xdata$x:000131C1                 db    0
.xdata$x:000131C2                 db    0
.xdata$x:000131C3                 db    0
.xdata$x:000131C4                 db    0
.xdata$x:000131C5                 db    0
.xdata$x:000131C6                 db    0
.xdata$x:000131C7                 db    0
.xdata$x:000131C8                 db    0
.xdata$x:000131C9                 db    0
.xdata$x:000131CA                 db    0
.xdata$x:000131CB                 db    0
.xdata$x:000131CC                 db    0
.xdata$x:000131CD                 db    0
.xdata$x:000131CE                 db    0
.xdata$x:000131CF                 db    0
.xdata$x:000131CF _xdata$x        ends
.xdata$x:000131CF
.xdata$x:000131D0 ; ===========================================================================
.xdata$x:000131D0
.xdata$x:000131D0 ; Segment type: Pure data
.xdata$x:000131D0 ; Segment permissions: Read
.xdata$x:000131D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000131D0                 assume cs:_xdata$x
.xdata$x:000131D0                 ;org 131D0h
.xdata$x:000131D0 ; COMDAT (pick associative to section at FA28)
.xdata$x:000131D0 __unwindtable$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:000131D0                                         ; DATA XREF: .xdata$x:000131E0o
.xdata$x:000131D1                 db 0FFh
.xdata$x:000131D2                 db 0FFh
.xdata$x:000131D3                 db 0FFh
.xdata$x:000131D4                 dd offset __unwindfunclet$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ$0
.xdata$x:000131D8 __ehfuncinfo$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:000131D8                                         ; DATA XREF: __ehhandler$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ+11o
.xdata$x:000131D9                 db    5
.xdata$x:000131DA                 db  93h ; ô
.xdata$x:000131DB                 db  19h
.xdata$x:000131DC                 db    1
.xdata$x:000131DD                 db    0
.xdata$x:000131DE                 db    0
.xdata$x:000131DF                 db    0
.xdata$x:000131E0                 dd offset __unwindtable$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ
.xdata$x:000131E4                 db    0
.xdata$x:000131E5                 db    0
.xdata$x:000131E6                 db    0
.xdata$x:000131E7                 db    0
.xdata$x:000131E8                 db    0
.xdata$x:000131E9                 db    0
.xdata$x:000131EA                 db    0
.xdata$x:000131EB                 db    0
.xdata$x:000131EC                 db    0
.xdata$x:000131ED                 db    0
.xdata$x:000131EE                 db    0
.xdata$x:000131EF                 db    0
.xdata$x:000131F0                 db    0
.xdata$x:000131F1                 db    0
.xdata$x:000131F2                 db    0
.xdata$x:000131F3                 db    0
.xdata$x:000131F4                 db    0
.xdata$x:000131F5                 db    0
.xdata$x:000131F6                 db    0
.xdata$x:000131F7                 db    0
.xdata$x:000131F8                 db    0
.xdata$x:000131F9                 db    0
.xdata$x:000131FA                 db    0
.xdata$x:000131FB                 db    0
.xdata$x:000131FB _xdata$x        ends
.xdata$x:000131FB
.xdata$x:000131FC ; ===========================================================================
.xdata$x:000131FC
.xdata$x:000131FC ; Segment type: Pure data
.xdata$x:000131FC ; Segment permissions: Read
.xdata$x:000131FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000131FC                 assume cs:_xdata$x
.xdata$x:000131FC                 ;org 131FCh
.xdata$x:000131FC ; COMDAT (pick associative to section at FAC4)
.xdata$x:000131FC __unwindtable$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:000131FC                                         ; DATA XREF: .xdata$x:0001320Co
.xdata$x:000131FD                 db 0FFh
.xdata$x:000131FE                 db 0FFh
.xdata$x:000131FF                 db 0FFh
.xdata$x:00013200                 dd offset __unwindfunclet$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ$0
.xdata$x:00013204 __ehfuncinfo$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00013204                                         ; DATA XREF: __ehhandler$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ+11o
.xdata$x:00013205                 db    5
.xdata$x:00013206                 db  93h ; ô
.xdata$x:00013207                 db  19h
.xdata$x:00013208                 db    1
.xdata$x:00013209                 db    0
.xdata$x:0001320A                 db    0
.xdata$x:0001320B                 db    0
.xdata$x:0001320C                 dd offset __unwindtable$?begin@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ
.xdata$x:00013210                 db    0
.xdata$x:00013211                 db    0
.xdata$x:00013212                 db    0
.xdata$x:00013213                 db    0
.xdata$x:00013214                 db    0
.xdata$x:00013215                 db    0
.xdata$x:00013216                 db    0
.xdata$x:00013217                 db    0
.xdata$x:00013218                 db    0
.xdata$x:00013219                 db    0
.xdata$x:0001321A                 db    0
.xdata$x:0001321B                 db    0
.xdata$x:0001321C                 db    0
.xdata$x:0001321D                 db    0
.xdata$x:0001321E                 db    0
.xdata$x:0001321F                 db    0
.xdata$x:00013220                 db    0
.xdata$x:00013221                 db    0
.xdata$x:00013222                 db    0
.xdata$x:00013223                 db    0
.xdata$x:00013224                 db    0
.xdata$x:00013225                 db    0
.xdata$x:00013226                 db    0
.xdata$x:00013227                 db    0
.xdata$x:00013227 _xdata$x        ends
.xdata$x:00013227
.xdata$x:00013228 ; ===========================================================================
.xdata$x:00013228
.xdata$x:00013228 ; Segment type: Pure data
.xdata$x:00013228 ; Segment permissions: Read
.xdata$x:00013228 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013228                 assume cs:_xdata$x
.xdata$x:00013228                 ;org 13228h
.xdata$x:00013228 ; COMDAT (pick associative to section at 10410)
.xdata$x:00013228 __unwindtable$?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:00013228                                         ; DATA XREF: .xdata$x:00013238o
.xdata$x:00013229                 db 0FFh
.xdata$x:0001322A                 db 0FFh
.xdata$x:0001322B                 db 0FFh
.xdata$x:0001322C                 dd offset __unwindfunclet$?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ$0
.xdata$x:00013230 __ehfuncinfo$?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00013230                                         ; DATA XREF: __ehhandler$?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ+11o
.xdata$x:00013231                 db    5
.xdata$x:00013232                 db  93h ; ô
.xdata$x:00013233                 db  19h
.xdata$x:00013234                 db    1
.xdata$x:00013235                 db    0
.xdata$x:00013236                 db    0
.xdata$x:00013237                 db    0
.xdata$x:00013238                 dd offset __unwindtable$?end@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@XZ
.xdata$x:0001323C                 db    0
.xdata$x:0001323D                 db    0
.xdata$x:0001323E                 db    0
.xdata$x:0001323F                 db    0
.xdata$x:00013240                 db    0
.xdata$x:00013241                 db    0
.xdata$x:00013242                 db    0
.xdata$x:00013243                 db    0
.xdata$x:00013244                 db    0
.xdata$x:00013245                 db    0
.xdata$x:00013246                 db    0
.xdata$x:00013247                 db    0
.xdata$x:00013248                 db    0
.xdata$x:00013249                 db    0
.xdata$x:0001324A                 db    0
.xdata$x:0001324B                 db    0
.xdata$x:0001324C                 db    0
.xdata$x:0001324D                 db    0
.xdata$x:0001324E                 db    0
.xdata$x:0001324F                 db    0
.xdata$x:00013250                 db    0
.xdata$x:00013251                 db    0
.xdata$x:00013252                 db    0
.xdata$x:00013253                 db    0
.xdata$x:00013253 _xdata$x        ends
.xdata$x:00013253
.xdata$x:00013254 ; ===========================================================================
.xdata$x:00013254
.xdata$x:00013254 ; Segment type: Pure data
.xdata$x:00013254 ; Segment permissions: Read
.xdata$x:00013254 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013254                 assume cs:_xdata$x
.xdata$x:00013254                 ;org 13254h
.xdata$x:00013254 ; COMDAT (pick associative to section at E18C)
.xdata$x:00013254 __unwindtable$?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z db 0FFh
.xdata$x:00013254                                         ; DATA XREF: .xdata$x:0001326Co
.xdata$x:00013255                 db 0FFh
.xdata$x:00013256                 db 0FFh
.xdata$x:00013257                 db 0FFh
.xdata$x:00013258                 dd offset __unwindfunclet$?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$1
.xdata$x:0001325C                 align 10h
.xdata$x:00013260                 dd offset __unwindfunclet$?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$0
.xdata$x:00013264 __ehfuncinfo$?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z db  22h ; "
.xdata$x:00013264                                         ; DATA XREF: __ehhandler$?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z+11o
.xdata$x:00013265                 db    5
.xdata$x:00013266                 db  93h ; ô
.xdata$x:00013267                 db  19h
.xdata$x:00013268                 db    2
.xdata$x:00013269                 db    0
.xdata$x:0001326A                 db    0
.xdata$x:0001326B                 db    0
.xdata$x:0001326C                 dd offset __unwindtable$?_Make_iter@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z
.xdata$x:00013270                 db    0
.xdata$x:00013271                 db    0
.xdata$x:00013272                 db    0
.xdata$x:00013273                 db    0
.xdata$x:00013274                 db    0
.xdata$x:00013275                 db    0
.xdata$x:00013276                 db    0
.xdata$x:00013277                 db    0
.xdata$x:00013278                 db    0
.xdata$x:00013279                 db    0
.xdata$x:0001327A                 db    0
.xdata$x:0001327B                 db    0
.xdata$x:0001327C                 db    0
.xdata$x:0001327D                 db    0
.xdata$x:0001327E                 db    0
.xdata$x:0001327F                 db    0
.xdata$x:00013280                 db    0
.xdata$x:00013281                 db    0
.xdata$x:00013282                 db    0
.xdata$x:00013283                 db    0
.xdata$x:00013284                 db    0
.xdata$x:00013285                 db    0
.xdata$x:00013286                 db    0
.xdata$x:00013287                 db    0
.xdata$x:00013287 _xdata$x        ends
.xdata$x:00013287
.xdata$x:00013288 ; ===========================================================================
.xdata$x:00013288
.xdata$x:00013288 ; Segment type: Pure data
.xdata$x:00013288 ; Segment permissions: Read
.xdata$x:00013288 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013288                 assume cs:_xdata$x
.xdata$x:00013288                 ;org 13288h
.xdata$x:00013288 ; COMDAT (pick associative to section at 1069C)
.xdata$x:00013288 __unwindtable$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z db 0FFh
.xdata$x:00013288                                         ; DATA XREF: .xdata$x:000132A8o
.xdata$x:00013289                 db 0FFh
.xdata$x:0001328A                 db 0FFh
.xdata$x:0001328B                 db 0FFh
.xdata$x:0001328C                 dd offset __unwindfunclet$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$2
.xdata$x:00013290                 db    0
.xdata$x:00013291                 db    0
.xdata$x:00013292                 db    0
.xdata$x:00013293                 db    0
.xdata$x:00013294                 dd offset __unwindfunclet$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$0
.xdata$x:00013298                 db    1
.xdata$x:00013299                 db    0
.xdata$x:0001329A                 db    0
.xdata$x:0001329B                 db    0
.xdata$x:0001329C                 dd offset __unwindfunclet$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z$1
.xdata$x:000132A0 __ehfuncinfo$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z db  22h ; "
.xdata$x:000132A0                                         ; DATA XREF: __ehhandler$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z+11o
.xdata$x:000132A1                 db    5
.xdata$x:000132A2                 db  93h ; ô
.xdata$x:000132A3                 db  19h
.xdata$x:000132A4                 db    3
.xdata$x:000132A5                 db    0
.xdata$x:000132A6                 db    0
.xdata$x:000132A7                 db    0
.xdata$x:000132A8                 dd offset __unwindtable$?erase@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@2@@Z
.xdata$x:000132AC                 db    0
.xdata$x:000132AD                 db    0
.xdata$x:000132AE                 db    0
.xdata$x:000132AF                 db    0
.xdata$x:000132B0                 db    0
.xdata$x:000132B1                 db    0
.xdata$x:000132B2                 db    0
.xdata$x:000132B3                 db    0
.xdata$x:000132B4                 db    0
.xdata$x:000132B5                 db    0
.xdata$x:000132B6                 db    0
.xdata$x:000132B7                 db    0
.xdata$x:000132B8                 db    0
.xdata$x:000132B9                 db    0
.xdata$x:000132BA                 db    0
.xdata$x:000132BB                 db    0
.xdata$x:000132BC                 db    0
.xdata$x:000132BD                 db    0
.xdata$x:000132BE                 db    0
.xdata$x:000132BF                 db    0
.xdata$x:000132C0                 db    0
.xdata$x:000132C1                 db    0
.xdata$x:000132C2                 db    0
.xdata$x:000132C3                 db    0
.xdata$x:000132C3 _xdata$x        ends
.xdata$x:000132C3
.xdata$x:000132C4 ; ===========================================================================
.xdata$x:000132C4
.xdata$x:000132C4 ; Segment type: Pure data
.xdata$x:000132C4 ; Segment permissions: Read
.xdata$x:000132C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000132C4                 assume cs:_xdata$x
.xdata$x:000132C4                 ;org 132C4h
.xdata$x:000132C4 ; COMDAT (pick associative to section at E8E8)
.xdata$x:000132C4 __catchsym$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:000132C4                                         ; DATA XREF: .xdata$x:000132F4o
.xdata$x:000132C5                 db    0
.xdata$x:000132C6                 db    0
.xdata$x:000132C7                 db    0
.xdata$x:000132C8                 db    0
.xdata$x:000132C9                 db    0
.xdata$x:000132CA                 db    0
.xdata$x:000132CB                 db    0
.xdata$x:000132CC                 db    0
.xdata$x:000132CD                 db    0
.xdata$x:000132CE                 db    0
.xdata$x:000132CF                 db    0
.xdata$x:000132D0                 dd offset __catch$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z$0
.xdata$x:000132D4 __unwindtable$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:000132D4                                         ; DATA XREF: .xdata$x:00013300o
.xdata$x:000132D5                 db 0FFh
.xdata$x:000132D6                 db 0FFh
.xdata$x:000132D7                 db 0FFh
.xdata$x:000132D8                 db    0
.xdata$x:000132D9                 db    0
.xdata$x:000132DA                 db    0
.xdata$x:000132DB                 db    0
.xdata$x:000132DC                 db 0FFh
.xdata$x:000132DD                 db 0FFh
.xdata$x:000132DE                 db 0FFh
.xdata$x:000132DF                 db 0FFh
.xdata$x:000132E0                 db    0
.xdata$x:000132E1                 db    0
.xdata$x:000132E2                 db    0
.xdata$x:000132E3                 db    0
.xdata$x:000132E4 __tryblocktable$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z db    0
.xdata$x:000132E4                                         ; DATA XREF: .xdata$x:00013308o
.xdata$x:000132E5                 db    0
.xdata$x:000132E6                 db    0
.xdata$x:000132E7                 db    0
.xdata$x:000132E8                 db    0
.xdata$x:000132E9                 db    0
.xdata$x:000132EA                 db    0
.xdata$x:000132EB                 db    0
.xdata$x:000132EC                 db    1
.xdata$x:000132ED                 db    0
.xdata$x:000132EE                 db    0
.xdata$x:000132EF                 db    0
.xdata$x:000132F0                 db    1
.xdata$x:000132F1                 db    0
.xdata$x:000132F2                 db    0
.xdata$x:000132F3                 db    0
.xdata$x:000132F4                 dd offset __catchsym$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z$2
.xdata$x:000132F8 __ehfuncinfo$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:000132F8                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z+11o
.xdata$x:000132F9                 db    5
.xdata$x:000132FA                 db  93h ; ô
.xdata$x:000132FB                 db  19h
.xdata$x:000132FC                 db    2
.xdata$x:000132FD                 db    0
.xdata$x:000132FE                 db    0
.xdata$x:000132FF                 db    0
.xdata$x:00013300                 dd offset __unwindtable$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z
.xdata$x:00013304                 db    1
.xdata$x:00013305                 db    0
.xdata$x:00013306                 db    0
.xdata$x:00013307                 db    0
.xdata$x:00013308                 dd offset __tryblocktable$?_Reallocate@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEXI@Z
.xdata$x:0001330C                 db    0
.xdata$x:0001330D                 db    0
.xdata$x:0001330E                 db    0
.xdata$x:0001330F                 db    0
.xdata$x:00013310                 db    0
.xdata$x:00013311                 db    0
.xdata$x:00013312                 db    0
.xdata$x:00013313                 db    0
.xdata$x:00013314                 db    0
.xdata$x:00013315                 db    0
.xdata$x:00013316                 db    0
.xdata$x:00013317                 db    0
.xdata$x:00013318                 db    0
.xdata$x:00013319                 db    0
.xdata$x:0001331A                 db    0
.xdata$x:0001331B                 db    0
.xdata$x:0001331B _xdata$x        ends
.xdata$x:0001331B
.xdata$x:0001331C ; ===========================================================================
.xdata$x:0001331C
.xdata$x:0001331C ; Segment type: Pure data
.xdata$x:0001331C ; Segment permissions: Read
.xdata$x:0001331C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0001331C                 assume cs:_xdata$x
.xdata$x:0001331C                 ;org 1331Ch
.xdata$x:0001331C ; COMDAT (pick associative to section at E528)
.xdata$x:0001331C __unwindtable$?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z db 0FFh
.xdata$x:0001331C                                         ; DATA XREF: .xdata$x:0001332Co
.xdata$x:0001331D                 db 0FFh
.xdata$x:0001331E                 db 0FFh
.xdata$x:0001331F                 db 0FFh
.xdata$x:00013320                 dd offset __unwindfunclet$?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z$0
.xdata$x:00013324 __ehfuncinfo$?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z db  22h ; "
.xdata$x:00013324                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z+11o
.xdata$x:00013325                 db    5
.xdata$x:00013326                 db  93h ; ô
.xdata$x:00013327                 db  19h
.xdata$x:00013328                 db    1
.xdata$x:00013329                 db    0
.xdata$x:0001332A                 db    0
.xdata$x:0001332B                 db    0
.xdata$x:0001332C                 dd offset __unwindtable$?_Orphan_range@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IBEXPAUsessionFileInfo@@0@Z
.xdata$x:00013330                 db    0
.xdata$x:00013331                 db    0
.xdata$x:00013332                 db    0
.xdata$x:00013333                 db    0
.xdata$x:00013334                 db    0
.xdata$x:00013335                 db    0
.xdata$x:00013336                 db    0
.xdata$x:00013337                 db    0
.xdata$x:00013338                 db    0
.xdata$x:00013339                 db    0
.xdata$x:0001333A                 db    0
.xdata$x:0001333B                 db    0
.xdata$x:0001333C                 db    0
.xdata$x:0001333D                 db    0
.xdata$x:0001333E                 db    0
.xdata$x:0001333F                 db    0
.xdata$x:00013340                 db    0
.xdata$x:00013341                 db    0
.xdata$x:00013342                 db    0
.xdata$x:00013343                 db    0
.xdata$x:00013344                 db    0
.xdata$x:00013345                 db    0
.xdata$x:00013346                 db    0
.xdata$x:00013347                 db    0
.xdata$x:00013347 _xdata$x        ends
.xdata$x:00013347
.xdata$x:00013348 ; ===========================================================================
.xdata$x:00013348
.xdata$x:00013348 ; Segment type: Pure data
.xdata$x:00013348 ; Segment permissions: Read
.xdata$x:00013348 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013348                 assume cs:_xdata$x
.xdata$x:00013348                 ;org 13348h
.xdata$x:00013348 ; COMDAT (pick associative to section at ABA0)
.xdata$x:00013348 __unwindtable$??0Session@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:00013360o
.xdata$x:00013349                 db 0FFh
.xdata$x:0001334A                 db 0FFh
.xdata$x:0001334B                 db 0FFh
.xdata$x:0001334C                 dd offset __unwindfunclet$??0Session@@QAE@XZ$0
.xdata$x:00013350                 db    0
.xdata$x:00013351                 db    0
.xdata$x:00013352                 db    0
.xdata$x:00013353                 db    0
.xdata$x:00013354                 dd offset __unwindfunclet$??0Session@@QAE@XZ$1
.xdata$x:00013358 __ehfuncinfo$??0Session@@QAE@XZ db  22h ; "
.xdata$x:00013358                                         ; DATA XREF: __ehhandler$??0Session@@QAE@XZ+11o
.xdata$x:00013359                 db    5
.xdata$x:0001335A                 db  93h ; ô
.xdata$x:0001335B                 db  19h
.xdata$x:0001335C                 db    2
.xdata$x:0001335D                 db    0
.xdata$x:0001335E                 db    0
.xdata$x:0001335F                 db    0
.xdata$x:00013360                 dd offset __unwindtable$??0Session@@QAE@XZ
.xdata$x:00013364                 db    0
.xdata$x:00013365                 db    0
.xdata$x:00013366                 db    0
.xdata$x:00013367                 db    0
.xdata$x:00013368                 db    0
.xdata$x:00013369                 db    0
.xdata$x:0001336A                 db    0
.xdata$x:0001336B                 db    0
.xdata$x:0001336C                 db    0
.xdata$x:0001336D                 db    0
.xdata$x:0001336E                 db    0
.xdata$x:0001336F                 db    0
.xdata$x:00013370                 db    0
.xdata$x:00013371                 db    0
.xdata$x:00013372                 db    0
.xdata$x:00013373                 db    0
.xdata$x:00013374                 db    0
.xdata$x:00013375                 db    0
.xdata$x:00013376                 db    0
.xdata$x:00013377                 db    0
.xdata$x:00013378                 db    0
.xdata$x:00013379                 db    0
.xdata$x:0001337A                 db    0
.xdata$x:0001337B                 db    0
.xdata$x:0001337B _xdata$x        ends
.xdata$x:0001337B
.xdata$x:0001337C ; ===========================================================================
.xdata$x:0001337C
.xdata$x:0001337C ; Segment type: Pure data
.xdata$x:0001337C ; Segment permissions: Read
.xdata$x:0001337C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0001337C                 assume cs:_xdata$x
.xdata$x:0001337C                 ;org 1337Ch
.xdata$x:0001337C ; COMDAT (pick associative to section at BDAC)
.xdata$x:0001337C __unwindtable$??1Session@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:00013394o
.xdata$x:0001337D                 db 0FFh
.xdata$x:0001337E                 db 0FFh
.xdata$x:0001337F                 db 0FFh
.xdata$x:00013380                 dd offset __unwindfunclet$??1Session@@QAE@XZ$0
.xdata$x:00013384                 align 8
.xdata$x:00013388                 dd offset __unwindfunclet$??1Session@@QAE@XZ$1
.xdata$x:0001338C __ehfuncinfo$??1Session@@QAE@XZ db  22h ; "
.xdata$x:0001338C                                         ; DATA XREF: __ehhandler$??1Session@@QAE@XZ+11o
.xdata$x:0001338D                 db    5
.xdata$x:0001338E                 db  93h ; ô
.xdata$x:0001338F                 db  19h
.xdata$x:00013390                 db    2
.xdata$x:00013391                 db    0
.xdata$x:00013392                 db    0
.xdata$x:00013393                 db    0
.xdata$x:00013394                 dd offset __unwindtable$??1Session@@QAE@XZ
.xdata$x:00013398                 db    0
.xdata$x:00013399                 db    0
.xdata$x:0001339A                 db    0
.xdata$x:0001339B                 db    0
.xdata$x:0001339C                 db    0
.xdata$x:0001339D                 db    0
.xdata$x:0001339E                 db    0
.xdata$x:0001339F                 db    0
.xdata$x:000133A0                 db    0
.xdata$x:000133A1                 db    0
.xdata$x:000133A2                 db    0
.xdata$x:000133A3                 db    0
.xdata$x:000133A4                 db    0
.xdata$x:000133A5                 db    0
.xdata$x:000133A6                 db    0
.xdata$x:000133A7                 db    0
.xdata$x:000133A8                 db    0
.xdata$x:000133A9                 db    0
.xdata$x:000133AA                 db    0
.xdata$x:000133AB                 db    0
.xdata$x:000133AC                 db    0
.xdata$x:000133AD                 db    0
.xdata$x:000133AE                 db    0
.xdata$x:000133AF                 db    0
.xdata$x:000133AF _xdata$x        ends
.xdata$x:000133AF
.xdata$x:000133B0 ; ===========================================================================
.xdata$x:000133B0
.xdata$x:000133B0 ; Segment type: Pure data
.xdata$x:000133B0 ; Segment permissions: Read
.xdata$x:000133B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000133B0                 assume cs:_xdata$x
.xdata$x:000133B0                 ;org 133B0h
.xdata$x:000133B0 ; COMDAT (pick associative to section at AAD8)
.xdata$x:000133B0 __unwindtable$??0Session@@QAE@ABU0@@Z db 0FFh
.xdata$x:000133B0                                         ; DATA XREF: .xdata$x:000133C8o
.xdata$x:000133B1                 db 0FFh
.xdata$x:000133B2                 db 0FFh
.xdata$x:000133B3                 db 0FFh
.xdata$x:000133B4                 dd offset __unwindfunclet$??0Session@@QAE@ABU0@@Z$0
.xdata$x:000133B8                 db    0
.xdata$x:000133B9                 db    0
.xdata$x:000133BA                 db    0
.xdata$x:000133BB                 db    0
.xdata$x:000133BC                 dd offset __unwindfunclet$??0Session@@QAE@ABU0@@Z$1
.xdata$x:000133C0 __ehfuncinfo$??0Session@@QAE@ABU0@@Z db  22h ; "
.xdata$x:000133C0                                         ; DATA XREF: __ehhandler$??0Session@@QAE@ABU0@@Z+11o
.xdata$x:000133C1                 db    5
.xdata$x:000133C2                 db  93h ; ô
.xdata$x:000133C3                 db  19h
.xdata$x:000133C4                 db    2
.xdata$x:000133C5                 db    0
.xdata$x:000133C6                 db    0
.xdata$x:000133C7                 db    0
.xdata$x:000133C8                 dd offset __unwindtable$??0Session@@QAE@ABU0@@Z
.xdata$x:000133CC                 db    0
.xdata$x:000133CD                 db    0
.xdata$x:000133CE                 db    0
.xdata$x:000133CF                 db    0
.xdata$x:000133D0                 db    0
.xdata$x:000133D1                 db    0
.xdata$x:000133D2                 db    0
.xdata$x:000133D3                 db    0
.xdata$x:000133D4                 db    0
.xdata$x:000133D5                 db    0
.xdata$x:000133D6                 db    0
.xdata$x:000133D7                 db    0
.xdata$x:000133D8                 db    0
.xdata$x:000133D9                 db    0
.xdata$x:000133DA                 db    0
.xdata$x:000133DB                 db    0
.xdata$x:000133DC                 db    0
.xdata$x:000133DD                 db    0
.xdata$x:000133DE                 db    0
.xdata$x:000133DF                 db    0
.xdata$x:000133E0                 db    0
.xdata$x:000133E1                 db    0
.xdata$x:000133E2                 db    0
.xdata$x:000133E3                 db    0
.xdata$x:000133E3 _xdata$x        ends
.xdata$x:000133E3
.xdata$x:000133E4 ; ===========================================================================
.xdata$x:000133E4
.xdata$x:000133E4 ; Segment type: Pure data
.xdata$x:000133E4 ; Segment permissions: Read
.xdata$x:000133E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000133E4                 assume cs:_xdata$x
.xdata$x:000133E4                 ;org 133E4h
.xdata$x:000133E4 ; COMDAT (pick associative to section at 9F84)
.xdata$x:000133E4 __unwindtable$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000133E4                                         ; DATA XREF: .xdata$x:000133F4o
.xdata$x:000133E5                 db 0FFh
.xdata$x:000133E6                 db 0FFh
.xdata$x:000133E7                 db 0FFh
.xdata$x:000133E8                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000133EC __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000133EC                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000133ED                 db    5
.xdata$x:000133EE                 db  93h ; ô
.xdata$x:000133EF                 db  19h
.xdata$x:000133F0                 db    1
.xdata$x:000133F1                 db    0
.xdata$x:000133F2                 db    0
.xdata$x:000133F3                 db    0
.xdata$x:000133F4                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.xdata$x:000133F8                 db    0
.xdata$x:000133F9                 db    0
.xdata$x:000133FA                 db    0
.xdata$x:000133FB                 db    0
.xdata$x:000133FC                 db    0
.xdata$x:000133FD                 db    0
.xdata$x:000133FE                 db    0
.xdata$x:000133FF                 db    0
.xdata$x:00013400                 db    0
.xdata$x:00013401                 db    0
.xdata$x:00013402                 db    0
.xdata$x:00013403                 db    0
.xdata$x:00013404                 db    0
.xdata$x:00013405                 db    0
.xdata$x:00013406                 db    0
.xdata$x:00013407                 db    0
.xdata$x:00013408                 db    0
.xdata$x:00013409                 db    0
.xdata$x:0001340A                 db    0
.xdata$x:0001340B                 db    0
.xdata$x:0001340C                 db    0
.xdata$x:0001340D                 db    0
.xdata$x:0001340E                 db    0
.xdata$x:0001340F                 db    0
.xdata$x:0001340F _xdata$x        ends
.xdata$x:0001340F
.xdata$x:00013410 ; ===========================================================================
.xdata$x:00013410
.xdata$x:00013410 ; Segment type: Pure data
.xdata$x:00013410 ; Segment permissions: Read
.xdata$x:00013410 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013410                 assume cs:_xdata$x
.xdata$x:00013410                 ;org 13410h
.xdata$x:00013410 ; COMDAT (pick associative to section at BA64)
.xdata$x:00013410 __unwindtable$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00013410                                         ; DATA XREF: .xdata$x:00013420o
.xdata$x:00013411                 db 0FFh
.xdata$x:00013412                 db 0FFh
.xdata$x:00013413                 db 0FFh
.xdata$x:00013414                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00013418 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00013418                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00013419                 db    5
.xdata$x:0001341A                 db  93h ; ô
.xdata$x:0001341B                 db  19h
.xdata$x:0001341C                 db    1
.xdata$x:0001341D                 db    0
.xdata$x:0001341E                 db    0
.xdata$x:0001341F                 db    0
.xdata$x:00013420                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.xdata$x:00013424                 db    0
.xdata$x:00013425                 db    0
.xdata$x:00013426                 db    0
.xdata$x:00013427                 db    0
.xdata$x:00013428                 db    0
.xdata$x:00013429                 db    0
.xdata$x:0001342A                 db    0
.xdata$x:0001342B                 db    0
.xdata$x:0001342C                 db    0
.xdata$x:0001342D                 db    0
.xdata$x:0001342E                 db    0
.xdata$x:0001342F                 db    0
.xdata$x:00013430                 db    0
.xdata$x:00013431                 db    0
.xdata$x:00013432                 db    0
.xdata$x:00013433                 db    0
.xdata$x:00013434                 db    0
.xdata$x:00013435                 db    0
.xdata$x:00013436                 db    0
.xdata$x:00013437                 db    0
.xdata$x:00013438                 db    0
.xdata$x:00013439                 db    0
.xdata$x:0001343A                 db    0
.xdata$x:0001343B                 db    0
.xdata$x:0001343B _xdata$x        ends
.xdata$x:0001343B
.xdata$x:0001343C ; ===========================================================================
.xdata$x:0001343C
.xdata$x:0001343C ; Segment type: Pure data
.xdata$x:0001343C ; Segment permissions: Read
.xdata$x:0001343C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0001343C                 assume cs:_xdata$x
.xdata$x:0001343C                 ;org 1343Ch
.xdata$x:0001343C ; COMDAT (pick associative to section at 99B8)
.xdata$x:0001343C __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z db 0FFh
.xdata$x:0001343C                                         ; DATA XREF: .xdata$x:0001344Co
.xdata$x:0001343D                 db 0FFh
.xdata$x:0001343E                 db 0FFh
.xdata$x:0001343F                 db 0FFh
.xdata$x:00013440                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$0
.xdata$x:00013444 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z db  22h ; "
.xdata$x:00013444                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z+11o
.xdata$x:00013445                 db    5
.xdata$x:00013446                 db  93h ; ô
.xdata$x:00013447                 db  19h
.xdata$x:00013448                 db    1
.xdata$x:00013449                 db    0
.xdata$x:0001344A                 db    0
.xdata$x:0001344B                 db    0
.xdata$x:0001344C                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
.xdata$x:00013450                 db    0
.xdata$x:00013451                 db    0
.xdata$x:00013452                 db    0
.xdata$x:00013453                 db    0
.xdata$x:00013454                 db    0
.xdata$x:00013455                 db    0
.xdata$x:00013456                 db    0
.xdata$x:00013457                 db    0
.xdata$x:00013458                 db    0
.xdata$x:00013459                 db    0
.xdata$x:0001345A                 db    0
.xdata$x:0001345B                 db    0
.xdata$x:0001345C                 db    0
.xdata$x:0001345D                 db    0
.xdata$x:0001345E                 db    0
.xdata$x:0001345F                 db    0
.xdata$x:00013460                 db    0
.xdata$x:00013461                 db    0
.xdata$x:00013462                 db    0
.xdata$x:00013463                 db    0
.xdata$x:00013464                 db    0
.xdata$x:00013465                 db    0
.xdata$x:00013466                 db    0
.xdata$x:00013467                 db    0
.xdata$x:00013467 _xdata$x        ends
.xdata$x:00013467
.xdata$x:00013468 ; ===========================================================================
.xdata$x:00013468
.xdata$x:00013468 ; Segment type: Pure data
.xdata$x:00013468 ; Segment permissions: Read
.xdata$x:00013468 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013468                 assume cs:_xdata$x
.xdata$x:00013468                 ;org 13468h
.xdata$x:00013468 ; COMDAT (pick associative to section at B6DC)
.xdata$x:00013468 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00013468                                         ; DATA XREF: .xdata$x:00013478o
.xdata$x:00013469                 db 0FFh
.xdata$x:0001346A                 db 0FFh
.xdata$x:0001346B                 db 0FFh
.xdata$x:0001346C                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ$0
.xdata$x:00013470 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00013470                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ+11o
.xdata$x:00013471                 db    5
.xdata$x:00013472                 db  93h ; ô
.xdata$x:00013473                 db  19h
.xdata$x:00013474                 db    1
.xdata$x:00013475                 db    0
.xdata$x:00013476                 db    0
.xdata$x:00013477                 db    0
.xdata$x:00013478                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ
.xdata$x:0001347C                 db    0
.xdata$x:0001347D                 db    0
.xdata$x:0001347E                 db    0
.xdata$x:0001347F                 db    0
.xdata$x:00013480                 db    0
.xdata$x:00013481                 db    0
.xdata$x:00013482                 db    0
.xdata$x:00013483                 db    0
.xdata$x:00013484                 db    0
.xdata$x:00013485                 db    0
.xdata$x:00013486                 db    0
.xdata$x:00013487                 db    0
.xdata$x:00013488                 db    0
.xdata$x:00013489                 db    0
.xdata$x:0001348A                 db    0
.xdata$x:0001348B                 db    0
.xdata$x:0001348C                 db    0
.xdata$x:0001348D                 db    0
.xdata$x:0001348E                 db    0
.xdata$x:0001348F                 db    0
.xdata$x:00013490                 db    0
.xdata$x:00013491                 db    0
.xdata$x:00013492                 db    0
.xdata$x:00013493                 db    0
.xdata$x:00013493 _xdata$x        ends
.xdata$x:00013493
.xdata$x:00013494 ; ===========================================================================
.xdata$x:00013494
.xdata$x:00013494 ; Segment type: Pure data
.xdata$x:00013494 ; Segment permissions: Read
.xdata$x:00013494 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013494                 assume cs:_xdata$x
.xdata$x:00013494                 ;org 13494h
.xdata$x:00013494 ; COMDAT (pick associative to section at AA0C)
.xdata$x:00013494 __unwindtable$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ db 0FFh
.xdata$x:00013494                                         ; DATA XREF: .xdata$x:000134A4o
.xdata$x:00013495                 db 0FFh
.xdata$x:00013496                 db 0FFh
.xdata$x:00013497                 db 0FFh
.xdata$x:00013498                 dd offset __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0
.xdata$x:0001349C __ehfuncinfo$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0001349C                                         ; DATA XREF: __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ+11o
.xdata$x:0001349D                 db    5
.xdata$x:0001349E                 db  93h ; ô
.xdata$x:0001349F                 db  19h
.xdata$x:000134A0                 db    1
.xdata$x:000134A1                 db    0
.xdata$x:000134A2                 db    0
.xdata$x:000134A3                 db    0
.xdata$x:000134A4                 dd offset __unwindtable$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.xdata$x:000134A8                 align 20h
.xdata$x:000134A8 _xdata$x        ends
.xdata$x:000134A8
.xdata$x:000134C0 ; ===========================================================================
.xdata$x:000134C0
.xdata$x:000134C0 ; Segment type: Pure data
.xdata$x:000134C0 ; Segment permissions: Read
.xdata$x:000134C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000134C0                 assume cs:_xdata$x
.xdata$x:000134C0                 ;org 134C0h
.xdata$x:000134C0 ; COMDAT (pick associative to section at BD34)
.xdata$x:000134C0 __unwindtable$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ db 0FFh
.xdata$x:000134C0                                         ; DATA XREF: .xdata$x:000134D0o
.xdata$x:000134C1                 db 0FFh
.xdata$x:000134C2                 db 0FFh
.xdata$x:000134C3                 db 0FFh
.xdata$x:000134C4                 dd offset __unwindfunclet$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0
.xdata$x:000134C8 __ehfuncinfo$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000134C8                                         ; DATA XREF: __ehhandler$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ+11o
.xdata$x:000134C9                 db    5
.xdata$x:000134CA                 db  93h ; ô
.xdata$x:000134CB                 db  19h
.xdata$x:000134CC                 db    1
.xdata$x:000134CD                 db    0
.xdata$x:000134CE                 db    0
.xdata$x:000134CF                 db    0
.xdata$x:000134D0                 dd offset __unwindtable$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.xdata$x:000134D4                 db    0
.xdata$x:000134D5                 db    0
.xdata$x:000134D6                 db    0
.xdata$x:000134D7                 db    0
.xdata$x:000134D8                 db    0
.xdata$x:000134D9                 db    0
.xdata$x:000134DA                 db    0
.xdata$x:000134DB                 db    0
.xdata$x:000134DC                 db    0
.xdata$x:000134DD                 db    0
.xdata$x:000134DE                 db    0
.xdata$x:000134DF                 db    0
.xdata$x:000134E0                 db    0
.xdata$x:000134E1                 db    0
.xdata$x:000134E2                 db    0
.xdata$x:000134E3                 db    0
.xdata$x:000134E4                 db    0
.xdata$x:000134E5                 db    0
.xdata$x:000134E6                 db    0
.xdata$x:000134E7                 db    0
.xdata$x:000134E8                 db    0
.xdata$x:000134E9                 db    0
.xdata$x:000134EA                 db    0
.xdata$x:000134EB                 db    0
.xdata$x:000134EB _xdata$x        ends
.xdata$x:000134EB
.xdata$x:000134EC ; ===========================================================================
.xdata$x:000134EC
.xdata$x:000134EC ; Segment type: Pure data
.xdata$x:000134EC ; Segment permissions: Read
.xdata$x:000134EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000134EC                 assume cs:_xdata$x
.xdata$x:000134EC                 ;org 134ECh
.xdata$x:000134EC ; COMDAT (pick associative to section at EA48)
.xdata$x:000134EC __catchsym$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$2 db    0
.xdata$x:000134EC                                         ; DATA XREF: .xdata$x:0001351Co
.xdata$x:000134ED                 db    0
.xdata$x:000134EE                 db    0
.xdata$x:000134EF                 db    0
.xdata$x:000134F0                 db    0
.xdata$x:000134F1                 db    0
.xdata$x:000134F2                 db    0
.xdata$x:000134F3                 db    0
.xdata$x:000134F4                 db    0
.xdata$x:000134F5                 db    0
.xdata$x:000134F6                 db    0
.xdata$x:000134F7                 db    0
.xdata$x:000134F8                 dd offset __catch$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$0
.xdata$x:000134FC __unwindtable$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z db 0FFh
.xdata$x:000134FC                                         ; DATA XREF: .xdata$x:00013528o
.xdata$x:000134FD                 db 0FFh
.xdata$x:000134FE                 db 0FFh
.xdata$x:000134FF                 db 0FFh
.xdata$x:00013500                 db    0
.xdata$x:00013501                 db    0
.xdata$x:00013502                 db    0
.xdata$x:00013503                 db    0
.xdata$x:00013504                 db 0FFh
.xdata$x:00013505                 db 0FFh
.xdata$x:00013506                 db 0FFh
.xdata$x:00013507                 db 0FFh
.xdata$x:00013508                 db    0
.xdata$x:00013509                 db    0
.xdata$x:0001350A                 db    0
.xdata$x:0001350B                 db    0
.xdata$x:0001350C __tryblocktable$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z db    0
.xdata$x:0001350C                                         ; DATA XREF: .xdata$x:00013530o
.xdata$x:0001350D                 db    0
.xdata$x:0001350E                 db    0
.xdata$x:0001350F                 db    0
.xdata$x:00013510                 db    0
.xdata$x:00013511                 db    0
.xdata$x:00013512                 db    0
.xdata$x:00013513                 db    0
.xdata$x:00013514                 db    1
.xdata$x:00013515                 db    0
.xdata$x:00013516                 db    0
.xdata$x:00013517                 db    0
.xdata$x:00013518                 db    1
.xdata$x:00013519                 db    0
.xdata$x:0001351A                 db    0
.xdata$x:0001351B                 db    0
.xdata$x:0001351C                 dd offset __catchsym$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$2
.xdata$x:00013520 __ehfuncinfo$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z db  22h ; "
.xdata$x:00013520                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z+11o
.xdata$x:00013521                 db    5
.xdata$x:00013522                 db  93h ; ô
.xdata$x:00013523                 db  19h
.xdata$x:00013524                 db    2
.xdata$x:00013525                 db    0
.xdata$x:00013526                 db    0
.xdata$x:00013527                 db    0
.xdata$x:00013528                 dd offset __unwindtable$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.xdata$x:0001352C                 db    1
.xdata$x:0001352D                 db    0
.xdata$x:0001352E                 db    0
.xdata$x:0001352F                 db    0
.xdata$x:00013530                 dd offset __tryblocktable$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.xdata$x:00013534                 db    0
.xdata$x:00013535                 db    0
.xdata$x:00013536                 db    0
.xdata$x:00013537                 db    0
.xdata$x:00013538                 db    0
.xdata$x:00013539                 db    0
.xdata$x:0001353A                 db    0
.xdata$x:0001353B                 db    0
.xdata$x:0001353C                 db    0
.xdata$x:0001353D                 db    0
.xdata$x:0001353E                 db    0
.xdata$x:0001353F                 db    0
.xdata$x:00013540                 db    0
.xdata$x:00013541                 db    0
.xdata$x:00013542                 db    0
.xdata$x:00013543                 db    0
.xdata$x:00013543 _xdata$x        ends
.xdata$x:00013543
.xdata$x:00013544 ; ===========================================================================
.xdata$x:00013544
.xdata$x:00013544 ; Segment type: Pure data
.xdata$x:00013544 ; Segment permissions: Read
.xdata$x:00013544 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013544                 assume cs:_xdata$x
.xdata$x:00013544                 ;org 13544h
.xdata$x:00013544 ; COMDAT (pick associative to section at E604)
.xdata$x:00013544 __unwindtable$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z db 0FFh
.xdata$x:00013544                                         ; DATA XREF: .xdata$x:00013554o
.xdata$x:00013545                 db 0FFh
.xdata$x:00013546                 db 0FFh
.xdata$x:00013547                 db 0FFh
.xdata$x:00013548                 dd offset __unwindfunclet$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$0
.xdata$x:0001354C __ehfuncinfo$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z db  22h ; "
.xdata$x:0001354C                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z+11o
.xdata$x:0001354D                 db    5
.xdata$x:0001354E                 db  93h ; ô
.xdata$x:0001354F                 db  19h
.xdata$x:00013550                 db    1
.xdata$x:00013551                 db    0
.xdata$x:00013552                 db    0
.xdata$x:00013553                 db    0
.xdata$x:00013554                 dd offset __unwindtable$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.xdata$x:00013558                 db    0
.xdata$x:00013559                 db    0
.xdata$x:0001355A                 db    0
.xdata$x:0001355B                 db    0
.xdata$x:0001355C                 db    0
.xdata$x:0001355D                 db    0
.xdata$x:0001355E                 db    0
.xdata$x:0001355F                 db    0
.xdata$x:00013560                 db    0
.xdata$x:00013561                 db    0
.xdata$x:00013562                 db    0
.xdata$x:00013563                 db    0
.xdata$x:00013564                 db    0
.xdata$x:00013565                 db    0
.xdata$x:00013566                 db    0
.xdata$x:00013567                 db    0
.xdata$x:00013568                 db    0
.xdata$x:00013569                 db    0
.xdata$x:0001356A                 db    0
.xdata$x:0001356B                 db    0
.xdata$x:0001356C                 db    0
.xdata$x:0001356D                 db    0
.xdata$x:0001356E                 db    0
.xdata$x:0001356F                 db    0
.xdata$x:0001356F _xdata$x        ends
.xdata$x:0001356F
.xdata$x:00013570 ; ===========================================================================
.xdata$x:00013570
.xdata$x:00013570 ; Segment type: Pure data
.xdata$x:00013570 ; Segment permissions: Read
.xdata$x:00013570 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013570                 assume cs:_xdata$x
.xdata$x:00013570                 ;org 13570h
.xdata$x:00013570 ; COMDAT (pick associative to section at 1095C)
.xdata$x:00013570 __unwindtable$?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ db 0FFh
.xdata$x:00013570                                         ; DATA XREF: .xdata$x:00013580o
.xdata$x:00013571                 db 0FFh
.xdata$x:00013572                 db 0FFh
.xdata$x:00013573                 db 0FFh
.xdata$x:00013574                 dd offset __unwindfunclet$?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$0
.xdata$x:00013578 __ehfuncinfo$?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ db  22h ; "
.xdata$x:00013578                                         ; DATA XREF: __ehhandler$?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ+11o
.xdata$x:00013579                 db    5
.xdata$x:0001357A                 db  93h ; ô
.xdata$x:0001357B                 db  19h
.xdata$x:0001357C                 db    1
.xdata$x:0001357D                 db    0
.xdata$x:0001357E                 db    0
.xdata$x:0001357F                 db    0
.xdata$x:00013580                 dd offset __unwindtable$?getBackupFileName@Buffer@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
.xdata$x:00013584                 db    0
.xdata$x:00013585                 db    0
.xdata$x:00013586                 db    0
.xdata$x:00013587                 db    0
.xdata$x:00013588                 db    0
.xdata$x:00013589                 db    0
.xdata$x:0001358A                 db    0
.xdata$x:0001358B                 db    0
.xdata$x:0001358C                 db    0
.xdata$x:0001358D                 db    0
.xdata$x:0001358E                 db    0
.xdata$x:0001358F                 db    0
.xdata$x:00013590                 db    0
.xdata$x:00013591                 db    0
.xdata$x:00013592                 db    0
.xdata$x:00013593                 db    0
.xdata$x:00013594                 db    0
.xdata$x:00013595                 db    0
.xdata$x:00013596                 db    0
.xdata$x:00013597                 db    0
.xdata$x:00013598                 db    0
.xdata$x:00013599                 db    0
.xdata$x:0001359A                 db    0
.xdata$x:0001359B                 db    0
.xdata$x:0001359B _xdata$x        ends
.xdata$x:0001359B
.xdata$x:0001359C ; ===========================================================================
.xdata$x:0001359C
.xdata$x:0001359C ; Segment type: Pure data
.xdata$x:0001359C ; Segment permissions: Read
.xdata$x:0001359C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0001359C                 assume cs:_xdata$x
.xdata$x:0001359C                 ;org 1359Ch
.xdata$x:0001359C __unwindtable$?loadLastSession@Notepad_plus@@QAEXXZ db 0FFh
.xdata$x:0001359C                                         ; DATA XREF: .xdata$x:00013748o
.xdata$x:0001359D                 db 0FFh
.xdata$x:0001359E                 db 0FFh
.xdata$x:0001359F                 db 0FFh
.xdata$x:000135A0                 dd offset __unwindfunclet$?loadLastSession@Notepad_plus@@QAEXXZ$0
.xdata$x:000135A4 __unwindtable$?fileRename@Notepad_plus@@QAE_NPAVBuffer@@@Z db 0FFh
.xdata$x:000135A4                                         ; DATA XREF: .xdata$x:000137FCo
.xdata$x:000135A5                 db 0FFh
.xdata$x:000135A6                 db 0FFh
.xdata$x:000135A7                 db 0FFh
.xdata$x:000135A8                 dd offset __unwindfunclet$?fileRename@Notepad_plus@@QAE_NPAVBuffer@@@Z$0
.xdata$x:000135AC __unwindtable$?fileSaveAs@Notepad_plus@@QAE_NPAVBuffer@@_N@Z db 0FFh
.xdata$x:000135AC                                         ; DATA XREF: .xdata$x:00013820o
.xdata$x:000135AD                 db 0FFh
.xdata$x:000135AE                 db 0FFh
.xdata$x:000135AF                 db 0FFh
.xdata$x:000135B0                 dd offset __unwindfunclet$?fileSaveAs@Notepad_plus@@QAE_NPAVBuffer@@_N@Z$0
.xdata$x:000135B4 __unwindtable$?fileCloseAllToRight@Notepad_plus@@QAE_NXZ db 0FFh
.xdata$x:000135B4                                         ; DATA XREF: .xdata$x:00013868o
.xdata$x:000135B5                 db 0FFh
.xdata$x:000135B6                 db 0FFh
.xdata$x:000135B7                 db 0FFh
.xdata$x:000135B8                 dd offset __unwindfunclet$?fileCloseAllToRight@Notepad_plus@@QAE_NXZ$0
.xdata$x:000135BC __unwindtable$?fileCloseAllToLeft@Notepad_plus@@QAE_NXZ db 0FFh
.xdata$x:000135BC                                         ; DATA XREF: .xdata$x:0001388Co
.xdata$x:000135BD                 db 0FFh
.xdata$x:000135BE                 db 0FFh
.xdata$x:000135BF                 db 0FFh
.xdata$x:000135C0                 dd offset __unwindfunclet$?fileCloseAllToLeft@Notepad_plus@@QAE_NXZ$0
.xdata$x:000135C4 __unwindtable$?fileOpen@Notepad_plus@@QAEXXZ db 0FFh
.xdata$x:000135C4                                         ; DATA XREF: .xdata$x:000138F8o
.xdata$x:000135C5                 db 0FFh
.xdata$x:000135C6                 db 0FFh
.xdata$x:000135C7                 db 0FFh
.xdata$x:000135C8                 dd offset __unwindfunclet$?fileOpen@Notepad_plus@@QAEXXZ$0
.xdata$x:000135CC __unwindtable$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z db 0FFh
.xdata$x:000135CC                                         ; DATA XREF: .xdata$x:0001376Co
.xdata$x:000135CD                 db 0FFh
.xdata$x:000135CE                 db 0FFh
.xdata$x:000135CF                 db 0FFh
.xdata$x:000135D0                 dd offset __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z$0
.xdata$x:000135D4                 align 8
.xdata$x:000135D8                 dd offset __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z$1
.xdata$x:000135DC __unwindtable$?isFileSession@Notepad_plus@@QAE_NPB_W@Z db 0FFh
.xdata$x:000135DC                                         ; DATA XREF: .xdata$x:000137D8o
.xdata$x:000135DD                 db 0FFh
.xdata$x:000135DE                 db 0FFh
.xdata$x:000135DF                 db 0FFh
.xdata$x:000135E0                 dd offset __unwindfunclet$?isFileSession@Notepad_plus@@QAE_NPB_W@Z$0
.xdata$x:000135E4                 align 8
.xdata$x:000135E8                 dd offset __unwindfunclet$?isFileSession@Notepad_plus@@QAE_NPB_W@Z$1
.xdata$x:000135EC __unwindtable$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z db 0FFh
.xdata$x:000135EC                                         ; DATA XREF: .xdata$x:00013790o
.xdata$x:000135ED                 db 0FFh
.xdata$x:000135EE                 db 0FFh
.xdata$x:000135EF                 db 0FFh
.xdata$x:000135F0                 dd offset __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z$0
.xdata$x:000135F4                 align 8
.xdata$x:000135F8                 dd offset __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z$1
.xdata$x:000135FC                 align 10h
.xdata$x:00013600                 dd offset __unwindfunclet$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z$2
.xdata$x:00013604 __unwindtable$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z db 0FFh
.xdata$x:00013604                                         ; DATA XREF: .xdata$x:00013844o
.xdata$x:00013605                 db 0FFh
.xdata$x:00013606                 db 0FFh
.xdata$x:00013607                 db 0FFh
.xdata$x:00013608                 dd offset __unwindfunclet$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z$0
.xdata$x:0001360C                 db 0FFh
.xdata$x:0001360D                 db 0FFh
.xdata$x:0001360E                 db 0FFh
.xdata$x:0001360F                 db 0FFh
.xdata$x:00013610                 dd offset __unwindfunclet$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z$1
.xdata$x:00013614                 db    1
.xdata$x:00013615                 db    0
.xdata$x:00013616                 db    0
.xdata$x:00013617                 db    0
.xdata$x:00013618                 dd offset __unwindfunclet$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z$2
.xdata$x:0001361C __unwindtable$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z db 0FFh
.xdata$x:0001361C                                         ; DATA XREF: .xdata$x:000138B0o
.xdata$x:0001361D                 db 0FFh
.xdata$x:0001361E                 db 0FFh
.xdata$x:0001361F                 db 0FFh
.xdata$x:00013620                 dd offset __unwindfunclet$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z$0
.xdata$x:00013624                 align 8
.xdata$x:00013628                 dd offset __unwindfunclet$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z$1
.xdata$x:0001362C                 align 10h
.xdata$x:00013630                 dd offset __unwindfunclet$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z$2
.xdata$x:00013634 __unwindtable$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z db 0FFh
.xdata$x:00013634                                         ; DATA XREF: .xdata$x:000136DCo
.xdata$x:00013635                 db 0FFh
.xdata$x:00013636                 db 0FFh
.xdata$x:00013637                 db 0FFh
.xdata$x:00013638                 dd offset __unwindfunclet$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z$0
.xdata$x:0001363C                 align 10h
.xdata$x:00013640                 dd offset __unwindfunclet$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z$1
.xdata$x:00013644                 align 8
.xdata$x:00013648                 dd offset __unwindfunclet$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z$2
.xdata$x:0001364C                 db    2
.xdata$x:0001364D                 db    0
.xdata$x:0001364E                 db    0
.xdata$x:0001364F                 db    0
.xdata$x:00013650                 dd offset __unwindfunclet$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z$3
.xdata$x:00013654 __unwindtable$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z db 0FFh
.xdata$x:00013654                                         ; DATA XREF: .xdata$x:00013700o
.xdata$x:00013655                 db 0FFh
.xdata$x:00013656                 db 0FFh
.xdata$x:00013657                 db 0FFh
.xdata$x:00013658                 dd offset __unwindfunclet$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z$3
.xdata$x:0001365C                 align 10h
.xdata$x:00013660                 dd offset __unwindfunclet$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z$0
.xdata$x:00013664                 db    1
.xdata$x:00013665                 db    0
.xdata$x:00013666                 db    0
.xdata$x:00013667                 db    0
.xdata$x:00013668                 dd offset __unwindfunclet$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z$1
.xdata$x:0001366C                 db    2
.xdata$x:0001366D                 db    0
.xdata$x:0001366E                 db    0
.xdata$x:0001366F                 db    0
.xdata$x:00013670                 dd offset __unwindfunclet$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z$2
.xdata$x:00013674 __unwindtable$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z db 0FFh
.xdata$x:00013674                                         ; DATA XREF: .xdata$x:000137B4o
.xdata$x:00013675                 db 0FFh
.xdata$x:00013676                 db 0FFh
.xdata$x:00013677                 db 0FFh
.xdata$x:00013678                 dd offset __unwindfunclet$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z$0
.xdata$x:0001367C                 align 10h
.xdata$x:00013680                 dd offset __unwindfunclet$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z$1
.xdata$x:00013684                 db 0FFh
.xdata$x:00013685                 db 0FFh
.xdata$x:00013686                 db 0FFh
.xdata$x:00013687                 db 0FFh
.xdata$x:00013688                 dd offset __unwindfunclet$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z$2
.xdata$x:0001368C                 db 0FFh
.xdata$x:0001368D                 db 0FFh
.xdata$x:0001368E                 db 0FFh
.xdata$x:0001368F                 db 0FFh
.xdata$x:00013690                 dd offset __unwindfunclet$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z$3
.xdata$x:00013694 __unwindtable$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z db 0FFh
.xdata$x:00013694                                         ; DATA XREF: .xdata$x:000138D4o
.xdata$x:00013695                 db 0FFh
.xdata$x:00013696                 db 0FFh
.xdata$x:00013697                 db 0FFh
.xdata$x:00013698                 dd offset __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$0
.xdata$x:0001369C                 align 10h
.xdata$x:000136A0                 dd offset __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$1
.xdata$x:000136A4                 db 0FFh
.xdata$x:000136A5                 db 0FFh
.xdata$x:000136A6                 db 0FFh
.xdata$x:000136A7                 db 0FFh
.xdata$x:000136A8                 dd offset __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$2
.xdata$x:000136AC                 db    2
.xdata$x:000136AD                 db    0
.xdata$x:000136AE                 db    0
.xdata$x:000136AF                 db    0
.xdata$x:000136B0                 dd offset __unwindfunclet$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z$3
.xdata$x:000136B4 __unwindtable$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z db 0FFh
.xdata$x:000136B4                                         ; DATA XREF: .xdata$x:0001391Co
.xdata$x:000136B5                 db 0FFh
.xdata$x:000136B6                 db 0FFh
.xdata$x:000136B7                 db 0FFh
.xdata$x:000136B8                 dd offset __unwindfunclet$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z$0
.xdata$x:000136BC                 align 10h
.xdata$x:000136C0                 dd offset __unwindfunclet$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z$1
.xdata$x:000136C4                 align 8
.xdata$x:000136C8                 dd offset __unwindfunclet$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z$2
.xdata$x:000136CC                 db    2
.xdata$x:000136CD                 db    0
.xdata$x:000136CE                 db    0
.xdata$x:000136CF                 db    0
.xdata$x:000136D0                 dd offset __unwindfunclet$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z$3
.xdata$x:000136D4 __ehfuncinfo$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z db  22h ; "
.xdata$x:000136D4                                         ; DATA XREF: __ehhandler$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z+1Eo
.xdata$x:000136D5                 db    5
.xdata$x:000136D6                 db  93h ; ô
.xdata$x:000136D7                 db  19h
.xdata$x:000136D8                 db    4
.xdata$x:000136D9                 db    0
.xdata$x:000136DA                 db    0
.xdata$x:000136DB                 db    0
.xdata$x:000136DC                 dd offset __unwindtable$?setFileOpenSaveDlgFilters@Notepad_plus@@AAEHAAVFileDialog@@H@Z
.xdata$x:000136E0                 db    0
.xdata$x:000136E1                 db    0
.xdata$x:000136E2                 db    0
.xdata$x:000136E3                 db    0
.xdata$x:000136E4                 db    0
.xdata$x:000136E5                 db    0
.xdata$x:000136E6                 db    0
.xdata$x:000136E7                 db    0
.xdata$x:000136E8                 db    0
.xdata$x:000136E9                 db    0
.xdata$x:000136EA                 db    0
.xdata$x:000136EB                 db    0
.xdata$x:000136EC                 db    0
.xdata$x:000136ED                 db    0
.xdata$x:000136EE                 db    0
.xdata$x:000136EF                 db    0
.xdata$x:000136F0                 db    0
.xdata$x:000136F1                 db    0
.xdata$x:000136F2                 db    0
.xdata$x:000136F3                 db    0
.xdata$x:000136F4                 db    0
.xdata$x:000136F5                 db    0
.xdata$x:000136F6                 db    0
.xdata$x:000136F7                 db    0
.xdata$x:000136F8 __ehfuncinfo$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z db  22h ; "
.xdata$x:000136F8                                         ; DATA XREF: __ehhandler$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z+1Eo
.xdata$x:000136F9                 db    5
.xdata$x:000136FA                 db  93h ; ô
.xdata$x:000136FB                 db  19h
.xdata$x:000136FC                 db    4
.xdata$x:000136FD                 db    0
.xdata$x:000136FE                 db    0
.xdata$x:000136FF                 db    0
.xdata$x:00013700                 dd offset __unwindtable$?exts2Filters@Notepad_plus@@ABE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V23@@Z
.xdata$x:00013704                 db    0
.xdata$x:00013705                 db    0
.xdata$x:00013706                 db    0
.xdata$x:00013707                 db    0
.xdata$x:00013708                 db    0
.xdata$x:00013709                 db    0
.xdata$x:0001370A                 db    0
.xdata$x:0001370B                 db    0
.xdata$x:0001370C                 db    0
.xdata$x:0001370D                 db    0
.xdata$x:0001370E                 db    0
.xdata$x:0001370F                 db    0
.xdata$x:00013710                 db    0
.xdata$x:00013711                 db    0
.xdata$x:00013712                 db    0
.xdata$x:00013713                 db    0
.xdata$x:00013714                 db    0
.xdata$x:00013715                 db    0
.xdata$x:00013716                 db    0
.xdata$x:00013717                 db    0
.xdata$x:00013718                 db    0
.xdata$x:00013719                 db    0
.xdata$x:0001371A                 db    0
.xdata$x:0001371B                 db    0
.xdata$x:0001371C __ehfuncinfo$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z db  22h ; "
.xdata$x:0001371C                                         ; DATA XREF: __ehhandler$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z+14o
.xdata$x:0001371D                 db    5
.xdata$x:0001371E                 db  93h ; ô
.xdata$x:0001371F                 db  19h
.xdata$x:00013720                 db  10h
.xdata$x:00013721                 db    0
.xdata$x:00013722                 db    0
.xdata$x:00013723                 db    0
.xdata$x:00013724                 dd offset __unwindtable$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z
.xdata$x:00013728                 align 20h
.xdata$x:00013740 __ehfuncinfo$?loadLastSession@Notepad_plus@@QAEXXZ db  22h ; "
.xdata$x:00013740                                         ; DATA XREF: __ehhandler$?loadLastSession@Notepad_plus@@QAEXXZ+11o
.xdata$x:00013741                 db    5
.xdata$x:00013742                 db  93h ; ô
.xdata$x:00013743                 db  19h
.xdata$x:00013744                 db    1
.xdata$x:00013745                 db    0
.xdata$x:00013746                 db    0
.xdata$x:00013747                 db    0
.xdata$x:00013748                 dd offset __unwindtable$?loadLastSession@Notepad_plus@@QAEXXZ
.xdata$x:0001374C                 db    0
.xdata$x:0001374D                 db    0
.xdata$x:0001374E                 db    0
.xdata$x:0001374F                 db    0
.xdata$x:00013750                 db    0
.xdata$x:00013751                 db    0
.xdata$x:00013752                 db    0
.xdata$x:00013753                 db    0
.xdata$x:00013754                 db    0
.xdata$x:00013755                 db    0
.xdata$x:00013756                 db    0
.xdata$x:00013757                 db    0
.xdata$x:00013758                 db    0
.xdata$x:00013759                 db    0
.xdata$x:0001375A                 db    0
.xdata$x:0001375B                 db    0
.xdata$x:0001375C                 db    0
.xdata$x:0001375D                 db    0
.xdata$x:0001375E                 db    0
.xdata$x:0001375F                 db    0
.xdata$x:00013760                 db    0
.xdata$x:00013761                 db    0
.xdata$x:00013762                 db    0
.xdata$x:00013763                 db    0
.xdata$x:00013764 __ehfuncinfo$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z db  22h ; "
.xdata$x:00013764                                         ; DATA XREF: __ehhandler$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z+1Eo
.xdata$x:00013765                 db    5
.xdata$x:00013766                 db  93h ; ô
.xdata$x:00013767                 db  19h
.xdata$x:00013768                 db    2
.xdata$x:00013769                 db    0
.xdata$x:0001376A                 db    0
.xdata$x:0001376B                 db    0
.xdata$x:0001376C                 dd offset __unwindtable$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_W@Z
.xdata$x:00013770                 db    0
.xdata$x:00013771                 db    0
.xdata$x:00013772                 db    0
.xdata$x:00013773                 db    0
.xdata$x:00013774                 db    0
.xdata$x:00013775                 db    0
.xdata$x:00013776                 db    0
.xdata$x:00013777                 db    0
.xdata$x:00013778                 db    0
.xdata$x:00013779                 db    0
.xdata$x:0001377A                 db    0
.xdata$x:0001377B                 db    0
.xdata$x:0001377C                 db    0
.xdata$x:0001377D                 db    0
.xdata$x:0001377E                 db    0
.xdata$x:0001377F                 db    0
.xdata$x:00013780                 db    0
.xdata$x:00013781                 db    0
.xdata$x:00013782                 db    0
.xdata$x:00013783                 db    0
.xdata$x:00013784                 db    0
.xdata$x:00013785                 db    0
.xdata$x:00013786                 db    0
.xdata$x:00013787                 db    0
.xdata$x:00013788 __ehfuncinfo$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z db  22h ; "
.xdata$x:00013788                                         ; DATA XREF: __ehhandler$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z+1Eo
.xdata$x:00013789                 db    5
.xdata$x:0001378A                 db  93h ; ô
.xdata$x:0001378B                 db  19h
.xdata$x:0001378C                 db    3
.xdata$x:0001378D                 db    0
.xdata$x:0001378E                 db    0
.xdata$x:0001378F                 db    0
.xdata$x:00013790                 dd offset __unwindtable$?fileSaveSession@Notepad_plus@@QAEPB_WIPAPA_WPB_W@Z
.xdata$x:00013794                 db    0
.xdata$x:00013795                 db    0
.xdata$x:00013796                 db    0
.xdata$x:00013797                 db    0
.xdata$x:00013798                 db    0
.xdata$x:00013799                 db    0
.xdata$x:0001379A                 db    0
.xdata$x:0001379B                 db    0
.xdata$x:0001379C                 db    0
.xdata$x:0001379D                 db    0
.xdata$x:0001379E                 db    0
.xdata$x:0001379F                 db    0
.xdata$x:000137A0                 db    0
.xdata$x:000137A1                 db    0
.xdata$x:000137A2                 db    0
.xdata$x:000137A3                 db    0
.xdata$x:000137A4                 db    0
.xdata$x:000137A5                 db    0
.xdata$x:000137A6                 db    0
.xdata$x:000137A7                 db    0
.xdata$x:000137A8                 db    0
.xdata$x:000137A9                 db    0
.xdata$x:000137AA                 db    0
.xdata$x:000137AB                 db    0
.xdata$x:000137AC __ehfuncinfo$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z db  22h ; "
.xdata$x:000137AC                                         ; DATA XREF: __ehhandler$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z+1Eo
.xdata$x:000137AD                 db    5
.xdata$x:000137AE                 db  93h ; ô
.xdata$x:000137AF                 db  19h
.xdata$x:000137B0                 db    4
.xdata$x:000137B1                 db    0
.xdata$x:000137B2                 db    0
.xdata$x:000137B3                 db    0
.xdata$x:000137B4                 dd offset __unwindtable$?fileLoadSession@Notepad_plus@@QAE_NPB_W@Z
.xdata$x:000137B8                 db    0
.xdata$x:000137B9                 db    0
.xdata$x:000137BA                 db    0
.xdata$x:000137BB                 db    0
.xdata$x:000137BC                 db    0
.xdata$x:000137BD                 db    0
.xdata$x:000137BE                 db    0
.xdata$x:000137BF                 db    0
.xdata$x:000137C0                 db    0
.xdata$x:000137C1                 db    0
.xdata$x:000137C2                 db    0
.xdata$x:000137C3                 db    0
.xdata$x:000137C4                 db    0
.xdata$x:000137C5                 db    0
.xdata$x:000137C6                 db    0
.xdata$x:000137C7                 db    0
.xdata$x:000137C8                 db    0
.xdata$x:000137C9                 db    0
.xdata$x:000137CA                 db    0
.xdata$x:000137CB                 db    0
.xdata$x:000137CC                 db    0
.xdata$x:000137CD                 db    0
.xdata$x:000137CE                 db    0
.xdata$x:000137CF                 db    0
.xdata$x:000137D0 __ehfuncinfo$?isFileSession@Notepad_plus@@QAE_NPB_W@Z db  22h ; "
.xdata$x:000137D0                                         ; DATA XREF: __ehhandler$?isFileSession@Notepad_plus@@QAE_NPB_W@Z+1Bo
.xdata$x:000137D1                 db    5
.xdata$x:000137D2                 db  93h ; ô
.xdata$x:000137D3                 db  19h
.xdata$x:000137D4                 db    2
.xdata$x:000137D5                 db    0
.xdata$x:000137D6                 db    0
.xdata$x:000137D7                 db    0
.xdata$x:000137D8                 dd offset __unwindtable$?isFileSession@Notepad_plus@@QAE_NPB_W@Z
.xdata$x:000137DC                 db    0
.xdata$x:000137DD                 db    0
.xdata$x:000137DE                 db    0
.xdata$x:000137DF                 db    0
.xdata$x:000137E0                 db    0
.xdata$x:000137E1                 db    0
.xdata$x:000137E2                 db    0
.xdata$x:000137E3                 db    0
.xdata$x:000137E4                 db    0
.xdata$x:000137E5                 db    0
.xdata$x:000137E6                 db    0
.xdata$x:000137E7                 db    0
.xdata$x:000137E8                 db    0
.xdata$x:000137E9                 db    0
.xdata$x:000137EA                 db    0
.xdata$x:000137EB                 db    0
.xdata$x:000137EC                 db    0
.xdata$x:000137ED                 db    0
.xdata$x:000137EE                 db    0
.xdata$x:000137EF                 db    0
.xdata$x:000137F0                 db    0
.xdata$x:000137F1                 db    0
.xdata$x:000137F2                 db    0
.xdata$x:000137F3                 db    0
.xdata$x:000137F4 __ehfuncinfo$?fileRename@Notepad_plus@@QAE_NPAVBuffer@@@Z db  22h ; "
.xdata$x:000137F4                                         ; DATA XREF: __ehhandler$?fileRename@Notepad_plus@@QAE_NPAVBuffer@@@Z+1Eo
.xdata$x:000137F5                 db    5
.xdata$x:000137F6                 db  93h ; ô
.xdata$x:000137F7                 db  19h
.xdata$x:000137F8                 db    1
.xdata$x:000137F9                 db    0
.xdata$x:000137FA                 db    0
.xdata$x:000137FB                 db    0
.xdata$x:000137FC                 dd offset __unwindtable$?fileRename@Notepad_plus@@QAE_NPAVBuffer@@@Z
.xdata$x:00013800                 db    0
.xdata$x:00013801                 db    0
.xdata$x:00013802                 db    0
.xdata$x:00013803                 db    0
.xdata$x:00013804                 db    0
.xdata$x:00013805                 db    0
.xdata$x:00013806                 db    0
.xdata$x:00013807                 db    0
.xdata$x:00013808                 db    0
.xdata$x:00013809                 db    0
.xdata$x:0001380A                 db    0
.xdata$x:0001380B                 db    0
.xdata$x:0001380C                 db    0
.xdata$x:0001380D                 db    0
.xdata$x:0001380E                 db    0
.xdata$x:0001380F                 db    0
.xdata$x:00013810                 db    0
.xdata$x:00013811                 db    0
.xdata$x:00013812                 db    0
.xdata$x:00013813                 db    0
.xdata$x:00013814                 db    0
.xdata$x:00013815                 db    0
.xdata$x:00013816                 db    0
.xdata$x:00013817                 db    0
.xdata$x:00013818 __ehfuncinfo$?fileSaveAs@Notepad_plus@@QAE_NPAVBuffer@@_N@Z db  22h ; "
.xdata$x:00013818                                         ; DATA XREF: __ehhandler$?fileSaveAs@Notepad_plus@@QAE_NPAVBuffer@@_N@Z+1Eo
.xdata$x:00013819                 db    5
.xdata$x:0001381A                 db  93h ; ô
.xdata$x:0001381B                 db  19h
.xdata$x:0001381C                 db    1
.xdata$x:0001381D                 db    0
.xdata$x:0001381E                 db    0
.xdata$x:0001381F                 db    0
.xdata$x:00013820                 dd offset __unwindtable$?fileSaveAs@Notepad_plus@@QAE_NPAVBuffer@@_N@Z
.xdata$x:00013824                 db    0
.xdata$x:00013825                 db    0
.xdata$x:00013826                 db    0
.xdata$x:00013827                 db    0
.xdata$x:00013828                 db    0
.xdata$x:00013829                 db    0
.xdata$x:0001382A                 db    0
.xdata$x:0001382B                 db    0
.xdata$x:0001382C                 db    0
.xdata$x:0001382D                 db    0
.xdata$x:0001382E                 db    0
.xdata$x:0001382F                 db    0
.xdata$x:00013830                 db    0
.xdata$x:00013831                 db    0
.xdata$x:00013832                 db    0
.xdata$x:00013833                 db    0
.xdata$x:00013834                 db    0
.xdata$x:00013835                 db    0
.xdata$x:00013836                 db    0
.xdata$x:00013837                 db    0
.xdata$x:00013838                 db    0
.xdata$x:00013839                 db    0
.xdata$x:0001383A                 db    0
.xdata$x:0001383B                 db    0
.xdata$x:0001383C __ehfuncinfo$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z db  22h ; "
.xdata$x:0001383C                                         ; DATA XREF: __ehhandler$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z+1Eo
.xdata$x:0001383D                 db    5
.xdata$x:0001383E                 db  93h ; ô
.xdata$x:0001383F                 db  19h
.xdata$x:00013840                 db    3
.xdata$x:00013841                 db    0
.xdata$x:00013842                 db    0
.xdata$x:00013843                 db    0
.xdata$x:00013844                 dd offset __unwindtable$?fileSave@Notepad_plus@@QAE_NPAVBuffer@@@Z
.xdata$x:00013848                 align 20h
.xdata$x:00013860 __ehfuncinfo$?fileCloseAllToRight@Notepad_plus@@QAE_NXZ db  22h ; "
.xdata$x:00013860                                         ; DATA XREF: __ehhandler$?fileCloseAllToRight@Notepad_plus@@QAE_NXZ+11o
.xdata$x:00013861                 db    5
.xdata$x:00013862                 db  93h ; ô
.xdata$x:00013863                 db  19h
.xdata$x:00013864                 db    1
.xdata$x:00013865                 db    0
.xdata$x:00013866                 db    0
.xdata$x:00013867                 db    0
.xdata$x:00013868                 dd offset __unwindtable$?fileCloseAllToRight@Notepad_plus@@QAE_NXZ
.xdata$x:0001386C                 db    0
.xdata$x:0001386D                 db    0
.xdata$x:0001386E                 db    0
.xdata$x:0001386F                 db    0
.xdata$x:00013870                 db    0
.xdata$x:00013871                 db    0
.xdata$x:00013872                 db    0
.xdata$x:00013873                 db    0
.xdata$x:00013874                 db    0
.xdata$x:00013875                 db    0
.xdata$x:00013876                 db    0
.xdata$x:00013877                 db    0
.xdata$x:00013878                 db    0
.xdata$x:00013879                 db    0
.xdata$x:0001387A                 db    0
.xdata$x:0001387B                 db    0
.xdata$x:0001387C                 db    0
.xdata$x:0001387D                 db    0
.xdata$x:0001387E                 db    0
.xdata$x:0001387F                 db    0
.xdata$x:00013880                 db    0
.xdata$x:00013881                 db    0
.xdata$x:00013882                 db    0
.xdata$x:00013883                 db    0
.xdata$x:00013884 __ehfuncinfo$?fileCloseAllToLeft@Notepad_plus@@QAE_NXZ db  22h ; "
.xdata$x:00013884                                         ; DATA XREF: __ehhandler$?fileCloseAllToLeft@Notepad_plus@@QAE_NXZ+11o
.xdata$x:00013885                 db    5
.xdata$x:00013886                 db  93h ; ô
.xdata$x:00013887                 db  19h
.xdata$x:00013888                 db    1
.xdata$x:00013889                 db    0
.xdata$x:0001388A                 db    0
.xdata$x:0001388B                 db    0
.xdata$x:0001388C                 dd offset __unwindtable$?fileCloseAllToLeft@Notepad_plus@@QAE_NXZ
.xdata$x:00013890                 db    0
.xdata$x:00013891                 db    0
.xdata$x:00013892                 db    0
.xdata$x:00013893                 db    0
.xdata$x:00013894                 db    0
.xdata$x:00013895                 db    0
.xdata$x:00013896                 db    0
.xdata$x:00013897                 db    0
.xdata$x:00013898                 db    0
.xdata$x:00013899                 db    0
.xdata$x:0001389A                 db    0
.xdata$x:0001389B                 db    0
.xdata$x:0001389C                 db    0
.xdata$x:0001389D                 db    0
.xdata$x:0001389E                 db    0
.xdata$x:0001389F                 db    0
.xdata$x:000138A0                 db    0
.xdata$x:000138A1                 db    0
.xdata$x:000138A2                 db    0
.xdata$x:000138A3                 db    0
.xdata$x:000138A4                 db    0
.xdata$x:000138A5                 db    0
.xdata$x:000138A6                 db    0
.xdata$x:000138A7                 db    0
.xdata$x:000138A8 __ehfuncinfo$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z db  22h ; "
.xdata$x:000138A8                                         ; DATA XREF: __ehhandler$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z+11o
.xdata$x:000138A9                 db    5
.xdata$x:000138AA                 db  93h ; ô
.xdata$x:000138AB                 db  19h
.xdata$x:000138AC                 db    3
.xdata$x:000138AD                 db    0
.xdata$x:000138AE                 db    0
.xdata$x:000138AF                 db    0
.xdata$x:000138B0                 dd offset __unwindtable$?fileCloseAllGiven@Notepad_plus@@QAE_NABV?$vector@HV?$allocator@H@std@@@std@@@Z
.xdata$x:000138B4                 db    0
.xdata$x:000138B5                 db    0
.xdata$x:000138B6                 db    0
.xdata$x:000138B7                 db    0
.xdata$x:000138B8                 db    0
.xdata$x:000138B9                 db    0
.xdata$x:000138BA                 db    0
.xdata$x:000138BB                 db    0
.xdata$x:000138BC                 db    0
.xdata$x:000138BD                 db    0
.xdata$x:000138BE                 db    0
.xdata$x:000138BF                 db    0
.xdata$x:000138C0                 db    0
.xdata$x:000138C1                 db    0
.xdata$x:000138C2                 db    0
.xdata$x:000138C3                 db    0
.xdata$x:000138C4                 db    0
.xdata$x:000138C5                 db    0
.xdata$x:000138C6                 db    0
.xdata$x:000138C7                 db    0
.xdata$x:000138C8                 db    0
.xdata$x:000138C9                 db    0
.xdata$x:000138CA                 db    0
.xdata$x:000138CB                 db    0
.xdata$x:000138CC __ehfuncinfo$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z db  22h ; "
.xdata$x:000138CC                                         ; DATA XREF: __ehhandler$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z+1Eo
.xdata$x:000138CD                 db    5
.xdata$x:000138CE                 db  93h ; ô
.xdata$x:000138CF                 db  19h
.xdata$x:000138D0                 db    4
.xdata$x:000138D1                 db    0
.xdata$x:000138D2                 db    0
.xdata$x:000138D3                 db    0
.xdata$x:000138D4                 dd offset __unwindtable$?fileCloseAll@Notepad_plus@@QAE_N_N0@Z
.xdata$x:000138D8                 db    0
.xdata$x:000138D9                 db    0
.xdata$x:000138DA                 db    0
.xdata$x:000138DB                 db    0
.xdata$x:000138DC                 db    0
.xdata$x:000138DD                 db    0
.xdata$x:000138DE                 db    0
.xdata$x:000138DF                 db    0
.xdata$x:000138E0                 db    0
.xdata$x:000138E1                 db    0
.xdata$x:000138E2                 db    0
.xdata$x:000138E3                 db    0
.xdata$x:000138E4                 db    0
.xdata$x:000138E5                 db    0
.xdata$x:000138E6                 db    0
.xdata$x:000138E7                 db    0
.xdata$x:000138E8                 db    0
.xdata$x:000138E9                 db    0
.xdata$x:000138EA                 db    0
.xdata$x:000138EB                 db    0
.xdata$x:000138EC                 db    0
.xdata$x:000138ED                 db    0
.xdata$x:000138EE                 db    0
.xdata$x:000138EF                 db    0
.xdata$x:000138F0 __ehfuncinfo$?fileOpen@Notepad_plus@@QAEXXZ db  22h ; "
.xdata$x:000138F0                                         ; DATA XREF: __ehhandler$?fileOpen@Notepad_plus@@QAEXXZ+1Eo
.xdata$x:000138F1                 db    5
.xdata$x:000138F2                 db  93h ; ô
.xdata$x:000138F3                 db  19h
.xdata$x:000138F4                 db    1
.xdata$x:000138F5                 db    0
.xdata$x:000138F6                 db    0
.xdata$x:000138F7                 db    0
.xdata$x:000138F8                 dd offset __unwindtable$?fileOpen@Notepad_plus@@QAEXXZ
.xdata$x:000138FC                 db    0
.xdata$x:000138FD                 db    0
.xdata$x:000138FE                 db    0
.xdata$x:000138FF                 db    0
.xdata$x:00013900                 db    0
.xdata$x:00013901                 db    0
.xdata$x:00013902                 db    0
.xdata$x:00013903                 db    0
.xdata$x:00013904                 db    0
.xdata$x:00013905                 db    0
.xdata$x:00013906                 db    0
.xdata$x:00013907                 db    0
.xdata$x:00013908                 db    0
.xdata$x:00013909                 db    0
.xdata$x:0001390A                 db    0
.xdata$x:0001390B                 db    0
.xdata$x:0001390C                 db    0
.xdata$x:0001390D                 db    0
.xdata$x:0001390E                 db    0
.xdata$x:0001390F                 db    0
.xdata$x:00013910                 db    0
.xdata$x:00013911                 db    0
.xdata$x:00013912                 db    0
.xdata$x:00013913                 db    0
.xdata$x:00013914 __ehfuncinfo$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z db  22h ; "
.xdata$x:00013914                                         ; DATA XREF: __ehhandler$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z+1Eo
.xdata$x:00013915                 db    5
.xdata$x:00013916                 db  93h ; ô
.xdata$x:00013917                 db  19h
.xdata$x:00013918                 db    4
.xdata$x:00013919                 db    0
.xdata$x:0001391A                 db    0
.xdata$x:0001391B                 db    0
.xdata$x:0001391C                 dd offset __unwindtable$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z
.xdata$x:00013920                 db    0
.xdata$x:00013921                 db    0
.xdata$x:00013922                 db    0
.xdata$x:00013923                 db    0
.xdata$x:00013924                 db    0
.xdata$x:00013925                 db    0
.xdata$x:00013926                 db    0
.xdata$x:00013927                 db    0
.xdata$x:00013928                 db    0
.xdata$x:00013929                 db    0
.xdata$x:0001392A                 db    0
.xdata$x:0001392B                 db    0
.xdata$x:0001392C                 db    0
.xdata$x:0001392D                 db    0
.xdata$x:0001392E                 db    0
.xdata$x:0001392F                 db    0
.xdata$x:00013930                 db    0
.xdata$x:00013931                 db    0
.xdata$x:00013932                 db    0
.xdata$x:00013933                 db    0
.xdata$x:00013934                 db    0
.xdata$x:00013935                 db    0
.xdata$x:00013936                 db    0
.xdata$x:00013937                 db    0
.xdata$x:00013938 __ehfuncinfo$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z db  22h ; "
.xdata$x:00013938                                         ; DATA XREF: __ehhandler$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z+1Eo
.xdata$x:00013939                 db    5
.xdata$x:0001393A                 db  93h ; ô
.xdata$x:0001393B                 db  19h
.xdata$x:0001393C                 db    9
.xdata$x:0001393D                 db    0
.xdata$x:0001393E                 db    0
.xdata$x:0001393F                 db    0
.xdata$x:00013940                 dd offset __unwindtable$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z
.xdata$x:00013944                 db    0
.xdata$x:00013945                 db    0
.xdata$x:00013946                 db    0
.xdata$x:00013947                 db    0
.xdata$x:00013948                 db    0
.xdata$x:00013949                 db    0
.xdata$x:0001394A                 db    0
.xdata$x:0001394B                 db    0
.xdata$x:0001394C                 db    0
.xdata$x:0001394D                 db    0
.xdata$x:0001394E                 db    0
.xdata$x:0001394F                 db    0
.xdata$x:00013950                 db    0
.xdata$x:00013951                 db    0
.xdata$x:00013952                 db    0
.xdata$x:00013953                 db    0
.xdata$x:00013954                 db    0
.xdata$x:00013955                 db    0
.xdata$x:00013956                 db    0
.xdata$x:00013957                 db    0
.xdata$x:00013958                 db    0
.xdata$x:00013959                 db    0
.xdata$x:0001395A                 db    0
.xdata$x:0001395B                 db    0
.xdata$x:0001395C __unwindtable$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z db 0FFh
.xdata$x:0001395C                                         ; DATA XREF: .xdata$x:00013940o
.xdata$x:0001395D                 db 0FFh
.xdata$x:0001395E                 db 0FFh
.xdata$x:0001395F                 db 0FFh
.xdata$x:00013960                 dd offset __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$0
.xdata$x:00013964                 align 8
.xdata$x:00013968                 dd offset __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$1
.xdata$x:0001396C                 align 10h
.xdata$x:00013970                 dd offset __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$3
.xdata$x:00013974                 db    2
.xdata$x:00013975                 db    0
.xdata$x:00013976                 db    0
.xdata$x:00013977                 db    0
.xdata$x:00013978                 dd offset __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$4
.xdata$x:0001397C                 db    3
.xdata$x:0001397D                 db    0
.xdata$x:0001397E                 db    0
.xdata$x:0001397F                 db    0
.xdata$x:00013980                 dd offset __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$5
.xdata$x:00013984                 db    3
.xdata$x:00013985                 db    0
.xdata$x:00013986                 db    0
.xdata$x:00013987                 db    0
.xdata$x:00013988                 dd offset __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$6
.xdata$x:0001398C                 db    3
.xdata$x:0001398D                 db    0
.xdata$x:0001398E                 db    0
.xdata$x:0001398F                 db    0
.xdata$x:00013990                 dd offset __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$7
.xdata$x:00013994                 db    6
.xdata$x:00013995                 db    0
.xdata$x:00013996                 db    0
.xdata$x:00013997                 db    0
.xdata$x:00013998                 dd offset __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$8
.xdata$x:0001399C                 align 10h
.xdata$x:000139A0                 dd offset __unwindfunclet$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z$9
.xdata$x:000139A4 __unwindtable$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z db 0FFh
.xdata$x:000139A4                                         ; DATA XREF: .xdata$x:00013724o
.xdata$x:000139A5                 db 0FFh
.xdata$x:000139A6                 db 0FFh
.xdata$x:000139A7                 db 0FFh
.xdata$x:000139A8                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$0
.xdata$x:000139AC                 align 10h
.xdata$x:000139B0                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$1
.xdata$x:000139B4                 db 0FFh
.xdata$x:000139B5                 db 0FFh
.xdata$x:000139B6                 db 0FFh
.xdata$x:000139B7                 db 0FFh
.xdata$x:000139B8                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$1
.xdata$x:000139BC                 db    2
.xdata$x:000139BD                 db    0
.xdata$x:000139BE                 db    0
.xdata$x:000139BF                 db    0
.xdata$x:000139C0                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$2
.xdata$x:000139C4                 db 0FFh
.xdata$x:000139C5                 db 0FFh
.xdata$x:000139C6                 db 0FFh
.xdata$x:000139C7                 db 0FFh
.xdata$x:000139C8                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$4
.xdata$x:000139CC                 db    4
.xdata$x:000139CD                 db    0
.xdata$x:000139CE                 db    0
.xdata$x:000139CF                 db    0
.xdata$x:000139D0                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$5
.xdata$x:000139D4                 db 0FFh
.xdata$x:000139D5                 db 0FFh
.xdata$x:000139D6                 db 0FFh
.xdata$x:000139D7                 db 0FFh
.xdata$x:000139D8                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$5
.xdata$x:000139DC                 db    6
.xdata$x:000139DD                 db    0
.xdata$x:000139DE                 db    0
.xdata$x:000139DF                 db    0
.xdata$x:000139E0                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$6
.xdata$x:000139E4                 db 0FFh
.xdata$x:000139E5                 db 0FFh
.xdata$x:000139E6                 db 0FFh
.xdata$x:000139E7                 db 0FFh
.xdata$x:000139E8                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$8
.xdata$x:000139EC                 db    8
.xdata$x:000139ED                 db    0
.xdata$x:000139EE                 db    0
.xdata$x:000139EF                 db    0
.xdata$x:000139F0                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$9
.xdata$x:000139F4                 db 0FFh
.xdata$x:000139F5                 db 0FFh
.xdata$x:000139F6                 db 0FFh
.xdata$x:000139F7                 db 0FFh
.xdata$x:000139F8                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$9
.xdata$x:000139FC                 db  0Ah
.xdata$x:000139FD                 db    0
.xdata$x:000139FE                 db    0
.xdata$x:000139FF                 db    0
.xdata$x:00013A00                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$10
.xdata$x:00013A04                 db 0FFh
.xdata$x:00013A05                 db 0FFh
.xdata$x:00013A06                 db 0FFh
.xdata$x:00013A07                 db 0FFh
.xdata$x:00013A08                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$12
.xdata$x:00013A0C                 db  0Ch
.xdata$x:00013A0D                 db    0
.xdata$x:00013A0E                 db    0
.xdata$x:00013A0F                 db    0
.xdata$x:00013A10                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$13
.xdata$x:00013A14                 db 0FFh
.xdata$x:00013A15                 db 0FFh
.xdata$x:00013A16                 db 0FFh
.xdata$x:00013A17                 db 0FFh
.xdata$x:00013A18                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$13
.xdata$x:00013A1C                 db  0Eh
.xdata$x:00013A1D                 db    0
.xdata$x:00013A1E                 db    0
.xdata$x:00013A1F                 db    0
.xdata$x:00013A20                 dd offset __unwindfunclet$?loadSession@Notepad_plus@@QAE_NAAUSession@@_N@Z$14
.xdata$x:00013A20 _xdata$x        ends
.xdata$x:00013A20
.xdata$x:00013A24 ; ===========================================================================
.xdata$x:00013A24
.xdata$x:00013A24 ; Segment type: Pure data
.xdata$x:00013A24 ; Segment permissions: Read
.xdata$x:00013A24 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013A24                 assume cs:_xdata$x
.xdata$x:00013A24                 ;org 13A24h
.xdata$x:00013A24 ; COMDAT (pick associative to section at 93C4)
.xdata$x:00013A24 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00013A24                                         ; DATA XREF: .xdata$x:00013A34o
.xdata$x:00013A25                 db 0FFh
.xdata$x:00013A26                 db 0FFh
.xdata$x:00013A27                 db 0FFh
.xdata$x:00013A28                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00013A2C __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00013A2C                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00013A2D                 db    5
.xdata$x:00013A2E                 db  93h ; ô
.xdata$x:00013A2F                 db  19h
.xdata$x:00013A30                 db    1
.xdata$x:00013A31                 db    0
.xdata$x:00013A32                 db    0
.xdata$x:00013A33                 db    0
.xdata$x:00013A34                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00013A38                 db    0
.xdata$x:00013A39                 db    0
.xdata$x:00013A3A                 db    0
.xdata$x:00013A3B                 db    0
.xdata$x:00013A3C                 db    0
.xdata$x:00013A3D                 db    0
.xdata$x:00013A3E                 db    0
.xdata$x:00013A3F                 db    0
.xdata$x:00013A40                 db    0
.xdata$x:00013A41                 db    0
.xdata$x:00013A42                 db    0
.xdata$x:00013A43                 db    0
.xdata$x:00013A44                 db    0
.xdata$x:00013A45                 db    0
.xdata$x:00013A46                 db    0
.xdata$x:00013A47                 db    0
.xdata$x:00013A48                 db    0
.xdata$x:00013A49                 db    0
.xdata$x:00013A4A                 db    0
.xdata$x:00013A4B                 db    0
.xdata$x:00013A4C                 db    0
.xdata$x:00013A4D                 db    0
.xdata$x:00013A4E                 db    0
.xdata$x:00013A4F                 db    0
.xdata$x:00013A4F _xdata$x        ends
.xdata$x:00013A4F
.xdata$x:00013A50 ; ===========================================================================
.xdata$x:00013A50
.xdata$x:00013A50 ; Segment type: Pure data
.xdata$x:00013A50 ; Segment permissions: Read
.xdata$x:00013A50 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013A50                 assume cs:_xdata$x
.xdata$x:00013A50                 ;org 13A50h
.xdata$x:00013A50 ; COMDAT (pick associative to section at B254)
.xdata$x:00013A50 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00013A50                                         ; DATA XREF: .xdata$x:00013A60o
.xdata$x:00013A51                 db 0FFh
.xdata$x:00013A52                 db 0FFh
.xdata$x:00013A53                 db 0FFh
.xdata$x:00013A54                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00013A58 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00013A58                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00013A59                 db    5
.xdata$x:00013A5A                 db  93h ; ô
.xdata$x:00013A5B                 db  19h
.xdata$x:00013A5C                 db    1
.xdata$x:00013A5D                 db    0
.xdata$x:00013A5E                 db    0
.xdata$x:00013A5F                 db    0
.xdata$x:00013A60                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00013A64                 db    0
.xdata$x:00013A65                 db    0
.xdata$x:00013A66                 db    0
.xdata$x:00013A67                 db    0
.xdata$x:00013A68                 db    0
.xdata$x:00013A69                 db    0
.xdata$x:00013A6A                 db    0
.xdata$x:00013A6B                 db    0
.xdata$x:00013A6C                 db    0
.xdata$x:00013A6D                 db    0
.xdata$x:00013A6E                 db    0
.xdata$x:00013A6F                 db    0
.xdata$x:00013A70                 db    0
.xdata$x:00013A71                 db    0
.xdata$x:00013A72                 db    0
.xdata$x:00013A73                 db    0
.xdata$x:00013A74                 db    0
.xdata$x:00013A75                 db    0
.xdata$x:00013A76                 db    0
.xdata$x:00013A77                 db    0
.xdata$x:00013A78                 db    0
.xdata$x:00013A79                 db    0
.xdata$x:00013A7A                 db    0
.xdata$x:00013A7B                 db    0
.xdata$x:00013A7B _xdata$x        ends
.xdata$x:00013A7B
.xdata$x:00013A7C ; ===========================================================================
.xdata$x:00013A7C
.xdata$x:00013A7C ; Segment type: Pure data
.xdata$x:00013A7C ; Segment permissions: Read
.xdata$x:00013A7C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013A7C                 assume cs:_xdata$x
.xdata$x:00013A7C                 ;org 13A7Ch
.xdata$x:00013A7C ; COMDAT (pick associative to section at 934C)
.xdata$x:00013A7C __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:00013A7C                                         ; DATA XREF: .xdata$x:00013A8Co
.xdata$x:00013A7D                 db 0FFh
.xdata$x:00013A7E                 db 0FFh
.xdata$x:00013A7F                 db 0FFh
.xdata$x:00013A80                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:00013A84 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:00013A84                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:00013A85                 db    5
.xdata$x:00013A86                 db  93h ; ô
.xdata$x:00013A87                 db  19h
.xdata$x:00013A88                 db    1
.xdata$x:00013A89                 db    0
.xdata$x:00013A8A                 db    0
.xdata$x:00013A8B                 db    0
.xdata$x:00013A8C                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:00013A90                 db    0
.xdata$x:00013A91                 db    0
.xdata$x:00013A92                 db    0
.xdata$x:00013A93                 db    0
.xdata$x:00013A94                 db    0
.xdata$x:00013A95                 db    0
.xdata$x:00013A96                 db    0
.xdata$x:00013A97                 db    0
.xdata$x:00013A98                 db    0
.xdata$x:00013A99                 db    0
.xdata$x:00013A9A                 db    0
.xdata$x:00013A9B                 db    0
.xdata$x:00013A9C                 db    0
.xdata$x:00013A9D                 db    0
.xdata$x:00013A9E                 db    0
.xdata$x:00013A9F                 db    0
.xdata$x:00013AA0                 db    0
.xdata$x:00013AA1                 db    0
.xdata$x:00013AA2                 db    0
.xdata$x:00013AA3                 db    0
.xdata$x:00013AA4                 db    0
.xdata$x:00013AA5                 db    0
.xdata$x:00013AA6                 db    0
.xdata$x:00013AA7                 db    0
.xdata$x:00013AA7 _xdata$x        ends
.xdata$x:00013AA7
.xdata$x:00013AA8 ; ===========================================================================
.xdata$x:00013AA8
.xdata$x:00013AA8 ; Segment type: Pure data
.xdata$x:00013AA8 ; Segment permissions: Read
.xdata$x:00013AA8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013AA8                 assume cs:_xdata$x
.xdata$x:00013AA8                 ;org 13AA8h
.xdata$x:00013AA8 ; COMDAT (pick associative to section at 95B4)
.xdata$x:00013AA8 __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z db 0FFh
.xdata$x:00013AA8                                         ; DATA XREF: .xdata$x:00013AB8o
.xdata$x:00013AA9                 db 0FFh
.xdata$x:00013AAA                 db 0FFh
.xdata$x:00013AAB                 db 0FFh
.xdata$x:00013AAC                 dd offset __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0
.xdata$x:00013AB0 __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00013AB0                                         ; DATA XREF: __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z+11o
.xdata$x:00013AB1                 db    5
.xdata$x:00013AB2                 db  93h ; ô
.xdata$x:00013AB3                 db  19h
.xdata$x:00013AB4                 db    1
.xdata$x:00013AB5                 db    0
.xdata$x:00013AB6                 db    0
.xdata$x:00013AB7                 db    0
.xdata$x:00013AB8                 dd offset __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.xdata$x:00013ABC                 db    0
.xdata$x:00013ABD                 db    0
.xdata$x:00013ABE                 db    0
.xdata$x:00013ABF                 db    0
.xdata$x:00013AC0                 db    0
.xdata$x:00013AC1                 db    0
.xdata$x:00013AC2                 db    0
.xdata$x:00013AC3                 db    0
.xdata$x:00013AC4                 db    0
.xdata$x:00013AC5                 db    0
.xdata$x:00013AC6                 db    0
.xdata$x:00013AC7                 db    0
.xdata$x:00013AC8                 db    0
.xdata$x:00013AC9                 db    0
.xdata$x:00013ACA                 db    0
.xdata$x:00013ACB                 db    0
.xdata$x:00013ACC                 db    0
.xdata$x:00013ACD                 db    0
.xdata$x:00013ACE                 db    0
.xdata$x:00013ACF                 db    0
.xdata$x:00013AD0                 db    0
.xdata$x:00013AD1                 db    0
.xdata$x:00013AD2                 db    0
.xdata$x:00013AD3                 db    0
.xdata$x:00013AD3 _xdata$x        ends
.xdata$x:00013AD3
.xdata$x:00013AD4 ; ===========================================================================
.xdata$x:00013AD4
.xdata$x:00013AD4 ; Segment type: Pure data
.xdata$x:00013AD4 ; Segment permissions: Read
.xdata$x:00013AD4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013AD4                 assume cs:_xdata$x
.xdata$x:00013AD4                 ;org 13AD4h
.xdata$x:00013AD4 ; COMDAT (pick associative to section at B3B4)
.xdata$x:00013AD4 __unwindtable$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00013AD4                                         ; DATA XREF: .xdata$x:00013AE4o
.xdata$x:00013AD5                 db 0FFh
.xdata$x:00013AD6                 db 0FFh
.xdata$x:00013AD7                 db 0FFh
.xdata$x:00013AD8                 dd offset __unwindfunclet$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00013ADC __ehfuncinfo$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00013ADC                                         ; DATA XREF: __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00013ADD                 db    5
.xdata$x:00013ADE                 db  93h ; ô
.xdata$x:00013ADF                 db  19h
.xdata$x:00013AE0                 db    1
.xdata$x:00013AE1                 db    0
.xdata$x:00013AE2                 db    0
.xdata$x:00013AE3                 db    0
.xdata$x:00013AE4                 dd offset __unwindtable$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:00013AE8                 align 20h
.xdata$x:00013AE8 _xdata$x        ends
.xdata$x:00013AE8
.xdata$x:00013B00 ; ===========================================================================
.xdata$x:00013B00
.xdata$x:00013B00 ; Segment type: Pure data
.xdata$x:00013B00 ; Segment permissions: Read
.xdata$x:00013B00 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013B00                 assume cs:_xdata$x
.xdata$x:00013B00                 ;org 13B00h
.xdata$x:00013B00 ; COMDAT (pick associative to section at 9530)
.xdata$x:00013B00 __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00013B00                                         ; DATA XREF: .xdata$x:00013B10o
.xdata$x:00013B01                 db 0FFh
.xdata$x:00013B02                 db 0FFh
.xdata$x:00013B03                 db 0FFh
.xdata$x:00013B04                 dd offset __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00013B08 __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00013B08                                         ; DATA XREF: __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00013B09                 db    5
.xdata$x:00013B0A                 db  93h ; ô
.xdata$x:00013B0B                 db  19h
.xdata$x:00013B0C                 db    1
.xdata$x:00013B0D                 db    0
.xdata$x:00013B0E                 db    0
.xdata$x:00013B0F                 db    0
.xdata$x:00013B10                 dd offset __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00013B14                 db    0
.xdata$x:00013B15                 db    0
.xdata$x:00013B16                 db    0
.xdata$x:00013B17                 db    0
.xdata$x:00013B18                 db    0
.xdata$x:00013B19                 db    0
.xdata$x:00013B1A                 db    0
.xdata$x:00013B1B                 db    0
.xdata$x:00013B1C                 db    0
.xdata$x:00013B1D                 db    0
.xdata$x:00013B1E                 db    0
.xdata$x:00013B1F                 db    0
.xdata$x:00013B20                 db    0
.xdata$x:00013B21                 db    0
.xdata$x:00013B22                 db    0
.xdata$x:00013B23                 db    0
.xdata$x:00013B24                 db    0
.xdata$x:00013B25                 db    0
.xdata$x:00013B26                 db    0
.xdata$x:00013B27                 db    0
.xdata$x:00013B28                 db    0
.xdata$x:00013B29                 db    0
.xdata$x:00013B2A                 db    0
.xdata$x:00013B2B                 db    0
.xdata$x:00013B2B _xdata$x        ends
.xdata$x:00013B2B
.xdata$x:00013B2C ; ===========================================================================
.xdata$x:00013B2C
.xdata$x:00013B2C ; Segment type: Pure data
.xdata$x:00013B2C ; Segment permissions: Read
.xdata$x:00013B2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013B2C                 assume cs:_xdata$x
.xdata$x:00013B2C                 ;org 13B2Ch
.xdata$x:00013B2C ; COMDAT (pick associative to section at 9100)
.xdata$x:00013B2C __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00013B2C                                         ; DATA XREF: .xdata$x:00013B3Co
.xdata$x:00013B2D                 db 0FFh
.xdata$x:00013B2E                 db 0FFh
.xdata$x:00013B2F                 db 0FFh
.xdata$x:00013B30                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00013B34 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00013B34                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00013B35                 db    5
.xdata$x:00013B36                 db  93h ; ô
.xdata$x:00013B37                 db  19h
.xdata$x:00013B38                 db    1
.xdata$x:00013B39                 db    0
.xdata$x:00013B3A                 db    0
.xdata$x:00013B3B                 db    0
.xdata$x:00013B3C                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00013B40                 db    0
.xdata$x:00013B41                 db    0
.xdata$x:00013B42                 db    0
.xdata$x:00013B43                 db    0
.xdata$x:00013B44                 db    0
.xdata$x:00013B45                 db    0
.xdata$x:00013B46                 db    0
.xdata$x:00013B47                 db    0
.xdata$x:00013B48                 db    0
.xdata$x:00013B49                 db    0
.xdata$x:00013B4A                 db    0
.xdata$x:00013B4B                 db    0
.xdata$x:00013B4C                 db    0
.xdata$x:00013B4D                 db    0
.xdata$x:00013B4E                 db    0
.xdata$x:00013B4F                 db    0
.xdata$x:00013B50                 db    0
.xdata$x:00013B51                 db    0
.xdata$x:00013B52                 db    0
.xdata$x:00013B53                 db    0
.xdata$x:00013B54                 db    0
.xdata$x:00013B55                 db    0
.xdata$x:00013B56                 db    0
.xdata$x:00013B57                 db    0
.xdata$x:00013B57 _xdata$x        ends
.xdata$x:00013B57
.xdata$x:00013B58 ; ===========================================================================
.xdata$x:00013B58
.xdata$x:00013B58 ; Segment type: Pure data
.xdata$x:00013B58 ; Segment permissions: Read
.xdata$x:00013B58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013B58                 assume cs:_xdata$x
.xdata$x:00013B58                 ;org 13B58h
.xdata$x:00013B58 ; COMDAT (pick associative to section at B104)
.xdata$x:00013B58 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00013B58                                         ; DATA XREF: .xdata$x:00013B68o
.xdata$x:00013B59                 db 0FFh
.xdata$x:00013B5A                 db 0FFh
.xdata$x:00013B5B                 db 0FFh
.xdata$x:00013B5C                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00013B60 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00013B60                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00013B61                 db    5
.xdata$x:00013B62                 db  93h ; ô
.xdata$x:00013B63                 db  19h
.xdata$x:00013B64                 db    1
.xdata$x:00013B65                 db    0
.xdata$x:00013B66                 db    0
.xdata$x:00013B67                 db    0
.xdata$x:00013B68                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00013B6C                 db    0
.xdata$x:00013B6D                 db    0
.xdata$x:00013B6E                 db    0
.xdata$x:00013B6F                 db    0
.xdata$x:00013B70                 db    0
.xdata$x:00013B71                 db    0
.xdata$x:00013B72                 db    0
.xdata$x:00013B73                 db    0
.xdata$x:00013B74                 db    0
.xdata$x:00013B75                 db    0
.xdata$x:00013B76                 db    0
.xdata$x:00013B77                 db    0
.xdata$x:00013B78                 db    0
.xdata$x:00013B79                 db    0
.xdata$x:00013B7A                 db    0
.xdata$x:00013B7B                 db    0
.xdata$x:00013B7C                 db    0
.xdata$x:00013B7D                 db    0
.xdata$x:00013B7E                 db    0
.xdata$x:00013B7F                 db    0
.xdata$x:00013B80                 db    0
.xdata$x:00013B81                 db    0
.xdata$x:00013B82                 db    0
.xdata$x:00013B83                 db    0
.xdata$x:00013B83 _xdata$x        ends
.xdata$x:00013B83
.xdata$x:00013B84 ; ===========================================================================
.xdata$x:00013B84
.xdata$x:00013B84 ; Segment type: Pure data
.xdata$x:00013B84 ; Segment permissions: Read
.xdata$x:00013B84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013B84                 assume cs:_xdata$x
.xdata$x:00013B84                 ;org 13B84h
.xdata$x:00013B84 ; COMDAT (pick associative to section at 9A34)
.xdata$x:00013B84 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z db 0FFh
.xdata$x:00013B84                                         ; DATA XREF: .xdata$x:00013B94o
.xdata$x:00013B85                 db 0FFh
.xdata$x:00013B86                 db 0FFh
.xdata$x:00013B87                 db 0FFh
.xdata$x:00013B88                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0
.xdata$x:00013B8C __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00013B8C                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z+11o
.xdata$x:00013B8D                 db    5
.xdata$x:00013B8E                 db  93h ; ô
.xdata$x:00013B8F                 db  19h
.xdata$x:00013B90                 db    1
.xdata$x:00013B91                 db    0
.xdata$x:00013B92                 db    0
.xdata$x:00013B93                 db    0
.xdata$x:00013B94                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.xdata$x:00013B98                 db    0
.xdata$x:00013B99                 db    0
.xdata$x:00013B9A                 db    0
.xdata$x:00013B9B                 db    0
.xdata$x:00013B9C                 db    0
.xdata$x:00013B9D                 db    0
.xdata$x:00013B9E                 db    0
.xdata$x:00013B9F                 db    0
.xdata$x:00013BA0                 db    0
.xdata$x:00013BA1                 db    0
.xdata$x:00013BA2                 db    0
.xdata$x:00013BA3                 db    0
.xdata$x:00013BA4                 db    0
.xdata$x:00013BA5                 db    0
.xdata$x:00013BA6                 db    0
.xdata$x:00013BA7                 db    0
.xdata$x:00013BA8                 db    0
.xdata$x:00013BA9                 db    0
.xdata$x:00013BAA                 db    0
.xdata$x:00013BAB                 db    0
.xdata$x:00013BAC                 db    0
.xdata$x:00013BAD                 db    0
.xdata$x:00013BAE                 db    0
.xdata$x:00013BAF                 db    0
.xdata$x:00013BAF _xdata$x        ends
.xdata$x:00013BAF
.xdata$x:00013BB0 ; ===========================================================================
.xdata$x:00013BB0
.xdata$x:00013BB0 ; Segment type: Pure data
.xdata$x:00013BB0 ; Segment permissions: Read
.xdata$x:00013BB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013BB0                 assume cs:_xdata$x
.xdata$x:00013BB0                 ;org 13BB0h
.xdata$x:00013BB0 ; COMDAT (pick associative to section at B754)
.xdata$x:00013BB0 __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00013BB0                                         ; DATA XREF: .xdata$x:00013BC0o
.xdata$x:00013BB1                 db 0FFh
.xdata$x:00013BB2                 db 0FFh
.xdata$x:00013BB3                 db 0FFh
.xdata$x:00013BB4                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00013BB8 __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00013BB8                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00013BB9                 db    5
.xdata$x:00013BBA                 db  93h ; ô
.xdata$x:00013BBB                 db  19h
.xdata$x:00013BBC                 db    1
.xdata$x:00013BBD                 db    0
.xdata$x:00013BBE                 db    0
.xdata$x:00013BBF                 db    0
.xdata$x:00013BC0                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.xdata$x:00013BC4                 db    0
.xdata$x:00013BC5                 db    0
.xdata$x:00013BC6                 db    0
.xdata$x:00013BC7                 db    0
.xdata$x:00013BC8                 db    0
.xdata$x:00013BC9                 db    0
.xdata$x:00013BCA                 db    0
.xdata$x:00013BCB                 db    0
.xdata$x:00013BCC                 db    0
.xdata$x:00013BCD                 db    0
.xdata$x:00013BCE                 db    0
.xdata$x:00013BCF                 db    0
.xdata$x:00013BD0                 db    0
.xdata$x:00013BD1                 db    0
.xdata$x:00013BD2                 db    0
.xdata$x:00013BD3                 db    0
.xdata$x:00013BD4                 db    0
.xdata$x:00013BD5                 db    0
.xdata$x:00013BD6                 db    0
.xdata$x:00013BD7                 db    0
.xdata$x:00013BD8                 db    0
.xdata$x:00013BD9                 db    0
.xdata$x:00013BDA                 db    0
.xdata$x:00013BDB                 db    0
.xdata$x:00013BDB _xdata$x        ends
.xdata$x:00013BDB
.xdata$x:00013BDC ; ===========================================================================
.xdata$x:00013BDC
.xdata$x:00013BDC ; Segment type: Pure data
.xdata$x:00013BDC ; Segment permissions: Read
.xdata$x:00013BDC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013BDC                 assume cs:_xdata$x
.xdata$x:00013BDC                 ;org 13BDCh
.xdata$x:00013BDC ; COMDAT (pick associative to section at 92D8)
.xdata$x:00013BDC __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00013BDC                                         ; DATA XREF: .xdata$x:00013BECo
.xdata$x:00013BDD                 db 0FFh
.xdata$x:00013BDE                 db 0FFh
.xdata$x:00013BDF                 db 0FFh
.xdata$x:00013BE0                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00013BE4 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00013BE4                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00013BE5                 db    5
.xdata$x:00013BE6                 db  93h ; ô
.xdata$x:00013BE7                 db  19h
.xdata$x:00013BE8                 db    1
.xdata$x:00013BE9                 db    0
.xdata$x:00013BEA                 db    0
.xdata$x:00013BEB                 db    0
.xdata$x:00013BEC                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00013BF0                 db    0
.xdata$x:00013BF1                 db    0
.xdata$x:00013BF2                 db    0
.xdata$x:00013BF3                 db    0
.xdata$x:00013BF4                 db    0
.xdata$x:00013BF5                 db    0
.xdata$x:00013BF6                 db    0
.xdata$x:00013BF7                 db    0
.xdata$x:00013BF8                 db    0
.xdata$x:00013BF9                 db    0
.xdata$x:00013BFA                 db    0
.xdata$x:00013BFB                 db    0
.xdata$x:00013BFC                 db    0
.xdata$x:00013BFD                 db    0
.xdata$x:00013BFE                 db    0
.xdata$x:00013BFF                 db    0
.xdata$x:00013C00                 db    0
.xdata$x:00013C01                 db    0
.xdata$x:00013C02                 db    0
.xdata$x:00013C03                 db    0
.xdata$x:00013C04                 db    0
.xdata$x:00013C05                 db    0
.xdata$x:00013C06                 db    0
.xdata$x:00013C07                 db    0
.xdata$x:00013C07 _xdata$x        ends
.xdata$x:00013C07
.xdata$x:00013C08 ; ===========================================================================
.xdata$x:00013C08
.xdata$x:00013C08 ; Segment type: Pure data
.xdata$x:00013C08 ; Segment permissions: Read
.xdata$x:00013C08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013C08                 assume cs:_xdata$x
.xdata$x:00013C08                 ;org 13C08h
.xdata$x:00013C08 ; COMDAT (pick associative to section at B1E4)
.xdata$x:00013C08 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00013C08                                         ; DATA XREF: .xdata$x:00013C18o
.xdata$x:00013C09                 db 0FFh
.xdata$x:00013C0A                 db 0FFh
.xdata$x:00013C0B                 db 0FFh
.xdata$x:00013C0C                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00013C10 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00013C10                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00013C11                 db    5
.xdata$x:00013C12                 db  93h ; ô
.xdata$x:00013C13                 db  19h
.xdata$x:00013C14                 db    1
.xdata$x:00013C15                 db    0
.xdata$x:00013C16                 db    0
.xdata$x:00013C17                 db    0
.xdata$x:00013C18                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00013C1C                 db    0
.xdata$x:00013C1D                 db    0
.xdata$x:00013C1E                 db    0
.xdata$x:00013C1F                 db    0
.xdata$x:00013C20                 db    0
.xdata$x:00013C21                 db    0
.xdata$x:00013C22                 db    0
.xdata$x:00013C23                 db    0
.xdata$x:00013C24                 db    0
.xdata$x:00013C25                 db    0
.xdata$x:00013C26                 db    0
.xdata$x:00013C27                 db    0
.xdata$x:00013C28                 db    0
.xdata$x:00013C29                 db    0
.xdata$x:00013C2A                 db    0
.xdata$x:00013C2B                 db    0
.xdata$x:00013C2C                 db    0
.xdata$x:00013C2D                 db    0
.xdata$x:00013C2E                 db    0
.xdata$x:00013C2F                 db    0
.xdata$x:00013C30                 db    0
.xdata$x:00013C31                 db    0
.xdata$x:00013C32                 db    0
.xdata$x:00013C33                 db    0
.xdata$x:00013C33 _xdata$x        ends
.xdata$x:00013C33
.xdata$x:00013C34 ; ===========================================================================
.xdata$x:00013C34
.xdata$x:00013C34 ; Segment type: Pure data
.xdata$x:00013C34 ; Segment permissions: Read
.xdata$x:00013C34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013C34                 assume cs:_xdata$x
.xdata$x:00013C34                 ;org 13C34h
.xdata$x:00013C34 ; COMDAT (pick associative to section at 9260)
.xdata$x:00013C34 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:00013C34                                         ; DATA XREF: .xdata$x:00013C44o
.xdata$x:00013C35                 db 0FFh
.xdata$x:00013C36                 db 0FFh
.xdata$x:00013C37                 db 0FFh
.xdata$x:00013C38                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:00013C3C __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:00013C3C                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:00013C3D                 db    5
.xdata$x:00013C3E                 db  93h ; ô
.xdata$x:00013C3F                 db  19h
.xdata$x:00013C40                 db    1
.xdata$x:00013C41                 db    0
.xdata$x:00013C42                 db    0
.xdata$x:00013C43                 db    0
.xdata$x:00013C44                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UsessionFileInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:00013C48                 align 20h
.xdata$x:00013C48 _xdata$x        ends
.xdata$x:00013C48
.xdata$x:00013C60 ; ===========================================================================
.xdata$x:00013C60
.xdata$x:00013C60 ; Segment type: Pure data
.xdata$x:00013C60 ; Segment permissions: Read
.xdata$x:00013C60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013C60                 assume cs:_xdata$x
.xdata$x:00013C60                 ;org 13C60h
.xdata$x:00013C60 ; COMDAT (pick associative to section at 9C54)
.xdata$x:00013C60 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:00013C60                                         ; DATA XREF: .xdata$x:00013C70o
.xdata$x:00013C61                 db 0FFh
.xdata$x:00013C62                 db 0FFh
.xdata$x:00013C63                 db 0FFh
.xdata$x:00013C64                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z$0
.xdata$x:00013C68 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00013C68                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z+11o
.xdata$x:00013C69                 db    5
.xdata$x:00013C6A                 db  93h ; ô
.xdata$x:00013C6B                 db  19h
.xdata$x:00013C6C                 db    1
.xdata$x:00013C6D                 db    0
.xdata$x:00013C6E                 db    0
.xdata$x:00013C6F                 db    0
.xdata$x:00013C70                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z
.xdata$x:00013C74                 db    0
.xdata$x:00013C75                 db    0
.xdata$x:00013C76                 db    0
.xdata$x:00013C77                 db    0
.xdata$x:00013C78                 db    0
.xdata$x:00013C79                 db    0
.xdata$x:00013C7A                 db    0
.xdata$x:00013C7B                 db    0
.xdata$x:00013C7C                 db    0
.xdata$x:00013C7D                 db    0
.xdata$x:00013C7E                 db    0
.xdata$x:00013C7F                 db    0
.xdata$x:00013C80                 db    0
.xdata$x:00013C81                 db    0
.xdata$x:00013C82                 db    0
.xdata$x:00013C83                 db    0
.xdata$x:00013C84                 db    0
.xdata$x:00013C85                 db    0
.xdata$x:00013C86                 db    0
.xdata$x:00013C87                 db    0
.xdata$x:00013C88                 db    0
.xdata$x:00013C89                 db    0
.xdata$x:00013C8A                 db    0
.xdata$x:00013C8B                 db    0
.xdata$x:00013C8B _xdata$x        ends
.xdata$x:00013C8B
.xdata$x:00013C8C ; ===========================================================================
.xdata$x:00013C8C
.xdata$x:00013C8C ; Segment type: Pure data
.xdata$x:00013C8C ; Segment permissions: Read
.xdata$x:00013C8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013C8C                 assume cs:_xdata$x
.xdata$x:00013C8C                 ;org 13C8Ch
.xdata$x:00013C8C ; COMDAT (pick associative to section at B834)
.xdata$x:00013C8C __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00013C8C                                         ; DATA XREF: .xdata$x:00013C9Co
.xdata$x:00013C8D                 db 0FFh
.xdata$x:00013C8E                 db 0FFh
.xdata$x:00013C8F                 db 0FFh
.xdata$x:00013C90                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00013C94 __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00013C94                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00013C95                 db    5
.xdata$x:00013C96                 db  93h ; ô
.xdata$x:00013C97                 db  19h
.xdata$x:00013C98                 db    1
.xdata$x:00013C99                 db    0
.xdata$x:00013C9A                 db    0
.xdata$x:00013C9B                 db    0
.xdata$x:00013C9C                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00013CA0                 db    0
.xdata$x:00013CA1                 db    0
.xdata$x:00013CA2                 db    0
.xdata$x:00013CA3                 db    0
.xdata$x:00013CA4                 db    0
.xdata$x:00013CA5                 db    0
.xdata$x:00013CA6                 db    0
.xdata$x:00013CA7                 db    0
.xdata$x:00013CA8                 db    0
.xdata$x:00013CA9                 db    0
.xdata$x:00013CAA                 db    0
.xdata$x:00013CAB                 db    0
.xdata$x:00013CAC                 db    0
.xdata$x:00013CAD                 db    0
.xdata$x:00013CAE                 db    0
.xdata$x:00013CAF                 db    0
.xdata$x:00013CB0                 db    0
.xdata$x:00013CB1                 db    0
.xdata$x:00013CB2                 db    0
.xdata$x:00013CB3                 db    0
.xdata$x:00013CB4                 db    0
.xdata$x:00013CB5                 db    0
.xdata$x:00013CB6                 db    0
.xdata$x:00013CB7                 db    0
.xdata$x:00013CB7 _xdata$x        ends
.xdata$x:00013CB7
.xdata$x:00013CB8 ; ===========================================================================
.xdata$x:00013CB8
.xdata$x:00013CB8 ; Segment type: Pure data
.xdata$x:00013CB8 ; Segment permissions: Read
.xdata$x:00013CB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013CB8                 assume cs:_xdata$x
.xdata$x:00013CB8                 ;org 13CB8h
.xdata$x:00013CB8 ; COMDAT (pick associative to section at 9BD0)
.xdata$x:00013CB8 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00013CB8                                         ; DATA XREF: .xdata$x:00013CC8o
.xdata$x:00013CB9                 db 0FFh
.xdata$x:00013CBA                 db 0FFh
.xdata$x:00013CBB                 db 0FFh
.xdata$x:00013CBC                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00013CC0 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00013CC0                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00013CC1                 db    5
.xdata$x:00013CC2                 db  93h ; ô
.xdata$x:00013CC3                 db  19h
.xdata$x:00013CC4                 db    1
.xdata$x:00013CC5                 db    0
.xdata$x:00013CC6                 db    0
.xdata$x:00013CC7                 db    0
.xdata$x:00013CC8                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00013CCC                 db    0
.xdata$x:00013CCD                 db    0
.xdata$x:00013CCE                 db    0
.xdata$x:00013CCF                 db    0
.xdata$x:00013CD0                 db    0
.xdata$x:00013CD1                 db    0
.xdata$x:00013CD2                 db    0
.xdata$x:00013CD3                 db    0
.xdata$x:00013CD4                 db    0
.xdata$x:00013CD5                 db    0
.xdata$x:00013CD6                 db    0
.xdata$x:00013CD7                 db    0
.xdata$x:00013CD8                 db    0
.xdata$x:00013CD9                 db    0
.xdata$x:00013CDA                 db    0
.xdata$x:00013CDB                 db    0
.xdata$x:00013CDC                 db    0
.xdata$x:00013CDD                 db    0
.xdata$x:00013CDE                 db    0
.xdata$x:00013CDF                 db    0
.xdata$x:00013CE0                 db    0
.xdata$x:00013CE1                 db    0
.xdata$x:00013CE2                 db    0
.xdata$x:00013CE3                 db    0
.xdata$x:00013CE3 _xdata$x        ends
.xdata$x:00013CE3
.xdata$x:00013CE4 ; ===========================================================================
.xdata$x:00013CE4
.xdata$x:00013CE4 ; Segment type: Pure data
.xdata$x:00013CE4 ; Segment permissions: Read
.xdata$x:00013CE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013CE4                 assume cs:_xdata$x
.xdata$x:00013CE4                 ;org 13CE4h
.xdata$x:00013CE4 ; COMDAT (pick associative to section at 9D58)
.xdata$x:00013CE4 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:00013CE4                                         ; DATA XREF: .xdata$x:00013CF4o
.xdata$x:00013CE5                 db 0FFh
.xdata$x:00013CE6                 db 0FFh
.xdata$x:00013CE7                 db 0FFh
.xdata$x:00013CE8                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z$0
.xdata$x:00013CEC __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00013CEC                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z+11o
.xdata$x:00013CED                 db    5
.xdata$x:00013CEE                 db  93h ; ô
.xdata$x:00013CEF                 db  19h
.xdata$x:00013CF0                 db    1
.xdata$x:00013CF1                 db    0
.xdata$x:00013CF2                 db    0
.xdata$x:00013CF3                 db    0
.xdata$x:00013CF4                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@PAUsessionFileInfo@@PBU_Container_base12@1@@Z
.xdata$x:00013CF8                 db    0
.xdata$x:00013CF9                 db    0
.xdata$x:00013CFA                 db    0
.xdata$x:00013CFB                 db    0
.xdata$x:00013CFC                 db    0
.xdata$x:00013CFD                 db    0
.xdata$x:00013CFE                 db    0
.xdata$x:00013CFF                 db    0
.xdata$x:00013D00                 db    0
.xdata$x:00013D01                 db    0
.xdata$x:00013D02                 db    0
.xdata$x:00013D03                 db    0
.xdata$x:00013D04                 db    0
.xdata$x:00013D05                 db    0
.xdata$x:00013D06                 db    0
.xdata$x:00013D07                 db    0
.xdata$x:00013D08                 db    0
.xdata$x:00013D09                 db    0
.xdata$x:00013D0A                 db    0
.xdata$x:00013D0B                 db    0
.xdata$x:00013D0C                 db    0
.xdata$x:00013D0D                 db    0
.xdata$x:00013D0E                 db    0
.xdata$x:00013D0F                 db    0
.xdata$x:00013D0F _xdata$x        ends
.xdata$x:00013D0F
.xdata$x:00013D10 ; ===========================================================================
.xdata$x:00013D10
.xdata$x:00013D10 ; Segment type: Pure data
.xdata$x:00013D10 ; Segment permissions: Read
.xdata$x:00013D10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013D10                 assume cs:_xdata$x
.xdata$x:00013D10                 ;org 13D10h
.xdata$x:00013D10 ; COMDAT (pick associative to section at CD10)
.xdata$x:00013D10 __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:00013D10                                         ; DATA XREF: .xdata$x:00013D28o
.xdata$x:00013D11                 db 0FFh
.xdata$x:00013D12                 db 0FFh
.xdata$x:00013D13                 db 0FFh
.xdata$x:00013D14                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:00013D18                 db    0
.xdata$x:00013D19                 db    0
.xdata$x:00013D1A                 db    0
.xdata$x:00013D1B                 db    0
.xdata$x:00013D1C                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:00013D20 __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:00013D20                                         ; DATA XREF: __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:00013D21                 db    5
.xdata$x:00013D22                 db  93h ; ô
.xdata$x:00013D23                 db  19h
.xdata$x:00013D24                 db    2
.xdata$x:00013D25                 db    0
.xdata$x:00013D26                 db    0
.xdata$x:00013D27                 db    0
.xdata$x:00013D28                 dd offset __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:00013D2C                 db    0
.xdata$x:00013D2D                 db    0
.xdata$x:00013D2E                 db    0
.xdata$x:00013D2F                 db    0
.xdata$x:00013D30                 db    0
.xdata$x:00013D31                 db    0
.xdata$x:00013D32                 db    0
.xdata$x:00013D33                 db    0
.xdata$x:00013D34                 db    0
.xdata$x:00013D35                 db    0
.xdata$x:00013D36                 db    0
.xdata$x:00013D37                 db    0
.xdata$x:00013D38                 db    0
.xdata$x:00013D39                 db    0
.xdata$x:00013D3A                 db    0
.xdata$x:00013D3B                 db    0
.xdata$x:00013D3C                 db    0
.xdata$x:00013D3D                 db    0
.xdata$x:00013D3E                 db    0
.xdata$x:00013D3F                 db    0
.xdata$x:00013D40                 db    0
.xdata$x:00013D41                 db    0
.xdata$x:00013D42                 db    0
.xdata$x:00013D43                 db    0
.xdata$x:00013D43 _xdata$x        ends
.xdata$x:00013D43
.xdata$x:00013D44 ; ===========================================================================
.xdata$x:00013D44
.xdata$x:00013D44 ; Segment type: Pure data
.xdata$x:00013D44 ; Segment permissions: Read
.xdata$x:00013D44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013D44                 assume cs:_xdata$x
.xdata$x:00013D44                 ;org 13D44h
.xdata$x:00013D44 ; COMDAT (pick associative to section at B8A4)
.xdata$x:00013D44 __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00013D44                                         ; DATA XREF: .xdata$x:00013D54o
.xdata$x:00013D45                 db 0FFh
.xdata$x:00013D46                 db 0FFh
.xdata$x:00013D47                 db 0FFh
.xdata$x:00013D48                 dd offset __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00013D4C __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00013D4C                                         ; DATA XREF: __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00013D4D                 db    5
.xdata$x:00013D4E                 db  93h ; ô
.xdata$x:00013D4F                 db  19h
.xdata$x:00013D50                 db    1
.xdata$x:00013D51                 db    0
.xdata$x:00013D52                 db    0
.xdata$x:00013D53                 db    0
.xdata$x:00013D54                 dd offset __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00013D58                 db    0
.xdata$x:00013D59                 db    0
.xdata$x:00013D5A                 db    0
.xdata$x:00013D5B                 db    0
.xdata$x:00013D5C                 db    0
.xdata$x:00013D5D                 db    0
.xdata$x:00013D5E                 db    0
.xdata$x:00013D5F                 db    0
.xdata$x:00013D60                 db    0
.xdata$x:00013D61                 db    0
.xdata$x:00013D62                 db    0
.xdata$x:00013D63                 db    0
.xdata$x:00013D64                 db    0
.xdata$x:00013D65                 db    0
.xdata$x:00013D66                 db    0
.xdata$x:00013D67                 db    0
.xdata$x:00013D68                 db    0
.xdata$x:00013D69                 db    0
.xdata$x:00013D6A                 db    0
.xdata$x:00013D6B                 db    0
.xdata$x:00013D6C                 db    0
.xdata$x:00013D6D                 db    0
.xdata$x:00013D6E                 db    0
.xdata$x:00013D6F                 db    0
.xdata$x:00013D6F _xdata$x        ends
.xdata$x:00013D6F
.xdata$x:00013D70 ; ===========================================================================
.xdata$x:00013D70
.xdata$x:00013D70 ; Segment type: Pure data
.xdata$x:00013D70 ; Segment permissions: Read
.xdata$x:00013D70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013D70                 assume cs:_xdata$x
.xdata$x:00013D70                 ;org 13D70h
.xdata$x:00013D70 ; COMDAT (pick associative to section at 9CE0)
.xdata$x:00013D70 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00013D70                                         ; DATA XREF: .xdata$x:00013D80o
.xdata$x:00013D71                 db 0FFh
.xdata$x:00013D72                 db 0FFh
.xdata$x:00013D73                 db 0FFh
.xdata$x:00013D74                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00013D78 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00013D78                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00013D79                 db    5
.xdata$x:00013D7A                 db  93h ; ô
.xdata$x:00013D7B                 db  19h
.xdata$x:00013D7C                 db    1
.xdata$x:00013D7D                 db    0
.xdata$x:00013D7E                 db    0
.xdata$x:00013D7F                 db    0
.xdata$x:00013D80                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00013D84                 db    0
.xdata$x:00013D85                 db    0
.xdata$x:00013D86                 db    0
.xdata$x:00013D87                 db    0
.xdata$x:00013D88                 db    0
.xdata$x:00013D89                 db    0
.xdata$x:00013D8A                 db    0
.xdata$x:00013D8B                 db    0
.xdata$x:00013D8C                 db    0
.xdata$x:00013D8D                 db    0
.xdata$x:00013D8E                 db    0
.xdata$x:00013D8F                 db    0
.xdata$x:00013D90                 db    0
.xdata$x:00013D91                 db    0
.xdata$x:00013D92                 db    0
.xdata$x:00013D93                 db    0
.xdata$x:00013D94                 db    0
.xdata$x:00013D95                 db    0
.xdata$x:00013D96                 db    0
.xdata$x:00013D97                 db    0
.xdata$x:00013D98                 db    0
.xdata$x:00013D99                 db    0
.xdata$x:00013D9A                 db    0
.xdata$x:00013D9B                 db    0
.xdata$x:00013D9B _xdata$x        ends
.xdata$x:00013D9B
.xdata$x:00013D9C ; ===========================================================================
.xdata$x:00013D9C
.xdata$x:00013D9C ; Segment type: Pure data
.xdata$x:00013D9C ; Segment permissions: Read
.xdata$x:00013D9C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013D9C                 assume cs:_xdata$x
.xdata$x:00013D9C                 ;org 13D9Ch
.xdata$x:00013D9C ; COMDAT (pick associative to section at 96B8)
.xdata$x:00013D9C __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z db 0FFh
.xdata$x:00013D9C                                         ; DATA XREF: .xdata$x:00013DACo
.xdata$x:00013D9D                 db 0FFh
.xdata$x:00013D9E                 db 0FFh
.xdata$x:00013D9F                 db 0FFh
.xdata$x:00013DA0                 dd offset __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0
.xdata$x:00013DA4 __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00013DA4                                         ; DATA XREF: __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z+11o
.xdata$x:00013DA5                 db    5
.xdata$x:00013DA6                 db  93h ; ô
.xdata$x:00013DA7                 db  19h
.xdata$x:00013DA8                 db    1
.xdata$x:00013DA9                 db    0
.xdata$x:00013DAA                 db    0
.xdata$x:00013DAB                 db    0
.xdata$x:00013DAC                 dd offset __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.xdata$x:00013DB0                 db    0
.xdata$x:00013DB1                 db    0
.xdata$x:00013DB2                 db    0
.xdata$x:00013DB3                 db    0
.xdata$x:00013DB4                 db    0
.xdata$x:00013DB5                 db    0
.xdata$x:00013DB6                 db    0
.xdata$x:00013DB7                 db    0
.xdata$x:00013DB8                 db    0
.xdata$x:00013DB9                 db    0
.xdata$x:00013DBA                 db    0
.xdata$x:00013DBB                 db    0
.xdata$x:00013DBC                 db    0
.xdata$x:00013DBD                 db    0
.xdata$x:00013DBE                 db    0
.xdata$x:00013DBF                 db    0
.xdata$x:00013DC0                 db    0
.xdata$x:00013DC1                 db    0
.xdata$x:00013DC2                 db    0
.xdata$x:00013DC3                 db    0
.xdata$x:00013DC4                 db    0
.xdata$x:00013DC5                 db    0
.xdata$x:00013DC6                 db    0
.xdata$x:00013DC7                 db    0
.xdata$x:00013DC7 _xdata$x        ends
.xdata$x:00013DC7
.xdata$x:00013DC8 ; ===========================================================================
.xdata$x:00013DC8
.xdata$x:00013DC8 ; Segment type: Pure data
.xdata$x:00013DC8 ; Segment permissions: Read
.xdata$x:00013DC8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013DC8                 assume cs:_xdata$x
.xdata$x:00013DC8                 ;org 13DC8h
.xdata$x:00013DC8 ; COMDAT (pick associative to section at CC74)
.xdata$x:00013DC8 __unwindtable$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z db 0FFh
.xdata$x:00013DC8                                         ; DATA XREF: .xdata$x:00013DD8o
.xdata$x:00013DC9                 db 0FFh
.xdata$x:00013DCA                 db 0FFh
.xdata$x:00013DCB                 db 0FFh
.xdata$x:00013DCC                 dd offset __unwindfunclet$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$0
.xdata$x:00013DD0 __ehfuncinfo$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z db  22h ; "
.xdata$x:00013DD0                                         ; DATA XREF: __ehhandler$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z+11o
.xdata$x:00013DD1                 db    5
.xdata$x:00013DD2                 db  93h ; ô
.xdata$x:00013DD3                 db  19h
.xdata$x:00013DD4                 db    1
.xdata$x:00013DD5                 db    0
.xdata$x:00013DD6                 db    0
.xdata$x:00013DD7                 db    0
.xdata$x:00013DD8                 dd offset __unwindtable$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.xdata$x:00013DDC                 db    0
.xdata$x:00013DDD                 db    0
.xdata$x:00013DDE                 db    0
.xdata$x:00013DDF                 db    0
.xdata$x:00013DE0                 db    0
.xdata$x:00013DE1                 db    0
.xdata$x:00013DE2                 db    0
.xdata$x:00013DE3                 db    0
.xdata$x:00013DE4                 db    0
.xdata$x:00013DE5                 db    0
.xdata$x:00013DE6                 db    0
.xdata$x:00013DE7                 db    0
.xdata$x:00013DE8                 db    0
.xdata$x:00013DE9                 db    0
.xdata$x:00013DEA                 db    0
.xdata$x:00013DEB                 db    0
.xdata$x:00013DEC                 db    0
.xdata$x:00013DED                 db    0
.xdata$x:00013DEE                 db    0
.xdata$x:00013DEF                 db    0
.xdata$x:00013DF0                 db    0
.xdata$x:00013DF1                 db    0
.xdata$x:00013DF2                 db    0
.xdata$x:00013DF3                 db    0
.xdata$x:00013DF3 _xdata$x        ends
.xdata$x:00013DF3
.xdata$x:00013DF4 ; ===========================================================================
.xdata$x:00013DF4
.xdata$x:00013DF4 ; Segment type: Pure data
.xdata$x:00013DF4 ; Segment permissions: Read
.xdata$x:00013DF4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013DF4                 assume cs:_xdata$x
.xdata$x:00013DF4                 ;org 13DF4h
.xdata$x:00013DF4 ; COMDAT (pick associative to section at B424)
.xdata$x:00013DF4 __unwindtable$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00013DF4                                         ; DATA XREF: .xdata$x:00013E04o
.xdata$x:00013DF5                 db 0FFh
.xdata$x:00013DF6                 db 0FFh
.xdata$x:00013DF7                 db 0FFh
.xdata$x:00013DF8                 dd offset __unwindfunclet$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00013DFC __ehfuncinfo$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00013DFC                                         ; DATA XREF: __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00013DFD                 db    5
.xdata$x:00013DFE                 db  93h ; ô
.xdata$x:00013DFF                 db  19h
.xdata$x:00013E00                 db    1
.xdata$x:00013E01                 db    0
.xdata$x:00013E02                 db    0
.xdata$x:00013E03                 db    0
.xdata$x:00013E04                 dd offset __unwindtable$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:00013E08                 align 20h
.xdata$x:00013E08 _xdata$x        ends
.xdata$x:00013E08
.xdata$x:00013E20 ; ===========================================================================
.xdata$x:00013E20
.xdata$x:00013E20 ; Segment type: Pure data
.xdata$x:00013E20 ; Segment permissions: Read
.xdata$x:00013E20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013E20                 assume cs:_xdata$x
.xdata$x:00013E20                 ;org 13E20h
.xdata$x:00013E20 ; COMDAT (pick associative to section at 9640)
.xdata$x:00013E20 __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00013E20                                         ; DATA XREF: .xdata$x:00013E30o
.xdata$x:00013E21                 db 0FFh
.xdata$x:00013E22                 db 0FFh
.xdata$x:00013E23                 db 0FFh
.xdata$x:00013E24                 dd offset __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00013E28 __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00013E28                                         ; DATA XREF: __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00013E29                 db    5
.xdata$x:00013E2A                 db  93h ; ô
.xdata$x:00013E2B                 db  19h
.xdata$x:00013E2C                 db    1
.xdata$x:00013E2D                 db    0
.xdata$x:00013E2E                 db    0
.xdata$x:00013E2F                 db    0
.xdata$x:00013E30                 dd offset __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00013E34                 db    0
.xdata$x:00013E35                 db    0
.xdata$x:00013E36                 db    0
.xdata$x:00013E37                 db    0
.xdata$x:00013E38                 db    0
.xdata$x:00013E39                 db    0
.xdata$x:00013E3A                 db    0
.xdata$x:00013E3B                 db    0
.xdata$x:00013E3C                 db    0
.xdata$x:00013E3D                 db    0
.xdata$x:00013E3E                 db    0
.xdata$x:00013E3F                 db    0
.xdata$x:00013E40                 db    0
.xdata$x:00013E41                 db    0
.xdata$x:00013E42                 db    0
.xdata$x:00013E43                 db    0
.xdata$x:00013E44                 db    0
.xdata$x:00013E45                 db    0
.xdata$x:00013E46                 db    0
.xdata$x:00013E47                 db    0
.xdata$x:00013E48                 db    0
.xdata$x:00013E49                 db    0
.xdata$x:00013E4A                 db    0
.xdata$x:00013E4B                 db    0
.xdata$x:00013E4B _xdata$x        ends
.xdata$x:00013E4B
.xdata$x:00013E4C ; ===========================================================================
.xdata$x:00013E4C
.xdata$x:00013E4C ; Segment type: Pure data
.xdata$x:00013E4C ; Segment permissions: Read
.xdata$x:00013E4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013E4C                 assume cs:_xdata$x
.xdata$x:00013E4C                 ;org 13E4Ch
.xdata$x:00013E4C ; COMDAT (pick associative to section at 8724)
.xdata$x:00013E4C __ehfuncinfo$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z db  22h ; "
.xdata$x:00013E4C                                         ; DATA XREF: __ehhandler$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z+11o
.xdata$x:00013E4D                 db    5
.xdata$x:00013E4E                 db  93h ; ô
.xdata$x:00013E4F                 db  19h
.xdata$x:00013E50                 db  0Ah
.xdata$x:00013E51                 db    0
.xdata$x:00013E52                 db    0
.xdata$x:00013E53                 db    0
.xdata$x:00013E54                 dd offset __unwindtable$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.xdata$x:00013E58                 db    0
.xdata$x:00013E59                 db    0
.xdata$x:00013E5A                 db    0
.xdata$x:00013E5B                 db    0
.xdata$x:00013E5C                 db    0
.xdata$x:00013E5D                 db    0
.xdata$x:00013E5E                 db    0
.xdata$x:00013E5F                 db    0
.xdata$x:00013E60                 db    0
.xdata$x:00013E61                 db    0
.xdata$x:00013E62                 db    0
.xdata$x:00013E63                 db    0
.xdata$x:00013E64                 db    0
.xdata$x:00013E65                 db    0
.xdata$x:00013E66                 db    0
.xdata$x:00013E67                 db    0
.xdata$x:00013E68                 db    0
.xdata$x:00013E69                 db    0
.xdata$x:00013E6A                 db    0
.xdata$x:00013E6B                 db    0
.xdata$x:00013E6C                 db    0
.xdata$x:00013E6D                 db    0
.xdata$x:00013E6E                 db    0
.xdata$x:00013E6F                 db    0
.xdata$x:00013E70 __unwindtable$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z db 0FFh
.xdata$x:00013E70                                         ; DATA XREF: .xdata$x:00013E54o
.xdata$x:00013E71                 db 0FFh
.xdata$x:00013E72                 db 0FFh
.xdata$x:00013E73                 db 0FFh
.xdata$x:00013E74                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0
.xdata$x:00013E78                 db    0
.xdata$x:00013E79                 db    0
.xdata$x:00013E7A                 db    0
.xdata$x:00013E7B                 db    0
.xdata$x:00013E7C                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1
.xdata$x:00013E80                 db    1
.xdata$x:00013E81                 db    0
.xdata$x:00013E82                 db    0
.xdata$x:00013E83                 db    0
.xdata$x:00013E84                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2
.xdata$x:00013E88                 db    2
.xdata$x:00013E89                 db    0
.xdata$x:00013E8A                 db    0
.xdata$x:00013E8B                 db    0
.xdata$x:00013E8C                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3
.xdata$x:00013E90                 db    3
.xdata$x:00013E91                 db    0
.xdata$x:00013E92                 db    0
.xdata$x:00013E93                 db    0
.xdata$x:00013E94                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4
.xdata$x:00013E98                 db    4
.xdata$x:00013E99                 db    0
.xdata$x:00013E9A                 db    0
.xdata$x:00013E9B                 db    0
.xdata$x:00013E9C                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$5
.xdata$x:00013EA0                 db    5
.xdata$x:00013EA1                 db    0
.xdata$x:00013EA2                 db    0
.xdata$x:00013EA3                 db    0
.xdata$x:00013EA4                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$6
.xdata$x:00013EA8                 db    6
.xdata$x:00013EA9                 db    0
.xdata$x:00013EAA                 db    0
.xdata$x:00013EAB                 db    0
.xdata$x:00013EAC                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$7
.xdata$x:00013EB0                 db    1
.xdata$x:00013EB1                 db    0
.xdata$x:00013EB2                 db    0
.xdata$x:00013EB3                 db    0
.xdata$x:00013EB4                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4
.xdata$x:00013EB8                 db    8
.xdata$x:00013EB9                 db    0
.xdata$x:00013EBA                 db    0
.xdata$x:00013EBB                 db    0
.xdata$x:00013EBC                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$6
.xdata$x:00013EBC _xdata$x        ends
.xdata$x:00013EBC
.xdata$x:00013EC0 ; ===========================================================================
.xdata$x:00013EC0
.xdata$x:00013EC0 ; Segment type: Pure data
.xdata$x:00013EC0 ; Segment permissions: Read
.xdata$x:00013EC0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013EC0                 assume cs:_xdata$x
.xdata$x:00013EC0                 ;org 13EC0h
.xdata$x:00013EC0 ; COMDAT (pick associative to section at 7AEC)
.xdata$x:00013EC0 __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z db 0FFh
.xdata$x:00013EC0                                         ; DATA XREF: .xdata$x:00013EE8o
.xdata$x:00013EC1                 db 0FFh
.xdata$x:00013EC2                 db 0FFh
.xdata$x:00013EC3                 db 0FFh
.xdata$x:00013EC4                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z$0
.xdata$x:00013EC8                 db    0
.xdata$x:00013EC9                 db    0
.xdata$x:00013ECA                 db    0
.xdata$x:00013ECB                 db    0
.xdata$x:00013ECC                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z$1
.xdata$x:00013ED0                 db    1
.xdata$x:00013ED1                 db    0
.xdata$x:00013ED2                 db    0
.xdata$x:00013ED3                 db    0
.xdata$x:00013ED4                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z$2
.xdata$x:00013ED8                 db    2
.xdata$x:00013ED9                 db    0
.xdata$x:00013EDA                 db    0
.xdata$x:00013EDB                 db    0
.xdata$x:00013EDC                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z$3
.xdata$x:00013EE0 __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z db  22h ; "
.xdata$x:00013EE0                                         ; DATA XREF: __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z+11o
.xdata$x:00013EE1                 db    5
.xdata$x:00013EE2                 db  93h ; ô
.xdata$x:00013EE3                 db  19h
.xdata$x:00013EE4                 db    4
.xdata$x:00013EE5                 db    0
.xdata$x:00013EE6                 db    0
.xdata$x:00013EE7                 db    0
.xdata$x:00013EE8                 dd offset __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@@?$vector@UsessionFileInfo@@V?$allocator@UsessionFileInfo@@@std@@@std@@IAEPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@1@0PAU2@@Z
.xdata$x:00013EEC                 db    0
.xdata$x:00013EED                 db    0
.xdata$x:00013EEE                 db    0
.xdata$x:00013EEF                 db    0
.xdata$x:00013EF0                 db    0
.xdata$x:00013EF1                 db    0
.xdata$x:00013EF2                 db    0
.xdata$x:00013EF3                 db    0
.xdata$x:00013EF4                 db    0
.xdata$x:00013EF5                 db    0
.xdata$x:00013EF6                 db    0
.xdata$x:00013EF7                 db    0
.xdata$x:00013EF8                 db    0
.xdata$x:00013EF9                 db    0
.xdata$x:00013EFA                 db    0
.xdata$x:00013EFB                 db    0
.xdata$x:00013EFC                 db    0
.xdata$x:00013EFD                 db    0
.xdata$x:00013EFE                 db    0
.xdata$x:00013EFF                 db    0
.xdata$x:00013F00                 db    0
.xdata$x:00013F01                 db    0
.xdata$x:00013F02                 db    0
.xdata$x:00013F03                 db    0
.xdata$x:00013F03 _xdata$x        ends
.xdata$x:00013F03
.xdata$x:00013F04 ; ===========================================================================
.xdata$x:00013F04
.xdata$x:00013F04 ; Segment type: Pure data
.xdata$x:00013F04 ; Segment permissions: Read
.xdata$x:00013F04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013F04                 assume cs:_xdata$x
.xdata$x:00013F04                 ;org 13F04h
.xdata$x:00013F04 ; COMDAT (pick associative to section at 8C30)
.xdata$x:00013F04 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00013F04                                         ; DATA XREF: .xdata$x:00013F14o
.xdata$x:00013F05                 db 0FFh
.xdata$x:00013F06                 db 0FFh
.xdata$x:00013F07                 db 0FFh
.xdata$x:00013F08                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00013F0C __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00013F0C                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00013F0D                 db    5
.xdata$x:00013F0E                 db  93h ; ô
.xdata$x:00013F0F                 db  19h
.xdata$x:00013F10                 db    1
.xdata$x:00013F11                 db    0
.xdata$x:00013F12                 db    0
.xdata$x:00013F13                 db    0
.xdata$x:00013F14                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00013F18                 db    0
.xdata$x:00013F19                 db    0
.xdata$x:00013F1A                 db    0
.xdata$x:00013F1B                 db    0
.xdata$x:00013F1C                 db    0
.xdata$x:00013F1D                 db    0
.xdata$x:00013F1E                 db    0
.xdata$x:00013F1F                 db    0
.xdata$x:00013F20                 db    0
.xdata$x:00013F21                 db    0
.xdata$x:00013F22                 db    0
.xdata$x:00013F23                 db    0
.xdata$x:00013F24                 db    0
.xdata$x:00013F25                 db    0
.xdata$x:00013F26                 db    0
.xdata$x:00013F27                 db    0
.xdata$x:00013F28                 db    0
.xdata$x:00013F29                 db    0
.xdata$x:00013F2A                 db    0
.xdata$x:00013F2B                 db    0
.xdata$x:00013F2C                 db    0
.xdata$x:00013F2D                 db    0
.xdata$x:00013F2E                 db    0
.xdata$x:00013F2F                 db    0
.xdata$x:00013F2F _xdata$x        ends
.xdata$x:00013F2F
.xdata$x:00013F30 ; ===========================================================================
.xdata$x:00013F30
.xdata$x:00013F30 ; Segment type: Pure data
.xdata$x:00013F30 ; Segment permissions: Read
.xdata$x:00013F30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013F30                 assume cs:_xdata$x
.xdata$x:00013F30                 ;org 13F30h
.xdata$x:00013F30 ; COMDAT (pick associative to section at 84E4)
.xdata$x:00013F30 __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z db 0FFh
.xdata$x:00013F30                                         ; DATA XREF: .xdata$x:00013F58o
.xdata$x:00013F31                 db 0FFh
.xdata$x:00013F32                 db 0FFh
.xdata$x:00013F33                 db 0FFh
.xdata$x:00013F34                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z$0
.xdata$x:00013F38                 db    0
.xdata$x:00013F39                 db    0
.xdata$x:00013F3A                 db    0
.xdata$x:00013F3B                 db    0
.xdata$x:00013F3C                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z$1
.xdata$x:00013F40                 db    1
.xdata$x:00013F41                 db    0
.xdata$x:00013F42                 db    0
.xdata$x:00013F43                 db    0
.xdata$x:00013F44                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z$2
.xdata$x:00013F48                 db    1
.xdata$x:00013F49                 db    0
.xdata$x:00013F4A                 db    0
.xdata$x:00013F4B                 db    0
.xdata$x:00013F4C                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z$3
.xdata$x:00013F50 __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z db  22h ; "
.xdata$x:00013F50                                         ; DATA XREF: __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z+11o
.xdata$x:00013F51                 db    5
.xdata$x:00013F52                 db  93h ; ô
.xdata$x:00013F53                 db  19h
.xdata$x:00013F54                 db    4
.xdata$x:00013F55                 db    0
.xdata$x:00013F56                 db    0
.xdata$x:00013F57                 db    0
.xdata$x:00013F58                 dd offset __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@PAUsessionFileInfo@@U?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@2@@std@@YAPAUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@@Z
.xdata$x:00013F5C                 db    0
.xdata$x:00013F5D                 db    0
.xdata$x:00013F5E                 db    0
.xdata$x:00013F5F                 db    0
.xdata$x:00013F60                 db    0
.xdata$x:00013F61                 db    0
.xdata$x:00013F62                 db    0
.xdata$x:00013F63                 db    0
.xdata$x:00013F64                 db    0
.xdata$x:00013F65                 db    0
.xdata$x:00013F66                 db    0
.xdata$x:00013F67                 db    0
.xdata$x:00013F68                 db    0
.xdata$x:00013F69                 db    0
.xdata$x:00013F6A                 db    0
.xdata$x:00013F6B                 db    0
.xdata$x:00013F6C                 db    0
.xdata$x:00013F6D                 db    0
.xdata$x:00013F6E                 db    0
.xdata$x:00013F6F                 db    0
.xdata$x:00013F70                 db    0
.xdata$x:00013F71                 db    0
.xdata$x:00013F72                 db    0
.xdata$x:00013F73                 db    0
.xdata$x:00013F73 _xdata$x        ends
.xdata$x:00013F73
.xdata$x:00013F74 ; ===========================================================================
.xdata$x:00013F74
.xdata$x:00013F74 ; Segment type: Pure data
.xdata$x:00013F74 ; Segment permissions: Read
.xdata$x:00013F74 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013F74                 assume cs:_xdata$x
.xdata$x:00013F74                 ;org 13F74h
.xdata$x:00013F74 ; COMDAT (pick associative to section at 88E4)
.xdata$x:00013F74 __unwindtable$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z db 0FFh
.xdata$x:00013F74                                         ; DATA XREF: .xdata$x:00013F84o
.xdata$x:00013F75                 db 0FFh
.xdata$x:00013F76                 db 0FFh
.xdata$x:00013F77                 db 0FFh
.xdata$x:00013F78                 dd offset __unwindfunclet$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z$0
.xdata$x:00013F7C __ehfuncinfo$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z db  22h ; "
.xdata$x:00013F7C                                         ; DATA XREF: __ehhandler$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z+11o
.xdata$x:00013F7D                 db    5
.xdata$x:00013F7E                 db  93h ; ô
.xdata$x:00013F7F                 db  19h
.xdata$x:00013F80                 db    1
.xdata$x:00013F81                 db    0
.xdata$x:00013F82                 db    0
.xdata$x:00013F83                 db    0
.xdata$x:00013F84                 dd offset __unwindtable$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z
.xdata$x:00013F88                 align 20h
.xdata$x:00013F88 _xdata$x        ends
.xdata$x:00013F88
.xdata$x:00013FA0 ; ===========================================================================
.xdata$x:00013FA0
.xdata$x:00013FA0 ; Segment type: Pure data
.xdata$x:00013FA0 ; Segment permissions: Read
.xdata$x:00013FA0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013FA0                 assume cs:_xdata$x
.xdata$x:00013FA0                 ;org 13FA0h
.xdata$x:00013FA0 ; COMDAT (pick associative to section at 7D24)
.xdata$x:00013FA0 __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z db 0FFh
.xdata$x:00013FA0                                         ; DATA XREF: .xdata$x:00013FB0o
.xdata$x:00013FA1                 db 0FFh
.xdata$x:00013FA2                 db 0FFh
.xdata$x:00013FA3                 db 0FFh
.xdata$x:00013FA4                 dd offset __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z$0
.xdata$x:00013FA8 __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z db  22h ; "
.xdata$x:00013FA8                                         ; DATA XREF: __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z+11o
.xdata$x:00013FA9                 db    5
.xdata$x:00013FAA                 db  93h ; ô
.xdata$x:00013FAB                 db  19h
.xdata$x:00013FAC                 db    1
.xdata$x:00013FAD                 db    0
.xdata$x:00013FAE                 db    0
.xdata$x:00013FAF                 db    0
.xdata$x:00013FB0                 dd offset __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@std@@YAPBUsessionFileInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UsessionFileInfo@@@std@@@std@@@0@@Z
.xdata$x:00013FB4                 db    0
.xdata$x:00013FB5                 db    0
.xdata$x:00013FB6                 db    0
.xdata$x:00013FB7                 db    0
.xdata$x:00013FB8                 db    0
.xdata$x:00013FB9                 db    0
.xdata$x:00013FBA                 db    0
.xdata$x:00013FBB                 db    0
.xdata$x:00013FBC                 db    0
.xdata$x:00013FBD                 db    0
.xdata$x:00013FBE                 db    0
.xdata$x:00013FBF                 db    0
.xdata$x:00013FC0                 db    0
.xdata$x:00013FC1                 db    0
.xdata$x:00013FC2                 db    0
.xdata$x:00013FC3                 db    0
.xdata$x:00013FC4                 db    0
.xdata$x:00013FC5                 db    0
.xdata$x:00013FC6                 db    0
.xdata$x:00013FC7                 db    0
.xdata$x:00013FC8                 db    0
.xdata$x:00013FC9                 db    0
.xdata$x:00013FCA                 db    0
.xdata$x:00013FCB                 db    0
.xdata$x:00013FCB _xdata$x        ends
.xdata$x:00013FCB
.xdata$x:00013FCC ; ===========================================================================
.xdata$x:00013FCC
.xdata$x:00013FCC ; Segment type: Pure data
.xdata$x:00013FCC ; Segment permissions: Read
.xdata$x:00013FCC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013FCC                 assume cs:_xdata$x
.xdata$x:00013FCC                 ;org 13FCCh
.xdata$x:00013FCC ; COMDAT (pick associative to section at 8D80)
.xdata$x:00013FCC __unwindtable$??$construct@UsessionFileInfo@@U1@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z db 0FFh
.xdata$x:00013FCC                                         ; DATA XREF: .xdata$x:00013FDCo
.xdata$x:00013FCD                 db 0FFh
.xdata$x:00013FCE                 db 0FFh
.xdata$x:00013FCF                 db 0FFh
.xdata$x:00013FD0                 dd offset __unwindfunclet$??$construct@UsessionFileInfo@@U1@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z$0
.xdata$x:00013FD4 __ehfuncinfo$??$construct@UsessionFileInfo@@U1@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z db  22h ; "
.xdata$x:00013FD4                                         ; DATA XREF: __ehhandler$??$construct@UsessionFileInfo@@U1@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z+11o
.xdata$x:00013FD5                 db    5
.xdata$x:00013FD6                 db  93h ; ô
.xdata$x:00013FD7                 db  19h
.xdata$x:00013FD8                 db    1
.xdata$x:00013FD9                 db    0
.xdata$x:00013FDA                 db    0
.xdata$x:00013FDB                 db    0
.xdata$x:00013FDC                 dd offset __unwindtable$??$construct@UsessionFileInfo@@U1@@?$allocator@UsessionFileInfo@@@std@@QAEXPAUsessionFileInfo@@$$QAU2@@Z
.xdata$x:00013FE0                 db    0
.xdata$x:00013FE1                 db    0
.xdata$x:00013FE2                 db    0
.xdata$x:00013FE3                 db    0
.xdata$x:00013FE4                 db    0
.xdata$x:00013FE5                 db    0
.xdata$x:00013FE6                 db    0
.xdata$x:00013FE7                 db    0
.xdata$x:00013FE8                 db    0
.xdata$x:00013FE9                 db    0
.xdata$x:00013FEA                 db    0
.xdata$x:00013FEB                 db    0
.xdata$x:00013FEC                 db    0
.xdata$x:00013FED                 db    0
.xdata$x:00013FEE                 db    0
.xdata$x:00013FEF                 db    0
.xdata$x:00013FF0                 db    0
.xdata$x:00013FF1                 db    0
.xdata$x:00013FF2                 db    0
.xdata$x:00013FF3                 db    0
.xdata$x:00013FF4                 db    0
.xdata$x:00013FF5                 db    0
.xdata$x:00013FF6                 db    0
.xdata$x:00013FF7                 db    0
.xdata$x:00013FF7 _xdata$x        ends
.xdata$x:00013FF7
.xdata$x:00013FF8 ; ===========================================================================
.xdata$x:00013FF8
.xdata$x:00013FF8 ; Segment type: Pure data
.xdata$x:00013FF8 ; Segment permissions: Read
.xdata$x:00013FF8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00013FF8                 assume cs:_xdata$x
.xdata$x:00013FF8                 ;org 13FF8h
.xdata$x:00013FF8 ; COMDAT (pick associative to section at 8E80)
.xdata$x:00013FF8 __unwindtable$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z db 0FFh
.xdata$x:00013FF8                                         ; DATA XREF: .xdata$x:00014008o
.xdata$x:00013FF9                 db 0FFh
.xdata$x:00013FFA                 db 0FFh
.xdata$x:00013FFB                 db 0FFh
.xdata$x:00013FFC                 dd offset __unwindfunclet$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z$0
.xdata$x:00014000 __ehfuncinfo$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z db  22h ; "
.xdata$x:00014000                                         ; DATA XREF: __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z+11o
.xdata$x:00014001                 db    5
.xdata$x:00014002                 db  93h ; ô
.xdata$x:00014003                 db  19h
.xdata$x:00014004                 db    1
.xdata$x:00014005                 db    0
.xdata$x:00014006                 db    0
.xdata$x:00014007                 db    0
.xdata$x:00014008                 dd offset __unwindtable$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z
.xdata$x:0001400C                 db    0
.xdata$x:0001400D                 db    0
.xdata$x:0001400E                 db    0
.xdata$x:0001400F                 db    0
.xdata$x:00014010                 db    0
.xdata$x:00014011                 db    0
.xdata$x:00014012                 db    0
.xdata$x:00014013                 db    0
.xdata$x:00014014                 db    0
.xdata$x:00014015                 db    0
.xdata$x:00014016                 db    0
.xdata$x:00014017                 db    0
.xdata$x:00014018                 db    0
.xdata$x:00014019                 db    0
.xdata$x:0001401A                 db    0
.xdata$x:0001401B                 db    0
.xdata$x:0001401C                 db    0
.xdata$x:0001401D                 db    0
.xdata$x:0001401E                 db    0
.xdata$x:0001401F                 db    0
.xdata$x:00014020                 db    0
.xdata$x:00014021                 db    0
.xdata$x:00014022                 db    0
.xdata$x:00014023                 db    0
.xdata$x:00014023 _xdata$x        ends
.xdata$x:00014023
.xdata$x:00014024 ; ===========================================================================
.xdata$x:00014024
.xdata$x:00014024 ; Segment type: Pure data
.xdata$x:00014024 ; Segment permissions: Read
.xdata$x:00014024 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00014024                 assume cs:_xdata$x
.xdata$x:00014024                 ;org 14024h
.xdata$x:00014024 ; COMDAT (pick associative to section at 8A30)
.xdata$x:00014024 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00014024                                         ; DATA XREF: .xdata$x:00014034o
.xdata$x:00014025                 db 0FFh
.xdata$x:00014026                 db 0FFh
.xdata$x:00014027                 db 0FFh
.xdata$x:00014028                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:0001402C __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:0001402C                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:0001402D                 db    5
.xdata$x:0001402E                 db  93h ; ô
.xdata$x:0001402F                 db  19h
.xdata$x:00014030                 db    1
.xdata$x:00014031                 db    0
.xdata$x:00014032                 db    0
.xdata$x:00014033                 db    0
.xdata$x:00014034                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00014038                 db    0
.xdata$x:00014039                 db    0
.xdata$x:0001403A                 db    0
.xdata$x:0001403B                 db    0
.xdata$x:0001403C                 db    0
.xdata$x:0001403D                 db    0
.xdata$x:0001403E                 db    0
.xdata$x:0001403F                 db    0
.xdata$x:00014040                 db    0
.xdata$x:00014041                 db    0
.xdata$x:00014042                 db    0
.xdata$x:00014043                 db    0
.xdata$x:00014044                 db    0
.xdata$x:00014045                 db    0
.xdata$x:00014046                 db    0
.xdata$x:00014047                 db    0
.xdata$x:00014048                 db    0
.xdata$x:00014049                 db    0
.xdata$x:0001404A                 db    0
.xdata$x:0001404B                 db    0
.xdata$x:0001404C                 db    0
.xdata$x:0001404D                 db    0
.xdata$x:0001404E                 db    0
.xdata$x:0001404F                 db    0
.xdata$x:0001404F _xdata$x        ends
.xdata$x:0001404F
.xdata$x:00014050 ; ===========================================================================
.xdata$x:00014050
.xdata$x:00014050 ; Segment type: Pure data
.xdata$x:00014050 ; Segment permissions: Read
.xdata$x:00014050 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00014050                 assume cs:_xdata$x
.xdata$x:00014050                 ;org 14050h
.xdata$x:00014050 ; COMDAT (pick associative to section at 8B30)
.xdata$x:00014050 __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:00014050                                         ; DATA XREF: .xdata$x:00014060o
.xdata$x:00014051                 db 0FFh
.xdata$x:00014052                 db 0FFh
.xdata$x:00014053                 db 0FFh
.xdata$x:00014054                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:00014058 __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:00014058                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:00014059                 db    5
.xdata$x:0001405A                 db  93h ; ô
.xdata$x:0001405B                 db  19h
.xdata$x:0001405C                 db    1
.xdata$x:0001405D                 db    0
.xdata$x:0001405E                 db    0
.xdata$x:0001405F                 db    0
.xdata$x:00014060                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:00014064                 db    0
.xdata$x:00014065                 db    0
.xdata$x:00014066                 db    0
.xdata$x:00014067                 db    0
.xdata$x:00014068                 db    0
.xdata$x:00014069                 db    0
.xdata$x:0001406A                 db    0
.xdata$x:0001406B                 db    0
.xdata$x:0001406C                 db    0
.xdata$x:0001406D                 db    0
.xdata$x:0001406E                 db    0
.xdata$x:0001406F                 db    0
.xdata$x:00014070                 db    0
.xdata$x:00014071                 db    0
.xdata$x:00014072                 db    0
.xdata$x:00014073                 db    0
.xdata$x:00014074                 db    0
.xdata$x:00014075                 db    0
.xdata$x:00014076                 db    0
.xdata$x:00014077                 db    0
.xdata$x:00014078                 db    0
.xdata$x:00014079                 db    0
.xdata$x:0001407A                 db    0
.xdata$x:0001407B                 db    0
.xdata$x:0001407B _xdata$x        ends
.xdata$x:0001407B
.xdata$x:0001407C ; ===========================================================================
.xdata$x:0001407C
.xdata$x:0001407C ; Segment type: Pure data
.xdata$x:0001407C ; Segment permissions: Read
.xdata$x:0001407C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0001407C                 assume cs:_xdata$x
.xdata$x:0001407C                 ;org 1407Ch
.xdata$x:0001407C ; COMDAT (pick associative to section at 7F10)
.xdata$x:0001407C __catchsym$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0001407C                                         ; DATA XREF: .xdata$x:000140ACo
.xdata$x:0001407D                 db    0
.xdata$x:0001407E                 db    0
.xdata$x:0001407F                 db    0
.xdata$x:00014080                 db    0
.xdata$x:00014081                 db    0
.xdata$x:00014082                 db    0
.xdata$x:00014083                 db    0
.xdata$x:00014084                 db    0
.xdata$x:00014085                 db    0
.xdata$x:00014086                 db    0
.xdata$x:00014087                 db    0
.xdata$x:00014088                 dd offset __catch$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0001408C __unwindtable$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0001408C                                         ; DATA XREF: .xdata$x:000140B8o
.xdata$x:0001408D                 db 0FFh
.xdata$x:0001408E                 db 0FFh
.xdata$x:0001408F                 db 0FFh
.xdata$x:00014090                 db    0
.xdata$x:00014091                 db    0
.xdata$x:00014092                 db    0
.xdata$x:00014093                 db    0
.xdata$x:00014094                 db 0FFh
.xdata$x:00014095                 db 0FFh
.xdata$x:00014096                 db 0FFh
.xdata$x:00014097                 db 0FFh
.xdata$x:00014098                 db    0
.xdata$x:00014099                 db    0
.xdata$x:0001409A                 db    0
.xdata$x:0001409B                 db    0
.xdata$x:0001409C __tryblocktable$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0001409C                                         ; DATA XREF: .xdata$x:000140C0o
.xdata$x:0001409D                 db    0
.xdata$x:0001409E                 db    0
.xdata$x:0001409F                 db    0
.xdata$x:000140A0                 db    0
.xdata$x:000140A1                 db    0
.xdata$x:000140A2                 db    0
.xdata$x:000140A3                 db    0
.xdata$x:000140A4                 db    1
.xdata$x:000140A5                 db    0
.xdata$x:000140A6                 db    0
.xdata$x:000140A7                 db    0
.xdata$x:000140A8                 db    1
.xdata$x:000140A9                 db    0
.xdata$x:000140AA                 db    0
.xdata$x:000140AB                 db    0
.xdata$x:000140AC                 dd offset __catchsym$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:000140B0 __ehfuncinfo$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:000140B0                                         ; DATA XREF: __ehhandler$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:000140B1                 db    5
.xdata$x:000140B2                 db  93h ; ô
.xdata$x:000140B3                 db  19h
.xdata$x:000140B4                 db    2
.xdata$x:000140B5                 db    0
.xdata$x:000140B6                 db    0
.xdata$x:000140B7                 db    0
.xdata$x:000140B8                 dd offset __unwindtable$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:000140BC                 db    1
.xdata$x:000140BD                 db    0
.xdata$x:000140BE                 db    0
.xdata$x:000140BF                 db    0
.xdata$x:000140C0                 dd offset __tryblocktable$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:000140C4                 db    0
.xdata$x:000140C5                 db    0
.xdata$x:000140C6                 db    0
.xdata$x:000140C7                 db    0
.xdata$x:000140C8                 db    0
.xdata$x:000140C9                 db    0
.xdata$x:000140CA                 db    0
.xdata$x:000140CB                 db    0
.xdata$x:000140CC                 db    0
.xdata$x:000140CD                 db    0
.xdata$x:000140CE                 db    0
.xdata$x:000140CF                 db    0
.xdata$x:000140D0                 db    0
.xdata$x:000140D1                 db    0
.xdata$x:000140D2                 db    0
.xdata$x:000140D3                 db    0
.xdata$x:000140D3 _xdata$x        ends
.xdata$x:000140D3
.xdata$x:000140D4 ; ===========================================================================
.xdata$x:000140D4
.xdata$x:000140D4 ; Segment type: Pure data
.xdata$x:000140D4 ; Segment permissions: Read
.xdata$x:000140D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000140D4                 assume cs:_xdata$x
.xdata$x:000140D4                 ;org 140D4h
.xdata$x:000140D4 ; COMDAT (pick associative to section at 8114)
.xdata$x:000140D4 __catchsym$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:000140D4                                         ; DATA XREF: .xdata$x:00014104o
.xdata$x:000140D5                 db    0
.xdata$x:000140D6                 db    0
.xdata$x:000140D7                 db    0
.xdata$x:000140D8                 db    0
.xdata$x:000140D9                 db    0
.xdata$x:000140DA                 db    0
.xdata$x:000140DB                 db    0
.xdata$x:000140DC                 db    0
.xdata$x:000140DD                 db    0
.xdata$x:000140DE                 db    0
.xdata$x:000140DF                 db    0
.xdata$x:000140E0                 dd offset __catch$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:000140E4 __unwindtable$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:000140E4                                         ; DATA XREF: .xdata$x:00014110o
.xdata$x:000140E5                 db 0FFh
.xdata$x:000140E6                 db 0FFh
.xdata$x:000140E7                 db 0FFh
.xdata$x:000140E8                 db    0
.xdata$x:000140E9                 db    0
.xdata$x:000140EA                 db    0
.xdata$x:000140EB                 db    0
.xdata$x:000140EC                 db 0FFh
.xdata$x:000140ED                 db 0FFh
.xdata$x:000140EE                 db 0FFh
.xdata$x:000140EF                 db 0FFh
.xdata$x:000140F0                 db    0
.xdata$x:000140F1                 db    0
.xdata$x:000140F2                 db    0
.xdata$x:000140F3                 db    0
.xdata$x:000140F4 __tryblocktable$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:000140F4                                         ; DATA XREF: .xdata$x:00014118o
.xdata$x:000140F5                 db    0
.xdata$x:000140F6                 db    0
.xdata$x:000140F7                 db    0
.xdata$x:000140F8                 db    0
.xdata$x:000140F9                 db    0
.xdata$x:000140FA                 db    0
.xdata$x:000140FB                 db    0
.xdata$x:000140FC                 db    1
.xdata$x:000140FD                 db    0
.xdata$x:000140FE                 db    0
.xdata$x:000140FF                 db    0
.xdata$x:00014100                 db    1
.xdata$x:00014101                 db    0
.xdata$x:00014102                 db    0
.xdata$x:00014103                 db    0
.xdata$x:00014104                 dd offset __catchsym$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:00014108 __ehfuncinfo$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:00014108                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:00014109                 db    5
.xdata$x:0001410A                 db  93h ; ô
.xdata$x:0001410B                 db  19h
.xdata$x:0001410C                 db    2
.xdata$x:0001410D                 db    0
.xdata$x:0001410E                 db    0
.xdata$x:0001410F                 db    0
.xdata$x:00014110                 dd offset __unwindtable$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00014114                 db    1
.xdata$x:00014115                 db    0
.xdata$x:00014116                 db    0
.xdata$x:00014117                 db    0
.xdata$x:00014118                 dd offset __tryblocktable$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0001411C                 db    0
.xdata$x:0001411D                 db    0
.xdata$x:0001411E                 db    0
.xdata$x:0001411F                 db    0
.xdata$x:00014120                 db    0
.xdata$x:00014121                 db    0
.xdata$x:00014122                 db    0
.xdata$x:00014123                 db    0
.xdata$x:00014124                 db    0
.xdata$x:00014125                 db    0
.xdata$x:00014126                 db    0
.xdata$x:00014127                 db    0
.xdata$x:00014128                 db    0
.xdata$x:00014129                 db    0
.xdata$x:0001412A                 db    0
.xdata$x:0001412B                 db    0
.xdata$x:0001412B _xdata$x        ends
.xdata$x:0001412B
.xdata$x:0001412C ; ===========================================================================
.xdata$x:0001412C
.xdata$x:0001412C ; Segment type: Pure data
.xdata$x:0001412C ; Segment permissions: Read
.xdata$x:0001412C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0001412C                 assume cs:_xdata$x
.xdata$x:0001412C                 ;org 1412Ch
.xdata$x:0001412C ; COMDAT (pick associative to section at 826C)
.xdata$x:0001412C __catchsym$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0001412C                                         ; DATA XREF: .xdata$x:0001415Co
.xdata$x:0001412D                 db    0
.xdata$x:0001412E                 db    0
.xdata$x:0001412F                 db    0
.xdata$x:00014130                 db    0
.xdata$x:00014131                 db    0
.xdata$x:00014132                 db    0
.xdata$x:00014133                 db    0
.xdata$x:00014134                 db    0
.xdata$x:00014135                 db    0
.xdata$x:00014136                 db    0
.xdata$x:00014137                 db    0
.xdata$x:00014138                 dd offset __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0001413C __unwindtable$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0001413C                                         ; DATA XREF: .xdata$x:00014168o
.xdata$x:0001413D                 db 0FFh
.xdata$x:0001413E                 db 0FFh
.xdata$x:0001413F                 db 0FFh
.xdata$x:00014140                 db    0
.xdata$x:00014141                 db    0
.xdata$x:00014142                 db    0
.xdata$x:00014143                 db    0
.xdata$x:00014144                 db 0FFh
.xdata$x:00014145                 db 0FFh
.xdata$x:00014146                 db 0FFh
.xdata$x:00014147                 db 0FFh
.xdata$x:00014148                 db    0
.xdata$x:00014149                 db    0
.xdata$x:0001414A                 db    0
.xdata$x:0001414B                 db    0
.xdata$x:0001414C __tryblocktable$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0001414C                                         ; DATA XREF: .xdata$x:00014170o
.xdata$x:0001414D                 db    0
.xdata$x:0001414E                 db    0
.xdata$x:0001414F                 db    0
.xdata$x:00014150                 db    0
.xdata$x:00014151                 db    0
.xdata$x:00014152                 db    0
.xdata$x:00014153                 db    0
.xdata$x:00014154                 db    1
.xdata$x:00014155                 db    0
.xdata$x:00014156                 db    0
.xdata$x:00014157                 db    0
.xdata$x:00014158                 db    1
.xdata$x:00014159                 db    0
.xdata$x:0001415A                 db    0
.xdata$x:0001415B                 db    0
.xdata$x:0001415C                 dd offset __catchsym$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:00014160 __ehfuncinfo$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:00014160                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:00014161                 db    5
.xdata$x:00014162                 db  93h ; ô
.xdata$x:00014163                 db  19h
.xdata$x:00014164                 db    2
.xdata$x:00014165                 db    0
.xdata$x:00014166                 db    0
.xdata$x:00014167                 db    0
.xdata$x:00014168                 dd offset __unwindtable$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0001416C                 db    1
.xdata$x:0001416D                 db    0
.xdata$x:0001416E                 db    0
.xdata$x:0001416F                 db    0
.xdata$x:00014170                 dd offset __tryblocktable$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00014174                 db    0
.xdata$x:00014175                 db    0
.xdata$x:00014176                 db    0
.xdata$x:00014177                 db    0
.xdata$x:00014178                 db    0
.xdata$x:00014179                 db    0
.xdata$x:0001417A                 db    0
.xdata$x:0001417B                 db    0
.xdata$x:0001417C                 db    0
.xdata$x:0001417D                 db    0
.xdata$x:0001417E                 db    0
.xdata$x:0001417F                 db    0
.xdata$x:00014180                 db    0
.xdata$x:00014181                 db    0
.xdata$x:00014182                 db    0
.xdata$x:00014183                 db    0
.xdata$x:00014183 _xdata$x        ends
.xdata$x:00014183
.xdata$x:00014184 ; ===========================================================================
.xdata$x:00014184
.xdata$x:00014184 ; Segment type: Pure data
.xdata$x:00014184 ; Segment permissions: Read
.xdata$x:00014184 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00014184                 assume cs:_xdata$x
.xdata$x:00014184                 ;org 14184h
.xdata$x:00014184 ; COMDAT (pick associative to section at 91EC)
.xdata$x:00014184 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00014184                                         ; DATA XREF: .xdata$x:00014194o
.xdata$x:00014185                 db 0FFh
.xdata$x:00014186                 db 0FFh
.xdata$x:00014187                 db 0FFh
.xdata$x:00014188                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0001418C __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0001418C                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0001418D                 db    5
.xdata$x:0001418E                 db  93h ; ô
.xdata$x:0001418F                 db  19h
.xdata$x:00014190                 db    1
.xdata$x:00014191                 db    0
.xdata$x:00014192                 db    0
.xdata$x:00014193                 db    0
.xdata$x:00014194                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00014198                 db    0
.xdata$x:00014199                 db    0
.xdata$x:0001419A                 db    0
.xdata$x:0001419B                 db    0
.xdata$x:0001419C                 db    0
.xdata$x:0001419D                 db    0
.xdata$x:0001419E                 db    0
.xdata$x:0001419F                 db    0
.xdata$x:000141A0                 db    0
.xdata$x:000141A1                 db    0
.xdata$x:000141A2                 db    0
.xdata$x:000141A3                 db    0
.xdata$x:000141A4                 db    0
.xdata$x:000141A5                 db    0
.xdata$x:000141A6                 db    0
.xdata$x:000141A7                 db    0
.xdata$x:000141A8                 db    0
.xdata$x:000141A9                 db    0
.xdata$x:000141AA                 db    0
.xdata$x:000141AB                 db    0
.xdata$x:000141AC                 db    0
.xdata$x:000141AD                 db    0
.xdata$x:000141AE                 db    0
.xdata$x:000141AF                 db    0
.xdata$x:000141AF _xdata$x        ends
.xdata$x:000141AF
.xdata$x:000141B0 ; ===========================================================================
.xdata$x:000141B0
.xdata$x:000141B0 ; Segment type: Pure data
.xdata$x:000141B0 ; Segment permissions: Read
.xdata$x:000141B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000141B0                 assume cs:_xdata$x
.xdata$x:000141B0                 ;org 141B0h
.xdata$x:000141B0 ; COMDAT (pick associative to section at B174)
.xdata$x:000141B0 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:000141B0                                         ; DATA XREF: .xdata$x:000141C0o
.xdata$x:000141B1                 db 0FFh
.xdata$x:000141B2                 db 0FFh
.xdata$x:000141B3                 db 0FFh
.xdata$x:000141B4                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:000141B8 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000141B8                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:000141B9                 db    5
.xdata$x:000141BA                 db  93h ; ô
.xdata$x:000141BB                 db  19h
.xdata$x:000141BC                 db    1
.xdata$x:000141BD                 db    0
.xdata$x:000141BE                 db    0
.xdata$x:000141BF                 db    0
.xdata$x:000141C0                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:000141C4                 db    0
.xdata$x:000141C5                 db    0
.xdata$x:000141C6                 db    0
.xdata$x:000141C7                 db    0
.xdata$x:000141C8                 db    0
.xdata$x:000141C9                 db    0
.xdata$x:000141CA                 db    0
.xdata$x:000141CB                 db    0
.xdata$x:000141CC                 db    0
.xdata$x:000141CD                 db    0
.xdata$x:000141CE                 db    0
.xdata$x:000141CF                 db    0
.xdata$x:000141D0                 db    0
.xdata$x:000141D1                 db    0
.xdata$x:000141D2                 db    0
.xdata$x:000141D3                 db    0
.xdata$x:000141D4                 db    0
.xdata$x:000141D5                 db    0
.xdata$x:000141D6                 db    0
.xdata$x:000141D7                 db    0
.xdata$x:000141D8                 db    0
.xdata$x:000141D9                 db    0
.xdata$x:000141DA                 db    0
.xdata$x:000141DB                 db    0
.xdata$x:000141DB _xdata$x        ends
.xdata$x:000141DB
.xdata$x:000141DC ; ===========================================================================
.xdata$x:000141DC
.xdata$x:000141DC ; Segment type: Pure data
.xdata$x:000141DC ; Segment permissions: Read
.xdata$x:000141DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000141DC                 assume cs:_xdata$x
.xdata$x:000141DC                 ;org 141DCh
.xdata$x:000141DC ; COMDAT (pick associative to section at 9174)
.xdata$x:000141DC __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:000141DC                                         ; DATA XREF: .xdata$x:000141ECo
.xdata$x:000141DD                 db 0FFh
.xdata$x:000141DE                 db 0FFh
.xdata$x:000141DF                 db 0FFh
.xdata$x:000141E0                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:000141E4 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:000141E4                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:000141E5                 db    5
.xdata$x:000141E6                 db  93h ; ô
.xdata$x:000141E7                 db  19h
.xdata$x:000141E8                 db    1
.xdata$x:000141E9                 db    0
.xdata$x:000141EA                 db    0
.xdata$x:000141EB                 db    0
.xdata$x:000141EC                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@IHPBIABIU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:000141F0                 db    0
.xdata$x:000141F1                 db    0
.xdata$x:000141F2                 db    0
.xdata$x:000141F3                 db    0
.xdata$x:000141F4                 db    0
.xdata$x:000141F5                 db    0
.xdata$x:000141F6                 db    0
.xdata$x:000141F7                 db    0
.xdata$x:000141F8                 db    0
.xdata$x:000141F9                 db    0
.xdata$x:000141FA                 db    0
.xdata$x:000141FB                 db    0
.xdata$x:000141FC                 db    0
.xdata$x:000141FD                 db    0
.xdata$x:000141FE                 db    0
.xdata$x:000141FF                 db    0
.xdata$x:00014200                 db    0
.xdata$x:00014201                 db    0
.xdata$x:00014202                 db    0
.xdata$x:00014203                 db    0
.xdata$x:00014204                 db    0
.xdata$x:00014205                 db    0
.xdata$x:00014206                 db    0
.xdata$x:00014207                 db    0
.xdata$x:00014207 _xdata$x        ends
.xdata$x:00014207
.xdata$x:00014208 ; ===========================================================================
.xdata$x:00014208
.xdata$x:00014208 ; Segment type: Pure data
.xdata$x:00014208 ; Segment permissions: Read
.xdata$x:00014208 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00014208                 assume cs:_xdata$x
.xdata$x:00014208                 ;org 14208h
.xdata$x:00014208 ; COMDAT (pick associative to section at 9B44)
.xdata$x:00014208 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z db 0FFh
.xdata$x:00014208                                         ; DATA XREF: .xdata$x:00014218o
.xdata$x:00014209                 db 0FFh
.xdata$x:0001420A                 db 0FFh
.xdata$x:0001420B                 db 0FFh
.xdata$x:0001420C                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z$0
.xdata$x:00014210 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00014210                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z+11o
.xdata$x:00014211                 db    5
.xdata$x:00014212                 db  93h ; ô
.xdata$x:00014213                 db  19h
.xdata$x:00014214                 db    1
.xdata$x:00014215                 db    0
.xdata$x:00014216                 db    0
.xdata$x:00014217                 db    0
.xdata$x:00014218                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z
.xdata$x:0001421C                 db    0
.xdata$x:0001421D                 db    0
.xdata$x:0001421E                 db    0
.xdata$x:0001421F                 db    0
.xdata$x:00014220                 db    0
.xdata$x:00014221                 db    0
.xdata$x:00014222                 db    0
.xdata$x:00014223                 db    0
.xdata$x:00014224                 db    0
.xdata$x:00014225                 db    0
.xdata$x:00014226                 db    0
.xdata$x:00014227                 db    0
.xdata$x:00014228                 db    0
.xdata$x:00014229                 db    0
.xdata$x:0001422A                 db    0
.xdata$x:0001422B                 db    0
.xdata$x:0001422C                 db    0
.xdata$x:0001422D                 db    0
.xdata$x:0001422E                 db    0
.xdata$x:0001422F                 db    0
.xdata$x:00014230                 db    0
.xdata$x:00014231                 db    0
.xdata$x:00014232                 db    0
.xdata$x:00014233                 db    0
.xdata$x:00014233 _xdata$x        ends
.xdata$x:00014233
.xdata$x:00014234 ; ===========================================================================
.xdata$x:00014234
.xdata$x:00014234 ; Segment type: Pure data
.xdata$x:00014234 ; Segment permissions: Read
.xdata$x:00014234 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00014234                 assume cs:_xdata$x
.xdata$x:00014234                 ;org 14234h
.xdata$x:00014234 ; COMDAT (pick associative to section at B7C4)
.xdata$x:00014234 __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00014234                                         ; DATA XREF: .xdata$x:00014244o
.xdata$x:00014235                 db 0FFh
.xdata$x:00014236                 db 0FFh
.xdata$x:00014237                 db 0FFh
.xdata$x:00014238                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0001423C __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0001423C                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0001423D                 db    5
.xdata$x:0001423E                 db  93h ; ô
.xdata$x:0001423F                 db  19h
.xdata$x:00014240                 db    1
.xdata$x:00014241                 db    0
.xdata$x:00014242                 db    0
.xdata$x:00014243                 db    0
.xdata$x:00014244                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
.xdata$x:00014248                 align 20h
.xdata$x:00014248 _xdata$x        ends
.xdata$x:00014248
.xdata$x:00014260 ; ===========================================================================
.xdata$x:00014260
.xdata$x:00014260 ; Segment type: Pure data
.xdata$x:00014260 ; Segment permissions: Read
.xdata$x:00014260 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00014260                 assume cs:_xdata$x
.xdata$x:00014260                 ;org 14260h
.xdata$x:00014260 ; COMDAT (pick associative to section at 9AC0)
.xdata$x:00014260 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00014260                                         ; DATA XREF: .xdata$x:00014270o
.xdata$x:00014261                 db 0FFh
.xdata$x:00014262                 db 0FFh
.xdata$x:00014263                 db 0FFh
.xdata$x:00014264                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00014268 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00014268                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00014269                 db    5
.xdata$x:0001426A                 db  93h ; ô
.xdata$x:0001426B                 db  19h
.xdata$x:0001426C                 db    1
.xdata$x:0001426D                 db    0
.xdata$x:0001426E                 db    0
.xdata$x:0001426F                 db    0
.xdata$x:00014270                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00014274                 db    0
.xdata$x:00014275                 db    0
.xdata$x:00014276                 db    0
.xdata$x:00014277                 db    0
.xdata$x:00014278                 db    0
.xdata$x:00014279                 db    0
.xdata$x:0001427A                 db    0
.xdata$x:0001427B                 db    0
.xdata$x:0001427C                 db    0
.xdata$x:0001427D                 db    0
.xdata$x:0001427E                 db    0
.xdata$x:0001427F                 db    0
.xdata$x:00014280                 db    0
.xdata$x:00014281                 db    0
.xdata$x:00014282                 db    0
.xdata$x:00014283                 db    0
.xdata$x:00014284                 db    0
.xdata$x:00014285                 db    0
.xdata$x:00014286                 db    0
.xdata$x:00014287                 db    0
.xdata$x:00014288                 db    0
.xdata$x:00014289                 db    0
.xdata$x:0001428A                 db    0
.xdata$x:0001428B                 db    0
.xdata$x:0001428B _xdata$x        ends
.xdata$x:0001428B
.xdata$x:0001428C ; ===========================================================================
.xdata$x:0001428C
.xdata$x:0001428C ; Segment type: Pure data
.xdata$x:0001428C ; Segment permissions: Read
.xdata$x:0001428C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0001428C                 assume cs:_xdata$x
.xdata$x:0001428C                 ;org 1428Ch
.xdata$x:0001428C ; COMDAT (pick associative to section at 79EC)
.xdata$x:0001428C __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z db 0FFh
.xdata$x:0001428C                                         ; DATA XREF: .xdata$x:000142B4o
.xdata$x:0001428D                 db 0FFh
.xdata$x:0001428E                 db 0FFh
.xdata$x:0001428F                 db 0FFh
.xdata$x:00014290                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z$0
.xdata$x:00014294                 align 8
.xdata$x:00014298                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z$1
.xdata$x:0001429C                 db    1
.xdata$x:0001429D                 db    0
.xdata$x:0001429E                 db    0
.xdata$x:0001429F                 db    0
.xdata$x:000142A0                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z$2
.xdata$x:000142A4                 db    2
.xdata$x:000142A5                 db    0
.xdata$x:000142A6                 db    0
.xdata$x:000142A7                 db    0
.xdata$x:000142A8                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z$3
.xdata$x:000142AC __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z db  22h ; "
.xdata$x:000142AC                                         ; DATA XREF: __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z+11o
.xdata$x:000142AD                 db    5
.xdata$x:000142AE                 db  93h ; ô
.xdata$x:000142AF                 db  19h
.xdata$x:000142B0                 db    4
.xdata$x:000142B1                 db    0
.xdata$x:000142B2                 db    0
.xdata$x:000142B3                 db    0
.xdata$x:000142B4                 dd offset __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@1@0PAI@Z
.xdata$x:000142B8                 db    0
.xdata$x:000142B9                 db    0
.xdata$x:000142BA                 db    0
.xdata$x:000142BB                 db    0
.xdata$x:000142BC                 db    0
.xdata$x:000142BD                 db    0
.xdata$x:000142BE                 db    0
.xdata$x:000142BF                 db    0
.xdata$x:000142C0                 db    0
.xdata$x:000142C1                 db    0
.xdata$x:000142C2                 db    0
.xdata$x:000142C3                 db    0
.xdata$x:000142C4                 db    0
.xdata$x:000142C5                 db    0
.xdata$x:000142C6                 db    0
.xdata$x:000142C7                 db    0
.xdata$x:000142C8                 db    0
.xdata$x:000142C9                 db    0
.xdata$x:000142CA                 db    0
.xdata$x:000142CB                 db    0
.xdata$x:000142CC                 db    0
.xdata$x:000142CD                 db    0
.xdata$x:000142CE                 db    0
.xdata$x:000142CF                 db    0
.xdata$x:000142CF _xdata$x        ends
.xdata$x:000142CF
.xdata$x:000142D0 ; ===========================================================================
.xdata$x:000142D0
.xdata$x:000142D0 ; Segment type: Pure data
.xdata$x:000142D0 ; Segment permissions: Read
.xdata$x:000142D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000142D0                 assume cs:_xdata$x
.xdata$x:000142D0                 ;org 142D0h
.xdata$x:000142D0 ; COMDAT (pick associative to section at 83BC)
.xdata$x:000142D0 __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z db 0FFh
.xdata$x:000142D0                                         ; DATA XREF: .xdata$x:000142F8o
.xdata$x:000142D1                 db 0FFh
.xdata$x:000142D2                 db 0FFh
.xdata$x:000142D3                 db 0FFh
.xdata$x:000142D4                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z$0
.xdata$x:000142D8                 db    0
.xdata$x:000142D9                 db    0
.xdata$x:000142DA                 db    0
.xdata$x:000142DB                 db    0
.xdata$x:000142DC                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z$1
.xdata$x:000142E0                 db    1
.xdata$x:000142E1                 db    0
.xdata$x:000142E2                 db    0
.xdata$x:000142E3                 db    0
.xdata$x:000142E4                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z$2
.xdata$x:000142E8                 db    1
.xdata$x:000142E9                 db    0
.xdata$x:000142EA                 db    0
.xdata$x:000142EB                 db    0
.xdata$x:000142EC                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z$3
.xdata$x:000142F0 __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z db  22h ; "
.xdata$x:000142F0                                         ; DATA XREF: __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z+11o
.xdata$x:000142F1                 db    5
.xdata$x:000142F2                 db  93h ; ô
.xdata$x:000142F3                 db  19h
.xdata$x:000142F4                 db    4
.xdata$x:000142F5                 db    0
.xdata$x:000142F6                 db    0
.xdata$x:000142F7                 db    0
.xdata$x:000142F8                 dd offset __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@PAIU?$_Wrap_alloc@V?$allocator@I@std@@@2@@std@@YAPAIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@0PAIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
.xdata$x:000142FC                 db    0
.xdata$x:000142FD                 db    0
.xdata$x:000142FE                 db    0
.xdata$x:000142FF                 db    0
.xdata$x:00014300                 db    0
.xdata$x:00014301                 db    0
.xdata$x:00014302                 db    0
.xdata$x:00014303                 db    0
.xdata$x:00014304                 db    0
.xdata$x:00014305                 db    0
.xdata$x:00014306                 db    0
.xdata$x:00014307                 db    0
.xdata$x:00014308                 db    0
.xdata$x:00014309                 db    0
.xdata$x:0001430A                 db    0
.xdata$x:0001430B                 db    0
.xdata$x:0001430C                 db    0
.xdata$x:0001430D                 db    0
.xdata$x:0001430E                 db    0
.xdata$x:0001430F                 db    0
.xdata$x:00014310                 db    0
.xdata$x:00014311                 db    0
.xdata$x:00014312                 db    0
.xdata$x:00014313                 db    0
.xdata$x:00014313 _xdata$x        ends
.xdata$x:00014313
.xdata$x:00014314 ; ===========================================================================
.xdata$x:00014314
.xdata$x:00014314 ; Segment type: Pure data
.xdata$x:00014314 ; Segment permissions: Read
.xdata$x:00014314 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00014314                 assume cs:_xdata$x
.xdata$x:00014314                 ;org 14314h
.xdata$x:00014314 ; COMDAT (pick associative to section at 7CA8)
.xdata$x:00014314 __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z db 0FFh
.xdata$x:00014314                                         ; DATA XREF: .xdata$x:00014324o
.xdata$x:00014315                 db 0FFh
.xdata$x:00014316                 db 0FFh
.xdata$x:00014317                 db 0FFh
.xdata$x:00014318                 dd offset __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z$0
.xdata$x:0001431C __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z db  22h ; "
.xdata$x:0001431C                                         ; DATA XREF: __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z+11o
.xdata$x:0001431D                 db    5
.xdata$x:0001431E                 db  93h ; ô
.xdata$x:0001431F                 db  19h
.xdata$x:00014320                 db    1
.xdata$x:00014321                 db    0
.xdata$x:00014322                 db    0
.xdata$x:00014323                 db    0
.xdata$x:00014324                 dd offset __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPBIV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@@Z
.xdata$x:00014328                 align 20h
.xdata$x:00014328 _xdata$x        ends
.xdata$x:00014328
.rdata:00014340 ; ===========================================================================
.rdata:00014340
.rdata:00014340 ; Segment type: Pure data
.rdata:00014340 ; Segment permissions: Read
.rdata:00014340 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00014340 _rdata          segment para public 'DATA' use32
.rdata:00014340                 assume cs:_rdata
.rdata:00014340                 ;org 14340h
.rdata:00014340 ; COMDAT (pick any)
.rdata:00014340                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00014340 ; wchar_t `string'
.rdata:00014340 ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00014340                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+48o
.rdata:00014340                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00014340                 unicode 0, <clude\xutility>,0
.rdata:00014340 _rdata          ends
.rdata:00014340
.rdata:000143D0 ; ===========================================================================
.rdata:000143D0
.rdata:000143D0 ; Segment type: Pure data
.rdata:000143D0 ; Segment permissions: Read
.rdata:000143D0 _rdata          segment dword public 'DATA' use32
.rdata:000143D0                 assume cs:_rdata
.rdata:000143D0                 ;org 143D0h
.rdata:000143D0 ; COMDAT (pick any)
.rdata:000143D0                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:000143D0 ; wchar_t `string'
.rdata:000143D0 ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:000143D0                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:000143D0                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:00014402                 align 4
.rdata:00014402 _rdata          ends
.rdata:00014402
.rdata:00014404 ; ===========================================================================
.rdata:00014404
.rdata:00014404 ; Segment type: Pure data
.rdata:00014404 ; Segment permissions: Read
.rdata:00014404 _rdata          segment dword public 'DATA' use32
.rdata:00014404                 assume cs:_rdata
.rdata:00014404                 ;org 14404h
.rdata:00014404 ; COMDAT (pick any)
.rdata:00014404                 public ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
.rdata:00014404 ; public: static unsigned int const std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::npos
.rdata:00014404 ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB dd 0FFFFFFFFh
.rdata:00014404                                         ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+17Ar
.rdata:00014404 _rdata          ends
.rdata:00014404
.rdata:00014408 ; ===========================================================================
.rdata:00014408
.rdata:00014408 ; Segment type: Pure data
.rdata:00014408 ; Segment permissions: Read
.rdata:00014408 _rdata          segment dword public 'DATA' use32
.rdata:00014408                 assume cs:_rdata
.rdata:00014408                 ;org 14408h
.rdata:00014408 ; COMDAT (pick largest)
.rdata:00014408                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:0001440C                 public ??_7error_category@std@@6B@
.rdata:0001440C ; const std::error_category::`vftable'
.rdata:0001440C ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:0001440C                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:0001440C                                         ; std::error_category::~error_category(void)+Ao
.rdata:0001440C                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00014410                 dd offset __purecall
.rdata:00014414                 dd offset __purecall
.rdata:00014418                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0001441C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00014420                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00014420 _rdata          ends
.rdata:00014420
.rdata:00014424 ; ===========================================================================
.rdata:00014424
.rdata:00014424 ; Segment type: Pure data
.rdata:00014424 ; Segment permissions: Read
.rdata:00014424 _rdata          segment dword public 'DATA' use32
.rdata:00014424                 assume cs:_rdata
.rdata:00014424                 ;org 14424h
.rdata:00014424 ; COMDAT (pick largest)
.rdata:00014424                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00014428                 public ??_7_Generic_error_category@std@@6B@
.rdata:00014428 ; const std::_Generic_error_category::`vftable'
.rdata:00014428 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00014428                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00014428                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:0001442C                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00014430                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00014434                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00014438                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0001443C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0001443C _rdata          ends
.rdata:0001443C
.rdata:00014440 ; ===========================================================================
.rdata:00014440
.rdata:00014440 ; Segment type: Pure data
.rdata:00014440 ; Segment permissions: Read
.rdata:00014440 _rdata          segment dword public 'DATA' use32
.rdata:00014440                 assume cs:_rdata
.rdata:00014440                 ;org 14440h
.rdata:00014440 ; COMDAT (pick any)
.rdata:00014440                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00014440 ; `string'
.rdata:00014440 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00014440                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00014440 _rdata          ends
.rdata:00014440
.rdata:00014448 ; ===========================================================================
.rdata:00014448
.rdata:00014448 ; Segment type: Pure data
.rdata:00014448 ; Segment permissions: Read
.rdata:00014448 _rdata          segment dword public 'DATA' use32
.rdata:00014448                 assume cs:_rdata
.rdata:00014448                 ;org 14448h
.rdata:00014448 ; COMDAT (pick any)
.rdata:00014448                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00014448 ; `string'
.rdata:00014448 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00014448                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_11078o
.rdata:00014448                                         ; std::_System_error_category::message(int):loc_111F4o
.rdata:00014456                 align 4
.rdata:00014456 _rdata          ends
.rdata:00014456
.rdata:00014458 ; ===========================================================================
.rdata:00014458
.rdata:00014458 ; Segment type: Pure data
.rdata:00014458 ; Segment permissions: Read
.rdata:00014458 _rdata          segment dword public 'DATA' use32
.rdata:00014458                 assume cs:_rdata
.rdata:00014458                 ;org 14458h
.rdata:00014458 ; COMDAT (pick largest)
.rdata:00014458                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:0001445C                 public ??_7_Iostream_error_category@std@@6B@
.rdata:0001445C ; const std::_Iostream_error_category::`vftable'
.rdata:0001445C ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:0001445C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:0001445C                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00014460                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00014464                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00014468                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0001446C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00014470                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00014470 _rdata          ends
.rdata:00014470
.rdata:00014474 ; ===========================================================================
.rdata:00014474
.rdata:00014474 ; Segment type: Pure data
.rdata:00014474 ; Segment permissions: Read
.rdata:00014474 _rdata          segment dword public 'DATA' use32
.rdata:00014474                 assume cs:_rdata
.rdata:00014474                 ;org 14474h
.rdata:00014474 ; COMDAT (pick any)
.rdata:00014474                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00014474 ; `string'
.rdata:00014474 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00014474                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:0001447D                 align 10h
.rdata:0001447D _rdata          ends
.rdata:0001447D
.rdata:00014480 ; ===========================================================================
.rdata:00014480
.rdata:00014480 ; Segment type: Pure data
.rdata:00014480 ; Segment permissions: Read
.rdata:00014480 _rdata          segment dword public 'DATA' use32
.rdata:00014480                 assume cs:_rdata
.rdata:00014480                 ;org 14480h
.rdata:00014480 ; COMDAT (pick any)
.rdata:00014480                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00014480 ; char `string'[]
.rdata:00014480 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00014480                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00014496                 align 4
.rdata:00014496 _rdata          ends
.rdata:00014496
.rdata:00014498 ; ===========================================================================
.rdata:00014498
.rdata:00014498 ; Segment type: Pure data
.rdata:00014498 ; Segment permissions: Read
.rdata:00014498 _rdata          segment dword public 'DATA' use32
.rdata:00014498                 assume cs:_rdata
.rdata:00014498                 ;org 14498h
.rdata:00014498 ; COMDAT (pick largest)
.rdata:00014498                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:0001449C                 public ??_7_System_error_category@std@@6B@
.rdata:0001449C ; const std::_System_error_category::`vftable'
.rdata:0001449C ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:0001449C                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:0001449C                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:000144A0                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:000144A4                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:000144A8                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:000144AC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000144B0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000144B0 _rdata          ends
.rdata:000144B0
.rdata:000144B4 ; ===========================================================================
.rdata:000144B4
.rdata:000144B4 ; Segment type: Pure data
.rdata:000144B4 ; Segment permissions: Read
.rdata:000144B4 _rdata          segment dword public 'DATA' use32
.rdata:000144B4                 assume cs:_rdata
.rdata:000144B4                 ;org 144B4h
.rdata:000144B4 ; COMDAT (pick any)
.rdata:000144B4                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:000144B4 ; `string'
.rdata:000144B4 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:000144B4                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:000144BB                 align 4
.rdata:000144BB _rdata          ends
.rdata:000144BB
.bss:000144BC ; ===========================================================================
.bss:000144BC
.bss:000144BC ; Segment type: Uninitialized
.bss:000144BC ; Segment permissions: Read/Write
.bss:000144BC _bss            segment dword public 'BSS' use32
.bss:000144BC                 assume cs:_bss
.bss:000144BC                 ;org 144BCh
.bss:000144BC ; COMDAT (pick any)
.bss:000144BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000144BC                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:000144BC ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:000144BC ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:000144BC                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:000144BC                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:000144BD                 db    ? ;
.bss:000144BE                 db    ? ;
.bss:000144BF                 db    ? ;
.bss:000144BF _bss            ends
.bss:000144BF
.bss:000144C0 ; ===========================================================================
.bss:000144C0
.bss:000144C0 ; Segment type: Uninitialized
.bss:000144C0 ; Segment permissions: Read/Write
.bss:000144C0 _bss            segment dword public 'BSS' use32
.bss:000144C0                 assume cs:_bss
.bss:000144C0                 ;org 144C0h
.bss:000144C0 ; COMDAT (pick any)
.bss:000144C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000144C0                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:000144C0 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:000144C0 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:000144C0                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000144C0                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000144C1                 db    ? ;
.bss:000144C2                 db    ? ;
.bss:000144C3                 db    ? ;
.bss:000144C3 _bss            ends
.bss:000144C3
.bss:000144C4 ; ===========================================================================
.bss:000144C4
.bss:000144C4 ; Segment type: Uninitialized
.bss:000144C4 ; Segment permissions: Read/Write
.bss:000144C4 _bss            segment dword public 'BSS' use32
.bss:000144C4                 assume cs:_bss
.bss:000144C4                 ;org 144C4h
.bss:000144C4 ; COMDAT (pick any)
.bss:000144C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000144C4                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:000144C4 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:000144C4 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:000144C4                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:000144C4                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:000144C5                 db    ? ;
.bss:000144C6                 db    ? ;
.bss:000144C7                 db    ? ;
.bss:000144C7 _bss            ends
.bss:000144C7
.rdata:000144C8 ; ===========================================================================
.rdata:000144C8
.rdata:000144C8 ; Segment type: Pure data
.rdata:000144C8 ; Segment permissions: Read
.rdata:000144C8 _rdata          segment dword public 'DATA' use32
.rdata:000144C8                 assume cs:_rdata
.rdata:000144C8                 ;org 144C8h
.rdata:000144C8 ; COMDAT (pick any)
.rdata:000144C8                 public ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
.rdata:000144C8 ; public: static unsigned int const std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::npos
.rdata:000144C8 ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB dd 0FFFFFFFFh
.rdata:000144C8                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Br
.rdata:000144C8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+7r ...
.rdata:000144C8 _rdata          ends
.rdata:000144C8
.bss:000144CC ; ===========================================================================
.bss:000144CC
.bss:000144CC ; Segment type: Uninitialized
.bss:000144CC ; Segment permissions: Read/Write
.bss:000144CC _bss            segment dword public 'BSS' use32
.bss:000144CC                 assume cs:_bss
.bss:000144CC                 ;org 144CCh
.bss:000144CC ; COMDAT (pick any)
.bss:000144CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000144CC                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:000144CC ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:000144CC ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:000144CC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:000144CD                 db    ? ;
.bss:000144CE                 db    ? ;
.bss:000144CF                 db    ? ;
.bss:000144CF _bss            ends
.bss:000144CF
.bss:000144D0 ; ===========================================================================
.bss:000144D0
.bss:000144D0 ; Segment type: Uninitialized
.bss:000144D0 ; Segment permissions: Read/Write
.bss:000144D0 _bss            segment dword public 'BSS' use32
.bss:000144D0                 assume cs:_bss
.bss:000144D0                 ;org 144D0h
.bss:000144D0 ; COMDAT (pick any)
.bss:000144D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000144D0                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:000144D0 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:000144D0 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:000144D0                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:000144D1                 db    ? ;
.bss:000144D2                 db    ? ;
.bss:000144D3                 db    ? ;
.bss:000144D3 _bss            ends
.bss:000144D3
.rdata:000144D4 ; ===========================================================================
.rdata:000144D4
.rdata:000144D4 ; Segment type: Pure data
.rdata:000144D4 ; Segment permissions: Read
.rdata:000144D4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000144D4 _rdata          segment para public 'DATA' use32
.rdata:000144D4                 assume cs:_rdata
.rdata:000144D4                 ;org 144D4h
.rdata:000144D4 ; COMDAT (pick any)
.rdata:000144D4                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:000144D4 ; wchar_t `string'
.rdata:000144D4 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:000144D4                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+5Do
.rdata:000144D4                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+8Ao ...
.rdata:000144D4                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:000144D4                 unicode 0, <clude\xstring>,0
.rdata:00014562                 align 4
.rdata:00014562 _rdata          ends
.rdata:00014562
.bss:00014564 ; ===========================================================================
.bss:00014564
.bss:00014564 ; Segment type: Uninitialized
.bss:00014564 ; Segment permissions: Read/Write
.bss:00014564 _bss            segment dword public 'BSS' use32
.bss:00014564                 assume cs:_bss
.bss:00014564                 ;org 14564h
.bss:00014564 ; COMDAT (pick any)
.bss:00014564                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00014564                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00014564 ; std::locale::id std::numpunct<char>::id
.bss:00014564 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00014564                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00014565                 db    ? ;
.bss:00014566                 db    ? ;
.bss:00014567                 db    ? ;
.bss:00014567 _bss            ends
.bss:00014567
.bss:00014568 ; ===========================================================================
.bss:00014568
.bss:00014568 ; Segment type: Uninitialized
.bss:00014568 ; Segment permissions: Read/Write
.bss:00014568 _bss            segment dword public 'BSS' use32
.bss:00014568                 assume cs:_bss
.bss:00014568                 ;org 14568h
.bss:00014568 ; COMDAT (pick any)
.bss:00014568                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00014568                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00014568 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00014568 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00014568                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00014569                 db    ? ;
.bss:0001456A                 db    ? ;
.bss:0001456B                 db    ? ;
.bss:0001456B _bss            ends
.bss:0001456B
.rdata:0001456C ; ===========================================================================
.rdata:0001456C
.rdata:0001456C ; Segment type: Pure data
.rdata:0001456C ; Segment permissions: Read
.rdata:0001456C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0001456C _rdata          segment para public 'DATA' use32
.rdata:0001456C                 assume cs:_rdata
.rdata:0001456C                 ;org 1456Ch
.rdata:0001456C ; COMDAT (pick any)
.rdata:0001456C                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0001456C ; wchar_t `string'
.rdata:0001456C ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0001456C                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::operator[](uint)+19o
.rdata:0001456C                                         ; std::vector<uint,std::allocator<uint>>::operator[](uint)+49o ...
.rdata:0001456C                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0001456C                 unicode 0, <clude\vector>,0
.rdata:0001456C _rdata          ends
.rdata:0001456C
.rdata:000145F8 ; ===========================================================================
.rdata:000145F8
.rdata:000145F8 ; Segment type: Pure data
.rdata:000145F8 ; Segment permissions: Read
.rdata:000145F8 _rdata          segment dword public 'DATA' use32
.rdata:000145F8                 assume cs:_rdata
.rdata:000145F8                 ;org 145F8h
.rdata:000145F8 ; COMDAT (pick any)
.rdata:000145F8                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:000145F8 ; wchar_t `string'
.rdata:000145F8 ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:000145F8                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::operator[](uint)+1Eo
.rdata:000145F8                                         ; std::vector<LangMenuItem,std::allocator<LangMenuItem>>::operator[](uint)+1Eo ...
.rdata:000145F8                 unicode 0, <vector subscript out of range>,0
.rdata:000145F8 _rdata          ends
.rdata:000145F8
.rdata:00014634 ; ===========================================================================
.rdata:00014634
.rdata:00014634 ; Segment type: Pure data
.rdata:00014634 ; Segment permissions: Read
.rdata:00014634 _rdata          segment dword public 'DATA' use32
.rdata:00014634                 assume cs:_rdata
.rdata:00014634                 ;org 14634h
.rdata:00014634 ; COMDAT (pick any)
.rdata:00014634                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:00014634 ; `string'
.rdata:00014634 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:00014634                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::operator[](uint)+2Bo
.rdata:00014634                                         ; std::vector<LangMenuItem,std::allocator<LangMenuItem>>::operator[](uint)+2Bo ...
.rdata:00014634 _rdata          ends
.rdata:00014634
.rdata:00014658 ; ===========================================================================
.rdata:00014658
.rdata:00014658 ; Segment type: Pure data
.rdata:00014658 ; Segment permissions: Read
.rdata:00014658 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00014658 _rdata          segment para public 'DATA' use32
.rdata:00014658                 assume cs:_rdata
.rdata:00014658                 ;org 14658h
.rdata:00014658 ; COMDAT (pick any)
.rdata:00014658                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:00014658 ; `string'
.rdata:00014658 ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:00014658                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::operator[](uint):loc_C820o
.rdata:00014658                                         ; std::vector<LangMenuItem,std::allocator<LangMenuItem>>::operator[](uint):loc_C8B0o ...
.rdata:00014658                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:000146AE                 align 10h
.rdata:000146AE _rdata          ends
.rdata:000146AE
.rdata:000146B0 ; ===========================================================================
.rdata:000146B0
.rdata:000146B0 ; Segment type: Pure data
.rdata:000146B0 ; Segment permissions: Read
.rdata:000146B0 _rdata          segment dword public 'DATA' use32
.rdata:000146B0                 assume cs:_rdata
.rdata:000146B0                 ;org 146B0h
.rdata:000146B0 ; COMDAT (pick any)
.rdata:000146B0                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:000146B0 ; `string'
.rdata:000146B0 ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:000146B0                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::operator[](uint)+3Do
.rdata:000146B0                                         ; std::vector<LangMenuItem,std::allocator<LangMenuItem>>::operator[](uint)+3Do ...
.rdata:000146B0                 unicode 0, <%s>,0
.rdata:000146B6                 align 4
.rdata:000146B6 _rdata          ends
.rdata:000146B6
.rdata:000146B8 ; ===========================================================================
.rdata:000146B8
.rdata:000146B8 ; Segment type: Pure data
.rdata:000146B8 ; Segment permissions: Read
.rdata:000146B8 _rdata          segment dword public 'DATA' use32
.rdata:000146B8                 assume cs:_rdata
.rdata:000146B8                 ;org 146B8h
.rdata:000146B8 ; COMDAT (pick any)
.rdata:000146B8                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:000146B8 ; `string'
.rdata:000146B8 ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:000146B8                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::operator[](uint)+6Fo
.rdata:000146B8                                         ; std::vector<LangMenuItem,std::allocator<LangMenuItem>>::operator[](uint)+6Fo ...
.rdata:000146B8                 unicode 0, <"out of range">,0
.rdata:000146D6                 align 4
.rdata:000146D6 _rdata          ends
.rdata:000146D6
.rdata:000146D8 ; ===========================================================================
.rdata:000146D8
.rdata:000146D8 ; Segment type: Pure data
.rdata:000146D8 ; Segment permissions: Read
.rdata:000146D8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000146D8 _rdata          segment para public 'DATA' use32
.rdata:000146D8                 assume cs:_rdata
.rdata:000146D8                 ;org 146D8h
.rdata:000146D8 ; COMDAT (pick any)
.rdata:000146D8                 public ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
.rdata:000146D8 ; wchar_t `string'
.rdata:000146D8 ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@:
.rdata:000146D8                                         ; DATA XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>)+63o
.rdata:000146D8                 unicode 0, <vector erase iterator outside range>,0
.rdata:000146D8 _rdata          ends
.rdata:000146D8
.rdata:00014720 ; ===========================================================================
.rdata:00014720
.rdata:00014720 ; Segment type: Pure data
.rdata:00014720 ; Segment permissions: Read
.rdata:00014720 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00014720 _rdata          segment para public 'DATA' use32
.rdata:00014720                 assume cs:_rdata
.rdata:00014720                 ;org 14720h
.rdata:00014720 ; COMDAT (pick any)
.rdata:00014720                 public ??_C@_1JG@ILDNFCDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAi?$AAn?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs@
.rdata:00014720 ; `string'
.rdata:00014720 ??_C@_1JG@ILDNFCDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAi?$AAn?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs@:
.rdata:00014720                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::operator[](uint)+6Ao
.rdata:00014720                 unicode 0, <std::vector>
.rdata:00014720                 dw 3Ch
.rdata:00014720                 unicode 0, <unsigned int,class std::allocator>
.rdata:00014720                 dw 3Ch
.rdata:00014720                 unicode 0, <unsigned int>
.rdata:00014720                 dw 3Eh
.rdata:00014720                 unicode 0, < >
.rdata:00014720                 dw 3Eh
.rdata:00014720                 unicode 0, <::operator []>,0
.rdata:000147B6                 align 4
.rdata:000147B6 _rdata          ends
.rdata:000147B6
.rdata:000147B8 ; ===========================================================================
.rdata:000147B8
.rdata:000147B8 ; Segment type: Pure data
.rdata:000147B8 ; Segment permissions: Read
.rdata:000147B8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000147B8 _rdata          segment para public 'DATA' use32
.rdata:000147B8                 assume cs:_rdata
.rdata:000147B8                 ;org 147B8h
.rdata:000147B8 ; COMDAT (pick any)
.rdata:000147B8                 public ??_C@_1LO@OOOAEPIG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAs?$AAe?$AAs?$AAs?$AAi?$AAo?$AAn?$AAF?$AAi?$AAl?$AAe?$AAI?$AAn@
.rdata:000147B8 ; `string'
.rdata:000147B8 ??_C@_1LO@OOOAEPIG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAs?$AAe?$AAs?$AAs?$AAi?$AAo?$AAn?$AAF?$AAi?$AAl?$AAe?$AAI?$AAn@:
.rdata:000147B8                                         ; DATA XREF: std::vector<sessionFileInfo,std::allocator<sessionFileInfo>>::operator[](uint)+6Ao
.rdata:000147B8                 unicode 0, <std::vector>
.rdata:000147B8                 dw 3Ch
.rdata:000147B8                 unicode 0, <struct sessionFileInfo,class std::allocator>
.rdata:000147B8                 dw 3Ch
.rdata:000147B8                 unicode 0, <struct sessionFileInfo>
.rdata:000147B8                 dw 3Eh
.rdata:000147B8                 unicode 0, < >
.rdata:000147B8                 dw 3Eh
.rdata:000147B8                 unicode 0, <::operator []>,0
.rdata:00014876                 align 4
.rdata:00014876 _rdata          ends
.rdata:00014876
.rdata:00014878 ; ===========================================================================
.rdata:00014878
.rdata:00014878 ; Segment type: Pure data
.rdata:00014878 ; Segment permissions: Read
.rdata:00014878 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00014878 _rdata          segment para public 'DATA' use32
.rdata:00014878                 assume cs:_rdata
.rdata:00014878                 ;org 14878h
.rdata:00014878 ; COMDAT (pick any)
.rdata:00014878                 public ??_C@_1LC@JLHHOOPB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAL?$AAa?$AAn?$AAg?$AAM?$AAe?$AAn?$AAu?$AAI?$AAt?$AAe?$AAm?$AA?0@
.rdata:00014878 ; `string'
.rdata:00014878 ??_C@_1LC@JLHHOOPB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAL?$AAa?$AAn?$AAg?$AAM?$AAe?$AAn?$AAu?$AAI?$AAt?$AAe?$AAm?$AA?0@:
.rdata:00014878                                         ; DATA XREF: std::vector<LangMenuItem,std::allocator<LangMenuItem>>::operator[](uint)+6Ao
.rdata:00014878                 unicode 0, <std::vector>
.rdata:00014878                 dw 3Ch
.rdata:00014878                 unicode 0, <struct LangMenuItem,class std::allocator>
.rdata:00014878                 dw 3Ch
.rdata:00014878                 unicode 0, <struct LangMenuItem>
.rdata:00014878                 dw 3Eh
.rdata:00014878                 unicode 0, < >
.rdata:00014878                 dw 3Eh
.rdata:00014878                 unicode 0, <::operator []>,0
.rdata:0001492A                 align 4
.rdata:0001492A _rdata          ends
.rdata:0001492A
.rdata:0001492C ; ===========================================================================
.rdata:0001492C
.rdata:0001492C ; Segment type: Pure data
.rdata:0001492C ; Segment permissions: Read
.rdata:0001492C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0001492C _rdata          segment para public 'DATA' use32
.rdata:0001492C                 assume cs:_rdata
.rdata:0001492C                 ;org 1492Ch
.rdata:0001492C ; COMDAT (pick any)
.rdata:0001492C                 public ??_C@_1BOI@OCMBMPPD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr@
.rdata:0001492C ; `string'
.rdata:0001492C ??_C@_1BOI@OCMBMPPD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr@:
.rdata:0001492C                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)+6Ao
.rdata:0001492C                 unicode 0, <std::vector>
.rdata:0001492C                 dw 3Ch
.rdata:0001492C                 unicode 0, <class std::basic_string>
.rdata:0001492C                 dw 3Ch
.rdata:0001492C                 unicode 0, <wchar_t,struct std::char_traits>
.rdata:0001492C                 dw 3Ch
.rdata:0001492C                 unicode 0, <wchar_t>
.rdata:0001492C                 dw 3Eh
.rdata:0001492C                 unicode 0, <,class std::allocator>
.rdata:0001492C                 dw 3Ch
.rdata:0001492C                 unicode 0, <wchar_t>
.rdata:0001492C                 dw 3Eh
.rdata:0001492C                 unicode 0, < >
.rdata:0001492C                 dw 3Eh
.rdata:0001492C                 unicode 0, <,class std::allocator>
.rdata:0001492C                 dw 3Ch
.rdata:0001492C                 unicode 0, <class std::basic_string>
.rdata:0001492C                 dw 3Ch
.rdata:0001492C                 unicode 0, <wchar_t,struct std::char_traits>
.rdata:0001492C                 dw 3Ch
.rdata:0001492C                 unicode 0, <wchar_t>
.rdata:0001492C                 dw 3Eh
.rdata:0001492C                 unicode 0, <,class std::allocator>
.rdata:0001492C                 dw 3Ch
.rdata:0001492C                 unicode 0, <wchar_t>
.rdata:0001492C                 dw 3Eh
.rdata:0001492C                 unicode 0, < >
.rdata:0001492C                 dw 3Eh
.rdata:0001492C                 unicode 0, < >
.rdata:0001492C                 dw 3Eh
.rdata:0001492C                 unicode 0, < >
.rdata:0001492C                 dw 3Eh
.rdata:0001492C                 unicode 0, <::operator []>,0
.rdata:0001492C _rdata          ends
.rdata:0001492C
.rdata:00014B14 ; ===========================================================================
.rdata:00014B14
.rdata:00014B14 ; Segment type: Pure data
.rdata:00014B14 ; Segment permissions: Read
.rdata:00014B14 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00014B14 _rdata          segment para public 'DATA' use32
.rdata:00014B14                 assume cs:_rdata
.rdata:00014B14                 ;org 14B14h
.rdata:00014B14 ; COMDAT (pick any)
.rdata:00014B14                 public ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
.rdata:00014B14 ; wchar_t `string'
.rdata:00014B14 ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@:
.rdata:00014B14                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+49o
.rdata:00014B14                 unicode 0, <vector iterator not dereferencable>,0
.rdata:00014B5A                 align 4
.rdata:00014B5A _rdata          ends
.rdata:00014B5A
.rdata:00014B5C ; ===========================================================================
.rdata:00014B5C
.rdata:00014B5C ; Segment type: Pure data
.rdata:00014B5C ; Segment permissions: Read
.rdata:00014B5C ; Segment alignment 'qword' can not be represented in assembly
.rdata:00014B5C _rdata          segment para public 'DATA' use32
.rdata:00014B5C                 assume cs:_rdata
.rdata:00014B5C                 ;org 14B5Ch
.rdata:00014B5C ; COMDAT (pick any)
.rdata:00014B5C                 public ??_C@_1ME@LLCFNFIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:00014B5C ; `string'
.rdata:00014B5C ??_C@_1ME@LLCFNFIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:00014B5C                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+8Fo
.rdata:00014B5C                 unicode 0, <std::_Vector_const_iterator>
.rdata:00014B5C                 dw 3Ch
.rdata:00014B5C                 unicode 0, <class std::_Vector_val>
.rdata:00014B5C                 dw 3Ch
.rdata:00014B5C                 unicode 0, <struct std::_Simple_types>
.rdata:00014B5C                 dw 3Ch
.rdata:00014B5C                 unicode 0, <int>
.rdata:00014B5C                 dw 3Eh
.rdata:00014B5C                 unicode 0, < >
.rdata:00014B5C                 dw 3Eh
.rdata:00014B5C                 unicode 0, < >
.rdata:00014B5C                 dw 3Eh
.rdata:00014B5C                 unicode 0, <::operator *>,0
.rdata:00014B5C _rdata          ends
.rdata:00014B5C
.rdata:00014C20 ; ===========================================================================
.rdata:00014C20
.rdata:00014C20 ; Segment type: Pure data
.rdata:00014C20 ; Segment permissions: Read
.rdata:00014C20 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00014C20 _rdata          segment para public 'DATA' use32
.rdata:00014C20                 assume cs:_rdata
.rdata:00014C20                 ;org 14C20h
.rdata:00014C20 ; COMDAT (pick any)
.rdata:00014C20                 public ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
.rdata:00014C20 ; wchar_t `string'
.rdata:00014C20 ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@:
.rdata:00014C20                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+36o
.rdata:00014C20                 unicode 0, <vector iterator not incrementable>,0
.rdata:00014C20 _rdata          ends
.rdata:00014C20
.rdata:00014C64 ; ===========================================================================
.rdata:00014C64
.rdata:00014C64 ; Segment type: Pure data
.rdata:00014C64 ; Segment permissions: Read
.rdata:00014C64 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00014C64 _rdata          segment para public 'DATA' use32
.rdata:00014C64                 assume cs:_rdata
.rdata:00014C64                 ;org 14C64h
.rdata:00014C64 ; COMDAT (pick any)
.rdata:00014C64                 public ??_C@_1MG@OPNGNDCB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:00014C64 ; `string'
.rdata:00014C64 ??_C@_1MG@OPNGNDCB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:00014C64                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+7Co
.rdata:00014C64                 unicode 0, <std::_Vector_const_iterator>
.rdata:00014C64                 dw 3Ch
.rdata:00014C64                 unicode 0, <class std::_Vector_val>
.rdata:00014C64                 dw 3Ch
.rdata:00014C64                 unicode 0, <struct std::_Simple_types>
.rdata:00014C64                 dw 3Ch
.rdata:00014C64                 unicode 0, <int>
.rdata:00014C64                 dw 3Eh
.rdata:00014C64                 unicode 0, < >
.rdata:00014C64                 dw 3Eh
.rdata:00014C64                 unicode 0, < >
.rdata:00014C64                 dw 3Eh
.rdata:00014C64                 unicode 0, <::operator ++>,0
.rdata:00014D2A                 align 4
.rdata:00014D2A _rdata          ends
.rdata:00014D2A
.rdata:00014D2C ; ===========================================================================
.rdata:00014D2C
.rdata:00014D2C ; Segment type: Pure data
.rdata:00014D2C ; Segment permissions: Read
.rdata:00014D2C _rdata          segment dword public 'DATA' use32
.rdata:00014D2C                 assume cs:_rdata
.rdata:00014D2C                 ;org 14D2Ch
.rdata:00014D2C ; COMDAT (pick any)
.rdata:00014D2C                 public ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
.rdata:00014D2C ; char `string'[]
.rdata:00014D2C ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ db 'invalid vector<T> subscript',0
.rdata:00014D2C                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Xran(void)+7o
.rdata:00014D2C _rdata          ends
.rdata:00014D2C
.rdata:00014D48 ; ===========================================================================
.rdata:00014D48
.rdata:00014D48 ; Segment type: Pure data
.rdata:00014D48 ; Segment permissions: Read
.rdata:00014D48 _rdata          segment dword public 'DATA' use32
.rdata:00014D48                 assume cs:_rdata
.rdata:00014D48                 ;org 14D48h
.rdata:00014D48 ; COMDAT (pick any)
.rdata:00014D48                 public ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
.rdata:00014D48 ; `string'
.rdata:00014D48 ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ db 'Standard C++ Libraries Invalid Argument',0
.rdata:00014D48                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+41o
.rdata:00014D48                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+41o
.rdata:00014D48 _rdata          ends
.rdata:00014D48
.rdata:00014D70 ; ===========================================================================
.rdata:00014D70
.rdata:00014D70 ; Segment type: Pure data
.rdata:00014D70 ; Segment permissions: Read
.rdata:00014D70 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00014D70 _rdata          segment para public 'DATA' use32
.rdata:00014D70                 assume cs:_rdata
.rdata:00014D70                 ;org 14D70h
.rdata:00014D70 ; COMDAT (pick any)
.rdata:00014D70                 public ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
.rdata:00014D70 ; `string'
.rdata:00014D70 ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@:
.rdata:00014D70                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &):loc_D5D6o
.rdata:00014D70                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &):loc_D672o
.rdata:00014D70                 unicode 0, <"Standard C++ Libraries Invalid Argument" && 0>,0
.rdata:00014DCE                 align 10h
.rdata:00014DCE _rdata          ends
.rdata:00014DCE
.rdata:00014DD0 ; ===========================================================================
.rdata:00014DD0
.rdata:00014DD0 ; Segment type: Pure data
.rdata:00014DD0 ; Segment permissions: Read
.rdata:00014DD0 _rdata          segment dword public 'DATA' use32
.rdata:00014DD0                 assume cs:_rdata
.rdata:00014DD0                 ;org 14DD0h
.rdata:00014DD0 ; COMDAT (pick any)
.rdata:00014DD0                 public ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
.rdata:00014DD0 ; `string'
.rdata:00014DD0 ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@:
.rdata:00014DD0                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+85o
.rdata:00014DD0                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+85o
.rdata:00014DD0                 unicode 0, <"invalid argument">,0
.rdata:00014DF6                 align 4
.rdata:00014DF6 _rdata          ends
.rdata:00014DF6
.rdata:00014DF8 ; ===========================================================================
.rdata:00014DF8
.rdata:00014DF8 ; Segment type: Pure data
.rdata:00014DF8 ; Segment permissions: Read
.rdata:00014DF8 _rdata          segment dword public 'DATA' use32
.rdata:00014DF8                 assume cs:_rdata
.rdata:00014DF8                 ;org 14DF8h
.rdata:00014DF8 ; COMDAT (pick any)
.rdata:00014DF8                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00014DF8 ; char `string'[]
.rdata:00014DF8 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00014DF8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00014DF8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:00014DF8 _rdata          ends
.rdata:00014DF8
.rdata:00014E08 ; ===========================================================================
.rdata:00014E08
.rdata:00014E08 ; Segment type: Pure data
.rdata:00014E08 ; Segment permissions: Read
.rdata:00014E08 _rdata          segment dword public 'DATA' use32
.rdata:00014E08                 assume cs:_rdata
.rdata:00014E08                 ;org 14E08h
.rdata:00014E08 ; COMDAT (pick any)
.rdata:00014E08                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00014E08 ; char `string'[]
.rdata:00014E08 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00014E08                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00014E08                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:00014E08 _rdata          ends
.rdata:00014E08
.rdata:00014E20 ; ===========================================================================
.rdata:00014E20
.rdata:00014E20 ; Segment type: Pure data
.rdata:00014E20 ; Segment permissions: Read
.rdata:00014E20 _rdata          segment dword public 'DATA' use32
.rdata:00014E20                 assume cs:_rdata
.rdata:00014E20                 ;org 14E20h
.rdata:00014E20 ; COMDAT (pick any)
.rdata:00014E20                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:00014E20 ; char `string'[]
.rdata:00014E20 ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:00014E20                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Xlen(void)+7o
.rdata:00014E20                                         ; std::vector<uint,std::allocator<uint>>::_Xlen(void)+7o ...
.rdata:00014E33                 align 4
.rdata:00014E33 _rdata          ends
.rdata:00014E33
.rdata:00014E34 ; ===========================================================================
.rdata:00014E34
.rdata:00014E34 ; Segment type: Pure data
.rdata:00014E34 ; Segment permissions: Read
.rdata:00014E34 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00014E34 _rdata          segment para public 'DATA' use32
.rdata:00014E34                 assume cs:_rdata
.rdata:00014E34                 ;org 14E34h
.rdata:00014E34 ; COMDAT (pick any)
.rdata:00014E34                 public ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
.rdata:00014E34 ; wchar_t `string'
.rdata:00014E34 ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@:
.rdata:00014E34                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+=(int)+52o
.rdata:00014E34                 unicode 0, <vector iterator + offset out of range>,0
.rdata:00014E34 _rdata          ends
.rdata:00014E34
.rdata:00014E80 ; ===========================================================================
.rdata:00014E80
.rdata:00014E80 ; Segment type: Pure data
.rdata:00014E80 ; Segment permissions: Read
.rdata:00014E80 _rdata          segment dword public 'DATA' use32
.rdata:00014E80                 assume cs:_rdata
.rdata:00014E80                 ;org 14E80h
.rdata:00014E80 ; COMDAT (pick any)
.rdata:00014E80                 public ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
.rdata:00014E80 ; wchar_t `string'
.rdata:00014E80 ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@:
.rdata:00014E80                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+34o
.rdata:00014E80                 unicode 0, <vector iterators incompatible>,0
.rdata:00014E80 _rdata          ends
.rdata:00014E80
.rdata:00014EBC ; ===========================================================================
.rdata:00014EBC
.rdata:00014EBC ; Segment type: Pure data
.rdata:00014EBC ; Segment permissions: Read
.rdata:00014EBC ; Segment alignment 'qword' can not be represented in assembly
.rdata:00014EBC _rdata          segment para public 'DATA' use32
.rdata:00014EBC                 assume cs:_rdata
.rdata:00014EBC                 ;org 14EBCh
.rdata:00014EBC ; COMDAT (pick any)
.rdata:00014EBC                 public ??_C@_1LO@MGELDLOO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:00014EBC ; `string'
.rdata:00014EBC ??_C@_1LO@MGELDLOO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:00014EBC                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+80o
.rdata:00014EBC                 unicode 0, <std::_Vector_const_iterator>
.rdata:00014EBC                 dw 3Ch
.rdata:00014EBC                 unicode 0, <class std::_Vector_val>
.rdata:00014EBC                 dw 3Ch
.rdata:00014EBC                 unicode 0, <struct std::_Simple_types>
.rdata:00014EBC                 dw 3Ch
.rdata:00014EBC                 unicode 0, <int>
.rdata:00014EBC                 dw 3Eh
.rdata:00014EBC                 unicode 0, < >
.rdata:00014EBC                 dw 3Eh
.rdata:00014EBC                 unicode 0, < >
.rdata:00014EBC                 dw 3Eh
.rdata:00014EBC                 unicode 0, <::_Compat>,0
.rdata:00014F7A                 align 4
.rdata:00014F7A _rdata          ends
.rdata:00014F7A
.rdata:00014F7C ; ===========================================================================
.rdata:00014F7C
.rdata:00014F7C ; Segment type: Pure data
.rdata:00014F7C ; Segment permissions: Read
.rdata:00014F7C ; Segment alignment 'qword' can not be represented in assembly
.rdata:00014F7C _rdata          segment para public 'DATA' use32
.rdata:00014F7C                 assume cs:_rdata
.rdata:00014F7C                 ;org 14F7Ch
.rdata:00014F7C ; COMDAT (pick any)
.rdata:00014F7C                 public ??_C@_1OM@OFJPGKJA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:00014F7C ; `string'
.rdata:00014F7C ??_C@_1OM@OFJPGKJA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:00014F7C                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<sessionFileInfo>>>::operator+=(int)+9Eo
.rdata:00014F7C                 unicode 0, <std::_Vector_const_iterator>
.rdata:00014F7C                 dw 3Ch
.rdata:00014F7C                 unicode 0, <class std::_Vector_val>
.rdata:00014F7C                 dw 3Ch
.rdata:00014F7C                 unicode 0, <struct std::_Simple_types>
.rdata:00014F7C                 dw 3Ch
.rdata:00014F7C                 unicode 0, <struct sessionFileInfo>
.rdata:00014F7C                 dw 3Eh
.rdata:00014F7C                 unicode 0, < >
.rdata:00014F7C                 dw 3Eh
.rdata:00014F7C                 unicode 0, < >
.rdata:00014F7C                 dw 3Eh
.rdata:00014F7C                 unicode 0, <::operator +=>,0
.rdata:00014F7C _rdata          ends
.rdata:00014F7C
.rdata:00015068 ; ===========================================================================
.rdata:00015068
.rdata:00015068 ; Segment type: Pure data
.rdata:00015068 ; Segment permissions: Read
.rdata:00015068 _rdata          segment dword public 'DATA' use32
.rdata:00015068                 assume cs:_rdata
.rdata:00015068                 ;org 15068h
.rdata:00015068 ; COMDAT (pick any)
.rdata:00015068                 public ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
.rdata:00015068 ; wchar_t `string'
.rdata:00015068 ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@:
.rdata:00015068                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+34o
.rdata:00015068                 unicode 0, <string iterators incompatible>,0
.rdata:00015068 _rdata          ends
.rdata:00015068
.rdata:000150A4 ; ===========================================================================
.rdata:000150A4
.rdata:000150A4 ; Segment type: Pure data
.rdata:000150A4 ; Segment permissions: Read
.rdata:000150A4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000150A4 _rdata          segment para public 'DATA' use32
.rdata:000150A4                 assume cs:_rdata
.rdata:000150A4                 ;org 150A4h
.rdata:000150A4 ; COMDAT (pick any)
.rdata:000150A4                 public ??_C@_1MG@CLNEOJNJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:000150A4 ; `string'
.rdata:000150A4 ??_C@_1MG@CLNEOJNJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:000150A4                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+80o
.rdata:000150A4                 unicode 0, <std::_String_const_iterator>
.rdata:000150A4                 dw 3Ch
.rdata:000150A4                 unicode 0, <class std::_String_val>
.rdata:000150A4                 dw 3Ch
.rdata:000150A4                 unicode 0, <struct std::_Simple_types>
.rdata:000150A4                 dw 3Ch
.rdata:000150A4                 unicode 0, <wchar_t>
.rdata:000150A4                 dw 3Eh
.rdata:000150A4                 unicode 0, < >
.rdata:000150A4                 dw 3Eh
.rdata:000150A4                 unicode 0, < >
.rdata:000150A4                 dw 3Eh
.rdata:000150A4                 unicode 0, <::_Compat>,0
.rdata:0001516A                 align 4
.rdata:0001516A _rdata          ends
.rdata:0001516A
.rdata:0001516C ; ===========================================================================
.rdata:0001516C
.rdata:0001516C ; Segment type: Pure data
.rdata:0001516C ; Segment permissions: Read
.rdata:0001516C _rdata          segment dword public 'DATA' use32
.rdata:0001516C                 assume cs:_rdata
.rdata:0001516C                 ;org 1516Ch
.rdata:0001516C ; COMDAT (pick any)
.rdata:0001516C                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:0001516C ; wchar_t `string'
.rdata:0001516C ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:0001516C                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:0001516C                                         ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)+11o ...
.rdata:0001516C                 unicode 0, <invalid null pointer>,0
.rdata:00015196                 align 4
.rdata:00015196 _rdata          ends
.rdata:00015196
.rdata:00015198 ; ===========================================================================
.rdata:00015198
.rdata:00015198 ; Segment type: Pure data
.rdata:00015198 ; Segment permissions: Read
.rdata:00015198 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00015198 _rdata          segment para public 'DATA' use32
.rdata:00015198                 assume cs:_rdata
.rdata:00015198                 ;org 15198h
.rdata:00015198 ; COMDAT (pick any)
.rdata:00015198                 public ??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
.rdata:00015198 ; wchar_t `string'
.rdata:00015198 ??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@:
.rdata:00015198                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+62o
.rdata:00015198                 unicode 0, <string iterator not dereferencable>,0
.rdata:000151DE                 align 10h
.rdata:000151DE _rdata          ends
.rdata:000151DE
.rdata:000151E0 ; ===========================================================================
.rdata:000151E0
.rdata:000151E0 ; Segment type: Pure data
.rdata:000151E0 ; Segment permissions: Read
.rdata:000151E0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000151E0 _rdata          segment para public 'DATA' use32
.rdata:000151E0                 assume cs:_rdata
.rdata:000151E0                 ;org 151E0h
.rdata:000151E0 ; COMDAT (pick any)
.rdata:000151E0                 public ??_C@_1MM@BFHGHMKD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:000151E0 ; `string'
.rdata:000151E0 ??_C@_1MM@BFHGHMKD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:000151E0                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+A8o
.rdata:000151E0                 unicode 0, <std::_String_const_iterator>
.rdata:000151E0                 dw 3Ch
.rdata:000151E0                 unicode 0, <class std::_String_val>
.rdata:000151E0                 dw 3Ch
.rdata:000151E0                 unicode 0, <struct std::_Simple_types>
.rdata:000151E0                 dw 3Ch
.rdata:000151E0                 unicode 0, <wchar_t>
.rdata:000151E0                 dw 3Eh
.rdata:000151E0                 unicode 0, < >
.rdata:000151E0                 dw 3Eh
.rdata:000151E0                 unicode 0, < >
.rdata:000151E0                 dw 3Eh
.rdata:000151E0                 unicode 0, <::operator *>,0
.rdata:000151E0 _rdata          ends
.rdata:000151E0
.rdata:000152AC ; ===========================================================================
.rdata:000152AC
.rdata:000152AC ; Segment type: Pure data
.rdata:000152AC ; Segment permissions: Read
.rdata:000152AC _rdata          segment dword public 'DATA' use32
.rdata:000152AC                 assume cs:_rdata
.rdata:000152AC                 ;org 152ACh
.rdata:000152AC ; COMDAT (pick any)
.rdata:000152AC                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:000152AC ; wchar_t `string'
.rdata:000152AC ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:000152AC                                         ; DATA XREF: std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:000152AC                                         ; std::_Debug_range2<uint *>(uint *,uint *,wchar_t const *,uint,std::random_access_iterator_tag)+43o ...
.rdata:000152AC                 unicode 0, <invalid iterator range>,0
.rdata:000152DA                 align 4
.rdata:000152DA _rdata          ends
.rdata:000152DA
.rdata:000152DC ; ===========================================================================
.rdata:000152DC
.rdata:000152DC ; Segment type: Pure data
.rdata:000152DC ; Segment permissions: Read
.rdata:000152DC ; Segment alignment 'qword' can not be represented in assembly
.rdata:000152DC _rdata          segment para public 'DATA' use32
.rdata:000152DC                 assume cs:_rdata
.rdata:000152DC                 ;org 152DCh
.rdata:000152DC ; COMDAT (pick any)
.rdata:000152DC                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:000152DC ; wchar_t `string'
.rdata:000152DC ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:000152DC                                         ; DATA XREF: std::_Uninit_copy<uint const,uint>(uint const *,uint const *,uint *,std::_Wrap_alloc<std::allocator<uint>> &,std::_Scalar_ptr_iterator_tag)+9o
.rdata:000152DC                                         ; std::_Uninit_copy<uint const,uint>(uint const *,uint const *,uint *,std::_Wrap_alloc<std::allocator<uint>> &,std::_Scalar_ptr_iterator_tag)+23o ...
.rdata:000152DC                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:000152DC                 unicode 0, <clude\xmemory>,0
.rdata:0001536A                 align 4
.rdata:0001536A _rdata          ends
.rdata:0001536A
.rdata$r:0001536C ; ===========================================================================
.rdata$r:0001536C
.rdata$r:0001536C ; Segment type: Pure data
.rdata$r:0001536C ; Segment permissions: Read
.rdata$r:0001536C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0001536C                 assume cs:_rdata$r
.rdata$r:0001536C                 ;org 1536Ch
.rdata$r:0001536C ; COMDAT (pick any)
.rdata$r:0001536C                 public ??_R4error_category@std@@6B@
.rdata$r:0001536C ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:0001536C ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00014408o
.rdata$r:0001536D                 db    0
.rdata$r:0001536E                 db    0
.rdata$r:0001536F                 db    0
.rdata$r:00015370                 db    0
.rdata$r:00015371                 db    0
.rdata$r:00015372                 db    0
.rdata$r:00015373                 db    0
.rdata$r:00015374                 db    0
.rdata$r:00015375                 db    0
.rdata$r:00015376                 db    0
.rdata$r:00015377                 db    0
.rdata$r:00015378                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:0001537C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0001537C _rdata$r        ends
.rdata$r:0001537C
.data$r:00015380 ; ===========================================================================
.data$r:00015380
.data$r:00015380 ; Segment type: Pure data
.data$r:00015380 ; Segment permissions: Read/Write
.data$r:00015380 _data$r         segment dword public 'DATA' use32
.data$r:00015380                 assume cs:_data$r
.data$r:00015380                 ;org 15380h
.data$r:00015380 ; COMDAT (pick any)
.data$r:00015380                 public ??_R0?AVerror_category@std@@@8
.data$r:00015380 ; class std::error_category `RTTI Type Descriptor'
.data$r:00015380 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00015380                                         ; DATA XREF: .rdata$r:00015378o
.data$r:00015380                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00015380                                         ; const type_info::`vftable'
.data$r:00015384                 align 8
.data$r:00015388 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:000153A1                 align 4
.data$r:000153A1 _data$r         ends
.data$r:000153A1
.rdata$r:000153A4 ; ===========================================================================
.rdata$r:000153A4
.rdata$r:000153A4 ; Segment type: Pure data
.rdata$r:000153A4 ; Segment permissions: Read
.rdata$r:000153A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000153A4                 assume cs:_rdata$r
.rdata$r:000153A4                 ;org 153A4h
.rdata$r:000153A4 ; COMDAT (pick any)
.rdata$r:000153A4                 public ??_R3error_category@std@@8
.rdata$r:000153A4 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000153A4 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:0001537Co
.rdata$r:000153A4                                         ; .rdata$r:000153D4o
.rdata$r:000153A5                 db    0
.rdata$r:000153A6                 db    0
.rdata$r:000153A7                 db    0
.rdata$r:000153A8                 db    0
.rdata$r:000153A9                 db    0
.rdata$r:000153AA                 db    0
.rdata$r:000153AB                 db    0
.rdata$r:000153AC                 db    1
.rdata$r:000153AD                 db    0
.rdata$r:000153AE                 db    0
.rdata$r:000153AF                 db    0
.rdata$r:000153B0                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000153B0 _rdata$r        ends
.rdata$r:000153B0
.rdata$r:000153B4 ; ===========================================================================
.rdata$r:000153B4
.rdata$r:000153B4 ; Segment type: Pure data
.rdata$r:000153B4 ; Segment permissions: Read
.rdata$r:000153B4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000153B4                 assume cs:_rdata$r
.rdata$r:000153B4                 ;org 153B4h
.rdata$r:000153B4 ; COMDAT (pick any)
.rdata$r:000153B4                 public ??_R2error_category@std@@8
.rdata$r:000153B4 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000153B4 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000153B4                                         ; DATA XREF: .rdata$r:000153B0o
.rdata$r:000153B4                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000153B8                 db    0
.rdata$r:000153B9                 align 4
.rdata$r:000153B9 _rdata$r        ends
.rdata$r:000153B9
.rdata$r:000153BC ; ===========================================================================
.rdata$r:000153BC
.rdata$r:000153BC ; Segment type: Pure data
.rdata$r:000153BC ; Segment permissions: Read
.rdata$r:000153BC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000153BC                 assume cs:_rdata$r
.rdata$r:000153BC                 ;org 153BCh
.rdata$r:000153BC ; COMDAT (pick any)
.rdata$r:000153BC                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000153BC ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000153BC ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:000153BC                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:000153BC                                         ; .rdata$r:0001542Co ...
.rdata$r:000153BC                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:000153C0                 db    0
.rdata$r:000153C1                 db    0
.rdata$r:000153C2                 db    0
.rdata$r:000153C3                 db    0
.rdata$r:000153C4                 db    0
.rdata$r:000153C5                 db    0
.rdata$r:000153C6                 db    0
.rdata$r:000153C7                 db    0
.rdata$r:000153C8                 db 0FFh
.rdata$r:000153C9                 db 0FFh
.rdata$r:000153CA                 db 0FFh
.rdata$r:000153CB                 db 0FFh
.rdata$r:000153CC                 db    0
.rdata$r:000153CD                 db    0
.rdata$r:000153CE                 db    0
.rdata$r:000153CF                 db    0
.rdata$r:000153D0                 db  40h ; @
.rdata$r:000153D1                 db    0
.rdata$r:000153D2                 db    0
.rdata$r:000153D3                 db    0
.rdata$r:000153D4                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000153D4 _rdata$r        ends
.rdata$r:000153D4
.rdata$r:000153D8 ; ===========================================================================
.rdata$r:000153D8
.rdata$r:000153D8 ; Segment type: Pure data
.rdata$r:000153D8 ; Segment permissions: Read
.rdata$r:000153D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000153D8                 assume cs:_rdata$r
.rdata$r:000153D8                 ;org 153D8h
.rdata$r:000153D8 ; COMDAT (pick any)
.rdata$r:000153D8                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:000153D8 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:000153D8 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:000153D8                                         ; DATA XREF: .rdata:00014424o
.rdata$r:000153D9                 db    0
.rdata$r:000153DA                 db    0
.rdata$r:000153DB                 db    0
.rdata$r:000153DC                 db    0
.rdata$r:000153DD                 db    0
.rdata$r:000153DE                 db    0
.rdata$r:000153DF                 db    0
.rdata$r:000153E0                 db    0
.rdata$r:000153E1                 db    0
.rdata$r:000153E2                 db    0
.rdata$r:000153E3                 db    0
.rdata$r:000153E4                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000153E8                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000153E8 _rdata$r        ends
.rdata$r:000153E8
.data$r:000153EC ; ===========================================================================
.data$r:000153EC
.data$r:000153EC ; Segment type: Pure data
.data$r:000153EC ; Segment permissions: Read/Write
.data$r:000153EC _data$r         segment dword public 'DATA' use32
.data$r:000153EC                 assume cs:_data$r
.data$r:000153EC                 ;org 153ECh
.data$r:000153EC ; COMDAT (pick any)
.data$r:000153EC                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:000153EC ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:000153EC ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000153EC                                         ; DATA XREF: .rdata$r:000153E4o
.data$r:000153EC                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000153EC                                         ; const type_info::`vftable'
.data$r:000153F0                 db    0
.data$r:000153F1                 db    0
.data$r:000153F2                 db    0
.data$r:000153F3                 db    0
.data$r:000153F4                 db  2Eh ; .
.data$r:000153F5                 db  3Fh ; ?
.data$r:000153F6                 db  41h ; A
.data$r:000153F7                 db  56h ; V
.data$r:000153F8                 db  5Fh ; _
.data$r:000153F9                 db  47h ; G
.data$r:000153FA                 db  65h ; e
.data$r:000153FB                 db  6Eh ; n
.data$r:000153FC                 db  65h ; e
.data$r:000153FD                 db  72h ; r
.data$r:000153FE                 db  69h ; i
.data$r:000153FF                 db  63h ; c
.data$r:00015400                 db  5Fh ; _
.data$r:00015401                 db  65h ; e
.data$r:00015402                 db  72h ; r
.data$r:00015403                 db  72h ; r
.data$r:00015404                 db  6Fh ; o
.data$r:00015405                 db  72h ; r
.data$r:00015406                 db  5Fh ; _
.data$r:00015407                 db  63h ; c
.data$r:00015408                 db  61h ; a
.data$r:00015409                 db  74h ; t
.data$r:0001540A                 db  65h ; e
.data$r:0001540B                 db  67h ; g
.data$r:0001540C                 db  6Fh ; o
.data$r:0001540D                 db  72h ; r
.data$r:0001540E                 db  79h ; y
.data$r:0001540F                 db  40h ; @
.data$r:00015410                 db  73h ; s
.data$r:00015411                 db  74h ; t
.data$r:00015412                 db  64h ; d
.data$r:00015413                 db  40h ; @
.data$r:00015414                 db  40h ; @
.data$r:00015415                 db    0
.data$r:00015416                 align 4
.data$r:00015416 _data$r         ends
.data$r:00015416
.rdata$r:00015418 ; ===========================================================================
.rdata$r:00015418
.rdata$r:00015418 ; Segment type: Pure data
.rdata$r:00015418 ; Segment permissions: Read
.rdata$r:00015418 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00015418                 assume cs:_rdata$r
.rdata$r:00015418                 ;org 15418h
.rdata$r:00015418 ; COMDAT (pick any)
.rdata$r:00015418                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00015418 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00015418 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00015418                                         ; DATA XREF: .rdata$r:000153E8o
.rdata$r:00015418                                         ; .rdata$r:0001544Co
.rdata$r:00015419                 db    0
.rdata$r:0001541A                 db    0
.rdata$r:0001541B                 db    0
.rdata$r:0001541C                 db    0
.rdata$r:0001541D                 db    0
.rdata$r:0001541E                 db    0
.rdata$r:0001541F                 db    0
.rdata$r:00015420                 db    2
.rdata$r:00015421                 db    0
.rdata$r:00015422                 db    0
.rdata$r:00015423                 db    0
.rdata$r:00015424                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00015424 _rdata$r        ends
.rdata$r:00015424
.rdata$r:00015428 ; ===========================================================================
.rdata$r:00015428
.rdata$r:00015428 ; Segment type: Pure data
.rdata$r:00015428 ; Segment permissions: Read
.rdata$r:00015428 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00015428                 assume cs:_rdata$r
.rdata$r:00015428                 ;org 15428h
.rdata$r:00015428 ; COMDAT (pick any)
.rdata$r:00015428                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00015428 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00015428 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00015428                                         ; DATA XREF: .rdata$r:00015424o
.rdata$r:00015428                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0001542C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00015430                 db    0
.rdata$r:00015431                 align 4
.rdata$r:00015431 _rdata$r        ends
.rdata$r:00015431
.rdata$r:00015434 ; ===========================================================================
.rdata$r:00015434
.rdata$r:00015434 ; Segment type: Pure data
.rdata$r:00015434 ; Segment permissions: Read
.rdata$r:00015434 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00015434                 assume cs:_rdata$r
.rdata$r:00015434                 ;org 15434h
.rdata$r:00015434 ; COMDAT (pick any)
.rdata$r:00015434                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00015434 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00015434 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00015434                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00015434                                         ; .rdata$r:000154A4o ...
.rdata$r:00015434                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00015438                 db    1
.rdata$r:00015439                 db    0
.rdata$r:0001543A                 db    0
.rdata$r:0001543B                 db    0
.rdata$r:0001543C                 db    0
.rdata$r:0001543D                 db    0
.rdata$r:0001543E                 db    0
.rdata$r:0001543F                 db    0
.rdata$r:00015440                 db 0FFh
.rdata$r:00015441                 db 0FFh
.rdata$r:00015442                 db 0FFh
.rdata$r:00015443                 db 0FFh
.rdata$r:00015444                 db    0
.rdata$r:00015445                 db    0
.rdata$r:00015446                 db    0
.rdata$r:00015447                 db    0
.rdata$r:00015448                 db  40h ; @
.rdata$r:00015449                 db    0
.rdata$r:0001544A                 db    0
.rdata$r:0001544B                 db    0
.rdata$r:0001544C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0001544C _rdata$r        ends
.rdata$r:0001544C
.rdata$r:00015450 ; ===========================================================================
.rdata$r:00015450
.rdata$r:00015450 ; Segment type: Pure data
.rdata$r:00015450 ; Segment permissions: Read
.rdata$r:00015450 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00015450                 assume cs:_rdata$r
.rdata$r:00015450                 ;org 15450h
.rdata$r:00015450 ; COMDAT (pick any)
.rdata$r:00015450                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00015450 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00015450 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00015450                                         ; DATA XREF: .rdata:00014458o
.rdata$r:00015451                 db    0
.rdata$r:00015452                 db    0
.rdata$r:00015453                 db    0
.rdata$r:00015454                 db    0
.rdata$r:00015455                 db    0
.rdata$r:00015456                 db    0
.rdata$r:00015457                 db    0
.rdata$r:00015458                 db    0
.rdata$r:00015459                 db    0
.rdata$r:0001545A                 db    0
.rdata$r:0001545B                 db    0
.rdata$r:0001545C                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00015460                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00015460 _rdata$r        ends
.rdata$r:00015460
.data$r:00015464 ; ===========================================================================
.data$r:00015464
.data$r:00015464 ; Segment type: Pure data
.data$r:00015464 ; Segment permissions: Read/Write
.data$r:00015464 _data$r         segment dword public 'DATA' use32
.data$r:00015464                 assume cs:_data$r
.data$r:00015464                 ;org 15464h
.data$r:00015464 ; COMDAT (pick any)
.data$r:00015464                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00015464 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00015464 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00015464                                         ; DATA XREF: .rdata$r:0001545Co
.data$r:00015464                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00015464                                         ; const type_info::`vftable'
.data$r:00015468                 db    0
.data$r:00015469                 db    0
.data$r:0001546A                 db    0
.data$r:0001546B                 db    0
.data$r:0001546C                 db  2Eh ; .
.data$r:0001546D                 db  3Fh ; ?
.data$r:0001546E                 db  41h ; A
.data$r:0001546F                 db  56h ; V
.data$r:00015470                 db  5Fh ; _
.data$r:00015471                 db  49h ; I
.data$r:00015472                 db  6Fh ; o
.data$r:00015473                 db  73h ; s
.data$r:00015474                 db  74h ; t
.data$r:00015475                 db  72h ; r
.data$r:00015476                 db  65h ; e
.data$r:00015477                 db  61h ; a
.data$r:00015478                 db  6Dh ; m
.data$r:00015479                 db  5Fh ; _
.data$r:0001547A                 db  65h ; e
.data$r:0001547B                 db  72h ; r
.data$r:0001547C                 db  72h ; r
.data$r:0001547D                 db  6Fh ; o
.data$r:0001547E                 db  72h ; r
.data$r:0001547F                 db  5Fh ; _
.data$r:00015480                 db  63h ; c
.data$r:00015481                 db  61h ; a
.data$r:00015482                 db  74h ; t
.data$r:00015483                 db  65h ; e
.data$r:00015484                 db  67h ; g
.data$r:00015485                 db  6Fh ; o
.data$r:00015486                 db  72h ; r
.data$r:00015487                 db  79h ; y
.data$r:00015488                 db  40h ; @
.data$r:00015489                 db  73h ; s
.data$r:0001548A                 db  74h ; t
.data$r:0001548B                 db  64h ; d
.data$r:0001548C                 db  40h ; @
.data$r:0001548D                 db  40h ; @
.data$r:0001548E                 db    0
.data$r:0001548F                 align 10h
.data$r:0001548F _data$r         ends
.data$r:0001548F
.rdata$r:00015490 ; ===========================================================================
.rdata$r:00015490
.rdata$r:00015490 ; Segment type: Pure data
.rdata$r:00015490 ; Segment permissions: Read
.rdata$r:00015490 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00015490                 assume cs:_rdata$r
.rdata$r:00015490                 ;org 15490h
.rdata$r:00015490 ; COMDAT (pick any)
.rdata$r:00015490                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00015490 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00015490 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00015490                                         ; DATA XREF: .rdata$r:00015460o
.rdata$r:00015490                                         ; .rdata$r:000154C8o
.rdata$r:00015491                 db    0
.rdata$r:00015492                 db    0
.rdata$r:00015493                 db    0
.rdata$r:00015494                 db    0
.rdata$r:00015495                 db    0
.rdata$r:00015496                 db    0
.rdata$r:00015497                 db    0
.rdata$r:00015498                 db    3
.rdata$r:00015499                 db    0
.rdata$r:0001549A                 db    0
.rdata$r:0001549B                 db    0
.rdata$r:0001549C                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0001549C _rdata$r        ends
.rdata$r:0001549C
.rdata$r:000154A0 ; ===========================================================================
.rdata$r:000154A0
.rdata$r:000154A0 ; Segment type: Pure data
.rdata$r:000154A0 ; Segment permissions: Read
.rdata$r:000154A0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000154A0                 assume cs:_rdata$r
.rdata$r:000154A0                 ;org 154A0h
.rdata$r:000154A0 ; COMDAT (pick any)
.rdata$r:000154A0                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:000154A0 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000154A0 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000154A0                                         ; DATA XREF: .rdata$r:0001549Co
.rdata$r:000154A0                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000154A4                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000154A8                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000154AC                 db    0
.rdata$r:000154AD                 align 10h
.rdata$r:000154AD _rdata$r        ends
.rdata$r:000154AD
.rdata$r:000154B0 ; ===========================================================================
.rdata$r:000154B0
.rdata$r:000154B0 ; Segment type: Pure data
.rdata$r:000154B0 ; Segment permissions: Read
.rdata$r:000154B0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000154B0                 assume cs:_rdata$r
.rdata$r:000154B0                 ;org 154B0h
.rdata$r:000154B0 ; COMDAT (pick any)
.rdata$r:000154B0                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000154B0 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000154B0 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:000154B0                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:000154B0                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000154B4                 db    2
.rdata$r:000154B5                 db    0
.rdata$r:000154B6                 db    0
.rdata$r:000154B7                 db    0
.rdata$r:000154B8                 db    0
.rdata$r:000154B9                 db    0
.rdata$r:000154BA                 db    0
.rdata$r:000154BB                 db    0
.rdata$r:000154BC                 db 0FFh
.rdata$r:000154BD                 db 0FFh
.rdata$r:000154BE                 db 0FFh
.rdata$r:000154BF                 db 0FFh
.rdata$r:000154C0                 db    0
.rdata$r:000154C1                 db    0
.rdata$r:000154C2                 db    0
.rdata$r:000154C3                 db    0
.rdata$r:000154C4                 db  40h ; @
.rdata$r:000154C5                 db    0
.rdata$r:000154C6                 db    0
.rdata$r:000154C7                 db    0
.rdata$r:000154C8                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000154C8 _rdata$r        ends
.rdata$r:000154C8
.rdata$r:000154CC ; ===========================================================================
.rdata$r:000154CC
.rdata$r:000154CC ; Segment type: Pure data
.rdata$r:000154CC ; Segment permissions: Read
.rdata$r:000154CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000154CC                 assume cs:_rdata$r
.rdata$r:000154CC                 ;org 154CCh
.rdata$r:000154CC ; COMDAT (pick any)
.rdata$r:000154CC                 public ??_R4_System_error_category@std@@6B@
.rdata$r:000154CC ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:000154CC ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00014498o
.rdata$r:000154CD                 db    0
.rdata$r:000154CE                 db    0
.rdata$r:000154CF                 db    0
.rdata$r:000154D0                 db    0
.rdata$r:000154D1                 db    0
.rdata$r:000154D2                 db    0
.rdata$r:000154D3                 db    0
.rdata$r:000154D4                 db    0
.rdata$r:000154D5                 db    0
.rdata$r:000154D6                 db    0
.rdata$r:000154D7                 db    0
.rdata$r:000154D8                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000154DC                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000154DC _rdata$r        ends
.rdata$r:000154DC
.data$r:000154E0 ; ===========================================================================
.data$r:000154E0
.data$r:000154E0 ; Segment type: Pure data
.data$r:000154E0 ; Segment permissions: Read/Write
.data$r:000154E0 _data$r         segment dword public 'DATA' use32
.data$r:000154E0                 assume cs:_data$r
.data$r:000154E0                 ;org 154E0h
.data$r:000154E0 ; COMDAT (pick any)
.data$r:000154E0                 public ??_R0?AV_System_error_category@std@@@8
.data$r:000154E0 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:000154E0 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000154E0                                         ; DATA XREF: .rdata$r:000154D8o
.data$r:000154E0                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000154E0                                         ; const type_info::`vftable'
.data$r:000154E4                 align 8
.data$r:000154E8 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:00015509                 align 4
.data$r:00015509 _data$r         ends
.data$r:00015509
.rdata$r:0001550C ; ===========================================================================
.rdata$r:0001550C
.rdata$r:0001550C ; Segment type: Pure data
.rdata$r:0001550C ; Segment permissions: Read
.rdata$r:0001550C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0001550C                 assume cs:_rdata$r
.rdata$r:0001550C                 ;org 1550Ch
.rdata$r:0001550C ; COMDAT (pick any)
.rdata$r:0001550C                 public ??_R3_System_error_category@std@@8
.rdata$r:0001550C ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0001550C ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:000154DCo
.rdata$r:0001550C                                         ; .rdata$r:00015544o
.rdata$r:0001550D                 db    0
.rdata$r:0001550E                 db    0
.rdata$r:0001550F                 db    0
.rdata$r:00015510                 db    0
.rdata$r:00015511                 db    0
.rdata$r:00015512                 db    0
.rdata$r:00015513                 db    0
.rdata$r:00015514                 db    3
.rdata$r:00015515                 db    0
.rdata$r:00015516                 db    0
.rdata$r:00015517                 db    0
.rdata$r:00015518                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00015518 _rdata$r        ends
.rdata$r:00015518
.rdata$r:0001551C ; ===========================================================================
.rdata$r:0001551C
.rdata$r:0001551C ; Segment type: Pure data
.rdata$r:0001551C ; Segment permissions: Read
.rdata$r:0001551C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0001551C                 assume cs:_rdata$r
.rdata$r:0001551C                 ;org 1551Ch
.rdata$r:0001551C ; COMDAT (pick any)
.rdata$r:0001551C                 public ??_R2_System_error_category@std@@8
.rdata$r:0001551C ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0001551C ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0001551C                                         ; DATA XREF: .rdata$r:00015518o
.rdata$r:0001551C                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00015520                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00015524                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00015528                 db    0
.rdata$r:00015529                 align 4
.rdata$r:00015529 _rdata$r        ends
.rdata$r:00015529
.rdata$r:0001552C ; ===========================================================================
.rdata$r:0001552C
.rdata$r:0001552C ; Segment type: Pure data
.rdata$r:0001552C ; Segment permissions: Read
.rdata$r:0001552C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0001552C                 assume cs:_rdata$r
.rdata$r:0001552C                 ;org 1552Ch
.rdata$r:0001552C ; COMDAT (pick any)
.rdata$r:0001552C                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0001552C ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0001552C ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:0001552C                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:0001552C                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00015530                 db    2
.rdata$r:00015531                 db    0
.rdata$r:00015532                 db    0
.rdata$r:00015533                 db    0
.rdata$r:00015534                 db    0
.rdata$r:00015535                 db    0
.rdata$r:00015536                 db    0
.rdata$r:00015537                 db    0
.rdata$r:00015538                 db 0FFh
.rdata$r:00015539                 db 0FFh
.rdata$r:0001553A                 db 0FFh
.rdata$r:0001553B                 db 0FFh
.rdata$r:0001553C                 db    0
.rdata$r:0001553D                 db    0
.rdata$r:0001553E                 db    0
.rdata$r:0001553F                 db    0
.rdata$r:00015540                 db  40h ; @
.rdata$r:00015541                 db    0
.rdata$r:00015542                 db    0
.rdata$r:00015543                 db    0
.rdata$r:00015544                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00015544 _rdata$r        ends
.rdata$r:00015544
.CRT$XCU:00015548 ; ===========================================================================
.CRT$XCU:00015548
.CRT$XCU:00015548 ; Segment type: Pure data
.CRT$XCU:00015548 ; Segment permissions: Read
.CRT$XCU:00015548 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00015548                 assume cs:_CRT$XCU
.CRT$XCU:00015548                 ;org 15548h
.CRT$XCU:00015548 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:0001554C _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00015550 _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:00015554 __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:00015554 _CRT$XCU        ends
.CRT$XCU:00015554
.CRT$XCU:00015558 ; ===========================================================================
.CRT$XCU:00015558
.CRT$XCU:00015558 ; Segment type: Pure data
.CRT$XCU:00015558 ; Segment permissions: Read
.CRT$XCU:00015558 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00015558                 assume cs:_CRT$XCU
.CRT$XCU:00015558                 ;org 15558h
.CRT$XCU:00015558 ; COMDAT (pick associative to section at 144BC)
.CRT$XCU:00015558 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00015558 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00015558 _CRT$XCU        ends
.CRT$XCU:00015558
.CRT$XCU:0001555C ; ===========================================================================
.CRT$XCU:0001555C
.CRT$XCU:0001555C ; Segment type: Pure data
.CRT$XCU:0001555C ; Segment permissions: Read
.CRT$XCU:0001555C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0001555C                 assume cs:_CRT$XCU
.CRT$XCU:0001555C                 ;org 1555Ch
.CRT$XCU:0001555C ; COMDAT (pick associative to section at 144C0)
.CRT$XCU:0001555C ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0001555C ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0001555C _CRT$XCU        ends
.CRT$XCU:0001555C
.CRT$XCU:00015560 ; ===========================================================================
.CRT$XCU:00015560
.CRT$XCU:00015560 ; Segment type: Pure data
.CRT$XCU:00015560 ; Segment permissions: Read
.CRT$XCU:00015560 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00015560                 assume cs:_CRT$XCU
.CRT$XCU:00015560                 ;org 15560h
.CRT$XCU:00015560 ; COMDAT (pick associative to section at 144C4)
.CRT$XCU:00015560 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00015560 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00015560 _CRT$XCU        ends
.CRT$XCU:00015560
.CRT$XCU:00015564 ; ===========================================================================
.CRT$XCU:00015564
.CRT$XCU:00015564 ; Segment type: Pure data
.CRT$XCU:00015564 ; Segment permissions: Read
.CRT$XCU:00015564 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00015564                 assume cs:_CRT$XCU
.CRT$XCU:00015564                 ;org 15564h
.CRT$XCU:00015564 ; COMDAT (pick associative to section at 144CC)
.CRT$XCU:00015564 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00015564 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00015564 _CRT$XCU        ends
.CRT$XCU:00015564
.CRT$XCU:00015568 ; ===========================================================================
.CRT$XCU:00015568
.CRT$XCU:00015568 ; Segment type: Pure data
.CRT$XCU:00015568 ; Segment permissions: Read
.CRT$XCU:00015568 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00015568                 assume cs:_CRT$XCU
.CRT$XCU:00015568                 ;org 15568h
.CRT$XCU:00015568 ; COMDAT (pick associative to section at 144D0)
.CRT$XCU:00015568 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00015568 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00015568 _CRT$XCU        ends
.CRT$XCU:00015568
.CRT$XCU:0001556C ; ===========================================================================
.CRT$XCU:0001556C
.CRT$XCU:0001556C ; Segment type: Pure data
.CRT$XCU:0001556C ; Segment permissions: Read
.CRT$XCU:0001556C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0001556C                 assume cs:_CRT$XCU
.CRT$XCU:0001556C                 ;org 1556Ch
.CRT$XCU:0001556C ; COMDAT (pick associative to section at 14564)
.CRT$XCU:0001556C ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0001556C ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0001556C _CRT$XCU        ends
.CRT$XCU:0001556C
.CRT$XCU:00015570 ; ===========================================================================
.CRT$XCU:00015570
.CRT$XCU:00015570 ; Segment type: Pure data
.CRT$XCU:00015570 ; Segment permissions: Read
.CRT$XCU:00015570 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00015570                 assume cs:_CRT$XCU
.CRT$XCU:00015570                 ;org 15570h
.CRT$XCU:00015570 ; COMDAT (pick associative to section at 14568)
.CRT$XCU:00015570 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00015570 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00015570 _CRT$XCU        ends
.CRT$XCU:00015570
UNDEF:00015580 ; ===========================================================================
UNDEF:00015580
UNDEF:00015580 ; Segment type: Externs
UNDEF:00015580 ; UNDEF
UNDEF:00015580                 extrn __purecall:near   ; DATA XREF: .rdata:00014410o
UNDEF:00015580                                         ; .rdata:00014414o
UNDEF:00015584 ; void *__cdecl operator new(unsigned int)
UNDEF:00015584                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00015584                                         ; std::_Allocate<int>(uint,int *)+23p ...
UNDEF:00015588 ; void __cdecl operator delete(void *)
UNDEF:00015588                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`scalar deleting destructor'(uint)+1Bp
UNDEF:00015588                                         ; std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0001558C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0001558C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0001558C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00015590                 extrn ___report_rangecheckfailure:near
UNDEF:00015590                                         ; CODE XREF: Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>):loc_64FCp
UNDEF:00015590                                         ; Notepad_plus::exts2Filters(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>):loc_65C8p
UNDEF:00015594                 extrn __invalid_parameter:near
UNDEF:00015594                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator[](uint)+74p
UNDEF:00015594                                         ; std::vector<LangMenuItem,std::allocator<LangMenuItem>>::operator[](uint)+74p ...
UNDEF:00015598 ; struct tm *__cdecl _localtime64(const __time64_t *Time)
UNDEF:00015598                 extrn __localtime64:near ; CODE XREF: _localtime+7p
UNDEF:0001559C ; __time64_t __cdecl _time64(__time64_t *Time)
UNDEF:0001559C                 extrn __time64:near     ; CODE XREF: _time+7p
UNDEF:000155A0 ; size_t __cdecl wcsftime(wchar_t *Buf, size_t SizeInWords, const wchar_t *Format, const struct tm *Tm)
UNDEF:000155A0                 extrn _wcsftime:near    ; CODE XREF: Notepad_plus::fileSave(Buffer *)+37Bp
UNDEF:000155A4 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:000155A4                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:000155A4                                         ; _wmemcpy+11p
UNDEF:000155A8 ; size_t __cdecl strlen(const char *Str)
UNDEF:000155A8                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:000155AC ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:000155AC                 extrn _memmove:near     ; CODE XREF: std::_Copy_impl<uint *,uint *>(uint *,uint *,uint *,std::_Scalar_ptr_iterator_tag)+1Fp
UNDEF:000155AC                                         ; std::_Uninit_copy<uint const,uint>(uint const *,uint const *,uint *,std::_Wrap_alloc<std::allocator<uint>> &,std::_Scalar_ptr_iterator_tag)+4Fp ...
UNDEF:000155B0 ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:000155B0                 extrn _wcslen:near      ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+8Ep
UNDEF:000155B0                                         ; std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:000155B4 ; wchar_t *__cdecl wcsrchr(const wchar_t *Str, wchar_t Ch)
UNDEF:000155B4                 extrn _wcsrchr:near     ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+8C7p
UNDEF:000155B4                                         ; wcsrchr(wchar_t *,wchar_t)+Cp
UNDEF:000155B8 ; int __cdecl wcsicmp(const wchar_t *Str1, const wchar_t *Str2)
UNDEF:000155B8                 extrn _wcsicmp:near     ; CODE XREF: Notepad_plus::isFileSession(wchar_t const *)+BBp
UNDEF:000155BC ; BOOL __stdcall CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
UNDEF:000155BC                 extrn __imp__CreateDirectoryW@8:near
UNDEF:000155BC                                         ; CODE XREF: Notepad_plus::fileSave(Buffer *)+310p
UNDEF:000155BC                                         ; DATA XREF: Notepad_plus::fileSave(Buffer *)+310r
UNDEF:000155C0 ; DWORD __stdcall GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
UNDEF:000155C0                 extrn __imp__GetFullPathNameW@16:near
UNDEF:000155C0                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+58p
UNDEF:000155C0                                         ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+58r
UNDEF:000155C4 ; DWORD __stdcall GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
UNDEF:000155C4                 extrn __imp__GetLongPathNameW@12:near
UNDEF:000155C4                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+C5p
UNDEF:000155C4                                         ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+C5r
UNDEF:000155C8 ; DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
UNDEF:000155C8                 extrn __imp__GetModuleFileNameW@12:near
UNDEF:000155C8                                         ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+17Cp
UNDEF:000155C8                                         ; Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+295p ...
UNDEF:000155CC ; int __stdcall lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
UNDEF:000155CC                 extrn __imp__lstrcmpW@8:near
UNDEF:000155CC                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+A41p
UNDEF:000155CC                                         ; LexerStylerArray::getLexerStylerByName(wchar_t const *)+47p
UNDEF:000155CC                                         ; DATA XREF: ...
UNDEF:000155D0 ; LPWSTR __stdcall lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
UNDEF:000155D0                 extrn __imp__lstrcpyW@8:near
UNDEF:000155D0                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+128p
UNDEF:000155D0                                         ; FileDialog::setDefFileName(wchar_t const *)+Fp
UNDEF:000155D0                                         ; DATA XREF: ...
UNDEF:000155D4 ; int __stdcall lstrlenW(LPCWSTR lpString)
UNDEF:000155D4                 extrn __imp__lstrlenW@4:near
UNDEF:000155D4                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+994p
UNDEF:000155D4                                         ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+994r
UNDEF:000155D8 ; BOOL __stdcall CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
UNDEF:000155D8                 extrn __imp__CopyFileW@12:near
UNDEF:000155D8                                         ; CODE XREF: Notepad_plus::fileSave(Buffer *)+1DEp
UNDEF:000155D8                                         ; Notepad_plus::fileSave(Buffer *)+3BBp
UNDEF:000155D8                                         ; DATA XREF: ...
UNDEF:000155DC ; int _wsprintfW(LPWSTR, LPCWSTR, ...)
UNDEF:000155DC                 extrn __imp__wsprintfW:near
UNDEF:000155DC                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+401p
UNDEF:000155DC                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+479p ...
UNDEF:000155E0 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000155E0                 extrn __imp__SendMessageW@16:near
UNDEF:000155E0                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+252p
UNDEF:000155E0                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+7F0p ...
UNDEF:000155E4 ; BOOL __stdcall PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000155E4                 extrn __imp__PostMessageW@16:near
UNDEF:000155E4                                         ; CODE XREF: Notepad_plus::saveCurrentSession(void)+1Cp
UNDEF:000155E4                                         ; DATA XREF: Notepad_plus::saveCurrentSession(void)+1Cr
UNDEF:000155E8 ; BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow)
UNDEF:000155E8                 extrn __imp__ShowWindow@8:near
UNDEF:000155E8                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+20Fp
UNDEF:000155E8                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+7ADp
UNDEF:000155E8                                         ; DATA XREF: ...
UNDEF:000155EC ; int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
UNDEF:000155EC                 extrn __imp__MessageBoxW@16:near
UNDEF:000155EC                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+427p
UNDEF:000155EC                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+49Fp ...
UNDEF:000155F0 ; HINSTANCE __stdcall ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
UNDEF:000155F0                 extrn __imp__ShellExecuteW@24:near
UNDEF:000155F0                                         ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+1C4p
UNDEF:000155F0                                         ; Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+366p ...
UNDEF:000155F4 ; BOOL __stdcall PathFileExistsW(LPCWSTR pszPath)
UNDEF:000155F4                 extrn __imp__PathFileExistsW@4:near
UNDEF:000155F4                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+D5p
UNDEF:000155F4                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+113p ...
UNDEF:000155F8 ; LPWSTR __stdcall PathFindExtensionW(LPCWSTR pszPath)
UNDEF:000155F8                 extrn __imp__PathFindExtensionW@4:near
UNDEF:000155F8                                         ; CODE XREF: Notepad_plus::isFileSession(wchar_t const *)+70p
UNDEF:000155F8                                         ; DATA XREF: Notepad_plus::isFileSession(wchar_t const *)+70r
UNDEF:000155FC ; LPWSTR __stdcall PathFindFileNameW(LPCWSTR pszPath)
UNDEF:000155FC                 extrn __imp__PathFindFileNameW@4:near
UNDEF:000155FC                                         ; CODE XREF: Notepad_plus::fileSave(Buffer *)+108p
UNDEF:000155FC                                         ; DATA XREF: Notepad_plus::fileSave(Buffer *)+108r
UNDEF:00015600 ; BOOL __stdcall PathIsDirectoryW(LPCWSTR pszPath)
UNDEF:00015600                 extrn __imp__PathIsDirectoryW@4:near
UNDEF:00015600                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+886p
UNDEF:00015600                                         ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+886r
UNDEF:00015604 ; BOOL __stdcall PathRemoveFileSpecW(LPWSTR pszPath)
UNDEF:00015604                 extrn __imp__PathRemoveFileSpecW@4:near
UNDEF:00015604                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+7FDp
UNDEF:00015604                                         ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+7FDr
UNDEF:00015608 ; void __cdecl _wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
UNDEF:00015608                 extrn __wassert:near    ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+AAp
UNDEF:0001560C ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:0001560C                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:0001560C                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:0001560C                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:00015610 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00015610                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00015610                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:00015610                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:00015614                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00015618                 extrn __CrtDbgReportW:near
UNDEF:00015618                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::operator[](uint)+50p
UNDEF:00015618                                         ; std::vector<LangMenuItem,std::allocator<LangMenuItem>>::operator[](uint)+50p ...
UNDEF:0001561C ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0001561C                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0001561C                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0001561C                                         ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)+16p ...
UNDEF:00015620 ; void __cdecl std::_Xbad_alloc()
UNDEF:00015620                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00015620                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_70D2p
UNDEF:00015620                                         ; std::_Allocate<int>(uint,int *):loc_7114p ...
UNDEF:00015624 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00015624                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00015624                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00015624                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp ...
UNDEF:00015628 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00015628                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00015628                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00015628                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp ...
UNDEF:0001562C ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0001562C                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0001562C                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00015630 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00015630                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00015630                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00015630                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00015634 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00015634                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00015634                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00015638 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00015638                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00015638                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0001563C ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0001563C                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0001563C                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00015640 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00015640                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00015640                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00015644 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl PathRemoveFileSpecW(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &)
UNDEF:00015644                 extrn ?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z:near
UNDEF:00015644                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+3BAp
UNDEF:00015644                                         ; Notepad_plus::fileSave(Buffer *)+2A2p
UNDEF:00015648 ; void __thiscall NppParameters::writeSession(NppParameters *__hidden this, const struct Session *, const wchar_t *)
UNDEF:00015648                 extrn ?writeSession@NppParameters@@QAEXABUSession@@PB_W@Z:near
UNDEF:00015648                                         ; CODE XREF: Notepad_plus::saveSession(Session const &)+14p
UNDEF:00015648                                         ; Notepad_plus::fileLoadSession(wchar_t const *)+3E5p ...
UNDEF:0001564C ; bool __thiscall NppParameters::loadSession(NppParameters *__hidden this, struct Session *, const wchar_t *)
UNDEF:0001564C                 extrn ?loadSession@NppParameters@@QAE_NAAUSession@@PB_W@Z:near
UNDEF:0001564C                                         ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+398p
UNDEF:00015650 ; void __thiscall NppParameters::safeWow64EnableWow64FsRedirection(NppParameters *__hidden this, int)
UNDEF:00015650                 extrn ?safeWow64EnableWow64FsRedirection@NppParameters@@QAEXH@Z:near
UNDEF:00015650                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+304p
UNDEF:00015650                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+4C3p ...
UNDEF:00015654 ; void __thiscall FileManager::beNotifiedOfBufferChange(FileManager *__hidden this, struct Buffer *, int)
UNDEF:00015654                 extrn ?beNotifiedOfBufferChange@FileManager@@QAEXPAVBuffer@@H@Z:near
UNDEF:00015654                                         ; CODE XREF: Buffer::doNotify(int)+1Fp
UNDEF:00015658 ; struct Buffer *__thiscall FileManager::loadFile(FileManager *__hidden this, const wchar_t *, __int32, int, const wchar_t *, __int64)
UNDEF:00015658                 extrn ?loadFile@FileManager@@QAEPAVBuffer@@PB_WJH0_J@Z:near
UNDEF:00015658                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+59Ep
UNDEF:00015658                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+658p
UNDEF:0001565C ; struct Buffer *__thiscall FileManager::newEmptyDocument(FileManager *__hidden this)
UNDEF:0001565C                 extrn ?newEmptyDocument@FileManager@@QAEPAVBuffer@@XZ:near
UNDEF:0001565C                                         ; CODE XREF: Notepad_plus::fileNew(void)+10p
UNDEF:00015660 ; struct Buffer *__thiscall FileManager::getBufferFromName(FileManager *__hidden this, const wchar_t *)
UNDEF:00015660                 extrn ?getBufferFromName@FileManager@@QAEPAVBuffer@@PB_W@Z:near
UNDEF:00015660                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+1B0p
UNDEF:00015664 ; bool __thiscall FileManager::reloadBuffer(FileManager *__hidden this, struct Buffer *)
UNDEF:00015664                 extrn ?reloadBuffer@FileManager@@QAE_NPAVBuffer@@@Z:near
UNDEF:00015664                                         ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+12Cp
UNDEF:00015668 ; bool __thiscall FileManager::reloadBufferDeferred(FileManager *__hidden this, struct Buffer *)
UNDEF:00015668                 extrn ?reloadBufferDeferred@FileManager@@QAE_NPAVBuffer@@@Z:near
UNDEF:00015668                                         ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+117p
UNDEF:0001566C ; public: bool __thiscall FileManager::saveBuffer(class Buffer *, wchar_t const *, bool, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
UNDEF:0001566C                 extrn ?saveBuffer@FileManager@@QAE_NPAVBuffer@@PB_W_NPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z:near
UNDEF:0001566C                                         ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+A5p
UNDEF:00015670 ; bool __thiscall FileManager::deleteCurrentBufferBackup(FileManager *__hidden this)
UNDEF:00015670                 extrn ?deleteCurrentBufferBackup@FileManager@@QAE_NXZ:near
UNDEF:00015670                                         ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+5Ap
UNDEF:00015674 ; bool __thiscall FileManager::deleteFile(FileManager *__hidden this, struct Buffer *)
UNDEF:00015674                 extrn ?deleteFile@FileManager@@QAE_NPAVBuffer@@@Z:near
UNDEF:00015674                                         ; CODE XREF: Notepad_plus::fileDelete(Buffer *)+CEp
UNDEF:00015678 ; bool __thiscall FileManager::moveFile(FileManager *__hidden this, struct Buffer *, const wchar_t *)
UNDEF:00015678                 extrn ?moveFile@FileManager@@QAE_NPAVBuffer@@PB_W@Z:near
UNDEF:00015678                                         ; CODE XREF: Notepad_plus::fileRename(Buffer *)+162p
UNDEF:0001567C ; bool __thiscall FileManager::createEmptyFile(FileManager *__hidden this, const wchar_t *)
UNDEF:0001567C                 extrn ?createEmptyFile@FileManager@@QAE_NPB_W@Z:near
UNDEF:0001567C                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+440p
UNDEF:00015680 ; int __thiscall FileManager::docLength(FileManager *__hidden this, struct Buffer *)
UNDEF:00015680                 extrn ?docLength@FileManager@@QBEHPAVBuffer@@@Z:near
UNDEF:00015680                                         ; CODE XREF: Buffer::docLength(void)+13p
UNDEF:00015684 ; void __thiscall __high Buffer::setLangType(enum LangType, const wchar_t *)
UNDEF:00015684                 extrn ?setLangType@Buffer@@QAEXW4LangType@@PB_W@Z:near
UNDEF:00015684                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+722p
UNDEF:00015684                                         ; Notepad_plus::loadSession(Session &,bool)+405p ...
UNDEF:00015688 ; void __thiscall Buffer::setPosition(Buffer *__hidden this, const struct Position *, struct ScintillaEditView *)
UNDEF:00015688                 extrn ?setPosition@Buffer@@QAEXABUPosition@@PAVScintillaEditView@@@Z:near
UNDEF:00015688                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+3F5p
UNDEF:00015688                                         ; Notepad_plus::loadSession(Session &,bool)+A2Dp
UNDEF:0001568C ; public: void __thiscall Buffer::setHeaderLineState(class std::vector<unsigned int, class std::allocator<unsigned int>> const &, class ScintillaEditView *)
UNDEF:0001568C                 extrn ?setHeaderLineState@Buffer@@QAEXABV?$vector@IV?$allocator@I@std@@@std@@PAVScintillaEditView@@@Z:near
UNDEF:0001568C                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+3D4p
UNDEF:0001568C                                         ; Notepad_plus::loadSession(Session &,bool)+A0Cp
UNDEF:00015690 ; public: void __thiscall ScintillaEditView::syncFoldStateWith(class std::vector<unsigned int, class std::allocator<unsigned int>> const &)
UNDEF:00015690                 extrn ?syncFoldStateWith@ScintillaEditView@@QAEXABV?$vector@IV?$allocator@I@std@@@std@@@Z:near
UNDEF:00015690                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+63Ep
UNDEF:00015690                                         ; Notepad_plus::loadSession(Session &,bool)+C8Dp
UNDEF:00015694 ; void __thiscall ScintillaEditView::saveCurrentPos(ScintillaEditView *__hidden this)
UNDEF:00015694                 extrn ?saveCurrentPos@ScintillaEditView@@QAEXXZ:near
UNDEF:00015694                                         ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+B3p
UNDEF:00015694                                         ; Notepad_plus::doReload(Buffer *,bool)+E0p
UNDEF:00015698 ; void __thiscall ScintillaEditView::restoreCurrentPos(ScintillaEditView *__hidden this)
UNDEF:00015698                 extrn ?restoreCurrentPos@ScintillaEditView@@QAEXXZ:near
UNDEF:00015698                                         ; CODE XREF: Notepad_plus::doReload(Buffer *,bool)+176p
UNDEF:00015698                                         ; Notepad_plus::doReload(Buffer *,bool)+1AAp ...
UNDEF:0001569C ; struct Buffer *__thiscall DocTabView::findBufferByName(DocTabView *__hidden this, const wchar_t *)
UNDEF:0001569C                 extrn ?findBufferByName@DocTabView@@QAEPAVBuffer@@PB_W@Z:near
UNDEF:0001569C                                         ; CODE XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+185p
UNDEF:000156A0 ; int __thiscall DocTabView::getIndexByBuffer(DocTabView *__hidden this, struct Buffer *)
UNDEF:000156A0                 extrn ?getIndexByBuffer@DocTabView@@QAEHPAVBuffer@@@Z:near
UNDEF:000156A0                                         ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+38p
UNDEF:000156A0                                         ; Notepad_plus::loadSession(Session &,bool)+84Fp
UNDEF:000156A4 ; struct Buffer *__thiscall DocTabView::getBufferByIndex(DocTabView *__hidden this, int)
UNDEF:000156A4                 extrn ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z:near
UNDEF:000156A4                                         ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+88p
UNDEF:000156A4                                         ; Notepad_plus::fileCloseAll(bool,bool)+3D7p ...
UNDEF:000156A8 ; void __thiscall LastRecentFileList::add(LastRecentFileList *__hidden this, const wchar_t *)
UNDEF:000156A8                 extrn ?add@LastRecentFileList@@QAEXPB_W@Z:near
UNDEF:000156A8                                         ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+10Fp
UNDEF:000156AC ; void __thiscall LastRecentFileList::remove(LastRecentFileList *__hidden this, const wchar_t *)
UNDEF:000156AC                 extrn ?remove@LastRecentFileList@@QAEXPB_W@Z:near
UNDEF:000156AC                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+141p
UNDEF:000156B0 ; int __thiscall trayIconControler::doTrayIcon(trayIconControler *__hidden this, unsigned __int32)
UNDEF:000156B0                 extrn ?doTrayIcon@trayIconControler@@QAEHK@Z:near
UNDEF:000156B0                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+238p
UNDEF:000156B0                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+7D6p
UNDEF:000156B4 ; void __thiscall PluginsManager::notify(PluginsManager *__hidden this, const struct SCNotification *)
UNDEF:000156B4                 extrn ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z:near
UNDEF:000156B4                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+54Fp
UNDEF:000156B4                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+62Ap ...
UNDEF:000156B8 ; int __thiscall NativeLangSpeaker::messageBox(NativeLangSpeaker *__hidden this, const char *, HWND, const wchar_t *, const wchar_t *, int, int, const wchar_t *)
UNDEF:000156B8                 extrn ?messageBox@NativeLangSpeaker@@QAEHPBDPAUHWND__@@PB_W2HH2@Z:near
UNDEF:000156B8                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+A7Dp
UNDEF:000156B8                                         ; Notepad_plus::doReload(Buffer *,bool)+3Bp ...
UNDEF:000156BC ; bool __thiscall Notepad_plus::switchToFile(Notepad_plus *__hidden this, struct Buffer *)
UNDEF:000156BC                 extrn ?switchToFile@Notepad_plus@@QAE_NPAVBuffer@@@Z:near
UNDEF:000156BC                                         ; CODE XREF: Notepad_plus::fileOpen(void)+167p
UNDEF:000156BC                                         ; Notepad_plus::fileSaveAs(Buffer *,bool)+22Ap
UNDEF:000156C0 ; void __thiscall Notepad_plus::getCurrentOpenedFiles(Notepad_plus *__hidden this, struct Session *, bool)
UNDEF:000156C0                 extrn ?getCurrentOpenedFiles@Notepad_plus@@QAEXAAUSession@@_N@Z:near
UNDEF:000156C0                                         ; CODE XREF: Notepad_plus::fileSaveSession(uint,wchar_t * *,wchar_t const *)+125p
UNDEF:000156C4 ; int __thiscall Notepad_plus::getHtmlXmlEncoding(Notepad_plus *__hidden this, const wchar_t *)
UNDEF:000156C4                 extrn ?getHtmlXmlEncoding@Notepad_plus@@QBEHPB_W@Z:near
UNDEF:000156C4                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+567p
UNDEF:000156C8 ; void __thiscall Notepad_plus::command(Notepad_plus *__hidden this, int)
UNDEF:000156C8                 extrn ?command@Notepad_plus@@AAEXH@Z:near
UNDEF:000156C8                                         ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+21Fp
UNDEF:000156CC ; void __thiscall Notepad_plus::showView(Notepad_plus *__hidden this, int)
UNDEF:000156CC                 extrn ?showView@Notepad_plus@@AAEXH@Z:near
UNDEF:000156CC                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+43p
UNDEF:000156CC                                         ; Notepad_plus::loadSession(Session &,bool)+303p ...
UNDEF:000156D0 ; bool __thiscall Notepad_plus::viewVisible(Notepad_plus *__hidden this, int)
UNDEF:000156D0                 extrn ?viewVisible@Notepad_plus@@AAE_NH@Z:near
UNDEF:000156D0                                         ; CODE XREF: Notepad_plus::fileSaveAll(void)+Ep
UNDEF:000156D0                                         ; Notepad_plus::fileSaveAll(void)+67p
UNDEF:000156D4 ; void __thiscall Notepad_plus::hideView(Notepad_plus *__hidden this, int)
UNDEF:000156D4                 extrn ?hideView@Notepad_plus@@AAEXH@Z:near
UNDEF:000156D4                                         ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+190p
UNDEF:000156D4                                         ; Notepad_plus::loadSession(Session &,bool)+944p ...
UNDEF:000156D8 ; bool __thiscall Notepad_plus::canHideView(Notepad_plus *__hidden this, int)
UNDEF:000156D8                 extrn ?canHideView@Notepad_plus@@AAE_NH@Z:near
UNDEF:000156D8                                         ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+17Dp
UNDEF:000156D8                                         ; Notepad_plus::loadSession(Session &,bool)+933p ...
UNDEF:000156DC ; int __thiscall Notepad_plus::switchEditViewTo(Notepad_plus *__hidden this, int)
UNDEF:000156DC                 extrn ?switchEditViewTo@Notepad_plus@@AAEHH@Z:near
UNDEF:000156DC                                         ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+249p
UNDEF:000156DC                                         ; Notepad_plus::fileCloseAll(bool,bool)+32Ap ...
UNDEF:000156E0 ; void __thiscall Notepad_plus::loadBufferIntoView(Notepad_plus *__hidden this, struct Buffer *, int, bool)
UNDEF:000156E0                 extrn ?loadBufferIntoView@Notepad_plus@@AAEXPAVBuffer@@H_N@Z:near
UNDEF:000156E0                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+770p
UNDEF:000156E0                                         ; Notepad_plus::fileNew(void)+2Ap ...
UNDEF:000156E4 ; bool __thiscall Notepad_plus::removeBufferFromView(Notepad_plus *__hidden this, struct Buffer *, int)
UNDEF:000156E4                 extrn ?removeBufferFromView@Notepad_plus@@AAE_NPAVBuffer@@H@Z:near
UNDEF:000156E4                                         ; CODE XREF: Notepad_plus::doClose(Buffer *,int,bool)+161p
UNDEF:000156E8 ; bool __thiscall Notepad_plus::activateBuffer(Notepad_plus *__hidden this, struct Buffer *, int)
UNDEF:000156E8                 extrn ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z:near
UNDEF:000156E8                                         ; CODE XREF: Notepad_plus::fileNew(void)+3Fp
UNDEF:000156E8                                         ; Notepad_plus::fileCloseAll(bool,bool)+221p ...
UNDEF:000156EC ; int __thiscall Notepad_plus::doSaveOrNot(Notepad_plus *__hidden this, const wchar_t *)
UNDEF:000156EC                 extrn ?doSaveOrNot@Notepad_plus@@AAEHPB_W@Z:near
UNDEF:000156EC                                         ; CODE XREF: Notepad_plus::fileClose(Buffer *,int)+77p
UNDEF:000156EC                                         ; Notepad_plus::fileCloseAll(bool,bool)+341p ...
UNDEF:000156F0 ; int __thiscall Notepad_plus::doDeleteOrNot(Notepad_plus *__hidden this, const wchar_t *)
UNDEF:000156F0                 extrn ?doDeleteOrNot@Notepad_plus@@AAEHPB_W@Z:near
UNDEF:000156F0                                         ; CODE XREF: Notepad_plus::fileDelete(Buffer *)+6Ap
UNDEF:000156F4 ; int __thiscall Notepad_plus::doActionOrNot(Notepad_plus *__hidden this, const wchar_t *, const wchar_t *, int)
UNDEF:000156F4                 extrn ?doActionOrNot@Notepad_plus@@AAEHPB_W0H@Z:near
UNDEF:000156F4                                         ; CODE XREF: Notepad_plus::fileCloseAll(bool,bool)+2A8p
UNDEF:000156F4                                         ; Notepad_plus::fileCloseAll(bool,bool)+5EBp
UNDEF:000156F8 ; void __thiscall Notepad_plus::checkDocState(Notepad_plus *__hidden this)
UNDEF:000156F8                 extrn ?checkDocState@Notepad_plus@@AAEXXZ:near
UNDEF:000156F8                                         ; CODE XREF: Notepad_plus::fileSaveAll(void)+BEp
UNDEF:000156FC ; void __thiscall Notepad_plus::checkModifiedDocument(Notepad_plus *__hidden this)
UNDEF:000156FC                 extrn ?checkModifiedDocument@Notepad_plus@@AAEXXZ:near
UNDEF:000156FC                                         ; CODE XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+258p
UNDEF:00015700 ; private: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall Notepad_plus::getLangDesc(enum  LangType, bool)
UNDEF:00015700                 extrn ?getLangDesc@Notepad_plus@@AAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LangType@@_N@Z:near
UNDEF:00015700                                         ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+233p
UNDEF:00015704 ; enum LangType __thiscall __high Notepad_plus::menuID2LangType(int)
UNDEF:00015704                 extrn ?menuID2LangType@Notepad_plus@@AAE?AW4LangType@@H@Z:near
UNDEF:00015704                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+350p
UNDEF:00015704                                         ; Notepad_plus::loadSession(Session &,bool)+988p
UNDEF:00015708 ; private: void __thiscall Notepad_plus::getMatchedFileNames(wchar_t const *, class std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> const &, class std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> &, bool, bool)
UNDEF:00015708                 extrn ?getMatchedFileNames@Notepad_plus@@AAEXPB_WABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAV23@_N3@Z:near
UNDEF:00015708                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+964p
UNDEF:00015708                                         ; Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+A10p
UNDEF:0001570C ; int __thiscall Notepad_plus::getLangFromMenuName(Notepad_plus *__hidden this, const wchar_t *)
UNDEF:0001570C                 extrn ?getLangFromMenuName@Notepad_plus@@AAEHPB_W@Z:near
UNDEF:0001570C                                         ; CODE XREF: Notepad_plus::loadSession(Session &,bool)+32Bp
UNDEF:0001570C                                         ; Notepad_plus::loadSession(Session &,bool)+96Cp
UNDEF:00015710 ; public: __thiscall FileDialog::FileDialog(struct HWND__ *, struct HINSTANCE__ *)
UNDEF:00015710                 extrn ??0FileDialog@@QAE@PAUHWND__@@PAUHINSTANCE__@@@Z:near
UNDEF:00015710                                         ; CODE XREF: Notepad_plus::fileOpen(void)+59p
UNDEF:00015710                                         ; Notepad_plus::fileSaveAs(Buffer *,bool)+98p ...
UNDEF:00015714 ; _DWORD __thiscall FileDialog::~FileDialog(FileDialog *__hidden this)
UNDEF:00015714                 extrn ??1FileDialog@@QAE@XZ:near
UNDEF:00015714                                         ; CODE XREF: Notepad_plus::fileOpen(void)+179p
UNDEF:00015714                                         ; Notepad_plus::fileSaveAs(Buffer *,bool)+1D6p ...
UNDEF:00015718 ; void FileDialog::setExtFilter(FileDialog *__hidden this, const wchar_t *, const wchar_t *, ...)
UNDEF:00015718                 extrn ?setExtFilter@FileDialog@@QAAXPB_W0ZZ:near
UNDEF:00015718                                         ; CODE XREF: Notepad_plus::fileOpen(void)+78p
UNDEF:00015718                                         ; Notepad_plus::fileSaveAs(Buffer *,bool)+B7p ...
UNDEF:0001571C ; int __thiscall FileDialog::setExtsFilter(FileDialog *__hidden this, const wchar_t *, const wchar_t *)
UNDEF:0001571C                 extrn ?setExtsFilter@FileDialog@@QAEHPB_W0@Z:near
UNDEF:0001571C                                         ; CODE XREF: Notepad_plus::setFileOpenSaveDlgFilters(FileDialog &,int)+25Dp
UNDEF:00015720 ; wchar_t *__thiscall FileDialog::doSaveDlg(FileDialog *__hidden this)
UNDEF:00015720                 extrn ?doSaveDlg@FileDialog@@QAEPA_WXZ:near
UNDEF:00015720                                         ; CODE XREF: Notepad_plus::fileSaveAs(Buffer *,bool)+146p
UNDEF:00015720                                         ; Notepad_plus::fileRename(Buffer *)+132p ...
UNDEF:00015724 ; public: class std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> * __thiscall FileDialog::doOpenMultiFilesDlg(void)
UNDEF:00015724                 extrn ?doOpenMultiFilesDlg@FileDialog@@QAEPAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@XZ:near
UNDEF:00015724                                         ; CODE XREF: Notepad_plus::fileOpen(void)+A4p
UNDEF:00015728 ; wchar_t *__thiscall FileDialog::doOpenSingleFileDlg(FileDialog *__hidden this)
UNDEF:00015728                 extrn ?doOpenSingleFileDlg@FileDialog@@QAEPA_WXZ:near
UNDEF:00015728                                         ; CODE XREF: Notepad_plus::fileLoadSession(wchar_t const *)+132p
UNDEF:0001572C ; int __thiscall VerticalFileSwitcherListView::newItem(VerticalFileSwitcherListView *__hidden this, int, int)
UNDEF:0001572C                 extrn ?newItem@VerticalFileSwitcherListView@@QAEHHH@Z:near
UNDEF:0001572C                                         ; CODE XREF: VerticalFileSwitcher::newItem(int,int)+15p
UNDEF:00015730 ; int __thiscall VerticalFileSwitcherListView::closeItem(VerticalFileSwitcherListView *__hidden this, int, int)
UNDEF:00015730                 extrn ?closeItem@VerticalFileSwitcherListView@@QAEHHH@Z:near
UNDEF:00015730                                         ; CODE XREF: VerticalFileSwitcher::closeItem(int,int)+15p
UNDEF:00015734 ; void __thiscall VerticalFileSwitcherListView::reload(VerticalFileSwitcherListView *__hidden this)
UNDEF:00015734                 extrn ?reload@VerticalFileSwitcherListView@@QAEXXZ:near
UNDEF:00015734                                         ; CODE XREF: VerticalFileSwitcher::reload(void)+27p
UNDEF:00015738 ; void __thiscall FunctionListPanel::reload(FunctionListPanel *__hidden this)
UNDEF:00015738                 extrn ?reload@FunctionListPanel@@QAEXXZ:near
UNDEF:00015738                                         ; CODE XREF: Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+4A5p
UNDEF:0001573C ; __fastcall __security_check_cookie(x)
UNDEF:0001573C                 extrn @__security_check_cookie@4:near
UNDEF:0001573C                                         ; CODE XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+C1Bp
UNDEF:0001573C                                         ; Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+4DEp ...
UNDEF:00015740 ; __stdcall _CxxThrowException(x, x)
UNDEF:00015740                 extrn __CxxThrowException@8:near
UNDEF:00015740                                         ; CODE XREF: __catch$??$_Uninit_copy@PBUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@@std@@YAPAUsessionFileInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+27p
UNDEF:00015740                                         ; __catch$??$_Uninit_move@PAUsessionFileInfo@@PAU1@V?$allocator@UsessionFileInfo@@@std@@U1@@std@@YAPAUsessionFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UsessionFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+27p ...
UNDEF:00015744                 extrn ___CxxFrameHandler3:near
UNDEF:00015744                                         ; CODE XREF: __ehhandler$?doOpen@Notepad_plus@@QAEPAVBuffer@@PB_W_N1H0_J@Z+23j
UNDEF:00015744                                         ; __ehhandler$?doSave@Notepad_plus@@QAE_NPAVBuffer@@PB_W_N@Z+23j ...
UNDEF:00015748                 extrn __chkstk:near     ; CODE XREF: Notepad_plus::fileOpen(void)+16p
UNDEF:00015748                                         ; Notepad_plus::fileSaveAs(Buffer *,bool)+16p ...
UNDEF:0001574C ; const type_info::`vftable'
UNDEF:0001574C                 extrn ??_7type_info@@6B@:near
UNDEF:0001574C                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:0001574C                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00015750 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:00015750                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:00015750                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:00015754 ; private: static class FileManager * FileManager::_pSelf
UNDEF:00015754                 extrn ?_pSelf@FileManager@@0PAV1@A:near
UNDEF:00015754                                         ; DATA XREF: FileManager::getInstance(void)+3r
UNDEF:00015758                 extrn ___security_cookie:near
UNDEF:00015758                                         ; DATA XREF: Notepad_plus::doOpen(wchar_t const *,bool,bool,int,wchar_t const *,__int64)+17r
UNDEF:00015758                                         ; Notepad_plus::doSave(Buffer *,wchar_t const *,bool)+17r ...
UNDEF:0001575C                 extrn __fltused:near
UNDEF:0001575C
UNDEF:0001575C
UNDEF:0001575C                 end