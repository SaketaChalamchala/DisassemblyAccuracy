.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 17195BD200C2AF3DF52167B0576179BE
.rdata:00000000 ; Input CRC32 : 219FB950
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\lastRecentFileList.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; wchar_t _SG124943
.rdata:00000000 $SG124943       dw 0                    ; DATA XREF: LastRecentFileList::updateMenu(void):loc_3E8o
.rdata:00000002                 db    0
.rdata:00000003                 db    0
.rdata:00000004 ; wchar_t _SG124944
.rdata:00000004 $SG124944:                              ; DATA XREF: LastRecentFileList::updateMenu(void)+134o
.rdata:00000004                 unicode 0, <Open All Recent Files>,0
.rdata:00000030 ; wchar_t _SG124962
.rdata:00000030 $SG124962       dw 0                    ; DATA XREF: LastRecentFileList::updateMenu(void):loc_40Do
.rdata:00000032                 db    0
.rdata:00000033                 db    0
.rdata:00000034 ; wchar_t _SG124963
.rdata:00000034 $SG124963:                              ; DATA XREF: LastRecentFileList::updateMenu(void)+159o
.rdata:00000034                 unicode 0, <Empty Recent Files List>,0
.rdata:00000064 $SG124881       db 'RecentFiles',0      ; DATA XREF: LastRecentFileList::updateMenu(void)+6Fo
.rdata:00000070 ; wchar_t _SG124905
.rdata:00000070 $SG124905       dw 0                    ; DATA XREF: LastRecentFileList::updateMenu(void)+D2o
.rdata:00000072                 db    0
.rdata:00000073                 db    0
.rdata:00000074 ; wchar_t _SG124906
.rdata:00000074 $SG124906:                              ; DATA XREF: LastRecentFileList::updateMenu(void)+EAo
.rdata:00000074                 unicode 0, <&Recent Files>,0
.rdata:00000090 ; wchar_t _SG124924
.rdata:00000090 $SG124924       dw 0                    ; DATA XREF: LastRecentFileList::updateMenu(void):loc_3C3o
.rdata:00000092                 db    0
.rdata:00000093                 db    0
.rdata:00000094 ; wchar_t _SG124925
.rdata:00000094 $SG124925:                              ; DATA XREF: LastRecentFileList::updateMenu(void)+10Fo
.rdata:00000094                 unicode 0, <Restore Recent Closed File>,0
.rdata:000000CA                 align 4
.rdata:000000CA _rdata          ends
.rdata:000000CA
.text$mn:000000CC ; ===========================================================================
.text$mn:000000CC
.text$mn:000000CC ; Segment type: Pure code
.text$mn:000000CC ; Segment permissions: Read/Execute
.text$mn:000000CC _text$mn        segment para public 'CODE' use32
.text$mn:000000CC                 assume cs:_text$mn
.text$mn:000000CC                 ;org 0CCh
.text$mn:000000CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000000CC
.text$mn:000000CC ; =============== S U B R O U T I N E =======================================
.text$mn:000000CC
.text$mn:000000CC ; Attributes: bp-based frame
.text$mn:000000CC
.text$mn:000000CC ; void __thiscall LastRecentFileList::initMenu(LastRecentFileList *this, HMENU, int, int, struct Accelerator *, bool)
.text$mn:000000CC                 public ?initMenu@LastRecentFileList@@QAEXPAUHMENU__@@HHPAVAccelerator@@_N@Z
.text$mn:000000CC ?initMenu@LastRecentFileList@@QAEXPAUHMENU__@@HHPAVAccelerator@@_N@Z proc near
.text$mn:000000CC
.text$mn:000000CC var_8           = dword ptr -8
.text$mn:000000CC var_4           = dword ptr -4
.text$mn:000000CC arg_0           = dword ptr  8
.text$mn:000000CC arg_4           = dword ptr  0Ch
.text$mn:000000CC arg_8           = dword ptr  10h
.text$mn:000000CC arg_C           = dword ptr  14h
.text$mn:000000CC arg_10          = byte ptr  18h
.text$mn:000000CC
.text$mn:000000CC                 push    ebp
.text$mn:000000CD                 mov     ebp, esp
.text$mn:000000CF                 sub     esp, 8
.text$mn:000000D2                 mov     [ebp+var_4], ecx
.text$mn:000000D5                 movzx   eax, [ebp+arg_10]
.text$mn:000000D9                 test    eax, eax
.text$mn:000000DB                 jz      short loc_F4
.text$mn:000000DD                 mov     ecx, [ebp+var_4]
.text$mn:000000E0                 mov     edx, [ebp+arg_0]
.text$mn:000000E3                 mov     [ecx+24h], edx
.text$mn:000000E6                 call    dword ptr ds:__imp__CreatePopupMenu@0 ; CreatePopupMenu()
.text$mn:000000EC                 mov     ecx, [ebp+var_4]
.text$mn:000000EF                 mov     [ecx+28h], eax
.text$mn:000000F2                 jmp     short loc_107
.text$mn:000000F4 ; ---------------------------------------------------------------------------
.text$mn:000000F4
.text$mn:000000F4 loc_F4:                                 ; CODE XREF: LastRecentFileList::initMenu(HMENU__ *,int,int,Accelerator *,bool)+Fj
.text$mn:000000F4                 mov     edx, [ebp+var_4]
.text$mn:000000F7                 mov     dword ptr [edx+24h], 0
.text$mn:000000FE                 mov     eax, [ebp+var_4]
.text$mn:00000101                 mov     ecx, [ebp+arg_0]
.text$mn:00000104                 mov     [eax+28h], ecx
.text$mn:00000107
.text$mn:00000107 loc_107:                                ; CODE XREF: LastRecentFileList::initMenu(HMENU__ *,int,int,Accelerator *,bool)+26j
.text$mn:00000107                 mov     edx, [ebp+var_4]
.text$mn:0000010A                 mov     eax, [ebp+arg_4]
.text$mn:0000010D                 mov     [edx+30h], eax
.text$mn:00000110                 mov     ecx, [ebp+var_4]
.text$mn:00000113                 mov     edx, [ebp+arg_8]
.text$mn:00000116                 mov     [ecx+2Ch], edx
.text$mn:00000119                 mov     eax, [ebp+var_4]
.text$mn:0000011C                 mov     ecx, [ebp+arg_C]
.text$mn:0000011F                 mov     [eax+14h], ecx
.text$mn:00000122                 mov     edx, [ebp+var_4]
.text$mn:00000125                 mov     dword ptr [edx+20h], 4E4h
.text$mn:0000012C                 mov     [ebp+var_8], 0
.text$mn:00000133                 jmp     short loc_13E
.text$mn:00000135 ; ---------------------------------------------------------------------------
.text$mn:00000135
.text$mn:00000135 loc_135:                                ; CODE XREF: LastRecentFileList::initMenu(HMENU__ *,int,int,Accelerator *,bool)+82j
.text$mn:00000135                 mov     eax, [ebp+var_8]
.text$mn:00000138                 add     eax, 1
.text$mn:0000013B                 mov     [ebp+var_8], eax
.text$mn:0000013E
.text$mn:0000013E loc_13E:                                ; CODE XREF: LastRecentFileList::initMenu(HMENU__ *,int,int,Accelerator *,bool)+67j
.text$mn:0000013E                 cmp     [ebp+var_8], 1Eh
.text$mn:00000142                 jnb     short loc_150
.text$mn:00000144                 mov     ecx, [ebp+var_4]
.text$mn:00000147                 add     ecx, [ebp+var_8]
.text$mn:0000014A                 mov     byte ptr [ecx+34h], 1
.text$mn:0000014E                 jmp     short loc_135
.text$mn:00000150 ; ---------------------------------------------------------------------------
.text$mn:00000150
.text$mn:00000150 loc_150:                                ; CODE XREF: LastRecentFileList::initMenu(HMENU__ *,int,int,Accelerator *,bool)+76j
.text$mn:00000150                 mov     esp, ebp
.text$mn:00000152                 pop     ebp
.text$mn:00000153                 retn    14h
.text$mn:00000153 ?initMenu@LastRecentFileList@@QAEXPAUHMENU__@@HHPAVAccelerator@@_N@Z endp
.text$mn:00000153
.text$mn:00000153 ; ---------------------------------------------------------------------------
.text$mn:00000156                 db 6 dup(0CCh)
.text$mn:0000015C
.text$mn:0000015C ; =============== S U B R O U T I N E =======================================
.text$mn:0000015C
.text$mn:0000015C ; Attributes: bp-based frame
.text$mn:0000015C
.text$mn:0000015C ; void __thiscall LastRecentFileList::switchMode(LastRecentFileList *__hidden this)
.text$mn:0000015C                 public ?switchMode@LastRecentFileList@@QAEXXZ
.text$mn:0000015C ?switchMode@LastRecentFileList@@QAEXXZ proc near
.text$mn:0000015C
.text$mn:0000015C var_8           = dword ptr -8
.text$mn:0000015C var_4           = dword ptr -4
.text$mn:0000015C
.text$mn:0000015C                 push    ebp
.text$mn:0000015D                 mov     ebp, esp
.text$mn:0000015F                 sub     esp, 8
.text$mn:00000162                 mov     [ebp+var_4], ecx
.text$mn:00000165                 push    0               ; uFlags
.text$mn:00000167                 push    0A03Dh          ; uPosition
.text$mn:0000016C                 mov     eax, [ebp+var_4]
.text$mn:0000016F                 mov     ecx, [eax+28h]
.text$mn:00000172                 push    ecx             ; hMenu
.text$mn:00000173                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:00000179                 push    0               ; uFlags
.text$mn:0000017B                 push    0A438h          ; uPosition
.text$mn:00000180                 mov     edx, [ebp+var_4]
.text$mn:00000183                 mov     eax, [edx+28h]
.text$mn:00000186                 push    eax             ; hMenu
.text$mn:00000187                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:0000018D                 push    0               ; uFlags
.text$mn:0000018F                 push    0A439h          ; uPosition
.text$mn:00000194                 mov     ecx, [ebp+var_4]
.text$mn:00000197                 mov     edx, [ecx+28h]
.text$mn:0000019A                 push    edx             ; hMenu
.text$mn:0000019B                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:000001A1                 mov     [ebp+var_8], 0
.text$mn:000001A8                 jmp     short loc_1B3
.text$mn:000001AA ; ---------------------------------------------------------------------------
.text$mn:000001AA
.text$mn:000001AA loc_1AA:                                ; CODE XREF: LastRecentFileList::switchMode(void)+80j
.text$mn:000001AA                 mov     eax, [ebp+var_8]
.text$mn:000001AD                 add     eax, 1
.text$mn:000001B0                 mov     [ebp+var_8], eax
.text$mn:000001B3
.text$mn:000001B3 loc_1B3:                                ; CODE XREF: LastRecentFileList::switchMode(void)+4Cj
.text$mn:000001B3                 mov     ecx, [ebp+var_4]
.text$mn:000001B6                 mov     edx, [ebp+var_8]
.text$mn:000001B9                 cmp     edx, [ecx+1Ch]
.text$mn:000001BC                 jge     short loc_1DE
.text$mn:000001BE                 push    0               ; uFlags
.text$mn:000001C0                 mov     eax, [ebp+var_8]
.text$mn:000001C3                 push    eax
.text$mn:000001C4                 mov     ecx, [ebp+var_4]
.text$mn:000001C7                 call    ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)
.text$mn:000001CC                 mov     ecx, [eax]
.text$mn:000001CE                 push    ecx             ; uPosition
.text$mn:000001CF                 mov     edx, [ebp+var_4]
.text$mn:000001D2                 mov     eax, [edx+28h]
.text$mn:000001D5                 push    eax             ; hMenu
.text$mn:000001D6                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:000001DC                 jmp     short loc_1AA
.text$mn:000001DE ; ---------------------------------------------------------------------------
.text$mn:000001DE
.text$mn:000001DE loc_1DE:                                ; CODE XREF: LastRecentFileList::switchMode(void)+60j
.text$mn:000001DE                 mov     ecx, [ebp+var_4]
.text$mn:000001E1                 cmp     dword ptr [ecx+24h], 0
.text$mn:000001E5                 jnz     short loc_258
.text$mn:000001E7                 mov     edx, [ebp+var_4]
.text$mn:000001EA                 cmp     dword ptr [edx+1Ch], 0
.text$mn:000001EE                 jle     short loc_222
.text$mn:000001F0                 push    400h            ; uFlags
.text$mn:000001F5                 mov     eax, [ebp+var_4]
.text$mn:000001F8                 mov     ecx, [eax+2Ch]
.text$mn:000001FB                 push    ecx             ; uPosition
.text$mn:000001FC                 mov     edx, [ebp+var_4]
.text$mn:000001FF                 mov     eax, [edx+28h]
.text$mn:00000202                 push    eax             ; hMenu
.text$mn:00000203                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:00000209                 push    400h            ; uFlags
.text$mn:0000020E                 mov     ecx, [ebp+var_4]
.text$mn:00000211                 mov     edx, [ecx+2Ch]
.text$mn:00000214                 push    edx             ; uPosition
.text$mn:00000215                 mov     eax, [ebp+var_4]
.text$mn:00000218                 mov     ecx, [eax+28h]
.text$mn:0000021B                 push    ecx             ; hMenu
.text$mn:0000021C                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:00000222
.text$mn:00000222 loc_222:                                ; CODE XREF: LastRecentFileList::switchMode(void)+92j
.text$mn:00000222                 mov     edx, [ebp+var_4]
.text$mn:00000225                 mov     eax, [ebp+var_4]
.text$mn:00000228                 mov     ecx, [eax+28h]
.text$mn:0000022B                 mov     [edx+24h], ecx
.text$mn:0000022E                 call    dword ptr ds:__imp__CreatePopupMenu@0 ; CreatePopupMenu()
.text$mn:00000234                 mov     edx, [ebp+var_4]
.text$mn:00000237                 mov     [edx+28h], eax
.text$mn:0000023A                 push    400h            ; uFlags
.text$mn:0000023F                 mov     eax, [ebp+var_4]
.text$mn:00000242                 mov     ecx, [eax+2Ch]
.text$mn:00000245                 add     ecx, 1
.text$mn:00000248                 push    ecx             ; uPosition
.text$mn:00000249                 mov     edx, [ebp+var_4]
.text$mn:0000024C                 mov     eax, [edx+28h]
.text$mn:0000024F                 push    eax             ; hMenu
.text$mn:00000250                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:00000256                 jmp     short loc_2B6
.text$mn:00000258 ; ---------------------------------------------------------------------------
.text$mn:00000258
.text$mn:00000258 loc_258:                                ; CODE XREF: LastRecentFileList::switchMode(void)+89j
.text$mn:00000258                 mov     ecx, [ebp+var_4]
.text$mn:0000025B                 cmp     dword ptr [ecx+1Ch], 0
.text$mn:0000025F                 jle     short loc_293
.text$mn:00000261                 push    400h            ; uFlags
.text$mn:00000266                 mov     edx, [ebp+var_4]
.text$mn:00000269                 mov     eax, [edx+2Ch]
.text$mn:0000026C                 push    eax             ; uPosition
.text$mn:0000026D                 mov     ecx, [ebp+var_4]
.text$mn:00000270                 mov     edx, [ecx+24h]
.text$mn:00000273                 push    edx             ; hMenu
.text$mn:00000274                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:0000027A                 push    400h            ; uFlags
.text$mn:0000027F                 mov     eax, [ebp+var_4]
.text$mn:00000282                 mov     ecx, [eax+2Ch]
.text$mn:00000285                 push    ecx             ; uPosition
.text$mn:00000286                 mov     edx, [ebp+var_4]
.text$mn:00000289                 mov     eax, [edx+24h]
.text$mn:0000028C                 push    eax             ; hMenu
.text$mn:0000028D                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:00000293
.text$mn:00000293 loc_293:                                ; CODE XREF: LastRecentFileList::switchMode(void)+103j
.text$mn:00000293                 mov     ecx, [ebp+var_4]
.text$mn:00000296                 mov     edx, [ecx+28h]
.text$mn:00000299                 push    edx             ; hMenu
.text$mn:0000029A                 call    dword ptr ds:__imp__DestroyMenu@4 ; DestroyMenu(x)
.text$mn:000002A0                 mov     eax, [ebp+var_4]
.text$mn:000002A3                 mov     ecx, [ebp+var_4]
.text$mn:000002A6                 mov     edx, [ecx+24h]
.text$mn:000002A9                 mov     [eax+28h], edx
.text$mn:000002AC                 mov     eax, [ebp+var_4]
.text$mn:000002AF                 mov     dword ptr [eax+24h], 0
.text$mn:000002B6
.text$mn:000002B6 loc_2B6:                                ; CODE XREF: LastRecentFileList::switchMode(void)+FAj
.text$mn:000002B6                 mov     ecx, [ebp+var_4]
.text$mn:000002B9                 mov     byte ptr [ecx+52h], 0
.text$mn:000002BD                 mov     esp, ebp
.text$mn:000002BF                 pop     ebp
.text$mn:000002C0                 retn
.text$mn:000002C0 ?switchMode@LastRecentFileList@@QAEXXZ endp
.text$mn:000002C0
.text$mn:000002C0 ; ---------------------------------------------------------------------------
.text$mn:000002C1                 db 0Bh dup(0CCh)
.text$mn:000002CC
.text$mn:000002CC ; =============== S U B R O U T I N E =======================================
.text$mn:000002CC
.text$mn:000002CC ; Attributes: bp-based frame
.text$mn:000002CC
.text$mn:000002CC ; void __thiscall LastRecentFileList::updateMenu(LastRecentFileList *__hidden this)
.text$mn:000002CC                 public ?updateMenu@LastRecentFileList@@QAEXXZ
.text$mn:000002CC ?updateMenu@LastRecentFileList@@QAEXXZ proc near
.text$mn:000002CC                                         ; CODE XREF: LastRecentFileList::add(wchar_t const *)+C6p
.text$mn:000002CC                                         ; LastRecentFileList::remove(int)+130p ...
.text$mn:000002CC
.text$mn:000002CC var_B0          = dword ptr -0B0h
.text$mn:000002CC var_AC          = dword ptr -0ACh
.text$mn:000002CC var_A8          = dword ptr -0A8h
.text$mn:000002CC var_A4          = dword ptr -0A4h
.text$mn:000002CC var_A0          = dword ptr -0A0h
.text$mn:000002CC var_9C          = byte ptr -9Ch
.text$mn:000002CC var_80          = dword ptr -80h
.text$mn:000002CC var_64          = dword ptr -64h
.text$mn:000002CC var_48          = dword ptr -48h
.text$mn:000002CC var_2C          = dword ptr -2Ch
.text$mn:000002CC var_10          = dword ptr -10h
.text$mn:000002CC var_C           = dword ptr -0Ch
.text$mn:000002CC var_4           = dword ptr -4
.text$mn:000002CC
.text$mn:000002CC                 push    ebp
.text$mn:000002CD                 mov     ebp, esp
.text$mn:000002CF                 push    0FFFFFFFFh
.text$mn:000002D1                 push    offset __ehhandler$?updateMenu@LastRecentFileList@@QAEXXZ
.text$mn:000002D6                 mov     eax, large fs:0
.text$mn:000002DC                 push    eax
.text$mn:000002DD                 sub     esp, 0A4h
.text$mn:000002E3                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000002E8                 xor     eax, ebp
.text$mn:000002EA                 mov     [ebp+var_10], eax
.text$mn:000002ED                 push    eax
.text$mn:000002EE                 lea     eax, [ebp+var_C]
.text$mn:000002F1                 mov     large fs:0, eax
.text$mn:000002F7                 mov     [ebp+var_A0], ecx
.text$mn:000002FD                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000302                 mov     [ebp+var_B0], eax
.text$mn:00000308                 mov     eax, [ebp+var_A0]
.text$mn:0000030E                 movzx   ecx, byte ptr [eax+52h]
.text$mn:00000312                 test    ecx, ecx
.text$mn:00000314                 jnz     loc_5D7
.text$mn:0000031A                 mov     edx, [ebp+var_A0]
.text$mn:00000320                 cmp     dword ptr [edx+1Ch], 0
.text$mn:00000324                 jle     loc_5D7
.text$mn:0000032A                 mov     ecx, [ebp+var_B0] ; this
.text$mn:00000330                 call    ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ ; NppParameters::getNativeLangSpeaker(void)
.text$mn:00000335                 mov     [ebp+var_AC], eax
.text$mn:0000033B                 push    offset $SG124881 ; "RecentFiles"
.text$mn:00000340                 lea     eax, [ebp+var_48]
.text$mn:00000343                 push    eax
.text$mn:00000344                 mov     ecx, [ebp+var_AC]
.text$mn:0000034A                 call    ?getSpecialMenuEntryName@NativeLangSpeaker@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PBD@Z ; NativeLangSpeaker::getSpecialMenuEntryName(char const *)
.text$mn:0000034F                 mov     [ebp+var_4], 0
.text$mn:00000356                 push    0A03Dh
.text$mn:0000035B                 lea     ecx, [ebp+var_80]
.text$mn:0000035E                 push    ecx
.text$mn:0000035F                 mov     ecx, [ebp+var_AC]
.text$mn:00000365                 call    ?getNativeLangMenuString@NativeLangSpeaker@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z ; NativeLangSpeaker::getNativeLangMenuString(int)
.text$mn:0000036A                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000036E                 push    0A438h
.text$mn:00000373                 lea     edx, [ebp+var_64]
.text$mn:00000376                 push    edx
.text$mn:00000377                 mov     ecx, [ebp+var_AC]
.text$mn:0000037D                 call    ?getNativeLangMenuString@NativeLangSpeaker@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z ; NativeLangSpeaker::getNativeLangMenuString(int)
.text$mn:00000382                 mov     byte ptr [ebp+var_4], 2
.text$mn:00000386                 push    0A439h
.text$mn:0000038B                 lea     eax, [ebp+var_2C]
.text$mn:0000038E                 push    eax
.text$mn:0000038F                 mov     ecx, [ebp+var_AC]
.text$mn:00000395                 call    ?getNativeLangMenuString@NativeLangSpeaker@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z ; NativeLangSpeaker::getNativeLangMenuString(int)
.text$mn:0000039A                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000039E                 push    offset $SG124905 ; Str
.text$mn:000003A3                 lea     ecx, [ebp+var_48]
.text$mn:000003A6                 push    ecx             ; int
.text$mn:000003A7                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:000003AC                 add     esp, 8
.text$mn:000003AF                 movzx   edx, al
.text$mn:000003B2                 test    edx, edx
.text$mn:000003B4                 jz      short loc_3C3
.text$mn:000003B6                 push    offset $SG124906 ; "&Recent Files"
.text$mn:000003BB                 lea     ecx, [ebp+var_48]
.text$mn:000003BE                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:000003C3
.text$mn:000003C3 loc_3C3:                                ; CODE XREF: LastRecentFileList::updateMenu(void)+E8j
.text$mn:000003C3                 push    offset $SG124924 ; Str
.text$mn:000003C8                 lea     eax, [ebp+var_80]
.text$mn:000003CB                 push    eax             ; int
.text$mn:000003CC                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:000003D1                 add     esp, 8
.text$mn:000003D4                 movzx   ecx, al
.text$mn:000003D7                 test    ecx, ecx
.text$mn:000003D9                 jz      short loc_3E8
.text$mn:000003DB                 push    offset $SG124925 ; "Restore Recent Closed File"
.text$mn:000003E0                 lea     ecx, [ebp+var_80]
.text$mn:000003E3                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:000003E8
.text$mn:000003E8 loc_3E8:                                ; CODE XREF: LastRecentFileList::updateMenu(void)+10Dj
.text$mn:000003E8                 push    offset $SG124943 ; Str
.text$mn:000003ED                 lea     edx, [ebp+var_64]
.text$mn:000003F0                 push    edx             ; int
.text$mn:000003F1                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:000003F6                 add     esp, 8
.text$mn:000003F9                 movzx   eax, al
.text$mn:000003FC                 test    eax, eax
.text$mn:000003FE                 jz      short loc_40D
.text$mn:00000400                 push    offset $SG124944 ; "Open All Recent Files"
.text$mn:00000405                 lea     ecx, [ebp+var_64]
.text$mn:00000408                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:0000040D
.text$mn:0000040D loc_40D:                                ; CODE XREF: LastRecentFileList::updateMenu(void)+132j
.text$mn:0000040D                 push    offset $SG124962 ; Str
.text$mn:00000412                 lea     ecx, [ebp+var_2C]
.text$mn:00000415                 push    ecx             ; int
.text$mn:00000416                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:0000041B                 add     esp, 8
.text$mn:0000041E                 movzx   edx, al
.text$mn:00000421                 test    edx, edx
.text$mn:00000423                 jz      short loc_432
.text$mn:00000425                 push    offset $SG124963 ; "Empty Recent Files List"
.text$mn:0000042A                 lea     ecx, [ebp+var_2C]
.text$mn:0000042D                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:00000432
.text$mn:00000432 loc_432:                                ; CODE XREF: LastRecentFileList::updateMenu(void)+157j
.text$mn:00000432                 mov     ecx, [ebp+var_A0] ; this
.text$mn:00000438                 call    ?isSubMenuMode@LastRecentFileList@@QBE_NXZ ; LastRecentFileList::isSubMenuMode(void)
.text$mn:0000043D                 movzx   eax, al
.text$mn:00000440                 test    eax, eax
.text$mn:00000442                 jnz     short loc_467
.text$mn:00000444                 push    0               ; lpNewItem
.text$mn:00000446                 push    0FFFFFFFFh      ; uIDNewItem
.text$mn:00000448                 push    400h            ; uFlags
.text$mn:0000044D                 mov     ecx, [ebp+var_A0]
.text$mn:00000453                 mov     edx, [ecx+2Ch]
.text$mn:00000456                 push    edx             ; uPosition
.text$mn:00000457                 mov     eax, [ebp+var_A0]
.text$mn:0000045D                 mov     ecx, [eax+28h]
.text$mn:00000460                 push    ecx             ; hMenu
.text$mn:00000461                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:00000467
.text$mn:00000467 loc_467:                                ; CODE XREF: LastRecentFileList::updateMenu(void)+176j
.text$mn:00000467                 lea     ecx, [ebp+var_80]
.text$mn:0000046A                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000046F                 push    eax             ; lpNewItem
.text$mn:00000470                 push    0A03Dh          ; uIDNewItem
.text$mn:00000475                 push    400h            ; uFlags
.text$mn:0000047A                 mov     edx, [ebp+var_A0]
.text$mn:00000480                 mov     eax, [edx+2Ch]
.text$mn:00000483                 add     eax, 1
.text$mn:00000486                 push    eax             ; uPosition
.text$mn:00000487                 mov     ecx, [ebp+var_A0]
.text$mn:0000048D                 mov     edx, [ecx+28h]
.text$mn:00000490                 push    edx             ; hMenu
.text$mn:00000491                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:00000497                 lea     ecx, [ebp+var_64]
.text$mn:0000049A                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000049F                 push    eax             ; lpNewItem
.text$mn:000004A0                 push    0A438h          ; uIDNewItem
.text$mn:000004A5                 push    400h            ; uFlags
.text$mn:000004AA                 mov     eax, [ebp+var_A0]
.text$mn:000004B0                 mov     ecx, [eax+2Ch]
.text$mn:000004B3                 add     ecx, 2
.text$mn:000004B6                 push    ecx             ; uPosition
.text$mn:000004B7                 mov     edx, [ebp+var_A0]
.text$mn:000004BD                 mov     eax, [edx+28h]
.text$mn:000004C0                 push    eax             ; hMenu
.text$mn:000004C1                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:000004C7                 lea     ecx, [ebp+var_2C]
.text$mn:000004CA                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000004CF                 push    eax             ; lpNewItem
.text$mn:000004D0                 push    0A439h          ; uIDNewItem
.text$mn:000004D5                 push    400h            ; uFlags
.text$mn:000004DA                 mov     ecx, [ebp+var_A0]
.text$mn:000004E0                 mov     edx, [ecx+2Ch]
.text$mn:000004E3                 add     edx, 3
.text$mn:000004E6                 push    edx             ; uPosition
.text$mn:000004E7                 mov     eax, [ebp+var_A0]
.text$mn:000004ED                 mov     ecx, [eax+28h]
.text$mn:000004F0                 push    ecx             ; hMenu
.text$mn:000004F1                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:000004F7                 push    0               ; lpNewItem
.text$mn:000004F9                 push    0FFFFFFFFh      ; uIDNewItem
.text$mn:000004FB                 push    400h            ; uFlags
.text$mn:00000500                 mov     edx, [ebp+var_A0]
.text$mn:00000506                 mov     eax, [edx+2Ch]
.text$mn:00000509                 add     eax, 4
.text$mn:0000050C                 push    eax             ; uPosition
.text$mn:0000050D                 mov     ecx, [ebp+var_A0]
.text$mn:00000513                 mov     edx, [ecx+28h]
.text$mn:00000516                 push    edx             ; hMenu
.text$mn:00000517                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:0000051D                 mov     eax, [ebp+var_A0]
.text$mn:00000523                 mov     byte ptr [eax+52h], 1
.text$mn:00000527                 mov     ecx, [ebp+var_A0] ; this
.text$mn:0000052D                 call    ?isSubMenuMode@LastRecentFileList@@QBE_NXZ ; LastRecentFileList::isSubMenuMode(void)
.text$mn:00000532                 movzx   ecx, al
.text$mn:00000535                 test    ecx, ecx
.text$mn:00000537                 jz      short loc_591
.text$mn:00000539                 lea     ecx, [ebp+var_48]
.text$mn:0000053C                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000541                 push    eax             ; lpNewItem
.text$mn:00000542                 mov     edx, [ebp+var_A0]
.text$mn:00000548                 mov     eax, [edx+28h]
.text$mn:0000054B                 push    eax             ; uIDNewItem
.text$mn:0000054C                 push    410h            ; uFlags
.text$mn:00000551                 mov     ecx, [ebp+var_A0]
.text$mn:00000557                 mov     edx, [ecx+2Ch]
.text$mn:0000055A                 push    edx             ; uPosition
.text$mn:0000055B                 mov     eax, [ebp+var_A0]
.text$mn:00000561                 mov     ecx, [eax+24h]
.text$mn:00000564                 push    ecx             ; hMenu
.text$mn:00000565                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:0000056B                 push    0               ; lpNewItem
.text$mn:0000056D                 push    0FFFFFFFFh      ; uIDNewItem
.text$mn:0000056F                 push    400h            ; uFlags
.text$mn:00000574                 mov     edx, [ebp+var_A0]
.text$mn:0000057A                 mov     eax, [edx+2Ch]
.text$mn:0000057D                 add     eax, 1
.text$mn:00000580                 push    eax             ; uPosition
.text$mn:00000581                 mov     ecx, [ebp+var_A0]
.text$mn:00000587                 mov     edx, [ecx+24h]
.text$mn:0000058A                 push    edx             ; hMenu
.text$mn:0000058B                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:00000591
.text$mn:00000591 loc_591:                                ; CODE XREF: LastRecentFileList::updateMenu(void)+26Bj
.text$mn:00000591                 mov     eax, [ebp+var_A0]
.text$mn:00000597                 mov     ecx, [eax+14h]  ; this
.text$mn:0000059A                 call    ?updateFullMenu@Accelerator@@QAEXXZ ; Accelerator::updateFullMenu(void)
.text$mn:0000059F                 mov     byte ptr [ebp+var_4], 2
.text$mn:000005A3                 lea     ecx, [ebp+var_2C]
.text$mn:000005A6                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000005AB                 mov     byte ptr [ebp+var_4], 1
.text$mn:000005AF                 lea     ecx, [ebp+var_64]
.text$mn:000005B2                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000005B7                 mov     byte ptr [ebp+var_4], 0
.text$mn:000005BB                 lea     ecx, [ebp+var_80]
.text$mn:000005BE                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000005C3                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000005CA                 lea     ecx, [ebp+var_48]
.text$mn:000005CD                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000005D2                 jmp     loc_6F3
.text$mn:000005D7 ; ---------------------------------------------------------------------------
.text$mn:000005D7
.text$mn:000005D7 loc_5D7:                                ; CODE XREF: LastRecentFileList::updateMenu(void)+48j
.text$mn:000005D7                                         ; LastRecentFileList::updateMenu(void)+58j
.text$mn:000005D7                 mov     ecx, [ebp+var_A0]
.text$mn:000005DD                 movzx   edx, byte ptr [ecx+52h]
.text$mn:000005E1                 test    edx, edx
.text$mn:000005E3                 jz      loc_6F3
.text$mn:000005E9                 mov     eax, [ebp+var_A0]
.text$mn:000005EF                 cmp     dword ptr [eax+1Ch], 0
.text$mn:000005F3                 jnz     loc_6F3
.text$mn:000005F9                 push    400h            ; uFlags
.text$mn:000005FE                 mov     ecx, [ebp+var_A0]
.text$mn:00000604                 mov     edx, [ecx+2Ch]
.text$mn:00000607                 add     edx, 4
.text$mn:0000060A                 push    edx             ; uPosition
.text$mn:0000060B                 mov     eax, [ebp+var_A0]
.text$mn:00000611                 mov     ecx, [eax+28h]
.text$mn:00000614                 push    ecx             ; hMenu
.text$mn:00000615                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:0000061B                 push    0               ; uFlags
.text$mn:0000061D                 push    0A439h          ; uPosition
.text$mn:00000622                 mov     edx, [ebp+var_A0]
.text$mn:00000628                 mov     eax, [edx+28h]
.text$mn:0000062B                 push    eax             ; hMenu
.text$mn:0000062C                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:00000632                 push    0               ; uFlags
.text$mn:00000634                 push    0A438h          ; uPosition
.text$mn:00000639                 mov     ecx, [ebp+var_A0]
.text$mn:0000063F                 mov     edx, [ecx+28h]
.text$mn:00000642                 push    edx             ; hMenu
.text$mn:00000643                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:00000649                 push    0               ; uFlags
.text$mn:0000064B                 push    0A03Dh          ; uPosition
.text$mn:00000650                 mov     eax, [ebp+var_A0]
.text$mn:00000656                 mov     ecx, [eax+28h]
.text$mn:00000659                 push    ecx             ; hMenu
.text$mn:0000065A                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:00000660                 push    400h            ; uFlags
.text$mn:00000665                 mov     edx, [ebp+var_A0]
.text$mn:0000066B                 mov     eax, [edx+2Ch]
.text$mn:0000066E                 push    eax             ; uPosition
.text$mn:0000066F                 mov     ecx, [ebp+var_A0]
.text$mn:00000675                 mov     edx, [ecx+28h]
.text$mn:00000678                 push    edx             ; hMenu
.text$mn:00000679                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:0000067F                 mov     eax, [ebp+var_A0]
.text$mn:00000685                 mov     byte ptr [eax+52h], 0
.text$mn:00000689                 mov     ecx, [ebp+var_A0] ; this
.text$mn:0000068F                 call    ?isSubMenuMode@LastRecentFileList@@QBE_NXZ ; LastRecentFileList::isSubMenuMode(void)
.text$mn:00000694                 movzx   ecx, al
.text$mn:00000697                 test    ecx, ecx
.text$mn:00000699                 jz      short loc_6F3
.text$mn:0000069B                 push    400h            ; uFlags
.text$mn:000006A0                 mov     edx, [ebp+var_A0]
.text$mn:000006A6                 mov     eax, [edx+2Ch]
.text$mn:000006A9                 add     eax, 1
.text$mn:000006AC                 push    eax             ; uPosition
.text$mn:000006AD                 mov     ecx, [ebp+var_A0]
.text$mn:000006B3                 mov     edx, [ecx+24h]
.text$mn:000006B6                 push    edx             ; hMenu
.text$mn:000006B7                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:000006BD                 push    400h            ; uFlags
.text$mn:000006C2                 mov     eax, [ebp+var_A0]
.text$mn:000006C8                 mov     ecx, [eax+2Ch]
.text$mn:000006CB                 push    ecx             ; uPosition
.text$mn:000006CC                 mov     edx, [ebp+var_A0]
.text$mn:000006D2                 mov     eax, [edx+24h]
.text$mn:000006D5                 push    eax             ; hMenu
.text$mn:000006D6                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:000006DC                 push    400h            ; uFlags
.text$mn:000006E1                 push    0               ; uPosition
.text$mn:000006E3                 mov     ecx, [ebp+var_A0]
.text$mn:000006E9                 mov     edx, [ecx+28h]
.text$mn:000006EC                 push    edx             ; hMenu
.text$mn:000006ED                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:000006F3
.text$mn:000006F3 loc_6F3:                                ; CODE XREF: LastRecentFileList::updateMenu(void)+306j
.text$mn:000006F3                                         ; LastRecentFileList::updateMenu(void)+317j ...
.text$mn:000006F3                 mov     [ebp+var_A8], 0
.text$mn:000006FD                 jmp     short loc_70E
.text$mn:000006FF ; ---------------------------------------------------------------------------
.text$mn:000006FF
.text$mn:000006FF loc_6FF:                                ; CODE XREF: LastRecentFileList::updateMenu(void)+47Aj
.text$mn:000006FF                 mov     eax, [ebp+var_A8]
.text$mn:00000705                 add     eax, 1
.text$mn:00000708                 mov     [ebp+var_A8], eax
.text$mn:0000070E
.text$mn:0000070E loc_70E:                                ; CODE XREF: LastRecentFileList::updateMenu(void)+431j
.text$mn:0000070E                 mov     ecx, [ebp+var_A0]
.text$mn:00000714                 mov     edx, [ebp+var_A8]
.text$mn:0000071A                 cmp     edx, [ecx+1Ch]
.text$mn:0000071D                 jge     short loc_748
.text$mn:0000071F                 push    0               ; uFlags
.text$mn:00000721                 mov     eax, [ebp+var_A8]
.text$mn:00000727                 push    eax
.text$mn:00000728                 mov     ecx, [ebp+var_A0]
.text$mn:0000072E                 call    ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)
.text$mn:00000733                 mov     ecx, [eax]
.text$mn:00000735                 push    ecx             ; uPosition
.text$mn:00000736                 mov     edx, [ebp+var_A0]
.text$mn:0000073C                 mov     eax, [edx+28h]
.text$mn:0000073F                 push    eax             ; hMenu
.text$mn:00000740                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:00000746                 jmp     short loc_6FF
.text$mn:00000748 ; ---------------------------------------------------------------------------
.text$mn:00000748
.text$mn:00000748 loc_748:                                ; CODE XREF: LastRecentFileList::updateMenu(void)+451j
.text$mn:00000748                 mov     [ebp+var_A4], 0
.text$mn:00000752                 jmp     short loc_763
.text$mn:00000754 ; ---------------------------------------------------------------------------
.text$mn:00000754
.text$mn:00000754 loc_754:                                ; CODE XREF: LastRecentFileList::updateMenu(void)+543j
.text$mn:00000754                 mov     ecx, [ebp+var_A4]
.text$mn:0000075A                 add     ecx, 1
.text$mn:0000075D                 mov     [ebp+var_A4], ecx
.text$mn:00000763
.text$mn:00000763 loc_763:                                ; CODE XREF: LastRecentFileList::updateMenu(void)+486j
.text$mn:00000763                 mov     edx, [ebp+var_A0]
.text$mn:00000769                 mov     eax, [ebp+var_A4]
.text$mn:0000076F                 cmp     eax, [edx+1Ch]
.text$mn:00000772                 jge     loc_814
.text$mn:00000778                 mov     ecx, [ebp+var_A4]
.text$mn:0000077E                 push    ecx
.text$mn:0000077F                 mov     ecx, [ebp+var_A0]
.text$mn:00000785                 call    ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)
.text$mn:0000078A                 add     eax, 4
.text$mn:0000078D                 push    eax
.text$mn:0000078E                 mov     edx, [ebp+var_A4]
.text$mn:00000794                 push    edx
.text$mn:00000795                 mov     ecx, [ebp+var_B0] ; this
.text$mn:0000079B                 call    ?getRecentFileCustomLength@NppParameters@@QBEHXZ ; NppParameters::getRecentFileCustomLength(void)
.text$mn:000007A0                 push    eax
.text$mn:000007A1                 lea     eax, [ebp+var_9C]
.text$mn:000007A7                 push    eax
.text$mn:000007A8                 call    ?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z ; BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000007AD                 add     esp, 10h
.text$mn:000007B0                 mov     [ebp+var_4], 4
.text$mn:000007B7                 lea     ecx, [ebp+var_9C]
.text$mn:000007BD                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000007C2                 push    eax             ; lpNewItem
.text$mn:000007C3                 mov     ecx, [ebp+var_A4]
.text$mn:000007C9                 push    ecx
.text$mn:000007CA                 mov     ecx, [ebp+var_A0]
.text$mn:000007D0                 call    ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)
.text$mn:000007D5                 mov     edx, [eax]
.text$mn:000007D7                 push    edx             ; uIDNewItem
.text$mn:000007D8                 push    400h            ; uFlags
.text$mn:000007DD                 mov     eax, [ebp+var_A0]
.text$mn:000007E3                 mov     ecx, [eax+2Ch]
.text$mn:000007E6                 add     ecx, [ebp+var_A4]
.text$mn:000007EC                 push    ecx             ; uPosition
.text$mn:000007ED                 mov     edx, [ebp+var_A0]
.text$mn:000007F3                 mov     eax, [edx+28h]
.text$mn:000007F6                 push    eax             ; hMenu
.text$mn:000007F7                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:000007FD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000804                 lea     ecx, [ebp+var_9C]
.text$mn:0000080A                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000080F                 jmp     loc_754
.text$mn:00000814 ; ---------------------------------------------------------------------------
.text$mn:00000814
.text$mn:00000814 loc_814:                                ; CODE XREF: LastRecentFileList::updateMenu(void)+4A6j
.text$mn:00000814                 mov     ecx, [ebp+var_C]
.text$mn:00000817                 mov     large fs:0, ecx
.text$mn:0000081E                 pop     ecx
.text$mn:0000081F                 mov     ecx, [ebp+var_10]
.text$mn:00000822                 xor     ecx, ebp
.text$mn:00000824                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000829                 mov     esp, ebp
.text$mn:0000082B                 pop     ebp
.text$mn:0000082C                 retn
.text$mn:0000082C ?updateMenu@LastRecentFileList@@QAEXXZ endp
.text$mn:0000082C
.text$mn:0000082C ; ---------------------------------------------------------------------------
.text$mn:0000082D                 db 0Fh dup(0CCh)
.text$mn:0000083C
.text$mn:0000083C ; =============== S U B R O U T I N E =======================================
.text$mn:0000083C
.text$mn:0000083C ; Attributes: bp-based frame
.text$mn:0000083C
.text$mn:0000083C ; void __thiscall LastRecentFileList::add(LastRecentFileList *this, const wchar_t *)
.text$mn:0000083C                 public ?add@LastRecentFileList@@QAEXPB_W@Z
.text$mn:0000083C ?add@LastRecentFileList@@QAEXPB_W@Z proc near
.text$mn:0000083C
.text$mn:0000083C var_38          = dword ptr -38h
.text$mn:0000083C var_34          = dword ptr -34h
.text$mn:0000083C var_30          = dword ptr -30h
.text$mn:0000083C var_10          = dword ptr -10h
.text$mn:0000083C var_C           = dword ptr -0Ch
.text$mn:0000083C var_4           = dword ptr -4
.text$mn:0000083C Str             = dword ptr  8
.text$mn:0000083C
.text$mn:0000083C                 push    ebp
.text$mn:0000083D                 mov     ebp, esp
.text$mn:0000083F                 push    0FFFFFFFFh
.text$mn:00000841                 push    offset __ehhandler$?add@LastRecentFileList@@QAEXPB_W@Z
.text$mn:00000846                 mov     eax, large fs:0
.text$mn:0000084C                 push    eax
.text$mn:0000084D                 sub     esp, 2Ch
.text$mn:00000850                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000855                 xor     eax, ebp
.text$mn:00000857                 mov     [ebp+var_10], eax
.text$mn:0000085A                 push    eax
.text$mn:0000085B                 lea     eax, [ebp+var_C]
.text$mn:0000085E                 mov     large fs:0, eax
.text$mn:00000864                 mov     [ebp+var_34], ecx
.text$mn:00000867                 mov     eax, [ebp+var_34]
.text$mn:0000086A                 cmp     dword ptr [eax+18h], 0
.text$mn:0000086E                 jz      short loc_87B
.text$mn:00000870                 mov     ecx, [ebp+var_34]
.text$mn:00000873                 movzx   edx, byte ptr [ecx+53h]
.text$mn:00000877                 test    edx, edx
.text$mn:00000879                 jz      short loc_880
.text$mn:0000087B
.text$mn:0000087B loc_87B:                                ; CODE XREF: LastRecentFileList::add(wchar_t const *)+32j
.text$mn:0000087B                 jmp     loc_916
.text$mn:00000880 ; ---------------------------------------------------------------------------
.text$mn:00000880
.text$mn:00000880 loc_880:                                ; CODE XREF: LastRecentFileList::add(wchar_t const *)+3Dj
.text$mn:00000880                 mov     eax, [ebp+Str]
.text$mn:00000883                 push    eax             ; Str
.text$mn:00000884                 lea     ecx, [ebp+var_30]
.text$mn:00000887                 call    ??0RecentItem@@QAE@PB_W@Z ; RecentItem::RecentItem(wchar_t const *)
.text$mn:0000088C                 mov     [ebp+var_4], 0
.text$mn:00000893                 mov     ecx, [ebp+Str]
.text$mn:00000896                 push    ecx             ; wchar_t *
.text$mn:00000897                 mov     ecx, [ebp+var_34] ; this
.text$mn:0000089A                 call    ?find@LastRecentFileList@@AAEHPB_W@Z ; LastRecentFileList::find(wchar_t const *)
.text$mn:0000089F                 mov     [ebp+var_38], eax
.text$mn:000008A2                 cmp     [ebp+var_38], 0FFFFFFFFh
.text$mn:000008A6                 jz      short loc_8B4
.text$mn:000008A8                 mov     edx, [ebp+var_38]
.text$mn:000008AB                 push    edx             ; int
.text$mn:000008AC                 mov     ecx, [ebp+var_34] ; this
.text$mn:000008AF                 call    ?remove@LastRecentFileList@@QAEXH@Z ; LastRecentFileList::remove(int)
.text$mn:000008B4
.text$mn:000008B4 loc_8B4:                                ; CODE XREF: LastRecentFileList::add(wchar_t const *)+6Aj
.text$mn:000008B4                 mov     eax, [ebp+var_34]
.text$mn:000008B7                 mov     ecx, [ebp+var_34]
.text$mn:000008BA                 mov     edx, [eax+1Ch]
.text$mn:000008BD                 cmp     edx, [ecx+18h]
.text$mn:000008C0                 jnz     short loc_8D9
.text$mn:000008C2                 mov     ecx, [ebp+var_34]
.text$mn:000008C5                 call    ?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ ; std::deque<RecentItem,std::allocator<RecentItem>>::back(void)
.text$mn:000008CA                 mov     eax, [eax]
.text$mn:000008CC                 mov     [ebp+var_30], eax
.text$mn:000008CF                 mov     ecx, [ebp+var_34]
.text$mn:000008D2                 call    ?pop_back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEXXZ ; std::deque<RecentItem,std::allocator<RecentItem>>::pop_back(void)
.text$mn:000008D7                 jmp     short loc_8F3
.text$mn:000008D9 ; ---------------------------------------------------------------------------
.text$mn:000008D9
.text$mn:000008D9 loc_8D9:                                ; CODE XREF: LastRecentFileList::add(wchar_t const *)+84j
.text$mn:000008D9                 mov     ecx, [ebp+var_34] ; this
.text$mn:000008DC                 call    ?popFirstAvailableID@LastRecentFileList@@AAEHXZ ; LastRecentFileList::popFirstAvailableID(void)
.text$mn:000008E1                 mov     [ebp+var_30], eax
.text$mn:000008E4                 mov     ecx, [ebp+var_34]
.text$mn:000008E7                 mov     edx, [ecx+1Ch]
.text$mn:000008EA                 add     edx, 1
.text$mn:000008ED                 mov     eax, [ebp+var_34]
.text$mn:000008F0                 mov     [eax+1Ch], edx
.text$mn:000008F3
.text$mn:000008F3 loc_8F3:                                ; CODE XREF: LastRecentFileList::add(wchar_t const *)+9Bj
.text$mn:000008F3                 lea     ecx, [ebp+var_30]
.text$mn:000008F6                 push    ecx
.text$mn:000008F7                 mov     ecx, [ebp+var_34]
.text$mn:000008FA                 call    ?push_front@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEXABURecentItem@@@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::push_front(RecentItem const &)
.text$mn:000008FF                 mov     ecx, [ebp+var_34] ; this
.text$mn:00000902                 call    ?updateMenu@LastRecentFileList@@QAEXXZ ; LastRecentFileList::updateMenu(void)
.text$mn:00000907                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000090E                 lea     ecx, [ebp+var_30] ; this
.text$mn:00000911                 call    ??1RecentItem@@QAE@XZ ; RecentItem::~RecentItem(void)
.text$mn:00000916
.text$mn:00000916 loc_916:                                ; CODE XREF: LastRecentFileList::add(wchar_t const *):loc_87Bj
.text$mn:00000916                 mov     ecx, [ebp+var_C]
.text$mn:00000919                 mov     large fs:0, ecx
.text$mn:00000920                 pop     ecx
.text$mn:00000921                 mov     ecx, [ebp+var_10]
.text$mn:00000924                 xor     ecx, ebp
.text$mn:00000926                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000092B                 mov     esp, ebp
.text$mn:0000092D                 pop     ebp
.text$mn:0000092E                 retn    4
.text$mn:0000092E ?add@LastRecentFileList@@QAEXPB_W@Z endp
.text$mn:0000092E
.text$mn:0000092E ; ---------------------------------------------------------------------------
.text$mn:00000931                 db 0Bh dup(0CCh)
.text$mn:0000093C
.text$mn:0000093C ; =============== S U B R O U T I N E =======================================
.text$mn:0000093C
.text$mn:0000093C ; Attributes: bp-based frame
.text$mn:0000093C
.text$mn:0000093C ; void __thiscall LastRecentFileList::remove(LastRecentFileList *this, const wchar_t *)
.text$mn:0000093C                 public ?remove@LastRecentFileList@@QAEXPB_W@Z
.text$mn:0000093C ?remove@LastRecentFileList@@QAEXPB_W@Z proc near
.text$mn:0000093C
.text$mn:0000093C var_8           = dword ptr -8
.text$mn:0000093C var_4           = dword ptr -4
.text$mn:0000093C arg_0           = dword ptr  8
.text$mn:0000093C
.text$mn:0000093C                 push    ebp
.text$mn:0000093D                 mov     ebp, esp
.text$mn:0000093F                 sub     esp, 8
.text$mn:00000942                 mov     [ebp+var_8], ecx
.text$mn:00000945                 mov     eax, [ebp+arg_0]
.text$mn:00000948                 push    eax             ; wchar_t *
.text$mn:00000949                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000094C                 call    ?find@LastRecentFileList@@AAEHPB_W@Z ; LastRecentFileList::find(wchar_t const *)
.text$mn:00000951                 mov     [ebp+var_4], eax
.text$mn:00000954                 cmp     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000958                 jz      short loc_966
.text$mn:0000095A                 mov     ecx, [ebp+var_4]
.text$mn:0000095D                 push    ecx             ; int
.text$mn:0000095E                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000961                 call    ?remove@LastRecentFileList@@QAEXH@Z ; LastRecentFileList::remove(int)
.text$mn:00000966
.text$mn:00000966 loc_966:                                ; CODE XREF: LastRecentFileList::remove(wchar_t const *)+1Cj
.text$mn:00000966                 mov     esp, ebp
.text$mn:00000968                 pop     ebp
.text$mn:00000969                 retn    4
.text$mn:00000969 ?remove@LastRecentFileList@@QAEXPB_W@Z endp
.text$mn:00000969
.text$mn:0000096C
.text$mn:0000096C ; =============== S U B R O U T I N E =======================================
.text$mn:0000096C
.text$mn:0000096C ; Attributes: bp-based frame
.text$mn:0000096C
.text$mn:0000096C ; void __thiscall LastRecentFileList::remove(LastRecentFileList *this, int)
.text$mn:0000096C                 public ?remove@LastRecentFileList@@QAEXH@Z
.text$mn:0000096C ?remove@LastRecentFileList@@QAEXH@Z proc near
.text$mn:0000096C                                         ; CODE XREF: LastRecentFileList::add(wchar_t const *)+73p
.text$mn:0000096C                                         ; LastRecentFileList::remove(wchar_t const *)+25p
.text$mn:0000096C
.text$mn:0000096C var_54          = byte ptr -54h
.text$mn:0000096C var_48          = byte ptr -48h
.text$mn:0000096C var_3C          = byte ptr -3Ch
.text$mn:0000096C var_30          = dword ptr -30h
.text$mn:0000096C var_2C          = dword ptr -2Ch
.text$mn:0000096C var_28          = dword ptr -28h
.text$mn:0000096C var_24          = dword ptr -24h
.text$mn:0000096C var_20          = dword ptr -20h
.text$mn:0000096C var_1C          = dword ptr -1Ch
.text$mn:0000096C var_18          = dword ptr -18h
.text$mn:0000096C var_14          = dword ptr -14h
.text$mn:0000096C var_10          = dword ptr -10h
.text$mn:0000096C var_C           = dword ptr -0Ch
.text$mn:0000096C var_4           = dword ptr -4
.text$mn:0000096C arg_0           = dword ptr  8
.text$mn:0000096C
.text$mn:0000096C                 push    ebp
.text$mn:0000096D                 mov     ebp, esp
.text$mn:0000096F                 push    0FFFFFFFFh
.text$mn:00000971                 push    offset __ehhandler$?remove@LastRecentFileList@@QAEXH@Z
.text$mn:00000976                 mov     eax, large fs:0
.text$mn:0000097C                 push    eax
.text$mn:0000097D                 sub     esp, 48h
.text$mn:00000980                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000985                 xor     eax, ebp
.text$mn:00000987                 push    eax
.text$mn:00000988                 lea     eax, [ebp+var_C]
.text$mn:0000098B                 mov     large fs:0, eax
.text$mn:00000991                 mov     [ebp+var_10], ecx
.text$mn:00000994                 mov     eax, [ebp+var_10]
.text$mn:00000997                 cmp     dword ptr [eax+1Ch], 0
.text$mn:0000099B                 jz      short loc_9A8
.text$mn:0000099D                 mov     ecx, [ebp+var_10]
.text$mn:000009A0                 movzx   edx, byte ptr [ecx+53h]
.text$mn:000009A4                 test    edx, edx
.text$mn:000009A6                 jz      short loc_9AD
.text$mn:000009A8
.text$mn:000009A8 loc_9A8:                                ; CODE XREF: LastRecentFileList::remove(int)+2Fj
.text$mn:000009A8                 jmp     loc_AA1
.text$mn:000009AD ; ---------------------------------------------------------------------------
.text$mn:000009AD
.text$mn:000009AD loc_9AD:                                ; CODE XREF: LastRecentFileList::remove(int)+3Aj
.text$mn:000009AD                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:000009B1                 jle     loc_AA1
.text$mn:000009B7                 mov     ecx, [ebp+var_10]
.text$mn:000009BA                 call    ?size@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBEIXZ ; std::deque<RecentItem,std::allocator<RecentItem>>::size(void)
.text$mn:000009BF                 cmp     [ebp+arg_0], eax
.text$mn:000009C2                 jge     loc_AA1
.text$mn:000009C8                 push    0               ; uFlags
.text$mn:000009CA                 mov     eax, [ebp+arg_0]
.text$mn:000009CD                 push    eax
.text$mn:000009CE                 mov     ecx, [ebp+var_10]
.text$mn:000009D1                 call    ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)
.text$mn:000009D6                 mov     ecx, [eax]
.text$mn:000009D8                 push    ecx             ; uPosition
.text$mn:000009D9                 mov     edx, [ebp+var_10]
.text$mn:000009DC                 mov     eax, [edx+28h]
.text$mn:000009DF                 push    eax             ; hMenu
.text$mn:000009E0                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:000009E6                 mov     ecx, [ebp+arg_0]
.text$mn:000009E9                 push    ecx
.text$mn:000009EA                 mov     ecx, [ebp+var_10]
.text$mn:000009ED                 call    ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)
.text$mn:000009F2                 mov     edx, [eax]
.text$mn:000009F4                 push    edx             ; int
.text$mn:000009F5                 mov     ecx, [ebp+var_10] ; this
.text$mn:000009F8                 call    ?setAvailable@LastRecentFileList@@AAEXH@Z ; LastRecentFileList::setAvailable(int)
.text$mn:000009FD                 mov     eax, [ebp+arg_0]
.text$mn:00000A00                 push    eax
.text$mn:00000A01                 lea     ecx, [ebp+var_48]
.text$mn:00000A04                 push    ecx
.text$mn:00000A05                 lea     edx, [ebp+var_54]
.text$mn:00000A08                 push    edx
.text$mn:00000A09                 mov     ecx, [ebp+var_10]
.text$mn:00000A0C                 call    ?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ ; std::deque<RecentItem,std::allocator<RecentItem>>::begin(void)
.text$mn:00000A11                 mov     [ebp+var_14], eax
.text$mn:00000A14                 mov     eax, [ebp+var_14]
.text$mn:00000A17                 mov     [ebp+var_18], eax
.text$mn:00000A1A                 mov     [ebp+var_4], 0
.text$mn:00000A21                 mov     ecx, [ebp+var_18]
.text$mn:00000A24                 call    ??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+(int)
.text$mn:00000A29                 mov     [ebp+var_1C], eax
.text$mn:00000A2C                 mov     ecx, [ebp+var_1C]
.text$mn:00000A2F                 mov     [ebp+var_20], ecx
.text$mn:00000A32                 mov     byte ptr [ebp+var_4], 1
.text$mn:00000A36                 sub     esp, 0Ch
.text$mn:00000A39                 mov     ecx, esp
.text$mn:00000A3B                 mov     [ebp+var_28], esp
.text$mn:00000A3E                 mov     edx, [ebp+var_20]
.text$mn:00000A41                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00000A42                 call    ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00000A47                 mov     [ebp+var_24], eax
.text$mn:00000A4A                 mov     eax, [ebp+var_24]
.text$mn:00000A4D                 mov     [ebp+var_2C], eax
.text$mn:00000A50                 mov     byte ptr [ebp+var_4], 2
.text$mn:00000A54                 lea     ecx, [ebp+var_3C]
.text$mn:00000A57                 push    ecx
.text$mn:00000A58                 mov     ecx, [ebp+var_10]
.text$mn:00000A5B                 mov     byte ptr [ebp+var_4], 1
.text$mn:00000A5F                 call    ?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)
.text$mn:00000A64                 mov     [ebp+var_30], eax
.text$mn:00000A67                 lea     ecx, [ebp+var_3C]
.text$mn:00000A6A                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00000A6F                 mov     byte ptr [ebp+var_4], 0
.text$mn:00000A73                 lea     ecx, [ebp+var_48]
.text$mn:00000A76                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00000A7B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A82                 lea     ecx, [ebp+var_54]
.text$mn:00000A85                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00000A8A                 mov     edx, [ebp+var_10]
.text$mn:00000A8D                 mov     eax, [edx+1Ch]
.text$mn:00000A90                 sub     eax, 1
.text$mn:00000A93                 mov     ecx, [ebp+var_10]
.text$mn:00000A96                 mov     [ecx+1Ch], eax
.text$mn:00000A99                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000A9C                 call    ?updateMenu@LastRecentFileList@@QAEXXZ ; LastRecentFileList::updateMenu(void)
.text$mn:00000AA1
.text$mn:00000AA1 loc_AA1:                                ; CODE XREF: LastRecentFileList::remove(int):loc_9A8j
.text$mn:00000AA1                                         ; LastRecentFileList::remove(int)+45j ...
.text$mn:00000AA1                 mov     ecx, [ebp+var_C]
.text$mn:00000AA4                 mov     large fs:0, ecx
.text$mn:00000AAB                 pop     ecx
.text$mn:00000AAC                 mov     esp, ebp
.text$mn:00000AAE                 pop     ebp
.text$mn:00000AAF                 retn    4
.text$mn:00000AAF ?remove@LastRecentFileList@@QAEXH@Z endp
.text$mn:00000AAF
.text$mn:00000AAF ; ---------------------------------------------------------------------------
.text$mn:00000AB2                 db 0Ah dup(0CCh)
.text$mn:00000ABC
.text$mn:00000ABC ; =============== S U B R O U T I N E =======================================
.text$mn:00000ABC
.text$mn:00000ABC ; Attributes: bp-based frame
.text$mn:00000ABC
.text$mn:00000ABC ; void __thiscall LastRecentFileList::clear(LastRecentFileList *__hidden this)
.text$mn:00000ABC                 public ?clear@LastRecentFileList@@QAEXXZ
.text$mn:00000ABC ?clear@LastRecentFileList@@QAEXXZ proc near
.text$mn:00000ABC
.text$mn:00000ABC var_58          = byte ptr -58h
.text$mn:00000ABC var_4C          = byte ptr -4Ch
.text$mn:00000ABC var_40          = byte ptr -40h
.text$mn:00000ABC var_34          = dword ptr -34h
.text$mn:00000ABC var_30          = dword ptr -30h
.text$mn:00000ABC var_2C          = dword ptr -2Ch
.text$mn:00000ABC var_28          = dword ptr -28h
.text$mn:00000ABC var_24          = dword ptr -24h
.text$mn:00000ABC var_20          = dword ptr -20h
.text$mn:00000ABC var_1C          = dword ptr -1Ch
.text$mn:00000ABC var_18          = dword ptr -18h
.text$mn:00000ABC var_14          = dword ptr -14h
.text$mn:00000ABC var_10          = dword ptr -10h
.text$mn:00000ABC var_C           = dword ptr -0Ch
.text$mn:00000ABC var_4           = dword ptr -4
.text$mn:00000ABC
.text$mn:00000ABC                 push    ebp
.text$mn:00000ABD                 mov     ebp, esp
.text$mn:00000ABF                 push    0FFFFFFFFh
.text$mn:00000AC1                 push    offset __ehhandler$?clear@LastRecentFileList@@QAEXXZ
.text$mn:00000AC6                 mov     eax, large fs:0
.text$mn:00000ACC                 push    eax
.text$mn:00000ACD                 sub     esp, 4Ch
.text$mn:00000AD0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000AD5                 xor     eax, ebp
.text$mn:00000AD7                 push    eax
.text$mn:00000AD8                 lea     eax, [ebp+var_C]
.text$mn:00000ADB                 mov     large fs:0, eax
.text$mn:00000AE1                 mov     [ebp+var_10], ecx
.text$mn:00000AE4                 mov     eax, [ebp+var_10]
.text$mn:00000AE7                 cmp     dword ptr [eax+1Ch], 0
.text$mn:00000AEB                 jnz     short loc_AF2
.text$mn:00000AED                 jmp     loc_BEC
.text$mn:00000AF2 ; ---------------------------------------------------------------------------
.text$mn:00000AF2
.text$mn:00000AF2 loc_AF2:                                ; CODE XREF: LastRecentFileList::clear(void)+2Fj
.text$mn:00000AF2                 mov     ecx, [ebp+var_10]
.text$mn:00000AF5                 mov     edx, [ecx+1Ch]
.text$mn:00000AF8                 sub     edx, 1
.text$mn:00000AFB                 mov     [ebp+var_14], edx
.text$mn:00000AFE                 jmp     short loc_B09
.text$mn:00000B00 ; ---------------------------------------------------------------------------
.text$mn:00000B00
.text$mn:00000B00 loc_B00:                                ; CODE XREF: LastRecentFileList::clear(void)+119j
.text$mn:00000B00                 mov     eax, [ebp+var_14]
.text$mn:00000B03                 sub     eax, 1
.text$mn:00000B06                 mov     [ebp+var_14], eax
.text$mn:00000B09
.text$mn:00000B09 loc_B09:                                ; CODE XREF: LastRecentFileList::clear(void)+42j
.text$mn:00000B09                 cmp     [ebp+var_14], 0
.text$mn:00000B0D                 jl      loc_BDA
.text$mn:00000B13                 push    0               ; uFlags
.text$mn:00000B15                 mov     ecx, [ebp+var_14]
.text$mn:00000B18                 push    ecx
.text$mn:00000B19                 mov     ecx, [ebp+var_10]
.text$mn:00000B1C                 call    ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)
.text$mn:00000B21                 mov     edx, [eax]
.text$mn:00000B23                 push    edx             ; uPosition
.text$mn:00000B24                 mov     eax, [ebp+var_10]
.text$mn:00000B27                 mov     ecx, [eax+28h]
.text$mn:00000B2A                 push    ecx             ; hMenu
.text$mn:00000B2B                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:00000B31                 mov     edx, [ebp+var_14]
.text$mn:00000B34                 push    edx
.text$mn:00000B35                 mov     ecx, [ebp+var_10]
.text$mn:00000B38                 call    ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)
.text$mn:00000B3D                 mov     eax, [eax]
.text$mn:00000B3F                 push    eax             ; int
.text$mn:00000B40                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000B43                 call    ?setAvailable@LastRecentFileList@@AAEXH@Z ; LastRecentFileList::setAvailable(int)
.text$mn:00000B48                 mov     ecx, [ebp+var_14]
.text$mn:00000B4B                 push    ecx
.text$mn:00000B4C                 lea     edx, [ebp+var_4C]
.text$mn:00000B4F                 push    edx
.text$mn:00000B50                 lea     eax, [ebp+var_58]
.text$mn:00000B53                 push    eax
.text$mn:00000B54                 mov     ecx, [ebp+var_10]
.text$mn:00000B57                 call    ?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ ; std::deque<RecentItem,std::allocator<RecentItem>>::begin(void)
.text$mn:00000B5C                 mov     [ebp+var_18], eax
.text$mn:00000B5F                 mov     ecx, [ebp+var_18]
.text$mn:00000B62                 mov     [ebp+var_1C], ecx
.text$mn:00000B65                 mov     [ebp+var_4], 0
.text$mn:00000B6C                 mov     ecx, [ebp+var_1C]
.text$mn:00000B6F                 call    ??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+(int)
.text$mn:00000B74                 mov     [ebp+var_20], eax
.text$mn:00000B77                 mov     edx, [ebp+var_20]
.text$mn:00000B7A                 mov     [ebp+var_24], edx
.text$mn:00000B7D                 mov     byte ptr [ebp+var_4], 1
.text$mn:00000B81                 sub     esp, 0Ch
.text$mn:00000B84                 mov     ecx, esp
.text$mn:00000B86                 mov     [ebp+var_2C], esp
.text$mn:00000B89                 mov     eax, [ebp+var_24]
.text$mn:00000B8C                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00000B8D                 call    ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00000B92                 mov     [ebp+var_28], eax
.text$mn:00000B95                 mov     ecx, [ebp+var_28]
.text$mn:00000B98                 mov     [ebp+var_30], ecx
.text$mn:00000B9B                 mov     byte ptr [ebp+var_4], 2
.text$mn:00000B9F                 lea     edx, [ebp+var_40]
.text$mn:00000BA2                 push    edx
.text$mn:00000BA3                 mov     ecx, [ebp+var_10]
.text$mn:00000BA6                 mov     byte ptr [ebp+var_4], 1
.text$mn:00000BAA                 call    ?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)
.text$mn:00000BAF                 mov     [ebp+var_34], eax
.text$mn:00000BB2                 lea     ecx, [ebp+var_40]
.text$mn:00000BB5                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00000BBA                 mov     byte ptr [ebp+var_4], 0
.text$mn:00000BBE                 lea     ecx, [ebp+var_4C]
.text$mn:00000BC1                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00000BC6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000BCD                 lea     ecx, [ebp+var_58]
.text$mn:00000BD0                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00000BD5                 jmp     loc_B00
.text$mn:00000BDA ; ---------------------------------------------------------------------------
.text$mn:00000BDA
.text$mn:00000BDA loc_BDA:                                ; CODE XREF: LastRecentFileList::clear(void)+51j
.text$mn:00000BDA                 mov     eax, [ebp+var_10]
.text$mn:00000BDD                 mov     dword ptr [eax+1Ch], 0
.text$mn:00000BE4                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000BE7                 call    ?updateMenu@LastRecentFileList@@QAEXXZ ; LastRecentFileList::updateMenu(void)
.text$mn:00000BEC
.text$mn:00000BEC loc_BEC:                                ; CODE XREF: LastRecentFileList::clear(void)+31j
.text$mn:00000BEC                 mov     ecx, [ebp+var_C]
.text$mn:00000BEF                 mov     large fs:0, ecx
.text$mn:00000BF6                 pop     ecx
.text$mn:00000BF7                 mov     esp, ebp
.text$mn:00000BF9                 pop     ebp
.text$mn:00000BFA                 retn
.text$mn:00000BFA ?clear@LastRecentFileList@@QAEXXZ endp
.text$mn:00000BFA
.text$mn:00000BFA ; ---------------------------------------------------------------------------
.text$mn:00000BFB                 align 4
.text$mn:00000BFC
.text$mn:00000BFC ; =============== S U B R O U T I N E =======================================
.text$mn:00000BFC
.text$mn:00000BFC ; Attributes: bp-based frame
.text$mn:00000BFC
.text$mn:00000BFC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall LastRecentFileList::getItem(int)
.text$mn:00000BFC                 public ?getItem@LastRecentFileList@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z
.text$mn:00000BFC ?getItem@LastRecentFileList@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z proc near
.text$mn:00000BFC
.text$mn:00000BFC var_8           = dword ptr -8
.text$mn:00000BFC var_4           = dword ptr -4
.text$mn:00000BFC arg_0           = dword ptr  8
.text$mn:00000BFC
.text$mn:00000BFC                 push    ebp
.text$mn:00000BFD                 mov     ebp, esp
.text$mn:00000BFF                 sub     esp, 8
.text$mn:00000C02                 mov     [ebp+var_8], ecx
.text$mn:00000C05                 mov     [ebp+var_4], 0
.text$mn:00000C0C                 jmp     short loc_C17
.text$mn:00000C0E ; ---------------------------------------------------------------------------
.text$mn:00000C0E
.text$mn:00000C0E loc_C0E:                                ; CODE XREF: LastRecentFileList::getItem(int):loc_C37j
.text$mn:00000C0E                 mov     eax, [ebp+var_4]
.text$mn:00000C11                 add     eax, 1
.text$mn:00000C14                 mov     [ebp+var_4], eax
.text$mn:00000C17
.text$mn:00000C17 loc_C17:                                ; CODE XREF: LastRecentFileList::getItem(int)+10j
.text$mn:00000C17                 mov     ecx, [ebp+var_8]
.text$mn:00000C1A                 mov     edx, [ebp+var_4]
.text$mn:00000C1D                 cmp     edx, [ecx+1Ch]
.text$mn:00000C20                 jge     short loc_C39
.text$mn:00000C22                 mov     eax, [ebp+var_4]
.text$mn:00000C25                 push    eax
.text$mn:00000C26                 mov     ecx, [ebp+var_8]
.text$mn:00000C29                 call    ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)
.text$mn:00000C2E                 mov     ecx, [eax]
.text$mn:00000C30                 cmp     ecx, [ebp+arg_0]
.text$mn:00000C33                 jnz     short loc_C37
.text$mn:00000C35                 jmp     short loc_C39
.text$mn:00000C37 ; ---------------------------------------------------------------------------
.text$mn:00000C37
.text$mn:00000C37 loc_C37:                                ; CODE XREF: LastRecentFileList::getItem(int)+37j
.text$mn:00000C37                 jmp     short loc_C0E
.text$mn:00000C39 ; ---------------------------------------------------------------------------
.text$mn:00000C39
.text$mn:00000C39 loc_C39:                                ; CODE XREF: LastRecentFileList::getItem(int)+24j
.text$mn:00000C39                                         ; LastRecentFileList::getItem(int)+39j
.text$mn:00000C39                 mov     edx, [ebp+var_8]
.text$mn:00000C3C                 mov     eax, [ebp+var_4]
.text$mn:00000C3F                 cmp     eax, [edx+1Ch]
.text$mn:00000C42                 jnz     short loc_C4B
.text$mn:00000C44                 mov     [ebp+var_4], 0
.text$mn:00000C4B
.text$mn:00000C4B loc_C4B:                                ; CODE XREF: LastRecentFileList::getItem(int)+46j
.text$mn:00000C4B                 mov     ecx, [ebp+var_4]
.text$mn:00000C4E                 push    ecx
.text$mn:00000C4F                 mov     ecx, [ebp+var_8]
.text$mn:00000C52                 call    ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)
.text$mn:00000C57                 add     eax, 4
.text$mn:00000C5A                 mov     esp, ebp
.text$mn:00000C5C                 pop     ebp
.text$mn:00000C5D                 retn    4
.text$mn:00000C5D ?getItem@LastRecentFileList@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z endp
.text$mn:00000C5D
.text$mn:00000C5D ; ---------------------------------------------------------------------------
.text$mn:00000C60                 db 0Ch dup(0CCh)
.text$mn:00000C6C
.text$mn:00000C6C ; =============== S U B R O U T I N E =======================================
.text$mn:00000C6C
.text$mn:00000C6C ; Attributes: bp-based frame
.text$mn:00000C6C
.text$mn:00000C6C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall LastRecentFileList::getIndex(int)
.text$mn:00000C6C                 public ?getIndex@LastRecentFileList@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z
.text$mn:00000C6C ?getIndex@LastRecentFileList@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z proc near
.text$mn:00000C6C
.text$mn:00000C6C var_4           = dword ptr -4
.text$mn:00000C6C arg_0           = dword ptr  8
.text$mn:00000C6C
.text$mn:00000C6C                 push    ebp
.text$mn:00000C6D                 mov     ebp, esp
.text$mn:00000C6F                 push    ecx
.text$mn:00000C70                 mov     [ebp+var_4], ecx
.text$mn:00000C73                 mov     eax, [ebp+arg_0]
.text$mn:00000C76                 push    eax
.text$mn:00000C77                 mov     ecx, [ebp+var_4]
.text$mn:00000C7A                 call    ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)
.text$mn:00000C7F                 add     eax, 4
.text$mn:00000C82                 mov     esp, ebp
.text$mn:00000C84                 pop     ebp
.text$mn:00000C85                 retn    4
.text$mn:00000C85 ?getIndex@LastRecentFileList@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z endp
.text$mn:00000C85
.text$mn:00000C85 ; ---------------------------------------------------------------------------
.text$mn:00000C88                 db 4 dup(0CCh)
.text$mn:00000C8C
.text$mn:00000C8C ; =============== S U B R O U T I N E =======================================
.text$mn:00000C8C
.text$mn:00000C8C ; Attributes: bp-based frame
.text$mn:00000C8C
.text$mn:00000C8C ; void __thiscall LastRecentFileList::setUserMaxNbLRF(LastRecentFileList *this, int)
.text$mn:00000C8C                 public ?setUserMaxNbLRF@LastRecentFileList@@QAEXH@Z
.text$mn:00000C8C ?setUserMaxNbLRF@LastRecentFileList@@QAEXH@Z proc near
.text$mn:00000C8C
.text$mn:00000C8C var_8           = dword ptr -8
.text$mn:00000C8C var_4           = dword ptr -4
.text$mn:00000C8C arg_0           = dword ptr  8
.text$mn:00000C8C
.text$mn:00000C8C                 push    ebp
.text$mn:00000C8D                 mov     ebp, esp
.text$mn:00000C8F                 sub     esp, 8
.text$mn:00000C92                 mov     [ebp+var_4], ecx
.text$mn:00000C95                 mov     eax, [ebp+var_4]
.text$mn:00000C98                 mov     ecx, [ebp+arg_0]
.text$mn:00000C9B                 mov     [eax+18h], ecx
.text$mn:00000C9E                 mov     edx, [ebp+var_4]
.text$mn:00000CA1                 mov     eax, [ebp+var_4]
.text$mn:00000CA4                 mov     ecx, [edx+1Ch]
.text$mn:00000CA7                 cmp     ecx, [eax+18h]
.text$mn:00000CAA                 jle     short loc_D24
.text$mn:00000CAC                 mov     edx, [ebp+var_4]
.text$mn:00000CAF                 mov     eax, [ebp+var_4]
.text$mn:00000CB2                 mov     ecx, [edx+1Ch]
.text$mn:00000CB5                 sub     ecx, [eax+18h]
.text$mn:00000CB8                 mov     [ebp+var_8], ecx
.text$mn:00000CBB
.text$mn:00000CBB loc_CBB:                                ; CODE XREF: LastRecentFileList::setUserMaxNbLRF(int)+82j
.text$mn:00000CBB                 cmp     [ebp+var_8], 0
.text$mn:00000CBF                 jle     short loc_D10
.text$mn:00000CC1                 push    0               ; uFlags
.text$mn:00000CC3                 mov     ecx, [ebp+var_4]
.text$mn:00000CC6                 call    ?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ ; std::deque<RecentItem,std::allocator<RecentItem>>::back(void)
.text$mn:00000CCB                 mov     edx, [eax]
.text$mn:00000CCD                 push    edx             ; uPosition
.text$mn:00000CCE                 mov     eax, [ebp+var_4]
.text$mn:00000CD1                 mov     ecx, [eax+28h]
.text$mn:00000CD4                 push    ecx             ; hMenu
.text$mn:00000CD5                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:00000CDB                 mov     ecx, [ebp+var_4]
.text$mn:00000CDE                 call    ?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ ; std::deque<RecentItem,std::allocator<RecentItem>>::back(void)
.text$mn:00000CE3                 mov     edx, [eax]
.text$mn:00000CE5                 push    edx             ; int
.text$mn:00000CE6                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000CE9                 call    ?setAvailable@LastRecentFileList@@AAEXH@Z ; LastRecentFileList::setAvailable(int)
.text$mn:00000CEE                 mov     ecx, [ebp+var_4]
.text$mn:00000CF1                 call    ?pop_back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEXXZ ; std::deque<RecentItem,std::allocator<RecentItem>>::pop_back(void)
.text$mn:00000CF6                 mov     eax, [ebp+var_8]
.text$mn:00000CF9                 sub     eax, 1
.text$mn:00000CFC                 mov     [ebp+var_8], eax
.text$mn:00000CFF                 mov     ecx, [ebp+var_4]
.text$mn:00000D02                 mov     edx, [ecx+1Ch]
.text$mn:00000D05                 sub     edx, 1
.text$mn:00000D08                 mov     eax, [ebp+var_4]
.text$mn:00000D0B                 mov     [eax+1Ch], edx
.text$mn:00000D0E                 jmp     short loc_CBB
.text$mn:00000D10 ; ---------------------------------------------------------------------------
.text$mn:00000D10
.text$mn:00000D10 loc_D10:                                ; CODE XREF: LastRecentFileList::setUserMaxNbLRF(int)+33j
.text$mn:00000D10                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000D13                 call    ?updateMenu@LastRecentFileList@@QAEXXZ ; LastRecentFileList::updateMenu(void)
.text$mn:00000D18                 mov     ecx, [ebp+var_4]
.text$mn:00000D1B                 mov     edx, [ebp+var_4]
.text$mn:00000D1E                 mov     eax, [edx+18h]
.text$mn:00000D21                 mov     [ecx+1Ch], eax
.text$mn:00000D24
.text$mn:00000D24 loc_D24:                                ; CODE XREF: LastRecentFileList::setUserMaxNbLRF(int)+1Ej
.text$mn:00000D24                 mov     esp, ebp
.text$mn:00000D26                 pop     ebp
.text$mn:00000D27                 retn    4
.text$mn:00000D27 ?setUserMaxNbLRF@LastRecentFileList@@QAEXH@Z endp
.text$mn:00000D27
.text$mn:00000D27 ; ---------------------------------------------------------------------------
.text$mn:00000D2A                 align 4
.text$mn:00000D2C
.text$mn:00000D2C ; =============== S U B R O U T I N E =======================================
.text$mn:00000D2C
.text$mn:00000D2C ; Attributes: bp-based frame
.text$mn:00000D2C
.text$mn:00000D2C ; void __thiscall LastRecentFileList::saveLRFL(LastRecentFileList *__hidden this)
.text$mn:00000D2C                 public ?saveLRFL@LastRecentFileList@@QAEXXZ
.text$mn:00000D2C ?saveLRFL@LastRecentFileList@@QAEXXZ proc near
.text$mn:00000D2C
.text$mn:00000D2C var_C           = dword ptr -0Ch
.text$mn:00000D2C var_8           = dword ptr -8
.text$mn:00000D2C var_4           = dword ptr -4
.text$mn:00000D2C
.text$mn:00000D2C                 push    ebp
.text$mn:00000D2D                 mov     ebp, esp
.text$mn:00000D2F                 sub     esp, 0Ch
.text$mn:00000D32                 mov     [ebp+var_8], ecx
.text$mn:00000D35                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000D3A                 mov     [ebp+var_C], eax
.text$mn:00000D3D                 mov     eax, [ebp+var_8]
.text$mn:00000D40                 mov     ecx, [eax+18h]
.text$mn:00000D43                 push    ecx             ; int
.text$mn:00000D44                 mov     ecx, [ebp+var_C] ; this
.text$mn:00000D47                 call    ?writeRecentFileHistorySettings@NppParameters@@QBE_NH@Z ; NppParameters::writeRecentFileHistorySettings(int)
.text$mn:00000D4C                 movzx   edx, al
.text$mn:00000D4F                 test    edx, edx
.text$mn:00000D51                 jz      short loc_D91
.text$mn:00000D53                 mov     eax, [ebp+var_8]
.text$mn:00000D56                 mov     ecx, [eax+1Ch]
.text$mn:00000D59                 sub     ecx, 1
.text$mn:00000D5C                 mov     [ebp+var_4], ecx
.text$mn:00000D5F                 jmp     short loc_D6A
.text$mn:00000D61 ; ---------------------------------------------------------------------------
.text$mn:00000D61
.text$mn:00000D61 loc_D61:                                ; CODE XREF: LastRecentFileList::saveLRFL(void)+63j
.text$mn:00000D61                 mov     edx, [ebp+var_4]
.text$mn:00000D64                 sub     edx, 1
.text$mn:00000D67                 mov     [ebp+var_4], edx
.text$mn:00000D6A
.text$mn:00000D6A loc_D6A:                                ; CODE XREF: LastRecentFileList::saveLRFL(void)+33j
.text$mn:00000D6A                 cmp     [ebp+var_4], 0
.text$mn:00000D6E                 jl      short loc_D91
.text$mn:00000D70                 mov     eax, [ebp+var_4]
.text$mn:00000D73                 push    eax
.text$mn:00000D74                 mov     ecx, [ebp+var_8]
.text$mn:00000D77                 call    ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)
.text$mn:00000D7C                 add     eax, 4
.text$mn:00000D7F                 mov     ecx, eax
.text$mn:00000D81                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000D86                 push    eax             ; wchar_t *
.text$mn:00000D87                 mov     ecx, [ebp+var_C] ; this
.text$mn:00000D8A                 call    ?writeHistory@NppParameters@@QAE_NPB_W@Z ; NppParameters::writeHistory(wchar_t const *)
.text$mn:00000D8F                 jmp     short loc_D61
.text$mn:00000D91 ; ---------------------------------------------------------------------------
.text$mn:00000D91
.text$mn:00000D91 loc_D91:                                ; CODE XREF: LastRecentFileList::saveLRFL(void)+25j
.text$mn:00000D91                                         ; LastRecentFileList::saveLRFL(void)+42j
.text$mn:00000D91                 mov     esp, ebp
.text$mn:00000D93                 pop     ebp
.text$mn:00000D94                 retn
.text$mn:00000D94 ?saveLRFL@LastRecentFileList@@QAEXXZ endp
.text$mn:00000D94
.text$mn:00000D94 ; ---------------------------------------------------------------------------
.text$mn:00000D95                 db 7 dup(0CCh)
.text$mn:00000D9C
.text$mn:00000D9C ; =============== S U B R O U T I N E =======================================
.text$mn:00000D9C
.text$mn:00000D9C ; Attributes: bp-based frame
.text$mn:00000D9C
.text$mn:00000D9C ; int __thiscall LastRecentFileList::find(LastRecentFileList *this, const wchar_t *)
.text$mn:00000D9C                 public ?find@LastRecentFileList@@AAEHPB_W@Z
.text$mn:00000D9C ?find@LastRecentFileList@@AAEHPB_W@Z proc near
.text$mn:00000D9C                                         ; CODE XREF: LastRecentFileList::add(wchar_t const *)+5Ep
.text$mn:00000D9C                                         ; LastRecentFileList::remove(wchar_t const *)+10p
.text$mn:00000D9C
.text$mn:00000D9C var_8           = dword ptr -8
.text$mn:00000D9C var_4           = dword ptr -4
.text$mn:00000D9C lpString2       = dword ptr  8
.text$mn:00000D9C
.text$mn:00000D9C                 push    ebp
.text$mn:00000D9D                 mov     ebp, esp
.text$mn:00000D9F                 sub     esp, 8
.text$mn:00000DA2                 mov     [ebp+var_8], ecx
.text$mn:00000DA5                 mov     [ebp+var_4], 0
.text$mn:00000DAC                 jmp     short loc_DB7
.text$mn:00000DAE ; ---------------------------------------------------------------------------
.text$mn:00000DAE
.text$mn:00000DAE loc_DAE:                                ; CODE XREF: LastRecentFileList::find(wchar_t const *):loc_DECj
.text$mn:00000DAE                 mov     eax, [ebp+var_4]
.text$mn:00000DB1                 add     eax, 1
.text$mn:00000DB4                 mov     [ebp+var_4], eax
.text$mn:00000DB7
.text$mn:00000DB7 loc_DB7:                                ; CODE XREF: LastRecentFileList::find(wchar_t const *)+10j
.text$mn:00000DB7                 mov     ecx, [ebp+var_8]
.text$mn:00000DBA                 mov     edx, [ebp+var_4]
.text$mn:00000DBD                 cmp     edx, [ecx+1Ch]
.text$mn:00000DC0                 jge     short loc_DEE
.text$mn:00000DC2                 mov     eax, [ebp+lpString2]
.text$mn:00000DC5                 push    eax             ; lpString2
.text$mn:00000DC6                 mov     ecx, [ebp+var_4]
.text$mn:00000DC9                 push    ecx
.text$mn:00000DCA                 mov     ecx, [ebp+var_8]
.text$mn:00000DCD                 call    ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)
.text$mn:00000DD2                 add     eax, 4
.text$mn:00000DD5                 mov     ecx, eax
.text$mn:00000DD7                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000DDC                 push    eax             ; lpString1
.text$mn:00000DDD                 call    dword ptr ds:__imp__lstrcmpiW@8 ; lstrcmpiW(x,x)
.text$mn:00000DE3                 test    eax, eax
.text$mn:00000DE5                 jnz     short loc_DEC
.text$mn:00000DE7                 mov     eax, [ebp+var_4]
.text$mn:00000DEA                 jmp     short loc_DF1
.text$mn:00000DEC ; ---------------------------------------------------------------------------
.text$mn:00000DEC
.text$mn:00000DEC loc_DEC:                                ; CODE XREF: LastRecentFileList::find(wchar_t const *)+49j
.text$mn:00000DEC                 jmp     short loc_DAE
.text$mn:00000DEE ; ---------------------------------------------------------------------------
.text$mn:00000DEE
.text$mn:00000DEE loc_DEE:                                ; CODE XREF: LastRecentFileList::find(wchar_t const *)+24j
.text$mn:00000DEE                 or      eax, 0FFFFFFFFh
.text$mn:00000DF1
.text$mn:00000DF1 loc_DF1:                                ; CODE XREF: LastRecentFileList::find(wchar_t const *)+4Ej
.text$mn:00000DF1                 mov     esp, ebp
.text$mn:00000DF3                 pop     ebp
.text$mn:00000DF4                 retn    4
.text$mn:00000DF4 ?find@LastRecentFileList@@AAEHPB_W@Z endp
.text$mn:00000DF4
.text$mn:00000DF4 ; ---------------------------------------------------------------------------
.text$mn:00000DF7                 db 5 dup(0CCh)
.text$mn:00000DFC
.text$mn:00000DFC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DFC
.text$mn:00000DFC ; Attributes: bp-based frame
.text$mn:00000DFC
.text$mn:00000DFC ; int __thiscall LastRecentFileList::popFirstAvailableID(LastRecentFileList *__hidden this)
.text$mn:00000DFC                 public ?popFirstAvailableID@LastRecentFileList@@AAEHXZ
.text$mn:00000DFC ?popFirstAvailableID@LastRecentFileList@@AAEHXZ proc near
.text$mn:00000DFC                                         ; CODE XREF: LastRecentFileList::add(wchar_t const *)+A0p
.text$mn:00000DFC
.text$mn:00000DFC var_8           = dword ptr -8
.text$mn:00000DFC var_4           = dword ptr -4
.text$mn:00000DFC
.text$mn:00000DFC                 push    ebp
.text$mn:00000DFD                 mov     ebp, esp
.text$mn:00000DFF                 sub     esp, 8
.text$mn:00000E02                 mov     [ebp+var_8], ecx
.text$mn:00000E05                 mov     [ebp+var_4], 0
.text$mn:00000E0C                 jmp     short loc_E17
.text$mn:00000E0E ; ---------------------------------------------------------------------------
.text$mn:00000E0E
.text$mn:00000E0E loc_E0E:                                ; CODE XREF: LastRecentFileList::popFirstAvailableID(void):loc_E40j
.text$mn:00000E0E                 mov     eax, [ebp+var_4]
.text$mn:00000E11                 add     eax, 1
.text$mn:00000E14                 mov     [ebp+var_4], eax
.text$mn:00000E17
.text$mn:00000E17 loc_E17:                                ; CODE XREF: LastRecentFileList::popFirstAvailableID(void)+10j
.text$mn:00000E17                 cmp     [ebp+var_4], 1Eh
.text$mn:00000E1B                 jge     short loc_E42
.text$mn:00000E1D                 mov     ecx, [ebp+var_8]
.text$mn:00000E20                 add     ecx, [ebp+var_4]
.text$mn:00000E23                 movzx   edx, byte ptr [ecx+34h]
.text$mn:00000E27                 test    edx, edx
.text$mn:00000E29                 jz      short loc_E40
.text$mn:00000E2B                 mov     eax, [ebp+var_8]
.text$mn:00000E2E                 add     eax, [ebp+var_4]
.text$mn:00000E31                 mov     byte ptr [eax+34h], 0
.text$mn:00000E35                 mov     ecx, [ebp+var_8]
.text$mn:00000E38                 mov     eax, [ebp+var_4]
.text$mn:00000E3B                 add     eax, [ecx+30h]
.text$mn:00000E3E                 jmp     short loc_E44
.text$mn:00000E40 ; ---------------------------------------------------------------------------
.text$mn:00000E40
.text$mn:00000E40 loc_E40:                                ; CODE XREF: LastRecentFileList::popFirstAvailableID(void)+2Dj
.text$mn:00000E40                 jmp     short loc_E0E
.text$mn:00000E42 ; ---------------------------------------------------------------------------
.text$mn:00000E42
.text$mn:00000E42 loc_E42:                                ; CODE XREF: LastRecentFileList::popFirstAvailableID(void)+1Fj
.text$mn:00000E42                 xor     eax, eax
.text$mn:00000E44
.text$mn:00000E44 loc_E44:                                ; CODE XREF: LastRecentFileList::popFirstAvailableID(void)+42j
.text$mn:00000E44                 mov     esp, ebp
.text$mn:00000E46                 pop     ebp
.text$mn:00000E47                 retn
.text$mn:00000E47 ?popFirstAvailableID@LastRecentFileList@@AAEHXZ endp
.text$mn:00000E47
.text$mn:00000E47 ; ---------------------------------------------------------------------------
.text$mn:00000E48                 db 4 dup(0CCh)
.text$mn:00000E4C
.text$mn:00000E4C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E4C
.text$mn:00000E4C ; Attributes: bp-based frame
.text$mn:00000E4C
.text$mn:00000E4C ; void __thiscall LastRecentFileList::setAvailable(LastRecentFileList *this, int)
.text$mn:00000E4C                 public ?setAvailable@LastRecentFileList@@AAEXH@Z
.text$mn:00000E4C ?setAvailable@LastRecentFileList@@AAEXH@Z proc near
.text$mn:00000E4C                                         ; CODE XREF: LastRecentFileList::remove(int)+8Cp
.text$mn:00000E4C                                         ; LastRecentFileList::clear(void)+87p ...
.text$mn:00000E4C
.text$mn:00000E4C var_8           = dword ptr -8
.text$mn:00000E4C var_4           = dword ptr -4
.text$mn:00000E4C arg_0           = dword ptr  8
.text$mn:00000E4C
.text$mn:00000E4C                 push    ebp
.text$mn:00000E4D                 mov     ebp, esp
.text$mn:00000E4F                 sub     esp, 8
.text$mn:00000E52                 mov     [ebp+var_4], ecx
.text$mn:00000E55                 mov     eax, [ebp+var_4]
.text$mn:00000E58                 mov     ecx, [ebp+arg_0]
.text$mn:00000E5B                 sub     ecx, [eax+30h]
.text$mn:00000E5E                 mov     [ebp+var_8], ecx
.text$mn:00000E61                 mov     edx, [ebp+var_4]
.text$mn:00000E64                 add     edx, [ebp+var_8]
.text$mn:00000E67                 mov     byte ptr [edx+34h], 1
.text$mn:00000E6B                 mov     esp, ebp
.text$mn:00000E6D                 pop     ebp
.text$mn:00000E6E                 retn    4
.text$mn:00000E6E ?setAvailable@LastRecentFileList@@AAEXH@Z endp
.text$mn:00000E6E
.text$mn:00000E6E ; ---------------------------------------------------------------------------
.text$mn:00000E71                 align 4
.text$mn:00000E71 _text$mn        ends
.text$mn:00000E71
.text$x:00000E74 ; ===========================================================================
.text$x:00000E74
.text$x:00000E74 ; Segment type: Pure code
.text$x:00000E74 ; Segment permissions: Read/Execute
.text$x:00000E74 _text$x         segment para public 'CODE' use32
.text$x:00000E74                 assume cs:_text$x
.text$x:00000E74                 ;org 0E74h
.text$x:00000E74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000E74
.text$x:00000E74 ; =============== S U B R O U T I N E =======================================
.text$x:00000E74
.text$x:00000E74
.text$x:00000E74 __unwindfunclet$?updateMenu@LastRecentFileList@@QAEXXZ$0 proc near
.text$x:00000E74                                         ; DATA XREF: .xdata$x:00006F14o
.text$x:00000E74                 lea     ecx, [ebp-48h]
.text$x:00000E77                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00000E77 __unwindfunclet$?updateMenu@LastRecentFileList@@QAEXXZ$0 endp
.text$x:00000E77
.text$x:00000E7C
.text$x:00000E7C ; =============== S U B R O U T I N E =======================================
.text$x:00000E7C
.text$x:00000E7C
.text$x:00000E7C __unwindfunclet$?updateMenu@LastRecentFileList@@QAEXXZ$1 proc near
.text$x:00000E7C                                         ; DATA XREF: .xdata$x:00006F1Co
.text$x:00000E7C                 lea     ecx, [ebp-80h]
.text$x:00000E7F                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00000E7F __unwindfunclet$?updateMenu@LastRecentFileList@@QAEXXZ$1 endp
.text$x:00000E7F
.text$x:00000E84
.text$x:00000E84 ; =============== S U B R O U T I N E =======================================
.text$x:00000E84
.text$x:00000E84
.text$x:00000E84 __unwindfunclet$?updateMenu@LastRecentFileList@@QAEXXZ$2 proc near
.text$x:00000E84                                         ; DATA XREF: .xdata$x:00006F24o
.text$x:00000E84                 lea     ecx, [ebp-64h]
.text$x:00000E87                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00000E87 __unwindfunclet$?updateMenu@LastRecentFileList@@QAEXXZ$2 endp
.text$x:00000E87
.text$x:00000E8C
.text$x:00000E8C ; =============== S U B R O U T I N E =======================================
.text$x:00000E8C
.text$x:00000E8C
.text$x:00000E8C __unwindfunclet$?updateMenu@LastRecentFileList@@QAEXXZ$3 proc near
.text$x:00000E8C                                         ; DATA XREF: .xdata$x:00006F2Co
.text$x:00000E8C                 lea     ecx, [ebp-2Ch]
.text$x:00000E8F                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00000E8F __unwindfunclet$?updateMenu@LastRecentFileList@@QAEXXZ$3 endp
.text$x:00000E8F
.text$x:00000E94
.text$x:00000E94 ; =============== S U B R O U T I N E =======================================
.text$x:00000E94
.text$x:00000E94
.text$x:00000E94 __unwindfunclet$?updateMenu@LastRecentFileList@@QAEXXZ$4 proc near
.text$x:00000E94                                         ; DATA XREF: .xdata$x:00006F34o
.text$x:00000E94                 lea     ecx, [ebp-9Ch]
.text$x:00000E9A                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00000E9A __unwindfunclet$?updateMenu@LastRecentFileList@@QAEXXZ$4 endp
.text$x:00000E9A
.text$x:00000E9F
.text$x:00000E9F ; =============== S U B R O U T I N E =======================================
.text$x:00000E9F
.text$x:00000E9F
.text$x:00000E9F __ehhandler$?updateMenu@LastRecentFileList@@QAEXXZ proc near
.text$x:00000E9F                                         ; DATA XREF: LastRecentFileList::updateMenu(void)+5o
.text$x:00000E9F
.text$x:00000E9F arg_4           = dword ptr  8
.text$x:00000E9F
.text$x:00000E9F                 mov     edx, [esp+arg_4]
.text$x:00000EA3                 lea     eax, [edx+0Ch]
.text$x:00000EA6                 mov     ecx, [edx-0A8h]
.text$x:00000EAC                 xor     ecx, eax
.text$x:00000EAE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000EB3                 mov     ecx, [edx-4]
.text$x:00000EB6                 xor     ecx, eax
.text$x:00000EB8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000EBD                 mov     eax, offset __ehfuncinfo$?updateMenu@LastRecentFileList@@QAEXXZ
.text$x:00000EC2                 jmp     ___CxxFrameHandler3
.text$x:00000EC2 __ehhandler$?updateMenu@LastRecentFileList@@QAEXXZ endp
.text$x:00000EC2
.text$x:00000EC7
.text$x:00000EC7 ; =============== S U B R O U T I N E =======================================
.text$x:00000EC7
.text$x:00000EC7
.text$x:00000EC7 __unwindfunclet$?add@LastRecentFileList@@QAEXPB_W@Z$0 proc near
.text$x:00000EC7                                         ; DATA XREF: .xdata$x:00006E4Co
.text$x:00000EC7                 lea     ecx, [ebp-30h]  ; this
.text$x:00000ECA                 jmp     ??1RecentItem@@QAE@XZ ; RecentItem::~RecentItem(void)
.text$x:00000ECA __unwindfunclet$?add@LastRecentFileList@@QAEXPB_W@Z$0 endp
.text$x:00000ECA
.text$x:00000ECF
.text$x:00000ECF ; =============== S U B R O U T I N E =======================================
.text$x:00000ECF
.text$x:00000ECF
.text$x:00000ECF __ehhandler$?add@LastRecentFileList@@QAEXPB_W@Z proc near
.text$x:00000ECF                                         ; DATA XREF: LastRecentFileList::add(wchar_t const *)+5o
.text$x:00000ECF
.text$x:00000ECF arg_4           = dword ptr  8
.text$x:00000ECF
.text$x:00000ECF                 mov     edx, [esp+arg_4]
.text$x:00000ED3                 lea     eax, [edx+0Ch]
.text$x:00000ED6                 mov     ecx, [edx-30h]
.text$x:00000ED9                 xor     ecx, eax
.text$x:00000EDB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000EE0                 mov     ecx, [edx-4]
.text$x:00000EE3                 xor     ecx, eax
.text$x:00000EE5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000EEA                 mov     eax, offset __ehfuncinfo$?add@LastRecentFileList@@QAEXPB_W@Z
.text$x:00000EEF                 jmp     ___CxxFrameHandler3
.text$x:00000EEF __ehhandler$?add@LastRecentFileList@@QAEXPB_W@Z endp
.text$x:00000EEF
.text$x:00000EF4
.text$x:00000EF4 ; =============== S U B R O U T I N E =======================================
.text$x:00000EF4
.text$x:00000EF4
.text$x:00000EF4 __unwindfunclet$?remove@LastRecentFileList@@QAEXH@Z$0 proc near
.text$x:00000EF4                                         ; DATA XREF: .xdata$x:00006E6Co
.text$x:00000EF4                 lea     ecx, [ebp-54h]
.text$x:00000EF7                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00000EF7 __unwindfunclet$?remove@LastRecentFileList@@QAEXH@Z$0 endp
.text$x:00000EF7
.text$x:00000EFC
.text$x:00000EFC ; =============== S U B R O U T I N E =======================================
.text$x:00000EFC
.text$x:00000EFC
.text$x:00000EFC __unwindfunclet$?remove@LastRecentFileList@@QAEXH@Z$1 proc near
.text$x:00000EFC                                         ; DATA XREF: .xdata$x:00006E74o
.text$x:00000EFC                 lea     ecx, [ebp-48h]
.text$x:00000EFF                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00000EFF __unwindfunclet$?remove@LastRecentFileList@@QAEXH@Z$1 endp
.text$x:00000EFF
.text$x:00000F04
.text$x:00000F04 ; =============== S U B R O U T I N E =======================================
.text$x:00000F04
.text$x:00000F04
.text$x:00000F04 __unwindfunclet$?remove@LastRecentFileList@@QAEXH@Z$2 proc near
.text$x:00000F04                                         ; DATA XREF: .xdata$x:00006E7Co
.text$x:00000F04                 mov     ecx, [ebp-28h]
.text$x:00000F07                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00000F07 __unwindfunclet$?remove@LastRecentFileList@@QAEXH@Z$2 endp
.text$x:00000F07
.text$x:00000F0C
.text$x:00000F0C ; =============== S U B R O U T I N E =======================================
.text$x:00000F0C
.text$x:00000F0C
.text$x:00000F0C __ehhandler$?remove@LastRecentFileList@@QAEXH@Z proc near
.text$x:00000F0C                                         ; DATA XREF: LastRecentFileList::remove(int)+5o
.text$x:00000F0C
.text$x:00000F0C arg_4           = dword ptr  8
.text$x:00000F0C
.text$x:00000F0C                 mov     edx, [esp+arg_4]
.text$x:00000F10                 lea     eax, [edx+0Ch]
.text$x:00000F13                 mov     ecx, [edx-4Ch]
.text$x:00000F16                 xor     ecx, eax
.text$x:00000F18                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000F1D                 mov     eax, offset __ehfuncinfo$?remove@LastRecentFileList@@QAEXH@Z
.text$x:00000F22                 jmp     ___CxxFrameHandler3
.text$x:00000F22 __ehhandler$?remove@LastRecentFileList@@QAEXH@Z endp
.text$x:00000F22
.text$x:00000F27
.text$x:00000F27 ; =============== S U B R O U T I N E =======================================
.text$x:00000F27
.text$x:00000F27
.text$x:00000F27 __unwindfunclet$?clear@LastRecentFileList@@QAEXXZ$0 proc near
.text$x:00000F27                                         ; DATA XREF: .xdata$x:00006E54o
.text$x:00000F27                 lea     ecx, [ebp-58h]
.text$x:00000F2A                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00000F2A __unwindfunclet$?clear@LastRecentFileList@@QAEXXZ$0 endp
.text$x:00000F2A
.text$x:00000F2F
.text$x:00000F2F ; =============== S U B R O U T I N E =======================================
.text$x:00000F2F
.text$x:00000F2F
.text$x:00000F2F __unwindfunclet$?clear@LastRecentFileList@@QAEXXZ$1 proc near
.text$x:00000F2F                                         ; DATA XREF: .xdata$x:00006E5Co
.text$x:00000F2F                 lea     ecx, [ebp-4Ch]
.text$x:00000F32                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00000F32 __unwindfunclet$?clear@LastRecentFileList@@QAEXXZ$1 endp
.text$x:00000F32
.text$x:00000F37
.text$x:00000F37 ; =============== S U B R O U T I N E =======================================
.text$x:00000F37
.text$x:00000F37
.text$x:00000F37 __unwindfunclet$?clear@LastRecentFileList@@QAEXXZ$2 proc near
.text$x:00000F37                                         ; DATA XREF: .xdata$x:00006E64o
.text$x:00000F37                 mov     ecx, [ebp-2Ch]
.text$x:00000F3A                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00000F3A __unwindfunclet$?clear@LastRecentFileList@@QAEXXZ$2 endp
.text$x:00000F3A
.text$x:00000F3F
.text$x:00000F3F ; =============== S U B R O U T I N E =======================================
.text$x:00000F3F
.text$x:00000F3F
.text$x:00000F3F __ehhandler$?clear@LastRecentFileList@@QAEXXZ proc near
.text$x:00000F3F                                         ; DATA XREF: LastRecentFileList::clear(void)+5o
.text$x:00000F3F
.text$x:00000F3F arg_4           = dword ptr  8
.text$x:00000F3F
.text$x:00000F3F                 mov     edx, [esp+arg_4]
.text$x:00000F43                 lea     eax, [edx+0Ch]
.text$x:00000F46                 mov     ecx, [edx-50h]
.text$x:00000F49                 xor     ecx, eax
.text$x:00000F4B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000F50                 mov     eax, offset __ehfuncinfo$?clear@LastRecentFileList@@QAEXXZ
.text$x:00000F55                 jmp     ___CxxFrameHandler3
.text$x:00000F55 __ehhandler$?clear@LastRecentFileList@@QAEXXZ endp
.text$x:00000F55
.text$x:00000F55 ; ---------------------------------------------------------------------------
.text$x:00000F5A                 align 4
.text$x:00000F5A _text$x         ends
.text$x:00000F5A
.text$mn:00000F5C ; ===========================================================================
.text$mn:00000F5C
.text$mn:00000F5C ; Segment type: Pure code
.text$mn:00000F5C ; Segment permissions: Read/Execute
.text$mn:00000F5C _text$mn        segment para public 'CODE' use32
.text$mn:00000F5C                 assume cs:_text$mn
.text$mn:00000F5C                 ;org 0F5Ch
.text$mn:00000F5C ; COMDAT (pick any)
.text$mn:00000F5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F5C
.text$mn:00000F5C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F5C
.text$mn:00000F5C ; Attributes: bp-based frame
.text$mn:00000F5C
.text$mn:00000F5C ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct RecentItem *>>::_Wrap_alloc<class std::allocator<struct RecentItem *>>(struct std::_Wrap_alloc<class std::allocator<struct RecentItem>> const &)
.text$mn:00000F5C                 public ??$?0U?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@1@@Z
.text$mn:00000F5C ??$?0U?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@1@@Z proc near
.text$mn:00000F5C                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+19p
.text$mn:00000F5C
.text$mn:00000F5C var_4           = dword ptr -4
.text$mn:00000F5C arg_0           = dword ptr  8
.text$mn:00000F5C
.text$mn:00000F5C                 push    ebp
.text$mn:00000F5D                 mov     ebp, esp
.text$mn:00000F5F                 push    ecx
.text$mn:00000F60                 mov     [ebp+var_4], ecx
.text$mn:00000F63                 mov     eax, [ebp+arg_0]
.text$mn:00000F66                 push    eax
.text$mn:00000F67                 mov     ecx, [ebp+var_4]
.text$mn:00000F6A                 call    ??$?0URecentItem@@@?$allocator@PAURecentItem@@@std@@QAE@ABV?$allocator@URecentItem@@@1@@Z ; std::allocator<RecentItem *>::allocator<RecentItem *>(std::allocator<RecentItem> const &)
.text$mn:00000F6F                 mov     eax, [ebp+var_4]
.text$mn:00000F72                 mov     esp, ebp
.text$mn:00000F74                 pop     ebp
.text$mn:00000F75                 retn    4
.text$mn:00000F75 ??$?0U?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@1@@Z endp
.text$mn:00000F75
.text$mn:00000F75 _text$mn        ends
.text$mn:00000F75
.text$mn:00000F78 ; ===========================================================================
.text$mn:00000F78
.text$mn:00000F78 ; Segment type: Pure code
.text$mn:00000F78 ; Segment permissions: Read/Execute
.text$mn:00000F78 _text$mn        segment para public 'CODE' use32
.text$mn:00000F78                 assume cs:_text$mn
.text$mn:00000F78                 ;org 0F78h
.text$mn:00000F78 ; COMDAT (pick any)
.text$mn:00000F78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F78
.text$mn:00000F78 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F78
.text$mn:00000F78 ; Attributes: bp-based frame
.text$mn:00000F78
.text$mn:00000F78 ; public: __thiscall std::allocator<struct RecentItem *>::allocator<struct RecentItem *>(class std::allocator<struct RecentItem> const &)
.text$mn:00000F78                 public ??$?0URecentItem@@@?$allocator@PAURecentItem@@@std@@QAE@ABV?$allocator@URecentItem@@@1@@Z
.text$mn:00000F78 ??$?0URecentItem@@@?$allocator@PAURecentItem@@@std@@QAE@ABV?$allocator@URecentItem@@@1@@Z proc near
.text$mn:00000F78                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<RecentItem *>>::_Wrap_alloc<std::allocator<RecentItem *>>(std::_Wrap_alloc<std::allocator<RecentItem>> const &)+Ep
.text$mn:00000F78
.text$mn:00000F78 var_4           = dword ptr -4
.text$mn:00000F78
.text$mn:00000F78                 push    ebp
.text$mn:00000F79                 mov     ebp, esp
.text$mn:00000F7B                 push    ecx
.text$mn:00000F7C                 mov     [ebp+var_4], ecx
.text$mn:00000F7F                 mov     eax, [ebp+var_4]
.text$mn:00000F82                 mov     esp, ebp
.text$mn:00000F84                 pop     ebp
.text$mn:00000F85                 retn    4
.text$mn:00000F85 ??$?0URecentItem@@@?$allocator@PAURecentItem@@@std@@QAE@ABV?$allocator@URecentItem@@@1@@Z endp
.text$mn:00000F85
.text$mn:00000F85 _text$mn        ends
.text$mn:00000F85
.text$mn:00000F88 ; ===========================================================================
.text$mn:00000F88
.text$mn:00000F88 ; Segment type: Pure code
.text$mn:00000F88 ; Segment permissions: Read/Execute
.text$mn:00000F88 _text$mn        segment para public 'CODE' use32
.text$mn:00000F88                 assume cs:_text$mn
.text$mn:00000F88                 ;org 0F88h
.text$mn:00000F88 ; COMDAT (pick any)
.text$mn:00000F88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F88
.text$mn:00000F88 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F88
.text$mn:00000F88 ; Attributes: bp-based frame
.text$mn:00000F88
.text$mn:00000F88 ; bool __cdecl std::operator==<class std::allocator<wchar_t>, class std::allocator<wchar_t>>(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &, struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:00000F88                 public ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
.text$mn:00000F88 ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z proc near
.text$mn:00000F88                                         ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+Cp
.text$mn:00000F88
.text$mn:00000F88 var_2           = byte ptr -2
.text$mn:00000F88 var_1           = byte ptr -1
.text$mn:00000F88 arg_0           = dword ptr  8
.text$mn:00000F88 arg_4           = dword ptr  0Ch
.text$mn:00000F88
.text$mn:00000F88                 push    ebp
.text$mn:00000F89                 mov     ebp, esp
.text$mn:00000F8B                 push    ecx
.text$mn:00000F8C                 mov     eax, [ebp+arg_4]
.text$mn:00000F8F                 push    eax
.text$mn:00000F90                 lea     ecx, [ebp+var_1]
.text$mn:00000F93                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00000F98                 push    eax
.text$mn:00000F99                 mov     ecx, [ebp+arg_0]
.text$mn:00000F9C                 push    ecx
.text$mn:00000F9D                 lea     ecx, [ebp+var_2]
.text$mn:00000FA0                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00000FA5                 push    eax
.text$mn:00000FA6                 call    ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z ; std::operator==<wchar_t,wchar_t>(std::allocator<wchar_t> const &,std::allocator<wchar_t> const &)
.text$mn:00000FAB                 add     esp, 8
.text$mn:00000FAE                 mov     esp, ebp
.text$mn:00000FB0                 pop     ebp
.text$mn:00000FB1                 retn
.text$mn:00000FB1 ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z endp
.text$mn:00000FB1
.text$mn:00000FB1 ; ---------------------------------------------------------------------------
.text$mn:00000FB2                 align 4
.text$mn:00000FB2 _text$mn        ends
.text$mn:00000FB2
.text$mn:00000FB4 ; ===========================================================================
.text$mn:00000FB4
.text$mn:00000FB4 ; Segment type: Pure code
.text$mn:00000FB4 ; Segment permissions: Read/Execute
.text$mn:00000FB4 _text$mn        segment para public 'CODE' use32
.text$mn:00000FB4                 assume cs:_text$mn
.text$mn:00000FB4                 ;org 0FB4h
.text$mn:00000FB4 ; COMDAT (pick any)
.text$mn:00000FB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FB4
.text$mn:00000FB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FB4
.text$mn:00000FB4 ; Attributes: bp-based frame
.text$mn:00000FB4
.text$mn:00000FB4 ; int __cdecl std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, wchar_t *Str)
.text$mn:00000FB4                 public ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z
.text$mn:00000FB4 ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z proc near
.text$mn:00000FB4                                         ; CODE XREF: LastRecentFileList::updateMenu(void)+DBp
.text$mn:00000FB4                                         ; LastRecentFileList::updateMenu(void)+100p ...
.text$mn:00000FB4
.text$mn:00000FB4 var_4           = dword ptr -4
.text$mn:00000FB4 arg_0           = dword ptr  8
.text$mn:00000FB4 Str             = dword ptr  0Ch
.text$mn:00000FB4
.text$mn:00000FB4                 push    ebp
.text$mn:00000FB5                 mov     ebp, esp
.text$mn:00000FB7                 push    ecx
.text$mn:00000FB8                 mov     eax, [ebp+Str]
.text$mn:00000FBB                 push    eax             ; Str
.text$mn:00000FBC                 mov     ecx, [ebp+arg_0]
.text$mn:00000FBF                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)
.text$mn:00000FC4                 test    eax, eax
.text$mn:00000FC6                 jnz     short loc_FD1
.text$mn:00000FC8                 mov     [ebp+var_4], 1
.text$mn:00000FCF                 jmp     short loc_FD8
.text$mn:00000FD1 ; ---------------------------------------------------------------------------
.text$mn:00000FD1
.text$mn:00000FD1 loc_FD1:                                ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+12j
.text$mn:00000FD1                 mov     [ebp+var_4], 0
.text$mn:00000FD8
.text$mn:00000FD8 loc_FD8:                                ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+1Bj
.text$mn:00000FD8                 mov     al, byte ptr [ebp+var_4]
.text$mn:00000FDB                 mov     esp, ebp
.text$mn:00000FDD                 pop     ebp
.text$mn:00000FDE                 retn
.text$mn:00000FDE ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z endp
.text$mn:00000FDE
.text$mn:00000FDE ; ---------------------------------------------------------------------------
.text$mn:00000FDF                 align 10h
.text$mn:00000FDF _text$mn        ends
.text$mn:00000FDF
.text$mn:00000FE0 ; ===========================================================================
.text$mn:00000FE0
.text$mn:00000FE0 ; Segment type: Pure code
.text$mn:00000FE0 ; Segment permissions: Read/Execute
.text$mn:00000FE0 _text$mn        segment para public 'CODE' use32
.text$mn:00000FE0                 assume cs:_text$mn
.text$mn:00000FE0                 ;org 0FE0h
.text$mn:00000FE0 ; COMDAT (pick any)
.text$mn:00000FE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FE0
.text$mn:00000FE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FE0
.text$mn:00000FE0 ; Attributes: bp-based frame
.text$mn:00000FE0
.text$mn:00000FE0 ; bool __cdecl std::operator==<wchar_t, wchar_t>(class std::allocator<wchar_t> const &, class std::allocator<wchar_t> const &)
.text$mn:00000FE0                 public ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z
.text$mn:00000FE0 ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z proc near
.text$mn:00000FE0                                         ; CODE XREF: std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+1Ep
.text$mn:00000FE0                 push    ebp
.text$mn:00000FE1                 mov     ebp, esp
.text$mn:00000FE3                 mov     al, 1
.text$mn:00000FE5                 pop     ebp
.text$mn:00000FE6                 retn
.text$mn:00000FE6 ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z endp
.text$mn:00000FE6
.text$mn:00000FE6 ; ---------------------------------------------------------------------------
.text$mn:00000FE7                 align 4
.text$mn:00000FE7 _text$mn        ends
.text$mn:00000FE7
.text$mn:00000FE8 ; ===========================================================================
.text$mn:00000FE8
.text$mn:00000FE8 ; Segment type: Pure code
.text$mn:00000FE8 ; Segment permissions: Read/Execute
.text$mn:00000FE8 _text$mn        segment para public 'CODE' use32
.text$mn:00000FE8                 assume cs:_text$mn
.text$mn:00000FE8                 ;org 0FE8h
.text$mn:00000FE8 ; COMDAT (pick any)
.text$mn:00000FE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FE8
.text$mn:00000FE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FE8
.text$mn:00000FE8 ; Attributes: bp-based frame
.text$mn:00000FE8
.text$mn:00000FE8 ; bool __cdecl std::operator!=<class std::allocator<wchar_t>, class std::allocator<wchar_t>>(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &, struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:00000FE8                 public ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
.text$mn:00000FE8 ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z proc near
.text$mn:00000FE8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+2Bp
.text$mn:00000FE8
.text$mn:00000FE8 var_4           = dword ptr -4
.text$mn:00000FE8 arg_0           = dword ptr  8
.text$mn:00000FE8 arg_4           = dword ptr  0Ch
.text$mn:00000FE8
.text$mn:00000FE8                 push    ebp
.text$mn:00000FE9                 mov     ebp, esp
.text$mn:00000FEB                 push    ecx
.text$mn:00000FEC                 mov     eax, [ebp+arg_4]
.text$mn:00000FEF                 push    eax
.text$mn:00000FF0                 mov     ecx, [ebp+arg_0]
.text$mn:00000FF3                 push    ecx
.text$mn:00000FF4                 call    ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00000FF9                 add     esp, 8
.text$mn:00000FFC                 movzx   edx, al
.text$mn:00000FFF                 test    edx, edx
.text$mn:00001001                 jnz     short loc_100C
.text$mn:00001003                 mov     [ebp+var_4], 1
.text$mn:0000100A                 jmp     short loc_1013
.text$mn:0000100C ; ---------------------------------------------------------------------------
.text$mn:0000100C
.text$mn:0000100C loc_100C:                               ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+19j
.text$mn:0000100C                 mov     [ebp+var_4], 0
.text$mn:00001013
.text$mn:00001013 loc_1013:                               ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+22j
.text$mn:00001013                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001016                 mov     esp, ebp
.text$mn:00001018                 pop     ebp
.text$mn:00001019                 retn
.text$mn:00001019 ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z endp
.text$mn:00001019
.text$mn:00001019 ; ---------------------------------------------------------------------------
.text$mn:0000101A                 align 4
.text$mn:0000101A _text$mn        ends
.text$mn:0000101A
.text$mn:0000101C ; ===========================================================================
.text$mn:0000101C
.text$mn:0000101C ; Segment type: Pure code
.text$mn:0000101C ; Segment permissions: Read/Execute
.text$mn:0000101C _text$mn        segment para public 'CODE' use32
.text$mn:0000101C                 assume cs:_text$mn
.text$mn:0000101C                 ;org 101Ch
.text$mn:0000101C ; COMDAT (pick any)
.text$mn:0000101C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000101C
.text$mn:0000101C ; =============== S U B R O U T I N E =======================================
.text$mn:0000101C
.text$mn:0000101C ; Attributes: bp-based frame
.text$mn:0000101C
.text$mn:0000101C ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:0000101C                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:0000101C ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:0000101C                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:0000101C
.text$mn:0000101C var_4           = dword ptr -4
.text$mn:0000101C arg_0           = dword ptr  8
.text$mn:0000101C
.text$mn:0000101C                 push    ebp
.text$mn:0000101D                 mov     ebp, esp
.text$mn:0000101F                 push    ecx
.text$mn:00001020                 mov     [ebp+var_4], 0
.text$mn:00001027                 cmp     [ebp+arg_0], 0
.text$mn:0000102B                 jnz     short loc_102F
.text$mn:0000102D                 jmp     short loc_104F
.text$mn:0000102F ; ---------------------------------------------------------------------------
.text$mn:0000102F
.text$mn:0000102F loc_102F:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:0000102F                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00001033                 ja      short loc_104A
.text$mn:00001035                 mov     eax, [ebp+arg_0]
.text$mn:00001038                 push    eax             ; unsigned int
.text$mn:00001039                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000103E                 add     esp, 4
.text$mn:00001041                 mov     [ebp+var_4], eax
.text$mn:00001044                 cmp     [ebp+var_4], 0
.text$mn:00001048                 jnz     short loc_104F
.text$mn:0000104A
.text$mn:0000104A loc_104A:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:0000104A                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:0000104F
.text$mn:0000104F loc_104F:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:0000104F                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:0000104F                 mov     eax, [ebp+var_4]
.text$mn:00001052                 mov     esp, ebp
.text$mn:00001054                 pop     ebp
.text$mn:00001055                 retn
.text$mn:00001055 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00001055
.text$mn:00001055 ; ---------------------------------------------------------------------------
.text$mn:00001056                 align 4
.text$mn:00001056 _text$mn        ends
.text$mn:00001056
.text$mn:00001058 ; ===========================================================================
.text$mn:00001058
.text$mn:00001058 ; Segment type: Pure code
.text$mn:00001058 ; Segment permissions: Read/Execute
.text$mn:00001058 _text$mn        segment para public 'CODE' use32
.text$mn:00001058                 assume cs:_text$mn
.text$mn:00001058                 ;org 1058h
.text$mn:00001058 ; COMDAT (pick any)
.text$mn:00001058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001058
.text$mn:00001058 ; =============== S U B R O U T I N E =======================================
.text$mn:00001058
.text$mn:00001058 ; Attributes: bp-based frame
.text$mn:00001058
.text$mn:00001058 ; struct RecentItem * * __cdecl std::_Allocate<struct RecentItem *>(unsigned int, struct RecentItem * *)
.text$mn:00001058                 public ??$_Allocate@PAURecentItem@@@std@@YAPAPAURecentItem@@IPAPAU1@@Z
.text$mn:00001058 ??$_Allocate@PAURecentItem@@@std@@YAPAPAURecentItem@@IPAPAU1@@Z proc near
.text$mn:00001058                                         ; CODE XREF: std::allocator<RecentItem *>::allocate(uint)+Dp
.text$mn:00001058
.text$mn:00001058 var_4           = dword ptr -4
.text$mn:00001058 arg_0           = dword ptr  8
.text$mn:00001058
.text$mn:00001058                 push    ebp
.text$mn:00001059                 mov     ebp, esp
.text$mn:0000105B                 push    ecx
.text$mn:0000105C                 mov     [ebp+var_4], 0
.text$mn:00001063                 cmp     [ebp+arg_0], 0
.text$mn:00001067                 jnz     short loc_106B
.text$mn:00001069                 jmp     short loc_1091
.text$mn:0000106B ; ---------------------------------------------------------------------------
.text$mn:0000106B
.text$mn:0000106B loc_106B:                               ; CODE XREF: std::_Allocate<RecentItem *>(uint,RecentItem * *)+Fj
.text$mn:0000106B                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:00001072                 ja      short loc_108C
.text$mn:00001074                 mov     eax, [ebp+arg_0]
.text$mn:00001077                 shl     eax, 2
.text$mn:0000107A                 push    eax             ; unsigned int
.text$mn:0000107B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001080                 add     esp, 4
.text$mn:00001083                 mov     [ebp+var_4], eax
.text$mn:00001086                 cmp     [ebp+var_4], 0
.text$mn:0000108A                 jnz     short loc_1091
.text$mn:0000108C
.text$mn:0000108C loc_108C:                               ; CODE XREF: std::_Allocate<RecentItem *>(uint,RecentItem * *)+1Aj
.text$mn:0000108C                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001091
.text$mn:00001091 loc_1091:                               ; CODE XREF: std::_Allocate<RecentItem *>(uint,RecentItem * *)+11j
.text$mn:00001091                                         ; std::_Allocate<RecentItem *>(uint,RecentItem * *)+32j
.text$mn:00001091                 mov     eax, [ebp+var_4]
.text$mn:00001094                 mov     esp, ebp
.text$mn:00001096                 pop     ebp
.text$mn:00001097                 retn
.text$mn:00001097 ??$_Allocate@PAURecentItem@@@std@@YAPAPAURecentItem@@IPAPAU1@@Z endp
.text$mn:00001097
.text$mn:00001097 _text$mn        ends
.text$mn:00001097
.text$mn:00001098 ; ===========================================================================
.text$mn:00001098
.text$mn:00001098 ; Segment type: Pure code
.text$mn:00001098 ; Segment permissions: Read/Execute
.text$mn:00001098 _text$mn        segment para public 'CODE' use32
.text$mn:00001098                 assume cs:_text$mn
.text$mn:00001098                 ;org 1098h
.text$mn:00001098 ; COMDAT (pick any)
.text$mn:00001098                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001098
.text$mn:00001098 ; =============== S U B R O U T I N E =======================================
.text$mn:00001098
.text$mn:00001098 ; Attributes: bp-based frame
.text$mn:00001098
.text$mn:00001098 ; struct RecentItem * __cdecl std::_Allocate<struct RecentItem>(unsigned int, struct RecentItem *)
.text$mn:00001098                 public ??$_Allocate@URecentItem@@@std@@YAPAURecentItem@@IPAU1@@Z
.text$mn:00001098 ??$_Allocate@URecentItem@@@std@@YAPAURecentItem@@IPAU1@@Z proc near
.text$mn:00001098                                         ; CODE XREF: std::allocator<RecentItem>::allocate(uint)+Dp
.text$mn:00001098
.text$mn:00001098 var_4           = dword ptr -4
.text$mn:00001098 arg_0           = dword ptr  8
.text$mn:00001098
.text$mn:00001098                 push    ebp
.text$mn:00001099                 mov     ebp, esp
.text$mn:0000109B                 push    ecx
.text$mn:0000109C                 mov     [ebp+var_4], 0
.text$mn:000010A3                 cmp     [ebp+arg_0], 0
.text$mn:000010A7                 jnz     short loc_10AB
.text$mn:000010A9                 jmp     short loc_10D1
.text$mn:000010AB ; ---------------------------------------------------------------------------
.text$mn:000010AB
.text$mn:000010AB loc_10AB:                               ; CODE XREF: std::_Allocate<RecentItem>(uint,RecentItem *)+Fj
.text$mn:000010AB                 cmp     [ebp+arg_0], 7FFFFFFh
.text$mn:000010B2                 ja      short loc_10CC
.text$mn:000010B4                 mov     eax, [ebp+arg_0]
.text$mn:000010B7                 shl     eax, 5
.text$mn:000010BA                 push    eax             ; unsigned int
.text$mn:000010BB                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000010C0                 add     esp, 4
.text$mn:000010C3                 mov     [ebp+var_4], eax
.text$mn:000010C6                 cmp     [ebp+var_4], 0
.text$mn:000010CA                 jnz     short loc_10D1
.text$mn:000010CC
.text$mn:000010CC loc_10CC:                               ; CODE XREF: std::_Allocate<RecentItem>(uint,RecentItem *)+1Aj
.text$mn:000010CC                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000010D1
.text$mn:000010D1 loc_10D1:                               ; CODE XREF: std::_Allocate<RecentItem>(uint,RecentItem *)+11j
.text$mn:000010D1                                         ; std::_Allocate<RecentItem>(uint,RecentItem *)+32j
.text$mn:000010D1                 mov     eax, [ebp+var_4]
.text$mn:000010D4                 mov     esp, ebp
.text$mn:000010D6                 pop     ebp
.text$mn:000010D7                 retn
.text$mn:000010D7 ??$_Allocate@URecentItem@@@std@@YAPAURecentItem@@IPAU1@@Z endp
.text$mn:000010D7
.text$mn:000010D7 _text$mn        ends
.text$mn:000010D7
.text$mn:000010D8 ; ===========================================================================
.text$mn:000010D8
.text$mn:000010D8 ; Segment type: Pure code
.text$mn:000010D8 ; Segment permissions: Read/Execute
.text$mn:000010D8 _text$mn        segment para public 'CODE' use32
.text$mn:000010D8                 assume cs:_text$mn
.text$mn:000010D8                 ;org 10D8h
.text$mn:000010D8 ; COMDAT (pick any)
.text$mn:000010D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010D8
.text$mn:000010D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000010D8
.text$mn:000010D8 ; Attributes: bp-based frame
.text$mn:000010D8
.text$mn:000010D8 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000010D8                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000010D8 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000010D8                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000010D8
.text$mn:000010D8 var_4           = dword ptr -4
.text$mn:000010D8 arg_0           = dword ptr  8
.text$mn:000010D8
.text$mn:000010D8                 push    ebp
.text$mn:000010D9                 mov     ebp, esp
.text$mn:000010DB                 push    ecx
.text$mn:000010DC                 mov     [ebp+var_4], 0
.text$mn:000010E3                 cmp     [ebp+arg_0], 0
.text$mn:000010E7                 jnz     short loc_10EB
.text$mn:000010E9                 jmp     short loc_1111
.text$mn:000010EB ; ---------------------------------------------------------------------------
.text$mn:000010EB
.text$mn:000010EB loc_10EB:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000010EB                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000010F2                 ja      short loc_110C
.text$mn:000010F4                 mov     eax, [ebp+arg_0]
.text$mn:000010F7                 shl     eax, 3
.text$mn:000010FA                 push    eax             ; unsigned int
.text$mn:000010FB                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001100                 add     esp, 4
.text$mn:00001103                 mov     [ebp+var_4], eax
.text$mn:00001106                 cmp     [ebp+var_4], 0
.text$mn:0000110A                 jnz     short loc_1111
.text$mn:0000110C
.text$mn:0000110C loc_110C:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:0000110C                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001111
.text$mn:00001111 loc_1111:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00001111                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00001111                 mov     eax, [ebp+var_4]
.text$mn:00001114                 mov     esp, ebp
.text$mn:00001116                 pop     ebp
.text$mn:00001117                 retn
.text$mn:00001117 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00001117
.text$mn:00001117 _text$mn        ends
.text$mn:00001117
.text$mn:00001118 ; ===========================================================================
.text$mn:00001118
.text$mn:00001118 ; Segment type: Pure code
.text$mn:00001118 ; Segment permissions: Read/Execute
.text$mn:00001118 _text$mn        segment para public 'CODE' use32
.text$mn:00001118                 assume cs:_text$mn
.text$mn:00001118                 ;org 1118h
.text$mn:00001118 ; COMDAT (pick any)
.text$mn:00001118                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001118
.text$mn:00001118 ; =============== S U B R O U T I N E =======================================
.text$mn:00001118
.text$mn:00001118 ; Attributes: bp-based frame
.text$mn:00001118
.text$mn:00001118 ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:00001118                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:00001118 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:00001118                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:00001118
.text$mn:00001118 var_4           = dword ptr -4
.text$mn:00001118 arg_0           = dword ptr  8
.text$mn:00001118
.text$mn:00001118                 push    ebp
.text$mn:00001119                 mov     ebp, esp
.text$mn:0000111B                 push    ecx
.text$mn:0000111C                 mov     [ebp+var_4], 0
.text$mn:00001123                 cmp     [ebp+arg_0], 0
.text$mn:00001127                 jnz     short loc_112B
.text$mn:00001129                 jmp     short loc_1150
.text$mn:0000112B ; ---------------------------------------------------------------------------
.text$mn:0000112B
.text$mn:0000112B loc_112B:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:0000112B                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:00001132                 ja      short loc_114B
.text$mn:00001134                 mov     eax, [ebp+arg_0]
.text$mn:00001137                 shl     eax, 1
.text$mn:00001139                 push    eax             ; unsigned int
.text$mn:0000113A                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000113F                 add     esp, 4
.text$mn:00001142                 mov     [ebp+var_4], eax
.text$mn:00001145                 cmp     [ebp+var_4], 0
.text$mn:00001149                 jnz     short loc_1150
.text$mn:0000114B
.text$mn:0000114B loc_114B:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:0000114B                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001150
.text$mn:00001150 loc_1150:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:00001150                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:00001150                 mov     eax, [ebp+var_4]
.text$mn:00001153                 mov     esp, ebp
.text$mn:00001155                 pop     ebp
.text$mn:00001156                 retn
.text$mn:00001156 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:00001156
.text$mn:00001156 ; ---------------------------------------------------------------------------
.text$mn:00001157                 align 4
.text$mn:00001157 _text$mn        ends
.text$mn:00001157
.text$mn:00001158 ; ===========================================================================
.text$mn:00001158
.text$mn:00001158 ; Segment type: Pure code
.text$mn:00001158 ; Segment permissions: Read/Execute
.text$mn:00001158 _text$mn        segment para public 'CODE' use32
.text$mn:00001158                 assume cs:_text$mn
.text$mn:00001158                 ;org 1158h
.text$mn:00001158 ; COMDAT (pick any)
.text$mn:00001158                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001158
.text$mn:00001158 ; =============== S U B R O U T I N E =======================================
.text$mn:00001158
.text$mn:00001158 ; Attributes: bp-based frame
.text$mn:00001158
.text$mn:00001158 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00001158                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00001158 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00001158                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00001158                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00001158
.text$mn:00001158 arg_0           = dword ptr  8
.text$mn:00001158 arg_4           = dword ptr  0Ch
.text$mn:00001158 arg_8           = dword ptr  10h
.text$mn:00001158
.text$mn:00001158                 push    ebp
.text$mn:00001159                 mov     ebp, esp
.text$mn:0000115B                 cmp     [ebp+arg_0], 0
.text$mn:0000115F                 jnz     short loc_1176
.text$mn:00001161                 mov     eax, [ebp+arg_8]
.text$mn:00001164                 push    eax             ; unsigned int
.text$mn:00001165                 mov     ecx, [ebp+arg_4]
.text$mn:00001168                 push    ecx             ; wchar_t *
.text$mn:00001169                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000116E                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001173                 add     esp, 0Ch
.text$mn:00001176
.text$mn:00001176 loc_1176:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00001176                 pop     ebp
.text$mn:00001177                 retn
.text$mn:00001177 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00001177
.text$mn:00001177 _text$mn        ends
.text$mn:00001177
.text$mn:00001178 ; ===========================================================================
.text$mn:00001178
.text$mn:00001178 ; Segment type: Pure code
.text$mn:00001178 ; Segment permissions: Read/Execute
.text$mn:00001178 _text$mn        segment para public 'CODE' use32
.text$mn:00001178                 assume cs:_text$mn
.text$mn:00001178                 ;org 1178h
.text$mn:00001178 ; COMDAT (pick any)
.text$mn:00001178                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001178
.text$mn:00001178 ; =============== S U B R O U T I N E =======================================
.text$mn:00001178
.text$mn:00001178 ; Attributes: bp-based frame
.text$mn:00001178
.text$mn:00001178 ; int __cdecl std::_Debug_pointer<RecentItem *>(int, wchar_t *, unsigned int)
.text$mn:00001178                 public ??$_Debug_pointer@PAURecentItem@@@std@@YAXPAPAURecentItem@@PB_WI@Z
.text$mn:00001178 ??$_Debug_pointer@PAURecentItem@@@std@@YAXPAPAURecentItem@@PB_WI@Z proc near
.text$mn:00001178                                         ; CODE XREF: std::_Debug_range2<RecentItem * *>(RecentItem * *,RecentItem * *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00001178                                         ; std::_Debug_range2<RecentItem * *>(RecentItem * *,RecentItem * *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00001178
.text$mn:00001178 arg_0           = dword ptr  8
.text$mn:00001178 arg_4           = dword ptr  0Ch
.text$mn:00001178 arg_8           = dword ptr  10h
.text$mn:00001178
.text$mn:00001178                 push    ebp
.text$mn:00001179                 mov     ebp, esp
.text$mn:0000117B                 cmp     [ebp+arg_0], 0
.text$mn:0000117F                 jnz     short loc_1196
.text$mn:00001181                 mov     eax, [ebp+arg_8]
.text$mn:00001184                 push    eax             ; unsigned int
.text$mn:00001185                 mov     ecx, [ebp+arg_4]
.text$mn:00001188                 push    ecx             ; wchar_t *
.text$mn:00001189                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000118E                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001193                 add     esp, 0Ch
.text$mn:00001196
.text$mn:00001196 loc_1196:                               ; CODE XREF: std::_Debug_pointer<RecentItem *>(RecentItem * *,wchar_t const *,uint)+7j
.text$mn:00001196                 pop     ebp
.text$mn:00001197                 retn
.text$mn:00001197 ??$_Debug_pointer@PAURecentItem@@@std@@YAXPAPAURecentItem@@PB_WI@Z endp
.text$mn:00001197
.text$mn:00001197 _text$mn        ends
.text$mn:00001197
.text$mn:00001198 ; ===========================================================================
.text$mn:00001198
.text$mn:00001198 ; Segment type: Pure code
.text$mn:00001198 ; Segment permissions: Read/Execute
.text$mn:00001198 _text$mn        segment para public 'CODE' use32
.text$mn:00001198                 assume cs:_text$mn
.text$mn:00001198                 ;org 1198h
.text$mn:00001198 ; COMDAT (pick any)
.text$mn:00001198                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001198
.text$mn:00001198 ; =============== S U B R O U T I N E =======================================
.text$mn:00001198
.text$mn:00001198 ; Attributes: bp-based frame
.text$mn:00001198
.text$mn:00001198 ; void __cdecl std::_Debug_pointer<class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>>(class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> &, wchar_t const *, unsigned int)
.text$mn:00001198                 public ??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@PB_WI@Z
.text$mn:00001198 ??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@PB_WI@Z proc near
.text$mn:00001198                                         ; CODE XREF: std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,wchar_t const *,uint,std::random_access_iterator_tag)+48p
.text$mn:00001198                                         ; std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,wchar_t const *,uint,std::random_access_iterator_tag)+5Cp
.text$mn:00001198                 push    ebp
.text$mn:00001199                 mov     ebp, esp
.text$mn:0000119B                 pop     ebp
.text$mn:0000119C                 retn
.text$mn:0000119C ??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@PB_WI@Z endp
.text$mn:0000119C
.text$mn:0000119C ; ---------------------------------------------------------------------------
.text$mn:0000119D                 align 10h
.text$mn:0000119D _text$mn        ends
.text$mn:0000119D
.text$mn:000011A0 ; ===========================================================================
.text$mn:000011A0
.text$mn:000011A0 ; Segment type: Pure code
.text$mn:000011A0 ; Segment permissions: Read/Execute
.text$mn:000011A0 _text$mn        segment para public 'CODE' use32
.text$mn:000011A0                 assume cs:_text$mn
.text$mn:000011A0                 ;org 11A0h
.text$mn:000011A0 ; COMDAT (pick any)
.text$mn:000011A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011A0
.text$mn:000011A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000011A0
.text$mn:000011A0 ; Attributes: bp-based frame
.text$mn:000011A0
.text$mn:000011A0 ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:000011A0                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:000011A0 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:000011A0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+15p
.text$mn:000011A0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+1Bp ...
.text$mn:000011A0
.text$mn:000011A0 arg_0           = dword ptr  8
.text$mn:000011A0 arg_4           = dword ptr  0Ch
.text$mn:000011A0 arg_8           = dword ptr  10h
.text$mn:000011A0
.text$mn:000011A0                 push    ebp
.text$mn:000011A1                 mov     ebp, esp
.text$mn:000011A3                 cmp     [ebp+arg_0], 0
.text$mn:000011A7                 jnz     short loc_11BE
.text$mn:000011A9                 mov     eax, [ebp+arg_8]
.text$mn:000011AC                 push    eax             ; unsigned int
.text$mn:000011AD                 mov     ecx, [ebp+arg_4]
.text$mn:000011B0                 push    ecx             ; wchar_t *
.text$mn:000011B1                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000011B6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000011BB                 add     esp, 0Ch
.text$mn:000011BE
.text$mn:000011BE loc_11BE:                               ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:000011BE                 pop     ebp
.text$mn:000011BF                 retn
.text$mn:000011BF ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:000011BF
.text$mn:000011BF _text$mn        ends
.text$mn:000011BF
.text$mn:000011C0 ; ===========================================================================
.text$mn:000011C0
.text$mn:000011C0 ; Segment type: Pure code
.text$mn:000011C0 ; Segment permissions: Read/Execute
.text$mn:000011C0 _text$mn        segment para public 'CODE' use32
.text$mn:000011C0                 assume cs:_text$mn
.text$mn:000011C0                 ;org 11C0h
.text$mn:000011C0 ; COMDAT (pick any)
.text$mn:000011C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011C0
.text$mn:000011C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000011C0
.text$mn:000011C0 ; Attributes: bp-based frame
.text$mn:000011C0
.text$mn:000011C0 ; int __cdecl std::_Debug_range2<RecentItem * *>(int, int, wchar_t *, unsigned int)
.text$mn:000011C0                 public ??$_Debug_range2@PAPAURecentItem@@@std@@YAXPAPAURecentItem@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000011C0 ??$_Debug_range2@PAPAURecentItem@@@std@@YAXPAPAURecentItem@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:000011C0                                         ; CODE XREF: std::_Debug_range<RecentItem * *>(RecentItem * *,RecentItem * *,wchar_t const *,uint)+2Ap
.text$mn:000011C0
.text$mn:000011C0 arg_0           = dword ptr  8
.text$mn:000011C0 arg_4           = dword ptr  0Ch
.text$mn:000011C0 arg_8           = dword ptr  10h
.text$mn:000011C0 arg_C           = dword ptr  14h
.text$mn:000011C0
.text$mn:000011C0                 push    ebp
.text$mn:000011C1                 mov     ebp, esp
.text$mn:000011C3                 mov     eax, [ebp+arg_0]
.text$mn:000011C6                 cmp     eax, [ebp+arg_4]
.text$mn:000011C9                 jz      short loc_1210
.text$mn:000011CB                 mov     ecx, [ebp+arg_C]
.text$mn:000011CE                 push    ecx             ; unsigned int
.text$mn:000011CF                 mov     edx, [ebp+arg_8]
.text$mn:000011D2                 push    edx             ; wchar_t *
.text$mn:000011D3                 mov     eax, [ebp+arg_0]
.text$mn:000011D6                 push    eax             ; int
.text$mn:000011D7                 call    ??$_Debug_pointer@PAURecentItem@@@std@@YAXPAPAURecentItem@@PB_WI@Z ; std::_Debug_pointer<RecentItem *>(RecentItem * *,wchar_t const *,uint)
.text$mn:000011DC                 add     esp, 0Ch
.text$mn:000011DF                 mov     ecx, [ebp+arg_C]
.text$mn:000011E2                 push    ecx             ; unsigned int
.text$mn:000011E3                 mov     edx, [ebp+arg_8]
.text$mn:000011E6                 push    edx             ; wchar_t *
.text$mn:000011E7                 mov     eax, [ebp+arg_4]
.text$mn:000011EA                 push    eax             ; int
.text$mn:000011EB                 call    ??$_Debug_pointer@PAURecentItem@@@std@@YAXPAPAURecentItem@@PB_WI@Z ; std::_Debug_pointer<RecentItem *>(RecentItem * *,wchar_t const *,uint)
.text$mn:000011F0                 add     esp, 0Ch
.text$mn:000011F3                 mov     ecx, [ebp+arg_4]
.text$mn:000011F6                 cmp     ecx, [ebp+arg_0]
.text$mn:000011F9                 jnb     short loc_1210
.text$mn:000011FB                 mov     edx, [ebp+arg_C]
.text$mn:000011FE                 push    edx             ; unsigned int
.text$mn:000011FF                 mov     eax, [ebp+arg_8]
.text$mn:00001202                 push    eax             ; wchar_t *
.text$mn:00001203                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00001208                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000120D                 add     esp, 0Ch
.text$mn:00001210
.text$mn:00001210 loc_1210:                               ; CODE XREF: std::_Debug_range2<RecentItem * *>(RecentItem * *,RecentItem * *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00001210                                         ; std::_Debug_range2<RecentItem * *>(RecentItem * *,RecentItem * *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00001210                 pop     ebp
.text$mn:00001211                 retn
.text$mn:00001211 ??$_Debug_range2@PAPAURecentItem@@@std@@YAXPAPAURecentItem@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00001211
.text$mn:00001211 ; ---------------------------------------------------------------------------
.text$mn:00001212                 align 4
.text$mn:00001212 _text$mn        ends
.text$mn:00001212
.text$mn:00001214 ; ===========================================================================
.text$mn:00001214
.text$mn:00001214 ; Segment type: Pure code
.text$mn:00001214 ; Segment permissions: Read/Execute
.text$mn:00001214 _text$mn        segment para public 'CODE' use32
.text$mn:00001214                 assume cs:_text$mn
.text$mn:00001214                 ;org 1214h
.text$mn:00001214 ; COMDAT (pick any)
.text$mn:00001214                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001214
.text$mn:00001214 ; =============== S U B R O U T I N E =======================================
.text$mn:00001214
.text$mn:00001214 ; Attributes: bp-based frame
.text$mn:00001214
.text$mn:00001214 ; int __cdecl std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(char, int, int, char, int, int, wchar_t *, unsigned int)
.text$mn:00001214                 public ??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00001214 ??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00001214                                         ; CODE XREF: std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,wchar_t const *,uint)+8Ap
.text$mn:00001214
.text$mn:00001214 var_C           = dword ptr -0Ch
.text$mn:00001214 var_4           = dword ptr -4
.text$mn:00001214 arg_0           = byte ptr  8
.text$mn:00001214 arg_C           = byte ptr  14h
.text$mn:00001214 arg_18          = dword ptr  20h
.text$mn:00001214 arg_1C          = dword ptr  24h
.text$mn:00001214
.text$mn:00001214                 push    ebp
.text$mn:00001215                 mov     ebp, esp
.text$mn:00001217                 push    0FFFFFFFFh
.text$mn:00001219                 push    offset __ehhandler$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:0000121E                 mov     eax, large fs:0
.text$mn:00001224                 push    eax
.text$mn:00001225                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000122A                 xor     eax, ebp
.text$mn:0000122C                 push    eax
.text$mn:0000122D                 lea     eax, [ebp+var_C]
.text$mn:00001230                 mov     large fs:0, eax
.text$mn:00001236                 mov     [ebp+var_4], 1
.text$mn:0000123D                 lea     eax, [ebp+arg_C]
.text$mn:00001240                 push    eax             ; std::_Iterator_base12 *
.text$mn:00001241                 lea     ecx, [ebp+arg_0]
.text$mn:00001244                 call    ??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator!=(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00001249                 movzx   ecx, al
.text$mn:0000124C                 test    ecx, ecx
.text$mn:0000124E                 jz      short loc_12A0
.text$mn:00001250                 mov     edx, [ebp+arg_1C]
.text$mn:00001253                 push    edx
.text$mn:00001254                 mov     eax, [ebp+arg_18]
.text$mn:00001257                 push    eax
.text$mn:00001258                 lea     ecx, [ebp+arg_0]
.text$mn:0000125B                 push    ecx
.text$mn:0000125C                 call    ??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> &,wchar_t const *,uint)
.text$mn:00001261                 add     esp, 0Ch
.text$mn:00001264                 mov     edx, [ebp+arg_1C]
.text$mn:00001267                 push    edx
.text$mn:00001268                 mov     eax, [ebp+arg_18]
.text$mn:0000126B                 push    eax
.text$mn:0000126C                 lea     ecx, [ebp+arg_C]
.text$mn:0000126F                 push    ecx
.text$mn:00001270                 call    ??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> &,wchar_t const *,uint)
.text$mn:00001275                 add     esp, 0Ch
.text$mn:00001278                 lea     edx, [ebp+arg_0]
.text$mn:0000127B                 push    edx             ; std::_Iterator_base12 *
.text$mn:0000127C                 lea     ecx, [ebp+arg_C]
.text$mn:0000127F                 call    ??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator<(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00001284                 movzx   eax, al
.text$mn:00001287                 test    eax, eax
.text$mn:00001289                 jz      short loc_12A0
.text$mn:0000128B                 mov     ecx, [ebp+arg_1C]
.text$mn:0000128E                 push    ecx             ; unsigned int
.text$mn:0000128F                 mov     edx, [ebp+arg_18]
.text$mn:00001292                 push    edx             ; wchar_t *
.text$mn:00001293                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00001298                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000129D                 add     esp, 0Ch
.text$mn:000012A0
.text$mn:000012A0 loc_12A0:                               ; CODE XREF: std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,wchar_t const *,uint,std::random_access_iterator_tag)+3Aj
.text$mn:000012A0                                         ; std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,wchar_t const *,uint,std::random_access_iterator_tag)+75j
.text$mn:000012A0                 mov     byte ptr [ebp+var_4], 0
.text$mn:000012A4                 lea     ecx, [ebp+arg_0]
.text$mn:000012A7                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:000012AC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000012B3                 lea     ecx, [ebp+arg_C]
.text$mn:000012B6                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:000012BB                 mov     ecx, [ebp+var_C]
.text$mn:000012BE                 mov     large fs:0, ecx
.text$mn:000012C5                 pop     ecx
.text$mn:000012C6                 mov     esp, ebp
.text$mn:000012C8                 pop     ebp
.text$mn:000012C9                 retn
.text$mn:000012C9 ??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000012C9
.text$mn:000012C9 ; ---------------------------------------------------------------------------
.text$mn:000012CA                 align 4
.text$mn:000012CA _text$mn        ends
.text$mn:000012CA
.text$x:000012CC ; ===========================================================================
.text$x:000012CC
.text$x:000012CC ; Segment type: Pure code
.text$x:000012CC ; Segment permissions: Read/Execute
.text$x:000012CC _text$x         segment para public 'CODE' use32
.text$x:000012CC                 assume cs:_text$x
.text$x:000012CC                 ;org 12CCh
.text$x:000012CC ; COMDAT (pick associative to section at 1214)
.text$x:000012CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000012CC
.text$x:000012CC ; =============== S U B R O U T I N E =======================================
.text$x:000012CC
.text$x:000012CC
.text$x:000012CC __unwindfunclet$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0 proc near
.text$x:000012CC                                         ; DATA XREF: .xdata$x:0000745Co
.text$x:000012CC                 lea     ecx, [ebp+14h]
.text$x:000012CF                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000012CF __unwindfunclet$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0 endp
.text$x:000012CF
.text$x:000012D4
.text$x:000012D4 ; =============== S U B R O U T I N E =======================================
.text$x:000012D4
.text$x:000012D4
.text$x:000012D4 __unwindfunclet$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1 proc near
.text$x:000012D4                                         ; DATA XREF: .xdata$x:00007464o
.text$x:000012D4                 lea     ecx, [ebp+8]
.text$x:000012D7                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000012D7 __unwindfunclet$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1 endp
.text$x:000012D7
.text$x:000012DC
.text$x:000012DC ; =============== S U B R O U T I N E =======================================
.text$x:000012DC
.text$x:000012DC
.text$x:000012DC __ehhandler$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$x:000012DC                                         ; DATA XREF: std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,wchar_t const *,uint,std::random_access_iterator_tag)+5o
.text$x:000012DC
.text$x:000012DC arg_4           = dword ptr  8
.text$x:000012DC
.text$x:000012DC                 mov     edx, [esp+arg_4]
.text$x:000012E0                 lea     eax, [edx+0Ch]
.text$x:000012E3                 mov     ecx, [edx-4]
.text$x:000012E6                 xor     ecx, eax
.text$x:000012E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000012ED                 mov     eax, offset __ehfuncinfo$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$x:000012F2                 jmp     ___CxxFrameHandler3
.text$x:000012F2 __ehhandler$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$x:000012F2
.text$x:000012F2 ; ---------------------------------------------------------------------------
.text$x:000012F7                 align 4
.text$x:000012F7 _text$x         ends
.text$x:000012F7
.text$mn:000012F8 ; ===========================================================================
.text$mn:000012F8
.text$mn:000012F8 ; Segment type: Pure code
.text$mn:000012F8 ; Segment permissions: Read/Execute
.text$mn:000012F8 _text$mn        segment para public 'CODE' use32
.text$mn:000012F8                 assume cs:_text$mn
.text$mn:000012F8                 ;org 12F8h
.text$mn:000012F8 ; COMDAT (pick any)
.text$mn:000012F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000012F8
.text$mn:000012F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000012F8
.text$mn:000012F8 ; Attributes: bp-based frame
.text$mn:000012F8
.text$mn:000012F8 ; int __cdecl std::_Debug_range<RecentItem * *>(int, int, wchar_t *, unsigned int)
.text$mn:000012F8                 public ??$_Debug_range@PAPAURecentItem@@@std@@YAXPAPAURecentItem@@0PB_WI@Z
.text$mn:000012F8 ??$_Debug_range@PAPAURecentItem@@@std@@YAXPAPAURecentItem@@0PB_WI@Z proc near
.text$mn:000012F8                                         ; CODE XREF: std::_Uninit_copy<RecentItem *,RecentItem *>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:000012F8
.text$mn:000012F8 var_1           = byte ptr -1
.text$mn:000012F8 arg_0           = dword ptr  8
.text$mn:000012F8 arg_4           = dword ptr  0Ch
.text$mn:000012F8 arg_8           = dword ptr  10h
.text$mn:000012F8 arg_C           = dword ptr  14h
.text$mn:000012F8
.text$mn:000012F8                 push    ebp
.text$mn:000012F9                 mov     ebp, esp
.text$mn:000012FB                 push    ecx
.text$mn:000012FC                 lea     eax, [ebp+arg_0]
.text$mn:000012FF                 push    eax
.text$mn:00001300                 lea     ecx, [ebp+var_1]
.text$mn:00001303                 push    ecx
.text$mn:00001304                 call    ??$_Iter_cat@PAPAURecentItem@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAURecentItem@@@Z ; std::_Iter_cat<RecentItem * *>(RecentItem * * const &)
.text$mn:00001309                 add     esp, 8
.text$mn:0000130C                 mov     dl, [eax]
.text$mn:0000130E                 movzx   eax, dl
.text$mn:00001311                 push    eax
.text$mn:00001312                 mov     ecx, [ebp+arg_C]
.text$mn:00001315                 push    ecx             ; unsigned int
.text$mn:00001316                 mov     edx, [ebp+arg_8]
.text$mn:00001319                 push    edx             ; wchar_t *
.text$mn:0000131A                 mov     eax, [ebp+arg_4]
.text$mn:0000131D                 push    eax             ; int
.text$mn:0000131E                 mov     ecx, [ebp+arg_0]
.text$mn:00001321                 push    ecx             ; int
.text$mn:00001322                 call    ??$_Debug_range2@PAPAURecentItem@@@std@@YAXPAPAURecentItem@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<RecentItem * *>(RecentItem * *,RecentItem * *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00001327                 add     esp, 14h
.text$mn:0000132A                 mov     esp, ebp
.text$mn:0000132C                 pop     ebp
.text$mn:0000132D                 retn
.text$mn:0000132D ??$_Debug_range@PAPAURecentItem@@@std@@YAXPAPAURecentItem@@0PB_WI@Z endp
.text$mn:0000132D
.text$mn:0000132D ; ---------------------------------------------------------------------------
.text$mn:0000132E                 align 10h
.text$mn:0000132E _text$mn        ends
.text$mn:0000132E
.text$mn:00001330 ; ===========================================================================
.text$mn:00001330
.text$mn:00001330 ; Segment type: Pure code
.text$mn:00001330 ; Segment permissions: Read/Execute
.text$mn:00001330 _text$mn        segment para public 'CODE' use32
.text$mn:00001330                 assume cs:_text$mn
.text$mn:00001330                 ;org 1330h
.text$mn:00001330 ; COMDAT (pick any)
.text$mn:00001330                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001330
.text$mn:00001330 ; =============== S U B R O U T I N E =======================================
.text$mn:00001330
.text$mn:00001330 ; Attributes: bp-based frame
.text$mn:00001330
.text$mn:00001330 ; int __cdecl std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(char, int, int, int, int, int, wchar_t *, unsigned int)
.text$mn:00001330                 public ??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z
.text$mn:00001330 ??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z proc near
.text$mn:00001330                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+218p
.text$mn:00001330
.text$mn:00001330 var_28          = dword ptr -28h
.text$mn:00001330 var_24          = dword ptr -24h
.text$mn:00001330 var_20          = dword ptr -20h
.text$mn:00001330 var_1C          = dword ptr -1Ch
.text$mn:00001330 var_18          = dword ptr -18h
.text$mn:00001330 var_14          = dword ptr -14h
.text$mn:00001330 var_D           = byte ptr -0Dh
.text$mn:00001330 var_C           = dword ptr -0Ch
.text$mn:00001330 var_4           = dword ptr -4
.text$mn:00001330 arg_0           = byte ptr  8
.text$mn:00001330 arg_C           = dword ptr  14h
.text$mn:00001330 arg_18          = dword ptr  20h
.text$mn:00001330 arg_1C          = dword ptr  24h
.text$mn:00001330
.text$mn:00001330                 push    ebp
.text$mn:00001331                 mov     ebp, esp
.text$mn:00001333                 push    0FFFFFFFFh
.text$mn:00001335                 push    offset __ehhandler$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z
.text$mn:0000133A                 mov     eax, large fs:0
.text$mn:00001340                 push    eax
.text$mn:00001341                 sub     esp, 1Ch
.text$mn:00001344                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001349                 xor     eax, ebp
.text$mn:0000134B                 push    eax
.text$mn:0000134C                 lea     eax, [ebp+var_C]
.text$mn:0000134F                 mov     large fs:0, eax
.text$mn:00001355                 mov     [ebp+var_4], 1
.text$mn:0000135C                 lea     eax, [ebp+arg_0]
.text$mn:0000135F                 push    eax
.text$mn:00001360                 lea     ecx, [ebp+var_D]
.text$mn:00001363                 push    ecx
.text$mn:00001364                 call    ??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00001369                 add     esp, 8
.text$mn:0000136C                 mov     dl, [eax]
.text$mn:0000136E                 movzx   eax, dl
.text$mn:00001371                 push    eax
.text$mn:00001372                 mov     ecx, [ebp+arg_1C]
.text$mn:00001375                 push    ecx             ; unsigned int
.text$mn:00001376                 mov     edx, [ebp+arg_18]
.text$mn:00001379                 push    edx             ; wchar_t *
.text$mn:0000137A                 sub     esp, 0Ch
.text$mn:0000137D                 mov     ecx, esp
.text$mn:0000137F                 mov     [ebp+var_1C], esp
.text$mn:00001382                 lea     eax, [ebp+arg_C]
.text$mn:00001385                 push    eax             ; int
.text$mn:00001386                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:0000138B                 mov     [ebp+var_14], eax
.text$mn:0000138E                 mov     ecx, [ebp+var_14]
.text$mn:00001391                 mov     [ebp+var_20], ecx
.text$mn:00001394                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001398                 sub     esp, 0Ch
.text$mn:0000139B                 mov     ecx, esp
.text$mn:0000139D                 mov     [ebp+var_24], esp
.text$mn:000013A0                 lea     edx, [ebp+arg_0]
.text$mn:000013A3                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000013A4                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:000013A9                 mov     [ebp+var_18], eax
.text$mn:000013AC                 mov     eax, [ebp+var_18]
.text$mn:000013AF                 mov     [ebp+var_28], eax
.text$mn:000013B2                 mov     byte ptr [ebp+var_4], 3
.text$mn:000013B6                 mov     byte ptr [ebp+var_4], 1
.text$mn:000013BA                 call    ??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:000013BF                 add     esp, 24h
.text$mn:000013C2                 mov     byte ptr [ebp+var_4], 0
.text$mn:000013C6                 lea     ecx, [ebp+arg_0]
.text$mn:000013C9                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:000013CE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000013D5                 lea     ecx, [ebp+arg_C]
.text$mn:000013D8                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:000013DD                 mov     ecx, [ebp+var_C]
.text$mn:000013E0                 mov     large fs:0, ecx
.text$mn:000013E7                 pop     ecx
.text$mn:000013E8                 mov     esp, ebp
.text$mn:000013EA                 pop     ebp
.text$mn:000013EB                 retn
.text$mn:000013EB ??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z endp
.text$mn:000013EB
.text$mn:000013EB _text$mn        ends
.text$mn:000013EB
.text$x:000013EC ; ===========================================================================
.text$x:000013EC
.text$x:000013EC ; Segment type: Pure code
.text$x:000013EC ; Segment permissions: Read/Execute
.text$x:000013EC _text$x         segment para public 'CODE' use32
.text$x:000013EC                 assume cs:_text$x
.text$x:000013EC                 ;org 13ECh
.text$x:000013EC ; COMDAT (pick associative to section at 1330)
.text$x:000013EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000013EC
.text$x:000013EC ; =============== S U B R O U T I N E =======================================
.text$x:000013EC
.text$x:000013EC
.text$x:000013EC __unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z$0 proc near
.text$x:000013EC                                         ; DATA XREF: .xdata$x:00007334o
.text$x:000013EC                 lea     ecx, [ebp+14h]
.text$x:000013EF                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000013EF __unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z$0 endp
.text$x:000013EF
.text$x:000013F4
.text$x:000013F4 ; =============== S U B R O U T I N E =======================================
.text$x:000013F4
.text$x:000013F4
.text$x:000013F4 __unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z$1 proc near
.text$x:000013F4                                         ; DATA XREF: .xdata$x:0000733Co
.text$x:000013F4                 lea     ecx, [ebp+8]
.text$x:000013F7                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000013F7 __unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z$1 endp
.text$x:000013F7
.text$x:000013FC
.text$x:000013FC ; =============== S U B R O U T I N E =======================================
.text$x:000013FC
.text$x:000013FC
.text$x:000013FC __unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z$2 proc near
.text$x:000013FC                                         ; DATA XREF: .xdata$x:00007344o
.text$x:000013FC                 mov     ecx, [ebp-1Ch]
.text$x:000013FF                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000013FF __unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z$2 endp
.text$x:000013FF
.text$x:00001404
.text$x:00001404 ; =============== S U B R O U T I N E =======================================
.text$x:00001404
.text$x:00001404
.text$x:00001404 __unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z$3 proc near
.text$x:00001404                                         ; DATA XREF: .xdata$x:0000734Co
.text$x:00001404                 mov     ecx, [ebp-24h]
.text$x:00001407                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00001407 __unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z$3 endp
.text$x:00001407
.text$x:0000140C
.text$x:0000140C ; =============== S U B R O U T I N E =======================================
.text$x:0000140C
.text$x:0000140C
.text$x:0000140C __ehhandler$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z proc near
.text$x:0000140C                                         ; DATA XREF: std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,wchar_t const *,uint)+5o
.text$x:0000140C
.text$x:0000140C arg_4           = dword ptr  8
.text$x:0000140C
.text$x:0000140C                 mov     edx, [esp+arg_4]
.text$x:00001410                 lea     eax, [edx+0Ch]
.text$x:00001413                 mov     ecx, [edx-20h]
.text$x:00001416                 xor     ecx, eax
.text$x:00001418                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000141D                 mov     eax, offset __ehfuncinfo$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z
.text$x:00001422                 jmp     ___CxxFrameHandler3
.text$x:00001422 __ehhandler$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z endp
.text$x:00001422
.text$x:00001422 ; ---------------------------------------------------------------------------
.text$x:00001427                 align 4
.text$x:00001427 _text$x         ends
.text$x:00001427
.text$mn:00001428 ; ===========================================================================
.text$mn:00001428
.text$mn:00001428 ; Segment type: Pure code
.text$mn:00001428 ; Segment permissions: Read/Execute
.text$mn:00001428 _text$mn        segment para public 'CODE' use32
.text$mn:00001428                 assume cs:_text$mn
.text$mn:00001428                 ;org 1428h
.text$mn:00001428 ; COMDAT (pick any)
.text$mn:00001428                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001428
.text$mn:00001428 ; =============== S U B R O U T I N E =======================================
.text$mn:00001428
.text$mn:00001428 ; Attributes: bp-based frame
.text$mn:00001428
.text$mn:00001428 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct RecentItem *>>>(struct RecentItem * *, struct RecentItem * *, struct std::_Wrap_alloc<class std::allocator<struct RecentItem *>> &)
.text$mn:00001428                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAXPAPAURecentItem@@0AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z
.text$mn:00001428 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAXPAPAURecentItem@@0AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z proc near
.text$mn:00001428                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+1BDp
.text$mn:00001428
.text$mn:00001428 var_1           = byte ptr -1
.text$mn:00001428 arg_0           = dword ptr  8
.text$mn:00001428 arg_4           = dword ptr  0Ch
.text$mn:00001428 arg_8           = dword ptr  10h
.text$mn:00001428
.text$mn:00001428                 push    ebp
.text$mn:00001429                 mov     ebp, esp
.text$mn:0000142B                 push    ecx
.text$mn:0000142C                 mov     eax, [ebp+arg_4]
.text$mn:0000142F                 push    eax
.text$mn:00001430                 mov     ecx, [ebp+arg_0]
.text$mn:00001433                 push    ecx
.text$mn:00001434                 call    ??$_Ptr_cat@PAURecentItem@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAURecentItem@@0@Z ; std::_Ptr_cat<RecentItem *,RecentItem *>(RecentItem * *,RecentItem * *)
.text$mn:00001439                 add     esp, 8
.text$mn:0000143C                 mov     [ebp+var_1], al
.text$mn:0000143F                 movzx   edx, [ebp+var_1]
.text$mn:00001443                 push    edx
.text$mn:00001444                 mov     eax, [ebp+arg_8]
.text$mn:00001447                 push    eax
.text$mn:00001448                 mov     ecx, [ebp+arg_4]
.text$mn:0000144B                 push    ecx
.text$mn:0000144C                 mov     edx, [ebp+arg_0]
.text$mn:0000144F                 push    edx
.text$mn:00001450                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAXPAPAURecentItem@@0AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00001455                 add     esp, 10h
.text$mn:00001458                 mov     esp, ebp
.text$mn:0000145A                 pop     ebp
.text$mn:0000145B                 retn
.text$mn:0000145B ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAXPAPAURecentItem@@0AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z endp
.text$mn:0000145B
.text$mn:0000145B _text$mn        ends
.text$mn:0000145B
.text$mn:0000145C ; ===========================================================================
.text$mn:0000145C
.text$mn:0000145C ; Segment type: Pure code
.text$mn:0000145C ; Segment permissions: Read/Execute
.text$mn:0000145C _text$mn        segment para public 'CODE' use32
.text$mn:0000145C                 assume cs:_text$mn
.text$mn:0000145C                 ;org 145Ch
.text$mn:0000145C ; COMDAT (pick any)
.text$mn:0000145C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000145C
.text$mn:0000145C ; =============== S U B R O U T I N E =======================================
.text$mn:0000145C
.text$mn:0000145C ; Attributes: bp-based frame
.text$mn:0000145C
.text$mn:0000145C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct RecentItem *>>>(struct RecentItem * *, struct RecentItem * *, struct std::_Wrap_alloc<class std::allocator<struct RecentItem *>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:0000145C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAXPAPAURecentItem@@0AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:0000145C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAXPAPAURecentItem@@0AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:0000145C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &)+28p
.text$mn:0000145C                 push    ebp
.text$mn:0000145D                 mov     ebp, esp
.text$mn:0000145F                 pop     ebp
.text$mn:00001460                 retn
.text$mn:00001460 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAXPAPAURecentItem@@0AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00001460
.text$mn:00001460 ; ---------------------------------------------------------------------------
.text$mn:00001461                 align 4
.text$mn:00001461 _text$mn        ends
.text$mn:00001461
.text$mn:00001464 ; ===========================================================================
.text$mn:00001464
.text$mn:00001464 ; Segment type: Pure code
.text$mn:00001464 ; Segment permissions: Read/Execute
.text$mn:00001464 _text$mn        segment para public 'CODE' use32
.text$mn:00001464                 assume cs:_text$mn
.text$mn:00001464                 ;org 1464h
.text$mn:00001464 ; COMDAT (pick any)
.text$mn:00001464                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001464
.text$mn:00001464 ; =============== S U B R O U T I N E =======================================
.text$mn:00001464
.text$mn:00001464 ; Attributes: bp-based frame
.text$mn:00001464
.text$mn:00001464 ; struct RecentItem * * __cdecl std::_Fill_n<struct RecentItem * *, unsigned int, struct RecentItem *>(struct RecentItem * *, unsigned int, struct RecentItem * const &)
.text$mn:00001464                 public ??$_Fill_n@PAPAURecentItem@@IPAU1@@std@@YAPAPAURecentItem@@PAPAU1@IABQAU1@@Z
.text$mn:00001464 ??$_Fill_n@PAPAURecentItem@@IPAU1@@std@@YAPAPAURecentItem@@PAPAU1@IABQAU1@@Z proc near
.text$mn:00001464                                         ; CODE XREF: std::_Uninit_def_fill_n<RecentItem *,uint,RecentItem *>(RecentItem * *,uint,std::_Wrap_alloc<std::allocator<RecentItem *>> &,RecentItem * *,std::_Scalar_ptr_iterator_tag)+17p
.text$mn:00001464
.text$mn:00001464 arg_0           = dword ptr  8
.text$mn:00001464 arg_4           = dword ptr  0Ch
.text$mn:00001464 arg_8           = dword ptr  10h
.text$mn:00001464
.text$mn:00001464                 push    ebp
.text$mn:00001465                 mov     ebp, esp
.text$mn:00001467                 jmp     short loc_147B
.text$mn:00001469 ; ---------------------------------------------------------------------------
.text$mn:00001469
.text$mn:00001469 loc_1469:                               ; CODE XREF: std::_Fill_n<RecentItem * *,uint,RecentItem *>(RecentItem * *,uint,RecentItem * const &)+27j
.text$mn:00001469                 mov     eax, [ebp+arg_4]
.text$mn:0000146C                 sub     eax, 1
.text$mn:0000146F                 mov     [ebp+arg_4], eax
.text$mn:00001472                 mov     ecx, [ebp+arg_0]
.text$mn:00001475                 add     ecx, 4
.text$mn:00001478                 mov     [ebp+arg_0], ecx
.text$mn:0000147B
.text$mn:0000147B loc_147B:                               ; CODE XREF: std::_Fill_n<RecentItem * *,uint,RecentItem *>(RecentItem * *,uint,RecentItem * const &)+3j
.text$mn:0000147B                 cmp     [ebp+arg_4], 0
.text$mn:0000147F                 jbe     short loc_148D
.text$mn:00001481                 mov     edx, [ebp+arg_0]
.text$mn:00001484                 mov     eax, [ebp+arg_8]
.text$mn:00001487                 mov     ecx, [eax]
.text$mn:00001489                 mov     [edx], ecx
.text$mn:0000148B                 jmp     short loc_1469
.text$mn:0000148D ; ---------------------------------------------------------------------------
.text$mn:0000148D
.text$mn:0000148D loc_148D:                               ; CODE XREF: std::_Fill_n<RecentItem * *,uint,RecentItem *>(RecentItem * *,uint,RecentItem * const &)+1Bj
.text$mn:0000148D                 mov     eax, [ebp+arg_0]
.text$mn:00001490                 pop     ebp
.text$mn:00001491                 retn
.text$mn:00001491 ??$_Fill_n@PAPAURecentItem@@IPAU1@@std@@YAPAPAURecentItem@@PAPAU1@IABQAU1@@Z endp
.text$mn:00001491
.text$mn:00001491 ; ---------------------------------------------------------------------------
.text$mn:00001492                 align 4
.text$mn:00001492 _text$mn        ends
.text$mn:00001492
.text$mn:00001494 ; ===========================================================================
.text$mn:00001494
.text$mn:00001494 ; Segment type: Pure code
.text$mn:00001494 ; Segment permissions: Read/Execute
.text$mn:00001494 _text$mn        segment para public 'CODE' use32
.text$mn:00001494                 assume cs:_text$mn
.text$mn:00001494                 ;org 1494h
.text$mn:00001494 ; COMDAT (pick any)
.text$mn:00001494                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001494
.text$mn:00001494 ; =============== S U B R O U T I N E =======================================
.text$mn:00001494
.text$mn:00001494 ; Attributes: bp-based frame
.text$mn:00001494
.text$mn:00001494 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct RecentItem * *>(struct RecentItem * * const &)
.text$mn:00001494                 public ??$_Iter_cat@PAPAURecentItem@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAURecentItem@@@Z
.text$mn:00001494 ??$_Iter_cat@PAPAURecentItem@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAURecentItem@@@Z proc near
.text$mn:00001494                                         ; CODE XREF: std::_Debug_range<RecentItem * *>(RecentItem * *,RecentItem * *,wchar_t const *,uint)+Cp
.text$mn:00001494
.text$mn:00001494 var_1           = byte ptr -1
.text$mn:00001494 arg_0           = dword ptr  8
.text$mn:00001494
.text$mn:00001494                 push    ebp
.text$mn:00001495                 mov     ebp, esp
.text$mn:00001497                 push    ecx
.text$mn:00001498                 mov     eax, [ebp+arg_0]
.text$mn:0000149B                 mov     cl, [ebp+var_1]
.text$mn:0000149E                 mov     [eax], cl
.text$mn:000014A0                 mov     eax, [ebp+arg_0]
.text$mn:000014A3                 mov     esp, ebp
.text$mn:000014A5                 pop     ebp
.text$mn:000014A6                 retn
.text$mn:000014A6 ??$_Iter_cat@PAPAURecentItem@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAURecentItem@@@Z endp
.text$mn:000014A6
.text$mn:000014A6 ; ---------------------------------------------------------------------------
.text$mn:000014A7                 align 4
.text$mn:000014A7 _text$mn        ends
.text$mn:000014A7
.text$mn:000014A8 ; ===========================================================================
.text$mn:000014A8
.text$mn:000014A8 ; Segment type: Pure code
.text$mn:000014A8 ; Segment permissions: Read/Execute
.text$mn:000014A8 _text$mn        segment para public 'CODE' use32
.text$mn:000014A8                 assume cs:_text$mn
.text$mn:000014A8                 ;org 14A8h
.text$mn:000014A8 ; COMDAT (pick any)
.text$mn:000014A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014A8
.text$mn:000014A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014A8
.text$mn:000014A8 ; Attributes: bp-based frame
.text$mn:000014A8
.text$mn:000014A8 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>>(class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> const &)
.text$mn:000014A8                 public ??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@@Z
.text$mn:000014A8 ??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@@Z proc near
.text$mn:000014A8                                         ; CODE XREF: std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,wchar_t const *,uint)+34p
.text$mn:000014A8
.text$mn:000014A8 var_1           = byte ptr -1
.text$mn:000014A8 arg_0           = dword ptr  8
.text$mn:000014A8
.text$mn:000014A8                 push    ebp
.text$mn:000014A9                 mov     ebp, esp
.text$mn:000014AB                 push    ecx
.text$mn:000014AC                 mov     eax, [ebp+arg_0]
.text$mn:000014AF                 mov     cl, [ebp+var_1]
.text$mn:000014B2                 mov     [eax], cl
.text$mn:000014B4                 mov     eax, [ebp+arg_0]
.text$mn:000014B7                 mov     esp, ebp
.text$mn:000014B9                 pop     ebp
.text$mn:000014BA                 retn
.text$mn:000014BA ??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@@Z endp
.text$mn:000014BA
.text$mn:000014BA ; ---------------------------------------------------------------------------
.text$mn:000014BB                 align 4
.text$mn:000014BB _text$mn        ends
.text$mn:000014BB
.text$mn:000014BC ; ===========================================================================
.text$mn:000014BC
.text$mn:000014BC ; Segment type: Pure code
.text$mn:000014BC ; Segment permissions: Read/Execute
.text$mn:000014BC _text$mn        segment para public 'CODE' use32
.text$mn:000014BC                 assume cs:_text$mn
.text$mn:000014BC                 ;org 14BCh
.text$mn:000014BC ; COMDAT (pick any)
.text$mn:000014BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014BC
.text$mn:000014BC ; =============== S U B R O U T I N E =======================================
.text$mn:000014BC
.text$mn:000014BC ; Attributes: bp-based frame
.text$mn:000014BC
.text$mn:000014BC ; class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> __cdecl std::_Move<class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>>(class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>)
.text$mn:000014BC                 public ??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z
.text$mn:000014BC ??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z proc near
.text$mn:000014BC                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+41Ep
.text$mn:000014BC
.text$mn:000014BC var_3C          = dword ptr -3Ch
.text$mn:000014BC var_38          = dword ptr -38h
.text$mn:000014BC var_34          = dword ptr -34h
.text$mn:000014BC var_30          = dword ptr -30h
.text$mn:000014BC var_2C          = dword ptr -2Ch
.text$mn:000014BC var_28          = dword ptr -28h
.text$mn:000014BC var_24          = dword ptr -24h
.text$mn:000014BC var_20          = dword ptr -20h
.text$mn:000014BC var_1C          = dword ptr -1Ch
.text$mn:000014BC var_18          = dword ptr -18h
.text$mn:000014BC var_14          = dword ptr -14h
.text$mn:000014BC var_D           = byte ptr -0Dh
.text$mn:000014BC var_C           = dword ptr -0Ch
.text$mn:000014BC var_4           = dword ptr -4
.text$mn:000014BC arg_0           = dword ptr  8
.text$mn:000014BC arg_4           = byte ptr  0Ch
.text$mn:000014BC arg_10          = byte ptr  18h
.text$mn:000014BC arg_1C          = byte ptr  24h
.text$mn:000014BC
.text$mn:000014BC                 push    ebp
.text$mn:000014BD                 mov     ebp, esp
.text$mn:000014BF                 push    0FFFFFFFFh
.text$mn:000014C1                 push    offset __ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z
.text$mn:000014C6                 mov     eax, large fs:0
.text$mn:000014CC                 push    eax
.text$mn:000014CD                 sub     esp, 30h
.text$mn:000014D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000014D5                 xor     eax, ebp
.text$mn:000014D7                 push    eax
.text$mn:000014D8                 lea     eax, [ebp+var_C]
.text$mn:000014DB                 mov     large fs:0, eax
.text$mn:000014E1                 mov     [ebp+var_14], 0
.text$mn:000014E8                 mov     [ebp+var_4], 3
.text$mn:000014EF                 lea     eax, [ebp+arg_1C]
.text$mn:000014F2                 push    eax
.text$mn:000014F3                 lea     ecx, [ebp+arg_4]
.text$mn:000014F6                 push    ecx
.text$mn:000014F7                 call    ??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> &,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> &)
.text$mn:000014FC                 add     esp, 8
.text$mn:000014FF                 mov     [ebp+var_D], al
.text$mn:00001502                 movzx   edx, [ebp+var_D]
.text$mn:00001506                 push    edx
.text$mn:00001507                 sub     esp, 0Ch
.text$mn:0000150A                 mov     ecx, esp
.text$mn:0000150C                 mov     [ebp+var_24], esp
.text$mn:0000150F                 lea     eax, [ebp+arg_1C]
.text$mn:00001512                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00001513                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00001518                 mov     [ebp+var_18], eax
.text$mn:0000151B                 mov     ecx, [ebp+var_18]
.text$mn:0000151E                 mov     [ebp+var_28], ecx
.text$mn:00001521                 mov     byte ptr [ebp+var_4], 4
.text$mn:00001525                 sub     esp, 0Ch
.text$mn:00001528                 mov     ecx, esp
.text$mn:0000152A                 mov     [ebp+var_2C], esp
.text$mn:0000152D                 lea     edx, [ebp+arg_10]
.text$mn:00001530                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00001531                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00001536                 mov     [ebp+var_1C], eax
.text$mn:00001539                 mov     eax, [ebp+var_1C]
.text$mn:0000153C                 mov     [ebp+var_30], eax
.text$mn:0000153F                 mov     byte ptr [ebp+var_4], 5
.text$mn:00001543                 sub     esp, 0Ch
.text$mn:00001546                 mov     ecx, esp
.text$mn:00001548                 mov     [ebp+var_34], esp
.text$mn:0000154B                 lea     edx, [ebp+arg_4]
.text$mn:0000154E                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000154F                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00001554                 mov     [ebp+var_20], eax
.text$mn:00001557                 mov     eax, [ebp+var_20]
.text$mn:0000155A                 mov     [ebp+var_38], eax
.text$mn:0000155D                 mov     byte ptr [ebp+var_4], 6
.text$mn:00001561                 mov     ecx, [ebp+arg_0]
.text$mn:00001564                 push    ecx
.text$mn:00001565                 mov     byte ptr [ebp+var_4], 3
.text$mn:00001569                 call    ??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000156E                 add     esp, 2Ch
.text$mn:00001571                 mov     [ebp+var_3C], eax
.text$mn:00001574                 mov     edx, [ebp+var_14]
.text$mn:00001577                 or      edx, 1
.text$mn:0000157A                 mov     [ebp+var_14], edx
.text$mn:0000157D                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001581                 lea     ecx, [ebp+arg_4]
.text$mn:00001584                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00001589                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000158D                 lea     ecx, [ebp+arg_10]
.text$mn:00001590                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00001595                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001599                 lea     ecx, [ebp+arg_1C]
.text$mn:0000159C                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:000015A1                 mov     eax, [ebp+arg_0]
.text$mn:000015A4                 mov     ecx, [ebp+var_C]
.text$mn:000015A7                 mov     large fs:0, ecx
.text$mn:000015AE                 pop     ecx
.text$mn:000015AF                 mov     esp, ebp
.text$mn:000015B1                 pop     ebp
.text$mn:000015B2                 retn
.text$mn:000015B2 ??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z endp
.text$mn:000015B2
.text$mn:000015B2 ; ---------------------------------------------------------------------------
.text$mn:000015B3                 align 4
.text$mn:000015B3 _text$mn        ends
.text$mn:000015B3
.text$x:000015B4 ; ===========================================================================
.text$x:000015B4
.text$x:000015B4 ; Segment type: Pure code
.text$x:000015B4 ; Segment permissions: Read/Execute
.text$x:000015B4 _text$x         segment para public 'CODE' use32
.text$x:000015B4                 assume cs:_text$x
.text$x:000015B4                 ;org 15B4h
.text$x:000015B4 ; COMDAT (pick associative to section at 14BC)
.text$x:000015B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000015B4
.text$x:000015B4 ; =============== S U B R O U T I N E =======================================
.text$x:000015B4
.text$x:000015B4
.text$x:000015B4 __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$0 proc near
.text$x:000015B4                                         ; DATA XREF: .xdata$x:00007400o
.text$x:000015B4                 lea     ecx, [ebp+24h]
.text$x:000015B7                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000015B7 __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$0 endp
.text$x:000015B7
.text$x:000015BC
.text$x:000015BC ; =============== S U B R O U T I N E =======================================
.text$x:000015BC
.text$x:000015BC
.text$x:000015BC __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$1 proc near
.text$x:000015BC                                         ; DATA XREF: .xdata$x:00007408o
.text$x:000015BC                 lea     ecx, [ebp+18h]
.text$x:000015BF                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000015BF __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$1 endp
.text$x:000015BF
.text$x:000015C4
.text$x:000015C4 ; =============== S U B R O U T I N E =======================================
.text$x:000015C4
.text$x:000015C4
.text$x:000015C4 __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$2 proc near
.text$x:000015C4                                         ; DATA XREF: .xdata$x:00007410o
.text$x:000015C4                 lea     ecx, [ebp+0Ch]
.text$x:000015C7                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000015C7 __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$2 endp
.text$x:000015C7
.text$x:000015CC
.text$x:000015CC ; =============== S U B R O U T I N E =======================================
.text$x:000015CC
.text$x:000015CC
.text$x:000015CC __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$3 proc near
.text$x:000015CC                                         ; DATA XREF: .xdata$x:00007418o
.text$x:000015CC                 mov     ecx, [ebp-24h]
.text$x:000015CF                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000015CF __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$3 endp
.text$x:000015CF
.text$x:000015D4
.text$x:000015D4 ; =============== S U B R O U T I N E =======================================
.text$x:000015D4
.text$x:000015D4
.text$x:000015D4 __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$4 proc near
.text$x:000015D4                                         ; DATA XREF: .xdata$x:00007420o
.text$x:000015D4                 mov     ecx, [ebp-2Ch]
.text$x:000015D7                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000015D7 __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$4 endp
.text$x:000015D7
.text$x:000015DC
.text$x:000015DC ; =============== S U B R O U T I N E =======================================
.text$x:000015DC
.text$x:000015DC
.text$x:000015DC __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$5 proc near
.text$x:000015DC                                         ; DATA XREF: .xdata$x:00007428o
.text$x:000015DC                 mov     ecx, [ebp-34h]
.text$x:000015DF                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000015DF __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$5 endp
.text$x:000015DF
.text$x:000015E4
.text$x:000015E4 ; =============== S U B R O U T I N E =======================================
.text$x:000015E4
.text$x:000015E4
.text$x:000015E4 __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$6 proc near
.text$x:000015E4                                         ; DATA XREF: .xdata$x:000073F8o
.text$x:000015E4                 mov     eax, [ebp-14h]
.text$x:000015E7                 and     eax, 1
.text$x:000015EA                 jz      $LN10_0
.text$x:000015F0                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:000015F4                 mov     ecx, [ebp+8]
.text$x:000015F7                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000015FC ; ---------------------------------------------------------------------------
.text$x:000015FC
.text$x:000015FC $LN10_0:                                ; CODE XREF: __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$6+6j
.text$x:000015FC                 retn
.text$x:000015FC __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$6 endp
.text$x:000015FC
.text$x:000015FD
.text$x:000015FD ; =============== S U B R O U T I N E =======================================
.text$x:000015FD
.text$x:000015FD
.text$x:000015FD __ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z proc near
.text$x:000015FD                                         ; DATA XREF: std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+5o
.text$x:000015FD
.text$x:000015FD arg_4           = dword ptr  8
.text$x:000015FD
.text$x:000015FD                 mov     edx, [esp+arg_4]
.text$x:00001601                 lea     eax, [edx+0Ch]
.text$x:00001604                 mov     ecx, [edx-34h]
.text$x:00001607                 xor     ecx, eax
.text$x:00001609                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000160E                 mov     eax, offset __ehfuncinfo$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z
.text$x:00001613                 jmp     ___CxxFrameHandler3
.text$x:00001613 __ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z endp
.text$x:00001613
.text$x:00001613 _text$x         ends
.text$x:00001613
.text$mn:00001618 ; ===========================================================================
.text$mn:00001618
.text$mn:00001618 ; Segment type: Pure code
.text$mn:00001618 ; Segment permissions: Read/Execute
.text$mn:00001618 _text$mn        segment para public 'CODE' use32
.text$mn:00001618                 assume cs:_text$mn
.text$mn:00001618                 ;org 1618h
.text$mn:00001618 ; COMDAT (pick any)
.text$mn:00001618                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001618
.text$mn:00001618 ; =============== S U B R O U T I N E =======================================
.text$mn:00001618
.text$mn:00001618 ; Attributes: bp-based frame
.text$mn:00001618
.text$mn:00001618 ; class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> __cdecl std::_Move<class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>>(class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00001618                 public ??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00001618 ??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00001618                                         ; CODE XREF: std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+ADp
.text$mn:00001618
.text$mn:00001618 var_10          = dword ptr -10h
.text$mn:00001618 var_C           = dword ptr -0Ch
.text$mn:00001618 var_4           = dword ptr -4
.text$mn:00001618 arg_0           = dword ptr  8
.text$mn:00001618 arg_4           = byte ptr  0Ch
.text$mn:00001618 arg_10          = byte ptr  18h
.text$mn:00001618 arg_1C          = byte ptr  24h
.text$mn:00001618
.text$mn:00001618                 push    ebp
.text$mn:00001619                 mov     ebp, esp
.text$mn:0000161B                 push    0FFFFFFFFh
.text$mn:0000161D                 push    offset __ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00001622                 mov     eax, large fs:0
.text$mn:00001628                 push    eax
.text$mn:00001629                 push    ecx
.text$mn:0000162A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000162F                 xor     eax, ebp
.text$mn:00001631                 push    eax
.text$mn:00001632                 lea     eax, [ebp+var_C]
.text$mn:00001635                 mov     large fs:0, eax
.text$mn:0000163B                 mov     [ebp+var_10], 0
.text$mn:00001642                 mov     [ebp+var_4], 3
.text$mn:00001649                 jmp     short loc_165B
.text$mn:0000164B ; ---------------------------------------------------------------------------
.text$mn:0000164B
.text$mn:0000164B loc_164B:                               ; CODE XREF: std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+77j
.text$mn:0000164B                 lea     ecx, [ebp+arg_1C]
.text$mn:0000164E                 call    ??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)
.text$mn:00001653                 lea     ecx, [ebp+arg_4]
.text$mn:00001656                 call    ??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)
.text$mn:0000165B
.text$mn:0000165B loc_165B:                               ; CODE XREF: std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+31j
.text$mn:0000165B                 lea     eax, [ebp+arg_10]
.text$mn:0000165E                 push    eax             ; std::_Iterator_base12 *
.text$mn:0000165F                 lea     ecx, [ebp+arg_4]
.text$mn:00001662                 call    ??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator!=(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00001667                 movzx   ecx, al
.text$mn:0000166A                 test    ecx, ecx
.text$mn:0000166C                 jz      short loc_1691
.text$mn:0000166E                 lea     ecx, [ebp+arg_4]
.text$mn:00001671                 call    ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEAAURecentItem@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)
.text$mn:00001676                 push    eax
.text$mn:00001677                 call    ??$move@AAURecentItem@@@std@@YA$$QAURecentItem@@AAU1@@Z ; std::move<RecentItem &>(RecentItem &)
.text$mn:0000167C                 add     esp, 4
.text$mn:0000167F                 push    eax
.text$mn:00001680                 lea     ecx, [ebp+arg_1C]
.text$mn:00001683                 call    ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEAAURecentItem@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)
.text$mn:00001688                 mov     ecx, eax
.text$mn:0000168A                 call    ??4RecentItem@@QAEAAU0@ABU0@@Z ; RecentItem::operator=(RecentItem const &)
.text$mn:0000168F                 jmp     short loc_164B
.text$mn:00001691 ; ---------------------------------------------------------------------------
.text$mn:00001691
.text$mn:00001691 loc_1691:                               ; CODE XREF: std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+54j
.text$mn:00001691                 lea     edx, [ebp+arg_1C]
.text$mn:00001694                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00001695                 mov     ecx, [ebp+arg_0]
.text$mn:00001698                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:0000169D                 mov     eax, [ebp+var_10]
.text$mn:000016A0                 or      eax, 1
.text$mn:000016A3                 mov     [ebp+var_10], eax
.text$mn:000016A6                 mov     byte ptr [ebp+var_4], 2
.text$mn:000016AA                 lea     ecx, [ebp+arg_4]
.text$mn:000016AD                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:000016B2                 mov     byte ptr [ebp+var_4], 1
.text$mn:000016B6                 lea     ecx, [ebp+arg_10]
.text$mn:000016B9                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:000016BE                 mov     byte ptr [ebp+var_4], 0
.text$mn:000016C2                 lea     ecx, [ebp+arg_1C]
.text$mn:000016C5                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:000016CA                 mov     eax, [ebp+arg_0]
.text$mn:000016CD                 mov     ecx, [ebp+var_C]
.text$mn:000016D0                 mov     large fs:0, ecx
.text$mn:000016D7                 pop     ecx
.text$mn:000016D8                 mov     esp, ebp
.text$mn:000016DA                 pop     ebp
.text$mn:000016DB                 retn
.text$mn:000016DB ??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000016DB
.text$mn:000016DB _text$mn        ends
.text$mn:000016DB
.text$x:000016DC ; ===========================================================================
.text$x:000016DC
.text$x:000016DC ; Segment type: Pure code
.text$x:000016DC ; Segment permissions: Read/Execute
.text$x:000016DC _text$x         segment para public 'CODE' use32
.text$x:000016DC                 assume cs:_text$x
.text$x:000016DC                 ;org 16DCh
.text$x:000016DC ; COMDAT (pick associative to section at 1618)
.text$x:000016DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000016DC
.text$x:000016DC ; =============== S U B R O U T I N E =======================================
.text$x:000016DC
.text$x:000016DC
.text$x:000016DC __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$x:000016DC                                         ; DATA XREF: .xdata$x:000074DCo
.text$x:000016DC                 lea     ecx, [ebp+24h]
.text$x:000016DF                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000016DF __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$x:000016DF
.text$x:000016E4
.text$x:000016E4 ; =============== S U B R O U T I N E =======================================
.text$x:000016E4
.text$x:000016E4
.text$x:000016E4 __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$1 proc near
.text$x:000016E4                                         ; DATA XREF: .xdata$x:000074E4o
.text$x:000016E4                 lea     ecx, [ebp+18h]
.text$x:000016E7                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000016E7 __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$1 endp
.text$x:000016E7
.text$x:000016EC
.text$x:000016EC ; =============== S U B R O U T I N E =======================================
.text$x:000016EC
.text$x:000016EC
.text$x:000016EC __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$2 proc near
.text$x:000016EC                                         ; DATA XREF: .xdata$x:000074ECo
.text$x:000016EC                 lea     ecx, [ebp+0Ch]
.text$x:000016EF                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000016EF __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$2 endp
.text$x:000016EF
.text$x:000016F4
.text$x:000016F4 ; =============== S U B R O U T I N E =======================================
.text$x:000016F4
.text$x:000016F4
.text$x:000016F4 __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$3 proc near
.text$x:000016F4                                         ; DATA XREF: .xdata$x:000074D4o
.text$x:000016F4                 mov     eax, [ebp-10h]
.text$x:000016F7                 and     eax, 1
.text$x:000016FA                 jz      $LN10_1
.text$x:00001700                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00001704                 mov     ecx, [ebp+8]
.text$x:00001707                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:0000170C ; ---------------------------------------------------------------------------
.text$x:0000170C
.text$x:0000170C $LN10_1:                                ; CODE XREF: __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$3+6j
.text$x:0000170C                 retn
.text$x:0000170C __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$3 endp
.text$x:0000170C
.text$x:0000170D
.text$x:0000170D ; =============== S U B R O U T I N E =======================================
.text$x:0000170D
.text$x:0000170D
.text$x:0000170D __ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:0000170D                                         ; DATA XREF: std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:0000170D
.text$x:0000170D arg_4           = dword ptr  8
.text$x:0000170D
.text$x:0000170D                 mov     edx, [esp+arg_4]
.text$x:00001711                 lea     eax, [edx+0Ch]
.text$x:00001714                 mov     ecx, [edx-8]
.text$x:00001717                 xor     ecx, eax
.text$x:00001719                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000171E                 mov     eax, offset __ehfuncinfo$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:00001723                 jmp     ___CxxFrameHandler3
.text$x:00001723 __ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:00001723
.text$x:00001723 _text$x         ends
.text$x:00001723
.text$mn:00001728 ; ===========================================================================
.text$mn:00001728
.text$mn:00001728 ; Segment type: Pure code
.text$mn:00001728 ; Segment permissions: Read/Execute
.text$mn:00001728 _text$mn        segment para public 'CODE' use32
.text$mn:00001728                 assume cs:_text$mn
.text$mn:00001728                 ;org 1728h
.text$mn:00001728 ; COMDAT (pick any)
.text$mn:00001728                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001728
.text$mn:00001728 ; =============== S U B R O U T I N E =======================================
.text$mn:00001728
.text$mn:00001728 ; Attributes: bp-based frame
.text$mn:00001728
.text$mn:00001728 ; class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> __cdecl std::_Move_backward<class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>>(class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>)
.text$mn:00001728                 public ??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z
.text$mn:00001728 ??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z proc near
.text$mn:00001728                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+36Ep
.text$mn:00001728
.text$mn:00001728 var_3C          = dword ptr -3Ch
.text$mn:00001728 var_38          = dword ptr -38h
.text$mn:00001728 var_34          = dword ptr -34h
.text$mn:00001728 var_30          = dword ptr -30h
.text$mn:00001728 var_2C          = dword ptr -2Ch
.text$mn:00001728 var_28          = dword ptr -28h
.text$mn:00001728 var_24          = dword ptr -24h
.text$mn:00001728 var_20          = dword ptr -20h
.text$mn:00001728 var_1C          = dword ptr -1Ch
.text$mn:00001728 var_18          = dword ptr -18h
.text$mn:00001728 var_14          = dword ptr -14h
.text$mn:00001728 var_D           = byte ptr -0Dh
.text$mn:00001728 var_C           = dword ptr -0Ch
.text$mn:00001728 var_4           = dword ptr -4
.text$mn:00001728 arg_0           = dword ptr  8
.text$mn:00001728 arg_4           = byte ptr  0Ch
.text$mn:00001728 arg_10          = byte ptr  18h
.text$mn:00001728 arg_1C          = byte ptr  24h
.text$mn:00001728
.text$mn:00001728                 push    ebp
.text$mn:00001729                 mov     ebp, esp
.text$mn:0000172B                 push    0FFFFFFFFh
.text$mn:0000172D                 push    offset __ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z
.text$mn:00001732                 mov     eax, large fs:0
.text$mn:00001738                 push    eax
.text$mn:00001739                 sub     esp, 30h
.text$mn:0000173C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001741                 xor     eax, ebp
.text$mn:00001743                 push    eax
.text$mn:00001744                 lea     eax, [ebp+var_C]
.text$mn:00001747                 mov     large fs:0, eax
.text$mn:0000174D                 mov     [ebp+var_14], 0
.text$mn:00001754                 mov     [ebp+var_4], 3
.text$mn:0000175B                 lea     eax, [ebp+arg_1C]
.text$mn:0000175E                 push    eax
.text$mn:0000175F                 lea     ecx, [ebp+arg_4]
.text$mn:00001762                 push    ecx
.text$mn:00001763                 call    ??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> &,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> &)
.text$mn:00001768                 add     esp, 8
.text$mn:0000176B                 mov     [ebp+var_D], al
.text$mn:0000176E                 movzx   edx, [ebp+var_D]
.text$mn:00001772                 push    edx
.text$mn:00001773                 sub     esp, 0Ch
.text$mn:00001776                 mov     ecx, esp
.text$mn:00001778                 mov     [ebp+var_24], esp
.text$mn:0000177B                 lea     eax, [ebp+arg_1C]
.text$mn:0000177E                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000177F                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00001784                 mov     [ebp+var_18], eax
.text$mn:00001787                 mov     ecx, [ebp+var_18]
.text$mn:0000178A                 mov     [ebp+var_28], ecx
.text$mn:0000178D                 mov     byte ptr [ebp+var_4], 4
.text$mn:00001791                 sub     esp, 0Ch
.text$mn:00001794                 mov     ecx, esp
.text$mn:00001796                 mov     [ebp+var_2C], esp
.text$mn:00001799                 lea     edx, [ebp+arg_10]
.text$mn:0000179C                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000179D                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:000017A2                 mov     [ebp+var_1C], eax
.text$mn:000017A5                 mov     eax, [ebp+var_1C]
.text$mn:000017A8                 mov     [ebp+var_30], eax
.text$mn:000017AB                 mov     byte ptr [ebp+var_4], 5
.text$mn:000017AF                 sub     esp, 0Ch
.text$mn:000017B2                 mov     ecx, esp
.text$mn:000017B4                 mov     [ebp+var_34], esp
.text$mn:000017B7                 lea     edx, [ebp+arg_4]
.text$mn:000017BA                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000017BB                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:000017C0                 mov     [ebp+var_20], eax
.text$mn:000017C3                 mov     eax, [ebp+var_20]
.text$mn:000017C6                 mov     [ebp+var_38], eax
.text$mn:000017C9                 mov     byte ptr [ebp+var_4], 6
.text$mn:000017CD                 mov     ecx, [ebp+arg_0]
.text$mn:000017D0                 push    ecx
.text$mn:000017D1                 mov     byte ptr [ebp+var_4], 3
.text$mn:000017D5                 call    ??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)
.text$mn:000017DA                 add     esp, 2Ch
.text$mn:000017DD                 mov     [ebp+var_3C], eax
.text$mn:000017E0                 mov     edx, [ebp+var_14]
.text$mn:000017E3                 or      edx, 1
.text$mn:000017E6                 mov     [ebp+var_14], edx
.text$mn:000017E9                 mov     byte ptr [ebp+var_4], 2
.text$mn:000017ED                 lea     ecx, [ebp+arg_4]
.text$mn:000017F0                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:000017F5                 mov     byte ptr [ebp+var_4], 1
.text$mn:000017F9                 lea     ecx, [ebp+arg_10]
.text$mn:000017FC                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00001801                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001805                 lea     ecx, [ebp+arg_1C]
.text$mn:00001808                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:0000180D                 mov     eax, [ebp+arg_0]
.text$mn:00001810                 mov     ecx, [ebp+var_C]
.text$mn:00001813                 mov     large fs:0, ecx
.text$mn:0000181A                 pop     ecx
.text$mn:0000181B                 mov     esp, ebp
.text$mn:0000181D                 pop     ebp
.text$mn:0000181E                 retn
.text$mn:0000181E ??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z endp
.text$mn:0000181E
.text$mn:0000181E ; ---------------------------------------------------------------------------
.text$mn:0000181F                 align 10h
.text$mn:0000181F _text$mn        ends
.text$mn:0000181F
.text$x:00001820 ; ===========================================================================
.text$x:00001820
.text$x:00001820 ; Segment type: Pure code
.text$x:00001820 ; Segment permissions: Read/Execute
.text$x:00001820 _text$x         segment para public 'CODE' use32
.text$x:00001820                 assume cs:_text$x
.text$x:00001820                 ;org 1820h
.text$x:00001820 ; COMDAT (pick associative to section at 1728)
.text$x:00001820                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001820
.text$x:00001820 ; =============== S U B R O U T I N E =======================================
.text$x:00001820
.text$x:00001820
.text$x:00001820 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$0 proc near
.text$x:00001820                                         ; DATA XREF: .xdata$x:000073A4o
.text$x:00001820                 lea     ecx, [ebp+24h]
.text$x:00001823                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00001823 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$0 endp
.text$x:00001823
.text$x:00001828
.text$x:00001828 ; =============== S U B R O U T I N E =======================================
.text$x:00001828
.text$x:00001828
.text$x:00001828 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$1 proc near
.text$x:00001828                                         ; DATA XREF: .xdata$x:000073ACo
.text$x:00001828                 lea     ecx, [ebp+18h]
.text$x:0000182B                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:0000182B __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$1 endp
.text$x:0000182B
.text$x:00001830
.text$x:00001830 ; =============== S U B R O U T I N E =======================================
.text$x:00001830
.text$x:00001830
.text$x:00001830 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$2 proc near
.text$x:00001830                                         ; DATA XREF: .xdata$x:000073B4o
.text$x:00001830                 lea     ecx, [ebp+0Ch]
.text$x:00001833                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00001833 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$2 endp
.text$x:00001833
.text$x:00001838
.text$x:00001838 ; =============== S U B R O U T I N E =======================================
.text$x:00001838
.text$x:00001838
.text$x:00001838 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$3 proc near
.text$x:00001838                                         ; DATA XREF: .xdata$x:000073BCo
.text$x:00001838                 mov     ecx, [ebp-24h]
.text$x:0000183B                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:0000183B __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$3 endp
.text$x:0000183B
.text$x:00001840
.text$x:00001840 ; =============== S U B R O U T I N E =======================================
.text$x:00001840
.text$x:00001840
.text$x:00001840 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$4 proc near
.text$x:00001840                                         ; DATA XREF: .xdata$x:000073C4o
.text$x:00001840                 mov     ecx, [ebp-2Ch]
.text$x:00001843                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00001843 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$4 endp
.text$x:00001843
.text$x:00001848
.text$x:00001848 ; =============== S U B R O U T I N E =======================================
.text$x:00001848
.text$x:00001848
.text$x:00001848 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$5 proc near
.text$x:00001848                                         ; DATA XREF: .xdata$x:000073CCo
.text$x:00001848                 mov     ecx, [ebp-34h]
.text$x:0000184B                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:0000184B __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$5 endp
.text$x:0000184B
.text$x:00001850
.text$x:00001850 ; =============== S U B R O U T I N E =======================================
.text$x:00001850
.text$x:00001850
.text$x:00001850 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$6 proc near
.text$x:00001850                                         ; DATA XREF: .xdata$x:0000739Co
.text$x:00001850                 mov     eax, [ebp-14h]
.text$x:00001853                 and     eax, 1
.text$x:00001856                 jz      $LN10
.text$x:0000185C                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00001860                 mov     ecx, [ebp+8]
.text$x:00001863                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00001868 ; ---------------------------------------------------------------------------
.text$x:00001868
.text$x:00001868 $LN10:                                  ; CODE XREF: __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$6+6j
.text$x:00001868                 retn
.text$x:00001868 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$6 endp
.text$x:00001868
.text$x:00001869
.text$x:00001869 ; =============== S U B R O U T I N E =======================================
.text$x:00001869
.text$x:00001869
.text$x:00001869 __ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z proc near
.text$x:00001869                                         ; DATA XREF: std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+5o
.text$x:00001869
.text$x:00001869 arg_4           = dword ptr  8
.text$x:00001869
.text$x:00001869                 mov     edx, [esp+arg_4]
.text$x:0000186D                 lea     eax, [edx+0Ch]
.text$x:00001870                 mov     ecx, [edx-34h]
.text$x:00001873                 xor     ecx, eax
.text$x:00001875                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000187A                 mov     eax, offset __ehfuncinfo$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z
.text$x:0000187F                 jmp     ___CxxFrameHandler3
.text$x:0000187F __ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z endp
.text$x:0000187F
.text$x:0000187F _text$x         ends
.text$x:0000187F
.text$mn:00001884 ; ===========================================================================
.text$mn:00001884
.text$mn:00001884 ; Segment type: Pure code
.text$mn:00001884 ; Segment permissions: Read/Execute
.text$mn:00001884 _text$mn        segment para public 'CODE' use32
.text$mn:00001884                 assume cs:_text$mn
.text$mn:00001884                 ;org 1884h
.text$mn:00001884 ; COMDAT (pick any)
.text$mn:00001884                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001884
.text$mn:00001884 ; =============== S U B R O U T I N E =======================================
.text$mn:00001884
.text$mn:00001884 ; Attributes: bp-based frame
.text$mn:00001884
.text$mn:00001884 ; class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> __cdecl std::_Move_backward<class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>>(class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00001884                 public ??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00001884 ??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00001884                                         ; CODE XREF: std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+ADp
.text$mn:00001884
.text$mn:00001884 var_10          = dword ptr -10h
.text$mn:00001884 var_C           = dword ptr -0Ch
.text$mn:00001884 var_4           = dword ptr -4
.text$mn:00001884 arg_0           = dword ptr  8
.text$mn:00001884 arg_4           = byte ptr  0Ch
.text$mn:00001884 arg_10          = byte ptr  18h
.text$mn:00001884 arg_1C          = byte ptr  24h
.text$mn:00001884
.text$mn:00001884                 push    ebp
.text$mn:00001885                 mov     ebp, esp
.text$mn:00001887                 push    0FFFFFFFFh
.text$mn:00001889                 push    offset __ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000188E                 mov     eax, large fs:0
.text$mn:00001894                 push    eax
.text$mn:00001895                 push    ecx
.text$mn:00001896                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000189B                 xor     eax, ebp
.text$mn:0000189D                 push    eax
.text$mn:0000189E                 lea     eax, [ebp+var_C]
.text$mn:000018A1                 mov     large fs:0, eax
.text$mn:000018A7                 mov     [ebp+var_10], 0
.text$mn:000018AE                 mov     [ebp+var_4], 3
.text$mn:000018B5
.text$mn:000018B5 loc_18B5:                               ; CODE XREF: std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+73j
.text$mn:000018B5                 lea     eax, [ebp+arg_10]
.text$mn:000018B8                 push    eax             ; std::_Iterator_base12 *
.text$mn:000018B9                 lea     ecx, [ebp+arg_4]
.text$mn:000018BC                 call    ??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator!=(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:000018C1                 movzx   ecx, al
.text$mn:000018C4                 test    ecx, ecx
.text$mn:000018C6                 jz      short loc_18F9
.text$mn:000018C8                 lea     ecx, [ebp+arg_10]
.text$mn:000018CB                 call    ??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator--(void)
.text$mn:000018D0                 mov     ecx, eax
.text$mn:000018D2                 call    ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEAAURecentItem@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)
.text$mn:000018D7                 push    eax
.text$mn:000018D8                 call    ??$move@AAURecentItem@@@std@@YA$$QAURecentItem@@AAU1@@Z ; std::move<RecentItem &>(RecentItem &)
.text$mn:000018DD                 add     esp, 4
.text$mn:000018E0                 push    eax
.text$mn:000018E1                 lea     ecx, [ebp+arg_1C]
.text$mn:000018E4                 call    ??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator--(void)
.text$mn:000018E9                 mov     ecx, eax
.text$mn:000018EB                 call    ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEAAURecentItem@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)
.text$mn:000018F0                 mov     ecx, eax
.text$mn:000018F2                 call    ??4RecentItem@@QAEAAU0@ABU0@@Z ; RecentItem::operator=(RecentItem const &)
.text$mn:000018F7                 jmp     short loc_18B5
.text$mn:000018F9 ; ---------------------------------------------------------------------------
.text$mn:000018F9
.text$mn:000018F9 loc_18F9:                               ; CODE XREF: std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+42j
.text$mn:000018F9                 lea     edx, [ebp+arg_1C]
.text$mn:000018FC                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000018FD                 mov     ecx, [ebp+arg_0]
.text$mn:00001900                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00001905                 mov     eax, [ebp+var_10]
.text$mn:00001908                 or      eax, 1
.text$mn:0000190B                 mov     [ebp+var_10], eax
.text$mn:0000190E                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001912                 lea     ecx, [ebp+arg_4]
.text$mn:00001915                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:0000191A                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000191E                 lea     ecx, [ebp+arg_10]
.text$mn:00001921                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00001926                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000192A                 lea     ecx, [ebp+arg_1C]
.text$mn:0000192D                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00001932                 mov     eax, [ebp+arg_0]
.text$mn:00001935                 mov     ecx, [ebp+var_C]
.text$mn:00001938                 mov     large fs:0, ecx
.text$mn:0000193F                 pop     ecx
.text$mn:00001940                 mov     esp, ebp
.text$mn:00001942                 pop     ebp
.text$mn:00001943                 retn
.text$mn:00001943 ??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00001943
.text$mn:00001943 _text$mn        ends
.text$mn:00001943
.text$x:00001944 ; ===========================================================================
.text$x:00001944
.text$x:00001944 ; Segment type: Pure code
.text$x:00001944 ; Segment permissions: Read/Execute
.text$x:00001944 _text$x         segment para public 'CODE' use32
.text$x:00001944                 assume cs:_text$x
.text$x:00001944                 ;org 1944h
.text$x:00001944 ; COMDAT (pick associative to section at 1884)
.text$x:00001944                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001944
.text$x:00001944 ; =============== S U B R O U T I N E =======================================
.text$x:00001944
.text$x:00001944
.text$x:00001944 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$x:00001944                                         ; DATA XREF: .xdata$x:00007498o
.text$x:00001944                 lea     ecx, [ebp+24h]
.text$x:00001947                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00001947 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$x:00001947
.text$x:0000194C
.text$x:0000194C ; =============== S U B R O U T I N E =======================================
.text$x:0000194C
.text$x:0000194C
.text$x:0000194C __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$1 proc near
.text$x:0000194C                                         ; DATA XREF: .xdata$x:000074A0o
.text$x:0000194C                 lea     ecx, [ebp+18h]
.text$x:0000194F                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:0000194F __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$1 endp
.text$x:0000194F
.text$x:00001954
.text$x:00001954 ; =============== S U B R O U T I N E =======================================
.text$x:00001954
.text$x:00001954
.text$x:00001954 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$2 proc near
.text$x:00001954                                         ; DATA XREF: .xdata$x:000074A8o
.text$x:00001954                 lea     ecx, [ebp+0Ch]
.text$x:00001957                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00001957 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$2 endp
.text$x:00001957
.text$x:0000195C
.text$x:0000195C ; =============== S U B R O U T I N E =======================================
.text$x:0000195C
.text$x:0000195C
.text$x:0000195C __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$3 proc near
.text$x:0000195C                                         ; DATA XREF: .xdata$x:00007490o
.text$x:0000195C                 mov     eax, [ebp-10h]
.text$x:0000195F                 and     eax, 1
.text$x:00001962                 jz      $LN9
.text$x:00001968                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000196C                 mov     ecx, [ebp+8]
.text$x:0000196F                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00001974 ; ---------------------------------------------------------------------------
.text$x:00001974
.text$x:00001974 $LN9:                                   ; CODE XREF: __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$3+6j
.text$x:00001974                 retn
.text$x:00001974 __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$3 endp
.text$x:00001974
.text$x:00001975
.text$x:00001975 ; =============== S U B R O U T I N E =======================================
.text$x:00001975
.text$x:00001975
.text$x:00001975 __ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00001975                                         ; DATA XREF: std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00001975
.text$x:00001975 arg_4           = dword ptr  8
.text$x:00001975
.text$x:00001975                 mov     edx, [esp+arg_4]
.text$x:00001979                 lea     eax, [edx+0Ch]
.text$x:0000197C                 mov     ecx, [edx-8]
.text$x:0000197F                 xor     ecx, eax
.text$x:00001981                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001986                 mov     eax, offset __ehfuncinfo$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:0000198B                 jmp     ___CxxFrameHandler3
.text$x:0000198B __ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:0000198B
.text$x:0000198B _text$x         ends
.text$x:0000198B
.text$mn:00001990 ; ===========================================================================
.text$mn:00001990
.text$mn:00001990 ; Segment type: Pure code
.text$mn:00001990 ; Segment permissions: Read/Execute
.text$mn:00001990 _text$mn        segment para public 'CODE' use32
.text$mn:00001990                 assume cs:_text$mn
.text$mn:00001990                 ;org 1990h
.text$mn:00001990 ; COMDAT (pick any)
.text$mn:00001990                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001990
.text$mn:00001990 ; =============== S U B R O U T I N E =======================================
.text$mn:00001990
.text$mn:00001990 ; Attributes: bp-based frame
.text$mn:00001990
.text$mn:00001990 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct RecentItem *, struct RecentItem *>(struct RecentItem * *, struct RecentItem * *)
.text$mn:00001990                 public ??$_Ptr_cat@PAURecentItem@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAURecentItem@@0@Z
.text$mn:00001990 ??$_Ptr_cat@PAURecentItem@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAURecentItem@@0@Z proc near
.text$mn:00001990                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &)+Cp
.text$mn:00001990                                         ; std::_Uninit_copy<RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &)+Cp ...
.text$mn:00001990
.text$mn:00001990 var_1           = byte ptr -1
.text$mn:00001990
.text$mn:00001990                 push    ebp
.text$mn:00001991                 mov     ebp, esp
.text$mn:00001993                 push    ecx
.text$mn:00001994                 mov     al, [ebp+var_1]
.text$mn:00001997                 mov     esp, ebp
.text$mn:00001999                 pop     ebp
.text$mn:0000199A                 retn
.text$mn:0000199A ??$_Ptr_cat@PAURecentItem@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAURecentItem@@0@Z endp
.text$mn:0000199A
.text$mn:0000199A ; ---------------------------------------------------------------------------
.text$mn:0000199B                 align 4
.text$mn:0000199B _text$mn        ends
.text$mn:0000199B
.text$mn:0000199C ; ===========================================================================
.text$mn:0000199C
.text$mn:0000199C ; Segment type: Pure code
.text$mn:0000199C ; Segment permissions: Read/Execute
.text$mn:0000199C _text$mn        segment para public 'CODE' use32
.text$mn:0000199C                 assume cs:_text$mn
.text$mn:0000199C                 ;org 199Ch
.text$mn:0000199C ; COMDAT (pick any)
.text$mn:0000199C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000199C
.text$mn:0000199C ; =============== S U B R O U T I N E =======================================
.text$mn:0000199C
.text$mn:0000199C ; Attributes: bp-based frame
.text$mn:0000199C
.text$mn:0000199C ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>>(class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> &, class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> &)
.text$mn:0000199C                 public ??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0@Z
.text$mn:0000199C ??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0@Z proc near
.text$mn:0000199C                                         ; CODE XREF: std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+3Bp
.text$mn:0000199C                                         ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+3Bp
.text$mn:0000199C
.text$mn:0000199C var_1           = byte ptr -1
.text$mn:0000199C
.text$mn:0000199C                 push    ebp
.text$mn:0000199D                 mov     ebp, esp
.text$mn:0000199F                 push    ecx
.text$mn:000019A0                 mov     al, [ebp+var_1]
.text$mn:000019A3                 mov     esp, ebp
.text$mn:000019A5                 pop     ebp
.text$mn:000019A6                 retn
.text$mn:000019A6 ??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0@Z endp
.text$mn:000019A6
.text$mn:000019A6 ; ---------------------------------------------------------------------------
.text$mn:000019A7                 align 4
.text$mn:000019A7 _text$mn        ends
.text$mn:000019A7
.text$mn:000019A8 ; ===========================================================================
.text$mn:000019A8
.text$mn:000019A8 ; Segment type: Pure code
.text$mn:000019A8 ; Segment permissions: Read/Execute
.text$mn:000019A8 _text$mn        segment para public 'CODE' use32
.text$mn:000019A8                 assume cs:_text$mn
.text$mn:000019A8                 ;org 19A8h
.text$mn:000019A8 ; COMDAT (pick any)
.text$mn:000019A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019A8
.text$mn:000019A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000019A8
.text$mn:000019A8 ; Attributes: bp-based frame
.text$mn:000019A8
.text$mn:000019A8 ; struct RecentItem * * & __cdecl std::_Rechecked<struct RecentItem * *, struct RecentItem * *>(struct RecentItem * * &, struct RecentItem * *)
.text$mn:000019A8                 public ??$_Rechecked@PAPAURecentItem@@PAPAU1@@std@@YAAAPAPAURecentItem@@AAPAPAU1@PAPAU1@@Z
.text$mn:000019A8 ??$_Rechecked@PAPAURecentItem@@PAPAU1@@std@@YAAAPAPAURecentItem@@AAPAPAU1@PAPAU1@@Z proc near
.text$mn:000019A8                                         ; CODE XREF: std::_Uninitialized_copy<RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &)+3Bp
.text$mn:000019A8
.text$mn:000019A8 arg_0           = dword ptr  8
.text$mn:000019A8 arg_4           = dword ptr  0Ch
.text$mn:000019A8
.text$mn:000019A8                 push    ebp
.text$mn:000019A9                 mov     ebp, esp
.text$mn:000019AB                 mov     eax, [ebp+arg_0]
.text$mn:000019AE                 mov     ecx, [ebp+arg_4]
.text$mn:000019B1                 mov     [eax], ecx
.text$mn:000019B3                 mov     eax, [ebp+arg_0]
.text$mn:000019B6                 pop     ebp
.text$mn:000019B7                 retn
.text$mn:000019B7 ??$_Rechecked@PAPAURecentItem@@PAPAU1@@std@@YAAAPAPAURecentItem@@AAPAPAU1@PAPAU1@@Z endp
.text$mn:000019B7
.text$mn:000019B7 _text$mn        ends
.text$mn:000019B7
.text$mn:000019B8 ; ===========================================================================
.text$mn:000019B8
.text$mn:000019B8 ; Segment type: Pure code
.text$mn:000019B8 ; Segment permissions: Read/Execute
.text$mn:000019B8 _text$mn        segment para public 'CODE' use32
.text$mn:000019B8                 assume cs:_text$mn
.text$mn:000019B8                 ;org 19B8h
.text$mn:000019B8 ; COMDAT (pick any)
.text$mn:000019B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019B8
.text$mn:000019B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000019B8
.text$mn:000019B8 ; Attributes: bp-based frame
.text$mn:000019B8
.text$mn:000019B8 ; struct RecentItem * * __cdecl std::_Unchecked<struct RecentItem * *>(struct RecentItem * *)
.text$mn:000019B8                 public ??$_Unchecked@PAPAURecentItem@@@std@@YAPAPAURecentItem@@PAPAU1@@Z
.text$mn:000019B8 ??$_Unchecked@PAPAURecentItem@@@std@@YAPAPAURecentItem@@PAPAU1@@Z proc near
.text$mn:000019B8                                         ; CODE XREF: std::_Uninitialized_copy<RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &)+Bp
.text$mn:000019B8                                         ; std::_Uninitialized_copy<RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &)+18p ...
.text$mn:000019B8
.text$mn:000019B8 arg_0           = dword ptr  8
.text$mn:000019B8
.text$mn:000019B8                 push    ebp
.text$mn:000019B9                 mov     ebp, esp
.text$mn:000019BB                 mov     eax, [ebp+arg_0]
.text$mn:000019BE                 pop     ebp
.text$mn:000019BF                 retn
.text$mn:000019BF ??$_Unchecked@PAPAURecentItem@@@std@@YAPAPAURecentItem@@PAPAU1@@Z endp
.text$mn:000019BF
.text$mn:000019BF _text$mn        ends
.text$mn:000019BF
.text$mn:000019C0 ; ===========================================================================
.text$mn:000019C0
.text$mn:000019C0 ; Segment type: Pure code
.text$mn:000019C0 ; Segment permissions: Read/Execute
.text$mn:000019C0 _text$mn        segment para public 'CODE' use32
.text$mn:000019C0                 assume cs:_text$mn
.text$mn:000019C0                 ;org 19C0h
.text$mn:000019C0 ; COMDAT (pick any)
.text$mn:000019C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019C0
.text$mn:000019C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000019C0
.text$mn:000019C0 ; Attributes: bp-based frame
.text$mn:000019C0
.text$mn:000019C0 ; int __cdecl std::_Uninit_copy<RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>>>(void *Src, int, void *Dst, int)
.text$mn:000019C0                 public ??$_Uninit_copy@PAPAURecentItem@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAPAPAURecentItem@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z
.text$mn:000019C0 ??$_Uninit_copy@PAPAURecentItem@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAPAPAURecentItem@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z proc near
.text$mn:000019C0                                         ; CODE XREF: std::_Uninitialized_copy<RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &)+2Ep
.text$mn:000019C0
.text$mn:000019C0 var_1           = byte ptr -1
.text$mn:000019C0 Src             = dword ptr  8
.text$mn:000019C0 arg_4           = dword ptr  0Ch
.text$mn:000019C0 Dst             = dword ptr  10h
.text$mn:000019C0 arg_C           = dword ptr  14h
.text$mn:000019C0
.text$mn:000019C0                 push    ebp
.text$mn:000019C1                 mov     ebp, esp
.text$mn:000019C3                 push    ecx
.text$mn:000019C4                 mov     eax, [ebp+Dst]
.text$mn:000019C7                 push    eax
.text$mn:000019C8                 mov     ecx, [ebp+Src]
.text$mn:000019CB                 push    ecx
.text$mn:000019CC                 call    ??$_Ptr_cat@PAURecentItem@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAURecentItem@@0@Z ; std::_Ptr_cat<RecentItem *,RecentItem *>(RecentItem * *,RecentItem * *)
.text$mn:000019D1                 add     esp, 8
.text$mn:000019D4                 mov     [ebp+var_1], al
.text$mn:000019D7                 movzx   edx, [ebp+var_1]
.text$mn:000019DB                 push    edx
.text$mn:000019DC                 mov     eax, [ebp+arg_C]
.text$mn:000019DF                 push    eax
.text$mn:000019E0                 mov     ecx, [ebp+Dst]
.text$mn:000019E3                 push    ecx             ; Dst
.text$mn:000019E4                 mov     edx, [ebp+arg_4]
.text$mn:000019E7                 push    edx             ; int
.text$mn:000019E8                 mov     eax, [ebp+Src]
.text$mn:000019EB                 push    eax             ; Src
.text$mn:000019EC                 call    ??$_Uninit_copy@PAURecentItem@@PAU1@@std@@YAPAPAURecentItem@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<RecentItem *,RecentItem *>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:000019F1                 add     esp, 14h
.text$mn:000019F4                 mov     esp, ebp
.text$mn:000019F6                 pop     ebp
.text$mn:000019F7                 retn
.text$mn:000019F7 ??$_Uninit_copy@PAPAURecentItem@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAPAPAURecentItem@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z endp
.text$mn:000019F7
.text$mn:000019F7 _text$mn        ends
.text$mn:000019F7
.text$mn:000019F8 ; ===========================================================================
.text$mn:000019F8
.text$mn:000019F8 ; Segment type: Pure code
.text$mn:000019F8 ; Segment permissions: Read/Execute
.text$mn:000019F8 _text$mn        segment para public 'CODE' use32
.text$mn:000019F8                 assume cs:_text$mn
.text$mn:000019F8                 ;org 19F8h
.text$mn:000019F8 ; COMDAT (pick any)
.text$mn:000019F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019F8
.text$mn:000019F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000019F8
.text$mn:000019F8 ; Attributes: bp-based frame
.text$mn:000019F8
.text$mn:000019F8 ; int __cdecl std::_Uninit_copy<RecentItem *,RecentItem *>(void *Src, int, void *Dst)
.text$mn:000019F8                 public ??$_Uninit_copy@PAURecentItem@@PAU1@@std@@YAPAPAURecentItem@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:000019F8 ??$_Uninit_copy@PAURecentItem@@PAU1@@std@@YAPAPAURecentItem@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000019F8                                         ; CODE XREF: std::_Uninit_copy<RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &)+2Cp
.text$mn:000019F8
.text$mn:000019F8 var_4           = dword ptr -4
.text$mn:000019F8 Src             = dword ptr  8
.text$mn:000019F8 arg_4           = dword ptr  0Ch
.text$mn:000019F8 Dst             = dword ptr  10h
.text$mn:000019F8
.text$mn:000019F8                 push    ebp
.text$mn:000019F9                 mov     ebp, esp
.text$mn:000019FB                 push    ecx
.text$mn:000019FC                 push    192h            ; unsigned int
.text$mn:00001A01                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001A06                 mov     eax, [ebp+arg_4]
.text$mn:00001A09                 push    eax             ; int
.text$mn:00001A0A                 mov     ecx, [ebp+Src]
.text$mn:00001A0D                 push    ecx             ; int
.text$mn:00001A0E                 call    ??$_Debug_range@PAPAURecentItem@@@std@@YAXPAPAURecentItem@@0PB_WI@Z ; std::_Debug_range<RecentItem * *>(RecentItem * *,RecentItem * *,wchar_t const *,uint)
.text$mn:00001A13                 add     esp, 10h
.text$mn:00001A16                 push    193h            ; unsigned int
.text$mn:00001A1B                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001A20                 mov     edx, [ebp+Dst]
.text$mn:00001A23                 push    edx             ; int
.text$mn:00001A24                 call    ??$_Debug_pointer@PAURecentItem@@@std@@YAXPAPAURecentItem@@PB_WI@Z ; std::_Debug_pointer<RecentItem *>(RecentItem * *,wchar_t const *,uint)
.text$mn:00001A29                 add     esp, 0Ch
.text$mn:00001A2C                 mov     eax, [ebp+arg_4]
.text$mn:00001A2F                 sub     eax, [ebp+Src]
.text$mn:00001A32                 sar     eax, 2
.text$mn:00001A35                 mov     [ebp+var_4], eax
.text$mn:00001A38                 mov     ecx, [ebp+var_4]
.text$mn:00001A3B                 shl     ecx, 2
.text$mn:00001A3E                 push    ecx             ; Size
.text$mn:00001A3F                 mov     edx, [ebp+Src]
.text$mn:00001A42                 push    edx             ; Src
.text$mn:00001A43                 mov     eax, [ebp+Dst]
.text$mn:00001A46                 push    eax             ; Dst
.text$mn:00001A47                 call    _memmove
.text$mn:00001A4C                 add     esp, 0Ch
.text$mn:00001A4F                 mov     ecx, [ebp+var_4]
.text$mn:00001A52                 lea     eax, [eax+ecx*4]
.text$mn:00001A55                 mov     esp, ebp
.text$mn:00001A57                 pop     ebp
.text$mn:00001A58                 retn
.text$mn:00001A58 ??$_Uninit_copy@PAURecentItem@@PAU1@@std@@YAPAPAURecentItem@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00001A58
.text$mn:00001A58 ; ---------------------------------------------------------------------------
.text$mn:00001A59                 align 4
.text$mn:00001A59 _text$mn        ends
.text$mn:00001A59
.text$mn:00001A5C ; ===========================================================================
.text$mn:00001A5C
.text$mn:00001A5C ; Segment type: Pure code
.text$mn:00001A5C ; Segment permissions: Read/Execute
.text$mn:00001A5C _text$mn        segment para public 'CODE' use32
.text$mn:00001A5C                 assume cs:_text$mn
.text$mn:00001A5C                 ;org 1A5Ch
.text$mn:00001A5C ; COMDAT (pick any)
.text$mn:00001A5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A5C
.text$mn:00001A5C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A5C
.text$mn:00001A5C ; Attributes: bp-based frame
.text$mn:00001A5C
.text$mn:00001A5C ; void __cdecl std::_Uninit_def_fill_n<struct RecentItem *, unsigned int, struct RecentItem *>(struct RecentItem * *, unsigned int, struct std::_Wrap_alloc<class std::allocator<struct RecentItem *>> &, struct RecentItem * *, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00001A5C                 public ??$_Uninit_def_fill_n@PAURecentItem@@IPAU1@@std@@YAXPAPAURecentItem@@IAAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00001A5C ??$_Uninit_def_fill_n@PAURecentItem@@IPAU1@@std@@YAXPAPAURecentItem@@IAAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00001A5C                                         ; CODE XREF: std::_Uninitialized_default_fill_n<RecentItem * *,uint,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,uint,std::_Wrap_alloc<std::allocator<RecentItem *>> &)+35p
.text$mn:00001A5C
.text$mn:00001A5C var_4           = dword ptr -4
.text$mn:00001A5C arg_0           = dword ptr  8
.text$mn:00001A5C arg_4           = dword ptr  0Ch
.text$mn:00001A5C
.text$mn:00001A5C                 push    ebp
.text$mn:00001A5D                 mov     ebp, esp
.text$mn:00001A5F                 push    ecx
.text$mn:00001A60                 mov     [ebp+var_4], 0
.text$mn:00001A67                 lea     eax, [ebp+var_4]
.text$mn:00001A6A                 push    eax
.text$mn:00001A6B                 mov     ecx, [ebp+arg_4]
.text$mn:00001A6E                 push    ecx
.text$mn:00001A6F                 mov     edx, [ebp+arg_0]
.text$mn:00001A72                 push    edx
.text$mn:00001A73                 call    ??$_Fill_n@PAPAURecentItem@@IPAU1@@std@@YAPAPAURecentItem@@PAPAU1@IABQAU1@@Z ; std::_Fill_n<RecentItem * *,uint,RecentItem *>(RecentItem * *,uint,RecentItem * const &)
.text$mn:00001A78                 add     esp, 0Ch
.text$mn:00001A7B                 mov     esp, ebp
.text$mn:00001A7D                 pop     ebp
.text$mn:00001A7E                 retn
.text$mn:00001A7E ??$_Uninit_def_fill_n@PAURecentItem@@IPAU1@@std@@YAXPAPAURecentItem@@IAAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00001A7E
.text$mn:00001A7E ; ---------------------------------------------------------------------------
.text$mn:00001A7F                 align 10h
.text$mn:00001A7F _text$mn        ends
.text$mn:00001A7F
.text$mn:00001A80 ; ===========================================================================
.text$mn:00001A80
.text$mn:00001A80 ; Segment type: Pure code
.text$mn:00001A80 ; Segment permissions: Read/Execute
.text$mn:00001A80 _text$mn        segment para public 'CODE' use32
.text$mn:00001A80                 assume cs:_text$mn
.text$mn:00001A80                 ;org 1A80h
.text$mn:00001A80 ; COMDAT (pick any)
.text$mn:00001A80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A80
.text$mn:00001A80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A80
.text$mn:00001A80 ; Attributes: bp-based frame
.text$mn:00001A80
.text$mn:00001A80 ; struct RecentItem * * __cdecl std::_Uninitialized_copy<struct RecentItem * *, struct RecentItem * *, struct std::_Wrap_alloc<class std::allocator<struct RecentItem *>>>(struct RecentItem * *, struct RecentItem * *, struct RecentItem * *, struct std::_Wrap_alloc<class std::allocator<struct RecentItem *>> &)
.text$mn:00001A80                 public ??$_Uninitialized_copy@PAPAURecentItem@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAPAPAURecentItem@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z
.text$mn:00001A80 ??$_Uninitialized_copy@PAPAURecentItem@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAPAPAURecentItem@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z proc near
.text$mn:00001A80                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+D0p
.text$mn:00001A80                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+FFp ...
.text$mn:00001A80
.text$mn:00001A80 arg_0           = dword ptr  8
.text$mn:00001A80 arg_4           = dword ptr  0Ch
.text$mn:00001A80 arg_8           = dword ptr  10h
.text$mn:00001A80 arg_C           = dword ptr  14h
.text$mn:00001A80
.text$mn:00001A80                 push    ebp
.text$mn:00001A81                 mov     ebp, esp
.text$mn:00001A83                 mov     eax, [ebp+arg_C]
.text$mn:00001A86                 push    eax             ; int
.text$mn:00001A87                 mov     ecx, [ebp+arg_8]
.text$mn:00001A8A                 push    ecx
.text$mn:00001A8B                 call    ??$_Unchecked@PAPAURecentItem@@@std@@YAPAPAURecentItem@@PAPAU1@@Z ; std::_Unchecked<RecentItem * *>(RecentItem * *)
.text$mn:00001A90                 add     esp, 4
.text$mn:00001A93                 push    eax             ; Dst
.text$mn:00001A94                 mov     edx, [ebp+arg_4]
.text$mn:00001A97                 push    edx
.text$mn:00001A98                 call    ??$_Unchecked@PAPAURecentItem@@@std@@YAPAPAURecentItem@@PAPAU1@@Z ; std::_Unchecked<RecentItem * *>(RecentItem * *)
.text$mn:00001A9D                 add     esp, 4
.text$mn:00001AA0                 push    eax             ; int
.text$mn:00001AA1                 mov     eax, [ebp+arg_0]
.text$mn:00001AA4                 push    eax
.text$mn:00001AA5                 call    ??$_Unchecked@PAPAURecentItem@@@std@@YAPAPAURecentItem@@PAPAU1@@Z ; std::_Unchecked<RecentItem * *>(RecentItem * *)
.text$mn:00001AAA                 add     esp, 4
.text$mn:00001AAD                 push    eax             ; Src
.text$mn:00001AAE                 call    ??$_Uninit_copy@PAPAURecentItem@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAPAPAURecentItem@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z ; std::_Uninit_copy<RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &)
.text$mn:00001AB3                 add     esp, 10h
.text$mn:00001AB6                 push    eax
.text$mn:00001AB7                 lea     ecx, [ebp+arg_8]
.text$mn:00001ABA                 push    ecx
.text$mn:00001ABB                 call    ??$_Rechecked@PAPAURecentItem@@PAPAU1@@std@@YAAAPAPAURecentItem@@AAPAPAU1@PAPAU1@@Z ; std::_Rechecked<RecentItem * *,RecentItem * *>(RecentItem * * &,RecentItem * *)
.text$mn:00001AC0                 add     esp, 8
.text$mn:00001AC3                 mov     eax, [eax]
.text$mn:00001AC5                 pop     ebp
.text$mn:00001AC6                 retn
.text$mn:00001AC6 ??$_Uninitialized_copy@PAPAURecentItem@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAPAPAURecentItem@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z endp
.text$mn:00001AC6
.text$mn:00001AC6 ; ---------------------------------------------------------------------------
.text$mn:00001AC7                 align 4
.text$mn:00001AC7 _text$mn        ends
.text$mn:00001AC7
.text$mn:00001AC8 ; ===========================================================================
.text$mn:00001AC8
.text$mn:00001AC8 ; Segment type: Pure code
.text$mn:00001AC8 ; Segment permissions: Read/Execute
.text$mn:00001AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00001AC8                 assume cs:_text$mn
.text$mn:00001AC8                 ;org 1AC8h
.text$mn:00001AC8 ; COMDAT (pick any)
.text$mn:00001AC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AC8
.text$mn:00001AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AC8
.text$mn:00001AC8 ; Attributes: bp-based frame
.text$mn:00001AC8
.text$mn:00001AC8 ; void __cdecl std::_Uninitialized_default_fill_n<struct RecentItem * *, unsigned int, struct std::_Wrap_alloc<class std::allocator<struct RecentItem *>>>(struct RecentItem * *, unsigned int, struct std::_Wrap_alloc<class std::allocator<struct RecentItem *>> &)
.text$mn:00001AC8                 public ??$_Uninitialized_default_fill_n@PAPAURecentItem@@IU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAXPAPAURecentItem@@IAAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z
.text$mn:00001AC8 ??$_Uninitialized_default_fill_n@PAPAURecentItem@@IU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAXPAPAURecentItem@@IAAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z proc near
.text$mn:00001AC8                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+119p
.text$mn:00001AC8                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+12Dp ...
.text$mn:00001AC8
.text$mn:00001AC8 var_1           = byte ptr -1
.text$mn:00001AC8 arg_0           = dword ptr  8
.text$mn:00001AC8 arg_4           = dword ptr  0Ch
.text$mn:00001AC8 arg_8           = dword ptr  10h
.text$mn:00001AC8
.text$mn:00001AC8                 push    ebp
.text$mn:00001AC9                 mov     ebp, esp
.text$mn:00001ACB                 push    ecx
.text$mn:00001ACC                 mov     eax, [ebp+arg_0]
.text$mn:00001ACF                 push    eax
.text$mn:00001AD0                 mov     ecx, [ebp+arg_0]
.text$mn:00001AD3                 push    ecx
.text$mn:00001AD4                 call    ??$_Ptr_cat@PAURecentItem@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAURecentItem@@0@Z ; std::_Ptr_cat<RecentItem *,RecentItem *>(RecentItem * *,RecentItem * *)
.text$mn:00001AD9                 add     esp, 8
.text$mn:00001ADC                 mov     [ebp+var_1], al
.text$mn:00001ADF                 movzx   edx, [ebp+var_1]
.text$mn:00001AE3                 push    edx
.text$mn:00001AE4                 mov     eax, [ebp+arg_0]
.text$mn:00001AE7                 push    eax
.text$mn:00001AE8                 call    ??$_Val_type@PAPAURecentItem@@@std@@YAPAPAURecentItem@@PAPAU1@@Z ; std::_Val_type<RecentItem * *>(RecentItem * *)
.text$mn:00001AED                 add     esp, 4
.text$mn:00001AF0                 push    eax
.text$mn:00001AF1                 mov     ecx, [ebp+arg_8]
.text$mn:00001AF4                 push    ecx
.text$mn:00001AF5                 mov     edx, [ebp+arg_4]
.text$mn:00001AF8                 push    edx
.text$mn:00001AF9                 mov     eax, [ebp+arg_0]
.text$mn:00001AFC                 push    eax
.text$mn:00001AFD                 call    ??$_Uninit_def_fill_n@PAURecentItem@@IPAU1@@std@@YAXPAPAURecentItem@@IAAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<RecentItem *,uint,RecentItem *>(RecentItem * *,uint,std::_Wrap_alloc<std::allocator<RecentItem *>> &,RecentItem * *,std::_Scalar_ptr_iterator_tag)
.text$mn:00001B02                 add     esp, 14h
.text$mn:00001B05                 mov     esp, ebp
.text$mn:00001B07                 pop     ebp
.text$mn:00001B08                 retn
.text$mn:00001B08 ??$_Uninitialized_default_fill_n@PAPAURecentItem@@IU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAXPAPAURecentItem@@IAAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z endp
.text$mn:00001B08
.text$mn:00001B08 ; ---------------------------------------------------------------------------
.text$mn:00001B09                 align 4
.text$mn:00001B09 _text$mn        ends
.text$mn:00001B09
.text$mn:00001B0C ; ===========================================================================
.text$mn:00001B0C
.text$mn:00001B0C ; Segment type: Pure code
.text$mn:00001B0C ; Segment permissions: Read/Execute
.text$mn:00001B0C _text$mn        segment para public 'CODE' use32
.text$mn:00001B0C                 assume cs:_text$mn
.text$mn:00001B0C                 ;org 1B0Ch
.text$mn:00001B0C ; COMDAT (pick any)
.text$mn:00001B0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B0C
.text$mn:00001B0C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B0C
.text$mn:00001B0C ; Attributes: bp-based frame
.text$mn:00001B0C
.text$mn:00001B0C ; struct RecentItem * * __cdecl std::_Val_type<struct RecentItem * *>(struct RecentItem * *)
.text$mn:00001B0C                 public ??$_Val_type@PAPAURecentItem@@@std@@YAPAPAURecentItem@@PAPAU1@@Z
.text$mn:00001B0C ??$_Val_type@PAPAURecentItem@@@std@@YAPAPAURecentItem@@PAPAU1@@Z proc near
.text$mn:00001B0C                                         ; CODE XREF: std::_Uninitialized_default_fill_n<RecentItem * *,uint,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,uint,std::_Wrap_alloc<std::allocator<RecentItem *>> &)+20p
.text$mn:00001B0C                 push    ebp
.text$mn:00001B0D                 mov     ebp, esp
.text$mn:00001B0F                 xor     eax, eax
.text$mn:00001B11                 pop     ebp
.text$mn:00001B12                 retn
.text$mn:00001B12 ??$_Val_type@PAPAURecentItem@@@std@@YAPAPAURecentItem@@PAPAU1@@Z endp
.text$mn:00001B12
.text$mn:00001B12 ; ---------------------------------------------------------------------------
.text$mn:00001B13                 align 4
.text$mn:00001B13 _text$mn        ends
.text$mn:00001B13
.text$mn:00001B14 ; ===========================================================================
.text$mn:00001B14
.text$mn:00001B14 ; Segment type: Pure code
.text$mn:00001B14 ; Segment permissions: Read/Execute
.text$mn:00001B14 _text$mn        segment para public 'CODE' use32
.text$mn:00001B14                 assume cs:_text$mn
.text$mn:00001B14                 ;org 1B14h
.text$mn:00001B14 ; COMDAT (pick any)
.text$mn:00001B14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B14
.text$mn:00001B14 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B14
.text$mn:00001B14 ; Attributes: bp-based frame
.text$mn:00001B14
.text$mn:00001B14 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00001B14                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00001B14 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00001B14                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00001B14                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00001B14
.text$mn:00001B14 arg_0           = dword ptr  8
.text$mn:00001B14
.text$mn:00001B14                 push    ebp
.text$mn:00001B15                 mov     ebp, esp
.text$mn:00001B17                 mov     eax, [ebp+arg_0]
.text$mn:00001B1A                 pop     ebp
.text$mn:00001B1B                 retn
.text$mn:00001B1B ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00001B1B
.text$mn:00001B1B _text$mn        ends
.text$mn:00001B1B
.text$mn:00001B1C ; ===========================================================================
.text$mn:00001B1C
.text$mn:00001B1C ; Segment type: Pure code
.text$mn:00001B1C ; Segment permissions: Read/Execute
.text$mn:00001B1C _text$mn        segment para public 'CODE' use32
.text$mn:00001B1C                 assume cs:_text$mn
.text$mn:00001B1C                 ;org 1B1Ch
.text$mn:00001B1C ; COMDAT (pick any)
.text$mn:00001B1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B1C
.text$mn:00001B1C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B1C
.text$mn:00001B1C ; Attributes: bp-based frame
.text$mn:00001B1C
.text$mn:00001B1C ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:00001B1C                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:00001B1C ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:00001B1C                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:00001B1C                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:00001B1C
.text$mn:00001B1C arg_0           = dword ptr  8
.text$mn:00001B1C
.text$mn:00001B1C                 push    ebp
.text$mn:00001B1D                 mov     ebp, esp
.text$mn:00001B1F                 mov     eax, [ebp+arg_0]
.text$mn:00001B22                 pop     ebp
.text$mn:00001B23                 retn
.text$mn:00001B23 ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:00001B23
.text$mn:00001B23 _text$mn        ends
.text$mn:00001B23
.text$mn:00001B24 ; ===========================================================================
.text$mn:00001B24
.text$mn:00001B24 ; Segment type: Pure code
.text$mn:00001B24 ; Segment permissions: Read/Execute
.text$mn:00001B24 _text$mn        segment para public 'CODE' use32
.text$mn:00001B24                 assume cs:_text$mn
.text$mn:00001B24                 ;org 1B24h
.text$mn:00001B24 ; COMDAT (pick any)
.text$mn:00001B24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B24
.text$mn:00001B24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B24
.text$mn:00001B24 ; Attributes: bp-based frame
.text$mn:00001B24
.text$mn:00001B24 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00001B24                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00001B24 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00001B24                                         ; CODE XREF: $LN19+4Bp
.text$mn:00001B24
.text$mn:00001B24 var_4           = dword ptr -4
.text$mn:00001B24 arg_0           = dword ptr  8
.text$mn:00001B24 arg_4           = dword ptr  0Ch
.text$mn:00001B24
.text$mn:00001B24                 push    ebp
.text$mn:00001B25                 mov     ebp, esp
.text$mn:00001B27                 push    ecx
.text$mn:00001B28                 mov     [ebp+var_4], ecx
.text$mn:00001B2B                 mov     eax, [ebp+arg_4]
.text$mn:00001B2E                 push    eax
.text$mn:00001B2F                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001B34                 add     esp, 4
.text$mn:00001B37                 push    eax             ; int
.text$mn:00001B38                 mov     ecx, [ebp+arg_0]
.text$mn:00001B3B                 push    ecx             ; void *
.text$mn:00001B3C                 mov     edx, [ebp+var_4]
.text$mn:00001B3F                 push    edx             ; int
.text$mn:00001B40                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00001B45                 add     esp, 0Ch
.text$mn:00001B48                 mov     esp, ebp
.text$mn:00001B4A                 pop     ebp
.text$mn:00001B4B                 retn    8
.text$mn:00001B4B ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00001B4B
.text$mn:00001B4B ; ---------------------------------------------------------------------------
.text$mn:00001B4E                 align 10h
.text$mn:00001B4E _text$mn        ends
.text$mn:00001B4E
.text$mn:00001B50 ; ===========================================================================
.text$mn:00001B50
.text$mn:00001B50 ; Segment type: Pure code
.text$mn:00001B50 ; Segment permissions: Read/Execute
.text$mn:00001B50 _text$mn        segment para public 'CODE' use32
.text$mn:00001B50                 assume cs:_text$mn
.text$mn:00001B50                 ;org 1B50h
.text$mn:00001B50 ; COMDAT (pick any)
.text$mn:00001B50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B50
.text$mn:00001B50 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B50
.text$mn:00001B50 ; Attributes: bp-based frame
.text$mn:00001B50
.text$mn:00001B50 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00001B50                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00001B50 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00001B50                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00001B50
.text$mn:00001B50 var_1C          = dword ptr -1Ch
.text$mn:00001B50 var_18          = dword ptr -18h
.text$mn:00001B50 var_14          = dword ptr -14h
.text$mn:00001B50 var_10          = dword ptr -10h
.text$mn:00001B50 var_C           = dword ptr -0Ch
.text$mn:00001B50 var_4           = dword ptr -4
.text$mn:00001B50 arg_0           = dword ptr  8
.text$mn:00001B50 arg_4           = dword ptr  0Ch
.text$mn:00001B50
.text$mn:00001B50                 push    ebp
.text$mn:00001B51                 mov     ebp, esp
.text$mn:00001B53                 push    0FFFFFFFFh
.text$mn:00001B55                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00001B5A                 mov     eax, large fs:0
.text$mn:00001B60                 push    eax
.text$mn:00001B61                 sub     esp, 10h
.text$mn:00001B64                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001B69                 xor     eax, ebp
.text$mn:00001B6B                 push    eax
.text$mn:00001B6C                 lea     eax, [ebp+var_C]
.text$mn:00001B6F                 mov     large fs:0, eax
.text$mn:00001B75                 mov     [ebp+var_18], ecx
.text$mn:00001B78                 mov     eax, [ebp+arg_0]
.text$mn:00001B7B                 push    eax             ; void *
.text$mn:00001B7C                 push    4               ; unsigned int
.text$mn:00001B7E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001B83                 add     esp, 8
.text$mn:00001B86                 mov     [ebp+var_10], eax
.text$mn:00001B89                 mov     [ebp+var_4], 0
.text$mn:00001B90                 cmp     [ebp+var_10], 0
.text$mn:00001B94                 jz      short loc_1BB1
.text$mn:00001B96                 mov     ecx, [ebp+arg_4]
.text$mn:00001B99                 push    ecx
.text$mn:00001B9A                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001B9F                 add     esp, 4
.text$mn:00001BA2                 mov     edx, [ebp+var_10]
.text$mn:00001BA5                 mov     eax, [eax]
.text$mn:00001BA7                 mov     [edx], eax
.text$mn:00001BA9                 mov     ecx, [ebp+var_10]
.text$mn:00001BAC                 mov     [ebp+var_14], ecx
.text$mn:00001BAF                 jmp     short loc_1BB8
.text$mn:00001BB1 ; ---------------------------------------------------------------------------
.text$mn:00001BB1
.text$mn:00001BB1 loc_1BB1:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00001BB1                 mov     [ebp+var_14], 0
.text$mn:00001BB8
.text$mn:00001BB8 loc_1BB8:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00001BB8                 mov     edx, [ebp+var_14]
.text$mn:00001BBB                 mov     [ebp+var_1C], edx
.text$mn:00001BBE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001BC5                 mov     ecx, [ebp+var_C]
.text$mn:00001BC8                 mov     large fs:0, ecx
.text$mn:00001BCF                 pop     ecx
.text$mn:00001BD0                 mov     esp, ebp
.text$mn:00001BD2                 pop     ebp
.text$mn:00001BD3                 retn    8
.text$mn:00001BD3 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00001BD3
.text$mn:00001BD3 ; ---------------------------------------------------------------------------
.text$mn:00001BD6                 align 4
.text$mn:00001BD6 _text$mn        ends
.text$mn:00001BD6
.text$x:00001BD8 ; ===========================================================================
.text$x:00001BD8
.text$x:00001BD8 ; Segment type: Pure code
.text$x:00001BD8 ; Segment permissions: Read/Execute
.text$x:00001BD8 _text$x         segment para public 'CODE' use32
.text$x:00001BD8                 assume cs:_text$x
.text$x:00001BD8                 ;org 1BD8h
.text$x:00001BD8 ; COMDAT (pick associative to section at 1B50)
.text$x:00001BD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001BD8
.text$x:00001BD8 ; =============== S U B R O U T I N E =======================================
.text$x:00001BD8
.text$x:00001BD8
.text$x:00001BD8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00001BD8                                         ; DATA XREF: .xdata$x:00007518o
.text$x:00001BD8                 mov     eax, [ebp+8]
.text$x:00001BDB                 push    eax
.text$x:00001BDC                 mov     eax, [ebp-10h]
.text$x:00001BDF                 push    eax             ; void *
.text$x:00001BE0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001BE5                 add     esp, 8
.text$x:00001BE8                 retn
.text$x:00001BE8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00001BE8
.text$x:00001BE9
.text$x:00001BE9 ; =============== S U B R O U T I N E =======================================
.text$x:00001BE9
.text$x:00001BE9
.text$x:00001BE9 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00001BE9                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00001BE9
.text$x:00001BE9 arg_4           = dword ptr  8
.text$x:00001BE9
.text$x:00001BE9                 mov     edx, [esp+arg_4]
.text$x:00001BED                 lea     eax, [edx+0Ch]
.text$x:00001BF0                 mov     ecx, [edx-14h]
.text$x:00001BF3                 xor     ecx, eax
.text$x:00001BF5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001BFA                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00001BFF                 jmp     ___CxxFrameHandler3
.text$x:00001BFF __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00001BFF
.text$x:00001BFF _text$x         ends
.text$x:00001BFF
.text$mn:00001C04 ; ===========================================================================
.text$mn:00001C04
.text$mn:00001C04 ; Segment type: Pure code
.text$mn:00001C04 ; Segment permissions: Read/Execute
.text$mn:00001C04 _text$mn        segment para public 'CODE' use32
.text$mn:00001C04                 assume cs:_text$mn
.text$mn:00001C04                 ;org 1C04h
.text$mn:00001C04 ; COMDAT (pick any)
.text$mn:00001C04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C04
.text$mn:00001C04 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C04
.text$mn:00001C04 ; Attributes: bp-based frame
.text$mn:00001C04
.text$mn:00001C04 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00001C04                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00001C04 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00001C04                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00001C04
.text$mn:00001C04 arg_0           = dword ptr  8
.text$mn:00001C04 arg_4           = dword ptr  0Ch
.text$mn:00001C04 arg_8           = dword ptr  10h
.text$mn:00001C04
.text$mn:00001C04                 push    ebp
.text$mn:00001C05                 mov     ebp, esp
.text$mn:00001C07                 mov     eax, [ebp+arg_8]
.text$mn:00001C0A                 push    eax
.text$mn:00001C0B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001C10                 add     esp, 4
.text$mn:00001C13                 push    eax             ; int
.text$mn:00001C14                 mov     ecx, [ebp+arg_4]
.text$mn:00001C17                 push    ecx             ; void *
.text$mn:00001C18                 mov     ecx, [ebp+arg_0]
.text$mn:00001C1B                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001C20                 pop     ebp
.text$mn:00001C21                 retn
.text$mn:00001C21 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00001C21
.text$mn:00001C21 ; ---------------------------------------------------------------------------
.text$mn:00001C22                 align 4
.text$mn:00001C22 _text$mn        ends
.text$mn:00001C22
.text$mn:00001C24 ; ===========================================================================
.text$mn:00001C24
.text$mn:00001C24 ; Segment type: Pure code
.text$mn:00001C24 ; Segment permissions: Read/Execute
.text$mn:00001C24 _text$mn        segment para public 'CODE' use32
.text$mn:00001C24                 assume cs:_text$mn
.text$mn:00001C24                 ;org 1C24h
.text$mn:00001C24 ; COMDAT (pick any)
.text$mn:00001C24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C24
.text$mn:00001C24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C24
.text$mn:00001C24 ; Attributes: bp-based frame
.text$mn:00001C24
.text$mn:00001C24 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00001C24                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00001C24 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00001C24                                         ; CODE XREF: $LN19_0+4Bp
.text$mn:00001C24
.text$mn:00001C24 var_4           = dword ptr -4
.text$mn:00001C24 arg_0           = dword ptr  8
.text$mn:00001C24 arg_4           = dword ptr  0Ch
.text$mn:00001C24
.text$mn:00001C24                 push    ebp
.text$mn:00001C25                 mov     ebp, esp
.text$mn:00001C27                 push    ecx
.text$mn:00001C28                 mov     [ebp+var_4], ecx
.text$mn:00001C2B                 mov     eax, [ebp+arg_4]
.text$mn:00001C2E                 push    eax
.text$mn:00001C2F                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00001C34                 add     esp, 4
.text$mn:00001C37                 push    eax             ; int
.text$mn:00001C38                 mov     ecx, [ebp+arg_0]
.text$mn:00001C3B                 push    ecx             ; void *
.text$mn:00001C3C                 mov     edx, [ebp+var_4]
.text$mn:00001C3F                 push    edx             ; int
.text$mn:00001C40                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:00001C45                 add     esp, 0Ch
.text$mn:00001C48                 mov     esp, ebp
.text$mn:00001C4A                 pop     ebp
.text$mn:00001C4B                 retn    8
.text$mn:00001C4B ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00001C4B
.text$mn:00001C4B ; ---------------------------------------------------------------------------
.text$mn:00001C4E                 align 10h
.text$mn:00001C4E _text$mn        ends
.text$mn:00001C4E
.text$mn:00001C50 ; ===========================================================================
.text$mn:00001C50
.text$mn:00001C50 ; Segment type: Pure code
.text$mn:00001C50 ; Segment permissions: Read/Execute
.text$mn:00001C50 _text$mn        segment para public 'CODE' use32
.text$mn:00001C50                 assume cs:_text$mn
.text$mn:00001C50                 ;org 1C50h
.text$mn:00001C50 ; COMDAT (pick any)
.text$mn:00001C50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C50
.text$mn:00001C50 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C50
.text$mn:00001C50 ; Attributes: bp-based frame
.text$mn:00001C50
.text$mn:00001C50 ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00001C50                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00001C50 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00001C50                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:00001C50
.text$mn:00001C50 var_1C          = dword ptr -1Ch
.text$mn:00001C50 var_18          = dword ptr -18h
.text$mn:00001C50 var_14          = dword ptr -14h
.text$mn:00001C50 var_10          = dword ptr -10h
.text$mn:00001C50 var_C           = dword ptr -0Ch
.text$mn:00001C50 var_4           = dword ptr -4
.text$mn:00001C50 arg_0           = dword ptr  8
.text$mn:00001C50 arg_4           = dword ptr  0Ch
.text$mn:00001C50
.text$mn:00001C50                 push    ebp
.text$mn:00001C51                 mov     ebp, esp
.text$mn:00001C53                 push    0FFFFFFFFh
.text$mn:00001C55                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00001C5A                 mov     eax, large fs:0
.text$mn:00001C60                 push    eax
.text$mn:00001C61                 sub     esp, 10h
.text$mn:00001C64                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001C69                 xor     eax, ebp
.text$mn:00001C6B                 push    eax
.text$mn:00001C6C                 lea     eax, [ebp+var_C]
.text$mn:00001C6F                 mov     large fs:0, eax
.text$mn:00001C75                 mov     [ebp+var_18], ecx
.text$mn:00001C78                 mov     eax, [ebp+arg_0]
.text$mn:00001C7B                 push    eax             ; void *
.text$mn:00001C7C                 push    4               ; unsigned int
.text$mn:00001C7E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001C83                 add     esp, 8
.text$mn:00001C86                 mov     [ebp+var_10], eax
.text$mn:00001C89                 mov     [ebp+var_4], 0
.text$mn:00001C90                 cmp     [ebp+var_10], 0
.text$mn:00001C94                 jz      short loc_1CB1
.text$mn:00001C96                 mov     ecx, [ebp+arg_4]
.text$mn:00001C99                 push    ecx
.text$mn:00001C9A                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00001C9F                 add     esp, 4
.text$mn:00001CA2                 mov     edx, [ebp+var_10]
.text$mn:00001CA5                 mov     eax, [eax]
.text$mn:00001CA7                 mov     [edx], eax
.text$mn:00001CA9                 mov     ecx, [ebp+var_10]
.text$mn:00001CAC                 mov     [ebp+var_14], ecx
.text$mn:00001CAF                 jmp     short loc_1CB8
.text$mn:00001CB1 ; ---------------------------------------------------------------------------
.text$mn:00001CB1
.text$mn:00001CB1 loc_1CB1:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:00001CB1                 mov     [ebp+var_14], 0
.text$mn:00001CB8
.text$mn:00001CB8 loc_1CB8:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:00001CB8                 mov     edx, [ebp+var_14]
.text$mn:00001CBB                 mov     [ebp+var_1C], edx
.text$mn:00001CBE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001CC5                 mov     ecx, [ebp+var_C]
.text$mn:00001CC8                 mov     large fs:0, ecx
.text$mn:00001CCF                 pop     ecx
.text$mn:00001CD0                 mov     esp, ebp
.text$mn:00001CD2                 pop     ebp
.text$mn:00001CD3                 retn    8
.text$mn:00001CD3 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00001CD3
.text$mn:00001CD3 ; ---------------------------------------------------------------------------
.text$mn:00001CD6                 align 4
.text$mn:00001CD6 _text$mn        ends
.text$mn:00001CD6
.text$x:00001CD8 ; ===========================================================================
.text$x:00001CD8
.text$x:00001CD8 ; Segment type: Pure code
.text$x:00001CD8 ; Segment permissions: Read/Execute
.text$x:00001CD8 _text$x         segment para public 'CODE' use32
.text$x:00001CD8                 assume cs:_text$x
.text$x:00001CD8                 ;org 1CD8h
.text$x:00001CD8 ; COMDAT (pick associative to section at 1C50)
.text$x:00001CD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001CD8
.text$x:00001CD8 ; =============== S U B R O U T I N E =======================================
.text$x:00001CD8
.text$x:00001CD8
.text$x:00001CD8 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:00001CD8                                         ; DATA XREF: .xdata$x:00007544o
.text$x:00001CD8                 mov     eax, [ebp+8]
.text$x:00001CDB                 push    eax
.text$x:00001CDC                 mov     eax, [ebp-10h]
.text$x:00001CDF                 push    eax             ; void *
.text$x:00001CE0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001CE5                 add     esp, 8
.text$x:00001CE8                 retn
.text$x:00001CE8 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:00001CE8
.text$x:00001CE9
.text$x:00001CE9 ; =============== S U B R O U T I N E =======================================
.text$x:00001CE9
.text$x:00001CE9
.text$x:00001CE9 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:00001CE9                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:00001CE9
.text$x:00001CE9 arg_4           = dword ptr  8
.text$x:00001CE9
.text$x:00001CE9                 mov     edx, [esp+arg_4]
.text$x:00001CED                 lea     eax, [edx+0Ch]
.text$x:00001CF0                 mov     ecx, [edx-14h]
.text$x:00001CF3                 xor     ecx, eax
.text$x:00001CF5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001CFA                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:00001CFF                 jmp     ___CxxFrameHandler3
.text$x:00001CFF __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:00001CFF
.text$x:00001CFF _text$x         ends
.text$x:00001CFF
.text$mn:00001D04 ; ===========================================================================
.text$mn:00001D04
.text$mn:00001D04 ; Segment type: Pure code
.text$mn:00001D04 ; Segment permissions: Read/Execute
.text$mn:00001D04 _text$mn        segment para public 'CODE' use32
.text$mn:00001D04                 assume cs:_text$mn
.text$mn:00001D04                 ;org 1D04h
.text$mn:00001D04 ; COMDAT (pick any)
.text$mn:00001D04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D04
.text$mn:00001D04 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D04
.text$mn:00001D04 ; Attributes: bp-based frame
.text$mn:00001D04
.text$mn:00001D04 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:00001D04                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:00001D04 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:00001D04                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:00001D04
.text$mn:00001D04 arg_0           = dword ptr  8
.text$mn:00001D04 arg_4           = dword ptr  0Ch
.text$mn:00001D04 arg_8           = dword ptr  10h
.text$mn:00001D04
.text$mn:00001D04                 push    ebp
.text$mn:00001D05                 mov     ebp, esp
.text$mn:00001D07                 mov     eax, [ebp+arg_8]
.text$mn:00001D0A                 push    eax
.text$mn:00001D0B                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00001D10                 add     esp, 4
.text$mn:00001D13                 push    eax             ; int
.text$mn:00001D14                 mov     ecx, [ebp+arg_4]
.text$mn:00001D17                 push    ecx             ; void *
.text$mn:00001D18                 mov     ecx, [ebp+arg_0]
.text$mn:00001D1B                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00001D20                 pop     ebp
.text$mn:00001D21                 retn
.text$mn:00001D21 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:00001D21
.text$mn:00001D21 ; ---------------------------------------------------------------------------
.text$mn:00001D22                 align 4
.text$mn:00001D22 _text$mn        ends
.text$mn:00001D22
.text$mn:00001D24 ; ===========================================================================
.text$mn:00001D24
.text$mn:00001D24 ; Segment type: Pure code
.text$mn:00001D24 ; Segment permissions: Read/Execute
.text$mn:00001D24 _text$mn        segment para public 'CODE' use32
.text$mn:00001D24                 assume cs:_text$mn
.text$mn:00001D24                 ;org 1D24h
.text$mn:00001D24 ; COMDAT (pick any)
.text$mn:00001D24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D24
.text$mn:00001D24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D24
.text$mn:00001D24 ; Attributes: bp-based frame
.text$mn:00001D24
.text$mn:00001D24 ; int __stdcall std::_Wrap_alloc<std::allocator<RecentItem>>::construct<RecentItem,RecentItem const &>(void *, int)
.text$mn:00001D24                 public ??$construct@URecentItem@@ABU1@@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAEXPAURecentItem@@ABU2@@Z
.text$mn:00001D24 ??$construct@URecentItem@@ABU1@@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAEXPAURecentItem@@ABU2@@Z proc near
.text$mn:00001D24                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::push_front(RecentItem const &)+EEp
.text$mn:00001D24
.text$mn:00001D24 var_4           = dword ptr -4
.text$mn:00001D24 arg_0           = dword ptr  8
.text$mn:00001D24 arg_4           = dword ptr  0Ch
.text$mn:00001D24
.text$mn:00001D24                 push    ebp
.text$mn:00001D25                 mov     ebp, esp
.text$mn:00001D27                 push    ecx
.text$mn:00001D28                 mov     [ebp+var_4], ecx
.text$mn:00001D2B                 mov     eax, [ebp+arg_4]
.text$mn:00001D2E                 push    eax
.text$mn:00001D2F                 call    ??$forward@ABURecentItem@@@std@@YAABURecentItem@@ABU1@@Z ; std::forward<RecentItem const &>(RecentItem const &)
.text$mn:00001D34                 add     esp, 4
.text$mn:00001D37                 push    eax             ; int
.text$mn:00001D38                 mov     ecx, [ebp+arg_0]
.text$mn:00001D3B                 push    ecx             ; void *
.text$mn:00001D3C                 mov     edx, [ebp+var_4]
.text$mn:00001D3F                 push    edx             ; int
.text$mn:00001D40                 call    ??$construct@URecentItem@@ABU1@@?$allocator_traits@V?$allocator@URecentItem@@@std@@@std@@SAXAAV?$allocator@URecentItem@@@1@PAURecentItem@@ABU3@@Z ; std::allocator_traits<std::allocator<RecentItem>>::construct<RecentItem,RecentItem const &>(std::allocator<RecentItem> &,RecentItem *,RecentItem const &)
.text$mn:00001D45                 add     esp, 0Ch
.text$mn:00001D48                 mov     esp, ebp
.text$mn:00001D4A                 pop     ebp
.text$mn:00001D4B                 retn    8
.text$mn:00001D4B ??$construct@URecentItem@@ABU1@@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAEXPAURecentItem@@ABU2@@Z endp
.text$mn:00001D4B
.text$mn:00001D4B ; ---------------------------------------------------------------------------
.text$mn:00001D4E                 align 10h
.text$mn:00001D4E _text$mn        ends
.text$mn:00001D4E
.text$mn:00001D50 ; ===========================================================================
.text$mn:00001D50
.text$mn:00001D50 ; Segment type: Pure code
.text$mn:00001D50 ; Segment permissions: Read/Execute
.text$mn:00001D50 _text$mn        segment para public 'CODE' use32
.text$mn:00001D50                 assume cs:_text$mn
.text$mn:00001D50                 ;org 1D50h
.text$mn:00001D50 ; COMDAT (pick any)
.text$mn:00001D50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D50
.text$mn:00001D50 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D50
.text$mn:00001D50 ; Attributes: bp-based frame
.text$mn:00001D50
.text$mn:00001D50 ; int __cdecl std::allocator_traits<std::allocator<RecentItem>>::construct<RecentItem,RecentItem const &>(int, void *, int)
.text$mn:00001D50                 public ??$construct@URecentItem@@ABU1@@?$allocator_traits@V?$allocator@URecentItem@@@std@@@std@@SAXAAV?$allocator@URecentItem@@@1@PAURecentItem@@ABU3@@Z
.text$mn:00001D50 ??$construct@URecentItem@@ABU1@@?$allocator_traits@V?$allocator@URecentItem@@@std@@@std@@SAXAAV?$allocator@URecentItem@@@1@PAURecentItem@@ABU3@@Z proc near
.text$mn:00001D50                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<RecentItem>>::construct<RecentItem,RecentItem const &>(RecentItem *,RecentItem const &)+1Cp
.text$mn:00001D50
.text$mn:00001D50 arg_0           = dword ptr  8
.text$mn:00001D50 arg_4           = dword ptr  0Ch
.text$mn:00001D50 arg_8           = dword ptr  10h
.text$mn:00001D50
.text$mn:00001D50                 push    ebp
.text$mn:00001D51                 mov     ebp, esp
.text$mn:00001D53                 mov     eax, [ebp+arg_8]
.text$mn:00001D56                 push    eax
.text$mn:00001D57                 call    ??$forward@ABURecentItem@@@std@@YAABURecentItem@@ABU1@@Z ; std::forward<RecentItem const &>(RecentItem const &)
.text$mn:00001D5C                 add     esp, 4
.text$mn:00001D5F                 push    eax             ; int
.text$mn:00001D60                 mov     ecx, [ebp+arg_4]
.text$mn:00001D63                 push    ecx             ; void *
.text$mn:00001D64                 mov     ecx, [ebp+arg_0]
.text$mn:00001D67                 call    ?construct@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@ABU3@@Z ; std::allocator<RecentItem>::construct(RecentItem *,RecentItem const &)
.text$mn:00001D6C                 pop     ebp
.text$mn:00001D6D                 retn
.text$mn:00001D6D ??$construct@URecentItem@@ABU1@@?$allocator_traits@V?$allocator@URecentItem@@@std@@@std@@SAXAAV?$allocator@URecentItem@@@1@PAURecentItem@@ABU3@@Z endp
.text$mn:00001D6D
.text$mn:00001D6D ; ---------------------------------------------------------------------------
.text$mn:00001D6E                 align 10h
.text$mn:00001D6E _text$mn        ends
.text$mn:00001D6E
.text$mn:00001D70 ; ===========================================================================
.text$mn:00001D70
.text$mn:00001D70 ; Segment type: Pure code
.text$mn:00001D70 ; Segment permissions: Read/Execute
.text$mn:00001D70 _text$mn        segment para public 'CODE' use32
.text$mn:00001D70                 assume cs:_text$mn
.text$mn:00001D70                 ;org 1D70h
.text$mn:00001D70 ; COMDAT (pick any)
.text$mn:00001D70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D70
.text$mn:00001D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D70
.text$mn:00001D70 ; Attributes: bp-based frame
.text$mn:00001D70
.text$mn:00001D70 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00001D70                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001D70 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00001D70                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00001D70                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+32p
.text$mn:00001D70
.text$mn:00001D70 var_1C          = dword ptr -1Ch
.text$mn:00001D70 var_18          = dword ptr -18h
.text$mn:00001D70 var_14          = dword ptr -14h
.text$mn:00001D70 var_10          = dword ptr -10h
.text$mn:00001D70 var_C           = dword ptr -0Ch
.text$mn:00001D70 var_4           = dword ptr -4
.text$mn:00001D70 arg_0           = dword ptr  8
.text$mn:00001D70 arg_4           = dword ptr  0Ch
.text$mn:00001D70
.text$mn:00001D70                 push    ebp
.text$mn:00001D71                 mov     ebp, esp
.text$mn:00001D73                 push    0FFFFFFFFh
.text$mn:00001D75                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001D7A                 mov     eax, large fs:0
.text$mn:00001D80                 push    eax
.text$mn:00001D81                 sub     esp, 10h
.text$mn:00001D84                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001D89                 xor     eax, ebp
.text$mn:00001D8B                 push    eax
.text$mn:00001D8C                 lea     eax, [ebp+var_C]
.text$mn:00001D8F                 mov     large fs:0, eax
.text$mn:00001D95                 mov     [ebp+var_18], ecx
.text$mn:00001D98                 mov     eax, [ebp+arg_0]
.text$mn:00001D9B                 push    eax             ; void *
.text$mn:00001D9C                 push    8               ; unsigned int
.text$mn:00001D9E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001DA3                 add     esp, 8
.text$mn:00001DA6                 mov     [ebp+var_10], eax
.text$mn:00001DA9                 mov     [ebp+var_4], 0
.text$mn:00001DB0                 cmp     [ebp+var_10], 0
.text$mn:00001DB4                 jz      short loc_1DD7
.text$mn:00001DB6                 mov     ecx, [ebp+arg_4]
.text$mn:00001DB9                 push    ecx
.text$mn:00001DBA                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00001DBF                 add     esp, 4
.text$mn:00001DC2                 mov     edx, [eax]
.text$mn:00001DC4                 mov     eax, [eax+4]
.text$mn:00001DC7                 mov     ecx, [ebp+var_10]
.text$mn:00001DCA                 mov     [ecx], edx
.text$mn:00001DCC                 mov     [ecx+4], eax
.text$mn:00001DCF                 mov     edx, [ebp+var_10]
.text$mn:00001DD2                 mov     [ebp+var_14], edx
.text$mn:00001DD5                 jmp     short loc_1DDE
.text$mn:00001DD7 ; ---------------------------------------------------------------------------
.text$mn:00001DD7
.text$mn:00001DD7 loc_1DD7:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00001DD7                 mov     [ebp+var_14], 0
.text$mn:00001DDE
.text$mn:00001DDE loc_1DDE:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00001DDE                 mov     eax, [ebp+var_14]
.text$mn:00001DE1                 mov     [ebp+var_1C], eax
.text$mn:00001DE4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001DEB                 mov     ecx, [ebp+var_C]
.text$mn:00001DEE                 mov     large fs:0, ecx
.text$mn:00001DF5                 pop     ecx
.text$mn:00001DF6                 mov     esp, ebp
.text$mn:00001DF8                 pop     ebp
.text$mn:00001DF9                 retn    8
.text$mn:00001DF9 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00001DF9
.text$mn:00001DF9 _text$mn        ends
.text$mn:00001DF9
.text$x:00001DFC ; ===========================================================================
.text$x:00001DFC
.text$x:00001DFC ; Segment type: Pure code
.text$x:00001DFC ; Segment permissions: Read/Execute
.text$x:00001DFC _text$x         segment para public 'CODE' use32
.text$x:00001DFC                 assume cs:_text$x
.text$x:00001DFC                 ;org 1DFCh
.text$x:00001DFC ; COMDAT (pick associative to section at 1D70)
.text$x:00001DFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001DFC
.text$x:00001DFC ; =============== S U B R O U T I N E =======================================
.text$x:00001DFC
.text$x:00001DFC
.text$x:00001DFC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00001DFC                                         ; DATA XREF: .xdata$x:00007430o
.text$x:00001DFC                 mov     eax, [ebp+8]
.text$x:00001DFF                 push    eax
.text$x:00001E00                 mov     eax, [ebp-10h]
.text$x:00001E03                 push    eax             ; void *
.text$x:00001E04                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001E09                 add     esp, 8
.text$x:00001E0C                 retn
.text$x:00001E0C __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00001E0C
.text$x:00001E0D
.text$x:00001E0D ; =============== S U B R O U T I N E =======================================
.text$x:00001E0D
.text$x:00001E0D
.text$x:00001E0D __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00001E0D                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00001E0D
.text$x:00001E0D arg_4           = dword ptr  8
.text$x:00001E0D
.text$x:00001E0D                 mov     edx, [esp+arg_4]
.text$x:00001E11                 lea     eax, [edx+0Ch]
.text$x:00001E14                 mov     ecx, [edx-14h]
.text$x:00001E17                 xor     ecx, eax
.text$x:00001E19                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E1E                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00001E23                 jmp     ___CxxFrameHandler3
.text$x:00001E23 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00001E23
.text$x:00001E23 _text$x         ends
.text$x:00001E23
.text$mn:00001E28 ; ===========================================================================
.text$mn:00001E28
.text$mn:00001E28 ; Segment type: Pure code
.text$mn:00001E28 ; Segment permissions: Read/Execute
.text$mn:00001E28 _text$mn        segment para public 'CODE' use32
.text$mn:00001E28                 assume cs:_text$mn
.text$mn:00001E28                 ;org 1E28h
.text$mn:00001E28 ; COMDAT (pick any)
.text$mn:00001E28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E28
.text$mn:00001E28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E28
.text$mn:00001E28 ; Attributes: bp-based frame
.text$mn:00001E28
.text$mn:00001E28 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001E28                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00001E28 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00001E28                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00001E28
.text$mn:00001E28 var_4           = dword ptr -4
.text$mn:00001E28 arg_0           = dword ptr  8
.text$mn:00001E28
.text$mn:00001E28                 push    ebp
.text$mn:00001E29                 mov     ebp, esp
.text$mn:00001E2B                 push    ecx
.text$mn:00001E2C                 mov     [ebp+var_4], ecx
.text$mn:00001E2F                 mov     eax, [ebp+arg_0]
.text$mn:00001E32                 push    eax
.text$mn:00001E33                 mov     ecx, [ebp+var_4]
.text$mn:00001E36                 push    ecx
.text$mn:00001E37                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00001E3C                 add     esp, 8
.text$mn:00001E3F                 mov     esp, ebp
.text$mn:00001E41                 pop     ebp
.text$mn:00001E42                 retn    4
.text$mn:00001E42 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00001E42
.text$mn:00001E42 ; ---------------------------------------------------------------------------
.text$mn:00001E45                 align 4
.text$mn:00001E45 _text$mn        ends
.text$mn:00001E45
.text$mn:00001E48 ; ===========================================================================
.text$mn:00001E48
.text$mn:00001E48 ; Segment type: Pure code
.text$mn:00001E48 ; Segment permissions: Read/Execute
.text$mn:00001E48 _text$mn        segment para public 'CODE' use32
.text$mn:00001E48                 assume cs:_text$mn
.text$mn:00001E48                 ;org 1E48h
.text$mn:00001E48 ; COMDAT (pick any)
.text$mn:00001E48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E48
.text$mn:00001E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E48
.text$mn:00001E48 ; Attributes: bp-based frame
.text$mn:00001E48
.text$mn:00001E48 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00001E48                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00001E48 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00001E48                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00001E48
.text$mn:00001E48 var_4           = dword ptr -4
.text$mn:00001E48
.text$mn:00001E48                 push    ebp
.text$mn:00001E49                 mov     ebp, esp
.text$mn:00001E4B                 push    ecx
.text$mn:00001E4C                 mov     [ebp+var_4], ecx
.text$mn:00001E4F                 mov     esp, ebp
.text$mn:00001E51                 pop     ebp
.text$mn:00001E52                 retn    4
.text$mn:00001E52 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00001E52
.text$mn:00001E52 ; ---------------------------------------------------------------------------
.text$mn:00001E55                 align 4
.text$mn:00001E55 _text$mn        ends
.text$mn:00001E55
.text$mn:00001E58 ; ===========================================================================
.text$mn:00001E58
.text$mn:00001E58 ; Segment type: Pure code
.text$mn:00001E58 ; Segment permissions: Read/Execute
.text$mn:00001E58 _text$mn        segment para public 'CODE' use32
.text$mn:00001E58                 assume cs:_text$mn
.text$mn:00001E58                 ;org 1E58h
.text$mn:00001E58 ; COMDAT (pick any)
.text$mn:00001E58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E58
.text$mn:00001E58 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E58
.text$mn:00001E58 ; Attributes: bp-based frame
.text$mn:00001E58
.text$mn:00001E58 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00001E58                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00001E58 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00001E58                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00001E58
.text$mn:00001E58 arg_0           = dword ptr  8
.text$mn:00001E58 arg_4           = dword ptr  0Ch
.text$mn:00001E58
.text$mn:00001E58                 push    ebp
.text$mn:00001E59                 mov     ebp, esp
.text$mn:00001E5B                 mov     eax, [ebp+arg_4]
.text$mn:00001E5E                 push    eax
.text$mn:00001E5F                 mov     ecx, [ebp+arg_0]
.text$mn:00001E62                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00001E67                 pop     ebp
.text$mn:00001E68                 retn
.text$mn:00001E68 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00001E68
.text$mn:00001E68 ; ---------------------------------------------------------------------------
.text$mn:00001E69                 align 4
.text$mn:00001E69 _text$mn        ends
.text$mn:00001E69
.text$mn:00001E6C ; ===========================================================================
.text$mn:00001E6C
.text$mn:00001E6C ; Segment type: Pure code
.text$mn:00001E6C ; Segment permissions: Read/Execute
.text$mn:00001E6C _text$mn        segment para public 'CODE' use32
.text$mn:00001E6C                 assume cs:_text$mn
.text$mn:00001E6C                 ;org 1E6Ch
.text$mn:00001E6C ; COMDAT (pick any)
.text$mn:00001E6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E6C
.text$mn:00001E6C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E6C
.text$mn:00001E6C ; Attributes: bp-based frame
.text$mn:00001E6C
.text$mn:00001E6C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00001E6C                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:00001E6C ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:00001E6C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:00001E6C
.text$mn:00001E6C var_4           = dword ptr -4
.text$mn:00001E6C arg_0           = dword ptr  8
.text$mn:00001E6C
.text$mn:00001E6C                 push    ebp
.text$mn:00001E6D                 mov     ebp, esp
.text$mn:00001E6F                 push    ecx
.text$mn:00001E70                 mov     [ebp+var_4], ecx
.text$mn:00001E73                 mov     eax, [ebp+arg_0]
.text$mn:00001E76                 push    eax
.text$mn:00001E77                 mov     ecx, [ebp+var_4]
.text$mn:00001E7A                 push    ecx
.text$mn:00001E7B                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00001E80                 add     esp, 8
.text$mn:00001E83                 mov     esp, ebp
.text$mn:00001E85                 pop     ebp
.text$mn:00001E86                 retn    4
.text$mn:00001E86 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:00001E86
.text$mn:00001E86 ; ---------------------------------------------------------------------------
.text$mn:00001E89                 align 4
.text$mn:00001E89 _text$mn        ends
.text$mn:00001E89
.text$mn:00001E8C ; ===========================================================================
.text$mn:00001E8C
.text$mn:00001E8C ; Segment type: Pure code
.text$mn:00001E8C ; Segment permissions: Read/Execute
.text$mn:00001E8C _text$mn        segment para public 'CODE' use32
.text$mn:00001E8C                 assume cs:_text$mn
.text$mn:00001E8C                 ;org 1E8Ch
.text$mn:00001E8C ; COMDAT (pick any)
.text$mn:00001E8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E8C
.text$mn:00001E8C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E8C
.text$mn:00001E8C ; Attributes: bp-based frame
.text$mn:00001E8C
.text$mn:00001E8C ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00001E8C                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:00001E8C ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:00001E8C                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:00001E8C
.text$mn:00001E8C var_4           = dword ptr -4
.text$mn:00001E8C
.text$mn:00001E8C                 push    ebp
.text$mn:00001E8D                 mov     ebp, esp
.text$mn:00001E8F                 push    ecx
.text$mn:00001E90                 mov     [ebp+var_4], ecx
.text$mn:00001E93                 mov     esp, ebp
.text$mn:00001E95                 pop     ebp
.text$mn:00001E96                 retn    4
.text$mn:00001E96 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:00001E96
.text$mn:00001E96 ; ---------------------------------------------------------------------------
.text$mn:00001E99                 align 4
.text$mn:00001E99 _text$mn        ends
.text$mn:00001E99
.text$mn:00001E9C ; ===========================================================================
.text$mn:00001E9C
.text$mn:00001E9C ; Segment type: Pure code
.text$mn:00001E9C ; Segment permissions: Read/Execute
.text$mn:00001E9C _text$mn        segment para public 'CODE' use32
.text$mn:00001E9C                 assume cs:_text$mn
.text$mn:00001E9C                 ;org 1E9Ch
.text$mn:00001E9C ; COMDAT (pick any)
.text$mn:00001E9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E9C
.text$mn:00001E9C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E9C
.text$mn:00001E9C ; Attributes: bp-based frame
.text$mn:00001E9C
.text$mn:00001E9C ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00001E9C                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00001E9C ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00001E9C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00001E9C
.text$mn:00001E9C arg_0           = dword ptr  8
.text$mn:00001E9C arg_4           = dword ptr  0Ch
.text$mn:00001E9C
.text$mn:00001E9C                 push    ebp
.text$mn:00001E9D                 mov     ebp, esp
.text$mn:00001E9F                 mov     eax, [ebp+arg_4]
.text$mn:00001EA2                 push    eax
.text$mn:00001EA3                 mov     ecx, [ebp+arg_0]
.text$mn:00001EA6                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00001EAB                 pop     ebp
.text$mn:00001EAC                 retn
.text$mn:00001EAC ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:00001EAC
.text$mn:00001EAC ; ---------------------------------------------------------------------------
.text$mn:00001EAD                 align 10h
.text$mn:00001EAD _text$mn        ends
.text$mn:00001EAD
.text$mn:00001EB0 ; ===========================================================================
.text$mn:00001EB0
.text$mn:00001EB0 ; Segment type: Pure code
.text$mn:00001EB0 ; Segment permissions: Read/Execute
.text$mn:00001EB0 _text$mn        segment para public 'CODE' use32
.text$mn:00001EB0                 assume cs:_text$mn
.text$mn:00001EB0                 ;org 1EB0h
.text$mn:00001EB0 ; COMDAT (pick any)
.text$mn:00001EB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EB0
.text$mn:00001EB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EB0
.text$mn:00001EB0 ; Attributes: bp-based frame
.text$mn:00001EB0
.text$mn:00001EB0 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct RecentItem>>::destroy<struct RecentItem>(struct RecentItem *)
.text$mn:00001EB0                 public ??$destroy@URecentItem@@@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAEXPAURecentItem@@@Z
.text$mn:00001EB0 ??$destroy@URecentItem@@@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAEXPAURecentItem@@@Z proc near
.text$mn:00001EB0                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::pop_back(void)+8Dp
.text$mn:00001EB0                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::pop_front(void)+83p
.text$mn:00001EB0
.text$mn:00001EB0 var_4           = dword ptr -4
.text$mn:00001EB0 arg_0           = dword ptr  8
.text$mn:00001EB0
.text$mn:00001EB0                 push    ebp
.text$mn:00001EB1                 mov     ebp, esp
.text$mn:00001EB3                 push    ecx
.text$mn:00001EB4                 mov     [ebp+var_4], ecx
.text$mn:00001EB7                 mov     eax, [ebp+arg_0]
.text$mn:00001EBA                 push    eax
.text$mn:00001EBB                 mov     ecx, [ebp+var_4]
.text$mn:00001EBE                 push    ecx
.text$mn:00001EBF                 call    ??$destroy@URecentItem@@@?$allocator_traits@V?$allocator@URecentItem@@@std@@@std@@SAXAAV?$allocator@URecentItem@@@1@PAURecentItem@@@Z ; std::allocator_traits<std::allocator<RecentItem>>::destroy<RecentItem>(std::allocator<RecentItem> &,RecentItem *)
.text$mn:00001EC4                 add     esp, 8
.text$mn:00001EC7                 mov     esp, ebp
.text$mn:00001EC9                 pop     ebp
.text$mn:00001ECA                 retn    4
.text$mn:00001ECA ??$destroy@URecentItem@@@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAEXPAURecentItem@@@Z endp
.text$mn:00001ECA
.text$mn:00001ECA ; ---------------------------------------------------------------------------
.text$mn:00001ECD                 align 10h
.text$mn:00001ECD _text$mn        ends
.text$mn:00001ECD
.text$mn:00001ED0 ; ===========================================================================
.text$mn:00001ED0
.text$mn:00001ED0 ; Segment type: Pure code
.text$mn:00001ED0 ; Segment permissions: Read/Execute
.text$mn:00001ED0 _text$mn        segment para public 'CODE' use32
.text$mn:00001ED0                 assume cs:_text$mn
.text$mn:00001ED0                 ;org 1ED0h
.text$mn:00001ED0 ; COMDAT (pick any)
.text$mn:00001ED0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001ED0
.text$mn:00001ED0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001ED0
.text$mn:00001ED0 ; Attributes: bp-based frame
.text$mn:00001ED0
.text$mn:00001ED0 ; public: void __thiscall std::allocator<struct RecentItem>::destroy<struct RecentItem>(struct RecentItem *)
.text$mn:00001ED0                 public ??$destroy@URecentItem@@@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@@Z
.text$mn:00001ED0 ??$destroy@URecentItem@@@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@@Z proc near
.text$mn:00001ED0                                         ; CODE XREF: std::allocator_traits<std::allocator<RecentItem>>::destroy<RecentItem>(std::allocator<RecentItem> &,RecentItem *)+Ap
.text$mn:00001ED0
.text$mn:00001ED0 var_4           = dword ptr -4
.text$mn:00001ED0 arg_0           = dword ptr  8
.text$mn:00001ED0
.text$mn:00001ED0                 push    ebp
.text$mn:00001ED1                 mov     ebp, esp
.text$mn:00001ED3                 push    ecx
.text$mn:00001ED4                 mov     [ebp+var_4], ecx
.text$mn:00001ED7                 push    0
.text$mn:00001ED9                 mov     ecx, [ebp+arg_0]
.text$mn:00001EDC                 call    ??_GRecentItem@@QAEPAXI@Z ; RecentItem::`scalar deleting destructor'(uint)
.text$mn:00001EE1                 mov     esp, ebp
.text$mn:00001EE3                 pop     ebp
.text$mn:00001EE4                 retn    4
.text$mn:00001EE4 ??$destroy@URecentItem@@@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@@Z endp
.text$mn:00001EE4
.text$mn:00001EE4 ; ---------------------------------------------------------------------------
.text$mn:00001EE7                 align 4
.text$mn:00001EE7 _text$mn        ends
.text$mn:00001EE7
.text$mn:00001EE8 ; ===========================================================================
.text$mn:00001EE8
.text$mn:00001EE8 ; Segment type: Pure code
.text$mn:00001EE8 ; Segment permissions: Read/Execute
.text$mn:00001EE8 _text$mn        segment para public 'CODE' use32
.text$mn:00001EE8                 assume cs:_text$mn
.text$mn:00001EE8                 ;org 1EE8h
.text$mn:00001EE8 ; COMDAT (pick any)
.text$mn:00001EE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EE8
.text$mn:00001EE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EE8
.text$mn:00001EE8 ; Attributes: bp-based frame
.text$mn:00001EE8
.text$mn:00001EE8 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct RecentItem>>::destroy<struct RecentItem>(class std::allocator<struct RecentItem> &, struct RecentItem *)
.text$mn:00001EE8                 public ??$destroy@URecentItem@@@?$allocator_traits@V?$allocator@URecentItem@@@std@@@std@@SAXAAV?$allocator@URecentItem@@@1@PAURecentItem@@@Z
.text$mn:00001EE8 ??$destroy@URecentItem@@@?$allocator_traits@V?$allocator@URecentItem@@@std@@@std@@SAXAAV?$allocator@URecentItem@@@1@PAURecentItem@@@Z proc near
.text$mn:00001EE8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<RecentItem>>::destroy<RecentItem>(RecentItem *)+Fp
.text$mn:00001EE8
.text$mn:00001EE8 arg_0           = dword ptr  8
.text$mn:00001EE8 arg_4           = dword ptr  0Ch
.text$mn:00001EE8
.text$mn:00001EE8                 push    ebp
.text$mn:00001EE9                 mov     ebp, esp
.text$mn:00001EEB                 mov     eax, [ebp+arg_4]
.text$mn:00001EEE                 push    eax
.text$mn:00001EEF                 mov     ecx, [ebp+arg_0]
.text$mn:00001EF2                 call    ??$destroy@URecentItem@@@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@@Z ; std::allocator<RecentItem>::destroy<RecentItem>(RecentItem *)
.text$mn:00001EF7                 pop     ebp
.text$mn:00001EF8                 retn
.text$mn:00001EF8 ??$destroy@URecentItem@@@?$allocator_traits@V?$allocator@URecentItem@@@std@@@std@@SAXAAV?$allocator@URecentItem@@@1@PAURecentItem@@@Z endp
.text$mn:00001EF8
.text$mn:00001EF8 ; ---------------------------------------------------------------------------
.text$mn:00001EF9                 align 4
.text$mn:00001EF9 _text$mn        ends
.text$mn:00001EF9
.text$mn:00001EFC ; ===========================================================================
.text$mn:00001EFC
.text$mn:00001EFC ; Segment type: Pure code
.text$mn:00001EFC ; Segment permissions: Read/Execute
.text$mn:00001EFC _text$mn        segment para public 'CODE' use32
.text$mn:00001EFC                 assume cs:_text$mn
.text$mn:00001EFC                 ;org 1EFCh
.text$mn:00001EFC ; COMDAT (pick any)
.text$mn:00001EFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EFC
.text$mn:00001EFC ; =============== S U B R O U T I N E =======================================
.text$mn:00001EFC
.text$mn:00001EFC ; Attributes: bp-based frame
.text$mn:00001EFC
.text$mn:00001EFC ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00001EFC                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00001EFC ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00001EFC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00001EFC                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+22p
.text$mn:00001EFC
.text$mn:00001EFC var_4           = dword ptr -4
.text$mn:00001EFC
.text$mn:00001EFC                 push    ebp
.text$mn:00001EFD                 mov     ebp, esp
.text$mn:00001EFF                 push    ecx
.text$mn:00001F00                 mov     [ebp+var_4], ecx
.text$mn:00001F03                 mov     esp, ebp
.text$mn:00001F05                 pop     ebp
.text$mn:00001F06                 retn    4
.text$mn:00001F06 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00001F06
.text$mn:00001F06 ; ---------------------------------------------------------------------------
.text$mn:00001F09                 align 4
.text$mn:00001F09 _text$mn        ends
.text$mn:00001F09
.text$mn:00001F0C ; ===========================================================================
.text$mn:00001F0C
.text$mn:00001F0C ; Segment type: Pure code
.text$mn:00001F0C ; Segment permissions: Read/Execute
.text$mn:00001F0C _text$mn        segment para public 'CODE' use32
.text$mn:00001F0C                 assume cs:_text$mn
.text$mn:00001F0C                 ;org 1F0Ch
.text$mn:00001F0C ; COMDAT (pick any)
.text$mn:00001F0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F0C
.text$mn:00001F0C ; =============== S U B R O U T I N E =======================================
.text$mn:00001F0C
.text$mn:00001F0C ; Attributes: bp-based frame
.text$mn:00001F0C
.text$mn:00001F0C ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00001F0C                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00001F0C ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00001F0C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00001F0C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00001F0C
.text$mn:00001F0C arg_0           = dword ptr  8
.text$mn:00001F0C
.text$mn:00001F0C                 push    ebp
.text$mn:00001F0D                 mov     ebp, esp
.text$mn:00001F0F                 mov     eax, [ebp+arg_0]
.text$mn:00001F12                 pop     ebp
.text$mn:00001F13                 retn
.text$mn:00001F13 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00001F13
.text$mn:00001F13 _text$mn        ends
.text$mn:00001F13
.text$mn:00001F14 ; ===========================================================================
.text$mn:00001F14
.text$mn:00001F14 ; Segment type: Pure code
.text$mn:00001F14 ; Segment permissions: Read/Execute
.text$mn:00001F14 _text$mn        segment para public 'CODE' use32
.text$mn:00001F14                 assume cs:_text$mn
.text$mn:00001F14                 ;org 1F14h
.text$mn:00001F14 ; COMDAT (pick any)
.text$mn:00001F14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F14
.text$mn:00001F14 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F14
.text$mn:00001F14 ; Attributes: bp-based frame
.text$mn:00001F14
.text$mn:00001F14 ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00001F14                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:00001F14 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:00001F14                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:00001F14                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:00001F14
.text$mn:00001F14 arg_0           = dword ptr  8
.text$mn:00001F14
.text$mn:00001F14                 push    ebp
.text$mn:00001F15                 mov     ebp, esp
.text$mn:00001F17                 mov     eax, [ebp+arg_0]
.text$mn:00001F1A                 pop     ebp
.text$mn:00001F1B                 retn
.text$mn:00001F1B ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:00001F1B
.text$mn:00001F1B _text$mn        ends
.text$mn:00001F1B
.text$mn:00001F1C ; ===========================================================================
.text$mn:00001F1C
.text$mn:00001F1C ; Segment type: Pure code
.text$mn:00001F1C ; Segment permissions: Read/Execute
.text$mn:00001F1C _text$mn        segment para public 'CODE' use32
.text$mn:00001F1C                 assume cs:_text$mn
.text$mn:00001F1C                 ;org 1F1Ch
.text$mn:00001F1C ; COMDAT (pick any)
.text$mn:00001F1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F1C
.text$mn:00001F1C ; =============== S U B R O U T I N E =======================================
.text$mn:00001F1C
.text$mn:00001F1C ; Attributes: bp-based frame
.text$mn:00001F1C
.text$mn:00001F1C ; struct RecentItem const & __cdecl std::forward<struct RecentItem const &>(struct RecentItem const &)
.text$mn:00001F1C                 public ??$forward@ABURecentItem@@@std@@YAABURecentItem@@ABU1@@Z
.text$mn:00001F1C ??$forward@ABURecentItem@@@std@@YAABURecentItem@@ABU1@@Z proc near
.text$mn:00001F1C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<RecentItem>>::construct<RecentItem,RecentItem const &>(RecentItem *,RecentItem const &)+Bp
.text$mn:00001F1C                                         ; std::allocator_traits<std::allocator<RecentItem>>::construct<RecentItem,RecentItem const &>(std::allocator<RecentItem> &,RecentItem *,RecentItem const &)+7p
.text$mn:00001F1C
.text$mn:00001F1C arg_0           = dword ptr  8
.text$mn:00001F1C
.text$mn:00001F1C                 push    ebp
.text$mn:00001F1D                 mov     ebp, esp
.text$mn:00001F1F                 mov     eax, [ebp+arg_0]
.text$mn:00001F22                 pop     ebp
.text$mn:00001F23                 retn
.text$mn:00001F23 ??$forward@ABURecentItem@@@std@@YAABURecentItem@@ABU1@@Z endp
.text$mn:00001F23
.text$mn:00001F23 _text$mn        ends
.text$mn:00001F23
.text$mn:00001F24 ; ===========================================================================
.text$mn:00001F24
.text$mn:00001F24 ; Segment type: Pure code
.text$mn:00001F24 ; Segment permissions: Read/Execute
.text$mn:00001F24 _text$mn        segment para public 'CODE' use32
.text$mn:00001F24                 assume cs:_text$mn
.text$mn:00001F24                 ;org 1F24h
.text$mn:00001F24 ; COMDAT (pick any)
.text$mn:00001F24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F24
.text$mn:00001F24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F24
.text$mn:00001F24 ; Attributes: bp-based frame
.text$mn:00001F24
.text$mn:00001F24 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00001F24                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00001F24 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00001F24                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00001F24
.text$mn:00001F24 arg_0           = dword ptr  8
.text$mn:00001F24
.text$mn:00001F24                 push    ebp
.text$mn:00001F25                 mov     ebp, esp
.text$mn:00001F27                 mov     eax, [ebp+arg_0]
.text$mn:00001F2A                 pop     ebp
.text$mn:00001F2B                 retn
.text$mn:00001F2B ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00001F2B
.text$mn:00001F2B _text$mn        ends
.text$mn:00001F2B
.text$mn:00001F2C ; ===========================================================================
.text$mn:00001F2C
.text$mn:00001F2C ; Segment type: Pure code
.text$mn:00001F2C ; Segment permissions: Read/Execute
.text$mn:00001F2C _text$mn        segment para public 'CODE' use32
.text$mn:00001F2C                 assume cs:_text$mn
.text$mn:00001F2C                 ;org 1F2Ch
.text$mn:00001F2C ; COMDAT (pick any)
.text$mn:00001F2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F2C
.text$mn:00001F2C ; =============== S U B R O U T I N E =======================================
.text$mn:00001F2C
.text$mn:00001F2C ; Attributes: bp-based frame
.text$mn:00001F2C
.text$mn:00001F2C ; struct RecentItem && __cdecl std::move<struct RecentItem &>(struct RecentItem &)
.text$mn:00001F2C                 public ??$move@AAURecentItem@@@std@@YA$$QAURecentItem@@AAU1@@Z
.text$mn:00001F2C ??$move@AAURecentItem@@@std@@YA$$QAURecentItem@@AAU1@@Z proc near
.text$mn:00001F2C                                         ; CODE XREF: std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+5Fp
.text$mn:00001F2C                                         ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+54p
.text$mn:00001F2C
.text$mn:00001F2C arg_0           = dword ptr  8
.text$mn:00001F2C
.text$mn:00001F2C                 push    ebp
.text$mn:00001F2D                 mov     ebp, esp
.text$mn:00001F2F                 mov     eax, [ebp+arg_0]
.text$mn:00001F32                 pop     ebp
.text$mn:00001F33                 retn
.text$mn:00001F33 ??$move@AAURecentItem@@@std@@YA$$QAURecentItem@@AAU1@@Z endp
.text$mn:00001F33
.text$mn:00001F33 _text$mn        ends
.text$mn:00001F33
.text$mn:00001F34 ; ===========================================================================
.text$mn:00001F34
.text$mn:00001F34 ; Segment type: Pure code
.text$mn:00001F34 ; Segment permissions: Read/Execute
.text$mn:00001F34 _text$mn        segment para public 'CODE' use32
.text$mn:00001F34                 assume cs:_text$mn
.text$mn:00001F34                 ;org 1F34h
.text$mn:00001F34 ; COMDAT (pick any)
.text$mn:00001F34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F34
.text$mn:00001F34 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F34
.text$mn:00001F34 ; Attributes: bp-based frame
.text$mn:00001F34
.text$mn:00001F34 ; int __stdcall std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(struct std::_Iterator_base12 *)
.text$mn:00001F34                 public ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00001F34 ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00001F34                                         ; CODE XREF: LastRecentFileList::remove(int)+D6p
.text$mn:00001F34                                         ; LastRecentFileList::clear(void)+D1p ...
.text$mn:00001F34
.text$mn:00001F34 var_10          = dword ptr -10h
.text$mn:00001F34 var_C           = dword ptr -0Ch
.text$mn:00001F34 var_4           = dword ptr -4
.text$mn:00001F34 arg_0           = dword ptr  8
.text$mn:00001F34
.text$mn:00001F34                 push    ebp
.text$mn:00001F35                 mov     ebp, esp
.text$mn:00001F37                 push    0FFFFFFFFh
.text$mn:00001F39                 push    offset __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00001F3E                 mov     eax, large fs:0
.text$mn:00001F44                 push    eax
.text$mn:00001F45                 push    ecx
.text$mn:00001F46                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001F4B                 xor     eax, ebp
.text$mn:00001F4D                 push    eax
.text$mn:00001F4E                 lea     eax, [ebp+var_C]
.text$mn:00001F51                 mov     large fs:0, eax
.text$mn:00001F57                 mov     [ebp+var_10], ecx
.text$mn:00001F5A                 mov     eax, [ebp+arg_0]
.text$mn:00001F5D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00001F5E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001F61                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:00001F66                 mov     [ebp+var_4], 0
.text$mn:00001F6D                 mov     ecx, [ebp+var_10]
.text$mn:00001F70                 mov     edx, [ebp+arg_0]
.text$mn:00001F73                 mov     eax, [edx+8]
.text$mn:00001F76                 mov     [ecx+8], eax
.text$mn:00001F79                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001F80                 mov     eax, [ebp+var_10]
.text$mn:00001F83                 mov     ecx, [ebp+var_C]
.text$mn:00001F86                 mov     large fs:0, ecx
.text$mn:00001F8D                 pop     ecx
.text$mn:00001F8E                 mov     esp, ebp
.text$mn:00001F90                 pop     ebp
.text$mn:00001F91                 retn    4
.text$mn:00001F91 ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00001F91
.text$mn:00001F91 _text$mn        ends
.text$mn:00001F91
.text$x:00001F94 ; ===========================================================================
.text$x:00001F94
.text$x:00001F94 ; Segment type: Pure code
.text$x:00001F94 ; Segment permissions: Read/Execute
.text$x:00001F94 _text$x         segment para public 'CODE' use32
.text$x:00001F94                 assume cs:_text$x
.text$x:00001F94                 ;org 1F94h
.text$x:00001F94 ; COMDAT (pick associative to section at 1F34)
.text$x:00001F94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001F94
.text$x:00001F94 ; =============== S U B R O U T I N E =======================================
.text$x:00001F94
.text$x:00001F94
.text$x:00001F94 __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00001F94                                         ; DATA XREF: .xdata$x:0000721Co
.text$x:00001F94                 mov     ecx, [ebp-10h]  ; this
.text$x:00001F97                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00001F97 __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00001F97
.text$x:00001F9C
.text$x:00001F9C ; =============== S U B R O U T I N E =======================================
.text$x:00001F9C
.text$x:00001F9C
.text$x:00001F9C __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00001F9C                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+5o
.text$x:00001F9C
.text$x:00001F9C arg_4           = dword ptr  8
.text$x:00001F9C
.text$x:00001F9C                 mov     edx, [esp+arg_4]
.text$x:00001FA0                 lea     eax, [edx+0Ch]
.text$x:00001FA3                 mov     ecx, [edx-8]
.text$x:00001FA6                 xor     ecx, eax
.text$x:00001FA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001FAD                 mov     eax, offset __ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00001FB2                 jmp     ___CxxFrameHandler3
.text$x:00001FB2 __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00001FB2
.text$x:00001FB2 ; ---------------------------------------------------------------------------
.text$x:00001FB7                 align 4
.text$x:00001FB7 _text$x         ends
.text$x:00001FB7
.text$mn:00001FB8 ; ===========================================================================
.text$mn:00001FB8
.text$mn:00001FB8 ; Segment type: Pure code
.text$mn:00001FB8 ; Segment permissions: Read/Execute
.text$mn:00001FB8 _text$mn        segment para public 'CODE' use32
.text$mn:00001FB8                 assume cs:_text$mn
.text$mn:00001FB8                 ;org 1FB8h
.text$mn:00001FB8 ; COMDAT (pick any)
.text$mn:00001FB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FB8
.text$mn:00001FB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FB8
.text$mn:00001FB8 ; Attributes: bp-based frame
.text$mn:00001FB8
.text$mn:00001FB8 ; int __stdcall std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(int, struct std::_Container_base12 *)
.text$mn:00001FB8                 public ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.text$mn:00001FB8 ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z proc near
.text$mn:00001FB8                                         ; CODE XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(uint,std::_Container_base12 const *)+31p
.text$mn:00001FB8
.text$mn:00001FB8 var_10          = dword ptr -10h
.text$mn:00001FB8 var_C           = dword ptr -0Ch
.text$mn:00001FB8 var_4           = dword ptr -4
.text$mn:00001FB8 arg_0           = dword ptr  8
.text$mn:00001FB8 arg_4           = dword ptr  0Ch
.text$mn:00001FB8
.text$mn:00001FB8                 push    ebp
.text$mn:00001FB9                 mov     ebp, esp
.text$mn:00001FBB                 push    0FFFFFFFFh
.text$mn:00001FBD                 push    offset __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.text$mn:00001FC2                 mov     eax, large fs:0
.text$mn:00001FC8                 push    eax
.text$mn:00001FC9                 push    ecx
.text$mn:00001FCA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001FCF                 xor     eax, ebp
.text$mn:00001FD1                 push    eax
.text$mn:00001FD2                 lea     eax, [ebp+var_C]
.text$mn:00001FD5                 mov     large fs:0, eax
.text$mn:00001FDB                 mov     [ebp+var_10], ecx
.text$mn:00001FDE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001FE1                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00001FE6                 mov     [ebp+var_4], 0
.text$mn:00001FED                 mov     eax, [ebp+arg_4]
.text$mn:00001FF0                 push    eax             ; struct std::_Container_base12 *
.text$mn:00001FF1                 mov     ecx, [ebp+var_10]
.text$mn:00001FF4                 call    ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Setcont(std::_Deque_val<std::_Deque_simple_types<RecentItem>> const *)
.text$mn:00001FF9                 mov     ecx, [ebp+var_10]
.text$mn:00001FFC                 mov     edx, [ebp+arg_0]
.text$mn:00001FFF                 mov     [ecx+8], edx
.text$mn:00002002                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002009                 mov     eax, [ebp+var_10]
.text$mn:0000200C                 mov     ecx, [ebp+var_C]
.text$mn:0000200F                 mov     large fs:0, ecx
.text$mn:00002016                 pop     ecx
.text$mn:00002017                 mov     esp, ebp
.text$mn:00002019                 pop     ebp
.text$mn:0000201A                 retn    8
.text$mn:0000201A ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z endp
.text$mn:0000201A
.text$mn:0000201A ; ---------------------------------------------------------------------------
.text$mn:0000201D                 align 10h
.text$mn:0000201D _text$mn        ends
.text$mn:0000201D
.text$x:00002020 ; ===========================================================================
.text$x:00002020
.text$x:00002020 ; Segment type: Pure code
.text$x:00002020 ; Segment permissions: Read/Execute
.text$x:00002020 _text$x         segment para public 'CODE' use32
.text$x:00002020                 assume cs:_text$x
.text$x:00002020                 ;org 2020h
.text$x:00002020 ; COMDAT (pick associative to section at 1FB8)
.text$x:00002020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002020
.text$x:00002020 ; =============== S U B R O U T I N E =======================================
.text$x:00002020
.text$x:00002020
.text$x:00002020 __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0 proc near
.text$x:00002020                                         ; DATA XREF: .xdata$x:00007190o
.text$x:00002020                 mov     ecx, [ebp-10h]  ; this
.text$x:00002023                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00002023 __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0 endp
.text$x:00002023
.text$x:00002028
.text$x:00002028 ; =============== S U B R O U T I N E =======================================
.text$x:00002028
.text$x:00002028
.text$x:00002028 __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z proc near
.text$x:00002028                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(uint,std::_Container_base12 const *)+5o
.text$x:00002028
.text$x:00002028 arg_4           = dword ptr  8
.text$x:00002028
.text$x:00002028                 mov     edx, [esp+arg_4]
.text$x:0000202C                 lea     eax, [edx+0Ch]
.text$x:0000202F                 mov     ecx, [edx-8]
.text$x:00002032                 xor     ecx, eax
.text$x:00002034                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002039                 mov     eax, offset __ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.text$x:0000203E                 jmp     ___CxxFrameHandler3
.text$x:0000203E __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z endp
.text$x:0000203E
.text$x:0000203E ; ---------------------------------------------------------------------------
.text$x:00002043                 align 4
.text$x:00002043 _text$x         ends
.text$x:00002043
.text$mn:00002044 ; ===========================================================================
.text$mn:00002044
.text$mn:00002044 ; Segment type: Pure code
.text$mn:00002044 ; Segment permissions: Read/Execute
.text$mn:00002044 _text$mn        segment para public 'CODE' use32
.text$mn:00002044                 assume cs:_text$mn
.text$mn:00002044                 ;org 2044h
.text$mn:00002044 ; COMDAT (pick any)
.text$mn:00002044                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002044
.text$mn:00002044 ; =============== S U B R O U T I N E =======================================
.text$mn:00002044
.text$mn:00002044 ; Attributes: bp-based frame
.text$mn:00002044
.text$mn:00002044 ; int __stdcall std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(struct std::_Iterator_base12 *)
.text$mn:00002044                 public ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002044 ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00002044                                         ; CODE XREF: std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,wchar_t const *,uint)+56p
.text$mn:00002044                                         ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,wchar_t const *,uint)+74p ...
.text$mn:00002044
.text$mn:00002044 var_10          = dword ptr -10h
.text$mn:00002044 var_C           = dword ptr -0Ch
.text$mn:00002044 var_4           = dword ptr -4
.text$mn:00002044 arg_0           = dword ptr  8
.text$mn:00002044
.text$mn:00002044                 push    ebp
.text$mn:00002045                 mov     ebp, esp
.text$mn:00002047                 push    0FFFFFFFFh
.text$mn:00002049                 push    offset __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000204E                 mov     eax, large fs:0
.text$mn:00002054                 push    eax
.text$mn:00002055                 push    ecx
.text$mn:00002056                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000205B                 xor     eax, ebp
.text$mn:0000205D                 push    eax
.text$mn:0000205E                 lea     eax, [ebp+var_C]
.text$mn:00002061                 mov     large fs:0, eax
.text$mn:00002067                 mov     [ebp+var_10], ecx
.text$mn:0000206A                 mov     eax, [ebp+arg_0]
.text$mn:0000206D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000206E                 mov     ecx, [ebp+var_10]
.text$mn:00002071                 call    ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00002076                 mov     [ebp+var_4], 0
.text$mn:0000207D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002084                 mov     eax, [ebp+var_10]
.text$mn:00002087                 mov     ecx, [ebp+var_C]
.text$mn:0000208A                 mov     large fs:0, ecx
.text$mn:00002091                 pop     ecx
.text$mn:00002092                 mov     esp, ebp
.text$mn:00002094                 pop     ebp
.text$mn:00002095                 retn    4
.text$mn:00002095 ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00002095
.text$mn:00002095 _text$mn        ends
.text$mn:00002095
.text$x:00002098 ; ===========================================================================
.text$x:00002098
.text$x:00002098 ; Segment type: Pure code
.text$x:00002098 ; Segment permissions: Read/Execute
.text$x:00002098 _text$x         segment para public 'CODE' use32
.text$x:00002098                 assume cs:_text$x
.text$x:00002098                 ;org 2098h
.text$x:00002098 ; COMDAT (pick associative to section at 2044)
.text$x:00002098                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002098
.text$x:00002098 ; =============== S U B R O U T I N E =======================================
.text$x:00002098
.text$x:00002098
.text$x:00002098 __unwindfunclet$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00002098                                         ; DATA XREF: .xdata$x:00007308o
.text$x:00002098                 mov     ecx, [ebp-10h]
.text$x:0000209B                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:0000209B __unwindfunclet$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000209B
.text$x:000020A0
.text$x:000020A0 ; =============== S U B R O U T I N E =======================================
.text$x:000020A0
.text$x:000020A0
.text$x:000020A0 __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:000020A0                                         ; DATA XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+5o
.text$x:000020A0
.text$x:000020A0 arg_4           = dword ptr  8
.text$x:000020A0
.text$x:000020A0                 mov     edx, [esp+arg_4]
.text$x:000020A4                 lea     eax, [edx+0Ch]
.text$x:000020A7                 mov     ecx, [edx-8]
.text$x:000020AA                 xor     ecx, eax
.text$x:000020AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000020B1                 mov     eax, offset __ehfuncinfo$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:000020B6                 jmp     ___CxxFrameHandler3
.text$x:000020B6 __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:000020B6
.text$x:000020B6 ; ---------------------------------------------------------------------------
.text$x:000020BB                 align 4
.text$x:000020BB _text$x         ends
.text$x:000020BB
.text$mn:000020BC ; ===========================================================================
.text$mn:000020BC
.text$mn:000020BC ; Segment type: Pure code
.text$mn:000020BC ; Segment permissions: Read/Execute
.text$mn:000020BC _text$mn        segment para public 'CODE' use32
.text$mn:000020BC                 assume cs:_text$mn
.text$mn:000020BC                 ;org 20BCh
.text$mn:000020BC ; COMDAT (pick any)
.text$mn:000020BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020BC
.text$mn:000020BC ; =============== S U B R O U T I N E =======================================
.text$mn:000020BC
.text$mn:000020BC ; Attributes: bp-based frame
.text$mn:000020BC
.text$mn:000020BC ; int __stdcall std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(int, struct std::_Container_base12 *)
.text$mn:000020BC                 public ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.text$mn:000020BC ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z proc near
.text$mn:000020BC                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Make_iter(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+41p
.text$mn:000020BC                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::begin(void)+3Dp ...
.text$mn:000020BC
.text$mn:000020BC var_10          = dword ptr -10h
.text$mn:000020BC var_C           = dword ptr -0Ch
.text$mn:000020BC var_4           = dword ptr -4
.text$mn:000020BC arg_0           = dword ptr  8
.text$mn:000020BC arg_4           = dword ptr  0Ch
.text$mn:000020BC
.text$mn:000020BC                 push    ebp
.text$mn:000020BD                 mov     ebp, esp
.text$mn:000020BF                 push    0FFFFFFFFh
.text$mn:000020C1                 push    offset __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.text$mn:000020C6                 mov     eax, large fs:0
.text$mn:000020CC                 push    eax
.text$mn:000020CD                 push    ecx
.text$mn:000020CE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000020D3                 xor     eax, ebp
.text$mn:000020D5                 push    eax
.text$mn:000020D6                 lea     eax, [ebp+var_C]
.text$mn:000020D9                 mov     large fs:0, eax
.text$mn:000020DF                 mov     [ebp+var_10], ecx
.text$mn:000020E2                 mov     eax, [ebp+arg_4]
.text$mn:000020E5                 push    eax             ; struct std::_Container_base12 *
.text$mn:000020E6                 mov     ecx, [ebp+arg_0]
.text$mn:000020E9                 push    ecx             ; int
.text$mn:000020EA                 mov     ecx, [ebp+var_10]
.text$mn:000020ED                 call    ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(uint,std::_Container_base12 const *)
.text$mn:000020F2                 mov     [ebp+var_4], 0
.text$mn:000020F9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002100                 mov     eax, [ebp+var_10]
.text$mn:00002103                 mov     ecx, [ebp+var_C]
.text$mn:00002106                 mov     large fs:0, ecx
.text$mn:0000210D                 pop     ecx
.text$mn:0000210E                 mov     esp, ebp
.text$mn:00002110                 pop     ebp
.text$mn:00002111                 retn    8
.text$mn:00002111 ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z endp
.text$mn:00002111
.text$mn:00002111 _text$mn        ends
.text$mn:00002111
.text$x:00002114 ; ===========================================================================
.text$x:00002114
.text$x:00002114 ; Segment type: Pure code
.text$x:00002114 ; Segment permissions: Read/Execute
.text$x:00002114 _text$x         segment para public 'CODE' use32
.text$x:00002114                 assume cs:_text$x
.text$x:00002114                 ;org 2114h
.text$x:00002114 ; COMDAT (pick associative to section at 20BC)
.text$x:00002114                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002114
.text$x:00002114 ; =============== S U B R O U T I N E =======================================
.text$x:00002114
.text$x:00002114
.text$x:00002114 __unwindfunclet$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0 proc near
.text$x:00002114                                         ; DATA XREF: .xdata$x:00007248o
.text$x:00002114                 mov     ecx, [ebp-10h]
.text$x:00002117                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00002117 __unwindfunclet$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0 endp
.text$x:00002117
.text$x:0000211C
.text$x:0000211C ; =============== S U B R O U T I N E =======================================
.text$x:0000211C
.text$x:0000211C
.text$x:0000211C __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z proc near
.text$x:0000211C                                         ; DATA XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(uint,std::_Container_base12 const *)+5o
.text$x:0000211C
.text$x:0000211C arg_4           = dword ptr  8
.text$x:0000211C
.text$x:0000211C                 mov     edx, [esp+arg_4]
.text$x:00002120                 lea     eax, [edx+0Ch]
.text$x:00002123                 mov     ecx, [edx-8]
.text$x:00002126                 xor     ecx, eax
.text$x:00002128                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000212D                 mov     eax, offset __ehfuncinfo$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.text$x:00002132                 jmp     ___CxxFrameHandler3
.text$x:00002132 __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z endp
.text$x:00002132
.text$x:00002132 ; ---------------------------------------------------------------------------
.text$x:00002137                 align 4
.text$x:00002137 _text$x         ends
.text$x:00002137
.text$mn:00002138 ; ===========================================================================
.text$mn:00002138
.text$mn:00002138 ; Segment type: Pure code
.text$mn:00002138 ; Segment permissions: Read/Execute
.text$mn:00002138 _text$mn        segment para public 'CODE' use32
.text$mn:00002138                 assume cs:_text$mn
.text$mn:00002138                 ;org 2138h
.text$mn:00002138 ; COMDAT (pick any)
.text$mn:00002138                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002138
.text$mn:00002138 ; =============== S U B R O U T I N E =======================================
.text$mn:00002138
.text$mn:00002138 ; Attributes: bp-based frame
.text$mn:00002138
.text$mn:00002138 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00002138                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002138 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00002138                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00002138
.text$mn:00002138 var_10          = dword ptr -10h
.text$mn:00002138 var_C           = dword ptr -0Ch
.text$mn:00002138 var_4           = dword ptr -4
.text$mn:00002138
.text$mn:00002138                 push    ebp
.text$mn:00002139                 mov     ebp, esp
.text$mn:0000213B                 push    0FFFFFFFFh
.text$mn:0000213D                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002142                 mov     eax, large fs:0
.text$mn:00002148                 push    eax
.text$mn:00002149                 push    ecx
.text$mn:0000214A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000214F                 xor     eax, ebp
.text$mn:00002151                 push    eax
.text$mn:00002152                 lea     eax, [ebp+var_C]
.text$mn:00002155                 mov     large fs:0, eax
.text$mn:0000215B                 mov     [ebp+var_10], ecx
.text$mn:0000215E                 mov     ecx, [ebp+var_10]
.text$mn:00002161                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00002166                 mov     [ebp+var_4], 0
.text$mn:0000216D                 mov     ecx, [ebp+var_10]
.text$mn:00002170                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00002175                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000217C                 mov     eax, [ebp+var_10]
.text$mn:0000217F                 mov     ecx, [ebp+var_C]
.text$mn:00002182                 mov     large fs:0, ecx
.text$mn:00002189                 pop     ecx
.text$mn:0000218A                 mov     esp, ebp
.text$mn:0000218C                 pop     ebp
.text$mn:0000218D                 retn    4
.text$mn:0000218D ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:0000218D
.text$mn:0000218D _text$mn        ends
.text$mn:0000218D
.text$x:00002190 ; ===========================================================================
.text$x:00002190
.text$x:00002190 ; Segment type: Pure code
.text$x:00002190 ; Segment permissions: Read/Execute
.text$x:00002190 _text$x         segment para public 'CODE' use32
.text$x:00002190                 assume cs:_text$x
.text$x:00002190                 ;org 2190h
.text$x:00002190 ; COMDAT (pick associative to section at 2138)
.text$x:00002190                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002190
.text$x:00002190 ; =============== S U B R O U T I N E =======================================
.text$x:00002190
.text$x:00002190
.text$x:00002190 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00002190                                         ; DATA XREF: .xdata$x:00006940o
.text$x:00002190                 mov     ecx, [ebp-10h]
.text$x:00002193                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00002193 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00002193
.text$x:00002198
.text$x:00002198 ; =============== S U B R O U T I N E =======================================
.text$x:00002198
.text$x:00002198
.text$x:00002198 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00002198                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00002198
.text$x:00002198 arg_4           = dword ptr  8
.text$x:00002198
.text$x:00002198                 mov     edx, [esp+arg_4]
.text$x:0000219C                 lea     eax, [edx+0Ch]
.text$x:0000219F                 mov     ecx, [edx-8]
.text$x:000021A2                 xor     ecx, eax
.text$x:000021A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000021A9                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000021AE                 jmp     ___CxxFrameHandler3
.text$x:000021AE __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000021AE
.text$x:000021AE ; ---------------------------------------------------------------------------
.text$x:000021B3                 align 4
.text$x:000021B3 _text$x         ends
.text$x:000021B3
.text$mn:000021B4 ; ===========================================================================
.text$mn:000021B4
.text$mn:000021B4 ; Segment type: Pure code
.text$mn:000021B4 ; Segment permissions: Read/Execute
.text$mn:000021B4 _text$mn        segment para public 'CODE' use32
.text$mn:000021B4                 assume cs:_text$mn
.text$mn:000021B4                 ;org 21B4h
.text$mn:000021B4 ; COMDAT (pick any)
.text$mn:000021B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021B4
.text$mn:000021B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000021B4
.text$mn:000021B4 ; Attributes: bp-based frame
.text$mn:000021B4
.text$mn:000021B4 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:000021B4                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:000021B4 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:000021B4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+43p
.text$mn:000021B4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+34p
.text$mn:000021B4
.text$mn:000021B4 var_10          = dword ptr -10h
.text$mn:000021B4 var_C           = dword ptr -0Ch
.text$mn:000021B4 var_4           = dword ptr -4
.text$mn:000021B4
.text$mn:000021B4                 push    ebp
.text$mn:000021B5                 mov     ebp, esp
.text$mn:000021B7                 push    0FFFFFFFFh
.text$mn:000021B9                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:000021BE                 mov     eax, large fs:0
.text$mn:000021C4                 push    eax
.text$mn:000021C5                 push    ecx
.text$mn:000021C6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000021CB                 xor     eax, ebp
.text$mn:000021CD                 push    eax
.text$mn:000021CE                 lea     eax, [ebp+var_C]
.text$mn:000021D1                 mov     large fs:0, eax
.text$mn:000021D7                 mov     [ebp+var_10], ecx
.text$mn:000021DA                 mov     ecx, [ebp+var_10]
.text$mn:000021DD                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:000021E2                 mov     [ebp+var_4], 0
.text$mn:000021E9                 mov     ecx, [ebp+var_10]
.text$mn:000021EC                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:000021F1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000021F8                 mov     eax, [ebp+var_10]
.text$mn:000021FB                 mov     ecx, [ebp+var_C]
.text$mn:000021FE                 mov     large fs:0, ecx
.text$mn:00002205                 pop     ecx
.text$mn:00002206                 mov     esp, ebp
.text$mn:00002208                 pop     ebp
.text$mn:00002209                 retn    4
.text$mn:00002209 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00002209
.text$mn:00002209 _text$mn        ends
.text$mn:00002209
.text$x:0000220C ; ===========================================================================
.text$x:0000220C
.text$x:0000220C ; Segment type: Pure code
.text$x:0000220C ; Segment permissions: Read/Execute
.text$x:0000220C _text$x         segment para public 'CODE' use32
.text$x:0000220C                 assume cs:_text$x
.text$x:0000220C                 ;org 220Ch
.text$x:0000220C ; COMDAT (pick associative to section at 21B4)
.text$x:0000220C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000220C
.text$x:0000220C ; =============== S U B R O U T I N E =======================================
.text$x:0000220C
.text$x:0000220C
.text$x:0000220C __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:0000220C                                         ; DATA XREF: .xdata$x:00006C60o
.text$x:0000220C                 mov     ecx, [ebp-10h]
.text$x:0000220F                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:0000220F __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:0000220F
.text$x:00002214
.text$x:00002214 ; =============== S U B R O U T I N E =======================================
.text$x:00002214
.text$x:00002214
.text$x:00002214 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:00002214                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:00002214
.text$x:00002214 arg_4           = dword ptr  8
.text$x:00002214
.text$x:00002214                 mov     edx, [esp+arg_4]
.text$x:00002218                 lea     eax, [edx+0Ch]
.text$x:0000221B                 mov     ecx, [edx-8]
.text$x:0000221E                 xor     ecx, eax
.text$x:00002220                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002225                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:0000222A                 jmp     ___CxxFrameHandler3
.text$x:0000222A __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:0000222A
.text$x:0000222A ; ---------------------------------------------------------------------------
.text$x:0000222F                 align 10h
.text$x:0000222F _text$x         ends
.text$x:0000222F
.text$mn:00002230 ; ===========================================================================
.text$mn:00002230
.text$mn:00002230 ; Segment type: Pure code
.text$mn:00002230 ; Segment permissions: Read/Execute
.text$mn:00002230 _text$mn        segment para public 'CODE' use32
.text$mn:00002230                 assume cs:_text$mn
.text$mn:00002230                 ;org 2230h
.text$mn:00002230 ; COMDAT (pick any)
.text$mn:00002230                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002230
.text$mn:00002230 ; =============== S U B R O U T I N E =======================================
.text$mn:00002230
.text$mn:00002230 ; Attributes: bp-based frame
.text$mn:00002230
.text$mn:00002230 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00002230                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002230 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00002230                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00002230
.text$mn:00002230 var_10          = dword ptr -10h
.text$mn:00002230 var_C           = dword ptr -0Ch
.text$mn:00002230 var_4           = dword ptr -4
.text$mn:00002230
.text$mn:00002230                 push    ebp
.text$mn:00002231                 mov     ebp, esp
.text$mn:00002233                 push    0FFFFFFFFh
.text$mn:00002235                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000223A                 mov     eax, large fs:0
.text$mn:00002240                 push    eax
.text$mn:00002241                 push    ecx
.text$mn:00002242                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002247                 xor     eax, ebp
.text$mn:00002249                 push    eax
.text$mn:0000224A                 lea     eax, [ebp+var_C]
.text$mn:0000224D                 mov     large fs:0, eax
.text$mn:00002253                 mov     [ebp+var_10], ecx
.text$mn:00002256                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002259                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000225E                 mov     [ebp+var_4], 0
.text$mn:00002265                 mov     eax, [ebp+var_10]
.text$mn:00002268                 mov     dword ptr [eax+14h], 0
.text$mn:0000226F                 mov     ecx, [ebp+var_10]
.text$mn:00002272                 mov     dword ptr [ecx+18h], 0
.text$mn:00002279                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002280                 mov     eax, [ebp+var_10]
.text$mn:00002283                 mov     ecx, [ebp+var_C]
.text$mn:00002286                 mov     large fs:0, ecx
.text$mn:0000228D                 pop     ecx
.text$mn:0000228E                 mov     esp, ebp
.text$mn:00002290                 pop     ebp
.text$mn:00002291                 retn
.text$mn:00002291 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00002291
.text$mn:00002291 ; ---------------------------------------------------------------------------
.text$mn:00002292                 align 4
.text$mn:00002292 _text$mn        ends
.text$mn:00002292
.text$x:00002294 ; ===========================================================================
.text$x:00002294
.text$x:00002294 ; Segment type: Pure code
.text$x:00002294 ; Segment permissions: Read/Execute
.text$x:00002294 _text$x         segment para public 'CODE' use32
.text$x:00002294                 assume cs:_text$x
.text$x:00002294                 ;org 2294h
.text$x:00002294 ; COMDAT (pick associative to section at 2230)
.text$x:00002294                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002294
.text$x:00002294 ; =============== S U B R O U T I N E =======================================
.text$x:00002294
.text$x:00002294
.text$x:00002294 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00002294                                         ; DATA XREF: .xdata$x:000068E8o
.text$x:00002294                 mov     ecx, [ebp-10h]  ; this
.text$x:00002297                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002297 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00002297
.text$x:0000229C
.text$x:0000229C ; =============== S U B R O U T I N E =======================================
.text$x:0000229C
.text$x:0000229C
.text$x:0000229C __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:0000229C                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:0000229C
.text$x:0000229C arg_4           = dword ptr  8
.text$x:0000229C
.text$x:0000229C                 mov     edx, [esp+arg_4]
.text$x:000022A0                 lea     eax, [edx+0Ch]
.text$x:000022A3                 mov     ecx, [edx-8]
.text$x:000022A6                 xor     ecx, eax
.text$x:000022A8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000022AD                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000022B2                 jmp     ___CxxFrameHandler3
.text$x:000022B2 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000022B2
.text$x:000022B2 ; ---------------------------------------------------------------------------
.text$x:000022B7                 align 4
.text$x:000022B7 _text$x         ends
.text$x:000022B7
.text$mn:000022B8 ; ===========================================================================
.text$mn:000022B8
.text$mn:000022B8 ; Segment type: Pure code
.text$mn:000022B8 ; Segment permissions: Read/Execute
.text$mn:000022B8 _text$mn        segment para public 'CODE' use32
.text$mn:000022B8                 assume cs:_text$mn
.text$mn:000022B8                 ;org 22B8h
.text$mn:000022B8 ; COMDAT (pick any)
.text$mn:000022B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022B8
.text$mn:000022B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000022B8
.text$mn:000022B8 ; Attributes: bp-based frame
.text$mn:000022B8
.text$mn:000022B8 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:000022B8                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000022B8 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:000022B8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:000022B8
.text$mn:000022B8 var_10          = dword ptr -10h
.text$mn:000022B8 var_C           = dword ptr -0Ch
.text$mn:000022B8 var_4           = dword ptr -4
.text$mn:000022B8
.text$mn:000022B8                 push    ebp
.text$mn:000022B9                 mov     ebp, esp
.text$mn:000022BB                 push    0FFFFFFFFh
.text$mn:000022BD                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000022C2                 mov     eax, large fs:0
.text$mn:000022C8                 push    eax
.text$mn:000022C9                 push    ecx
.text$mn:000022CA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000022CF                 xor     eax, ebp
.text$mn:000022D1                 push    eax
.text$mn:000022D2                 lea     eax, [ebp+var_C]
.text$mn:000022D5                 mov     large fs:0, eax
.text$mn:000022DB                 mov     [ebp+var_10], ecx
.text$mn:000022DE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000022E1                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000022E6                 mov     [ebp+var_4], 0
.text$mn:000022ED                 mov     eax, [ebp+var_10]
.text$mn:000022F0                 mov     dword ptr [eax+14h], 0
.text$mn:000022F7                 mov     ecx, [ebp+var_10]
.text$mn:000022FA                 mov     dword ptr [ecx+18h], 0
.text$mn:00002301                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002308                 mov     eax, [ebp+var_10]
.text$mn:0000230B                 mov     ecx, [ebp+var_C]
.text$mn:0000230E                 mov     large fs:0, ecx
.text$mn:00002315                 pop     ecx
.text$mn:00002316                 mov     esp, ebp
.text$mn:00002318                 pop     ebp
.text$mn:00002319                 retn
.text$mn:00002319 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00002319
.text$mn:00002319 ; ---------------------------------------------------------------------------
.text$mn:0000231A                 align 4
.text$mn:0000231A _text$mn        ends
.text$mn:0000231A
.text$x:0000231C ; ===========================================================================
.text$x:0000231C
.text$x:0000231C ; Segment type: Pure code
.text$x:0000231C ; Segment permissions: Read/Execute
.text$x:0000231C _text$x         segment para public 'CODE' use32
.text$x:0000231C                 assume cs:_text$x
.text$x:0000231C                 ;org 231Ch
.text$x:0000231C ; COMDAT (pick associative to section at 22B8)
.text$x:0000231C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000231C
.text$x:0000231C ; =============== S U B R O U T I N E =======================================
.text$x:0000231C
.text$x:0000231C
.text$x:0000231C __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:0000231C                                         ; DATA XREF: .xdata$x:00006C08o
.text$x:0000231C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000231F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000231F __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:0000231F
.text$x:00002324
.text$x:00002324 ; =============== S U B R O U T I N E =======================================
.text$x:00002324
.text$x:00002324
.text$x:00002324 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00002324                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00002324
.text$x:00002324 arg_4           = dword ptr  8
.text$x:00002324
.text$x:00002324                 mov     edx, [esp+arg_4]
.text$x:00002328                 lea     eax, [edx+0Ch]
.text$x:0000232B                 mov     ecx, [edx-8]
.text$x:0000232E                 xor     ecx, eax
.text$x:00002330                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002335                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:0000233A                 jmp     ___CxxFrameHandler3
.text$x:0000233A __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:0000233A
.text$x:0000233A ; ---------------------------------------------------------------------------
.text$x:0000233F                 align 10h
.text$x:0000233F _text$x         ends
.text$x:0000233F
.text$mn:00002340 ; ===========================================================================
.text$mn:00002340
.text$mn:00002340 ; Segment type: Pure code
.text$mn:00002340 ; Segment permissions: Read/Execute
.text$mn:00002340 _text$mn        segment para public 'CODE' use32
.text$mn:00002340                 assume cs:_text$mn
.text$mn:00002340                 ;org 2340h
.text$mn:00002340 ; COMDAT (pick any)
.text$mn:00002340                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002340
.text$mn:00002340 ; =============== S U B R O U T I N E =======================================
.text$mn:00002340
.text$mn:00002340 ; Attributes: bp-based frame
.text$mn:00002340
.text$mn:00002340 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00002340                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00002340 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00002340                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00002340
.text$mn:00002340 var_4           = dword ptr -4
.text$mn:00002340
.text$mn:00002340                 push    ebp
.text$mn:00002341                 mov     ebp, esp
.text$mn:00002343                 push    ecx
.text$mn:00002344                 mov     [ebp+var_4], ecx
.text$mn:00002347                 mov     ecx, [ebp+var_4]
.text$mn:0000234A                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000234F                 mov     eax, [ebp+var_4]
.text$mn:00002352                 mov     esp, ebp
.text$mn:00002354                 pop     ebp
.text$mn:00002355                 retn
.text$mn:00002355 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00002355
.text$mn:00002355 ; ---------------------------------------------------------------------------
.text$mn:00002356                 align 4
.text$mn:00002356 _text$mn        ends
.text$mn:00002356
.text$mn:00002358 ; ===========================================================================
.text$mn:00002358
.text$mn:00002358 ; Segment type: Pure code
.text$mn:00002358 ; Segment permissions: Read/Execute
.text$mn:00002358 _text$mn        segment para public 'CODE' use32
.text$mn:00002358                 assume cs:_text$mn
.text$mn:00002358                 ;org 2358h
.text$mn:00002358 ; COMDAT (pick any)
.text$mn:00002358                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002358
.text$mn:00002358 ; =============== S U B R O U T I N E =======================================
.text$mn:00002358
.text$mn:00002358 ; Attributes: bp-based frame
.text$mn:00002358
.text$mn:00002358 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct RecentItem>>::_Wrap_alloc<class std::allocator<struct RecentItem>>(void)
.text$mn:00002358                 public ??0?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAE@XZ
.text$mn:00002358 ??0?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAE@XZ proc near
.text$mn:00002358                                         ; CODE XREF: std::_Deque_alloc<0,std::_Deque_base_types<RecentItem,std::allocator<RecentItem>>>::_Getal(void)+Ap
.text$mn:00002358
.text$mn:00002358 var_4           = dword ptr -4
.text$mn:00002358
.text$mn:00002358                 push    ebp
.text$mn:00002359                 mov     ebp, esp
.text$mn:0000235B                 push    ecx
.text$mn:0000235C                 mov     [ebp+var_4], ecx
.text$mn:0000235F                 mov     ecx, [ebp+var_4]
.text$mn:00002362                 call    ??0?$allocator@URecentItem@@@std@@QAE@XZ ; std::allocator<RecentItem>::allocator<RecentItem>(void)
.text$mn:00002367                 mov     eax, [ebp+var_4]
.text$mn:0000236A                 mov     esp, ebp
.text$mn:0000236C                 pop     ebp
.text$mn:0000236D                 retn
.text$mn:0000236D ??0?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAE@XZ endp
.text$mn:0000236D
.text$mn:0000236D ; ---------------------------------------------------------------------------
.text$mn:0000236E                 align 10h
.text$mn:0000236E _text$mn        ends
.text$mn:0000236E
.text$mn:00002370 ; ===========================================================================
.text$mn:00002370
.text$mn:00002370 ; Segment type: Pure code
.text$mn:00002370 ; Segment permissions: Read/Execute
.text$mn:00002370 _text$mn        segment para public 'CODE' use32
.text$mn:00002370                 assume cs:_text$mn
.text$mn:00002370                 ;org 2370h
.text$mn:00002370 ; COMDAT (pick any)
.text$mn:00002370                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002370
.text$mn:00002370 ; =============== S U B R O U T I N E =======================================
.text$mn:00002370
.text$mn:00002370 ; Attributes: bp-based frame
.text$mn:00002370
.text$mn:00002370 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(class std::allocator<wchar_t> const &)
.text$mn:00002370                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00002370 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00002370                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+1Dp
.text$mn:00002370
.text$mn:00002370 var_4           = dword ptr -4
.text$mn:00002370 arg_0           = dword ptr  8
.text$mn:00002370
.text$mn:00002370                 push    ebp
.text$mn:00002371                 mov     ebp, esp
.text$mn:00002373                 push    ecx
.text$mn:00002374                 mov     [ebp+var_4], ecx
.text$mn:00002377                 mov     eax, [ebp+arg_0]
.text$mn:0000237A                 push    eax
.text$mn:0000237B                 mov     ecx, [ebp+var_4]
.text$mn:0000237E                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00002383                 mov     eax, [ebp+var_4]
.text$mn:00002386                 mov     esp, ebp
.text$mn:00002388                 pop     ebp
.text$mn:00002389                 retn    4
.text$mn:00002389 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00002389
.text$mn:00002389 _text$mn        ends
.text$mn:00002389
.text$mn:0000238C ; ===========================================================================
.text$mn:0000238C
.text$mn:0000238C ; Segment type: Pure code
.text$mn:0000238C ; Segment permissions: Read/Execute
.text$mn:0000238C _text$mn        segment para public 'CODE' use32
.text$mn:0000238C                 assume cs:_text$mn
.text$mn:0000238C                 ;org 238Ch
.text$mn:0000238C ; COMDAT (pick any)
.text$mn:0000238C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000238C
.text$mn:0000238C ; =============== S U B R O U T I N E =======================================
.text$mn:0000238C
.text$mn:0000238C ; Attributes: bp-based frame
.text$mn:0000238C
.text$mn:0000238C ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:0000238C                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:0000238C ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:0000238C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:0000238C
.text$mn:0000238C var_4           = dword ptr -4
.text$mn:0000238C
.text$mn:0000238C                 push    ebp
.text$mn:0000238D                 mov     ebp, esp
.text$mn:0000238F                 push    ecx
.text$mn:00002390                 mov     [ebp+var_4], ecx
.text$mn:00002393                 mov     ecx, [ebp+var_4]
.text$mn:00002396                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:0000239B                 mov     eax, [ebp+var_4]
.text$mn:0000239E                 mov     esp, ebp
.text$mn:000023A0                 pop     ebp
.text$mn:000023A1                 retn
.text$mn:000023A1 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:000023A1
.text$mn:000023A1 ; ---------------------------------------------------------------------------
.text$mn:000023A2                 align 4
.text$mn:000023A2 _text$mn        ends
.text$mn:000023A2
.text$mn:000023A4 ; ===========================================================================
.text$mn:000023A4
.text$mn:000023A4 ; Segment type: Pure code
.text$mn:000023A4 ; Segment permissions: Read/Execute
.text$mn:000023A4 _text$mn        segment para public 'CODE' use32
.text$mn:000023A4                 assume cs:_text$mn
.text$mn:000023A4                 ;org 23A4h
.text$mn:000023A4 ; COMDAT (pick any)
.text$mn:000023A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023A4
.text$mn:000023A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023A4
.text$mn:000023A4 ; Attributes: bp-based frame
.text$mn:000023A4
.text$mn:000023A4 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:000023A4                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:000023A4 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:000023A4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:000023A4
.text$mn:000023A4 var_4           = dword ptr -4
.text$mn:000023A4
.text$mn:000023A4                 push    ebp
.text$mn:000023A5                 mov     ebp, esp
.text$mn:000023A7                 push    ecx
.text$mn:000023A8                 mov     [ebp+var_4], ecx
.text$mn:000023AB                 mov     eax, [ebp+var_4]
.text$mn:000023AE                 mov     esp, ebp
.text$mn:000023B0                 pop     ebp
.text$mn:000023B1                 retn
.text$mn:000023B1 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:000023B1
.text$mn:000023B1 ; ---------------------------------------------------------------------------
.text$mn:000023B2                 align 4
.text$mn:000023B2 _text$mn        ends
.text$mn:000023B2
.text$mn:000023B4 ; ===========================================================================
.text$mn:000023B4
.text$mn:000023B4 ; Segment type: Pure code
.text$mn:000023B4 ; Segment permissions: Read/Execute
.text$mn:000023B4 _text$mn        segment para public 'CODE' use32
.text$mn:000023B4                 assume cs:_text$mn
.text$mn:000023B4                 ;org 23B4h
.text$mn:000023B4 ; COMDAT (pick any)
.text$mn:000023B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023B4
.text$mn:000023B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023B4
.text$mn:000023B4 ; Attributes: bp-based frame
.text$mn:000023B4
.text$mn:000023B4 ; public: __thiscall std::allocator<struct RecentItem>::allocator<struct RecentItem>(void)
.text$mn:000023B4                 public ??0?$allocator@URecentItem@@@std@@QAE@XZ
.text$mn:000023B4 ??0?$allocator@URecentItem@@@std@@QAE@XZ proc near
.text$mn:000023B4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<RecentItem>>::_Wrap_alloc<std::allocator<RecentItem>>(void)+Ap
.text$mn:000023B4
.text$mn:000023B4 var_4           = dword ptr -4
.text$mn:000023B4
.text$mn:000023B4                 push    ebp
.text$mn:000023B5                 mov     ebp, esp
.text$mn:000023B7                 push    ecx
.text$mn:000023B8                 mov     [ebp+var_4], ecx
.text$mn:000023BB                 mov     eax, [ebp+var_4]
.text$mn:000023BE                 mov     esp, ebp
.text$mn:000023C0                 pop     ebp
.text$mn:000023C1                 retn
.text$mn:000023C1 ??0?$allocator@URecentItem@@@std@@QAE@XZ endp
.text$mn:000023C1
.text$mn:000023C1 ; ---------------------------------------------------------------------------
.text$mn:000023C2                 align 4
.text$mn:000023C2 _text$mn        ends
.text$mn:000023C2
.text$mn:000023C4 ; ===========================================================================
.text$mn:000023C4
.text$mn:000023C4 ; Segment type: Pure code
.text$mn:000023C4 ; Segment permissions: Read/Execute
.text$mn:000023C4 _text$mn        segment para public 'CODE' use32
.text$mn:000023C4                 assume cs:_text$mn
.text$mn:000023C4                 ;org 23C4h
.text$mn:000023C4 ; COMDAT (pick any)
.text$mn:000023C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023C4
.text$mn:000023C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023C4
.text$mn:000023C4 ; Attributes: bp-based frame
.text$mn:000023C4
.text$mn:000023C4 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:000023C4                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:000023C4 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:000023C4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:000023C4                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+Cp ...
.text$mn:000023C4
.text$mn:000023C4 var_4           = dword ptr -4
.text$mn:000023C4
.text$mn:000023C4                 push    ebp
.text$mn:000023C5                 mov     ebp, esp
.text$mn:000023C7                 push    ecx
.text$mn:000023C8                 mov     [ebp+var_4], ecx
.text$mn:000023CB                 mov     eax, [ebp+var_4]
.text$mn:000023CE                 mov     esp, ebp
.text$mn:000023D0                 pop     ebp
.text$mn:000023D1                 retn
.text$mn:000023D1 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:000023D1
.text$mn:000023D1 ; ---------------------------------------------------------------------------
.text$mn:000023D2                 align 4
.text$mn:000023D2 _text$mn        ends
.text$mn:000023D2
.text$mn:000023D4 ; ===========================================================================
.text$mn:000023D4
.text$mn:000023D4 ; Segment type: Pure code
.text$mn:000023D4 ; Segment permissions: Read/Execute
.text$mn:000023D4 _text$mn        segment para public 'CODE' use32
.text$mn:000023D4                 assume cs:_text$mn
.text$mn:000023D4                 ;org 23D4h
.text$mn:000023D4 ; COMDAT (pick any)
.text$mn:000023D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023D4
.text$mn:000023D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023D4
.text$mn:000023D4 ; Attributes: bp-based frame
.text$mn:000023D4
.text$mn:000023D4 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(class std::allocator<wchar_t> const &)
.text$mn:000023D4                 public ??0?$allocator@_W@std@@QAE@ABV01@@Z
.text$mn:000023D4 ??0?$allocator@_W@std@@QAE@ABV01@@Z proc near
.text$mn:000023D4                                         ; CODE XREF: std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+Bp
.text$mn:000023D4                                         ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+18p ...
.text$mn:000023D4
.text$mn:000023D4 var_4           = dword ptr -4
.text$mn:000023D4
.text$mn:000023D4                 push    ebp
.text$mn:000023D5                 mov     ebp, esp
.text$mn:000023D7                 push    ecx
.text$mn:000023D8                 mov     [ebp+var_4], ecx
.text$mn:000023DB                 mov     eax, [ebp+var_4]
.text$mn:000023DE                 mov     esp, ebp
.text$mn:000023E0                 pop     ebp
.text$mn:000023E1                 retn    4
.text$mn:000023E1 ??0?$allocator@_W@std@@QAE@ABV01@@Z endp
.text$mn:000023E1
.text$mn:000023E1 _text$mn        ends
.text$mn:000023E1
.text$mn:000023E4 ; ===========================================================================
.text$mn:000023E4
.text$mn:000023E4 ; Segment type: Pure code
.text$mn:000023E4 ; Segment permissions: Read/Execute
.text$mn:000023E4 _text$mn        segment para public 'CODE' use32
.text$mn:000023E4                 assume cs:_text$mn
.text$mn:000023E4                 ;org 23E4h
.text$mn:000023E4 ; COMDAT (pick any)
.text$mn:000023E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023E4
.text$mn:000023E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023E4
.text$mn:000023E4 ; Attributes: bp-based frame
.text$mn:000023E4
.text$mn:000023E4 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000023E4                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:000023E4 ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:000023E4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+2Bp
.text$mn:000023E4
.text$mn:000023E4 var_4           = dword ptr -4
.text$mn:000023E4
.text$mn:000023E4                 push    ebp
.text$mn:000023E5                 mov     ebp, esp
.text$mn:000023E7                 push    ecx
.text$mn:000023E8                 mov     [ebp+var_4], ecx
.text$mn:000023EB                 mov     eax, [ebp+var_4]
.text$mn:000023EE                 mov     esp, ebp
.text$mn:000023F0                 pop     ebp
.text$mn:000023F1                 retn
.text$mn:000023F1 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:000023F1
.text$mn:000023F1 ; ---------------------------------------------------------------------------
.text$mn:000023F2                 align 4
.text$mn:000023F2 _text$mn        ends
.text$mn:000023F2
.text$mn:000023F4 ; ===========================================================================
.text$mn:000023F4
.text$mn:000023F4 ; Segment type: Pure code
.text$mn:000023F4 ; Segment permissions: Read/Execute
.text$mn:000023F4 _text$mn        segment para public 'CODE' use32
.text$mn:000023F4                 assume cs:_text$mn
.text$mn:000023F4                 ;org 23F4h
.text$mn:000023F4 ; COMDAT (pick any)
.text$mn:000023F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023F4
.text$mn:000023F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023F4
.text$mn:000023F4 ; Attributes: bp-based frame
.text$mn:000023F4
.text$mn:000023F4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:000023F4                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000023F4 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:000023F4                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:000023F4                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:000023F4
.text$mn:000023F4 var_14          = dword ptr -14h
.text$mn:000023F4 var_D           = byte ptr -0Dh
.text$mn:000023F4 var_C           = dword ptr -0Ch
.text$mn:000023F4 var_4           = dword ptr -4
.text$mn:000023F4 Str             = dword ptr  8
.text$mn:000023F4
.text$mn:000023F4                 push    ebp
.text$mn:000023F5                 mov     ebp, esp
.text$mn:000023F7                 push    0FFFFFFFFh
.text$mn:000023F9                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000023FE                 mov     eax, large fs:0
.text$mn:00002404                 push    eax
.text$mn:00002405                 sub     esp, 8
.text$mn:00002408                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000240D                 xor     eax, ebp
.text$mn:0000240F                 push    eax
.text$mn:00002410                 lea     eax, [ebp+var_C]
.text$mn:00002413                 mov     large fs:0, eax
.text$mn:00002419                 mov     [ebp+var_14], ecx
.text$mn:0000241C                 lea     ecx, [ebp+var_D]
.text$mn:0000241F                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00002424                 push    eax
.text$mn:00002425                 mov     ecx, [ebp+var_14]
.text$mn:00002428                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:0000242D                 mov     [ebp+var_4], 0
.text$mn:00002434                 push    0               ; Size
.text$mn:00002436                 push    0               ; char
.text$mn:00002438                 mov     ecx, [ebp+var_14]
.text$mn:0000243B                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002440                 mov     eax, [ebp+Str]
.text$mn:00002443                 push    eax             ; Str
.text$mn:00002444                 mov     ecx, [ebp+var_14]
.text$mn:00002447                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:0000244C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002453                 mov     eax, [ebp+var_14]
.text$mn:00002456                 mov     ecx, [ebp+var_C]
.text$mn:00002459                 mov     large fs:0, ecx
.text$mn:00002460                 pop     ecx
.text$mn:00002461                 mov     esp, ebp
.text$mn:00002463                 pop     ebp
.text$mn:00002464                 retn    4
.text$mn:00002464 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00002464
.text$mn:00002464 ; ---------------------------------------------------------------------------
.text$mn:00002467                 align 4
.text$mn:00002467 _text$mn        ends
.text$mn:00002467
.text$x:00002468 ; ===========================================================================
.text$x:00002468
.text$x:00002468 ; Segment type: Pure code
.text$x:00002468 ; Segment permissions: Read/Execute
.text$x:00002468 _text$x         segment para public 'CODE' use32
.text$x:00002468                 assume cs:_text$x
.text$x:00002468                 ;org 2468h
.text$x:00002468 ; COMDAT (pick associative to section at 23F4)
.text$x:00002468                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002468
.text$x:00002468 ; =============== S U B R O U T I N E =======================================
.text$x:00002468
.text$x:00002468
.text$x:00002468 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00002468                                         ; DATA XREF: .xdata$x:00006998o
.text$x:00002468                 mov     ecx, [ebp-14h]
.text$x:0000246B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000246B __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:0000246B
.text$x:00002470
.text$x:00002470 ; =============== S U B R O U T I N E =======================================
.text$x:00002470
.text$x:00002470
.text$x:00002470 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00002470                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00002470
.text$x:00002470 arg_4           = dword ptr  8
.text$x:00002470
.text$x:00002470                 mov     edx, [esp+arg_4]
.text$x:00002474                 lea     eax, [edx+0Ch]
.text$x:00002477                 mov     ecx, [edx-0Ch]
.text$x:0000247A                 xor     ecx, eax
.text$x:0000247C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002481                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00002486                 jmp     ___CxxFrameHandler3
.text$x:00002486 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00002486
.text$x:00002486 ; ---------------------------------------------------------------------------
.text$x:0000248B                 align 4
.text$x:0000248B _text$x         ends
.text$x:0000248B
.text$mn:0000248C ; ===========================================================================
.text$mn:0000248C
.text$mn:0000248C ; Segment type: Pure code
.text$mn:0000248C ; Segment permissions: Read/Execute
.text$mn:0000248C _text$mn        segment para public 'CODE' use32
.text$mn:0000248C                 assume cs:_text$mn
.text$mn:0000248C                 ;org 248Ch
.text$mn:0000248C ; COMDAT (pick any)
.text$mn:0000248C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000248C
.text$mn:0000248C ; =============== S U B R O U T I N E =======================================
.text$mn:0000248C
.text$mn:0000248C ; Attributes: bp-based frame
.text$mn:0000248C
.text$mn:0000248C ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:0000248C                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:0000248C ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$mn:0000248C                                         ; CODE XREF: RecentItem::RecentItem(RecentItem const &)+3Dp
.text$mn:0000248C
.text$mn:0000248C var_14          = dword ptr -14h
.text$mn:0000248C var_E           = byte ptr -0Eh
.text$mn:0000248C var_D           = byte ptr -0Dh
.text$mn:0000248C var_C           = dword ptr -0Ch
.text$mn:0000248C var_4           = dword ptr -4
.text$mn:0000248C arg_0           = dword ptr  8
.text$mn:0000248C
.text$mn:0000248C                 push    ebp
.text$mn:0000248D                 mov     ebp, esp
.text$mn:0000248F                 push    0FFFFFFFFh
.text$mn:00002491                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:00002496                 mov     eax, large fs:0
.text$mn:0000249C                 push    eax
.text$mn:0000249D                 sub     esp, 8
.text$mn:000024A0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000024A5                 xor     eax, ebp
.text$mn:000024A7                 push    eax
.text$mn:000024A8                 lea     eax, [ebp+var_C]
.text$mn:000024AB                 mov     large fs:0, eax
.text$mn:000024B1                 mov     [ebp+var_14], ecx
.text$mn:000024B4                 lea     eax, [ebp+var_D]
.text$mn:000024B7                 push    eax
.text$mn:000024B8                 lea     ecx, [ebp+var_E]
.text$mn:000024BB                 push    ecx
.text$mn:000024BC                 mov     ecx, [ebp+arg_0]
.text$mn:000024BF                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000024C4                 mov     ecx, eax
.text$mn:000024C6                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)
.text$mn:000024CB                 push    eax
.text$mn:000024CC                 mov     ecx, [ebp+var_14]
.text$mn:000024CF                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:000024D4                 mov     [ebp+var_4], 0
.text$mn:000024DB                 push    0
.text$mn:000024DD                 push    0
.text$mn:000024DF                 mov     ecx, [ebp+var_14]
.text$mn:000024E2                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000024E7                 mov     edx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:000024ED                 push    edx
.text$mn:000024EE                 push    0
.text$mn:000024F0                 mov     eax, [ebp+arg_0]
.text$mn:000024F3                 push    eax
.text$mn:000024F4                 mov     ecx, [ebp+var_14]
.text$mn:000024F7                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:000024FC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002503                 mov     eax, [ebp+var_14]
.text$mn:00002506                 mov     ecx, [ebp+var_C]
.text$mn:00002509                 mov     large fs:0, ecx
.text$mn:00002510                 pop     ecx
.text$mn:00002511                 mov     esp, ebp
.text$mn:00002513                 pop     ebp
.text$mn:00002514                 retn    4
.text$mn:00002514 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$mn:00002514
.text$mn:00002514 ; ---------------------------------------------------------------------------
.text$mn:00002517                 align 4
.text$mn:00002517 _text$mn        ends
.text$mn:00002517
.text$x:00002518 ; ===========================================================================
.text$x:00002518
.text$x:00002518 ; Segment type: Pure code
.text$x:00002518 ; Segment permissions: Read/Execute
.text$x:00002518 _text$x         segment para public 'CODE' use32
.text$x:00002518                 assume cs:_text$x
.text$x:00002518                 ;org 2518h
.text$x:00002518 ; COMDAT (pick associative to section at 248C)
.text$x:00002518                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002518
.text$x:00002518 ; =============== S U B R O U T I N E =======================================
.text$x:00002518
.text$x:00002518
.text$x:00002518 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00002518                                         ; DATA XREF: .xdata$x:00006CB8o
.text$x:00002518                 mov     ecx, [ebp-14h]
.text$x:0000251B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000251B __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000251B
.text$x:00002520
.text$x:00002520 ; =============== S U B R O U T I N E =======================================
.text$x:00002520
.text$x:00002520
.text$x:00002520 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$x:00002520                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:00002520
.text$x:00002520 arg_4           = dword ptr  8
.text$x:00002520
.text$x:00002520                 mov     edx, [esp+arg_4]
.text$x:00002524                 lea     eax, [edx+0Ch]
.text$x:00002527                 mov     ecx, [edx-0Ch]
.text$x:0000252A                 xor     ecx, eax
.text$x:0000252C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002531                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$x:00002536                 jmp     ___CxxFrameHandler3
.text$x:00002536 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$x:00002536
.text$x:00002536 ; ---------------------------------------------------------------------------
.text$x:0000253B                 align 4
.text$x:0000253B _text$x         ends
.text$x:0000253B
.text$mn:0000253C ; ===========================================================================
.text$mn:0000253C
.text$mn:0000253C ; Segment type: Pure code
.text$mn:0000253C ; Segment permissions: Read/Execute
.text$mn:0000253C _text$mn        segment para public 'CODE' use32
.text$mn:0000253C                 assume cs:_text$mn
.text$mn:0000253C                 ;org 253Ch
.text$mn:0000253C ; COMDAT (pick any)
.text$mn:0000253C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000253C
.text$mn:0000253C ; =============== S U B R O U T I N E =======================================
.text$mn:0000253C
.text$mn:0000253C ; Attributes: bp-based frame
.text$mn:0000253C
.text$mn:0000253C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t *Str)
.text$mn:0000253C                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:0000253C ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$mn:0000253C                                         ; CODE XREF: RecentItem::RecentItem(wchar_t const *)+30p
.text$mn:0000253C
.text$mn:0000253C var_14          = dword ptr -14h
.text$mn:0000253C var_D           = byte ptr -0Dh
.text$mn:0000253C var_C           = dword ptr -0Ch
.text$mn:0000253C var_4           = dword ptr -4
.text$mn:0000253C Str             = dword ptr  8
.text$mn:0000253C
.text$mn:0000253C                 push    ebp
.text$mn:0000253D                 mov     ebp, esp
.text$mn:0000253F                 push    0FFFFFFFFh
.text$mn:00002541                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:00002546                 mov     eax, large fs:0
.text$mn:0000254C                 push    eax
.text$mn:0000254D                 sub     esp, 8
.text$mn:00002550                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002555                 xor     eax, ebp
.text$mn:00002557                 push    eax
.text$mn:00002558                 lea     eax, [ebp+var_C]
.text$mn:0000255B                 mov     large fs:0, eax
.text$mn:00002561                 mov     [ebp+var_14], ecx
.text$mn:00002564                 lea     ecx, [ebp+var_D]
.text$mn:00002567                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:0000256C                 push    eax
.text$mn:0000256D                 mov     ecx, [ebp+var_14]
.text$mn:00002570                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00002575                 mov     [ebp+var_4], 0
.text$mn:0000257C                 push    0
.text$mn:0000257E                 push    0
.text$mn:00002580                 mov     ecx, [ebp+var_14]
.text$mn:00002583                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00002588                 mov     eax, [ebp+Str]
.text$mn:0000258B                 push    eax             ; Str
.text$mn:0000258C                 mov     ecx, [ebp+var_14]
.text$mn:0000258F                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00002594                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000259B                 mov     eax, [ebp+var_14]
.text$mn:0000259E                 mov     ecx, [ebp+var_C]
.text$mn:000025A1                 mov     large fs:0, ecx
.text$mn:000025A8                 pop     ecx
.text$mn:000025A9                 mov     esp, ebp
.text$mn:000025AB                 pop     ebp
.text$mn:000025AC                 retn    4
.text$mn:000025AC ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$mn:000025AC
.text$mn:000025AC ; ---------------------------------------------------------------------------
.text$mn:000025AF                 align 10h
.text$mn:000025AF _text$mn        ends
.text$mn:000025AF
.text$x:000025B0 ; ===========================================================================
.text$x:000025B0
.text$x:000025B0 ; Segment type: Pure code
.text$x:000025B0 ; Segment permissions: Read/Execute
.text$x:000025B0 _text$x         segment para public 'CODE' use32
.text$x:000025B0                 assume cs:_text$x
.text$x:000025B0                 ;org 25B0h
.text$x:000025B0 ; COMDAT (pick associative to section at 253C)
.text$x:000025B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000025B0
.text$x:000025B0 ; =============== S U B R O U T I N E =======================================
.text$x:000025B0
.text$x:000025B0
.text$x:000025B0 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 proc near
.text$x:000025B0                                         ; DATA XREF: .xdata$x:00006CE4o
.text$x:000025B0                 mov     ecx, [ebp-14h]
.text$x:000025B3                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000025B3 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 endp
.text$x:000025B3
.text$x:000025B8
.text$x:000025B8 ; =============== S U B R O U T I N E =======================================
.text$x:000025B8
.text$x:000025B8
.text$x:000025B8 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$x:000025B8                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+5o
.text$x:000025B8
.text$x:000025B8 arg_4           = dword ptr  8
.text$x:000025B8
.text$x:000025B8                 mov     edx, [esp+arg_4]
.text$x:000025BC                 lea     eax, [edx+0Ch]
.text$x:000025BF                 mov     ecx, [edx-0Ch]
.text$x:000025C2                 xor     ecx, eax
.text$x:000025C4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000025C9                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$x:000025CE                 jmp     ___CxxFrameHandler3
.text$x:000025CE __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$x:000025CE
.text$x:000025CE ; ---------------------------------------------------------------------------
.text$x:000025D3                 align 4
.text$x:000025D3 _text$x         ends
.text$x:000025D3
.text$mn:000025D4 ; ===========================================================================
.text$mn:000025D4
.text$mn:000025D4 ; Segment type: Pure code
.text$mn:000025D4 ; Segment permissions: Read/Execute
.text$mn:000025D4 _text$mn        segment para public 'CODE' use32
.text$mn:000025D4                 assume cs:_text$mn
.text$mn:000025D4                 ;org 25D4h
.text$mn:000025D4 ; COMDAT (pick any)
.text$mn:000025D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025D4
.text$mn:000025D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000025D4
.text$mn:000025D4 ; Attributes: bp-based frame
.text$mn:000025D4
.text$mn:000025D4 ; public: __thiscall RecentItem::RecentItem(struct RecentItem const &)
.text$mn:000025D4                 public ??0RecentItem@@QAE@ABU0@@Z
.text$mn:000025D4 ??0RecentItem@@QAE@ABU0@@Z proc near    ; CODE XREF: std::allocator<RecentItem>::construct(RecentItem *,RecentItem const &)+4Dp
.text$mn:000025D4
.text$mn:000025D4 var_10          = dword ptr -10h
.text$mn:000025D4 var_C           = dword ptr -0Ch
.text$mn:000025D4 var_4           = dword ptr -4
.text$mn:000025D4 arg_0           = dword ptr  8
.text$mn:000025D4
.text$mn:000025D4                 push    ebp
.text$mn:000025D5                 mov     ebp, esp
.text$mn:000025D7                 push    0FFFFFFFFh
.text$mn:000025D9                 push    offset __ehhandler$??0RecentItem@@QAE@ABU0@@Z
.text$mn:000025DE                 mov     eax, large fs:0
.text$mn:000025E4                 push    eax
.text$mn:000025E5                 push    ecx
.text$mn:000025E6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000025EB                 xor     eax, ebp
.text$mn:000025ED                 push    eax
.text$mn:000025EE                 lea     eax, [ebp+var_C]
.text$mn:000025F1                 mov     large fs:0, eax
.text$mn:000025F7                 mov     [ebp+var_10], ecx
.text$mn:000025FA                 mov     eax, [ebp+var_10]
.text$mn:000025FD                 mov     ecx, [ebp+arg_0]
.text$mn:00002600                 mov     edx, [ecx]
.text$mn:00002602                 mov     [eax], edx
.text$mn:00002604                 mov     eax, [ebp+arg_0]
.text$mn:00002607                 add     eax, 4
.text$mn:0000260A                 push    eax
.text$mn:0000260B                 mov     ecx, [ebp+var_10]
.text$mn:0000260E                 add     ecx, 4
.text$mn:00002611                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00002616                 mov     [ebp+var_4], 0
.text$mn:0000261D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002624                 mov     eax, [ebp+var_10]
.text$mn:00002627                 mov     ecx, [ebp+var_C]
.text$mn:0000262A                 mov     large fs:0, ecx
.text$mn:00002631                 pop     ecx
.text$mn:00002632                 mov     esp, ebp
.text$mn:00002634                 pop     ebp
.text$mn:00002635                 retn    4
.text$mn:00002635 ??0RecentItem@@QAE@ABU0@@Z endp
.text$mn:00002635
.text$mn:00002635 _text$mn        ends
.text$mn:00002635
.text$x:00002638 ; ===========================================================================
.text$x:00002638
.text$x:00002638 ; Segment type: Pure code
.text$x:00002638 ; Segment permissions: Read/Execute
.text$x:00002638 _text$x         segment para public 'CODE' use32
.text$x:00002638                 assume cs:_text$x
.text$x:00002638                 ;org 2638h
.text$x:00002638 ; COMDAT (pick associative to section at 25D4)
.text$x:00002638                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002638
.text$x:00002638 ; =============== S U B R O U T I N E =======================================
.text$x:00002638
.text$x:00002638
.text$x:00002638 __unwindfunclet$??0RecentItem@@QAE@ABU0@@Z$0 proc near
.text$x:00002638                                         ; DATA XREF: .xdata$x:00006E20o
.text$x:00002638                 mov     ecx, [ebp-10h]
.text$x:0000263B                 add     ecx, 4
.text$x:0000263E                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000263E __unwindfunclet$??0RecentItem@@QAE@ABU0@@Z$0 endp
.text$x:0000263E
.text$x:00002643
.text$x:00002643 ; =============== S U B R O U T I N E =======================================
.text$x:00002643
.text$x:00002643
.text$x:00002643 __ehhandler$??0RecentItem@@QAE@ABU0@@Z proc near
.text$x:00002643                                         ; DATA XREF: RecentItem::RecentItem(RecentItem const &)+5o
.text$x:00002643
.text$x:00002643 arg_4           = dword ptr  8
.text$x:00002643
.text$x:00002643                 mov     edx, [esp+arg_4]
.text$x:00002647                 lea     eax, [edx+0Ch]
.text$x:0000264A                 mov     ecx, [edx-8]
.text$x:0000264D                 xor     ecx, eax
.text$x:0000264F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002654                 mov     eax, offset __ehfuncinfo$??0RecentItem@@QAE@ABU0@@Z
.text$x:00002659                 jmp     ___CxxFrameHandler3
.text$x:00002659 __ehhandler$??0RecentItem@@QAE@ABU0@@Z endp
.text$x:00002659
.text$x:00002659 ; ---------------------------------------------------------------------------
.text$x:0000265E                 align 10h
.text$x:0000265E _text$x         ends
.text$x:0000265E
.text$mn:00002660 ; ===========================================================================
.text$mn:00002660
.text$mn:00002660 ; Segment type: Pure code
.text$mn:00002660 ; Segment permissions: Read/Execute
.text$mn:00002660 _text$mn        segment para public 'CODE' use32
.text$mn:00002660                 assume cs:_text$mn
.text$mn:00002660                 ;org 2660h
.text$mn:00002660 ; COMDAT (pick any)
.text$mn:00002660                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002660
.text$mn:00002660 ; =============== S U B R O U T I N E =======================================
.text$mn:00002660
.text$mn:00002660 ; Attributes: bp-based frame
.text$mn:00002660
.text$mn:00002660 ; int __stdcall RecentItem::RecentItem(wchar_t *Str)
.text$mn:00002660                 public ??0RecentItem@@QAE@PB_W@Z
.text$mn:00002660 ??0RecentItem@@QAE@PB_W@Z proc near     ; CODE XREF: LastRecentFileList::add(wchar_t const *)+4Bp
.text$mn:00002660
.text$mn:00002660 var_10          = dword ptr -10h
.text$mn:00002660 var_C           = dword ptr -0Ch
.text$mn:00002660 var_4           = dword ptr -4
.text$mn:00002660 Str             = dword ptr  8
.text$mn:00002660
.text$mn:00002660                 push    ebp
.text$mn:00002661                 mov     ebp, esp
.text$mn:00002663                 push    0FFFFFFFFh
.text$mn:00002665                 push    offset __ehhandler$??0RecentItem@@QAE@PB_W@Z
.text$mn:0000266A                 mov     eax, large fs:0
.text$mn:00002670                 push    eax
.text$mn:00002671                 push    ecx
.text$mn:00002672                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002677                 xor     eax, ebp
.text$mn:00002679                 push    eax
.text$mn:0000267A                 lea     eax, [ebp+var_C]
.text$mn:0000267D                 mov     large fs:0, eax
.text$mn:00002683                 mov     [ebp+var_10], ecx
.text$mn:00002686                 mov     eax, [ebp+Str]
.text$mn:00002689                 push    eax             ; Str
.text$mn:0000268A                 mov     ecx, [ebp+var_10]
.text$mn:0000268D                 add     ecx, 4
.text$mn:00002690                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00002695                 mov     [ebp+var_4], 0
.text$mn:0000269C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000026A3                 mov     eax, [ebp+var_10]
.text$mn:000026A6                 mov     ecx, [ebp+var_C]
.text$mn:000026A9                 mov     large fs:0, ecx
.text$mn:000026B0                 pop     ecx
.text$mn:000026B1                 mov     esp, ebp
.text$mn:000026B3                 pop     ebp
.text$mn:000026B4                 retn    4
.text$mn:000026B4 ??0RecentItem@@QAE@PB_W@Z endp
.text$mn:000026B4
.text$mn:000026B4 ; ---------------------------------------------------------------------------
.text$mn:000026B7                 align 4
.text$mn:000026B7 _text$mn        ends
.text$mn:000026B7
.text$x:000026B8 ; ===========================================================================
.text$x:000026B8
.text$x:000026B8 ; Segment type: Pure code
.text$x:000026B8 ; Segment permissions: Read/Execute
.text$x:000026B8 _text$x         segment para public 'CODE' use32
.text$x:000026B8                 assume cs:_text$x
.text$x:000026B8                 ;org 26B8h
.text$x:000026B8 ; COMDAT (pick associative to section at 2660)
.text$x:000026B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000026B8
.text$x:000026B8 ; =============== S U B R O U T I N E =======================================
.text$x:000026B8
.text$x:000026B8
.text$x:000026B8 __unwindfunclet$??0RecentItem@@QAE@PB_W@Z$0 proc near
.text$x:000026B8                                         ; DATA XREF: .xdata$x:00006DC8o
.text$x:000026B8                 mov     ecx, [ebp-10h]
.text$x:000026BB                 add     ecx, 4
.text$x:000026BE                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000026BE __unwindfunclet$??0RecentItem@@QAE@PB_W@Z$0 endp
.text$x:000026BE
.text$x:000026C3
.text$x:000026C3 ; =============== S U B R O U T I N E =======================================
.text$x:000026C3
.text$x:000026C3
.text$x:000026C3 __ehhandler$??0RecentItem@@QAE@PB_W@Z proc near
.text$x:000026C3                                         ; DATA XREF: RecentItem::RecentItem(wchar_t const *)+5o
.text$x:000026C3
.text$x:000026C3 arg_4           = dword ptr  8
.text$x:000026C3
.text$x:000026C3                 mov     edx, [esp+arg_4]
.text$x:000026C7                 lea     eax, [edx+0Ch]
.text$x:000026CA                 mov     ecx, [edx-8]
.text$x:000026CD                 xor     ecx, eax
.text$x:000026CF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000026D4                 mov     eax, offset __ehfuncinfo$??0RecentItem@@QAE@PB_W@Z
.text$x:000026D9                 jmp     ___CxxFrameHandler3
.text$x:000026D9 __ehhandler$??0RecentItem@@QAE@PB_W@Z endp
.text$x:000026D9
.text$x:000026D9 ; ---------------------------------------------------------------------------
.text$x:000026DE                 align 10h
.text$x:000026DE _text$x         ends
.text$x:000026DE
.text$mn:000026E0 ; ===========================================================================
.text$mn:000026E0
.text$mn:000026E0 ; Segment type: Pure code
.text$mn:000026E0 ; Segment permissions: Read/Execute
.text$mn:000026E0 _text$mn        segment para public 'CODE' use32
.text$mn:000026E0                 assume cs:_text$mn
.text$mn:000026E0                 ;org 26E0h
.text$mn:000026E0 ; COMDAT (pick any)
.text$mn:000026E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026E0
.text$mn:000026E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000026E0
.text$mn:000026E0 ; Attributes: bp-based frame
.text$mn:000026E0
.text$mn:000026E0 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000026E0                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:000026E0 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:000026E0                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:000026E0                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+29p
.text$mn:000026E0
.text$mn:000026E0 var_4           = dword ptr -4
.text$mn:000026E0
.text$mn:000026E0                 push    ebp
.text$mn:000026E1                 mov     ebp, esp
.text$mn:000026E3                 push    ecx
.text$mn:000026E4                 mov     [ebp+var_4], ecx
.text$mn:000026E7                 mov     eax, [ebp+var_4]
.text$mn:000026EA                 mov     dword ptr [eax], 0
.text$mn:000026F0                 mov     eax, [ebp+var_4]
.text$mn:000026F3                 mov     esp, ebp
.text$mn:000026F5                 pop     ebp
.text$mn:000026F6                 retn
.text$mn:000026F6 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:000026F6
.text$mn:000026F6 ; ---------------------------------------------------------------------------
.text$mn:000026F7                 align 4
.text$mn:000026F7 _text$mn        ends
.text$mn:000026F7
.text$mn:000026F8 ; ===========================================================================
.text$mn:000026F8
.text$mn:000026F8 ; Segment type: Pure code
.text$mn:000026F8 ; Segment permissions: Read/Execute
.text$mn:000026F8 _text$mn        segment para public 'CODE' use32
.text$mn:000026F8                 assume cs:_text$mn
.text$mn:000026F8                 ;org 26F8h
.text$mn:000026F8 ; COMDAT (pick any)
.text$mn:000026F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026F8
.text$mn:000026F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000026F8
.text$mn:000026F8 ; Attributes: bp-based frame
.text$mn:000026F8
.text$mn:000026F8 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:000026F8                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:000026F8 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:000026F8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:000026F8                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+23p
.text$mn:000026F8
.text$mn:000026F8 var_4           = dword ptr -4
.text$mn:000026F8
.text$mn:000026F8                 push    ebp
.text$mn:000026F9                 mov     ebp, esp
.text$mn:000026FB                 push    ecx
.text$mn:000026FC                 mov     [ebp+var_4], ecx
.text$mn:000026FF                 mov     eax, [ebp+var_4]
.text$mn:00002702                 mov     dword ptr [eax], 0
.text$mn:00002708                 mov     ecx, [ebp+var_4]
.text$mn:0000270B                 mov     dword ptr [ecx+4], 0
.text$mn:00002712                 mov     eax, [ebp+var_4]
.text$mn:00002715                 mov     esp, ebp
.text$mn:00002717                 pop     ebp
.text$mn:00002718                 retn
.text$mn:00002718 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00002718
.text$mn:00002718 ; ---------------------------------------------------------------------------
.text$mn:00002719                 align 4
.text$mn:00002719 _text$mn        ends
.text$mn:00002719
.text$mn:0000271C ; ===========================================================================
.text$mn:0000271C
.text$mn:0000271C ; Segment type: Pure code
.text$mn:0000271C ; Segment permissions: Read/Execute
.text$mn:0000271C _text$mn        segment para public 'CODE' use32
.text$mn:0000271C                 assume cs:_text$mn
.text$mn:0000271C                 ;org 271Ch
.text$mn:0000271C ; COMDAT (pick any)
.text$mn:0000271C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000271C
.text$mn:0000271C ; =============== S U B R O U T I N E =======================================
.text$mn:0000271C
.text$mn:0000271C ; Attributes: bp-based frame
.text$mn:0000271C
.text$mn:0000271C ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:0000271C                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000271C ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:0000271C                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:0000271C                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:0000271C
.text$mn:0000271C var_10          = dword ptr -10h
.text$mn:0000271C var_C           = dword ptr -0Ch
.text$mn:0000271C var_4           = dword ptr -4
.text$mn:0000271C
.text$mn:0000271C                 push    ebp
.text$mn:0000271D                 mov     ebp, esp
.text$mn:0000271F                 push    0FFFFFFFFh
.text$mn:00002721                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00002726                 mov     eax, large fs:0
.text$mn:0000272C                 push    eax
.text$mn:0000272D                 push    ecx
.text$mn:0000272E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002733                 xor     eax, ebp
.text$mn:00002735                 push    eax
.text$mn:00002736                 lea     eax, [ebp+var_C]
.text$mn:00002739                 mov     large fs:0, eax
.text$mn:0000273F                 mov     [ebp+var_10], ecx
.text$mn:00002742                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002745                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:0000274A                 mov     [ebp+var_4], 0
.text$mn:00002751                 mov     eax, [ebp+var_10]
.text$mn:00002754                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:0000275A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002761                 mov     eax, [ebp+var_10]
.text$mn:00002764                 mov     ecx, [ebp+var_C]
.text$mn:00002767                 mov     large fs:0, ecx
.text$mn:0000276E                 pop     ecx
.text$mn:0000276F                 mov     esp, ebp
.text$mn:00002771                 pop     ebp
.text$mn:00002772                 retn
.text$mn:00002772 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00002772
.text$mn:00002772 ; ---------------------------------------------------------------------------
.text$mn:00002773                 align 4
.text$mn:00002773 _text$mn        ends
.text$mn:00002773
.text$x:00002774 ; ===========================================================================
.text$x:00002774
.text$x:00002774 ; Segment type: Pure code
.text$x:00002774 ; Segment permissions: Read/Execute
.text$x:00002774 _text$x         segment para public 'CODE' use32
.text$x:00002774                 assume cs:_text$x
.text$x:00002774                 ;org 2774h
.text$x:00002774 ; COMDAT (pick associative to section at 271C)
.text$x:00002774                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002774
.text$x:00002774 ; =============== S U B R O U T I N E =======================================
.text$x:00002774
.text$x:00002774
.text$x:00002774 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00002774                                         ; DATA XREF: .xdata$x:00006A7Co
.text$x:00002774                 mov     ecx, [ebp-10h]  ; this
.text$x:00002777                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00002777 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00002777
.text$x:0000277C
.text$x:0000277C ; =============== S U B R O U T I N E =======================================
.text$x:0000277C
.text$x:0000277C
.text$x:0000277C __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:0000277C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:0000277C
.text$x:0000277C arg_4           = dword ptr  8
.text$x:0000277C
.text$x:0000277C                 mov     edx, [esp+arg_4]
.text$x:00002780                 lea     eax, [edx+0Ch]
.text$x:00002783                 mov     ecx, [edx-8]
.text$x:00002786                 xor     ecx, eax
.text$x:00002788                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000278D                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00002792                 jmp     ___CxxFrameHandler3
.text$x:00002792 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00002792
.text$x:00002792 ; ---------------------------------------------------------------------------
.text$x:00002797                 align 4
.text$x:00002797 _text$x         ends
.text$x:00002797
.text$mn:00002798 ; ===========================================================================
.text$mn:00002798
.text$mn:00002798 ; Segment type: Pure code
.text$mn:00002798 ; Segment permissions: Read/Execute
.text$mn:00002798 _text$mn        segment para public 'CODE' use32
.text$mn:00002798                 assume cs:_text$mn
.text$mn:00002798                 ;org 2798h
.text$mn:00002798 ; COMDAT (pick any)
.text$mn:00002798                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002798
.text$mn:00002798 ; =============== S U B R O U T I N E =======================================
.text$mn:00002798
.text$mn:00002798 ; Attributes: bp-based frame
.text$mn:00002798
.text$mn:00002798 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00002798                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00002798 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00002798                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00002798
.text$mn:00002798 var_10          = dword ptr -10h
.text$mn:00002798 var_C           = dword ptr -0Ch
.text$mn:00002798 var_4           = dword ptr -4
.text$mn:00002798
.text$mn:00002798                 push    ebp
.text$mn:00002799                 mov     ebp, esp
.text$mn:0000279B                 push    0FFFFFFFFh
.text$mn:0000279D                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000027A2                 mov     eax, large fs:0
.text$mn:000027A8                 push    eax
.text$mn:000027A9                 push    ecx
.text$mn:000027AA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000027AF                 xor     eax, ebp
.text$mn:000027B1                 push    eax
.text$mn:000027B2                 lea     eax, [ebp+var_C]
.text$mn:000027B5                 mov     large fs:0, eax
.text$mn:000027BB                 mov     [ebp+var_10], ecx
.text$mn:000027BE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000027C1                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000027C6                 mov     [ebp+var_4], 0
.text$mn:000027CD                 mov     eax, [ebp+var_10]
.text$mn:000027D0                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:000027D6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000027DD                 mov     eax, [ebp+var_10]
.text$mn:000027E0                 mov     ecx, [ebp+var_C]
.text$mn:000027E3                 mov     large fs:0, ecx
.text$mn:000027EA                 pop     ecx
.text$mn:000027EB                 mov     esp, ebp
.text$mn:000027ED                 pop     ebp
.text$mn:000027EE                 retn
.text$mn:000027EE ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:000027EE
.text$mn:000027EE ; ---------------------------------------------------------------------------
.text$mn:000027EF                 align 10h
.text$mn:000027EF _text$mn        ends
.text$mn:000027EF
.text$x:000027F0 ; ===========================================================================
.text$x:000027F0
.text$x:000027F0 ; Segment type: Pure code
.text$x:000027F0 ; Segment permissions: Read/Execute
.text$x:000027F0 _text$x         segment para public 'CODE' use32
.text$x:000027F0                 assume cs:_text$x
.text$x:000027F0                 ;org 27F0h
.text$x:000027F0 ; COMDAT (pick associative to section at 2798)
.text$x:000027F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000027F0
.text$x:000027F0 ; =============== S U B R O U T I N E =======================================
.text$x:000027F0
.text$x:000027F0
.text$x:000027F0 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:000027F0                                         ; DATA XREF: .xdata$x:00006B00o
.text$x:000027F0                 mov     ecx, [ebp-10h]  ; this
.text$x:000027F3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000027F3 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:000027F3
.text$x:000027F8
.text$x:000027F8 ; =============== S U B R O U T I N E =======================================
.text$x:000027F8
.text$x:000027F8
.text$x:000027F8 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:000027F8                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:000027F8
.text$x:000027F8 arg_4           = dword ptr  8
.text$x:000027F8
.text$x:000027F8                 mov     edx, [esp+arg_4]
.text$x:000027FC                 lea     eax, [edx+0Ch]
.text$x:000027FF                 mov     ecx, [edx-8]
.text$x:00002802                 xor     ecx, eax
.text$x:00002804                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002809                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:0000280E                 jmp     ___CxxFrameHandler3
.text$x:0000280E __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:0000280E
.text$x:0000280E ; ---------------------------------------------------------------------------
.text$x:00002813                 align 4
.text$x:00002813 _text$x         ends
.text$x:00002813
.text$mn:00002814 ; ===========================================================================
.text$mn:00002814
.text$mn:00002814 ; Segment type: Pure code
.text$mn:00002814 ; Segment permissions: Read/Execute
.text$mn:00002814 _text$mn        segment para public 'CODE' use32
.text$mn:00002814                 assume cs:_text$mn
.text$mn:00002814                 ;org 2814h
.text$mn:00002814 ; COMDAT (pick any)
.text$mn:00002814                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002814
.text$mn:00002814 ; =============== S U B R O U T I N E =======================================
.text$mn:00002814
.text$mn:00002814 ; Attributes: bp-based frame
.text$mn:00002814
.text$mn:00002814 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:00002814                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:00002814 ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:00002814                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+2Dp
.text$mn:00002814
.text$mn:00002814 var_4           = dword ptr -4
.text$mn:00002814 arg_0           = dword ptr  8
.text$mn:00002814
.text$mn:00002814                 push    ebp
.text$mn:00002815                 mov     ebp, esp
.text$mn:00002817                 push    ecx
.text$mn:00002818                 mov     [ebp+var_4], ecx
.text$mn:0000281B                 mov     eax, [ebp+var_4]
.text$mn:0000281E                 mov     dword ptr [eax], 0
.text$mn:00002824                 mov     ecx, [ebp+var_4]
.text$mn:00002827                 mov     dword ptr [ecx+4], 0
.text$mn:0000282E                 mov     edx, [ebp+arg_0]
.text$mn:00002831                 push    edx
.text$mn:00002832                 mov     ecx, [ebp+var_4]
.text$mn:00002835                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:0000283A                 mov     eax, [ebp+var_4]
.text$mn:0000283D                 mov     esp, ebp
.text$mn:0000283F                 pop     ebp
.text$mn:00002840                 retn    4
.text$mn:00002840 ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:00002840
.text$mn:00002840 ; ---------------------------------------------------------------------------
.text$mn:00002843                 align 4
.text$mn:00002843 _text$mn        ends
.text$mn:00002843
.text$mn:00002844 ; ===========================================================================
.text$mn:00002844
.text$mn:00002844 ; Segment type: Pure code
.text$mn:00002844 ; Segment permissions: Read/Execute
.text$mn:00002844 _text$mn        segment para public 'CODE' use32
.text$mn:00002844                 assume cs:_text$mn
.text$mn:00002844                 ;org 2844h
.text$mn:00002844 ; COMDAT (pick any)
.text$mn:00002844                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002844
.text$mn:00002844 ; =============== S U B R O U T I N E =======================================
.text$mn:00002844
.text$mn:00002844 ; Attributes: bp-based frame
.text$mn:00002844
.text$mn:00002844 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00002844                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:00002844 ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00002844                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(uint,std::_Container_base12 const *)+29p
.text$mn:00002844
.text$mn:00002844 var_4           = dword ptr -4
.text$mn:00002844
.text$mn:00002844                 push    ebp
.text$mn:00002845                 mov     ebp, esp
.text$mn:00002847                 push    ecx
.text$mn:00002848                 mov     [ebp+var_4], ecx
.text$mn:0000284B                 mov     eax, [ebp+var_4]
.text$mn:0000284E                 mov     dword ptr [eax], 0
.text$mn:00002854                 mov     ecx, [ebp+var_4]
.text$mn:00002857                 mov     dword ptr [ecx+4], 0
.text$mn:0000285E                 mov     eax, [ebp+var_4]
.text$mn:00002861                 mov     esp, ebp
.text$mn:00002863                 pop     ebp
.text$mn:00002864                 retn
.text$mn:00002864 ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:00002864
.text$mn:00002864 ; ---------------------------------------------------------------------------
.text$mn:00002865                 align 4
.text$mn:00002865 _text$mn        ends
.text$mn:00002865
.text$mn:00002868 ; ===========================================================================
.text$mn:00002868
.text$mn:00002868 ; Segment type: Pure code
.text$mn:00002868 ; Segment permissions: Read/Execute
.text$mn:00002868 _text$mn        segment para public 'CODE' use32
.text$mn:00002868                 assume cs:_text$mn
.text$mn:00002868                 ;org 2868h
.text$mn:00002868 ; COMDAT (pick any)
.text$mn:00002868                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002868
.text$mn:00002868 ; =============== S U B R O U T I N E =======================================
.text$mn:00002868
.text$mn:00002868 ; Attributes: bp-based frame
.text$mn:00002868
.text$mn:00002868 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00002868                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00002868 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00002868                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00002868
.text$mn:00002868 var_10          = dword ptr -10h
.text$mn:00002868 var_C           = dword ptr -0Ch
.text$mn:00002868 var_4           = dword ptr -4
.text$mn:00002868
.text$mn:00002868                 push    ebp
.text$mn:00002869                 mov     ebp, esp
.text$mn:0000286B                 push    0FFFFFFFFh
.text$mn:0000286D                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00002872                 mov     eax, large fs:0
.text$mn:00002878                 push    eax
.text$mn:00002879                 push    ecx
.text$mn:0000287A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000287F                 xor     eax, ebp
.text$mn:00002881                 push    eax
.text$mn:00002882                 lea     eax, [ebp+var_C]
.text$mn:00002885                 mov     large fs:0, eax
.text$mn:0000288B                 mov     [ebp+var_10], ecx
.text$mn:0000288E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002891                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00002896                 mov     [ebp+var_4], 0
.text$mn:0000289D                 mov     eax, [ebp+var_10]
.text$mn:000028A0                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:000028A6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000028AD                 mov     eax, [ebp+var_10]
.text$mn:000028B0                 mov     ecx, [ebp+var_C]
.text$mn:000028B3                 mov     large fs:0, ecx
.text$mn:000028BA                 pop     ecx
.text$mn:000028BB                 mov     esp, ebp
.text$mn:000028BD                 pop     ebp
.text$mn:000028BE                 retn
.text$mn:000028BE ??0_System_error_category@std@@QAE@XZ endp
.text$mn:000028BE
.text$mn:000028BE ; ---------------------------------------------------------------------------
.text$mn:000028BF                 align 10h
.text$mn:000028BF _text$mn        ends
.text$mn:000028BF
.text$x:000028C0 ; ===========================================================================
.text$x:000028C0
.text$x:000028C0 ; Segment type: Pure code
.text$x:000028C0 ; Segment permissions: Read/Execute
.text$x:000028C0 _text$x         segment para public 'CODE' use32
.text$x:000028C0                 assume cs:_text$x
.text$x:000028C0                 ;org 28C0h
.text$x:000028C0 ; COMDAT (pick associative to section at 2868)
.text$x:000028C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000028C0
.text$x:000028C0 ; =============== S U B R O U T I N E =======================================
.text$x:000028C0
.text$x:000028C0
.text$x:000028C0 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:000028C0                                         ; DATA XREF: .xdata$x:00006B84o
.text$x:000028C0                 mov     ecx, [ebp-10h]  ; this
.text$x:000028C3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000028C3 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:000028C3
.text$x:000028C8
.text$x:000028C8 ; =============== S U B R O U T I N E =======================================
.text$x:000028C8
.text$x:000028C8
.text$x:000028C8 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000028C8                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000028C8
.text$x:000028C8 arg_4           = dword ptr  8
.text$x:000028C8
.text$x:000028C8                 mov     edx, [esp+arg_4]
.text$x:000028CC                 lea     eax, [edx+0Ch]
.text$x:000028CF                 mov     ecx, [edx-8]
.text$x:000028D2                 xor     ecx, eax
.text$x:000028D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000028D9                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:000028DE                 jmp     ___CxxFrameHandler3
.text$x:000028DE __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:000028DE
.text$x:000028DE ; ---------------------------------------------------------------------------
.text$x:000028E3                 align 4
.text$x:000028E3 _text$x         ends
.text$x:000028E3
.text$mn:000028E4 ; ===========================================================================
.text$mn:000028E4
.text$mn:000028E4 ; Segment type: Pure code
.text$mn:000028E4 ; Segment permissions: Read/Execute
.text$mn:000028E4 _text$mn        segment para public 'CODE' use32
.text$mn:000028E4                 assume cs:_text$mn
.text$mn:000028E4                 ;org 28E4h
.text$mn:000028E4 ; COMDAT (pick any)
.text$mn:000028E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028E4
.text$mn:000028E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000028E4
.text$mn:000028E4 ; Attributes: bp-based frame
.text$mn:000028E4
.text$mn:000028E4 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000028E4                 public ??0error_category@std@@QAE@XZ
.text$mn:000028E4 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000028E4
.text$mn:000028E4 var_4           = dword ptr -4
.text$mn:000028E4
.text$mn:000028E4                 push    ebp
.text$mn:000028E5                 mov     ebp, esp
.text$mn:000028E7                 push    ecx
.text$mn:000028E8                 mov     [ebp+var_4], ecx
.text$mn:000028EB                 mov     eax, [ebp+var_4]
.text$mn:000028EE                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000028F4                 mov     eax, [ebp+var_4]
.text$mn:000028F7                 mov     esp, ebp
.text$mn:000028F9                 pop     ebp
.text$mn:000028FA                 retn
.text$mn:000028FA ??0error_category@std@@QAE@XZ endp
.text$mn:000028FA
.text$mn:000028FA ; ---------------------------------------------------------------------------
.text$mn:000028FB                 align 4
.text$mn:000028FB _text$mn        ends
.text$mn:000028FB
.text$mn:000028FC ; ===========================================================================
.text$mn:000028FC
.text$mn:000028FC ; Segment type: Pure code
.text$mn:000028FC ; Segment permissions: Read/Execute
.text$mn:000028FC _text$mn        segment para public 'CODE' use32
.text$mn:000028FC                 assume cs:_text$mn
.text$mn:000028FC                 ;org 28FCh
.text$mn:000028FC ; COMDAT (pick any)
.text$mn:000028FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028FC
.text$mn:000028FC ; =============== S U B R O U T I N E =======================================
.text$mn:000028FC
.text$mn:000028FC ; Attributes: bp-based frame
.text$mn:000028FC
.text$mn:000028FC ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:000028FC                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:000028FC ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:000028FC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:000028FC                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:000028FC
.text$mn:000028FC var_4           = dword ptr -4
.text$mn:000028FC arg_0           = dword ptr  8
.text$mn:000028FC arg_4           = dword ptr  0Ch
.text$mn:000028FC
.text$mn:000028FC                 push    ebp
.text$mn:000028FD                 mov     ebp, esp
.text$mn:000028FF                 push    ecx
.text$mn:00002900                 mov     [ebp+var_4], ecx
.text$mn:00002903                 mov     eax, [ebp+var_4]
.text$mn:00002906                 mov     ecx, [ebp+arg_0]
.text$mn:00002909                 mov     [eax], ecx
.text$mn:0000290B                 mov     edx, [ebp+var_4]
.text$mn:0000290E                 mov     eax, [ebp+arg_4]
.text$mn:00002911                 mov     [edx+4], eax
.text$mn:00002914                 mov     eax, [ebp+var_4]
.text$mn:00002917                 mov     esp, ebp
.text$mn:00002919                 pop     ebp
.text$mn:0000291A                 retn    8
.text$mn:0000291A ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:0000291A
.text$mn:0000291A ; ---------------------------------------------------------------------------
.text$mn:0000291D                 align 10h
.text$mn:0000291D _text$mn        ends
.text$mn:0000291D
.text$mn:00002920 ; ===========================================================================
.text$mn:00002920
.text$mn:00002920 ; Segment type: Pure code
.text$mn:00002920 ; Segment permissions: Read/Execute
.text$mn:00002920 _text$mn        segment para public 'CODE' use32
.text$mn:00002920                 assume cs:_text$mn
.text$mn:00002920                 ;org 2920h
.text$mn:00002920 ; COMDAT (pick any)
.text$mn:00002920                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002920
.text$mn:00002920 ; =============== S U B R O U T I N E =======================================
.text$mn:00002920
.text$mn:00002920 ; Attributes: bp-based frame
.text$mn:00002920
.text$mn:00002920 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00002920                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00002920 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00002920                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00002920
.text$mn:00002920 var_4           = dword ptr -4
.text$mn:00002920 arg_0           = dword ptr  8
.text$mn:00002920
.text$mn:00002920                 push    ebp
.text$mn:00002921                 mov     ebp, esp
.text$mn:00002923                 push    ecx
.text$mn:00002924                 mov     [ebp+var_4], ecx
.text$mn:00002927                 mov     eax, [ebp+var_4]
.text$mn:0000292A                 mov     ecx, [ebp+arg_0]
.text$mn:0000292D                 mov     [eax], ecx
.text$mn:0000292F                 mov     eax, [ebp+var_4]
.text$mn:00002932                 mov     esp, ebp
.text$mn:00002934                 pop     ebp
.text$mn:00002935                 retn    4
.text$mn:00002935 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00002935
.text$mn:00002935 _text$mn        ends
.text$mn:00002935
.text$mn:00002938 ; ===========================================================================
.text$mn:00002938
.text$mn:00002938 ; Segment type: Pure code
.text$mn:00002938 ; Segment permissions: Read/Execute
.text$mn:00002938 _text$mn        segment para public 'CODE' use32
.text$mn:00002938                 assume cs:_text$mn
.text$mn:00002938                 ;org 2938h
.text$mn:00002938 ; COMDAT (pick any)
.text$mn:00002938                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002938
.text$mn:00002938 ; =============== S U B R O U T I N E =======================================
.text$mn:00002938
.text$mn:00002938 ; Attributes: bp-based frame
.text$mn:00002938
.text$mn:00002938 ; public: __thiscall std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>::~_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>(void)
.text$mn:00002938                 public ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ
.text$mn:00002938 ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00002938                                         ; CODE XREF: __unwindfunclet$?remove@LastRecentFileList@@QAEXH@Z$2+3j
.text$mn:00002938                                         ; __unwindfunclet$?clear@LastRecentFileList@@QAEXXZ$2+3j ...
.text$mn:00002938
.text$mn:00002938 var_10          = dword ptr -10h
.text$mn:00002938 var_C           = dword ptr -0Ch
.text$mn:00002938 var_4           = dword ptr -4
.text$mn:00002938
.text$mn:00002938                 push    ebp
.text$mn:00002939                 mov     ebp, esp
.text$mn:0000293B                 push    0FFFFFFFFh
.text$mn:0000293D                 push    offset __ehhandler$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ
.text$mn:00002942                 mov     eax, large fs:0
.text$mn:00002948                 push    eax
.text$mn:00002949                 push    ecx
.text$mn:0000294A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000294F                 xor     eax, ebp
.text$mn:00002951                 push    eax
.text$mn:00002952                 lea     eax, [ebp+var_C]
.text$mn:00002955                 mov     large fs:0, eax
.text$mn:0000295B                 mov     [ebp+var_10], ecx
.text$mn:0000295E                 mov     [ebp+var_4], 0
.text$mn:00002965                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000296C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000296F                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00002974                 mov     ecx, [ebp+var_C]
.text$mn:00002977                 mov     large fs:0, ecx
.text$mn:0000297E                 pop     ecx
.text$mn:0000297F                 mov     esp, ebp
.text$mn:00002981                 pop     ebp
.text$mn:00002982                 retn
.text$mn:00002982 ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00002982
.text$mn:00002982 ; ---------------------------------------------------------------------------
.text$mn:00002983                 align 4
.text$mn:00002983 _text$mn        ends
.text$mn:00002983
.text$x:00002984 ; ===========================================================================
.text$x:00002984
.text$x:00002984 ; Segment type: Pure code
.text$x:00002984 ; Segment permissions: Read/Execute
.text$x:00002984 _text$x         segment para public 'CODE' use32
.text$x:00002984                 assume cs:_text$x
.text$x:00002984                 ;org 2984h
.text$x:00002984 ; COMDAT (pick associative to section at 2938)
.text$x:00002984                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002984
.text$x:00002984 ; =============== S U B R O U T I N E =======================================
.text$x:00002984
.text$x:00002984
.text$x:00002984 __unwindfunclet$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002984                                         ; DATA XREF: .xdata$x:000071F0o
.text$x:00002984                 mov     ecx, [ebp-10h]  ; this
.text$x:00002987                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00002987 __unwindfunclet$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002987
.text$x:0000298C
.text$x:0000298C ; =============== S U B R O U T I N E =======================================
.text$x:0000298C
.text$x:0000298C
.text$x:0000298C __ehhandler$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000298C                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)+5o
.text$x:0000298C
.text$x:0000298C arg_4           = dword ptr  8
.text$x:0000298C
.text$x:0000298C                 mov     edx, [esp+arg_4]
.text$x:00002990                 lea     eax, [edx+0Ch]
.text$x:00002993                 mov     ecx, [edx-8]
.text$x:00002996                 xor     ecx, eax
.text$x:00002998                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000299D                 mov     eax, offset __ehfuncinfo$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ
.text$x:000029A2                 jmp     ___CxxFrameHandler3
.text$x:000029A2 __ehhandler$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ endp
.text$x:000029A2
.text$x:000029A2 ; ---------------------------------------------------------------------------
.text$x:000029A7                 align 4
.text$x:000029A7 _text$x         ends
.text$x:000029A7
.text$mn:000029A8 ; ===========================================================================
.text$mn:000029A8
.text$mn:000029A8 ; Segment type: Pure code
.text$mn:000029A8 ; Segment permissions: Read/Execute
.text$mn:000029A8 _text$mn        segment para public 'CODE' use32
.text$mn:000029A8                 assume cs:_text$mn
.text$mn:000029A8                 ;org 29A8h
.text$mn:000029A8 ; COMDAT (pick any)
.text$mn:000029A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029A8
.text$mn:000029A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000029A8
.text$mn:000029A8 ; Attributes: bp-based frame
.text$mn:000029A8
.text$mn:000029A8 ; public: __thiscall std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>::~_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>(void)
.text$mn:000029A8                 public ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ
.text$mn:000029A8 ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000029A8                                         ; CODE XREF: LastRecentFileList::remove(int)+FEp
.text$mn:000029A8                                         ; LastRecentFileList::remove(int)+10Ap ...
.text$mn:000029A8
.text$mn:000029A8 var_10          = dword ptr -10h
.text$mn:000029A8 var_C           = dword ptr -0Ch
.text$mn:000029A8 var_4           = dword ptr -4
.text$mn:000029A8
.text$mn:000029A8                 push    ebp
.text$mn:000029A9                 mov     ebp, esp
.text$mn:000029AB                 push    0FFFFFFFFh
.text$mn:000029AD                 push    offset __ehhandler$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ
.text$mn:000029B2                 mov     eax, large fs:0
.text$mn:000029B8                 push    eax
.text$mn:000029B9                 push    ecx
.text$mn:000029BA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000029BF                 xor     eax, ebp
.text$mn:000029C1                 push    eax
.text$mn:000029C2                 lea     eax, [ebp+var_C]
.text$mn:000029C5                 mov     large fs:0, eax
.text$mn:000029CB                 mov     [ebp+var_10], ecx
.text$mn:000029CE                 mov     [ebp+var_4], 0
.text$mn:000029D5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000029DC                 mov     ecx, [ebp+var_10]
.text$mn:000029DF                 call    ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:000029E4                 mov     ecx, [ebp+var_C]
.text$mn:000029E7                 mov     large fs:0, ecx
.text$mn:000029EE                 pop     ecx
.text$mn:000029EF                 mov     esp, ebp
.text$mn:000029F1                 pop     ebp
.text$mn:000029F2                 retn
.text$mn:000029F2 ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000029F2
.text$mn:000029F2 ; ---------------------------------------------------------------------------
.text$mn:000029F3                 align 4
.text$mn:000029F3 _text$mn        ends
.text$mn:000029F3
.text$x:000029F4 ; ===========================================================================
.text$x:000029F4
.text$x:000029F4 ; Segment type: Pure code
.text$x:000029F4 ; Segment permissions: Read/Execute
.text$x:000029F4 _text$x         segment para public 'CODE' use32
.text$x:000029F4                 assume cs:_text$x
.text$x:000029F4                 ;org 29F4h
.text$x:000029F4 ; COMDAT (pick associative to section at 29A8)
.text$x:000029F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000029F4
.text$x:000029F4 ; =============== S U B R O U T I N E =======================================
.text$x:000029F4
.text$x:000029F4
.text$x:000029F4 __unwindfunclet$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000029F4                                         ; DATA XREF: .xdata$x:000072DCo
.text$x:000029F4                 mov     ecx, [ebp-10h]
.text$x:000029F7                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000029F7 __unwindfunclet$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000029F7
.text$x:000029FC
.text$x:000029FC ; =============== S U B R O U T I N E =======================================
.text$x:000029FC
.text$x:000029FC
.text$x:000029FC __ehhandler$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:000029FC                                         ; DATA XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)+5o
.text$x:000029FC
.text$x:000029FC arg_4           = dword ptr  8
.text$x:000029FC
.text$x:000029FC                 mov     edx, [esp+arg_4]
.text$x:00002A00                 lea     eax, [edx+0Ch]
.text$x:00002A03                 mov     ecx, [edx-8]
.text$x:00002A06                 xor     ecx, eax
.text$x:00002A08                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A0D                 mov     eax, offset __ehfuncinfo$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ
.text$x:00002A12                 jmp     ___CxxFrameHandler3
.text$x:00002A12 __ehhandler$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00002A12
.text$x:00002A12 ; ---------------------------------------------------------------------------
.text$x:00002A17                 align 4
.text$x:00002A17 _text$x         ends
.text$x:00002A17
.text$mn:00002A18 ; ===========================================================================
.text$mn:00002A18
.text$mn:00002A18 ; Segment type: Pure code
.text$mn:00002A18 ; Segment permissions: Read/Execute
.text$mn:00002A18 _text$mn        segment para public 'CODE' use32
.text$mn:00002A18                 assume cs:_text$mn
.text$mn:00002A18                 ;org 2A18h
.text$mn:00002A18 ; COMDAT (pick any)
.text$mn:00002A18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A18
.text$mn:00002A18 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A18
.text$mn:00002A18 ; Attributes: bp-based frame
.text$mn:00002A18
.text$mn:00002A18 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00002A18                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00002A18 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00002A18                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00002A18                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00002A18
.text$mn:00002A18 var_10          = dword ptr -10h
.text$mn:00002A18 var_C           = dword ptr -0Ch
.text$mn:00002A18 var_4           = dword ptr -4
.text$mn:00002A18
.text$mn:00002A18                 push    ebp
.text$mn:00002A19                 mov     ebp, esp
.text$mn:00002A1B                 push    0FFFFFFFFh
.text$mn:00002A1D                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00002A22                 mov     eax, large fs:0
.text$mn:00002A28                 push    eax
.text$mn:00002A29                 push    ecx
.text$mn:00002A2A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002A2F                 xor     eax, ebp
.text$mn:00002A31                 push    eax
.text$mn:00002A32                 lea     eax, [ebp+var_C]
.text$mn:00002A35                 mov     large fs:0, eax
.text$mn:00002A3B                 mov     [ebp+var_10], ecx
.text$mn:00002A3E                 mov     [ebp+var_4], 0
.text$mn:00002A45                 mov     ecx, [ebp+var_10]
.text$mn:00002A48                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00002A4D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002A54                 mov     ecx, [ebp+var_10]
.text$mn:00002A57                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00002A5C                 mov     ecx, [ebp+var_C]
.text$mn:00002A5F                 mov     large fs:0, ecx
.text$mn:00002A66                 pop     ecx
.text$mn:00002A67                 mov     esp, ebp
.text$mn:00002A69                 pop     ebp
.text$mn:00002A6A                 retn
.text$mn:00002A6A ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00002A6A
.text$mn:00002A6A ; ---------------------------------------------------------------------------
.text$mn:00002A6B                 align 4
.text$mn:00002A6B _text$mn        ends
.text$mn:00002A6B
.text$x:00002A6C ; ===========================================================================
.text$x:00002A6C
.text$x:00002A6C ; Segment type: Pure code
.text$x:00002A6C ; Segment permissions: Read/Execute
.text$x:00002A6C _text$x         segment para public 'CODE' use32
.text$x:00002A6C                 assume cs:_text$x
.text$x:00002A6C                 ;org 2A6Ch
.text$x:00002A6C ; COMDAT (pick associative to section at 2A18)
.text$x:00002A6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002A6C
.text$x:00002A6C ; =============== S U B R O U T I N E =======================================
.text$x:00002A6C
.text$x:00002A6C
.text$x:00002A6C __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002A6C                                         ; DATA XREF: .xdata$x:0000696Co
.text$x:00002A6C                 mov     ecx, [ebp-10h]
.text$x:00002A6F                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00002A6F __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002A6F
.text$x:00002A74
.text$x:00002A74 ; =============== S U B R O U T I N E =======================================
.text$x:00002A74
.text$x:00002A74
.text$x:00002A74 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00002A74                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00002A74
.text$x:00002A74 arg_4           = dword ptr  8
.text$x:00002A74
.text$x:00002A74                 mov     edx, [esp+arg_4]
.text$x:00002A78                 lea     eax, [edx+0Ch]
.text$x:00002A7B                 mov     ecx, [edx-8]
.text$x:00002A7E                 xor     ecx, eax
.text$x:00002A80                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A85                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00002A8A                 jmp     ___CxxFrameHandler3
.text$x:00002A8A __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00002A8A
.text$x:00002A8A ; ---------------------------------------------------------------------------
.text$x:00002A8F                 align 10h
.text$x:00002A8F _text$x         ends
.text$x:00002A8F
.text$mn:00002A90 ; ===========================================================================
.text$mn:00002A90
.text$mn:00002A90 ; Segment type: Pure code
.text$mn:00002A90 ; Segment permissions: Read/Execute
.text$mn:00002A90 _text$mn        segment para public 'CODE' use32
.text$mn:00002A90                 assume cs:_text$mn
.text$mn:00002A90                 ;org 2A90h
.text$mn:00002A90 ; COMDAT (pick any)
.text$mn:00002A90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A90
.text$mn:00002A90 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A90
.text$mn:00002A90 ; Attributes: bp-based frame
.text$mn:00002A90
.text$mn:00002A90 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:00002A90                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00002A90 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00002A90                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00002A90                                         ; __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0+3j ...
.text$mn:00002A90
.text$mn:00002A90 var_10          = dword ptr -10h
.text$mn:00002A90 var_C           = dword ptr -0Ch
.text$mn:00002A90 var_4           = dword ptr -4
.text$mn:00002A90
.text$mn:00002A90                 push    ebp
.text$mn:00002A91                 mov     ebp, esp
.text$mn:00002A93                 push    0FFFFFFFFh
.text$mn:00002A95                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00002A9A                 mov     eax, large fs:0
.text$mn:00002AA0                 push    eax
.text$mn:00002AA1                 push    ecx
.text$mn:00002AA2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002AA7                 xor     eax, ebp
.text$mn:00002AA9                 push    eax
.text$mn:00002AAA                 lea     eax, [ebp+var_C]
.text$mn:00002AAD                 mov     large fs:0, eax
.text$mn:00002AB3                 mov     [ebp+var_10], ecx
.text$mn:00002AB6                 mov     [ebp+var_4], 0
.text$mn:00002ABD                 mov     ecx, [ebp+var_10]
.text$mn:00002AC0                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00002AC5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002ACC                 mov     ecx, [ebp+var_10]
.text$mn:00002ACF                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00002AD4                 mov     ecx, [ebp+var_C]
.text$mn:00002AD7                 mov     large fs:0, ecx
.text$mn:00002ADE                 pop     ecx
.text$mn:00002ADF                 mov     esp, ebp
.text$mn:00002AE1                 pop     ebp
.text$mn:00002AE2                 retn
.text$mn:00002AE2 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:00002AE2
.text$mn:00002AE2 ; ---------------------------------------------------------------------------
.text$mn:00002AE3                 align 4
.text$mn:00002AE3 _text$mn        ends
.text$mn:00002AE3
.text$x:00002AE4 ; ===========================================================================
.text$x:00002AE4
.text$x:00002AE4 ; Segment type: Pure code
.text$x:00002AE4 ; Segment permissions: Read/Execute
.text$x:00002AE4 _text$x         segment para public 'CODE' use32
.text$x:00002AE4                 assume cs:_text$x
.text$x:00002AE4                 ;org 2AE4h
.text$x:00002AE4 ; COMDAT (pick associative to section at 2A90)
.text$x:00002AE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002AE4
.text$x:00002AE4 ; =============== S U B R O U T I N E =======================================
.text$x:00002AE4
.text$x:00002AE4
.text$x:00002AE4 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002AE4                                         ; DATA XREF: .xdata$x:00006C8Co
.text$x:00002AE4                 mov     ecx, [ebp-10h]
.text$x:00002AE7                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00002AE7 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002AE7
.text$x:00002AEC
.text$x:00002AEC ; =============== S U B R O U T I N E =======================================
.text$x:00002AEC
.text$x:00002AEC
.text$x:00002AEC __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00002AEC                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:00002AEC
.text$x:00002AEC arg_4           = dword ptr  8
.text$x:00002AEC
.text$x:00002AEC                 mov     edx, [esp+arg_4]
.text$x:00002AF0                 lea     eax, [edx+0Ch]
.text$x:00002AF3                 mov     ecx, [edx-8]
.text$x:00002AF6                 xor     ecx, eax
.text$x:00002AF8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002AFD                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:00002B02                 jmp     ___CxxFrameHandler3
.text$x:00002B02 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:00002B02
.text$x:00002B02 ; ---------------------------------------------------------------------------
.text$x:00002B07                 align 4
.text$x:00002B07 _text$x         ends
.text$x:00002B07
.text$mn:00002B08 ; ===========================================================================
.text$mn:00002B08
.text$mn:00002B08 ; Segment type: Pure code
.text$mn:00002B08 ; Segment permissions: Read/Execute
.text$mn:00002B08 _text$mn        segment para public 'CODE' use32
.text$mn:00002B08                 assume cs:_text$mn
.text$mn:00002B08                 ;org 2B08h
.text$mn:00002B08 ; COMDAT (pick any)
.text$mn:00002B08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B08
.text$mn:00002B08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B08
.text$mn:00002B08 ; Attributes: bp-based frame
.text$mn:00002B08
.text$mn:00002B08 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00002B08                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002B08 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00002B08                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00002B08                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00002B08
.text$mn:00002B08 var_10          = dword ptr -10h
.text$mn:00002B08 var_C           = dword ptr -0Ch
.text$mn:00002B08 var_4           = dword ptr -4
.text$mn:00002B08
.text$mn:00002B08                 push    ebp
.text$mn:00002B09                 mov     ebp, esp
.text$mn:00002B0B                 push    0FFFFFFFFh
.text$mn:00002B0D                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002B12                 mov     eax, large fs:0
.text$mn:00002B18                 push    eax
.text$mn:00002B19                 push    ecx
.text$mn:00002B1A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B1F                 xor     eax, ebp
.text$mn:00002B21                 push    eax
.text$mn:00002B22                 lea     eax, [ebp+var_C]
.text$mn:00002B25                 mov     large fs:0, eax
.text$mn:00002B2B                 mov     [ebp+var_10], ecx
.text$mn:00002B2E                 mov     [ebp+var_4], 0
.text$mn:00002B35                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002B3C                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002B3F                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00002B44                 mov     ecx, [ebp+var_C]
.text$mn:00002B47                 mov     large fs:0, ecx
.text$mn:00002B4E                 pop     ecx
.text$mn:00002B4F                 mov     esp, ebp
.text$mn:00002B51                 pop     ebp
.text$mn:00002B52                 retn
.text$mn:00002B52 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00002B52
.text$mn:00002B52 ; ---------------------------------------------------------------------------
.text$mn:00002B53                 align 4
.text$mn:00002B53 _text$mn        ends
.text$mn:00002B53
.text$x:00002B54 ; ===========================================================================
.text$x:00002B54
.text$x:00002B54 ; Segment type: Pure code
.text$x:00002B54 ; Segment permissions: Read/Execute
.text$x:00002B54 _text$x         segment para public 'CODE' use32
.text$x:00002B54                 assume cs:_text$x
.text$x:00002B54                 ;org 2B54h
.text$x:00002B54 ; COMDAT (pick associative to section at 2B08)
.text$x:00002B54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002B54
.text$x:00002B54 ; =============== S U B R O U T I N E =======================================
.text$x:00002B54
.text$x:00002B54
.text$x:00002B54 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00002B54                                         ; DATA XREF: .xdata$x:00006914o
.text$x:00002B54                 mov     ecx, [ebp-10h]  ; this
.text$x:00002B57                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002B57 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00002B57
.text$x:00002B5C
.text$x:00002B5C ; =============== S U B R O U T I N E =======================================
.text$x:00002B5C
.text$x:00002B5C
.text$x:00002B5C __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00002B5C                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00002B5C
.text$x:00002B5C arg_4           = dword ptr  8
.text$x:00002B5C
.text$x:00002B5C                 mov     edx, [esp+arg_4]
.text$x:00002B60                 lea     eax, [edx+0Ch]
.text$x:00002B63                 mov     ecx, [edx-8]
.text$x:00002B66                 xor     ecx, eax
.text$x:00002B68                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B6D                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00002B72                 jmp     ___CxxFrameHandler3
.text$x:00002B72 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00002B72
.text$x:00002B72 ; ---------------------------------------------------------------------------
.text$x:00002B77                 align 4
.text$x:00002B77 _text$x         ends
.text$x:00002B77
.text$mn:00002B78 ; ===========================================================================
.text$mn:00002B78
.text$mn:00002B78 ; Segment type: Pure code
.text$mn:00002B78 ; Segment permissions: Read/Execute
.text$mn:00002B78 _text$mn        segment para public 'CODE' use32
.text$mn:00002B78                 assume cs:_text$mn
.text$mn:00002B78                 ;org 2B78h
.text$mn:00002B78 ; COMDAT (pick any)
.text$mn:00002B78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B78
.text$mn:00002B78 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B78
.text$mn:00002B78 ; Attributes: bp-based frame
.text$mn:00002B78
.text$mn:00002B78 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00002B78                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00002B78 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00002B78                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:00002B78                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:00002B78
.text$mn:00002B78 var_10          = dword ptr -10h
.text$mn:00002B78 var_C           = dword ptr -0Ch
.text$mn:00002B78 var_4           = dword ptr -4
.text$mn:00002B78
.text$mn:00002B78                 push    ebp
.text$mn:00002B79                 mov     ebp, esp
.text$mn:00002B7B                 push    0FFFFFFFFh
.text$mn:00002B7D                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00002B82                 mov     eax, large fs:0
.text$mn:00002B88                 push    eax
.text$mn:00002B89                 push    ecx
.text$mn:00002B8A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B8F                 xor     eax, ebp
.text$mn:00002B91                 push    eax
.text$mn:00002B92                 lea     eax, [ebp+var_C]
.text$mn:00002B95                 mov     large fs:0, eax
.text$mn:00002B9B                 mov     [ebp+var_10], ecx
.text$mn:00002B9E                 mov     [ebp+var_4], 0
.text$mn:00002BA5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002BAC                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002BAF                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00002BB4                 mov     ecx, [ebp+var_C]
.text$mn:00002BB7                 mov     large fs:0, ecx
.text$mn:00002BBE                 pop     ecx
.text$mn:00002BBF                 mov     esp, ebp
.text$mn:00002BC1                 pop     ebp
.text$mn:00002BC2                 retn
.text$mn:00002BC2 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00002BC2
.text$mn:00002BC2 ; ---------------------------------------------------------------------------
.text$mn:00002BC3                 align 4
.text$mn:00002BC3 _text$mn        ends
.text$mn:00002BC3
.text$x:00002BC4 ; ===========================================================================
.text$x:00002BC4
.text$x:00002BC4 ; Segment type: Pure code
.text$x:00002BC4 ; Segment permissions: Read/Execute
.text$x:00002BC4 _text$x         segment para public 'CODE' use32
.text$x:00002BC4                 assume cs:_text$x
.text$x:00002BC4                 ;org 2BC4h
.text$x:00002BC4 ; COMDAT (pick associative to section at 2B78)
.text$x:00002BC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002BC4
.text$x:00002BC4 ; =============== S U B R O U T I N E =======================================
.text$x:00002BC4
.text$x:00002BC4
.text$x:00002BC4 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00002BC4                                         ; DATA XREF: .xdata$x:00006C34o
.text$x:00002BC4                 mov     ecx, [ebp-10h]  ; this
.text$x:00002BC7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002BC7 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00002BC7
.text$x:00002BCC
.text$x:00002BCC ; =============== S U B R O U T I N E =======================================
.text$x:00002BCC
.text$x:00002BCC
.text$x:00002BCC __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00002BCC                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00002BCC
.text$x:00002BCC arg_4           = dword ptr  8
.text$x:00002BCC
.text$x:00002BCC                 mov     edx, [esp+arg_4]
.text$x:00002BD0                 lea     eax, [edx+0Ch]
.text$x:00002BD3                 mov     ecx, [edx-8]
.text$x:00002BD6                 xor     ecx, eax
.text$x:00002BD8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002BDD                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00002BE2                 jmp     ___CxxFrameHandler3
.text$x:00002BE2 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00002BE2
.text$x:00002BE2 ; ---------------------------------------------------------------------------
.text$x:00002BE7                 align 4
.text$x:00002BE7 _text$x         ends
.text$x:00002BE7
.text$mn:00002BE8 ; ===========================================================================
.text$mn:00002BE8
.text$mn:00002BE8 ; Segment type: Pure code
.text$mn:00002BE8 ; Segment permissions: Read/Execute
.text$mn:00002BE8 _text$mn        segment para public 'CODE' use32
.text$mn:00002BE8                 assume cs:_text$mn
.text$mn:00002BE8                 ;org 2BE8h
.text$mn:00002BE8 ; COMDAT (pick any)
.text$mn:00002BE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BE8
.text$mn:00002BE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BE8
.text$mn:00002BE8 ; Attributes: bp-based frame
.text$mn:00002BE8
.text$mn:00002BE8 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00002BE8                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00002BE8 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00002BE8                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00002BE8                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00002BE8
.text$mn:00002BE8 var_10          = dword ptr -10h
.text$mn:00002BE8 var_C           = dword ptr -0Ch
.text$mn:00002BE8 var_4           = dword ptr -4
.text$mn:00002BE8
.text$mn:00002BE8                 push    ebp
.text$mn:00002BE9                 mov     ebp, esp
.text$mn:00002BEB                 push    0FFFFFFFFh
.text$mn:00002BED                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00002BF2                 mov     eax, large fs:0
.text$mn:00002BF8                 push    eax
.text$mn:00002BF9                 push    ecx
.text$mn:00002BFA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002BFF                 xor     eax, ebp
.text$mn:00002C01                 push    eax
.text$mn:00002C02                 lea     eax, [ebp+var_C]
.text$mn:00002C05                 mov     large fs:0, eax
.text$mn:00002C0B                 mov     [ebp+var_10], ecx
.text$mn:00002C0E                 mov     [ebp+var_4], 0
.text$mn:00002C15                 push    0               ; Size
.text$mn:00002C17                 push    1               ; char
.text$mn:00002C19                 mov     ecx, [ebp+var_10]
.text$mn:00002C1C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002C21                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002C28                 mov     ecx, [ebp+var_10]
.text$mn:00002C2B                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00002C30                 mov     ecx, [ebp+var_C]
.text$mn:00002C33                 mov     large fs:0, ecx
.text$mn:00002C3A                 pop     ecx
.text$mn:00002C3B                 mov     esp, ebp
.text$mn:00002C3D                 pop     ebp
.text$mn:00002C3E                 retn
.text$mn:00002C3E ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00002C3E
.text$mn:00002C3E ; ---------------------------------------------------------------------------
.text$mn:00002C3F                 align 10h
.text$mn:00002C3F _text$mn        ends
.text$mn:00002C3F
.text$x:00002C40 ; ===========================================================================
.text$x:00002C40
.text$x:00002C40 ; Segment type: Pure code
.text$x:00002C40 ; Segment permissions: Read/Execute
.text$x:00002C40 _text$x         segment para public 'CODE' use32
.text$x:00002C40                 assume cs:_text$x
.text$x:00002C40                 ;org 2C40h
.text$x:00002C40 ; COMDAT (pick associative to section at 2BE8)
.text$x:00002C40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002C40
.text$x:00002C40 ; =============== S U B R O U T I N E =======================================
.text$x:00002C40
.text$x:00002C40
.text$x:00002C40 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00002C40                                         ; DATA XREF: .xdata$x:000069C4o
.text$x:00002C40                 mov     ecx, [ebp-10h]
.text$x:00002C43                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00002C43 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00002C43
.text$x:00002C48
.text$x:00002C48 ; =============== S U B R O U T I N E =======================================
.text$x:00002C48
.text$x:00002C48
.text$x:00002C48 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00002C48                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00002C48
.text$x:00002C48 arg_4           = dword ptr  8
.text$x:00002C48
.text$x:00002C48                 mov     edx, [esp+arg_4]
.text$x:00002C4C                 lea     eax, [edx+0Ch]
.text$x:00002C4F                 mov     ecx, [edx-8]
.text$x:00002C52                 xor     ecx, eax
.text$x:00002C54                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002C59                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00002C5E                 jmp     ___CxxFrameHandler3
.text$x:00002C5E __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00002C5E
.text$x:00002C5E ; ---------------------------------------------------------------------------
.text$x:00002C63                 align 4
.text$x:00002C63 _text$x         ends
.text$x:00002C63
.text$mn:00002C64 ; ===========================================================================
.text$mn:00002C64
.text$mn:00002C64 ; Segment type: Pure code
.text$mn:00002C64 ; Segment permissions: Read/Execute
.text$mn:00002C64 _text$mn        segment para public 'CODE' use32
.text$mn:00002C64                 assume cs:_text$mn
.text$mn:00002C64                 ;org 2C64h
.text$mn:00002C64 ; COMDAT (pick any)
.text$mn:00002C64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C64
.text$mn:00002C64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C64
.text$mn:00002C64 ; Attributes: bp-based frame
.text$mn:00002C64
.text$mn:00002C64 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00002C64                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00002C64 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00002C64                                         ; CODE XREF: LastRecentFileList::updateMenu(void)+2DAp
.text$mn:00002C64                                         ; LastRecentFileList::updateMenu(void)+2E6p ...
.text$mn:00002C64
.text$mn:00002C64 var_10          = dword ptr -10h
.text$mn:00002C64 var_C           = dword ptr -0Ch
.text$mn:00002C64 var_4           = dword ptr -4
.text$mn:00002C64
.text$mn:00002C64                 push    ebp
.text$mn:00002C65                 mov     ebp, esp
.text$mn:00002C67                 push    0FFFFFFFFh
.text$mn:00002C69                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00002C6E                 mov     eax, large fs:0
.text$mn:00002C74                 push    eax
.text$mn:00002C75                 push    ecx
.text$mn:00002C76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002C7B                 xor     eax, ebp
.text$mn:00002C7D                 push    eax
.text$mn:00002C7E                 lea     eax, [ebp+var_C]
.text$mn:00002C81                 mov     large fs:0, eax
.text$mn:00002C87                 mov     [ebp+var_10], ecx
.text$mn:00002C8A                 mov     [ebp+var_4], 0
.text$mn:00002C91                 push    0
.text$mn:00002C93                 push    1
.text$mn:00002C95                 mov     ecx, [ebp+var_10]
.text$mn:00002C98                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00002C9D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002CA4                 mov     ecx, [ebp+var_10]
.text$mn:00002CA7                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:00002CAC                 mov     ecx, [ebp+var_C]
.text$mn:00002CAF                 mov     large fs:0, ecx
.text$mn:00002CB6                 pop     ecx
.text$mn:00002CB7                 mov     esp, ebp
.text$mn:00002CB9                 pop     ebp
.text$mn:00002CBA                 retn
.text$mn:00002CBA ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:00002CBA
.text$mn:00002CBA ; ---------------------------------------------------------------------------
.text$mn:00002CBB                 align 4
.text$mn:00002CBB _text$mn        ends
.text$mn:00002CBB
.text$x:00002CBC ; ===========================================================================
.text$x:00002CBC
.text$x:00002CBC ; Segment type: Pure code
.text$x:00002CBC ; Segment permissions: Read/Execute
.text$x:00002CBC _text$x         segment para public 'CODE' use32
.text$x:00002CBC                 assume cs:_text$x
.text$x:00002CBC                 ;org 2CBCh
.text$x:00002CBC ; COMDAT (pick associative to section at 2C64)
.text$x:00002CBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002CBC
.text$x:00002CBC ; =============== S U B R O U T I N E =======================================
.text$x:00002CBC
.text$x:00002CBC
.text$x:00002CBC __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:00002CBC                                         ; DATA XREF: .xdata$x:00006D10o
.text$x:00002CBC                 mov     ecx, [ebp-10h]
.text$x:00002CBF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00002CBF __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:00002CBF
.text$x:00002CC4
.text$x:00002CC4 ; =============== S U B R O U T I N E =======================================
.text$x:00002CC4
.text$x:00002CC4
.text$x:00002CC4 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:00002CC4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:00002CC4
.text$x:00002CC4 arg_4           = dword ptr  8
.text$x:00002CC4
.text$x:00002CC4                 mov     edx, [esp+arg_4]
.text$x:00002CC8                 lea     eax, [edx+0Ch]
.text$x:00002CCB                 mov     ecx, [edx-8]
.text$x:00002CCE                 xor     ecx, eax
.text$x:00002CD0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002CD5                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:00002CDA                 jmp     ___CxxFrameHandler3
.text$x:00002CDA __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:00002CDA
.text$x:00002CDA ; ---------------------------------------------------------------------------
.text$x:00002CDF                 align 10h
.text$x:00002CDF _text$x         ends
.text$x:00002CDF
.text$mn:00002CE0 ; ===========================================================================
.text$mn:00002CE0
.text$mn:00002CE0 ; Segment type: Pure code
.text$mn:00002CE0 ; Segment permissions: Read/Execute
.text$mn:00002CE0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CE0                 assume cs:_text$mn
.text$mn:00002CE0                 ;org 2CE0h
.text$mn:00002CE0 ; COMDAT (pick any)
.text$mn:00002CE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CE0
.text$mn:00002CE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CE0
.text$mn:00002CE0 ; Attributes: bp-based frame
.text$mn:00002CE0
.text$mn:00002CE0 ; _DWORD __thiscall RecentItem::~RecentItem(RecentItem *__hidden this)
.text$mn:00002CE0                 public ??1RecentItem@@QAE@XZ
.text$mn:00002CE0 ??1RecentItem@@QAE@XZ proc near         ; CODE XREF: LastRecentFileList::add(wchar_t const *)+D5p
.text$mn:00002CE0                                         ; __unwindfunclet$?add@LastRecentFileList@@QAEXPB_W@Z$0+3j ...
.text$mn:00002CE0
.text$mn:00002CE0 var_10          = dword ptr -10h
.text$mn:00002CE0 var_C           = dword ptr -0Ch
.text$mn:00002CE0 var_4           = dword ptr -4
.text$mn:00002CE0
.text$mn:00002CE0                 push    ebp
.text$mn:00002CE1                 mov     ebp, esp
.text$mn:00002CE3                 push    0FFFFFFFFh
.text$mn:00002CE5                 push    offset __ehhandler$??1RecentItem@@QAE@XZ
.text$mn:00002CEA                 mov     eax, large fs:0
.text$mn:00002CF0                 push    eax
.text$mn:00002CF1                 push    ecx
.text$mn:00002CF2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002CF7                 xor     eax, ebp
.text$mn:00002CF9                 push    eax
.text$mn:00002CFA                 lea     eax, [ebp+var_C]
.text$mn:00002CFD                 mov     large fs:0, eax
.text$mn:00002D03                 mov     [ebp+var_10], ecx
.text$mn:00002D06                 mov     [ebp+var_4], 0
.text$mn:00002D0D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002D14                 mov     ecx, [ebp+var_10]
.text$mn:00002D17                 add     ecx, 4
.text$mn:00002D1A                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002D1F                 mov     ecx, [ebp+var_C]
.text$mn:00002D22                 mov     large fs:0, ecx
.text$mn:00002D29                 pop     ecx
.text$mn:00002D2A                 mov     esp, ebp
.text$mn:00002D2C                 pop     ebp
.text$mn:00002D2D                 retn
.text$mn:00002D2D ??1RecentItem@@QAE@XZ endp
.text$mn:00002D2D
.text$mn:00002D2D ; ---------------------------------------------------------------------------
.text$mn:00002D2E                 align 10h
.text$mn:00002D2E _text$mn        ends
.text$mn:00002D2E
.text$x:00002D30 ; ===========================================================================
.text$x:00002D30
.text$x:00002D30 ; Segment type: Pure code
.text$x:00002D30 ; Segment permissions: Read/Execute
.text$x:00002D30 _text$x         segment para public 'CODE' use32
.text$x:00002D30                 assume cs:_text$x
.text$x:00002D30                 ;org 2D30h
.text$x:00002D30 ; COMDAT (pick associative to section at 2CE0)
.text$x:00002D30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002D30
.text$x:00002D30 ; =============== S U B R O U T I N E =======================================
.text$x:00002D30
.text$x:00002D30
.text$x:00002D30 __unwindfunclet$??1RecentItem@@QAE@XZ$0 proc near
.text$x:00002D30                                         ; DATA XREF: .xdata$x:00006DF4o
.text$x:00002D30                 mov     ecx, [ebp-10h]
.text$x:00002D33                 add     ecx, 4
.text$x:00002D36                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002D36 __unwindfunclet$??1RecentItem@@QAE@XZ$0 endp
.text$x:00002D36
.text$x:00002D3B
.text$x:00002D3B ; =============== S U B R O U T I N E =======================================
.text$x:00002D3B
.text$x:00002D3B
.text$x:00002D3B __ehhandler$??1RecentItem@@QAE@XZ proc near
.text$x:00002D3B                                         ; DATA XREF: RecentItem::~RecentItem(void)+5o
.text$x:00002D3B
.text$x:00002D3B arg_4           = dword ptr  8
.text$x:00002D3B
.text$x:00002D3B                 mov     edx, [esp+arg_4]
.text$x:00002D3F                 lea     eax, [edx+0Ch]
.text$x:00002D42                 mov     ecx, [edx-8]
.text$x:00002D45                 xor     ecx, eax
.text$x:00002D47                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D4C                 mov     eax, offset __ehfuncinfo$??1RecentItem@@QAE@XZ
.text$x:00002D51                 jmp     ___CxxFrameHandler3
.text$x:00002D51 __ehhandler$??1RecentItem@@QAE@XZ endp
.text$x:00002D51
.text$x:00002D51 ; ---------------------------------------------------------------------------
.text$x:00002D56                 align 4
.text$x:00002D56 _text$x         ends
.text$x:00002D56
.text$mn:00002D58 ; ===========================================================================
.text$mn:00002D58
.text$mn:00002D58 ; Segment type: Pure code
.text$mn:00002D58 ; Segment permissions: Read/Execute
.text$mn:00002D58 _text$mn        segment para public 'CODE' use32
.text$mn:00002D58                 assume cs:_text$mn
.text$mn:00002D58                 ;org 2D58h
.text$mn:00002D58 ; COMDAT (pick any)
.text$mn:00002D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D58
.text$mn:00002D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D58
.text$mn:00002D58 ; Attributes: bp-based frame
.text$mn:00002D58
.text$mn:00002D58 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00002D58                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00002D58 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00002D58                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00002D58                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00002D58
.text$mn:00002D58 var_4           = dword ptr -4
.text$mn:00002D58
.text$mn:00002D58                 push    ebp
.text$mn:00002D59                 mov     ebp, esp
.text$mn:00002D5B                 push    ecx
.text$mn:00002D5C                 mov     [ebp+var_4], ecx
.text$mn:00002D5F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002D62                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00002D67                 mov     esp, ebp
.text$mn:00002D69                 pop     ebp
.text$mn:00002D6A                 retn
.text$mn:00002D6A ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00002D6A
.text$mn:00002D6A ; ---------------------------------------------------------------------------
.text$mn:00002D6B                 align 4
.text$mn:00002D6B _text$mn        ends
.text$mn:00002D6B
.text$mn:00002D6C ; ===========================================================================
.text$mn:00002D6C
.text$mn:00002D6C ; Segment type: Pure code
.text$mn:00002D6C ; Segment permissions: Read/Execute
.text$mn:00002D6C _text$mn        segment para public 'CODE' use32
.text$mn:00002D6C                 assume cs:_text$mn
.text$mn:00002D6C                 ;org 2D6Ch
.text$mn:00002D6C ; COMDAT (pick any)
.text$mn:00002D6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D6C
.text$mn:00002D6C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D6C
.text$mn:00002D6C ; Attributes: bp-based frame
.text$mn:00002D6C
.text$mn:00002D6C ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00002D6C                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00002D6C ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00002D6C                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00002D6C                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00002D6C
.text$mn:00002D6C var_10          = dword ptr -10h
.text$mn:00002D6C var_C           = dword ptr -0Ch
.text$mn:00002D6C var_4           = dword ptr -4
.text$mn:00002D6C
.text$mn:00002D6C                 push    ebp
.text$mn:00002D6D                 mov     ebp, esp
.text$mn:00002D6F                 push    0FFFFFFFFh
.text$mn:00002D71                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00002D76                 mov     eax, large fs:0
.text$mn:00002D7C                 push    eax
.text$mn:00002D7D                 push    ecx
.text$mn:00002D7E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002D83                 xor     eax, ebp
.text$mn:00002D85                 push    eax
.text$mn:00002D86                 lea     eax, [ebp+var_C]
.text$mn:00002D89                 mov     large fs:0, eax
.text$mn:00002D8F                 mov     [ebp+var_10], ecx
.text$mn:00002D92                 mov     [ebp+var_4], 0
.text$mn:00002D99                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002DA0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002DA3                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00002DA8                 mov     ecx, [ebp+var_C]
.text$mn:00002DAB                 mov     large fs:0, ecx
.text$mn:00002DB2                 pop     ecx
.text$mn:00002DB3                 mov     esp, ebp
.text$mn:00002DB5                 pop     ebp
.text$mn:00002DB6                 retn
.text$mn:00002DB6 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00002DB6
.text$mn:00002DB6 ; ---------------------------------------------------------------------------
.text$mn:00002DB7                 align 4
.text$mn:00002DB7 _text$mn        ends
.text$mn:00002DB7
.text$x:00002DB8 ; ===========================================================================
.text$x:00002DB8
.text$x:00002DB8 ; Segment type: Pure code
.text$x:00002DB8 ; Segment permissions: Read/Execute
.text$x:00002DB8 _text$x         segment para public 'CODE' use32
.text$x:00002DB8                 assume cs:_text$x
.text$x:00002DB8                 ;org 2DB8h
.text$x:00002DB8 ; COMDAT (pick associative to section at 2D6C)
.text$x:00002DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002DB8
.text$x:00002DB8 ; =============== S U B R O U T I N E =======================================
.text$x:00002DB8
.text$x:00002DB8
.text$x:00002DB8 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00002DB8                                         ; DATA XREF: .xdata$x:00006AD4o
.text$x:00002DB8                 mov     ecx, [ebp-10h]  ; this
.text$x:00002DBB                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00002DBB __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00002DBB
.text$x:00002DC0
.text$x:00002DC0 ; =============== S U B R O U T I N E =======================================
.text$x:00002DC0
.text$x:00002DC0
.text$x:00002DC0 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00002DC0                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00002DC0
.text$x:00002DC0 arg_4           = dword ptr  8
.text$x:00002DC0
.text$x:00002DC0                 mov     edx, [esp+arg_4]
.text$x:00002DC4                 lea     eax, [edx+0Ch]
.text$x:00002DC7                 mov     ecx, [edx-8]
.text$x:00002DCA                 xor     ecx, eax
.text$x:00002DCC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002DD1                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00002DD6                 jmp     ___CxxFrameHandler3
.text$x:00002DD6 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00002DD6
.text$x:00002DD6 ; ---------------------------------------------------------------------------
.text$x:00002DDB                 align 4
.text$x:00002DDB _text$x         ends
.text$x:00002DDB
.text$mn:00002DDC ; ===========================================================================
.text$mn:00002DDC
.text$mn:00002DDC ; Segment type: Pure code
.text$mn:00002DDC ; Segment permissions: Read/Execute
.text$mn:00002DDC _text$mn        segment para public 'CODE' use32
.text$mn:00002DDC                 assume cs:_text$mn
.text$mn:00002DDC                 ;org 2DDCh
.text$mn:00002DDC ; COMDAT (pick any)
.text$mn:00002DDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DDC
.text$mn:00002DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00002DDC
.text$mn:00002DDC ; Attributes: bp-based frame
.text$mn:00002DDC
.text$mn:00002DDC ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00002DDC                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00002DDC ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00002DDC                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00002DDC                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00002DDC
.text$mn:00002DDC var_10          = dword ptr -10h
.text$mn:00002DDC var_C           = dword ptr -0Ch
.text$mn:00002DDC var_4           = dword ptr -4
.text$mn:00002DDC
.text$mn:00002DDC                 push    ebp
.text$mn:00002DDD                 mov     ebp, esp
.text$mn:00002DDF                 push    0FFFFFFFFh
.text$mn:00002DE1                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00002DE6                 mov     eax, large fs:0
.text$mn:00002DEC                 push    eax
.text$mn:00002DED                 push    ecx
.text$mn:00002DEE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002DF3                 xor     eax, ebp
.text$mn:00002DF5                 push    eax
.text$mn:00002DF6                 lea     eax, [ebp+var_C]
.text$mn:00002DF9                 mov     large fs:0, eax
.text$mn:00002DFF                 mov     [ebp+var_10], ecx
.text$mn:00002E02                 mov     [ebp+var_4], 0
.text$mn:00002E09                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002E10                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002E13                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00002E18                 mov     ecx, [ebp+var_C]
.text$mn:00002E1B                 mov     large fs:0, ecx
.text$mn:00002E22                 pop     ecx
.text$mn:00002E23                 mov     esp, ebp
.text$mn:00002E25                 pop     ebp
.text$mn:00002E26                 retn
.text$mn:00002E26 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00002E26
.text$mn:00002E26 ; ---------------------------------------------------------------------------
.text$mn:00002E27                 align 4
.text$mn:00002E27 _text$mn        ends
.text$mn:00002E27
.text$x:00002E28 ; ===========================================================================
.text$x:00002E28
.text$x:00002E28 ; Segment type: Pure code
.text$x:00002E28 ; Segment permissions: Read/Execute
.text$x:00002E28 _text$x         segment para public 'CODE' use32
.text$x:00002E28                 assume cs:_text$x
.text$x:00002E28                 ;org 2E28h
.text$x:00002E28 ; COMDAT (pick associative to section at 2DDC)
.text$x:00002E28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002E28
.text$x:00002E28 ; =============== S U B R O U T I N E =======================================
.text$x:00002E28
.text$x:00002E28
.text$x:00002E28 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00002E28                                         ; DATA XREF: .xdata$x:00006B58o
.text$x:00002E28                 mov     ecx, [ebp-10h]  ; this
.text$x:00002E2B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00002E2B __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00002E2B
.text$x:00002E30
.text$x:00002E30 ; =============== S U B R O U T I N E =======================================
.text$x:00002E30
.text$x:00002E30
.text$x:00002E30 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00002E30                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00002E30
.text$x:00002E30 arg_4           = dword ptr  8
.text$x:00002E30
.text$x:00002E30                 mov     edx, [esp+arg_4]
.text$x:00002E34                 lea     eax, [edx+0Ch]
.text$x:00002E37                 mov     ecx, [edx-8]
.text$x:00002E3A                 xor     ecx, eax
.text$x:00002E3C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002E41                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00002E46                 jmp     ___CxxFrameHandler3
.text$x:00002E46 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00002E46
.text$x:00002E46 ; ---------------------------------------------------------------------------
.text$x:00002E4B                 align 4
.text$x:00002E4B _text$x         ends
.text$x:00002E4B
.text$mn:00002E4C ; ===========================================================================
.text$mn:00002E4C
.text$mn:00002E4C ; Segment type: Pure code
.text$mn:00002E4C ; Segment permissions: Read/Execute
.text$mn:00002E4C _text$mn        segment para public 'CODE' use32
.text$mn:00002E4C                 assume cs:_text$mn
.text$mn:00002E4C                 ;org 2E4Ch
.text$mn:00002E4C ; COMDAT (pick any)
.text$mn:00002E4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E4C
.text$mn:00002E4C ; =============== S U B R O U T I N E =======================================
.text$mn:00002E4C
.text$mn:00002E4C ; Attributes: bp-based frame
.text$mn:00002E4C
.text$mn:00002E4C ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00002E4C                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:00002E4C ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00002E4C                                         ; CODE XREF: __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00002E4C                                         ; __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0+3j ...
.text$mn:00002E4C
.text$mn:00002E4C var_14          = byte ptr -14h
.text$mn:00002E4C var_10          = dword ptr -10h
.text$mn:00002E4C var_C           = dword ptr -0Ch
.text$mn:00002E4C var_4           = dword ptr -4
.text$mn:00002E4C
.text$mn:00002E4C                 push    ebp
.text$mn:00002E4D                 mov     ebp, esp
.text$mn:00002E4F                 push    0FFFFFFFFh
.text$mn:00002E51                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:00002E56                 mov     eax, large fs:0
.text$mn:00002E5C                 push    eax
.text$mn:00002E5D                 sub     esp, 8
.text$mn:00002E60                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002E65                 xor     eax, ebp
.text$mn:00002E67                 push    eax
.text$mn:00002E68                 lea     eax, [ebp+var_C]
.text$mn:00002E6B                 mov     large fs:0, eax
.text$mn:00002E71                 mov     [ebp+var_10], ecx
.text$mn:00002E74                 push    3               ; int
.text$mn:00002E76                 lea     ecx, [ebp+var_14] ; this
.text$mn:00002E79                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00002E7E                 mov     [ebp+var_4], 0
.text$mn:00002E85                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002E88                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00002E8D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002E94                 lea     ecx, [ebp+var_14] ; this
.text$mn:00002E97                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00002E9C                 mov     ecx, [ebp+var_C]
.text$mn:00002E9F                 mov     large fs:0, ecx
.text$mn:00002EA6                 pop     ecx
.text$mn:00002EA7                 mov     esp, ebp
.text$mn:00002EA9                 pop     ebp
.text$mn:00002EAA                 retn
.text$mn:00002EAA ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:00002EAA
.text$mn:00002EAA ; ---------------------------------------------------------------------------
.text$mn:00002EAB                 align 4
.text$mn:00002EAB _text$mn        ends
.text$mn:00002EAB
.text$x:00002EAC ; ===========================================================================
.text$x:00002EAC
.text$x:00002EAC ; Segment type: Pure code
.text$x:00002EAC ; Segment permissions: Read/Execute
.text$x:00002EAC _text$x         segment para public 'CODE' use32
.text$x:00002EAC                 assume cs:_text$x
.text$x:00002EAC                 ;org 2EACh
.text$x:00002EAC ; COMDAT (pick associative to section at 2E4C)
.text$x:00002EAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002EAC
.text$x:00002EAC ; =============== S U B R O U T I N E =======================================
.text$x:00002EAC
.text$x:00002EAC
.text$x:00002EAC __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:00002EAC                                         ; DATA XREF: .xdata$x:00006888o
.text$x:00002EAC                 lea     ecx, [ebp-14h]  ; this
.text$x:00002EAF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00002EAF __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:00002EAF
.text$x:00002EB4
.text$x:00002EB4 ; =============== S U B R O U T I N E =======================================
.text$x:00002EB4
.text$x:00002EB4
.text$x:00002EB4 __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:00002EB4                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:00002EB4
.text$x:00002EB4 arg_4           = dword ptr  8
.text$x:00002EB4
.text$x:00002EB4                 mov     edx, [esp+arg_4]
.text$x:00002EB8                 lea     eax, [edx+0Ch]
.text$x:00002EBB                 mov     ecx, [edx-0Ch]
.text$x:00002EBE                 xor     ecx, eax
.text$x:00002EC0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002EC5                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:00002ECA                 jmp     ___CxxFrameHandler3
.text$x:00002ECA __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:00002ECA
.text$x:00002ECA ; ---------------------------------------------------------------------------
.text$x:00002ECF                 align 10h
.text$x:00002ECF _text$x         ends
.text$x:00002ECF
.text$mn:00002ED0 ; ===========================================================================
.text$mn:00002ED0
.text$mn:00002ED0 ; Segment type: Pure code
.text$mn:00002ED0 ; Segment permissions: Read/Execute
.text$mn:00002ED0 _text$mn        segment para public 'CODE' use32
.text$mn:00002ED0                 assume cs:_text$mn
.text$mn:00002ED0                 ;org 2ED0h
.text$mn:00002ED0 ; COMDAT (pick any)
.text$mn:00002ED0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002ED0
.text$mn:00002ED0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002ED0
.text$mn:00002ED0 ; Attributes: bp-based frame
.text$mn:00002ED0
.text$mn:00002ED0 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00002ED0                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00002ED0 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00002ED0                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00002ED0                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00002ED0
.text$mn:00002ED0 var_10          = dword ptr -10h
.text$mn:00002ED0 var_C           = dword ptr -0Ch
.text$mn:00002ED0 var_4           = dword ptr -4
.text$mn:00002ED0
.text$mn:00002ED0                 push    ebp
.text$mn:00002ED1                 mov     ebp, esp
.text$mn:00002ED3                 push    0FFFFFFFFh
.text$mn:00002ED5                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00002EDA                 mov     eax, large fs:0
.text$mn:00002EE0                 push    eax
.text$mn:00002EE1                 push    ecx
.text$mn:00002EE2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002EE7                 xor     eax, ebp
.text$mn:00002EE9                 push    eax
.text$mn:00002EEA                 lea     eax, [ebp+var_C]
.text$mn:00002EED                 mov     large fs:0, eax
.text$mn:00002EF3                 mov     [ebp+var_10], ecx
.text$mn:00002EF6                 mov     [ebp+var_4], 0
.text$mn:00002EFD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002F04                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002F07                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00002F0C                 mov     ecx, [ebp+var_C]
.text$mn:00002F0F                 mov     large fs:0, ecx
.text$mn:00002F16                 pop     ecx
.text$mn:00002F17                 mov     esp, ebp
.text$mn:00002F19                 pop     ebp
.text$mn:00002F1A                 retn
.text$mn:00002F1A ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00002F1A
.text$mn:00002F1A ; ---------------------------------------------------------------------------
.text$mn:00002F1B                 align 4
.text$mn:00002F1B _text$mn        ends
.text$mn:00002F1B
.text$x:00002F1C ; ===========================================================================
.text$x:00002F1C
.text$x:00002F1C ; Segment type: Pure code
.text$x:00002F1C ; Segment permissions: Read/Execute
.text$x:00002F1C _text$x         segment para public 'CODE' use32
.text$x:00002F1C                 assume cs:_text$x
.text$x:00002F1C                 ;org 2F1Ch
.text$x:00002F1C ; COMDAT (pick associative to section at 2ED0)
.text$x:00002F1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002F1C
.text$x:00002F1C ; =============== S U B R O U T I N E =======================================
.text$x:00002F1C
.text$x:00002F1C
.text$x:00002F1C __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00002F1C                                         ; DATA XREF: .xdata$x:00006BDCo
.text$x:00002F1C                 mov     ecx, [ebp-10h]  ; this
.text$x:00002F1F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00002F1F __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00002F1F
.text$x:00002F24
.text$x:00002F24 ; =============== S U B R O U T I N E =======================================
.text$x:00002F24
.text$x:00002F24
.text$x:00002F24 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00002F24                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00002F24
.text$x:00002F24 arg_4           = dword ptr  8
.text$x:00002F24
.text$x:00002F24                 mov     edx, [esp+arg_4]
.text$x:00002F28                 lea     eax, [edx+0Ch]
.text$x:00002F2B                 mov     ecx, [edx-8]
.text$x:00002F2E                 xor     ecx, eax
.text$x:00002F30                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F35                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00002F3A                 jmp     ___CxxFrameHandler3
.text$x:00002F3A __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00002F3A
.text$x:00002F3A ; ---------------------------------------------------------------------------
.text$x:00002F3F                 align 10h
.text$x:00002F3F _text$x         ends
.text$x:00002F3F
.text$mn:00002F40 ; ===========================================================================
.text$mn:00002F40
.text$mn:00002F40 ; Segment type: Pure code
.text$mn:00002F40 ; Segment permissions: Read/Execute
.text$mn:00002F40 _text$mn        segment para public 'CODE' use32
.text$mn:00002F40                 assume cs:_text$mn
.text$mn:00002F40                 ;org 2F40h
.text$mn:00002F40 ; COMDAT (pick any)
.text$mn:00002F40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F40
.text$mn:00002F40 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F40
.text$mn:00002F40 ; Attributes: bp-based frame
.text$mn:00002F40
.text$mn:00002F40 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00002F40                 public ??1error_category@std@@UAE@XZ
.text$mn:00002F40 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00002F40                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00002F40
.text$mn:00002F40 var_4           = dword ptr -4
.text$mn:00002F40
.text$mn:00002F40                 push    ebp
.text$mn:00002F41                 mov     ebp, esp
.text$mn:00002F43                 push    ecx
.text$mn:00002F44                 mov     [ebp+var_4], ecx
.text$mn:00002F47                 mov     eax, [ebp+var_4]
.text$mn:00002F4A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00002F50                 mov     esp, ebp
.text$mn:00002F52                 pop     ebp
.text$mn:00002F53                 retn
.text$mn:00002F53 ??1error_category@std@@UAE@XZ endp
.text$mn:00002F53
.text$mn:00002F53 _text$mn        ends
.text$mn:00002F53
.text$mn:00002F54 ; ===========================================================================
.text$mn:00002F54
.text$mn:00002F54 ; Segment type: Pure code
.text$mn:00002F54 ; Segment permissions: Read/Execute
.text$mn:00002F54 _text$mn        segment para public 'CODE' use32
.text$mn:00002F54                 assume cs:_text$mn
.text$mn:00002F54                 ;org 2F54h
.text$mn:00002F54 ; COMDAT (pick any)
.text$mn:00002F54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F54
.text$mn:00002F54 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F54
.text$mn:00002F54 ; Attributes: bp-based frame
.text$mn:00002F54
.text$mn:00002F54 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00002F54                 public ??2@YAPAXIPAX@Z
.text$mn:00002F54 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00002F54                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+2Ep ...
.text$mn:00002F54
.text$mn:00002F54 arg_4           = dword ptr  0Ch
.text$mn:00002F54
.text$mn:00002F54                 push    ebp
.text$mn:00002F55                 mov     ebp, esp
.text$mn:00002F57                 mov     eax, [ebp+arg_4]
.text$mn:00002F5A                 pop     ebp
.text$mn:00002F5B                 retn
.text$mn:00002F5B ??2@YAPAXIPAX@Z endp
.text$mn:00002F5B
.text$mn:00002F5B _text$mn        ends
.text$mn:00002F5B
.text$mn:00002F5C ; ===========================================================================
.text$mn:00002F5C
.text$mn:00002F5C ; Segment type: Pure code
.text$mn:00002F5C ; Segment permissions: Read/Execute
.text$mn:00002F5C _text$mn        segment para public 'CODE' use32
.text$mn:00002F5C                 assume cs:_text$mn
.text$mn:00002F5C                 ;org 2F5Ch
.text$mn:00002F5C ; COMDAT (pick any)
.text$mn:00002F5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F5C
.text$mn:00002F5C ; =============== S U B R O U T I N E =======================================
.text$mn:00002F5C
.text$mn:00002F5C ; Attributes: bp-based frame
.text$mn:00002F5C
.text$mn:00002F5C ; void __cdecl operator delete(void *)
.text$mn:00002F5C                 public ??3@YAXPAX0@Z
.text$mn:00002F5C ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00002F5C                                         ; __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0+8p ...
.text$mn:00002F5C                 push    ebp
.text$mn:00002F5D                 mov     ebp, esp
.text$mn:00002F5F                 pop     ebp
.text$mn:00002F60                 retn
.text$mn:00002F60 ??3@YAXPAX0@Z   endp
.text$mn:00002F60
.text$mn:00002F60 ; ---------------------------------------------------------------------------
.text$mn:00002F61                 align 4
.text$mn:00002F61 _text$mn        ends
.text$mn:00002F61
.text$mn:00002F64 ; ===========================================================================
.text$mn:00002F64
.text$mn:00002F64 ; Segment type: Pure code
.text$mn:00002F64 ; Segment permissions: Read/Execute
.text$mn:00002F64 _text$mn        segment para public 'CODE' use32
.text$mn:00002F64                 assume cs:_text$mn
.text$mn:00002F64                 ;org 2F64h
.text$mn:00002F64 ; COMDAT (pick any)
.text$mn:00002F64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F64
.text$mn:00002F64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F64
.text$mn:00002F64 ; Attributes: bp-based frame
.text$mn:00002F64
.text$mn:00002F64 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator=(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00002F64                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
.text$mn:00002F64 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:00002F64                                         ; CODE XREF: RecentItem::operator=(RecentItem const &)+1Ep
.text$mn:00002F64
.text$mn:00002F64 var_8           = dword ptr -8
.text$mn:00002F64 var_3           = byte ptr -3
.text$mn:00002F64 var_2           = byte ptr -2
.text$mn:00002F64 var_1           = byte ptr -1
.text$mn:00002F64 arg_0           = dword ptr  8
.text$mn:00002F64
.text$mn:00002F64                 push    ebp
.text$mn:00002F65                 mov     ebp, esp
.text$mn:00002F67                 sub     esp, 8
.text$mn:00002F6A                 mov     [ebp+var_8], ecx
.text$mn:00002F6D                 mov     eax, [ebp+var_8]
.text$mn:00002F70                 cmp     eax, [ebp+arg_0]
.text$mn:00002F73                 jz      short loc_2FCF
.text$mn:00002F75                 lea     ecx, [ebp+var_1]
.text$mn:00002F78                 push    ecx
.text$mn:00002F79                 mov     ecx, [ebp+arg_0]
.text$mn:00002F7C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002F81                 push    eax
.text$mn:00002F82                 lea     edx, [ebp+var_2]
.text$mn:00002F85                 push    edx
.text$mn:00002F86                 mov     ecx, [ebp+var_8]
.text$mn:00002F89                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002F8E                 push    eax
.text$mn:00002F8F                 call    ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00002F94                 add     esp, 8
.text$mn:00002F97                 movzx   eax, al
.text$mn:00002F9A                 test    eax, eax
.text$mn:00002F9C                 jz      short loc_2FC3
.text$mn:00002F9E                 xor     ecx, ecx
.text$mn:00002FA0                 jz      short loc_2FC3
.text$mn:00002FA2                 push    0
.text$mn:00002FA4                 push    1
.text$mn:00002FA6                 mov     ecx, [ebp+var_8]
.text$mn:00002FA9                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00002FAE                 lea     edx, [ebp+var_3]
.text$mn:00002FB1                 push    edx
.text$mn:00002FB2                 mov     ecx, [ebp+arg_0]
.text$mn:00002FB5                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002FBA                 push    eax
.text$mn:00002FBB                 mov     ecx, [ebp+var_8]
.text$mn:00002FBE                 call    ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Change_alloc(std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00002FC3
.text$mn:00002FC3 loc_2FC3:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+38j
.text$mn:00002FC3                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Cj
.text$mn:00002FC3                 mov     eax, [ebp+arg_0]
.text$mn:00002FC6                 push    eax
.text$mn:00002FC7                 mov     ecx, [ebp+var_8]
.text$mn:00002FCA                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00002FCF
.text$mn:00002FCF loc_2FCF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+Fj
.text$mn:00002FCF                 mov     eax, [ebp+var_8]
.text$mn:00002FD2                 mov     esp, ebp
.text$mn:00002FD4                 pop     ebp
.text$mn:00002FD5                 retn    4
.text$mn:00002FD5 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:00002FD5
.text$mn:00002FD5 _text$mn        ends
.text$mn:00002FD5
.text$mn:00002FD8 ; ===========================================================================
.text$mn:00002FD8
.text$mn:00002FD8 ; Segment type: Pure code
.text$mn:00002FD8 ; Segment permissions: Read/Execute
.text$mn:00002FD8 _text$mn        segment para public 'CODE' use32
.text$mn:00002FD8                 assume cs:_text$mn
.text$mn:00002FD8                 ;org 2FD8h
.text$mn:00002FD8 ; COMDAT (pick any)
.text$mn:00002FD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FD8
.text$mn:00002FD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FD8
.text$mn:00002FD8 ; Attributes: bp-based frame
.text$mn:00002FD8
.text$mn:00002FD8 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t *Str)
.text$mn:00002FD8                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:00002FD8 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:00002FD8                                         ; CODE XREF: LastRecentFileList::updateMenu(void)+F2p
.text$mn:00002FD8                                         ; LastRecentFileList::updateMenu(void)+117p ...
.text$mn:00002FD8
.text$mn:00002FD8 var_4           = dword ptr -4
.text$mn:00002FD8 Str             = dword ptr  8
.text$mn:00002FD8
.text$mn:00002FD8                 push    ebp
.text$mn:00002FD9                 mov     ebp, esp
.text$mn:00002FDB                 push    ecx
.text$mn:00002FDC                 mov     [ebp+var_4], ecx
.text$mn:00002FDF                 mov     eax, [ebp+Str]
.text$mn:00002FE2                 push    eax             ; Str
.text$mn:00002FE3                 mov     ecx, [ebp+var_4]
.text$mn:00002FE6                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00002FEB                 mov     esp, ebp
.text$mn:00002FED                 pop     ebp
.text$mn:00002FEE                 retn    4
.text$mn:00002FEE ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:00002FEE
.text$mn:00002FEE ; ---------------------------------------------------------------------------
.text$mn:00002FF1                 align 4
.text$mn:00002FF1 _text$mn        ends
.text$mn:00002FF1
.text$mn:00002FF4 ; ===========================================================================
.text$mn:00002FF4
.text$mn:00002FF4 ; Segment type: Pure code
.text$mn:00002FF4 ; Segment permissions: Read/Execute
.text$mn:00002FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00002FF4                 assume cs:_text$mn
.text$mn:00002FF4                 ;org 2FF4h
.text$mn:00002FF4 ; COMDAT (pick any)
.text$mn:00002FF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FF4
.text$mn:00002FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FF4
.text$mn:00002FF4 ; Attributes: bp-based frame
.text$mn:00002FF4
.text$mn:00002FF4 ; public: struct RecentItem & __thiscall RecentItem::operator=(struct RecentItem const &)
.text$mn:00002FF4                 public ??4RecentItem@@QAEAAU0@ABU0@@Z
.text$mn:00002FF4 ??4RecentItem@@QAEAAU0@ABU0@@Z proc near
.text$mn:00002FF4                                         ; CODE XREF: std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+72p
.text$mn:00002FF4                                         ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+6Ep
.text$mn:00002FF4
.text$mn:00002FF4 var_4           = dword ptr -4
.text$mn:00002FF4 arg_0           = dword ptr  8
.text$mn:00002FF4
.text$mn:00002FF4                 push    ebp
.text$mn:00002FF5                 mov     ebp, esp
.text$mn:00002FF7                 push    ecx
.text$mn:00002FF8                 mov     [ebp+var_4], ecx
.text$mn:00002FFB                 mov     eax, [ebp+var_4]
.text$mn:00002FFE                 mov     ecx, [ebp+arg_0]
.text$mn:00003001                 mov     edx, [ecx]
.text$mn:00003003                 mov     [eax], edx
.text$mn:00003005                 mov     eax, [ebp+arg_0]
.text$mn:00003008                 add     eax, 4
.text$mn:0000300B                 push    eax
.text$mn:0000300C                 mov     ecx, [ebp+var_4]
.text$mn:0000300F                 add     ecx, 4
.text$mn:00003012                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00003017                 mov     eax, [ebp+var_4]
.text$mn:0000301A                 mov     esp, ebp
.text$mn:0000301C                 pop     ebp
.text$mn:0000301D                 retn    4
.text$mn:0000301D ??4RecentItem@@QAEAAU0@ABU0@@Z endp
.text$mn:0000301D
.text$mn:0000301D _text$mn        ends
.text$mn:0000301D
.text$mn:00003020 ; ===========================================================================
.text$mn:00003020
.text$mn:00003020 ; Segment type: Pure code
.text$mn:00003020 ; Segment permissions: Read/Execute
.text$mn:00003020 _text$mn        segment para public 'CODE' use32
.text$mn:00003020                 assume cs:_text$mn
.text$mn:00003020                 ;org 3020h
.text$mn:00003020 ; COMDAT (pick any)
.text$mn:00003020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003020
.text$mn:00003020 ; =============== S U B R O U T I N E =======================================
.text$mn:00003020
.text$mn:00003020 ; Attributes: bp-based frame
.text$mn:00003020
.text$mn:00003020 ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:00003020                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00003020 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:00003020                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:00003020
.text$mn:00003020 var_14          = byte ptr -14h
.text$mn:00003020 var_10          = dword ptr -10h
.text$mn:00003020 var_C           = dword ptr -0Ch
.text$mn:00003020 var_4           = dword ptr -4
.text$mn:00003020 arg_0           = dword ptr  8
.text$mn:00003020
.text$mn:00003020                 push    ebp
.text$mn:00003021                 mov     ebp, esp
.text$mn:00003023                 push    0FFFFFFFFh
.text$mn:00003025                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:0000302A                 mov     eax, large fs:0
.text$mn:00003030                 push    eax
.text$mn:00003031                 sub     esp, 8
.text$mn:00003034                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003039                 xor     eax, ebp
.text$mn:0000303B                 push    eax
.text$mn:0000303C                 lea     eax, [ebp+var_C]
.text$mn:0000303F                 mov     large fs:0, eax
.text$mn:00003045                 mov     [ebp+var_10], ecx
.text$mn:00003048                 mov     eax, [ebp+var_10]
.text$mn:0000304B                 mov     ecx, [ebp+arg_0]
.text$mn:0000304E                 mov     edx, [eax]
.text$mn:00003050                 cmp     edx, [ecx]
.text$mn:00003052                 jnz     short loc_3056
.text$mn:00003054                 jmp     short loc_3098
.text$mn:00003056 ; ---------------------------------------------------------------------------
.text$mn:00003056
.text$mn:00003056 loc_3056:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:00003056                 mov     eax, [ebp+arg_0]
.text$mn:00003059                 cmp     dword ptr [eax], 0
.text$mn:0000305C                 jz      short loc_3070
.text$mn:0000305E                 mov     ecx, [ebp+arg_0]
.text$mn:00003061                 mov     edx, [ecx]
.text$mn:00003063                 mov     eax, [edx]
.text$mn:00003065                 push    eax             ; struct std::_Container_base12 *
.text$mn:00003066                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003069                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:0000306E                 jmp     short loc_3098
.text$mn:00003070 ; ---------------------------------------------------------------------------
.text$mn:00003070
.text$mn:00003070 loc_3070:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:00003070                 push    3               ; int
.text$mn:00003072                 lea     ecx, [ebp+var_14] ; this
.text$mn:00003075                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000307A                 mov     [ebp+var_4], 0
.text$mn:00003081                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003084                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00003089                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003090                 lea     ecx, [ebp+var_14] ; this
.text$mn:00003093                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00003098
.text$mn:00003098 loc_3098:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:00003098                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:00003098                 mov     eax, [ebp+var_10]
.text$mn:0000309B                 mov     ecx, [ebp+var_C]
.text$mn:0000309E                 mov     large fs:0, ecx
.text$mn:000030A5                 pop     ecx
.text$mn:000030A6                 mov     esp, ebp
.text$mn:000030A8                 pop     ebp
.text$mn:000030A9                 retn    4
.text$mn:000030A9 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:000030A9
.text$mn:000030A9 _text$mn        ends
.text$mn:000030A9
.text$x:000030AC ; ===========================================================================
.text$x:000030AC
.text$x:000030AC ; Segment type: Pure code
.text$x:000030AC ; Segment permissions: Read/Execute
.text$x:000030AC _text$x         segment para public 'CODE' use32
.text$x:000030AC                 assume cs:_text$x
.text$x:000030AC                 ;org 30ACh
.text$x:000030AC ; COMDAT (pick associative to section at 3020)
.text$x:000030AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000030AC
.text$x:000030AC ; =============== S U B R O U T I N E =======================================
.text$x:000030AC
.text$x:000030AC
.text$x:000030AC __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:000030AC                                         ; DATA XREF: .xdata$x:0000685Co
.text$x:000030AC                 lea     ecx, [ebp-14h]  ; this
.text$x:000030AF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000030AF __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:000030AF
.text$x:000030B4
.text$x:000030B4 ; =============== S U B R O U T I N E =======================================
.text$x:000030B4
.text$x:000030B4
.text$x:000030B4 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:000030B4                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:000030B4
.text$x:000030B4 arg_4           = dword ptr  8
.text$x:000030B4
.text$x:000030B4                 mov     edx, [esp+arg_4]
.text$x:000030B8                 lea     eax, [edx+0Ch]
.text$x:000030BB                 mov     ecx, [edx-0Ch]
.text$x:000030BE                 xor     ecx, eax
.text$x:000030C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000030C5                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:000030CA                 jmp     ___CxxFrameHandler3
.text$x:000030CA __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:000030CA
.text$x:000030CA ; ---------------------------------------------------------------------------
.text$x:000030CF                 align 10h
.text$x:000030CF _text$x         ends
.text$x:000030CF
.text$mn:000030D0 ; ===========================================================================
.text$mn:000030D0
.text$mn:000030D0 ; Segment type: Pure code
.text$mn:000030D0 ; Segment permissions: Read/Execute
.text$mn:000030D0 _text$mn        segment para public 'CODE' use32
.text$mn:000030D0                 assume cs:_text$mn
.text$mn:000030D0                 ;org 30D0h
.text$mn:000030D0 ; COMDAT (pick any)
.text$mn:000030D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030D0
.text$mn:000030D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000030D0
.text$mn:000030D0 ; Attributes: bp-based frame
.text$mn:000030D0
.text$mn:000030D0 ; int __stdcall std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator==(std::_Iterator_base12 *)
.text$mn:000030D0                 public ??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:000030D0 ??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:000030D0                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator!=(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+10p
.text$mn:000030D0
.text$mn:000030D0 var_8           = dword ptr -8
.text$mn:000030D0 var_4           = dword ptr -4
.text$mn:000030D0 arg_0           = dword ptr  8
.text$mn:000030D0
.text$mn:000030D0                 push    ebp
.text$mn:000030D1                 mov     ebp, esp
.text$mn:000030D3                 sub     esp, 8
.text$mn:000030D6                 mov     [ebp+var_4], ecx
.text$mn:000030D9                 mov     eax, [ebp+arg_0]
.text$mn:000030DC                 push    eax             ; std::_Iterator_base12 *
.text$mn:000030DD                 mov     ecx, [ebp+var_4]
.text$mn:000030E0                 call    ?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Compat(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:000030E5                 mov     ecx, [ebp+var_4]
.text$mn:000030E8                 mov     edx, [ebp+arg_0]
.text$mn:000030EB                 mov     eax, [ecx+8]
.text$mn:000030EE                 cmp     eax, [edx+8]
.text$mn:000030F1                 jnz     short loc_30FC
.text$mn:000030F3                 mov     [ebp+var_8], 1
.text$mn:000030FA                 jmp     short loc_3103
.text$mn:000030FC ; ---------------------------------------------------------------------------
.text$mn:000030FC
.text$mn:000030FC loc_30FC:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator==(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+21j
.text$mn:000030FC                 mov     [ebp+var_8], 0
.text$mn:00003103
.text$mn:00003103 loc_3103:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator==(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+2Aj
.text$mn:00003103                 mov     al, byte ptr [ebp+var_8]
.text$mn:00003106                 mov     esp, ebp
.text$mn:00003108                 pop     ebp
.text$mn:00003109                 retn    4
.text$mn:00003109 ??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:00003109
.text$mn:00003109 _text$mn        ends
.text$mn:00003109
.text$mn:0000310C ; ===========================================================================
.text$mn:0000310C
.text$mn:0000310C ; Segment type: Pure code
.text$mn:0000310C ; Segment permissions: Read/Execute
.text$mn:0000310C _text$mn        segment para public 'CODE' use32
.text$mn:0000310C                 assume cs:_text$mn
.text$mn:0000310C                 ;org 310Ch
.text$mn:0000310C ; COMDAT (pick any)
.text$mn:0000310C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000310C
.text$mn:0000310C ; =============== S U B R O U T I N E =======================================
.text$mn:0000310C
.text$mn:0000310C ; Attributes: bp-based frame
.text$mn:0000310C
.text$mn:0000310C ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:0000310C                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:0000310C ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:0000310C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:0000310C                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:0000310C
.text$mn:0000310C var_8           = dword ptr -8
.text$mn:0000310C var_4           = dword ptr -4
.text$mn:0000310C arg_0           = dword ptr  8
.text$mn:0000310C
.text$mn:0000310C                 push    ebp
.text$mn:0000310D                 mov     ebp, esp
.text$mn:0000310F                 sub     esp, 8
.text$mn:00003112                 mov     [ebp+var_8], ecx
.text$mn:00003115                 mov     eax, [ebp+var_8]
.text$mn:00003118                 cmp     eax, [ebp+arg_0]
.text$mn:0000311B                 jnz     short loc_3126
.text$mn:0000311D                 mov     [ebp+var_4], 1
.text$mn:00003124                 jmp     short loc_312D
.text$mn:00003126 ; ---------------------------------------------------------------------------
.text$mn:00003126
.text$mn:00003126 loc_3126:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00003126                 mov     [ebp+var_4], 0
.text$mn:0000312D
.text$mn:0000312D loc_312D:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:0000312D                 mov     al, byte ptr [ebp+var_4]
.text$mn:00003130                 mov     esp, ebp
.text$mn:00003132                 pop     ebp
.text$mn:00003133                 retn    4
.text$mn:00003133 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00003133
.text$mn:00003133 ; ---------------------------------------------------------------------------
.text$mn:00003136                 align 4
.text$mn:00003136 _text$mn        ends
.text$mn:00003136
.text$mn:00003138 ; ===========================================================================
.text$mn:00003138
.text$mn:00003138 ; Segment type: Pure code
.text$mn:00003138 ; Segment permissions: Read/Execute
.text$mn:00003138 _text$mn        segment para public 'CODE' use32
.text$mn:00003138                 assume cs:_text$mn
.text$mn:00003138                 ;org 3138h
.text$mn:00003138 ; COMDAT (pick any)
.text$mn:00003138                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003138
.text$mn:00003138 ; =============== S U B R O U T I N E =======================================
.text$mn:00003138
.text$mn:00003138 ; Attributes: bp-based frame
.text$mn:00003138
.text$mn:00003138 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00003138                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00003138 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00003138                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00003138
.text$mn:00003138 var_8           = dword ptr -8
.text$mn:00003138 var_4           = dword ptr -4
.text$mn:00003138 arg_0           = dword ptr  8
.text$mn:00003138
.text$mn:00003138                 push    ebp
.text$mn:00003139                 mov     ebp, esp
.text$mn:0000313B                 sub     esp, 8
.text$mn:0000313E                 push    esi
.text$mn:0000313F                 mov     [ebp+var_4], ecx
.text$mn:00003142                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003145                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000314A                 push    eax
.text$mn:0000314B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000314E                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00003153                 mov     ecx, eax
.text$mn:00003155                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000315A                 movzx   eax, al
.text$mn:0000315D                 test    eax, eax
.text$mn:0000315F                 jz      short loc_3180
.text$mn:00003161                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003164                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00003169                 mov     esi, eax
.text$mn:0000316B                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000316E                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00003173                 cmp     esi, eax
.text$mn:00003175                 jnz     short loc_3180
.text$mn:00003177                 mov     [ebp+var_8], 1
.text$mn:0000317E                 jmp     short loc_3187
.text$mn:00003180 ; ---------------------------------------------------------------------------
.text$mn:00003180
.text$mn:00003180 loc_3180:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00003180                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00003180                 mov     [ebp+var_8], 0
.text$mn:00003187
.text$mn:00003187 loc_3187:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00003187                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000318A                 pop     esi
.text$mn:0000318B                 mov     esp, ebp
.text$mn:0000318D                 pop     ebp
.text$mn:0000318E                 retn    4
.text$mn:0000318E ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:0000318E
.text$mn:0000318E ; ---------------------------------------------------------------------------
.text$mn:00003191                 align 4
.text$mn:00003191 _text$mn        ends
.text$mn:00003191
.text$mn:00003194 ; ===========================================================================
.text$mn:00003194
.text$mn:00003194 ; Segment type: Pure code
.text$mn:00003194 ; Segment permissions: Read/Execute
.text$mn:00003194 _text$mn        segment para public 'CODE' use32
.text$mn:00003194                 assume cs:_text$mn
.text$mn:00003194                 ;org 3194h
.text$mn:00003194 ; COMDAT (pick any)
.text$mn:00003194                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003194
.text$mn:00003194 ; =============== S U B R O U T I N E =======================================
.text$mn:00003194
.text$mn:00003194 ; Attributes: bp-based frame
.text$mn:00003194
.text$mn:00003194 ; int __stdcall std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator!=(std::_Iterator_base12 *)
.text$mn:00003194                 public ??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00003194 ??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00003194                                         ; CODE XREF: std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,wchar_t const *,uint,std::random_access_iterator_tag)+30p
.text$mn:00003194                                         ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+4Ap ...
.text$mn:00003194
.text$mn:00003194 var_8           = dword ptr -8
.text$mn:00003194 var_4           = dword ptr -4
.text$mn:00003194 arg_0           = dword ptr  8
.text$mn:00003194
.text$mn:00003194                 push    ebp
.text$mn:00003195                 mov     ebp, esp
.text$mn:00003197                 sub     esp, 8
.text$mn:0000319A                 mov     [ebp+var_8], ecx
.text$mn:0000319D                 mov     eax, [ebp+arg_0]
.text$mn:000031A0                 push    eax             ; std::_Iterator_base12 *
.text$mn:000031A1                 mov     ecx, [ebp+var_8]
.text$mn:000031A4                 call    ??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator==(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:000031A9                 movzx   ecx, al
.text$mn:000031AC                 test    ecx, ecx
.text$mn:000031AE                 jnz     short loc_31B9
.text$mn:000031B0                 mov     [ebp+var_4], 1
.text$mn:000031B7                 jmp     short loc_31C0
.text$mn:000031B9 ; ---------------------------------------------------------------------------
.text$mn:000031B9
.text$mn:000031B9 loc_31B9:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator!=(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+1Aj
.text$mn:000031B9                 mov     [ebp+var_4], 0
.text$mn:000031C0
.text$mn:000031C0 loc_31C0:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator!=(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+23j
.text$mn:000031C0                 mov     al, byte ptr [ebp+var_4]
.text$mn:000031C3                 mov     esp, ebp
.text$mn:000031C5                 pop     ebp
.text$mn:000031C6                 retn    4
.text$mn:000031C6 ??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:000031C6
.text$mn:000031C6 ; ---------------------------------------------------------------------------
.text$mn:000031C9                 align 4
.text$mn:000031C9 _text$mn        ends
.text$mn:000031C9
.text$mn:000031CC ; ===========================================================================
.text$mn:000031CC
.text$mn:000031CC ; Segment type: Pure code
.text$mn:000031CC ; Segment permissions: Read/Execute
.text$mn:000031CC _text$mn        segment para public 'CODE' use32
.text$mn:000031CC                 assume cs:_text$mn
.text$mn:000031CC                 ;org 31CCh
.text$mn:000031CC ; COMDAT (pick any)
.text$mn:000031CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031CC
.text$mn:000031CC ; =============== S U B R O U T I N E =======================================
.text$mn:000031CC
.text$mn:000031CC ; Attributes: bp-based frame
.text$mn:000031CC
.text$mn:000031CC ; public: struct RecentItem const & __thiscall std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>::operator*(void)const
.text$mn:000031CC                 public ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEABURecentItem@@XZ
.text$mn:000031CC ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEABURecentItem@@XZ proc near
.text$mn:000031CC                                         ; CODE XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+Ap
.text$mn:000031CC
.text$mn:000031CC var_10          = dword ptr -10h
.text$mn:000031CC var_C           = dword ptr -0Ch
.text$mn:000031CC var_8           = dword ptr -8
.text$mn:000031CC var_4           = dword ptr -4
.text$mn:000031CC
.text$mn:000031CC                 push    ebp
.text$mn:000031CD                 mov     ebp, esp
.text$mn:000031CF                 sub     esp, 10h
.text$mn:000031D2                 mov     [ebp+var_8], ecx
.text$mn:000031D5                 mov     ecx, [ebp+var_8] ; this
.text$mn:000031D8                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000031DD                 mov     [ebp+var_4], eax
.text$mn:000031E0                 cmp     [ebp+var_4], 0
.text$mn:000031E4                 jz      short loc_3208
.text$mn:000031E6                 mov     eax, [ebp+var_8]
.text$mn:000031E9                 mov     ecx, [ebp+var_4]
.text$mn:000031EC                 mov     edx, [eax+8]
.text$mn:000031EF                 cmp     edx, [ecx+0Ch]
.text$mn:000031F2                 jb      short loc_3208
.text$mn:000031F4                 mov     eax, [ebp+var_4]
.text$mn:000031F7                 mov     ecx, [eax+0Ch]
.text$mn:000031FA                 mov     edx, [ebp+var_4]
.text$mn:000031FD                 add     ecx, [edx+10h]
.text$mn:00003200                 mov     eax, [ebp+var_8]
.text$mn:00003203                 cmp     ecx, [eax+8]
.text$mn:00003206                 ja      short loc_3270
.text$mn:00003208
.text$mn:00003208 loc_3208:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+18j
.text$mn:00003208                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+26j
.text$mn:00003208                 push    14Ah            ; unsigned int
.text$mn:0000320D                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003212                 push    offset ??_C@_1EE@INPCGGNP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb?$AAl@ ; "deque iterator not dereferencable"
.text$mn:00003217                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000321C                 add     esp, 0Ch
.text$mn:0000321F                 mov     ecx, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00003224                 test    ecx, ecx
.text$mn:00003226                 jz      short loc_322C
.text$mn:00003228                 xor     edx, edx
.text$mn:0000322A                 jnz     short loc_3252
.text$mn:0000322C
.text$mn:0000322C loc_322C:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+5Aj
.text$mn:0000322C                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00003231                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00003236                 push    0
.text$mn:00003238                 push    14Bh
.text$mn:0000323D                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003242                 push    2
.text$mn:00003244                 call    __CrtDbgReportW
.text$mn:00003249                 add     esp, 18h
.text$mn:0000324C                 cmp     eax, 1
.text$mn:0000324F                 jnz     short loc_3252
.text$mn:00003251                 int     3               ; Trap to Debugger
.text$mn:00003252
.text$mn:00003252 loc_3252:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+5Ej
.text$mn:00003252                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+83j
.text$mn:00003252                 push    0
.text$mn:00003254                 push    14Bh
.text$mn:00003259                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000325E                 push    offset ??_C@_1OI@NHIMBGBK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; "std::_Deque_const_iterator<class std::_"...
.text$mn:00003263                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00003268                 call    __invalid_parameter
.text$mn:0000326D                 add     esp, 14h
.text$mn:00003270
.text$mn:00003270 loc_3270:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+3Aj
.text$mn:00003270                 mov     ecx, [ebp+var_8]
.text$mn:00003273                 mov     edx, [ecx+8]
.text$mn:00003276                 push    edx
.text$mn:00003277                 mov     ecx, [ebp+var_4]
.text$mn:0000327A                 call    ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<RecentItem>>::_Getblock(uint)
.text$mn:0000327F                 mov     [ebp+var_10], eax
.text$mn:00003282                 mov     eax, [ebp+var_8]
.text$mn:00003285                 mov     eax, [eax+8]
.text$mn:00003288                 xor     edx, edx
.text$mn:0000328A                 mov     ecx, 1
.text$mn:0000328F                 div     ecx
.text$mn:00003291                 mov     [ebp+var_C], edx
.text$mn:00003294                 mov     edx, [ebp+var_4]
.text$mn:00003297                 mov     eax, [edx+4]
.text$mn:0000329A                 mov     ecx, [ebp+var_C]
.text$mn:0000329D                 shl     ecx, 5
.text$mn:000032A0                 mov     edx, [ebp+var_10]
.text$mn:000032A3                 add     ecx, [eax+edx*4]
.text$mn:000032A6                 mov     eax, ecx
.text$mn:000032A8                 mov     esp, ebp
.text$mn:000032AA                 pop     ebp
.text$mn:000032AB                 retn
.text$mn:000032AB ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEABURecentItem@@XZ endp
.text$mn:000032AB
.text$mn:000032AB _text$mn        ends
.text$mn:000032AB
.text$mn:000032AC ; ===========================================================================
.text$mn:000032AC
.text$mn:000032AC ; Segment type: Pure code
.text$mn:000032AC ; Segment permissions: Read/Execute
.text$mn:000032AC _text$mn        segment para public 'CODE' use32
.text$mn:000032AC                 assume cs:_text$mn
.text$mn:000032AC                 ;org 32ACh
.text$mn:000032AC ; COMDAT (pick any)
.text$mn:000032AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032AC
.text$mn:000032AC ; =============== S U B R O U T I N E =======================================
.text$mn:000032AC
.text$mn:000032AC ; Attributes: bp-based frame
.text$mn:000032AC
.text$mn:000032AC ; public: struct RecentItem & __thiscall std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>::operator*(void)const
.text$mn:000032AC                 public ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEAAURecentItem@@XZ
.text$mn:000032AC ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEAAURecentItem@@XZ proc near
.text$mn:000032AC                                         ; CODE XREF: std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+59p
.text$mn:000032AC                                         ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+6Bp ...
.text$mn:000032AC
.text$mn:000032AC var_4           = dword ptr -4
.text$mn:000032AC
.text$mn:000032AC                 push    ebp
.text$mn:000032AD                 mov     ebp, esp
.text$mn:000032AF                 push    ecx
.text$mn:000032B0                 mov     [ebp+var_4], ecx
.text$mn:000032B3                 mov     ecx, [ebp+var_4]
.text$mn:000032B6                 call    ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEABURecentItem@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)
.text$mn:000032BB                 mov     esp, ebp
.text$mn:000032BD                 pop     ebp
.text$mn:000032BE                 retn
.text$mn:000032BE ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEAAURecentItem@@XZ endp
.text$mn:000032BE
.text$mn:000032BE ; ---------------------------------------------------------------------------
.text$mn:000032BF                 align 10h
.text$mn:000032BF _text$mn        ends
.text$mn:000032BF
.text$mn:000032C0 ; ===========================================================================
.text$mn:000032C0
.text$mn:000032C0 ; Segment type: Pure code
.text$mn:000032C0 ; Segment permissions: Read/Execute
.text$mn:000032C0 _text$mn        segment para public 'CODE' use32
.text$mn:000032C0                 assume cs:_text$mn
.text$mn:000032C0                 ;org 32C0h
.text$mn:000032C0 ; COMDAT (pick any)
.text$mn:000032C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032C0
.text$mn:000032C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000032C0
.text$mn:000032C0 ; Attributes: bp-based frame
.text$mn:000032C0
.text$mn:000032C0 ; public: class std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> & __thiscall std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>::operator++(void)
.text$mn:000032C0                 public ??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:000032C0 ??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:000032C0                                         ; CODE XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)+Ap
.text$mn:000032C0
.text$mn:000032C0 var_8           = dword ptr -8
.text$mn:000032C0 var_4           = dword ptr -4
.text$mn:000032C0
.text$mn:000032C0                 push    ebp
.text$mn:000032C1                 mov     ebp, esp
.text$mn:000032C3                 sub     esp, 8
.text$mn:000032C6                 mov     [ebp+var_4], ecx
.text$mn:000032C9                 mov     ecx, [ebp+var_4] ; this
.text$mn:000032CC                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000032D1                 mov     [ebp+var_8], eax
.text$mn:000032D4                 cmp     [ebp+var_8], 0
.text$mn:000032D8                 jz      short loc_32EE
.text$mn:000032DA                 mov     eax, [ebp+var_8]
.text$mn:000032DD                 mov     ecx, [eax+0Ch]
.text$mn:000032E0                 mov     edx, [ebp+var_8]
.text$mn:000032E3                 add     ecx, [edx+10h]
.text$mn:000032E6                 mov     eax, [ebp+var_4]
.text$mn:000032E9                 cmp     ecx, [eax+8]
.text$mn:000032EC                 ja      short loc_3356
.text$mn:000032EE
.text$mn:000032EE loc_32EE:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)+18j
.text$mn:000032EE                 push    167h            ; unsigned int
.text$mn:000032F3                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000032F8                 push    offset ??_C@_1EC@CEAHEOFL@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@ ; "deque iterator not incrementable"
.text$mn:000032FD                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003302                 add     esp, 0Ch
.text$mn:00003305                 mov     ecx, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000330A                 test    ecx, ecx
.text$mn:0000330C                 jz      short loc_3312
.text$mn:0000330E                 xor     edx, edx
.text$mn:00003310                 jnz     short loc_3338
.text$mn:00003312
.text$mn:00003312 loc_3312:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)+4Cj
.text$mn:00003312                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00003317                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000331C                 push    0
.text$mn:0000331E                 push    168h
.text$mn:00003323                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003328                 push    2
.text$mn:0000332A                 call    __CrtDbgReportW
.text$mn:0000332F                 add     esp, 18h
.text$mn:00003332                 cmp     eax, 1
.text$mn:00003335                 jnz     short loc_3338
.text$mn:00003337                 int     3               ; Trap to Debugger
.text$mn:00003338
.text$mn:00003338 loc_3338:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)+50j
.text$mn:00003338                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)+75j
.text$mn:00003338                 push    0
.text$mn:0000333A                 push    168h
.text$mn:0000333F                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003344                 push    offset ??_C@_1OK@PIJGGDJM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; "std::_Deque_const_iterator<class std::_"...
.text$mn:00003349                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000334E                 call    __invalid_parameter
.text$mn:00003353                 add     esp, 14h
.text$mn:00003356
.text$mn:00003356 loc_3356:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)+2Cj
.text$mn:00003356                 mov     ecx, [ebp+var_4]
.text$mn:00003359                 mov     edx, [ecx+8]
.text$mn:0000335C                 add     edx, 1
.text$mn:0000335F                 mov     eax, [ebp+var_4]
.text$mn:00003362                 mov     [eax+8], edx
.text$mn:00003365                 mov     eax, [ebp+var_4]
.text$mn:00003368                 mov     esp, ebp
.text$mn:0000336A                 pop     ebp
.text$mn:0000336B                 retn
.text$mn:0000336B ??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:0000336B
.text$mn:0000336B _text$mn        ends
.text$mn:0000336B
.text$mn:0000336C ; ===========================================================================
.text$mn:0000336C
.text$mn:0000336C ; Segment type: Pure code
.text$mn:0000336C ; Segment permissions: Read/Execute
.text$mn:0000336C _text$mn        segment para public 'CODE' use32
.text$mn:0000336C                 assume cs:_text$mn
.text$mn:0000336C                 ;org 336Ch
.text$mn:0000336C ; COMDAT (pick any)
.text$mn:0000336C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000336C
.text$mn:0000336C ; =============== S U B R O U T I N E =======================================
.text$mn:0000336C
.text$mn:0000336C ; Attributes: bp-based frame
.text$mn:0000336C
.text$mn:0000336C ; public: class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> & __thiscall std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>::operator++(void)
.text$mn:0000336C                 public ??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:0000336C ??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:0000336C                                         ; CODE XREF: std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+36p
.text$mn:0000336C                                         ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+3Ep
.text$mn:0000336C
.text$mn:0000336C var_4           = dword ptr -4
.text$mn:0000336C
.text$mn:0000336C                 push    ebp
.text$mn:0000336D                 mov     ebp, esp
.text$mn:0000336F                 push    ecx
.text$mn:00003370                 mov     [ebp+var_4], ecx
.text$mn:00003373                 mov     ecx, [ebp+var_4]
.text$mn:00003376                 call    ??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)
.text$mn:0000337B                 mov     eax, [ebp+var_4]
.text$mn:0000337E                 mov     esp, ebp
.text$mn:00003380                 pop     ebp
.text$mn:00003381                 retn
.text$mn:00003381 ??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:00003381
.text$mn:00003381 ; ---------------------------------------------------------------------------
.text$mn:00003382                 align 4
.text$mn:00003382 _text$mn        ends
.text$mn:00003382
.text$mn:00003384 ; ===========================================================================
.text$mn:00003384
.text$mn:00003384 ; Segment type: Pure code
.text$mn:00003384 ; Segment permissions: Read/Execute
.text$mn:00003384 _text$mn        segment para public 'CODE' use32
.text$mn:00003384                 assume cs:_text$mn
.text$mn:00003384                 ;org 3384h
.text$mn:00003384 ; COMDAT (pick any)
.text$mn:00003384                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003384
.text$mn:00003384 ; =============== S U B R O U T I N E =======================================
.text$mn:00003384
.text$mn:00003384 ; Attributes: bp-based frame
.text$mn:00003384
.text$mn:00003384 ; public: class std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> & __thiscall std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>::operator--(void)
.text$mn:00003384                 public ??F?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:00003384 ??F?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:00003384                                         ; CODE XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator--(void)+Ap
.text$mn:00003384
.text$mn:00003384 var_8           = dword ptr -8
.text$mn:00003384 var_4           = dword ptr -4
.text$mn:00003384
.text$mn:00003384                 push    ebp
.text$mn:00003385                 mov     ebp, esp
.text$mn:00003387                 sub     esp, 8
.text$mn:0000338A                 mov     [ebp+var_4], ecx
.text$mn:0000338D                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003390                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00003395                 mov     [ebp+var_8], eax
.text$mn:00003398                 cmp     [ebp+var_8], 0
.text$mn:0000339C                 jz      short loc_33AC
.text$mn:0000339E                 mov     eax, [ebp+var_4]
.text$mn:000033A1                 mov     ecx, [ebp+var_8]
.text$mn:000033A4                 mov     edx, [eax+8]
.text$mn:000033A7                 cmp     edx, [ecx+0Ch]
.text$mn:000033AA                 ja      short loc_3414
.text$mn:000033AC
.text$mn:000033AC loc_33AC:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator--(void)+18j
.text$mn:000033AC                 push    184h            ; unsigned int
.text$mn:000033B1                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000033B6                 push    offset ??_C@_1EC@IJLEGPJO@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@ ; "deque iterator not decrementable"
.text$mn:000033BB                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000033C0                 add     esp, 0Ch
.text$mn:000033C3                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:000033C8                 test    eax, eax
.text$mn:000033CA                 jz      short loc_33D0
.text$mn:000033CC                 xor     ecx, ecx
.text$mn:000033CE                 jnz     short loc_33F6
.text$mn:000033D0
.text$mn:000033D0 loc_33D0:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator--(void)+46j
.text$mn:000033D0                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:000033D5                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:000033DA                 push    0
.text$mn:000033DC                 push    185h
.text$mn:000033E1                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000033E6                 push    2
.text$mn:000033E8                 call    __CrtDbgReportW
.text$mn:000033ED                 add     esp, 18h
.text$mn:000033F0                 cmp     eax, 1
.text$mn:000033F3                 jnz     short loc_33F6
.text$mn:000033F5                 int     3               ; Trap to Debugger
.text$mn:000033F6
.text$mn:000033F6 loc_33F6:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator--(void)+4Aj
.text$mn:000033F6                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator--(void)+6Fj
.text$mn:000033F6                 push    0
.text$mn:000033F8                 push    185h
.text$mn:000033FD                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003402                 push    offset ??_C@_1OK@LKENPFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; "std::_Deque_const_iterator<class std::_"...
.text$mn:00003407                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000340C                 call    __invalid_parameter
.text$mn:00003411                 add     esp, 14h
.text$mn:00003414
.text$mn:00003414 loc_3414:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator--(void)+26j
.text$mn:00003414                 mov     eax, [ebp+var_4]
.text$mn:00003417                 mov     ecx, [eax+8]
.text$mn:0000341A                 sub     ecx, 1
.text$mn:0000341D                 mov     edx, [ebp+var_4]
.text$mn:00003420                 mov     [edx+8], ecx
.text$mn:00003423                 mov     eax, [ebp+var_4]
.text$mn:00003426                 mov     esp, ebp
.text$mn:00003428                 pop     ebp
.text$mn:00003429                 retn
.text$mn:00003429 ??F?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:00003429
.text$mn:00003429 ; ---------------------------------------------------------------------------
.text$mn:0000342A                 align 4
.text$mn:0000342A _text$mn        ends
.text$mn:0000342A
.text$mn:0000342C ; ===========================================================================
.text$mn:0000342C
.text$mn:0000342C ; Segment type: Pure code
.text$mn:0000342C ; Segment permissions: Read/Execute
.text$mn:0000342C _text$mn        segment para public 'CODE' use32
.text$mn:0000342C                 assume cs:_text$mn
.text$mn:0000342C                 ;org 342Ch
.text$mn:0000342C ; COMDAT (pick any)
.text$mn:0000342C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000342C
.text$mn:0000342C ; =============== S U B R O U T I N E =======================================
.text$mn:0000342C
.text$mn:0000342C ; Attributes: bp-based frame
.text$mn:0000342C
.text$mn:0000342C ; public: class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> & __thiscall std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>::operator--(void)
.text$mn:0000342C                 public ??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:0000342C ??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:0000342C                                         ; CODE XREF: std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+47p
.text$mn:0000342C                                         ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Nonscalar_ptr_iterator_tag)+60p
.text$mn:0000342C
.text$mn:0000342C var_4           = dword ptr -4
.text$mn:0000342C
.text$mn:0000342C                 push    ebp
.text$mn:0000342D                 mov     ebp, esp
.text$mn:0000342F                 push    ecx
.text$mn:00003430                 mov     [ebp+var_4], ecx
.text$mn:00003433                 mov     ecx, [ebp+var_4]
.text$mn:00003436                 call    ??F?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator--(void)
.text$mn:0000343B                 mov     eax, [ebp+var_4]
.text$mn:0000343E                 mov     esp, ebp
.text$mn:00003440                 pop     ebp
.text$mn:00003441                 retn
.text$mn:00003441 ??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:00003441
.text$mn:00003441 ; ---------------------------------------------------------------------------
.text$mn:00003442                 align 4
.text$mn:00003442 _text$mn        ends
.text$mn:00003442
.text$mn:00003444 ; ===========================================================================
.text$mn:00003444
.text$mn:00003444 ; Segment type: Pure code
.text$mn:00003444 ; Segment permissions: Read/Execute
.text$mn:00003444 _text$mn        segment para public 'CODE' use32
.text$mn:00003444                 assume cs:_text$mn
.text$mn:00003444                 ;org 3444h
.text$mn:00003444 ; COMDAT (pick any)
.text$mn:00003444                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003444
.text$mn:00003444 ; =============== S U B R O U T I N E =======================================
.text$mn:00003444
.text$mn:00003444 ; Attributes: bp-based frame
.text$mn:00003444
.text$mn:00003444 ; int __stdcall std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator-(std::_Iterator_base12 *)
.text$mn:00003444                 public ??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEHABV01@@Z
.text$mn:00003444 ??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEHABV01@@Z proc near
.text$mn:00003444                                         ; CODE XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator-(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+Ep
.text$mn:00003444
.text$mn:00003444 var_8           = dword ptr -8
.text$mn:00003444 var_4           = dword ptr -4
.text$mn:00003444 arg_0           = dword ptr  8
.text$mn:00003444
.text$mn:00003444                 push    ebp
.text$mn:00003445                 mov     ebp, esp
.text$mn:00003447                 sub     esp, 8
.text$mn:0000344A                 mov     [ebp+var_4], ecx
.text$mn:0000344D                 mov     eax, [ebp+arg_0]
.text$mn:00003450                 push    eax             ; std::_Iterator_base12 *
.text$mn:00003451                 mov     ecx, [ebp+var_4]
.text$mn:00003454                 call    ?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Compat(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00003459                 mov     ecx, [ebp+arg_0]
.text$mn:0000345C                 mov     edx, [ebp+var_4]
.text$mn:0000345F                 mov     eax, [ecx+8]
.text$mn:00003462                 cmp     eax, [edx+8]
.text$mn:00003465                 ja      short loc_3478
.text$mn:00003467                 mov     ecx, [ebp+var_4]
.text$mn:0000346A                 mov     edx, [ebp+arg_0]
.text$mn:0000346D                 mov     eax, [ecx+8]
.text$mn:00003470                 sub     eax, [edx+8]
.text$mn:00003473                 mov     [ebp+var_8], eax
.text$mn:00003476                 jmp     short loc_3489
.text$mn:00003478 ; ---------------------------------------------------------------------------
.text$mn:00003478
.text$mn:00003478 loc_3478:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator-(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+21j
.text$mn:00003478                 mov     ecx, [ebp+arg_0]
.text$mn:0000347B                 mov     edx, [ebp+var_4]
.text$mn:0000347E                 mov     eax, [ecx+8]
.text$mn:00003481                 sub     eax, [edx+8]
.text$mn:00003484                 neg     eax
.text$mn:00003486                 mov     [ebp+var_8], eax
.text$mn:00003489
.text$mn:00003489 loc_3489:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator-(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+32j
.text$mn:00003489                 mov     eax, [ebp+var_8]
.text$mn:0000348C                 mov     esp, ebp
.text$mn:0000348E                 pop     ebp
.text$mn:0000348F                 retn    4
.text$mn:0000348F ??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEHABV01@@Z endp
.text$mn:0000348F
.text$mn:0000348F ; ---------------------------------------------------------------------------
.text$mn:00003492                 align 4
.text$mn:00003492 _text$mn        ends
.text$mn:00003492
.text$mn:00003494 ; ===========================================================================
.text$mn:00003494
.text$mn:00003494 ; Segment type: Pure code
.text$mn:00003494 ; Segment permissions: Read/Execute
.text$mn:00003494 _text$mn        segment para public 'CODE' use32
.text$mn:00003494                 assume cs:_text$mn
.text$mn:00003494                 ;org 3494h
.text$mn:00003494 ; COMDAT (pick any)
.text$mn:00003494                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003494
.text$mn:00003494 ; =============== S U B R O U T I N E =======================================
.text$mn:00003494
.text$mn:00003494 ; Attributes: bp-based frame
.text$mn:00003494
.text$mn:00003494 ; public: class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> __thiscall std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>::operator-(int)const
.text$mn:00003494                 public ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00003494 ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:00003494                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::back(void)+4Dp
.text$mn:00003494
.text$mn:00003494 var_20          = byte ptr -20h
.text$mn:00003494 var_14          = dword ptr -14h
.text$mn:00003494 var_10          = dword ptr -10h
.text$mn:00003494 var_C           = dword ptr -0Ch
.text$mn:00003494 var_4           = dword ptr -4
.text$mn:00003494 arg_0           = dword ptr  8
.text$mn:00003494 arg_4           = dword ptr  0Ch
.text$mn:00003494
.text$mn:00003494                 push    ebp
.text$mn:00003495                 mov     ebp, esp
.text$mn:00003497                 push    0FFFFFFFFh
.text$mn:00003499                 push    offset __ehhandler$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:0000349E                 mov     eax, large fs:0
.text$mn:000034A4                 push    eax
.text$mn:000034A5                 sub     esp, 14h
.text$mn:000034A8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000034AD                 xor     eax, ebp
.text$mn:000034AF                 push    eax
.text$mn:000034B0                 lea     eax, [ebp+var_C]
.text$mn:000034B3                 mov     large fs:0, eax
.text$mn:000034B9                 mov     [ebp+var_14], ecx
.text$mn:000034BC                 mov     [ebp+var_10], 0
.text$mn:000034C3                 mov     eax, [ebp+var_14]
.text$mn:000034C6                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000034C7                 lea     ecx, [ebp+var_20]
.text$mn:000034CA                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:000034CF                 mov     [ebp+var_4], 1
.text$mn:000034D6                 mov     ecx, [ebp+arg_4]
.text$mn:000034D9                 push    ecx
.text$mn:000034DA                 lea     ecx, [ebp+var_20]
.text$mn:000034DD                 call    ??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator-=(int)
.text$mn:000034E2                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000034E3                 mov     ecx, [ebp+arg_0]
.text$mn:000034E6                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:000034EB                 mov     edx, [ebp+var_10]
.text$mn:000034EE                 or      edx, 1
.text$mn:000034F1                 mov     [ebp+var_10], edx
.text$mn:000034F4                 mov     byte ptr [ebp+var_4], 0
.text$mn:000034F8                 lea     ecx, [ebp+var_20]
.text$mn:000034FB                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00003500                 mov     eax, [ebp+arg_0]
.text$mn:00003503                 mov     ecx, [ebp+var_C]
.text$mn:00003506                 mov     large fs:0, ecx
.text$mn:0000350D                 pop     ecx
.text$mn:0000350E                 mov     esp, ebp
.text$mn:00003510                 pop     ebp
.text$mn:00003511                 retn    8
.text$mn:00003511 ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:00003511
.text$mn:00003511 _text$mn        ends
.text$mn:00003511
.text$x:00003514 ; ===========================================================================
.text$x:00003514
.text$x:00003514 ; Segment type: Pure code
.text$x:00003514 ; Segment permissions: Read/Execute
.text$x:00003514 _text$x         segment para public 'CODE' use32
.text$x:00003514                 assume cs:_text$x
.text$x:00003514                 ;org 3514h
.text$x:00003514 ; COMDAT (pick associative to section at 3494)
.text$x:00003514                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003514
.text$x:00003514 ; =============== S U B R O U T I N E =======================================
.text$x:00003514
.text$x:00003514
.text$x:00003514 __unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:00003514                                         ; DATA XREF: .xdata$x:000072B0o
.text$x:00003514                 lea     ecx, [ebp-20h]
.text$x:00003517                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00003517 __unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:00003517
.text$x:0000351C
.text$x:0000351C ; =============== S U B R O U T I N E =======================================
.text$x:0000351C
.text$x:0000351C
.text$x:0000351C __unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:0000351C                                         ; DATA XREF: .xdata$x:000072A8o
.text$x:0000351C                 mov     eax, [ebp-10h]
.text$x:0000351F                 and     eax, 1
.text$x:00003522                 jz      $LN5_2
.text$x:00003528                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000352C                 mov     ecx, [ebp+8]
.text$x:0000352F                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00003534 ; ---------------------------------------------------------------------------
.text$x:00003534
.text$x:00003534 $LN5_2:                                 ; CODE XREF: __unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:00003534                 retn
.text$x:00003534 __unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:00003534
.text$x:00003535
.text$x:00003535 ; =============== S U B R O U T I N E =======================================
.text$x:00003535
.text$x:00003535
.text$x:00003535 __ehhandler$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:00003535                                         ; DATA XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator-(int)+5o
.text$x:00003535
.text$x:00003535 arg_4           = dword ptr  8
.text$x:00003535
.text$x:00003535                 mov     edx, [esp+arg_4]
.text$x:00003539                 lea     eax, [edx+0Ch]
.text$x:0000353C                 mov     ecx, [edx-18h]
.text$x:0000353F                 xor     ecx, eax
.text$x:00003541                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003546                 mov     eax, offset __ehfuncinfo$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:0000354B                 jmp     ___CxxFrameHandler3
.text$x:0000354B __ehhandler$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:0000354B
.text$x:0000354B _text$x         ends
.text$x:0000354B
.text$mn:00003550 ; ===========================================================================
.text$mn:00003550
.text$mn:00003550 ; Segment type: Pure code
.text$mn:00003550 ; Segment permissions: Read/Execute
.text$mn:00003550 _text$mn        segment para public 'CODE' use32
.text$mn:00003550                 assume cs:_text$mn
.text$mn:00003550                 ;org 3550h
.text$mn:00003550 ; COMDAT (pick any)
.text$mn:00003550                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003550
.text$mn:00003550 ; =============== S U B R O U T I N E =======================================
.text$mn:00003550
.text$mn:00003550 ; Attributes: bp-based frame
.text$mn:00003550
.text$mn:00003550 ; int __stdcall std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator-(std::_Iterator_base12 *)
.text$mn:00003550                 public ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@1@@Z
.text$mn:00003550 ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@1@@Z proc near
.text$mn:00003550                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+249p
.text$mn:00003550                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+267p ...
.text$mn:00003550
.text$mn:00003550 var_4           = dword ptr -4
.text$mn:00003550 arg_0           = dword ptr  8
.text$mn:00003550
.text$mn:00003550                 push    ebp
.text$mn:00003551                 mov     ebp, esp
.text$mn:00003553                 push    ecx
.text$mn:00003554                 mov     [ebp+var_4], ecx
.text$mn:00003557                 mov     eax, [ebp+arg_0]
.text$mn:0000355A                 push    eax             ; std::_Iterator_base12 *
.text$mn:0000355B                 mov     ecx, [ebp+var_4]
.text$mn:0000355E                 call    ??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator-(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00003563                 mov     esp, ebp
.text$mn:00003565                 pop     ebp
.text$mn:00003566                 retn    4
.text$mn:00003566 ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@1@@Z endp
.text$mn:00003566
.text$mn:00003566 ; ---------------------------------------------------------------------------
.text$mn:00003569                 align 4
.text$mn:00003569 _text$mn        ends
.text$mn:00003569
.text$mn:0000356C ; ===========================================================================
.text$mn:0000356C
.text$mn:0000356C ; Segment type: Pure code
.text$mn:0000356C ; Segment permissions: Read/Execute
.text$mn:0000356C _text$mn        segment para public 'CODE' use32
.text$mn:0000356C                 assume cs:_text$mn
.text$mn:0000356C                 ;org 356Ch
.text$mn:0000356C ; COMDAT (pick any)
.text$mn:0000356C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000356C
.text$mn:0000356C ; =============== S U B R O U T I N E =======================================
.text$mn:0000356C
.text$mn:0000356C ; Attributes: bp-based frame
.text$mn:0000356C
.text$mn:0000356C ; public: class std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> __thiscall std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>::operator+(int)const
.text$mn:0000356C                 public ??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:0000356C ??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:0000356C                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+44p
.text$mn:0000356C
.text$mn:0000356C var_20          = byte ptr -20h
.text$mn:0000356C var_14          = dword ptr -14h
.text$mn:0000356C var_10          = dword ptr -10h
.text$mn:0000356C var_C           = dword ptr -0Ch
.text$mn:0000356C var_4           = dword ptr -4
.text$mn:0000356C arg_0           = dword ptr  8
.text$mn:0000356C arg_4           = dword ptr  0Ch
.text$mn:0000356C
.text$mn:0000356C                 push    ebp
.text$mn:0000356D                 mov     ebp, esp
.text$mn:0000356F                 push    0FFFFFFFFh
.text$mn:00003571                 push    offset __ehhandler$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00003576                 mov     eax, large fs:0
.text$mn:0000357C                 push    eax
.text$mn:0000357D                 sub     esp, 14h
.text$mn:00003580                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003585                 xor     eax, ebp
.text$mn:00003587                 push    eax
.text$mn:00003588                 lea     eax, [ebp+var_C]
.text$mn:0000358B                 mov     large fs:0, eax
.text$mn:00003591                 mov     [ebp+var_14], ecx
.text$mn:00003594                 mov     [ebp+var_10], 0
.text$mn:0000359B                 mov     eax, [ebp+var_14]
.text$mn:0000359E                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000359F                 lea     ecx, [ebp+var_20]
.text$mn:000035A2                 call    ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:000035A7                 mov     [ebp+var_4], 1
.text$mn:000035AE                 mov     ecx, [ebp+arg_4]
.text$mn:000035B1                 push    ecx
.text$mn:000035B2                 lea     ecx, [ebp+var_20]
.text$mn:000035B5                 call    ??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+=(int)
.text$mn:000035BA                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000035BB                 mov     ecx, [ebp+arg_0]
.text$mn:000035BE                 call    ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:000035C3                 mov     edx, [ebp+var_10]
.text$mn:000035C6                 or      edx, 1
.text$mn:000035C9                 mov     [ebp+var_10], edx
.text$mn:000035CC                 mov     byte ptr [ebp+var_4], 0
.text$mn:000035D0                 lea     ecx, [ebp+var_20]
.text$mn:000035D3                 call    ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:000035D8                 mov     eax, [ebp+arg_0]
.text$mn:000035DB                 mov     ecx, [ebp+var_C]
.text$mn:000035DE                 mov     large fs:0, ecx
.text$mn:000035E5                 pop     ecx
.text$mn:000035E6                 mov     esp, ebp
.text$mn:000035E8                 pop     ebp
.text$mn:000035E9                 retn    8
.text$mn:000035E9 ??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:000035E9
.text$mn:000035E9 _text$mn        ends
.text$mn:000035E9
.text$x:000035EC ; ===========================================================================
.text$x:000035EC
.text$x:000035EC ; Segment type: Pure code
.text$x:000035EC ; Segment permissions: Read/Execute
.text$x:000035EC _text$x         segment para public 'CODE' use32
.text$x:000035EC                 assume cs:_text$x
.text$x:000035EC                 ;org 35ECh
.text$x:000035EC ; COMDAT (pick associative to section at 356C)
.text$x:000035EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000035EC
.text$x:000035EC ; =============== S U B R O U T I N E =======================================
.text$x:000035EC
.text$x:000035EC
.text$x:000035EC __unwindfunclet$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:000035EC                                         ; DATA XREF: .xdata$x:000071C4o
.text$x:000035EC                 lea     ecx, [ebp-20h]
.text$x:000035EF                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000035EF __unwindfunclet$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:000035EF
.text$x:000035F4
.text$x:000035F4 ; =============== S U B R O U T I N E =======================================
.text$x:000035F4
.text$x:000035F4
.text$x:000035F4 __unwindfunclet$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:000035F4                                         ; DATA XREF: .xdata$x:000071BCo
.text$x:000035F4                 mov     eax, [ebp-10h]
.text$x:000035F7                 and     eax, 1
.text$x:000035FA                 jz      $LN5_0
.text$x:00003600                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00003604                 mov     ecx, [ebp+8]
.text$x:00003607                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:0000360C ; ---------------------------------------------------------------------------
.text$x:0000360C
.text$x:0000360C $LN5_0:                                 ; CODE XREF: __unwindfunclet$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:0000360C                 retn
.text$x:0000360C __unwindfunclet$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:0000360C
.text$x:0000360D
.text$x:0000360D ; =============== S U B R O U T I N E =======================================
.text$x:0000360D
.text$x:0000360D
.text$x:0000360D __ehhandler$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:0000360D                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+(int)+5o
.text$x:0000360D
.text$x:0000360D arg_4           = dword ptr  8
.text$x:0000360D
.text$x:0000360D                 mov     edx, [esp+arg_4]
.text$x:00003611                 lea     eax, [edx+0Ch]
.text$x:00003614                 mov     ecx, [edx-18h]
.text$x:00003617                 xor     ecx, eax
.text$x:00003619                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000361E                 mov     eax, offset __ehfuncinfo$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:00003623                 jmp     ___CxxFrameHandler3
.text$x:00003623 __ehhandler$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:00003623
.text$x:00003623 _text$x         ends
.text$x:00003623
.text$mn:00003628 ; ===========================================================================
.text$mn:00003628
.text$mn:00003628 ; Segment type: Pure code
.text$mn:00003628 ; Segment permissions: Read/Execute
.text$mn:00003628 _text$mn        segment para public 'CODE' use32
.text$mn:00003628                 assume cs:_text$mn
.text$mn:00003628                 ;org 3628h
.text$mn:00003628 ; COMDAT (pick any)
.text$mn:00003628                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003628
.text$mn:00003628 ; =============== S U B R O U T I N E =======================================
.text$mn:00003628
.text$mn:00003628 ; Attributes: bp-based frame
.text$mn:00003628
.text$mn:00003628 ; public: class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> __thiscall std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>::operator+(int)const
.text$mn:00003628                 public ??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00003628 ??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:00003628                                         ; CODE XREF: LastRecentFileList::remove(int)+B8p
.text$mn:00003628                                         ; LastRecentFileList::clear(void)+B3p ...
.text$mn:00003628
.text$mn:00003628 var_20          = byte ptr -20h
.text$mn:00003628 var_14          = dword ptr -14h
.text$mn:00003628 var_10          = dword ptr -10h
.text$mn:00003628 var_C           = dword ptr -0Ch
.text$mn:00003628 var_4           = dword ptr -4
.text$mn:00003628 arg_0           = dword ptr  8
.text$mn:00003628 arg_4           = dword ptr  0Ch
.text$mn:00003628
.text$mn:00003628                 push    ebp
.text$mn:00003629                 mov     ebp, esp
.text$mn:0000362B                 push    0FFFFFFFFh
.text$mn:0000362D                 push    offset __ehhandler$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00003632                 mov     eax, large fs:0
.text$mn:00003638                 push    eax
.text$mn:00003639                 sub     esp, 14h
.text$mn:0000363C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003641                 xor     eax, ebp
.text$mn:00003643                 push    eax
.text$mn:00003644                 lea     eax, [ebp+var_C]
.text$mn:00003647                 mov     large fs:0, eax
.text$mn:0000364D                 mov     [ebp+var_14], ecx
.text$mn:00003650                 mov     [ebp+var_10], 0
.text$mn:00003657                 mov     eax, [ebp+var_14]
.text$mn:0000365A                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000365B                 lea     ecx, [ebp+var_20]
.text$mn:0000365E                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00003663                 mov     [ebp+var_4], 1
.text$mn:0000366A                 mov     ecx, [ebp+arg_4]
.text$mn:0000366D                 push    ecx
.text$mn:0000366E                 lea     ecx, [ebp+var_20]
.text$mn:00003671                 call    ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+=(int)
.text$mn:00003676                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00003677                 mov     ecx, [ebp+arg_0]
.text$mn:0000367A                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:0000367F                 mov     edx, [ebp+var_10]
.text$mn:00003682                 or      edx, 1
.text$mn:00003685                 mov     [ebp+var_10], edx
.text$mn:00003688                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000368C                 lea     ecx, [ebp+var_20]
.text$mn:0000368F                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00003694                 mov     eax, [ebp+arg_0]
.text$mn:00003697                 mov     ecx, [ebp+var_C]
.text$mn:0000369A                 mov     large fs:0, ecx
.text$mn:000036A1                 pop     ecx
.text$mn:000036A2                 mov     esp, ebp
.text$mn:000036A4                 pop     ebp
.text$mn:000036A5                 retn    8
.text$mn:000036A5 ??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:000036A5
.text$mn:000036A5 _text$mn        ends
.text$mn:000036A5
.text$x:000036A8 ; ===========================================================================
.text$x:000036A8
.text$x:000036A8 ; Segment type: Pure code
.text$x:000036A8 ; Segment permissions: Read/Execute
.text$x:000036A8 _text$x         segment para public 'CODE' use32
.text$x:000036A8                 assume cs:_text$x
.text$x:000036A8                 ;org 36A8h
.text$x:000036A8 ; COMDAT (pick associative to section at 3628)
.text$x:000036A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000036A8
.text$x:000036A8 ; =============== S U B R O U T I N E =======================================
.text$x:000036A8
.text$x:000036A8
.text$x:000036A8 __unwindfunclet$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:000036A8                                         ; DATA XREF: .xdata$x:0000727Co
.text$x:000036A8                 lea     ecx, [ebp-20h]
.text$x:000036AB                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000036AB __unwindfunclet$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:000036AB
.text$x:000036B0
.text$x:000036B0 ; =============== S U B R O U T I N E =======================================
.text$x:000036B0
.text$x:000036B0
.text$x:000036B0 __unwindfunclet$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:000036B0                                         ; DATA XREF: .xdata$x:00007274o
.text$x:000036B0                 mov     eax, [ebp-10h]
.text$x:000036B3                 and     eax, 1
.text$x:000036B6                 jz      $LN5_1
.text$x:000036BC                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000036C0                 mov     ecx, [ebp+8]
.text$x:000036C3                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000036C8 ; ---------------------------------------------------------------------------
.text$x:000036C8
.text$x:000036C8 $LN5_1:                                 ; CODE XREF: __unwindfunclet$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:000036C8                 retn
.text$x:000036C8 __unwindfunclet$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:000036C8
.text$x:000036C9
.text$x:000036C9 ; =============== S U B R O U T I N E =======================================
.text$x:000036C9
.text$x:000036C9
.text$x:000036C9 __ehhandler$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:000036C9                                         ; DATA XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+(int)+5o
.text$x:000036C9
.text$x:000036C9 arg_4           = dword ptr  8
.text$x:000036C9
.text$x:000036C9                 mov     edx, [esp+arg_4]
.text$x:000036CD                 lea     eax, [edx+0Ch]
.text$x:000036D0                 mov     ecx, [edx-18h]
.text$x:000036D3                 xor     ecx, eax
.text$x:000036D5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000036DA                 mov     eax, offset __ehfuncinfo$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:000036DF                 jmp     ___CxxFrameHandler3
.text$x:000036DF __ehhandler$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:000036DF
.text$x:000036DF _text$x         ends
.text$x:000036DF
.text$mn:000036E4 ; ===========================================================================
.text$mn:000036E4
.text$mn:000036E4 ; Segment type: Pure code
.text$mn:000036E4 ; Segment permissions: Read/Execute
.text$mn:000036E4 _text$mn        segment para public 'CODE' use32
.text$mn:000036E4                 assume cs:_text$mn
.text$mn:000036E4                 ;org 36E4h
.text$mn:000036E4 ; COMDAT (pick any)
.text$mn:000036E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036E4
.text$mn:000036E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000036E4
.text$mn:000036E4 ; Attributes: bp-based frame
.text$mn:000036E4
.text$mn:000036E4 ; int __stdcall std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator<(std::_Iterator_base12 *)
.text$mn:000036E4                 public ??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:000036E4 ??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:000036E4                                         ; CODE XREF: std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,wchar_t const *,uint,std::random_access_iterator_tag)+6Bp
.text$mn:000036E4                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+C2p ...
.text$mn:000036E4
.text$mn:000036E4 var_8           = dword ptr -8
.text$mn:000036E4 var_4           = dword ptr -4
.text$mn:000036E4 arg_0           = dword ptr  8
.text$mn:000036E4
.text$mn:000036E4                 push    ebp
.text$mn:000036E5                 mov     ebp, esp
.text$mn:000036E7                 sub     esp, 8
.text$mn:000036EA                 mov     [ebp+var_4], ecx
.text$mn:000036ED                 mov     eax, [ebp+arg_0]
.text$mn:000036F0                 push    eax             ; std::_Iterator_base12 *
.text$mn:000036F1                 mov     ecx, [ebp+var_4]
.text$mn:000036F4                 call    ?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Compat(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:000036F9                 mov     ecx, [ebp+var_4]
.text$mn:000036FC                 mov     edx, [ebp+arg_0]
.text$mn:000036FF                 mov     eax, [ecx+8]
.text$mn:00003702                 cmp     eax, [edx+8]
.text$mn:00003705                 jnb     short loc_3710
.text$mn:00003707                 mov     [ebp+var_8], 1
.text$mn:0000370E                 jmp     short loc_3717
.text$mn:00003710 ; ---------------------------------------------------------------------------
.text$mn:00003710
.text$mn:00003710 loc_3710:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator<(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+21j
.text$mn:00003710                 mov     [ebp+var_8], 0
.text$mn:00003717
.text$mn:00003717 loc_3717:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator<(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+2Aj
.text$mn:00003717                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000371A                 mov     esp, ebp
.text$mn:0000371C                 pop     ebp
.text$mn:0000371D                 retn    4
.text$mn:0000371D ??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:0000371D
.text$mn:0000371D _text$mn        ends
.text$mn:0000371D
.text$mn:00003720 ; ===========================================================================
.text$mn:00003720
.text$mn:00003720 ; Segment type: Pure code
.text$mn:00003720 ; Segment permissions: Read/Execute
.text$mn:00003720 _text$mn        segment para public 'CODE' use32
.text$mn:00003720                 assume cs:_text$mn
.text$mn:00003720                 ;org 3720h
.text$mn:00003720 ; COMDAT (pick any)
.text$mn:00003720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003720
.text$mn:00003720 ; =============== S U B R O U T I N E =======================================
.text$mn:00003720
.text$mn:00003720 ; Attributes: bp-based frame
.text$mn:00003720
.text$mn:00003720 ; public: class std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> & __thiscall std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>::operator+=(int)
.text$mn:00003720                 public ??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00003720 ??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00003720                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+(int)+49p
.text$mn:00003720
.text$mn:00003720 var_8           = dword ptr -8
.text$mn:00003720 var_4           = dword ptr -4
.text$mn:00003720 arg_0           = dword ptr  8
.text$mn:00003720
.text$mn:00003720                 push    ebp
.text$mn:00003721                 mov     ebp, esp
.text$mn:00003723                 sub     esp, 8
.text$mn:00003726                 mov     [ebp+var_4], ecx
.text$mn:00003729                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000372C                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00003731                 mov     [ebp+var_8], eax
.text$mn:00003734                 cmp     [ebp+var_8], 0
.text$mn:00003738                 jz      short loc_3764
.text$mn:0000373A                 mov     eax, [ebp+var_4]
.text$mn:0000373D                 mov     ecx, [eax+8]
.text$mn:00003740                 add     ecx, [ebp+arg_0]
.text$mn:00003743                 mov     edx, [ebp+var_8]
.text$mn:00003746                 cmp     ecx, [edx+0Ch]
.text$mn:00003749                 jb      short loc_3764
.text$mn:0000374B                 mov     eax, [ebp+var_8]
.text$mn:0000374E                 mov     ecx, [eax+0Ch]
.text$mn:00003751                 mov     edx, [ebp+var_8]
.text$mn:00003754                 add     ecx, [edx+10h]
.text$mn:00003757                 mov     eax, [ebp+var_4]
.text$mn:0000375A                 mov     edx, [eax+8]
.text$mn:0000375D                 add     edx, [ebp+arg_0]
.text$mn:00003760                 cmp     ecx, edx
.text$mn:00003762                 jnb     short loc_37CC
.text$mn:00003764
.text$mn:00003764 loc_3764:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+=(int)+18j
.text$mn:00003764                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+=(int)+29j
.text$mn:00003764                 push    1A1h            ; unsigned int
.text$mn:00003769                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000376E                 push    offset ??_C@_1EK@DEGNOCIK@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr@ ; "deque iterator + offset out of range"
.text$mn:00003773                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003778                 add     esp, 0Ch
.text$mn:0000377B                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00003780                 test    eax, eax
.text$mn:00003782                 jz      short loc_3788
.text$mn:00003784                 xor     ecx, ecx
.text$mn:00003786                 jnz     short loc_37AE
.text$mn:00003788
.text$mn:00003788 loc_3788:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+=(int)+62j
.text$mn:00003788                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:0000378D                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00003792                 push    0
.text$mn:00003794                 push    1A2h
.text$mn:00003799                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000379E                 push    2
.text$mn:000037A0                 call    __CrtDbgReportW
.text$mn:000037A5                 add     esp, 18h
.text$mn:000037A8                 cmp     eax, 1
.text$mn:000037AB                 jnz     short loc_37AE
.text$mn:000037AD                 int     3               ; Trap to Debugger
.text$mn:000037AE
.text$mn:000037AE loc_37AE:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+=(int)+66j
.text$mn:000037AE                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+=(int)+8Bj
.text$mn:000037AE                 push    0
.text$mn:000037B0                 push    1A2h
.text$mn:000037B5                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000037BA                 push    offset ??_C@_1OK@INOEGLNP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; "std::_Deque_const_iterator<class std::_"...
.text$mn:000037BF                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:000037C4                 call    __invalid_parameter
.text$mn:000037C9                 add     esp, 14h
.text$mn:000037CC
.text$mn:000037CC loc_37CC:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+=(int)+42j
.text$mn:000037CC                 mov     eax, [ebp+var_4]
.text$mn:000037CF                 mov     ecx, [eax+8]
.text$mn:000037D2                 add     ecx, [ebp+arg_0]
.text$mn:000037D5                 mov     edx, [ebp+var_4]
.text$mn:000037D8                 mov     [edx+8], ecx
.text$mn:000037DB                 mov     eax, [ebp+var_4]
.text$mn:000037DE                 mov     esp, ebp
.text$mn:000037E0                 pop     ebp
.text$mn:000037E1                 retn    4
.text$mn:000037E1 ??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:000037E1
.text$mn:000037E1 _text$mn        ends
.text$mn:000037E1
.text$mn:000037E4 ; ===========================================================================
.text$mn:000037E4
.text$mn:000037E4 ; Segment type: Pure code
.text$mn:000037E4 ; Segment permissions: Read/Execute
.text$mn:000037E4 _text$mn        segment para public 'CODE' use32
.text$mn:000037E4                 assume cs:_text$mn
.text$mn:000037E4                 ;org 37E4h
.text$mn:000037E4 ; COMDAT (pick any)
.text$mn:000037E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037E4
.text$mn:000037E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000037E4
.text$mn:000037E4 ; Attributes: bp-based frame
.text$mn:000037E4
.text$mn:000037E4 ; public: class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> & __thiscall std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>::operator+=(int)
.text$mn:000037E4                 public ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:000037E4 ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:000037E4                                         ; CODE XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+(int)+49p
.text$mn:000037E4                                         ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator-=(int)+10p
.text$mn:000037E4
.text$mn:000037E4 var_4           = dword ptr -4
.text$mn:000037E4 arg_0           = dword ptr  8
.text$mn:000037E4
.text$mn:000037E4                 push    ebp
.text$mn:000037E5                 mov     ebp, esp
.text$mn:000037E7                 push    ecx
.text$mn:000037E8                 mov     [ebp+var_4], ecx
.text$mn:000037EB                 mov     eax, [ebp+var_4]
.text$mn:000037EE                 mov     ecx, [eax+8]
.text$mn:000037F1                 add     ecx, [ebp+arg_0]
.text$mn:000037F4                 mov     edx, [ebp+var_4]
.text$mn:000037F7                 mov     [edx+8], ecx
.text$mn:000037FA                 mov     eax, [ebp+var_4]
.text$mn:000037FD                 mov     esp, ebp
.text$mn:000037FF                 pop     ebp
.text$mn:00003800                 retn    4
.text$mn:00003800 ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00003800
.text$mn:00003800 ; ---------------------------------------------------------------------------
.text$mn:00003803                 align 4
.text$mn:00003803 _text$mn        ends
.text$mn:00003803
.text$mn:00003804 ; ===========================================================================
.text$mn:00003804
.text$mn:00003804 ; Segment type: Pure code
.text$mn:00003804 ; Segment permissions: Read/Execute
.text$mn:00003804 _text$mn        segment para public 'CODE' use32
.text$mn:00003804                 assume cs:_text$mn
.text$mn:00003804                 ;org 3804h
.text$mn:00003804 ; COMDAT (pick any)
.text$mn:00003804                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003804
.text$mn:00003804 ; =============== S U B R O U T I N E =======================================
.text$mn:00003804
.text$mn:00003804 ; Attributes: bp-based frame
.text$mn:00003804
.text$mn:00003804 ; public: class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> & __thiscall std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>::operator-=(int)
.text$mn:00003804                 public ??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00003804 ??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00003804                                         ; CODE XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator-(int)+49p
.text$mn:00003804
.text$mn:00003804 var_4           = dword ptr -4
.text$mn:00003804 arg_0           = dword ptr  8
.text$mn:00003804
.text$mn:00003804                 push    ebp
.text$mn:00003805                 mov     ebp, esp
.text$mn:00003807                 push    ecx
.text$mn:00003808                 mov     [ebp+var_4], ecx
.text$mn:0000380B                 mov     eax, [ebp+arg_0]
.text$mn:0000380E                 neg     eax
.text$mn:00003810                 push    eax
.text$mn:00003811                 mov     ecx, [ebp+var_4]
.text$mn:00003814                 call    ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+=(int)
.text$mn:00003819                 mov     esp, ebp
.text$mn:0000381B                 pop     ebp
.text$mn:0000381C                 retn    4
.text$mn:0000381C ??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:0000381C
.text$mn:0000381C ; ---------------------------------------------------------------------------
.text$mn:0000381F                 align 10h
.text$mn:0000381F _text$mn        ends
.text$mn:0000381F
.text$mn:00003820 ; ===========================================================================
.text$mn:00003820
.text$mn:00003820 ; Segment type: Pure code
.text$mn:00003820 ; Segment permissions: Read/Execute
.text$mn:00003820 _text$mn        segment para public 'CODE' use32
.text$mn:00003820                 assume cs:_text$mn
.text$mn:00003820                 ;org 3820h
.text$mn:00003820 ; COMDAT (pick any)
.text$mn:00003820                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003820
.text$mn:00003820 ; =============== S U B R O U T I N E =======================================
.text$mn:00003820
.text$mn:00003820 ; Attributes: bp-based frame
.text$mn:00003820
.text$mn:00003820 ; public: void * __thiscall RecentItem::`scalar deleting destructor'(unsigned int)
.text$mn:00003820                 public ??_GRecentItem@@QAEPAXI@Z
.text$mn:00003820 ??_GRecentItem@@QAEPAXI@Z proc near     ; CODE XREF: std::allocator<RecentItem>::destroy<RecentItem>(RecentItem *)+Cp
.text$mn:00003820
.text$mn:00003820 var_4           = dword ptr -4
.text$mn:00003820 arg_0           = dword ptr  8
.text$mn:00003820
.text$mn:00003820                 push    ebp
.text$mn:00003821                 mov     ebp, esp
.text$mn:00003823                 push    ecx
.text$mn:00003824                 mov     [ebp+var_4], ecx
.text$mn:00003827                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000382A                 call    ??1RecentItem@@QAE@XZ ; RecentItem::~RecentItem(void)
.text$mn:0000382F                 mov     eax, [ebp+arg_0]
.text$mn:00003832                 and     eax, 1
.text$mn:00003835                 jz      short loc_3843
.text$mn:00003837                 mov     ecx, [ebp+var_4]
.text$mn:0000383A                 push    ecx             ; void *
.text$mn:0000383B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003840                 add     esp, 4
.text$mn:00003843
.text$mn:00003843 loc_3843:                               ; CODE XREF: RecentItem::`scalar deleting destructor'(uint)+15j
.text$mn:00003843                 mov     eax, [ebp+var_4]
.text$mn:00003846                 mov     esp, ebp
.text$mn:00003848                 pop     ebp
.text$mn:00003849                 retn    4
.text$mn:00003849 ??_GRecentItem@@QAEPAXI@Z endp
.text$mn:00003849
.text$mn:00003849 _text$mn        ends
.text$mn:00003849
.text$mn:0000384C ; ===========================================================================
.text$mn:0000384C
.text$mn:0000384C ; Segment type: Pure code
.text$mn:0000384C ; Segment permissions: Read/Execute
.text$mn:0000384C _text$mn        segment para public 'CODE' use32
.text$mn:0000384C                 assume cs:_text$mn
.text$mn:0000384C                 ;org 384Ch
.text$mn:0000384C ; COMDAT (pick any)
.text$mn:0000384C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000384C
.text$mn:0000384C ; =============== S U B R O U T I N E =======================================
.text$mn:0000384C
.text$mn:0000384C ; Attributes: bp-based frame
.text$mn:0000384C
.text$mn:0000384C ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000384C                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:0000384C ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000384C
.text$mn:0000384C var_4           = dword ptr -4
.text$mn:0000384C arg_0           = dword ptr  8
.text$mn:0000384C
.text$mn:0000384C                 push    ebp
.text$mn:0000384D                 mov     ebp, esp
.text$mn:0000384F                 push    ecx
.text$mn:00003850                 mov     [ebp+var_4], ecx
.text$mn:00003853                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003856                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000385B                 mov     eax, [ebp+arg_0]
.text$mn:0000385E                 and     eax, 1
.text$mn:00003861                 jz      short loc_386F
.text$mn:00003863                 mov     ecx, [ebp+var_4]
.text$mn:00003866                 push    ecx             ; void *
.text$mn:00003867                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000386C                 add     esp, 4
.text$mn:0000386F
.text$mn:0000386F loc_386F:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000386F                 mov     eax, [ebp+var_4]
.text$mn:00003872                 mov     esp, ebp
.text$mn:00003874                 pop     ebp
.text$mn:00003875                 retn    4
.text$mn:00003875 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00003875
.text$mn:00003875 _text$mn        ends
.text$mn:00003875
.text$mn:00003878 ; ===========================================================================
.text$mn:00003878
.text$mn:00003878 ; Segment type: Pure code
.text$mn:00003878 ; Segment permissions: Read/Execute
.text$mn:00003878 _text$mn        segment para public 'CODE' use32
.text$mn:00003878                 assume cs:_text$mn
.text$mn:00003878                 ;org 3878h
.text$mn:00003878 ; COMDAT (pick any)
.text$mn:00003878                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003878
.text$mn:00003878 ; =============== S U B R O U T I N E =======================================
.text$mn:00003878
.text$mn:00003878 ; Attributes: bp-based frame
.text$mn:00003878
.text$mn:00003878 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00003878                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00003878 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00003878
.text$mn:00003878 var_4           = dword ptr -4
.text$mn:00003878 arg_0           = dword ptr  8
.text$mn:00003878
.text$mn:00003878                 push    ebp
.text$mn:00003879                 mov     ebp, esp
.text$mn:0000387B                 push    ecx
.text$mn:0000387C                 mov     [ebp+var_4], ecx
.text$mn:0000387F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003882                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00003887                 mov     eax, [ebp+arg_0]
.text$mn:0000388A                 and     eax, 1
.text$mn:0000388D                 jz      short loc_389B
.text$mn:0000388F                 mov     ecx, [ebp+var_4]
.text$mn:00003892                 push    ecx             ; void *
.text$mn:00003893                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003898                 add     esp, 4
.text$mn:0000389B
.text$mn:0000389B loc_389B:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000389B                 mov     eax, [ebp+var_4]
.text$mn:0000389E                 mov     esp, ebp
.text$mn:000038A0                 pop     ebp
.text$mn:000038A1                 retn    4
.text$mn:000038A1 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:000038A1
.text$mn:000038A1 _text$mn        ends
.text$mn:000038A1
.text$mn:000038A4 ; ===========================================================================
.text$mn:000038A4
.text$mn:000038A4 ; Segment type: Pure code
.text$mn:000038A4 ; Segment permissions: Read/Execute
.text$mn:000038A4 _text$mn        segment para public 'CODE' use32
.text$mn:000038A4                 assume cs:_text$mn
.text$mn:000038A4                 ;org 38A4h
.text$mn:000038A4 ; COMDAT (pick any)
.text$mn:000038A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038A4
.text$mn:000038A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000038A4
.text$mn:000038A4 ; Attributes: bp-based frame
.text$mn:000038A4
.text$mn:000038A4 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000038A4                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:000038A4 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:000038A4
.text$mn:000038A4 var_4           = dword ptr -4
.text$mn:000038A4 arg_0           = dword ptr  8
.text$mn:000038A4
.text$mn:000038A4                 push    ebp
.text$mn:000038A5                 mov     ebp, esp
.text$mn:000038A7                 push    ecx
.text$mn:000038A8                 mov     [ebp+var_4], ecx
.text$mn:000038AB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000038AE                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:000038B3                 mov     eax, [ebp+arg_0]
.text$mn:000038B6                 and     eax, 1
.text$mn:000038B9                 jz      short loc_38C7
.text$mn:000038BB                 mov     ecx, [ebp+var_4]
.text$mn:000038BE                 push    ecx             ; void *
.text$mn:000038BF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000038C4                 add     esp, 4
.text$mn:000038C7
.text$mn:000038C7 loc_38C7:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000038C7                 mov     eax, [ebp+var_4]
.text$mn:000038CA                 mov     esp, ebp
.text$mn:000038CC                 pop     ebp
.text$mn:000038CD                 retn    4
.text$mn:000038CD ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:000038CD
.text$mn:000038CD _text$mn        ends
.text$mn:000038CD
.text$mn:000038D0 ; ===========================================================================
.text$mn:000038D0
.text$mn:000038D0 ; Segment type: Pure code
.text$mn:000038D0 ; Segment permissions: Read/Execute
.text$mn:000038D0 _text$mn        segment para public 'CODE' use32
.text$mn:000038D0                 assume cs:_text$mn
.text$mn:000038D0                 ;org 38D0h
.text$mn:000038D0 ; COMDAT (pick any)
.text$mn:000038D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038D0
.text$mn:000038D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000038D0
.text$mn:000038D0 ; Attributes: bp-based frame
.text$mn:000038D0
.text$mn:000038D0 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000038D0                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:000038D0 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:000038D0
.text$mn:000038D0 var_4           = dword ptr -4
.text$mn:000038D0 arg_0           = dword ptr  8
.text$mn:000038D0
.text$mn:000038D0                 push    ebp
.text$mn:000038D1                 mov     ebp, esp
.text$mn:000038D3                 push    ecx
.text$mn:000038D4                 mov     [ebp+var_4], ecx
.text$mn:000038D7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000038DA                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000038DF                 mov     eax, [ebp+arg_0]
.text$mn:000038E2                 and     eax, 1
.text$mn:000038E5                 jz      short loc_38F3
.text$mn:000038E7                 mov     ecx, [ebp+var_4]
.text$mn:000038EA                 push    ecx             ; void *
.text$mn:000038EB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000038F0                 add     esp, 4
.text$mn:000038F3
.text$mn:000038F3 loc_38F3:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000038F3                 mov     eax, [ebp+var_4]
.text$mn:000038F6                 mov     esp, ebp
.text$mn:000038F8                 pop     ebp
.text$mn:000038F9                 retn    4
.text$mn:000038F9 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:000038F9
.text$mn:000038F9 _text$mn        ends
.text$mn:000038F9
.text$di:000038FC ; ===========================================================================
.text$di:000038FC
.text$di:000038FC ; Segment type: Pure code
.text$di:000038FC ; Segment permissions: Read/Execute
.text$di:000038FC _text$di        segment para public 'CODE' use32
.text$di:000038FC                 assume cs:_text$di
.text$di:000038FC                 ;org 38FCh
.text$di:000038FC ; COMDAT (pick any)
.text$di:000038FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000038FC
.text$di:000038FC ; =============== S U B R O U T I N E =======================================
.text$di:000038FC
.text$di:000038FC ; Attributes: bp-based frame
.text$di:000038FC
.text$di:000038FC ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:000038FC ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:000038FC                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:000038FC                 push    ebp
.text$di:000038FD                 mov     ebp, esp
.text$di:000038FF                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00003904                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00003909                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000390E                 call    _atexit
.text$di:00003913                 add     esp, 4
.text$di:00003916                 pop     ebp
.text$di:00003917                 retn
.text$di:00003917 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00003917
.text$di:00003917 _text$di        ends
.text$di:00003917
.text$di:00003918 ; ===========================================================================
.text$di:00003918
.text$di:00003918 ; Segment type: Pure code
.text$di:00003918 ; Segment permissions: Read/Execute
.text$di:00003918 _text$di        segment para public 'CODE' use32
.text$di:00003918                 assume cs:_text$di
.text$di:00003918                 ;org 3918h
.text$di:00003918 ; COMDAT (pick any)
.text$di:00003918                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003918
.text$di:00003918 ; =============== S U B R O U T I N E =======================================
.text$di:00003918
.text$di:00003918 ; Attributes: bp-based frame
.text$di:00003918
.text$di:00003918 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00003918 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00003918                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00003918                 push    ebp
.text$di:00003919                 mov     ebp, esp
.text$di:0000391B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00003920                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00003925                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000392A                 call    _atexit
.text$di:0000392F                 add     esp, 4
.text$di:00003932                 pop     ebp
.text$di:00003933                 retn
.text$di:00003933 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00003933
.text$di:00003933 _text$di        ends
.text$di:00003933
.text$di:00003934 ; ===========================================================================
.text$di:00003934
.text$di:00003934 ; Segment type: Pure code
.text$di:00003934 ; Segment permissions: Read/Execute
.text$di:00003934 _text$di        segment para public 'CODE' use32
.text$di:00003934                 assume cs:_text$di
.text$di:00003934                 ;org 3934h
.text$di:00003934 ; COMDAT (pick any)
.text$di:00003934                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003934
.text$di:00003934 ; =============== S U B R O U T I N E =======================================
.text$di:00003934
.text$di:00003934 ; Attributes: bp-based frame
.text$di:00003934
.text$di:00003934 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00003934 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00003934                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00003934                 push    ebp
.text$di:00003935                 mov     ebp, esp
.text$di:00003937                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:0000393C                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00003941                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00003946                 call    _atexit
.text$di:0000394B                 add     esp, 4
.text$di:0000394E                 pop     ebp
.text$di:0000394F                 retn
.text$di:0000394F ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:0000394F
.text$di:0000394F _text$di        ends
.text$di:0000394F
.text$di:00003950 ; ===========================================================================
.text$di:00003950
.text$di:00003950 ; Segment type: Pure code
.text$di:00003950 ; Segment permissions: Read/Execute
.text$di:00003950 _text$di        segment para public 'CODE' use32
.text$di:00003950                 assume cs:_text$di
.text$di:00003950                 ;org 3950h
.text$di:00003950 ; COMDAT (pick any)
.text$di:00003950                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003950
.text$di:00003950 ; =============== S U B R O U T I N E =======================================
.text$di:00003950
.text$di:00003950 ; Attributes: bp-based frame
.text$di:00003950
.text$di:00003950 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00003950 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00003950                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00003950                 push    ebp
.text$di:00003951                 mov     ebp, esp
.text$di:00003953                 push    0               ; unsigned int
.text$di:00003955                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000395A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000395F                 pop     ebp
.text$di:00003960                 retn
.text$di:00003960 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00003960
.text$di:00003960 ; ---------------------------------------------------------------------------
.text$di:00003961                 align 4
.text$di:00003961 _text$di        ends
.text$di:00003961
.text$di:00003964 ; ===========================================================================
.text$di:00003964
.text$di:00003964 ; Segment type: Pure code
.text$di:00003964 ; Segment permissions: Read/Execute
.text$di:00003964 _text$di        segment para public 'CODE' use32
.text$di:00003964                 assume cs:_text$di
.text$di:00003964                 ;org 3964h
.text$di:00003964 ; COMDAT (pick any)
.text$di:00003964                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003964
.text$di:00003964 ; =============== S U B R O U T I N E =======================================
.text$di:00003964
.text$di:00003964 ; Attributes: bp-based frame
.text$di:00003964
.text$di:00003964 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00003964 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00003964                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00003964                 push    ebp
.text$di:00003965                 mov     ebp, esp
.text$di:00003967                 push    0               ; unsigned int
.text$di:00003969                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000396E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00003973                 pop     ebp
.text$di:00003974                 retn
.text$di:00003974 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00003974
.text$di:00003974 ; ---------------------------------------------------------------------------
.text$di:00003975                 align 4
.text$di:00003975 _text$di        ends
.text$di:00003975
.text$di:00003978 ; ===========================================================================
.text$di:00003978
.text$di:00003978 ; Segment type: Pure code
.text$di:00003978 ; Segment permissions: Read/Execute
.text$di:00003978 _text$di        segment para public 'CODE' use32
.text$di:00003978                 assume cs:_text$di
.text$di:00003978                 ;org 3978h
.text$di:00003978 ; COMDAT (pick any)
.text$di:00003978                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003978
.text$di:00003978 ; =============== S U B R O U T I N E =======================================
.text$di:00003978
.text$di:00003978 ; Attributes: bp-based frame
.text$di:00003978
.text$di:00003978 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00003978 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00003978                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00003978                 push    ebp
.text$di:00003979                 mov     ebp, esp
.text$di:0000397B                 push    0               ; unsigned int
.text$di:0000397D                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00003982                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00003987                 pop     ebp
.text$di:00003988                 retn
.text$di:00003988 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00003988
.text$di:00003988 ; ---------------------------------------------------------------------------
.text$di:00003989                 align 4
.text$di:00003989 _text$di        ends
.text$di:00003989
.text$di:0000398C ; ===========================================================================
.text$di:0000398C
.text$di:0000398C ; Segment type: Pure code
.text$di:0000398C ; Segment permissions: Read/Execute
.text$di:0000398C _text$di        segment para public 'CODE' use32
.text$di:0000398C                 assume cs:_text$di
.text$di:0000398C                 ;org 398Ch
.text$di:0000398C ; COMDAT (pick any)
.text$di:0000398C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000398C
.text$di:0000398C ; =============== S U B R O U T I N E =======================================
.text$di:0000398C
.text$di:0000398C ; Attributes: bp-based frame
.text$di:0000398C
.text$di:0000398C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:0000398C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000398C                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:0000398C                 push    ebp
.text$di:0000398D                 mov     ebp, esp
.text$di:0000398F                 push    0               ; unsigned int
.text$di:00003991                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00003996                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000399B                 pop     ebp
.text$di:0000399C                 retn
.text$di:0000399C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000399C
.text$di:0000399C ; ---------------------------------------------------------------------------
.text$di:0000399D                 align 10h
.text$di:0000399D _text$di        ends
.text$di:0000399D
.text$di:000039A0 ; ===========================================================================
.text$di:000039A0
.text$di:000039A0 ; Segment type: Pure code
.text$di:000039A0 ; Segment permissions: Read/Execute
.text$di:000039A0 _text$di        segment para public 'CODE' use32
.text$di:000039A0                 assume cs:_text$di
.text$di:000039A0                 ;org 39A0h
.text$di:000039A0 ; COMDAT (pick any)
.text$di:000039A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000039A0
.text$di:000039A0 ; =============== S U B R O U T I N E =======================================
.text$di:000039A0
.text$di:000039A0 ; Attributes: bp-based frame
.text$di:000039A0
.text$di:000039A0 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:000039A0 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:000039A0
.text$di:000039A0 var_1           = byte ptr -1
.text$di:000039A0
.text$di:000039A0                 push    ebp
.text$di:000039A1                 mov     ebp, esp
.text$di:000039A3                 push    ecx
.text$di:000039A4                 xor     eax, eax
.text$di:000039A6                 mov     [ebp+var_1], al
.text$di:000039A9                 mov     esp, ebp
.text$di:000039AB                 pop     ebp
.text$di:000039AC                 retn
.text$di:000039AC ??__Eallocator_arg@std@@YAXXZ endp
.text$di:000039AC
.text$di:000039AC ; ---------------------------------------------------------------------------
.text$di:000039AD                 align 10h
.text$di:000039AD _text$di        ends
.text$di:000039AD
.text$di:000039B0 ; ===========================================================================
.text$di:000039B0
.text$di:000039B0 ; Segment type: Pure code
.text$di:000039B0 ; Segment permissions: Read/Execute
.text$di:000039B0 _text$di        segment para public 'CODE' use32
.text$di:000039B0                 assume cs:_text$di
.text$di:000039B0                 ;org 39B0h
.text$di:000039B0 ; COMDAT (pick any)
.text$di:000039B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000039B0
.text$di:000039B0 ; =============== S U B R O U T I N E =======================================
.text$di:000039B0
.text$di:000039B0 ; Attributes: bp-based frame
.text$di:000039B0
.text$di:000039B0 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:000039B0 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:000039B0                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:000039B0
.text$di:000039B0 var_1           = byte ptr -1
.text$di:000039B0
.text$di:000039B0                 push    ebp
.text$di:000039B1                 mov     ebp, esp
.text$di:000039B3                 push    ecx
.text$di:000039B4                 xor     eax, eax
.text$di:000039B6                 mov     [ebp+var_1], al
.text$di:000039B9                 mov     esp, ebp
.text$di:000039BB                 pop     ebp
.text$di:000039BC                 retn
.text$di:000039BC ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:000039BC
.text$di:000039BC ; ---------------------------------------------------------------------------
.text$di:000039BD                 align 10h
.text$di:000039BD _text$di        ends
.text$di:000039BD
.text$yd:000039C0 ; ===========================================================================
.text$yd:000039C0
.text$yd:000039C0 ; Segment type: Pure code
.text$yd:000039C0 ; Segment permissions: Read/Execute
.text$yd:000039C0 _text$yd        segment para public 'CODE' use32
.text$yd:000039C0                 assume cs:_text$yd
.text$yd:000039C0                 ;org 39C0h
.text$yd:000039C0 ; COMDAT (pick any)
.text$yd:000039C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000039C0
.text$yd:000039C0 ; =============== S U B R O U T I N E =======================================
.text$yd:000039C0
.text$yd:000039C0 ; Attributes: bp-based frame
.text$yd:000039C0
.text$yd:000039C0 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:000039C0 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:000039C0                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:000039C0                 push    ebp
.text$yd:000039C1                 mov     ebp, esp
.text$yd:000039C3                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:000039C8                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:000039CD                 pop     ebp
.text$yd:000039CE                 retn
.text$yd:000039CE ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:000039CE
.text$yd:000039CE ; ---------------------------------------------------------------------------
.text$yd:000039CF                 align 10h
.text$yd:000039CF _text$yd        ends
.text$yd:000039CF
.text$yd:000039D0 ; ===========================================================================
.text$yd:000039D0
.text$yd:000039D0 ; Segment type: Pure code
.text$yd:000039D0 ; Segment permissions: Read/Execute
.text$yd:000039D0 _text$yd        segment para public 'CODE' use32
.text$yd:000039D0                 assume cs:_text$yd
.text$yd:000039D0                 ;org 39D0h
.text$yd:000039D0 ; COMDAT (pick any)
.text$yd:000039D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000039D0
.text$yd:000039D0 ; =============== S U B R O U T I N E =======================================
.text$yd:000039D0
.text$yd:000039D0 ; Attributes: bp-based frame
.text$yd:000039D0
.text$yd:000039D0 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:000039D0 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:000039D0                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:000039D0                 push    ebp
.text$yd:000039D1                 mov     ebp, esp
.text$yd:000039D3                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:000039D8                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:000039DD                 pop     ebp
.text$yd:000039DE                 retn
.text$yd:000039DE ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:000039DE
.text$yd:000039DE ; ---------------------------------------------------------------------------
.text$yd:000039DF                 align 10h
.text$yd:000039DF _text$yd        ends
.text$yd:000039DF
.text$yd:000039E0 ; ===========================================================================
.text$yd:000039E0
.text$yd:000039E0 ; Segment type: Pure code
.text$yd:000039E0 ; Segment permissions: Read/Execute
.text$yd:000039E0 _text$yd        segment para public 'CODE' use32
.text$yd:000039E0                 assume cs:_text$yd
.text$yd:000039E0                 ;org 39E0h
.text$yd:000039E0 ; COMDAT (pick any)
.text$yd:000039E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000039E0
.text$yd:000039E0 ; =============== S U B R O U T I N E =======================================
.text$yd:000039E0
.text$yd:000039E0 ; Attributes: bp-based frame
.text$yd:000039E0
.text$yd:000039E0 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:000039E0 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:000039E0                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:000039E0                 push    ebp
.text$yd:000039E1                 mov     ebp, esp
.text$yd:000039E3                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:000039E8                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:000039ED                 pop     ebp
.text$yd:000039EE                 retn
.text$yd:000039EE ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:000039EE
.text$yd:000039EE ; ---------------------------------------------------------------------------
.text$yd:000039EF                 align 10h
.text$yd:000039EF _text$yd        ends
.text$yd:000039EF
.text$mn:000039F0 ; ===========================================================================
.text$mn:000039F0
.text$mn:000039F0 ; Segment type: Pure code
.text$mn:000039F0 ; Segment permissions: Read/Execute
.text$mn:000039F0 _text$mn        segment para public 'CODE' use32
.text$mn:000039F0                 assume cs:_text$mn
.text$mn:000039F0                 ;org 39F0h
.text$mn:000039F0 ; COMDAT (pick any)
.text$mn:000039F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000039F0
.text$mn:000039F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000039F0
.text$mn:000039F0 ; Attributes: bp-based frame
.text$mn:000039F0
.text$mn:000039F0 ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:000039F0                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:000039F0 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:000039F0                                         ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+49p
.text$mn:000039F0                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Setcont(std::_Deque_val<std::_Deque_simple_types<RecentItem>> const *)+Ep
.text$mn:000039F0
.text$mn:000039F0 var_1C          = byte ptr -1Ch
.text$mn:000039F0 var_18          = byte ptr -18h
.text$mn:000039F0 var_14          = dword ptr -14h
.text$mn:000039F0 var_10          = dword ptr -10h
.text$mn:000039F0 var_C           = dword ptr -0Ch
.text$mn:000039F0 var_4           = dword ptr -4
.text$mn:000039F0 arg_0           = dword ptr  8
.text$mn:000039F0
.text$mn:000039F0                 push    ebp
.text$mn:000039F1                 mov     ebp, esp
.text$mn:000039F3                 push    0FFFFFFFFh
.text$mn:000039F5                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:000039FA                 mov     eax, large fs:0
.text$mn:00003A00                 push    eax
.text$mn:00003A01                 sub     esp, 10h
.text$mn:00003A04                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003A09                 xor     eax, ebp
.text$mn:00003A0B                 push    eax
.text$mn:00003A0C                 lea     eax, [ebp+var_C]
.text$mn:00003A0F                 mov     large fs:0, eax
.text$mn:00003A15                 mov     [ebp+var_10], ecx
.text$mn:00003A18                 cmp     [ebp+arg_0], 0
.text$mn:00003A1C                 jnz     short loc_3A48
.text$mn:00003A1E                 push    3               ; int
.text$mn:00003A20                 lea     ecx, [ebp+var_18] ; this
.text$mn:00003A23                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00003A28                 mov     [ebp+var_4], 0
.text$mn:00003A2F                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003A32                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00003A37                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003A3E                 lea     ecx, [ebp+var_18] ; this
.text$mn:00003A41                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00003A46                 jmp     short loc_3A9F
.text$mn:00003A48 ; ---------------------------------------------------------------------------
.text$mn:00003A48
.text$mn:00003A48 loc_3A48:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:00003A48                 mov     eax, [ebp+arg_0]
.text$mn:00003A4B                 mov     ecx, [eax]
.text$mn:00003A4D                 mov     [ebp+var_14], ecx
.text$mn:00003A50                 mov     edx, [ebp+var_10]
.text$mn:00003A53                 mov     eax, [edx]
.text$mn:00003A55                 cmp     eax, [ebp+var_14]
.text$mn:00003A58                 jz      short loc_3A9F
.text$mn:00003A5A                 push    3               ; int
.text$mn:00003A5C                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00003A5F                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00003A64                 mov     [ebp+var_4], 1
.text$mn:00003A6B                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003A6E                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00003A73                 mov     ecx, [ebp+var_10]
.text$mn:00003A76                 mov     edx, [ebp+var_14]
.text$mn:00003A79                 mov     eax, [edx+4]
.text$mn:00003A7C                 mov     [ecx+4], eax
.text$mn:00003A7F                 mov     ecx, [ebp+var_14]
.text$mn:00003A82                 mov     edx, [ebp+var_10]
.text$mn:00003A85                 mov     [ecx+4], edx
.text$mn:00003A88                 mov     eax, [ebp+var_10]
.text$mn:00003A8B                 mov     ecx, [ebp+var_14]
.text$mn:00003A8E                 mov     [eax], ecx
.text$mn:00003A90                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003A97                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00003A9A                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00003A9F
.text$mn:00003A9F loc_3A9F:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:00003A9F                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:00003A9F                 mov     ecx, [ebp+var_C]
.text$mn:00003AA2                 mov     large fs:0, ecx
.text$mn:00003AA9                 pop     ecx
.text$mn:00003AAA                 mov     esp, ebp
.text$mn:00003AAC                 pop     ebp
.text$mn:00003AAD                 retn    4
.text$mn:00003AAD ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:00003AAD
.text$mn:00003AAD _text$mn        ends
.text$mn:00003AAD
.text$x:00003AB0 ; ===========================================================================
.text$x:00003AB0
.text$x:00003AB0 ; Segment type: Pure code
.text$x:00003AB0 ; Segment permissions: Read/Execute
.text$x:00003AB0 _text$x         segment para public 'CODE' use32
.text$x:00003AB0                 assume cs:_text$x
.text$x:00003AB0                 ;org 3AB0h
.text$x:00003AB0 ; COMDAT (pick associative to section at 39F0)
.text$x:00003AB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003AB0
.text$x:00003AB0 ; =============== S U B R O U T I N E =======================================
.text$x:00003AB0
.text$x:00003AB0
.text$x:00003AB0 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:00003AB0                                         ; DATA XREF: .xdata$x:000068B4o
.text$x:00003AB0                 lea     ecx, [ebp-18h]  ; this
.text$x:00003AB3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00003AB3 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:00003AB3
.text$x:00003AB8
.text$x:00003AB8 ; =============== S U B R O U T I N E =======================================
.text$x:00003AB8
.text$x:00003AB8
.text$x:00003AB8 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:00003AB8                                         ; DATA XREF: .xdata$x:000068BCo
.text$x:00003AB8                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00003ABB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00003ABB __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:00003ABB
.text$x:00003AC0
.text$x:00003AC0 ; =============== S U B R O U T I N E =======================================
.text$x:00003AC0
.text$x:00003AC0
.text$x:00003AC0 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:00003AC0                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:00003AC0
.text$x:00003AC0 arg_4           = dword ptr  8
.text$x:00003AC0
.text$x:00003AC0                 mov     edx, [esp+arg_4]
.text$x:00003AC4                 lea     eax, [edx+0Ch]
.text$x:00003AC7                 mov     ecx, [edx-14h]
.text$x:00003ACA                 xor     ecx, eax
.text$x:00003ACC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003AD1                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:00003AD6                 jmp     ___CxxFrameHandler3
.text$x:00003AD6 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:00003AD6
.text$x:00003AD6 ; ---------------------------------------------------------------------------
.text$x:00003ADB                 align 4
.text$x:00003ADB _text$x         ends
.text$x:00003ADB
.text$mn:00003ADC ; ===========================================================================
.text$mn:00003ADC
.text$mn:00003ADC ; Segment type: Pure code
.text$mn:00003ADC ; Segment permissions: Read/Execute
.text$mn:00003ADC _text$mn        segment para public 'CODE' use32
.text$mn:00003ADC                 assume cs:_text$mn
.text$mn:00003ADC                 ;org 3ADCh
.text$mn:00003ADC ; COMDAT (pick any)
.text$mn:00003ADC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003ADC
.text$mn:00003ADC ; =============== S U B R O U T I N E =======================================
.text$mn:00003ADC
.text$mn:00003ADC ; Attributes: bp-based frame
.text$mn:00003ADC
.text$mn:00003ADC ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00003ADC                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00003ADC ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00003ADC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00003ADC
.text$mn:00003ADC var_10          = byte ptr -10h
.text$mn:00003ADC var_8           = dword ptr -8
.text$mn:00003ADC var_1           = byte ptr -1
.text$mn:00003ADC
.text$mn:00003ADC                 push    ebp
.text$mn:00003ADD                 mov     ebp, esp
.text$mn:00003ADF                 sub     esp, 10h
.text$mn:00003AE2                 mov     [ebp+var_8], ecx
.text$mn:00003AE5                 lea     ecx, [ebp+var_1]
.text$mn:00003AE8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00003AED                 push    1
.text$mn:00003AEF                 lea     ecx, [ebp+var_1]
.text$mn:00003AF2                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00003AF7                 mov     ecx, [ebp+var_8]
.text$mn:00003AFA                 mov     [ecx], eax
.text$mn:00003AFC                 lea     ecx, [ebp+var_10] ; this
.text$mn:00003AFF                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00003B04                 push    eax             ; int
.text$mn:00003B05                 mov     edx, [ebp+var_8]
.text$mn:00003B08                 mov     eax, [edx]
.text$mn:00003B0A                 push    eax             ; void *
.text$mn:00003B0B                 lea     ecx, [ebp+var_1]
.text$mn:00003B0E                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00003B13                 mov     ecx, [ebp+var_8]
.text$mn:00003B16                 mov     edx, [ecx]
.text$mn:00003B18                 mov     eax, [ebp+var_8]
.text$mn:00003B1B                 mov     [edx], eax
.text$mn:00003B1D                 mov     esp, ebp
.text$mn:00003B1F                 pop     ebp
.text$mn:00003B20                 retn
.text$mn:00003B20 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00003B20
.text$mn:00003B20 ; ---------------------------------------------------------------------------
.text$mn:00003B21                 align 4
.text$mn:00003B21 _text$mn        ends
.text$mn:00003B21
.text$mn:00003B24 ; ===========================================================================
.text$mn:00003B24
.text$mn:00003B24 ; Segment type: Pure code
.text$mn:00003B24 ; Segment permissions: Read/Execute
.text$mn:00003B24 _text$mn        segment para public 'CODE' use32
.text$mn:00003B24                 assume cs:_text$mn
.text$mn:00003B24                 ;org 3B24h
.text$mn:00003B24 ; COMDAT (pick any)
.text$mn:00003B24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B24
.text$mn:00003B24 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B24
.text$mn:00003B24 ; Attributes: bp-based frame
.text$mn:00003B24
.text$mn:00003B24 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00003B24                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00003B24 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00003B24                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:00003B24
.text$mn:00003B24 var_10          = byte ptr -10h
.text$mn:00003B24 var_8           = dword ptr -8
.text$mn:00003B24 var_1           = byte ptr -1
.text$mn:00003B24
.text$mn:00003B24                 push    ebp
.text$mn:00003B25                 mov     ebp, esp
.text$mn:00003B27                 sub     esp, 10h
.text$mn:00003B2A                 mov     [ebp+var_8], ecx
.text$mn:00003B2D                 lea     ecx, [ebp+var_1]
.text$mn:00003B30                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00003B35                 push    1
.text$mn:00003B37                 lea     ecx, [ebp+var_1]
.text$mn:00003B3A                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00003B3F                 mov     ecx, [ebp+var_8]
.text$mn:00003B42                 mov     [ecx], eax
.text$mn:00003B44                 lea     ecx, [ebp+var_10] ; this
.text$mn:00003B47                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00003B4C                 push    eax             ; int
.text$mn:00003B4D                 mov     edx, [ebp+var_8]
.text$mn:00003B50                 mov     eax, [edx]
.text$mn:00003B52                 push    eax             ; void *
.text$mn:00003B53                 lea     ecx, [ebp+var_1]
.text$mn:00003B56                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00003B5B                 mov     ecx, [ebp+var_8]
.text$mn:00003B5E                 mov     edx, [ecx]
.text$mn:00003B60                 mov     eax, [ebp+var_8]
.text$mn:00003B63                 mov     [edx], eax
.text$mn:00003B65                 mov     esp, ebp
.text$mn:00003B67                 pop     ebp
.text$mn:00003B68                 retn
.text$mn:00003B68 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00003B68
.text$mn:00003B68 ; ---------------------------------------------------------------------------
.text$mn:00003B69                 align 4
.text$mn:00003B69 _text$mn        ends
.text$mn:00003B69
.text$mn:00003B6C ; ===========================================================================
.text$mn:00003B6C
.text$mn:00003B6C ; Segment type: Pure code
.text$mn:00003B6C ; Segment permissions: Read/Execute
.text$mn:00003B6C _text$mn        segment para public 'CODE' use32
.text$mn:00003B6C                 assume cs:_text$mn
.text$mn:00003B6C                 ;org 3B6Ch
.text$mn:00003B6C ; COMDAT (pick any)
.text$mn:00003B6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B6C
.text$mn:00003B6C ; =============== S U B R O U T I N E =======================================
.text$mn:00003B6C
.text$mn:00003B6C ; Attributes: bp-based frame
.text$mn:00003B6C
.text$mn:00003B6C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Change_alloc(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:00003B6C                 public ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
.text$mn:00003B6C ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z proc near
.text$mn:00003B6C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Ap
.text$mn:00003B6C
.text$mn:00003B6C var_4           = dword ptr -4
.text$mn:00003B6C
.text$mn:00003B6C                 push    ebp
.text$mn:00003B6D                 mov     ebp, esp
.text$mn:00003B6F                 push    ecx
.text$mn:00003B70                 mov     [ebp+var_4], ecx
.text$mn:00003B73                 mov     esp, ebp
.text$mn:00003B75                 pop     ebp
.text$mn:00003B76                 retn    4
.text$mn:00003B76 ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z endp
.text$mn:00003B76
.text$mn:00003B76 ; ---------------------------------------------------------------------------
.text$mn:00003B79                 align 4
.text$mn:00003B79 _text$mn        ends
.text$mn:00003B79
.text$mn:00003B7C ; ===========================================================================
.text$mn:00003B7C
.text$mn:00003B7C ; Segment type: Pure code
.text$mn:00003B7C ; Segment permissions: Read/Execute
.text$mn:00003B7C _text$mn        segment para public 'CODE' use32
.text$mn:00003B7C                 assume cs:_text$mn
.text$mn:00003B7C                 ;org 3B7Ch
.text$mn:00003B7C ; COMDAT (pick any)
.text$mn:00003B7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B7C
.text$mn:00003B7C ; =============== S U B R O U T I N E =======================================
.text$mn:00003B7C
.text$mn:00003B7C ; Attributes: bp-based frame
.text$mn:00003B7C
.text$mn:00003B7C ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:00003B7C                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:00003B7C ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00003B7C                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint)+BDp
.text$mn:00003B7C
.text$mn:00003B7C var_4           = dword ptr -4
.text$mn:00003B7C
.text$mn:00003B7C                 push    ebp
.text$mn:00003B7D                 mov     ebp, esp
.text$mn:00003B7F                 push    ecx
.text$mn:00003B80                 mov     [ebp+var_4], ecx
.text$mn:00003B83                 mov     eax, [ebp+var_4]
.text$mn:00003B86                 mov     dword ptr [eax], 0
.text$mn:00003B8C                 mov     esp, ebp
.text$mn:00003B8E                 pop     ebp
.text$mn:00003B8F                 retn
.text$mn:00003B8F ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00003B8F
.text$mn:00003B8F _text$mn        ends
.text$mn:00003B8F
.text$mn:00003B90 ; ===========================================================================
.text$mn:00003B90
.text$mn:00003B90 ; Segment type: Pure code
.text$mn:00003B90 ; Segment permissions: Read/Execute
.text$mn:00003B90 _text$mn        segment para public 'CODE' use32
.text$mn:00003B90                 assume cs:_text$mn
.text$mn:00003B90                 ;org 3B90h
.text$mn:00003B90 ; COMDAT (pick any)
.text$mn:00003B90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B90
.text$mn:00003B90 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B90
.text$mn:00003B90 ; Attributes: bp-based frame
.text$mn:00003B90
.text$mn:00003B90 ; int __stdcall std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Compat(std::_Iterator_base12 *)
.text$mn:00003B90                 public ?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEXABV12@@Z
.text$mn:00003B90 ?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEXABV12@@Z proc near
.text$mn:00003B90                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator==(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+10p
.text$mn:00003B90                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator-(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+10p ...
.text$mn:00003B90
.text$mn:00003B90 var_8           = dword ptr -8
.text$mn:00003B90 var_4           = dword ptr -4
.text$mn:00003B90 arg_0           = dword ptr  8
.text$mn:00003B90
.text$mn:00003B90                 push    ebp
.text$mn:00003B91                 mov     ebp, esp
.text$mn:00003B93                 sub     esp, 8
.text$mn:00003B96                 mov     [ebp+var_8], ecx
.text$mn:00003B99                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003B9C                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00003BA1                 mov     [ebp+var_4], eax
.text$mn:00003BA4                 cmp     [ebp+var_4], 0
.text$mn:00003BA8                 jz      short loc_3BB7
.text$mn:00003BAA                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003BAD                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00003BB2                 cmp     [ebp+var_4], eax
.text$mn:00003BB5                 jz      short loc_3C1F
.text$mn:00003BB7
.text$mn:00003BB7 loc_3BB7:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Compat(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+18j
.text$mn:00003BB7                 push    1F5h            ; unsigned int
.text$mn:00003BBC                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003BC1                 push    offset ??_C@_1DK@CNDLFKCJ@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; "deque iterators incompatible"
.text$mn:00003BC6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003BCB                 add     esp, 0Ch
.text$mn:00003BCE                 mov     eax, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
.text$mn:00003BD3                 test    eax, eax
.text$mn:00003BD5                 jz      short loc_3BDB
.text$mn:00003BD7                 xor     ecx, ecx
.text$mn:00003BD9                 jnz     short loc_3C01
.text$mn:00003BDB
.text$mn:00003BDB loc_3BDB:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Compat(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+45j
.text$mn:00003BDB                 push    offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
.text$mn:00003BE0                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00003BE5                 push    0
.text$mn:00003BE7                 push    1F6h
.text$mn:00003BEC                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003BF1                 push    2
.text$mn:00003BF3                 call    __CrtDbgReportW
.text$mn:00003BF8                 add     esp, 18h
.text$mn:00003BFB                 cmp     eax, 1
.text$mn:00003BFE                 jnz     short loc_3C01
.text$mn:00003C00                 int     3               ; Trap to Debugger
.text$mn:00003C01
.text$mn:00003C01 loc_3C01:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Compat(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+49j
.text$mn:00003C01                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Compat(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+6Ej
.text$mn:00003C01                 push    0
.text$mn:00003C03                 push    1F6h
.text$mn:00003C08                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003C0D                 push    offset ??_C@_1OC@KALAPKNE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; "std::_Deque_const_iterator<class std::_"...
.text$mn:00003C12                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:00003C17                 call    __invalid_parameter
.text$mn:00003C1C                 add     esp, 14h
.text$mn:00003C1F
.text$mn:00003C1F loc_3C1F:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Compat(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+25j
.text$mn:00003C1F                 mov     esp, ebp
.text$mn:00003C21                 pop     ebp
.text$mn:00003C22                 retn    4
.text$mn:00003C22 ?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEXABV12@@Z endp
.text$mn:00003C22
.text$mn:00003C22 ; ---------------------------------------------------------------------------
.text$mn:00003C25                 align 4
.text$mn:00003C25 _text$mn        ends
.text$mn:00003C25
.text$mn:00003C28 ; ===========================================================================
.text$mn:00003C28
.text$mn:00003C28 ; Segment type: Pure code
.text$mn:00003C28 ; Segment permissions: Read/Execute
.text$mn:00003C28 _text$mn        segment para public 'CODE' use32
.text$mn:00003C28                 assume cs:_text$mn
.text$mn:00003C28                 ;org 3C28h
.text$mn:00003C28 ; COMDAT (pick any)
.text$mn:00003C28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C28
.text$mn:00003C28 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C28
.text$mn:00003C28 ; Attributes: bp-based frame
.text$mn:00003C28
.text$mn:00003C28 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00003C28                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00003C28 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00003C28                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00003C28
.text$mn:00003C28 var_20          = dword ptr -20h
.text$mn:00003C28 var_1C          = dword ptr -1Ch
.text$mn:00003C28 var_18          = dword ptr -18h
.text$mn:00003C28 var_11          = byte ptr -11h
.text$mn:00003C28 var_10          = dword ptr -10h
.text$mn:00003C28 var_C           = byte ptr -0Ch
.text$mn:00003C28 var_4           = dword ptr -4
.text$mn:00003C28 arg_0           = dword ptr  8
.text$mn:00003C28
.text$mn:00003C28 ; FUNCTION CHUNK AT .text$mn:00003D4A SIZE 00000009 BYTES
.text$mn:00003C28
.text$mn:00003C28                 push    ebp
.text$mn:00003C29                 mov     ebp, esp
.text$mn:00003C2B                 push    0FFFFFFFFh
.text$mn:00003C2D                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00003C32                 mov     eax, large fs:0
.text$mn:00003C38                 push    eax
.text$mn:00003C39                 push    ecx
.text$mn:00003C3A                 sub     esp, 10h
.text$mn:00003C3D                 push    ebx
.text$mn:00003C3E                 push    esi
.text$mn:00003C3F                 push    edi
.text$mn:00003C40                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003C45                 xor     eax, ebp
.text$mn:00003C47                 push    eax
.text$mn:00003C48                 lea     eax, [ebp+var_C]
.text$mn:00003C4B                 mov     large fs:0, eax
.text$mn:00003C51                 mov     [ebp+var_10], esp
.text$mn:00003C54                 mov     [ebp+var_18], ecx
.text$mn:00003C57                 mov     eax, [ebp+arg_0]
.text$mn:00003C5A                 or      eax, 0Fh
.text$mn:00003C5D                 mov     [ebp+var_1C], eax
.text$mn:00003C60                 mov     ecx, [ebp+var_18]
.text$mn:00003C63                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00003C68                 cmp     eax, [ebp+var_1C]
.text$mn:00003C6B                 jnb     short loc_3C75
.text$mn:00003C6D                 mov     ecx, [ebp+arg_0]
.text$mn:00003C70                 mov     [ebp+var_1C], ecx
.text$mn:00003C73                 jmp     short loc_3CC7
.text$mn:00003C75 ; ---------------------------------------------------------------------------
.text$mn:00003C75
.text$mn:00003C75 loc_3C75:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00003C75                 mov     edx, [ebp+var_18]
.text$mn:00003C78                 mov     ecx, [edx+18h]
.text$mn:00003C7B                 shr     ecx, 1
.text$mn:00003C7D                 mov     eax, [ebp+var_1C]
.text$mn:00003C80                 xor     edx, edx
.text$mn:00003C82                 mov     esi, 3
.text$mn:00003C87                 div     esi
.text$mn:00003C89                 cmp     ecx, eax
.text$mn:00003C8B                 ja      short loc_3C8F
.text$mn:00003C8D                 jmp     short loc_3CC7
.text$mn:00003C8F ; ---------------------------------------------------------------------------
.text$mn:00003C8F
.text$mn:00003C8F loc_3C8F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00003C8F                 mov     ecx, [ebp+var_18]
.text$mn:00003C92                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00003C97                 mov     edx, [ebp+var_18]
.text$mn:00003C9A                 mov     ecx, [edx+18h]
.text$mn:00003C9D                 shr     ecx, 1
.text$mn:00003C9F                 sub     eax, ecx
.text$mn:00003CA1                 mov     edx, [ebp+var_18]
.text$mn:00003CA4                 cmp     [edx+18h], eax
.text$mn:00003CA7                 ja      short loc_3CBC
.text$mn:00003CA9                 mov     eax, [ebp+var_18]
.text$mn:00003CAC                 mov     ecx, [eax+18h]
.text$mn:00003CAF                 shr     ecx, 1
.text$mn:00003CB1                 mov     edx, [ebp+var_18]
.text$mn:00003CB4                 add     ecx, [edx+18h]
.text$mn:00003CB7                 mov     [ebp+var_1C], ecx
.text$mn:00003CBA                 jmp     short loc_3CC7
.text$mn:00003CBC ; ---------------------------------------------------------------------------
.text$mn:00003CBC
.text$mn:00003CBC loc_3CBC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00003CBC                 mov     ecx, [ebp+var_18]
.text$mn:00003CBF                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00003CC4                 mov     [ebp+var_1C], eax
.text$mn:00003CC7
.text$mn:00003CC7 loc_3CC7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00003CC7                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00003CC7                 mov     [ebp+var_4], 0
.text$mn:00003CCE                 mov     eax, [ebp+var_1C]
.text$mn:00003CD1                 add     eax, 1
.text$mn:00003CD4                 push    eax
.text$mn:00003CD5                 lea     ecx, [ebp+var_11]
.text$mn:00003CD8                 push    ecx
.text$mn:00003CD9                 mov     ecx, [ebp+var_18]
.text$mn:00003CDC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003CE1                 mov     ecx, eax
.text$mn:00003CE3                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00003CE8                 mov     [ebp+var_20], eax
.text$mn:00003CEB                 jmp     short loc_3D4A
.text$mn:00003CEB ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00003CEB
.text$mn:00003CED
.text$mn:00003CED ; =============== S U B R O U T I N E =======================================
.text$mn:00003CED
.text$mn:00003CED
.text$mn:00003CED __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00003CED                                         ; DATA XREF: .xdata$x:000069F8o
.text$mn:00003CED
.text$mn:00003CED ; FUNCTION CHUNK AT .text$mn:00003D34 SIZE 00000009 BYTES
.text$mn:00003CED ; FUNCTION CHUNK AT .text$mn:00003D44 SIZE 00000006 BYTES
.text$mn:00003CED
.text$mn:00003CED                 mov     [ebp-10h], esp
.text$mn:00003CF0                 mov     edx, [ebp+8]
.text$mn:00003CF3                 mov     [ebp-1Ch], edx
.text$mn:00003CF6                 mov     byte ptr [ebp-4], 2
.text$mn:00003CFA                 mov     eax, [ebp-1Ch]
.text$mn:00003CFD                 add     eax, 1
.text$mn:00003D00                 push    eax
.text$mn:00003D01                 lea     ecx, [ebp-12h]
.text$mn:00003D04                 push    ecx
.text$mn:00003D05                 mov     ecx, [ebp-18h]
.text$mn:00003D08                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003D0D                 mov     ecx, eax
.text$mn:00003D0F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00003D14                 mov     [ebp-20h], eax
.text$mn:00003D17                 jmp     short loc_3D34
.text$mn:00003D17 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00003D17
.text$mn:00003D19
.text$mn:00003D19 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D19
.text$mn:00003D19 ; Attributes: noreturn
.text$mn:00003D19
.text$mn:00003D19 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00003D19                                         ; DATA XREF: .xdata$x:00006A08o
.text$mn:00003D19                 push    0               ; Size
.text$mn:00003D1B                 push    1               ; char
.text$mn:00003D1D                 mov     ecx, [ebp-18h]
.text$mn:00003D20                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003D25                 push    0
.text$mn:00003D27                 push    0
.text$mn:00003D29                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00003D29 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00003D29
.text$mn:00003D2E ; ---------------------------------------------------------------------------
.text$mn:00003D2E                 mov     eax, offset $LN17
.text$mn:00003D33                 retn
.text$mn:00003D34 ; ---------------------------------------------------------------------------
.text$mn:00003D34 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003D34
.text$mn:00003D34 loc_3D34:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00003D34                 mov     dword ptr [ebp-4], 1
.text$mn:00003D3B                 jmp     short loc_3D44
.text$mn:00003D3B ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003D3D
.text$mn:00003D3D ; =============== S U B R O U T I N E =======================================
.text$mn:00003D3D
.text$mn:00003D3D
.text$mn:00003D3D $LN17           proc near               ; DATA XREF: .text$mn:00003D2Eo
.text$mn:00003D3D                 mov     dword ptr [ebp-4], 1
.text$mn:00003D3D $LN17           endp ; sp-analysis failed
.text$mn:00003D3D
.text$mn:00003D44 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003D44
.text$mn:00003D44 loc_3D44:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00003D44                 mov     eax, offset $LN19
.text$mn:00003D49                 retn
.text$mn:00003D49 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003D4A ; ---------------------------------------------------------------------------
.text$mn:00003D4A ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00003D4A
.text$mn:00003D4A loc_3D4A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00003D4A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003D51                 jmp     short loc_3D5A
.text$mn:00003D51 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00003D53
.text$mn:00003D53 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D53
.text$mn:00003D53
.text$mn:00003D53 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_3D44o
.text$mn:00003D53                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00003D5A
.text$mn:00003D5A loc_3D5A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00003D5A                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00003D5E                 jbe     short loc_3D79
.text$mn:00003D60                 mov     edx, [ebp+0Ch]
.text$mn:00003D63                 push    edx             ; Size
.text$mn:00003D64                 mov     ecx, [ebp-18h]
.text$mn:00003D67                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003D6C                 push    eax             ; Src
.text$mn:00003D6D                 mov     eax, [ebp-20h]
.text$mn:00003D70                 push    eax             ; Dst
.text$mn:00003D71                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00003D76                 add     esp, 0Ch
.text$mn:00003D79
.text$mn:00003D79 loc_3D79:                               ; CODE XREF: $LN19+Bj
.text$mn:00003D79                 push    0               ; Size
.text$mn:00003D7B                 push    1               ; char
.text$mn:00003D7D                 mov     ecx, [ebp-18h]
.text$mn:00003D80                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003D85                 lea     ecx, [ebp-20h]
.text$mn:00003D88                 push    ecx             ; int
.text$mn:00003D89                 mov     edx, [ebp-18h]
.text$mn:00003D8C                 add     edx, 4
.text$mn:00003D8F                 push    edx             ; void *
.text$mn:00003D90                 lea     eax, [ebp-13h]
.text$mn:00003D93                 push    eax
.text$mn:00003D94                 mov     ecx, [ebp-18h]
.text$mn:00003D97                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003D9C                 mov     ecx, eax
.text$mn:00003D9E                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00003DA3                 mov     ecx, [ebp-18h]
.text$mn:00003DA6                 mov     edx, [ebp-1Ch]
.text$mn:00003DA9                 mov     [ecx+18h], edx
.text$mn:00003DAC                 mov     eax, [ebp+0Ch]
.text$mn:00003DAF                 push    eax
.text$mn:00003DB0                 mov     ecx, [ebp-18h]
.text$mn:00003DB3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003DB8                 mov     ecx, [ebp-0Ch]
.text$mn:00003DBB                 mov     large fs:0, ecx
.text$mn:00003DC2                 pop     ecx
.text$mn:00003DC3                 pop     edi
.text$mn:00003DC4                 pop     esi
.text$mn:00003DC5                 pop     ebx
.text$mn:00003DC6                 mov     esp, ebp
.text$mn:00003DC8                 pop     ebp
.text$mn:00003DC9                 retn    8
.text$mn:00003DC9 $LN19           endp ; sp-analysis failed
.text$mn:00003DC9
.text$mn:00003DC9 _text$mn        ends
.text$mn:00003DC9
.text$x:00003DCC ; ===========================================================================
.text$x:00003DCC
.text$x:00003DCC ; Segment type: Pure code
.text$x:00003DCC ; Segment permissions: Read/Execute
.text$x:00003DCC _text$x         segment para public 'CODE' use32
.text$x:00003DCC                 assume cs:_text$x
.text$x:00003DCC                 ;org 3DCCh
.text$x:00003DCC ; COMDAT (pick associative to section at 3C28)
.text$x:00003DCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003DCC
.text$x:00003DCC ; =============== S U B R O U T I N E =======================================
.text$x:00003DCC
.text$x:00003DCC
.text$x:00003DCC __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00003DCC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00003DCC
.text$x:00003DCC arg_4           = dword ptr  8
.text$x:00003DCC
.text$x:00003DCC                 mov     edx, [esp+arg_4]
.text$x:00003DD0                 lea     eax, [edx+0Ch]
.text$x:00003DD3                 mov     ecx, [edx-24h]
.text$x:00003DD6                 xor     ecx, eax
.text$x:00003DD8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003DDD                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00003DE2                 jmp     ___CxxFrameHandler3
.text$x:00003DE2 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00003DE2
.text$x:00003DE2 ; ---------------------------------------------------------------------------
.text$x:00003DE7                 align 4
.text$x:00003DE7 _text$x         ends
.text$x:00003DE7
.text$mn:00003DE8 ; ===========================================================================
.text$mn:00003DE8
.text$mn:00003DE8 ; Segment type: Pure code
.text$mn:00003DE8 ; Segment permissions: Read/Execute
.text$mn:00003DE8 _text$mn        segment para public 'CODE' use32
.text$mn:00003DE8                 assume cs:_text$mn
.text$mn:00003DE8                 ;org 3DE8h
.text$mn:00003DE8 ; COMDAT (pick any)
.text$mn:00003DE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DE8
.text$mn:00003DE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DE8
.text$mn:00003DE8 ; Attributes: bp-based frame
.text$mn:00003DE8
.text$mn:00003DE8 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:00003DE8                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00003DE8 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:00003DE8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:00003DE8
.text$mn:00003DE8 var_20          = dword ptr -20h
.text$mn:00003DE8 var_1C          = dword ptr -1Ch
.text$mn:00003DE8 var_18          = dword ptr -18h
.text$mn:00003DE8 var_11          = byte ptr -11h
.text$mn:00003DE8 var_10          = dword ptr -10h
.text$mn:00003DE8 var_C           = byte ptr -0Ch
.text$mn:00003DE8 var_4           = dword ptr -4
.text$mn:00003DE8 arg_0           = dword ptr  8
.text$mn:00003DE8
.text$mn:00003DE8 ; FUNCTION CHUNK AT .text$mn:00003F0A SIZE 00000009 BYTES
.text$mn:00003DE8
.text$mn:00003DE8                 push    ebp
.text$mn:00003DE9                 mov     ebp, esp
.text$mn:00003DEB                 push    0FFFFFFFFh
.text$mn:00003DED                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00003DF2                 mov     eax, large fs:0
.text$mn:00003DF8                 push    eax
.text$mn:00003DF9                 push    ecx
.text$mn:00003DFA                 sub     esp, 10h
.text$mn:00003DFD                 push    ebx
.text$mn:00003DFE                 push    esi
.text$mn:00003DFF                 push    edi
.text$mn:00003E00                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003E05                 xor     eax, ebp
.text$mn:00003E07                 push    eax
.text$mn:00003E08                 lea     eax, [ebp+var_C]
.text$mn:00003E0B                 mov     large fs:0, eax
.text$mn:00003E11                 mov     [ebp+var_10], esp
.text$mn:00003E14                 mov     [ebp+var_18], ecx
.text$mn:00003E17                 mov     eax, [ebp+arg_0]
.text$mn:00003E1A                 or      eax, 7
.text$mn:00003E1D                 mov     [ebp+var_1C], eax
.text$mn:00003E20                 mov     ecx, [ebp+var_18]
.text$mn:00003E23                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00003E28                 cmp     eax, [ebp+var_1C]
.text$mn:00003E2B                 jnb     short loc_3E35
.text$mn:00003E2D                 mov     ecx, [ebp+arg_0]
.text$mn:00003E30                 mov     [ebp+var_1C], ecx
.text$mn:00003E33                 jmp     short loc_3E87
.text$mn:00003E35 ; ---------------------------------------------------------------------------
.text$mn:00003E35
.text$mn:00003E35 loc_3E35:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:00003E35                 mov     edx, [ebp+var_18]
.text$mn:00003E38                 mov     ecx, [edx+18h]
.text$mn:00003E3B                 shr     ecx, 1
.text$mn:00003E3D                 mov     eax, [ebp+var_1C]
.text$mn:00003E40                 xor     edx, edx
.text$mn:00003E42                 mov     esi, 3
.text$mn:00003E47                 div     esi
.text$mn:00003E49                 cmp     ecx, eax
.text$mn:00003E4B                 ja      short loc_3E4F
.text$mn:00003E4D                 jmp     short loc_3E87
.text$mn:00003E4F ; ---------------------------------------------------------------------------
.text$mn:00003E4F
.text$mn:00003E4F loc_3E4F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:00003E4F                 mov     ecx, [ebp+var_18]
.text$mn:00003E52                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00003E57                 mov     edx, [ebp+var_18]
.text$mn:00003E5A                 mov     ecx, [edx+18h]
.text$mn:00003E5D                 shr     ecx, 1
.text$mn:00003E5F                 sub     eax, ecx
.text$mn:00003E61                 mov     edx, [ebp+var_18]
.text$mn:00003E64                 cmp     [edx+18h], eax
.text$mn:00003E67                 ja      short loc_3E7C
.text$mn:00003E69                 mov     eax, [ebp+var_18]
.text$mn:00003E6C                 mov     ecx, [eax+18h]
.text$mn:00003E6F                 shr     ecx, 1
.text$mn:00003E71                 mov     edx, [ebp+var_18]
.text$mn:00003E74                 add     ecx, [edx+18h]
.text$mn:00003E77                 mov     [ebp+var_1C], ecx
.text$mn:00003E7A                 jmp     short loc_3E87
.text$mn:00003E7C ; ---------------------------------------------------------------------------
.text$mn:00003E7C
.text$mn:00003E7C loc_3E7C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:00003E7C                 mov     ecx, [ebp+var_18]
.text$mn:00003E7F                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00003E84                 mov     [ebp+var_1C], eax
.text$mn:00003E87
.text$mn:00003E87 loc_3E87:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:00003E87                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:00003E87                 mov     [ebp+var_4], 0
.text$mn:00003E8E                 mov     eax, [ebp+var_1C]
.text$mn:00003E91                 add     eax, 1
.text$mn:00003E94                 push    eax
.text$mn:00003E95                 lea     ecx, [ebp+var_11]
.text$mn:00003E98                 push    ecx
.text$mn:00003E99                 mov     ecx, [ebp+var_18]
.text$mn:00003E9C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00003EA1                 mov     ecx, eax
.text$mn:00003EA3                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00003EA8                 mov     [ebp+var_20], eax
.text$mn:00003EAB                 jmp     short loc_3F0A
.text$mn:00003EAB ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:00003EAB
.text$mn:00003EAD
.text$mn:00003EAD ; =============== S U B R O U T I N E =======================================
.text$mn:00003EAD
.text$mn:00003EAD
.text$mn:00003EAD __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:00003EAD                                         ; DATA XREF: .xdata$x:00006D44o
.text$mn:00003EAD
.text$mn:00003EAD ; FUNCTION CHUNK AT .text$mn:00003EF4 SIZE 00000009 BYTES
.text$mn:00003EAD ; FUNCTION CHUNK AT .text$mn:00003F04 SIZE 00000006 BYTES
.text$mn:00003EAD
.text$mn:00003EAD                 mov     [ebp-10h], esp
.text$mn:00003EB0                 mov     edx, [ebp+8]
.text$mn:00003EB3                 mov     [ebp-1Ch], edx
.text$mn:00003EB6                 mov     byte ptr [ebp-4], 2
.text$mn:00003EBA                 mov     eax, [ebp-1Ch]
.text$mn:00003EBD                 add     eax, 1
.text$mn:00003EC0                 push    eax
.text$mn:00003EC1                 lea     ecx, [ebp-12h]
.text$mn:00003EC4                 push    ecx
.text$mn:00003EC5                 mov     ecx, [ebp-18h]
.text$mn:00003EC8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00003ECD                 mov     ecx, eax
.text$mn:00003ECF                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00003ED4                 mov     [ebp-20h], eax
.text$mn:00003ED7                 jmp     short loc_3EF4
.text$mn:00003ED7 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:00003ED7
.text$mn:00003ED9
.text$mn:00003ED9 ; =============== S U B R O U T I N E =======================================
.text$mn:00003ED9
.text$mn:00003ED9 ; Attributes: noreturn
.text$mn:00003ED9
.text$mn:00003ED9 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:00003ED9                                         ; DATA XREF: .xdata$x:00006D54o
.text$mn:00003ED9                 push    0
.text$mn:00003EDB                 push    1
.text$mn:00003EDD                 mov     ecx, [ebp-18h]
.text$mn:00003EE0                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00003EE5                 push    0
.text$mn:00003EE7                 push    0
.text$mn:00003EE9                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00003EE9 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:00003EE9
.text$mn:00003EEE ; ---------------------------------------------------------------------------
.text$mn:00003EEE                 mov     eax, offset $LN17_0
.text$mn:00003EF3                 retn
.text$mn:00003EF4 ; ---------------------------------------------------------------------------
.text$mn:00003EF4 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00003EF4
.text$mn:00003EF4 loc_3EF4:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00003EF4                 mov     dword ptr [ebp-4], 1
.text$mn:00003EFB                 jmp     short loc_3F04
.text$mn:00003EFB ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00003EFD
.text$mn:00003EFD ; =============== S U B R O U T I N E =======================================
.text$mn:00003EFD
.text$mn:00003EFD
.text$mn:00003EFD $LN17_0         proc near               ; DATA XREF: .text$mn:00003EEEo
.text$mn:00003EFD                 mov     dword ptr [ebp-4], 1
.text$mn:00003EFD $LN17_0         endp ; sp-analysis failed
.text$mn:00003EFD
.text$mn:00003F04 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00003F04
.text$mn:00003F04 loc_3F04:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00003F04                 mov     eax, offset $LN19_0
.text$mn:00003F09                 retn
.text$mn:00003F09 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00003F0A ; ---------------------------------------------------------------------------
.text$mn:00003F0A ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00003F0A
.text$mn:00003F0A loc_3F0A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:00003F0A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003F11                 jmp     short loc_3F1A
.text$mn:00003F11 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00003F13
.text$mn:00003F13 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F13
.text$mn:00003F13
.text$mn:00003F13 $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_3F04o
.text$mn:00003F13                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00003F1A
.text$mn:00003F1A loc_3F1A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:00003F1A                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00003F1E                 jbe     short loc_3F39
.text$mn:00003F20                 mov     edx, [ebp+0Ch]
.text$mn:00003F23                 push    edx             ; int
.text$mn:00003F24                 mov     ecx, [ebp-18h]
.text$mn:00003F27                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00003F2C                 push    eax             ; Src
.text$mn:00003F2D                 mov     eax, [ebp-20h]
.text$mn:00003F30                 push    eax             ; Dst
.text$mn:00003F31                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00003F36                 add     esp, 0Ch
.text$mn:00003F39
.text$mn:00003F39 loc_3F39:                               ; CODE XREF: $LN19_0+Bj
.text$mn:00003F39                 push    0
.text$mn:00003F3B                 push    1
.text$mn:00003F3D                 mov     ecx, [ebp-18h]
.text$mn:00003F40                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00003F45                 lea     ecx, [ebp-20h]
.text$mn:00003F48                 push    ecx             ; int
.text$mn:00003F49                 mov     edx, [ebp-18h]
.text$mn:00003F4C                 add     edx, 4
.text$mn:00003F4F                 push    edx             ; void *
.text$mn:00003F50                 lea     eax, [ebp-13h]
.text$mn:00003F53                 push    eax
.text$mn:00003F54                 mov     ecx, [ebp-18h]
.text$mn:00003F57                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00003F5C                 mov     ecx, eax
.text$mn:00003F5E                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00003F63                 mov     ecx, [ebp-18h]
.text$mn:00003F66                 mov     edx, [ebp-1Ch]
.text$mn:00003F69                 mov     [ecx+18h], edx
.text$mn:00003F6C                 mov     eax, [ebp+0Ch]
.text$mn:00003F6F                 push    eax
.text$mn:00003F70                 mov     ecx, [ebp-18h]
.text$mn:00003F73                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00003F78                 mov     ecx, [ebp-0Ch]
.text$mn:00003F7B                 mov     large fs:0, ecx
.text$mn:00003F82                 pop     ecx
.text$mn:00003F83                 pop     edi
.text$mn:00003F84                 pop     esi
.text$mn:00003F85                 pop     ebx
.text$mn:00003F86                 mov     esp, ebp
.text$mn:00003F88                 pop     ebp
.text$mn:00003F89                 retn    8
.text$mn:00003F89 $LN19_0         endp ; sp-analysis failed
.text$mn:00003F89
.text$mn:00003F89 _text$mn        ends
.text$mn:00003F89
.text$x:00003F8C ; ===========================================================================
.text$x:00003F8C
.text$x:00003F8C ; Segment type: Pure code
.text$x:00003F8C ; Segment permissions: Read/Execute
.text$x:00003F8C _text$x         segment para public 'CODE' use32
.text$x:00003F8C                 assume cs:_text$x
.text$x:00003F8C                 ;org 3F8Ch
.text$x:00003F8C ; COMDAT (pick associative to section at 3DE8)
.text$x:00003F8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003F8C
.text$x:00003F8C ; =============== S U B R O U T I N E =======================================
.text$x:00003F8C
.text$x:00003F8C
.text$x:00003F8C __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:00003F8C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:00003F8C
.text$x:00003F8C arg_4           = dword ptr  8
.text$x:00003F8C
.text$x:00003F8C                 mov     edx, [esp+arg_4]
.text$x:00003F90                 lea     eax, [edx+0Ch]
.text$x:00003F93                 mov     ecx, [edx-24h]
.text$x:00003F96                 xor     ecx, eax
.text$x:00003F98                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F9D                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:00003FA2                 jmp     ___CxxFrameHandler3
.text$x:00003FA2 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:00003FA2
.text$x:00003FA2 ; ---------------------------------------------------------------------------
.text$x:00003FA7                 align 4
.text$x:00003FA7 _text$x         ends
.text$x:00003FA7
.text$mn:00003FA8 ; ===========================================================================
.text$mn:00003FA8
.text$mn:00003FA8 ; Segment type: Pure code
.text$mn:00003FA8 ; Segment permissions: Read/Execute
.text$mn:00003FA8 _text$mn        segment para public 'CODE' use32
.text$mn:00003FA8                 assume cs:_text$mn
.text$mn:00003FA8                 ;org 3FA8h
.text$mn:00003FA8 ; COMDAT (pick any)
.text$mn:00003FA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FA8
.text$mn:00003FA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FA8
.text$mn:00003FA8 ; Attributes: bp-based frame
.text$mn:00003FA8
.text$mn:00003FA8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00003FA8                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00003FA8 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00003FA8                                         ; CODE XREF: $LN19+60p
.text$mn:00003FA8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00003FA8
.text$mn:00003FA8 var_8           = dword ptr -8
.text$mn:00003FA8 var_1           = byte ptr -1
.text$mn:00003FA8 arg_0           = dword ptr  8
.text$mn:00003FA8
.text$mn:00003FA8                 push    ebp
.text$mn:00003FA9                 mov     ebp, esp
.text$mn:00003FAB                 sub     esp, 8
.text$mn:00003FAE                 mov     [ebp+var_8], ecx
.text$mn:00003FB1                 mov     [ebp+var_1], 0
.text$mn:00003FB5                 mov     eax, [ebp+var_8]
.text$mn:00003FB8                 mov     ecx, [ebp+arg_0]
.text$mn:00003FBB                 mov     [eax+14h], ecx
.text$mn:00003FBE                 lea     edx, [ebp+var_1]
.text$mn:00003FC1                 push    edx
.text$mn:00003FC2                 mov     ecx, [ebp+var_8]
.text$mn:00003FC5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003FCA                 add     eax, [ebp+arg_0]
.text$mn:00003FCD                 push    eax
.text$mn:00003FCE                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00003FD3                 add     esp, 8
.text$mn:00003FD6                 mov     esp, ebp
.text$mn:00003FD8                 pop     ebp
.text$mn:00003FD9                 retn    4
.text$mn:00003FD9 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00003FD9
.text$mn:00003FD9 _text$mn        ends
.text$mn:00003FD9
.text$mn:00003FDC ; ===========================================================================
.text$mn:00003FDC
.text$mn:00003FDC ; Segment type: Pure code
.text$mn:00003FDC ; Segment permissions: Read/Execute
.text$mn:00003FDC _text$mn        segment para public 'CODE' use32
.text$mn:00003FDC                 assume cs:_text$mn
.text$mn:00003FDC                 ;org 3FDCh
.text$mn:00003FDC ; COMDAT (pick any)
.text$mn:00003FDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FDC
.text$mn:00003FDC ; =============== S U B R O U T I N E =======================================
.text$mn:00003FDC
.text$mn:00003FDC ; Attributes: bp-based frame
.text$mn:00003FDC
.text$mn:00003FDC ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:00003FDC                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:00003FDC ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:00003FDC                                         ; CODE XREF: $LN19_0+60p
.text$mn:00003FDC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:00003FDC
.text$mn:00003FDC var_8           = dword ptr -8
.text$mn:00003FDC var_2           = word ptr -2
.text$mn:00003FDC arg_0           = dword ptr  8
.text$mn:00003FDC
.text$mn:00003FDC                 push    ebp
.text$mn:00003FDD                 mov     ebp, esp
.text$mn:00003FDF                 sub     esp, 8
.text$mn:00003FE2                 mov     [ebp+var_8], ecx
.text$mn:00003FE5                 xor     eax, eax
.text$mn:00003FE7                 mov     [ebp+var_2], ax
.text$mn:00003FEB                 mov     ecx, [ebp+var_8]
.text$mn:00003FEE                 mov     edx, [ebp+arg_0]
.text$mn:00003FF1                 mov     [ecx+14h], edx
.text$mn:00003FF4                 lea     eax, [ebp+var_2]
.text$mn:00003FF7                 push    eax
.text$mn:00003FF8                 mov     ecx, [ebp+var_8]
.text$mn:00003FFB                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004000                 mov     ecx, [ebp+arg_0]
.text$mn:00004003                 lea     edx, [eax+ecx*2]
.text$mn:00004006                 push    edx
.text$mn:00004007                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:0000400C                 add     esp, 8
.text$mn:0000400F                 mov     esp, ebp
.text$mn:00004011                 pop     ebp
.text$mn:00004012                 retn    4
.text$mn:00004012 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:00004012
.text$mn:00004012 ; ---------------------------------------------------------------------------
.text$mn:00004015                 align 4
.text$mn:00004015 _text$mn        ends
.text$mn:00004015
.text$mn:00004018 ; ===========================================================================
.text$mn:00004018
.text$mn:00004018 ; Segment type: Pure code
.text$mn:00004018 ; Segment permissions: Read/Execute
.text$mn:00004018 _text$mn        segment para public 'CODE' use32
.text$mn:00004018                 assume cs:_text$mn
.text$mn:00004018                 ;org 4018h
.text$mn:00004018 ; COMDAT (pick any)
.text$mn:00004018                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004018
.text$mn:00004018 ; =============== S U B R O U T I N E =======================================
.text$mn:00004018
.text$mn:00004018 ; Attributes: bp-based frame
.text$mn:00004018
.text$mn:00004018 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00004018                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00004018 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00004018                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00004018
.text$mn:00004018 var_8           = dword ptr -8
.text$mn:00004018 var_1           = byte ptr -1
.text$mn:00004018
.text$mn:00004018                 push    ebp
.text$mn:00004019                 mov     ebp, esp
.text$mn:0000401B                 sub     esp, 8
.text$mn:0000401E                 mov     [ebp+var_8], ecx
.text$mn:00004021                 lea     ecx, [ebp+var_1]
.text$mn:00004024                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00004029                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000402C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00004031                 mov     eax, [ebp+var_8]
.text$mn:00004034                 mov     ecx, [eax]
.text$mn:00004036                 push    ecx
.text$mn:00004037                 lea     ecx, [ebp+var_1]
.text$mn:0000403A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000403F                 push    1               ; int
.text$mn:00004041                 mov     edx, [ebp+var_8]
.text$mn:00004044                 mov     eax, [edx]
.text$mn:00004046                 push    eax             ; void *
.text$mn:00004047                 lea     ecx, [ebp+var_1]
.text$mn:0000404A                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000404F                 mov     ecx, [ebp+var_8]
.text$mn:00004052                 mov     dword ptr [ecx], 0
.text$mn:00004058                 mov     esp, ebp
.text$mn:0000405A                 pop     ebp
.text$mn:0000405B                 retn
.text$mn:0000405B ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000405B
.text$mn:0000405B _text$mn        ends
.text$mn:0000405B
.text$mn:0000405C ; ===========================================================================
.text$mn:0000405C
.text$mn:0000405C ; Segment type: Pure code
.text$mn:0000405C ; Segment permissions: Read/Execute
.text$mn:0000405C _text$mn        segment para public 'CODE' use32
.text$mn:0000405C                 assume cs:_text$mn
.text$mn:0000405C                 ;org 405Ch
.text$mn:0000405C ; COMDAT (pick any)
.text$mn:0000405C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000405C
.text$mn:0000405C ; =============== S U B R O U T I N E =======================================
.text$mn:0000405C
.text$mn:0000405C ; Attributes: bp-based frame
.text$mn:0000405C
.text$mn:0000405C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:0000405C                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:0000405C ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000405C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:0000405C
.text$mn:0000405C var_8           = dword ptr -8
.text$mn:0000405C var_1           = byte ptr -1
.text$mn:0000405C
.text$mn:0000405C                 push    ebp
.text$mn:0000405D                 mov     ebp, esp
.text$mn:0000405F                 sub     esp, 8
.text$mn:00004062                 mov     [ebp+var_8], ecx
.text$mn:00004065                 lea     ecx, [ebp+var_1]
.text$mn:00004068                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000406D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00004070                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00004075                 mov     eax, [ebp+var_8]
.text$mn:00004078                 mov     ecx, [eax]
.text$mn:0000407A                 push    ecx
.text$mn:0000407B                 lea     ecx, [ebp+var_1]
.text$mn:0000407E                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00004083                 push    1               ; int
.text$mn:00004085                 mov     edx, [ebp+var_8]
.text$mn:00004088                 mov     eax, [edx]
.text$mn:0000408A                 push    eax             ; void *
.text$mn:0000408B                 lea     ecx, [ebp+var_1]
.text$mn:0000408E                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00004093                 mov     ecx, [ebp+var_8]
.text$mn:00004096                 mov     dword ptr [ecx], 0
.text$mn:0000409C                 mov     esp, ebp
.text$mn:0000409E                 pop     ebp
.text$mn:0000409F                 retn
.text$mn:0000409F ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000409F
.text$mn:0000409F _text$mn        ends
.text$mn:0000409F
.text$mn:000040A0 ; ===========================================================================
.text$mn:000040A0
.text$mn:000040A0 ; Segment type: Pure code
.text$mn:000040A0 ; Segment permissions: Read/Execute
.text$mn:000040A0 _text$mn        segment para public 'CODE' use32
.text$mn:000040A0                 assume cs:_text$mn
.text$mn:000040A0                 ;org 40A0h
.text$mn:000040A0 ; COMDAT (pick any)
.text$mn:000040A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040A0
.text$mn:000040A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000040A0
.text$mn:000040A0 ; Attributes: bp-based frame
.text$mn:000040A0
.text$mn:000040A0 ; public: struct std::_Wrap_alloc<class std::allocator<struct RecentItem>> __thiscall std::_Deque_alloc<0, struct std::_Deque_base_types<struct RecentItem, class std::allocator<struct RecentItem>>>::_Getal(void)const
.text$mn:000040A0                 public ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@2@XZ
.text$mn:000040A0 ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@2@XZ proc near
.text$mn:000040A0                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+10p
.text$mn:000040A0                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::max_size(void)+10p ...
.text$mn:000040A0
.text$mn:000040A0 var_4           = dword ptr -4
.text$mn:000040A0 arg_0           = dword ptr  8
.text$mn:000040A0
.text$mn:000040A0                 push    ebp
.text$mn:000040A1                 mov     ebp, esp
.text$mn:000040A3                 push    ecx
.text$mn:000040A4                 mov     [ebp+var_4], ecx
.text$mn:000040A7                 mov     ecx, [ebp+arg_0]
.text$mn:000040AA                 call    ??0?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<RecentItem>>::_Wrap_alloc<std::allocator<RecentItem>>(void)
.text$mn:000040AF                 mov     eax, [ebp+arg_0]
.text$mn:000040B2                 mov     esp, ebp
.text$mn:000040B4                 pop     ebp
.text$mn:000040B5                 retn    4
.text$mn:000040B5 ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@2@XZ endp
.text$mn:000040B5
.text$mn:000040B5 _text$mn        ends
.text$mn:000040B5
.text$mn:000040B8 ; ===========================================================================
.text$mn:000040B8
.text$mn:000040B8 ; Segment type: Pure code
.text$mn:000040B8 ; Segment permissions: Read/Execute
.text$mn:000040B8 _text$mn        segment para public 'CODE' use32
.text$mn:000040B8                 assume cs:_text$mn
.text$mn:000040B8                 ;org 40B8h
.text$mn:000040B8 ; COMDAT (pick any)
.text$mn:000040B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040B8
.text$mn:000040B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000040B8
.text$mn:000040B8 ; Attributes: bp-based frame
.text$mn:000040B8
.text$mn:000040B8 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:000040B8                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:000040B8 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:000040B8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:000040B8                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:000040B8
.text$mn:000040B8 var_4           = dword ptr -4
.text$mn:000040B8 arg_0           = dword ptr  8
.text$mn:000040B8
.text$mn:000040B8                 push    ebp
.text$mn:000040B9                 mov     ebp, esp
.text$mn:000040BB                 push    ecx
.text$mn:000040BC                 mov     [ebp+var_4], ecx
.text$mn:000040BF                 mov     ecx, [ebp+arg_0]
.text$mn:000040C2                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:000040C7                 mov     eax, [ebp+arg_0]
.text$mn:000040CA                 mov     esp, ebp
.text$mn:000040CC                 pop     ebp
.text$mn:000040CD                 retn    4
.text$mn:000040CD ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:000040CD
.text$mn:000040CD _text$mn        ends
.text$mn:000040CD
.text$mn:000040D0 ; ===========================================================================
.text$mn:000040D0
.text$mn:000040D0 ; Segment type: Pure code
.text$mn:000040D0 ; Segment permissions: Read/Execute
.text$mn:000040D0 _text$mn        segment para public 'CODE' use32
.text$mn:000040D0                 assume cs:_text$mn
.text$mn:000040D0                 ;org 40D0h
.text$mn:000040D0 ; COMDAT (pick any)
.text$mn:000040D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040D0
.text$mn:000040D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000040D0
.text$mn:000040D0 ; Attributes: bp-based frame
.text$mn:000040D0
.text$mn:000040D0 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:000040D0                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:000040D0 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:000040D0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+33p
.text$mn:000040D0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+18p ...
.text$mn:000040D0
.text$mn:000040D0 var_4           = dword ptr -4
.text$mn:000040D0 arg_0           = dword ptr  8
.text$mn:000040D0
.text$mn:000040D0                 push    ebp
.text$mn:000040D1                 mov     ebp, esp
.text$mn:000040D3                 push    ecx
.text$mn:000040D4                 mov     [ebp+var_4], ecx
.text$mn:000040D7                 mov     ecx, [ebp+arg_0]
.text$mn:000040DA                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:000040DF                 mov     eax, [ebp+arg_0]
.text$mn:000040E2                 mov     esp, ebp
.text$mn:000040E4                 pop     ebp
.text$mn:000040E5                 retn    4
.text$mn:000040E5 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:000040E5
.text$mn:000040E5 _text$mn        ends
.text$mn:000040E5
.text$mn:000040E8 ; ===========================================================================
.text$mn:000040E8
.text$mn:000040E8 ; Segment type: Pure code
.text$mn:000040E8 ; Segment permissions: Read/Execute
.text$mn:000040E8 _text$mn        segment para public 'CODE' use32
.text$mn:000040E8                 assume cs:_text$mn
.text$mn:000040E8                 ;org 40E8h
.text$mn:000040E8 ; COMDAT (pick any)
.text$mn:000040E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040E8
.text$mn:000040E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000040E8
.text$mn:000040E8 ; Attributes: bp-based frame
.text$mn:000040E8
.text$mn:000040E8 ; public: unsigned int __thiscall std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>::_Getblock(unsigned int)const
.text$mn:000040E8                 public ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@QBEII@Z
.text$mn:000040E8 ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@QBEII@Z proc near
.text$mn:000040E8                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+AEp
.text$mn:000040E8                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::pop_back(void)+5Bp ...
.text$mn:000040E8
.text$mn:000040E8 var_4           = dword ptr -4
.text$mn:000040E8 arg_0           = dword ptr  8
.text$mn:000040E8
.text$mn:000040E8                 push    ebp
.text$mn:000040E9                 mov     ebp, esp
.text$mn:000040EB                 push    ecx
.text$mn:000040EC                 mov     [ebp+var_4], ecx
.text$mn:000040EF                 mov     eax, [ebp+var_4]
.text$mn:000040F2                 mov     eax, [eax+8]
.text$mn:000040F5                 sub     eax, 1
.text$mn:000040F8                 and     eax, [ebp+arg_0]
.text$mn:000040FB                 mov     esp, ebp
.text$mn:000040FD                 pop     ebp
.text$mn:000040FE                 retn    4
.text$mn:000040FE ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@QBEII@Z endp
.text$mn:000040FE
.text$mn:000040FE ; ---------------------------------------------------------------------------
.text$mn:00004101                 align 4
.text$mn:00004101 _text$mn        ends
.text$mn:00004101
.text$mn:00004104 ; ===========================================================================
.text$mn:00004104
.text$mn:00004104 ; Segment type: Pure code
.text$mn:00004104 ; Segment permissions: Read/Execute
.text$mn:00004104 _text$mn        segment para public 'CODE' use32
.text$mn:00004104                 assume cs:_text$mn
.text$mn:00004104                 ;org 4104h
.text$mn:00004104 ; COMDAT (pick any)
.text$mn:00004104                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004104
.text$mn:00004104 ; =============== S U B R O U T I N E =======================================
.text$mn:00004104
.text$mn:00004104 ; Attributes: bp-based frame
.text$mn:00004104
.text$mn:00004104 ; const struct std::_Container_base12 *__thiscall std::_Iterator_base12::_Getcont(std::_Iterator_base12 *__hidden this)
.text$mn:00004104                 public ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
.text$mn:00004104 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ proc near
.text$mn:00004104                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+Cp
.text$mn:00004104                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)+Cp ...
.text$mn:00004104
.text$mn:00004104 var_8           = dword ptr -8
.text$mn:00004104 var_4           = dword ptr -4
.text$mn:00004104
.text$mn:00004104                 push    ebp
.text$mn:00004105                 mov     ebp, esp
.text$mn:00004107                 sub     esp, 8
.text$mn:0000410A                 mov     [ebp+var_4], ecx
.text$mn:0000410D                 mov     eax, [ebp+var_4]
.text$mn:00004110                 cmp     dword ptr [eax], 0
.text$mn:00004113                 jnz     short loc_411E
.text$mn:00004115                 mov     [ebp+var_8], 0
.text$mn:0000411C                 jmp     short loc_4128
.text$mn:0000411E ; ---------------------------------------------------------------------------
.text$mn:0000411E
.text$mn:0000411E loc_411E:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+Fj
.text$mn:0000411E                 mov     ecx, [ebp+var_4]
.text$mn:00004121                 mov     edx, [ecx]
.text$mn:00004123                 mov     eax, [edx]
.text$mn:00004125                 mov     [ebp+var_8], eax
.text$mn:00004128
.text$mn:00004128 loc_4128:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+18j
.text$mn:00004128                 mov     eax, [ebp+var_8]
.text$mn:0000412B                 mov     esp, ebp
.text$mn:0000412D                 pop     ebp
.text$mn:0000412E                 retn
.text$mn:0000412E ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ endp
.text$mn:0000412E
.text$mn:0000412E ; ---------------------------------------------------------------------------
.text$mn:0000412F                 align 10h
.text$mn:0000412F _text$mn        ends
.text$mn:0000412F
.text$mn:00004130 ; ===========================================================================
.text$mn:00004130
.text$mn:00004130 ; Segment type: Pure code
.text$mn:00004130 ; Segment permissions: Read/Execute
.text$mn:00004130 _text$mn        segment para public 'CODE' use32
.text$mn:00004130                 assume cs:_text$mn
.text$mn:00004130                 ;org 4130h
.text$mn:00004130 ; COMDAT (pick any)
.text$mn:00004130                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004130
.text$mn:00004130 ; =============== S U B R O U T I N E =======================================
.text$mn:00004130
.text$mn:00004130 ; Attributes: bp-based frame
.text$mn:00004130
.text$mn:00004130 ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:00004130                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:00004130 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:00004130                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint)+79p
.text$mn:00004130
.text$mn:00004130 var_8           = dword ptr -8
.text$mn:00004130 var_4           = dword ptr -4
.text$mn:00004130
.text$mn:00004130                 push    ebp
.text$mn:00004131                 mov     ebp, esp
.text$mn:00004133                 sub     esp, 8
.text$mn:00004136                 mov     [ebp+var_4], ecx
.text$mn:00004139                 mov     eax, [ebp+var_4]
.text$mn:0000413C                 cmp     dword ptr [eax], 0
.text$mn:0000413F                 jnz     short loc_414A
.text$mn:00004141                 mov     [ebp+var_8], 0
.text$mn:00004148                 jmp     short loc_4155
.text$mn:0000414A ; ---------------------------------------------------------------------------
.text$mn:0000414A
.text$mn:0000414A loc_414A:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:0000414A                 mov     ecx, [ebp+var_4]
.text$mn:0000414D                 mov     edx, [ecx]
.text$mn:0000414F                 add     edx, 4
.text$mn:00004152                 mov     [ebp+var_8], edx
.text$mn:00004155
.text$mn:00004155 loc_4155:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:00004155                 mov     eax, [ebp+var_8]
.text$mn:00004158                 mov     esp, ebp
.text$mn:0000415A                 pop     ebp
.text$mn:0000415B                 retn
.text$mn:0000415B ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:0000415B
.text$mn:0000415B _text$mn        ends
.text$mn:0000415B
.text$mn:0000415C ; ===========================================================================
.text$mn:0000415C
.text$mn:0000415C ; Segment type: Pure code
.text$mn:0000415C ; Segment permissions: Read/Execute
.text$mn:0000415C _text$mn        segment para public 'CODE' use32
.text$mn:0000415C                 assume cs:_text$mn
.text$mn:0000415C                 ;org 415Ch
.text$mn:0000415C ; COMDAT (pick any)
.text$mn:0000415C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000415C
.text$mn:0000415C ; =============== S U B R O U T I N E =======================================
.text$mn:0000415C
.text$mn:0000415C ; Attributes: bp-based frame
.text$mn:0000415C
.text$mn:0000415C ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:0000415C                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:0000415C ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:0000415C                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint)+AEp
.text$mn:0000415C                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint)+C7p
.text$mn:0000415C
.text$mn:0000415C var_4           = dword ptr -4
.text$mn:0000415C
.text$mn:0000415C                 push    ebp
.text$mn:0000415D                 mov     ebp, esp
.text$mn:0000415F                 push    ecx
.text$mn:00004160                 mov     [ebp+var_4], ecx
.text$mn:00004163                 mov     eax, [ebp+var_4]
.text$mn:00004166                 add     eax, 4
.text$mn:00004169                 mov     esp, ebp
.text$mn:0000416B                 pop     ebp
.text$mn:0000416C                 retn
.text$mn:0000416C ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:0000416C
.text$mn:0000416C ; ---------------------------------------------------------------------------
.text$mn:0000416D                 align 10h
.text$mn:0000416D _text$mn        ends
.text$mn:0000416D
.text$mn:00004170 ; ===========================================================================
.text$mn:00004170
.text$mn:00004170 ; Segment type: Pure code
.text$mn:00004170 ; Segment permissions: Read/Execute
.text$mn:00004170 _text$mn        segment para public 'CODE' use32
.text$mn:00004170                 assume cs:_text$mn
.text$mn:00004170                 ;org 4170h
.text$mn:00004170 ; COMDAT (pick any)
.text$mn:00004170                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004170
.text$mn:00004170 ; =============== S U B R O U T I N E =======================================
.text$mn:00004170
.text$mn:00004170 ; Attributes: bp-based frame
.text$mn:00004170
.text$mn:00004170 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00004170                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00004170 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00004170                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00004170                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00004170
.text$mn:00004170 var_C           = dword ptr -0Ch
.text$mn:00004170 Size            = dword ptr -8
.text$mn:00004170 var_4           = dword ptr -4
.text$mn:00004170 arg_0           = dword ptr  8
.text$mn:00004170 arg_4           = byte ptr  0Ch
.text$mn:00004170
.text$mn:00004170                 push    ebp
.text$mn:00004171                 mov     ebp, esp
.text$mn:00004173                 sub     esp, 0Ch
.text$mn:00004176                 mov     [ebp+var_4], ecx
.text$mn:00004179                 mov     ecx, [ebp+var_4]
.text$mn:0000417C                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00004181                 cmp     eax, [ebp+arg_0]
.text$mn:00004184                 jnb     short loc_418E
.text$mn:00004186                 mov     ecx, [ebp+var_4]
.text$mn:00004189                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:0000418E
.text$mn:0000418E loc_418E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:0000418E                 mov     eax, [ebp+var_4]
.text$mn:00004191                 mov     ecx, [eax+18h]
.text$mn:00004194                 cmp     ecx, [ebp+arg_0]
.text$mn:00004197                 jnb     short loc_41AE
.text$mn:00004199                 mov     edx, [ebp+var_4]
.text$mn:0000419C                 mov     eax, [edx+14h]
.text$mn:0000419F                 push    eax
.text$mn:000041A0                 mov     ecx, [ebp+arg_0]
.text$mn:000041A3                 push    ecx
.text$mn:000041A4                 mov     ecx, [ebp+var_4]
.text$mn:000041A7                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:000041AC                 jmp     short loc_41F8
.text$mn:000041AE ; ---------------------------------------------------------------------------
.text$mn:000041AE
.text$mn:000041AE loc_41AE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:000041AE                 movzx   edx, [ebp+arg_4]
.text$mn:000041B2                 test    edx, edx
.text$mn:000041B4                 jz      short loc_41E8
.text$mn:000041B6                 cmp     [ebp+arg_0], 10h
.text$mn:000041BA                 jnb     short loc_41E8
.text$mn:000041BC                 mov     eax, [ebp+var_4]
.text$mn:000041BF                 mov     ecx, [ebp+arg_0]
.text$mn:000041C2                 cmp     ecx, [eax+14h]
.text$mn:000041C5                 jnb     short loc_41CF
.text$mn:000041C7                 mov     edx, [ebp+arg_0]
.text$mn:000041CA                 mov     [ebp+Size], edx
.text$mn:000041CD                 jmp     short loc_41D8
.text$mn:000041CF ; ---------------------------------------------------------------------------
.text$mn:000041CF
.text$mn:000041CF loc_41CF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:000041CF                 mov     eax, [ebp+var_4]
.text$mn:000041D2                 mov     ecx, [eax+14h]
.text$mn:000041D5                 mov     [ebp+Size], ecx
.text$mn:000041D8
.text$mn:000041D8 loc_41D8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:000041D8                 mov     edx, [ebp+Size]
.text$mn:000041DB                 push    edx             ; Size
.text$mn:000041DC                 push    1               ; char
.text$mn:000041DE                 mov     ecx, [ebp+var_4]
.text$mn:000041E1                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000041E6                 jmp     short loc_41F8
.text$mn:000041E8 ; ---------------------------------------------------------------------------
.text$mn:000041E8
.text$mn:000041E8 loc_41E8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:000041E8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:000041E8                 cmp     [ebp+arg_0], 0
.text$mn:000041EC                 jnz     short loc_41F8
.text$mn:000041EE                 push    0
.text$mn:000041F0                 mov     ecx, [ebp+var_4]
.text$mn:000041F3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000041F8
.text$mn:000041F8 loc_41F8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:000041F8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:000041F8                 cmp     [ebp+arg_0], 0
.text$mn:000041FC                 jbe     short loc_4207
.text$mn:000041FE                 mov     [ebp+var_C], 1
.text$mn:00004205                 jmp     short loc_420E
.text$mn:00004207 ; ---------------------------------------------------------------------------
.text$mn:00004207
.text$mn:00004207 loc_4207:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00004207                 mov     [ebp+var_C], 0
.text$mn:0000420E
.text$mn:0000420E loc_420E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:0000420E                 mov     al, byte ptr [ebp+var_C]
.text$mn:00004211                 mov     esp, ebp
.text$mn:00004213                 pop     ebp
.text$mn:00004214                 retn    8
.text$mn:00004214 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00004214
.text$mn:00004214 ; ---------------------------------------------------------------------------
.text$mn:00004217                 align 4
.text$mn:00004217 _text$mn        ends
.text$mn:00004217
.text$mn:00004218 ; ===========================================================================
.text$mn:00004218
.text$mn:00004218 ; Segment type: Pure code
.text$mn:00004218 ; Segment permissions: Read/Execute
.text$mn:00004218 _text$mn        segment para public 'CODE' use32
.text$mn:00004218                 assume cs:_text$mn
.text$mn:00004218                 ;org 4218h
.text$mn:00004218 ; COMDAT (pick any)
.text$mn:00004218                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004218
.text$mn:00004218 ; =============== S U B R O U T I N E =======================================
.text$mn:00004218
.text$mn:00004218 ; Attributes: bp-based frame
.text$mn:00004218
.text$mn:00004218 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:00004218                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:00004218 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:00004218                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Ap
.text$mn:00004218                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+61p
.text$mn:00004218
.text$mn:00004218 var_C           = dword ptr -0Ch
.text$mn:00004218 var_8           = dword ptr -8
.text$mn:00004218 var_4           = dword ptr -4
.text$mn:00004218 arg_0           = dword ptr  8
.text$mn:00004218 arg_4           = byte ptr  0Ch
.text$mn:00004218
.text$mn:00004218                 push    ebp
.text$mn:00004219                 mov     ebp, esp
.text$mn:0000421B                 sub     esp, 0Ch
.text$mn:0000421E                 mov     [ebp+var_4], ecx
.text$mn:00004221                 mov     ecx, [ebp+var_4]
.text$mn:00004224                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00004229                 cmp     eax, [ebp+arg_0]
.text$mn:0000422C                 jnb     short loc_4236
.text$mn:0000422E                 mov     ecx, [ebp+var_4]
.text$mn:00004231                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00004236
.text$mn:00004236 loc_4236:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:00004236                 mov     eax, [ebp+var_4]
.text$mn:00004239                 mov     ecx, [eax+18h]
.text$mn:0000423C                 cmp     ecx, [ebp+arg_0]
.text$mn:0000423F                 jnb     short loc_4256
.text$mn:00004241                 mov     edx, [ebp+var_4]
.text$mn:00004244                 mov     eax, [edx+14h]
.text$mn:00004247                 push    eax
.text$mn:00004248                 mov     ecx, [ebp+arg_0]
.text$mn:0000424B                 push    ecx
.text$mn:0000424C                 mov     ecx, [ebp+var_4]
.text$mn:0000424F                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:00004254                 jmp     short loc_42A0
.text$mn:00004256 ; ---------------------------------------------------------------------------
.text$mn:00004256
.text$mn:00004256 loc_4256:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:00004256                 movzx   edx, [ebp+arg_4]
.text$mn:0000425A                 test    edx, edx
.text$mn:0000425C                 jz      short loc_4290
.text$mn:0000425E                 cmp     [ebp+arg_0], 8
.text$mn:00004262                 jnb     short loc_4290
.text$mn:00004264                 mov     eax, [ebp+var_4]
.text$mn:00004267                 mov     ecx, [ebp+arg_0]
.text$mn:0000426A                 cmp     ecx, [eax+14h]
.text$mn:0000426D                 jnb     short loc_4277
.text$mn:0000426F                 mov     edx, [ebp+arg_0]
.text$mn:00004272                 mov     [ebp+var_8], edx
.text$mn:00004275                 jmp     short loc_4280
.text$mn:00004277 ; ---------------------------------------------------------------------------
.text$mn:00004277
.text$mn:00004277 loc_4277:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:00004277                 mov     eax, [ebp+var_4]
.text$mn:0000427A                 mov     ecx, [eax+14h]
.text$mn:0000427D                 mov     [ebp+var_8], ecx
.text$mn:00004280
.text$mn:00004280 loc_4280:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:00004280                 mov     edx, [ebp+var_8]
.text$mn:00004283                 push    edx
.text$mn:00004284                 push    1
.text$mn:00004286                 mov     ecx, [ebp+var_4]
.text$mn:00004289                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000428E                 jmp     short loc_42A0
.text$mn:00004290 ; ---------------------------------------------------------------------------
.text$mn:00004290
.text$mn:00004290 loc_4290:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:00004290                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:00004290                 cmp     [ebp+arg_0], 0
.text$mn:00004294                 jnz     short loc_42A0
.text$mn:00004296                 push    0
.text$mn:00004298                 mov     ecx, [ebp+var_4]
.text$mn:0000429B                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000042A0
.text$mn:000042A0 loc_42A0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:000042A0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:000042A0                 cmp     [ebp+arg_0], 0
.text$mn:000042A4                 jbe     short loc_42AF
.text$mn:000042A6                 mov     [ebp+var_C], 1
.text$mn:000042AD                 jmp     short loc_42B6
.text$mn:000042AF ; ---------------------------------------------------------------------------
.text$mn:000042AF
.text$mn:000042AF loc_42AF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:000042AF                 mov     [ebp+var_C], 0
.text$mn:000042B6
.text$mn:000042B6 loc_42B6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:000042B6                 mov     al, byte ptr [ebp+var_C]
.text$mn:000042B9                 mov     esp, ebp
.text$mn:000042BB                 pop     ebp
.text$mn:000042BC                 retn    8
.text$mn:000042BC ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:000042BC
.text$mn:000042BC ; ---------------------------------------------------------------------------
.text$mn:000042BF                 align 10h
.text$mn:000042BF _text$mn        ends
.text$mn:000042BF
.text$mn:000042C0 ; ===========================================================================
.text$mn:000042C0
.text$mn:000042C0 ; Segment type: Pure code
.text$mn:000042C0 ; Segment permissions: Read/Execute
.text$mn:000042C0 _text$mn        segment para public 'CODE' use32
.text$mn:000042C0                 assume cs:_text$mn
.text$mn:000042C0                 ;org 42C0h
.text$mn:000042C0 ; COMDAT (pick any)
.text$mn:000042C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000042C0
.text$mn:000042C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000042C0
.text$mn:000042C0 ; Attributes: bp-based frame
.text$mn:000042C0
.text$mn:000042C0 ; protected: void __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::_Growmap(unsigned int)
.text$mn:000042C0                 public ?_Growmap@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IAEXI@Z
.text$mn:000042C0 ?_Growmap@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IAEXI@Z proc near
.text$mn:000042C0                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::push_front(RecentItem const &)+3Bp
.text$mn:000042C0
.text$mn:000042C0 var_1C          = dword ptr -1Ch
.text$mn:000042C0 var_18          = dword ptr -18h
.text$mn:000042C0 var_14          = dword ptr -14h
.text$mn:000042C0 var_10          = dword ptr -10h
.text$mn:000042C0 var_C           = dword ptr -0Ch
.text$mn:000042C0 var_8           = dword ptr -8
.text$mn:000042C0 var_2           = byte ptr -2
.text$mn:000042C0 var_1           = byte ptr -1
.text$mn:000042C0 arg_0           = dword ptr  8
.text$mn:000042C0
.text$mn:000042C0                 push    ebp
.text$mn:000042C1                 mov     ebp, esp
.text$mn:000042C3                 sub     esp, 1Ch
.text$mn:000042C6                 mov     [ebp+var_8], ecx
.text$mn:000042C9                 lea     eax, [ebp+var_2]
.text$mn:000042CC                 push    eax
.text$mn:000042CD                 mov     ecx, [ebp+var_8]
.text$mn:000042D0                 call    ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<RecentItem,std::allocator<RecentItem>>>::_Getal(void)
.text$mn:000042D5                 push    eax
.text$mn:000042D6                 lea     ecx, [ebp+var_1]
.text$mn:000042D9                 call    ??$?0U?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<RecentItem *>>::_Wrap_alloc<std::allocator<RecentItem *>>(std::_Wrap_alloc<std::allocator<RecentItem>> const &)
.text$mn:000042DE                 mov     ecx, [ebp+var_8]
.text$mn:000042E1                 cmp     dword ptr [ecx+8], 0
.text$mn:000042E5                 jbe     short loc_42F2
.text$mn:000042E7                 mov     edx, [ebp+var_8]
.text$mn:000042EA                 mov     eax, [edx+8]
.text$mn:000042ED                 mov     [ebp+var_1C], eax
.text$mn:000042F0                 jmp     short loc_42F9
.text$mn:000042F2 ; ---------------------------------------------------------------------------
.text$mn:000042F2
.text$mn:000042F2 loc_42F2:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+25j
.text$mn:000042F2                 mov     [ebp+var_1C], 1
.text$mn:000042F9
.text$mn:000042F9 loc_42F9:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+30j
.text$mn:000042F9                 mov     ecx, [ebp+var_1C]
.text$mn:000042FC                 mov     [ebp+var_14], ecx
.text$mn:000042FF
.text$mn:000042FF loc_42FF:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+73j
.text$mn:000042FF                 mov     edx, [ebp+var_8]
.text$mn:00004302                 mov     eax, [ebp+var_14]
.text$mn:00004305                 sub     eax, [edx+8]
.text$mn:00004308                 cmp     eax, [ebp+arg_0]
.text$mn:0000430B                 jb      short loc_4313
.text$mn:0000430D                 cmp     [ebp+var_14], 8
.text$mn:00004311                 jnb     short loc_4335
.text$mn:00004313
.text$mn:00004313 loc_4313:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+4Bj
.text$mn:00004313                 mov     ecx, [ebp+var_8]
.text$mn:00004316                 call    ?max_size@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBEIXZ ; std::deque<RecentItem,std::allocator<RecentItem>>::max_size(void)
.text$mn:0000431B                 sub     eax, [ebp+var_14]
.text$mn:0000431E                 cmp     eax, [ebp+var_14]
.text$mn:00004321                 jnb     short loc_432B
.text$mn:00004323                 mov     ecx, [ebp+var_8]
.text$mn:00004326                 call    ?_Xlen@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXXZ ; std::deque<RecentItem,std::allocator<RecentItem>>::_Xlen(void)
.text$mn:0000432B
.text$mn:0000432B loc_432B:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+61j
.text$mn:0000432B                 mov     ecx, [ebp+var_14]
.text$mn:0000432E                 shl     ecx, 1
.text$mn:00004330                 mov     [ebp+var_14], ecx
.text$mn:00004333                 jmp     short loc_42FF
.text$mn:00004335 ; ---------------------------------------------------------------------------
.text$mn:00004335
.text$mn:00004335 loc_4335:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+51j
.text$mn:00004335                 mov     edx, [ebp+var_8]
.text$mn:00004338                 mov     eax, [ebp+var_14]
.text$mn:0000433B                 sub     eax, [edx+8]
.text$mn:0000433E                 mov     [ebp+arg_0], eax
.text$mn:00004341                 mov     ecx, [ebp+var_8]
.text$mn:00004344                 mov     edx, [ecx+0Ch]
.text$mn:00004347                 mov     [ebp+var_10], edx
.text$mn:0000434A                 mov     eax, [ebp+var_8]
.text$mn:0000434D                 mov     ecx, [eax+8]
.text$mn:00004350                 add     ecx, [ebp+arg_0]
.text$mn:00004353                 push    ecx
.text$mn:00004354                 lea     ecx, [ebp+var_1]
.text$mn:00004357                 call    ?allocate@?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@QAEPAPAURecentItem@@I@Z ; std::_Wrap_alloc<std::allocator<RecentItem *>>::allocate(uint)
.text$mn:0000435C                 mov     [ebp+var_18], eax
.text$mn:0000435F                 mov     edx, [ebp+var_10]
.text$mn:00004362                 mov     eax, [ebp+var_18]
.text$mn:00004365                 lea     ecx, [eax+edx*4]
.text$mn:00004368                 mov     [ebp+var_C], ecx
.text$mn:0000436B                 lea     edx, [ebp+var_1]
.text$mn:0000436E                 push    edx
.text$mn:0000436F                 mov     eax, [ebp+var_C]
.text$mn:00004372                 push    eax
.text$mn:00004373                 mov     ecx, [ebp+var_8]
.text$mn:00004376                 mov     edx, [ecx+8]
.text$mn:00004379                 mov     eax, [ebp+var_8]
.text$mn:0000437C                 mov     ecx, [eax+4]
.text$mn:0000437F                 lea     edx, [ecx+edx*4]
.text$mn:00004382                 push    edx
.text$mn:00004383                 mov     eax, [ebp+var_8]
.text$mn:00004386                 mov     ecx, [eax+4]
.text$mn:00004389                 mov     edx, [ebp+var_10]
.text$mn:0000438C                 lea     eax, [ecx+edx*4]
.text$mn:0000438F                 push    eax
.text$mn:00004390                 call    ??$_Uninitialized_copy@PAPAURecentItem@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAPAPAURecentItem@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z ; std::_Uninitialized_copy<RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &)
.text$mn:00004395                 add     esp, 10h
.text$mn:00004398                 mov     [ebp+var_C], eax
.text$mn:0000439B                 mov     ecx, [ebp+var_10]
.text$mn:0000439E                 cmp     ecx, [ebp+arg_0]
.text$mn:000043A1                 ja      short loc_43F7
.text$mn:000043A3                 lea     edx, [ebp+var_1]
.text$mn:000043A6                 push    edx
.text$mn:000043A7                 mov     eax, [ebp+var_C]
.text$mn:000043AA                 push    eax
.text$mn:000043AB                 mov     ecx, [ebp+var_8]
.text$mn:000043AE                 mov     edx, [ecx+4]
.text$mn:000043B1                 mov     eax, [ebp+var_10]
.text$mn:000043B4                 lea     ecx, [edx+eax*4]
.text$mn:000043B7                 push    ecx
.text$mn:000043B8                 mov     edx, [ebp+var_8]
.text$mn:000043BB                 mov     eax, [edx+4]
.text$mn:000043BE                 push    eax
.text$mn:000043BF                 call    ??$_Uninitialized_copy@PAPAURecentItem@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAPAPAURecentItem@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z ; std::_Uninitialized_copy<RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &)
.text$mn:000043C4                 add     esp, 10h
.text$mn:000043C7                 mov     [ebp+var_C], eax
.text$mn:000043CA                 lea     ecx, [ebp+var_1]
.text$mn:000043CD                 push    ecx
.text$mn:000043CE                 mov     edx, [ebp+arg_0]
.text$mn:000043D1                 sub     edx, [ebp+var_10]
.text$mn:000043D4                 push    edx
.text$mn:000043D5                 mov     eax, [ebp+var_C]
.text$mn:000043D8                 push    eax
.text$mn:000043D9                 call    ??$_Uninitialized_default_fill_n@PAPAURecentItem@@IU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAXPAPAURecentItem@@IAAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<RecentItem * *,uint,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,uint,std::_Wrap_alloc<std::allocator<RecentItem *>> &)
.text$mn:000043DE                 add     esp, 0Ch
.text$mn:000043E1                 lea     ecx, [ebp+var_1]
.text$mn:000043E4                 push    ecx
.text$mn:000043E5                 mov     edx, [ebp+var_10]
.text$mn:000043E8                 push    edx
.text$mn:000043E9                 mov     eax, [ebp+var_18]
.text$mn:000043EC                 push    eax
.text$mn:000043ED                 call    ??$_Uninitialized_default_fill_n@PAPAURecentItem@@IU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAXPAPAURecentItem@@IAAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<RecentItem * *,uint,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,uint,std::_Wrap_alloc<std::allocator<RecentItem *>> &)
.text$mn:000043F2                 add     esp, 0Ch
.text$mn:000043F5                 jmp     short loc_445C
.text$mn:000043F7 ; ---------------------------------------------------------------------------
.text$mn:000043F7
.text$mn:000043F7 loc_43F7:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+E1j
.text$mn:000043F7                 lea     ecx, [ebp+var_1]
.text$mn:000043FA                 push    ecx
.text$mn:000043FB                 mov     edx, [ebp+var_C]
.text$mn:000043FE                 push    edx
.text$mn:000043FF                 mov     eax, [ebp+var_8]
.text$mn:00004402                 mov     ecx, [eax+4]
.text$mn:00004405                 mov     edx, [ebp+arg_0]
.text$mn:00004408                 lea     eax, [ecx+edx*4]
.text$mn:0000440B                 push    eax
.text$mn:0000440C                 mov     ecx, [ebp+var_8]
.text$mn:0000440F                 mov     edx, [ecx+4]
.text$mn:00004412                 push    edx
.text$mn:00004413                 call    ??$_Uninitialized_copy@PAPAURecentItem@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAPAPAURecentItem@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z ; std::_Uninitialized_copy<RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &)
.text$mn:00004418                 add     esp, 10h
.text$mn:0000441B                 lea     eax, [ebp+var_1]
.text$mn:0000441E                 push    eax
.text$mn:0000441F                 mov     ecx, [ebp+var_18]
.text$mn:00004422                 push    ecx
.text$mn:00004423                 mov     edx, [ebp+var_8]
.text$mn:00004426                 mov     eax, [edx+4]
.text$mn:00004429                 mov     ecx, [ebp+var_10]
.text$mn:0000442C                 lea     edx, [eax+ecx*4]
.text$mn:0000442F                 push    edx
.text$mn:00004430                 mov     eax, [ebp+var_8]
.text$mn:00004433                 mov     ecx, [eax+4]
.text$mn:00004436                 mov     edx, [ebp+arg_0]
.text$mn:00004439                 lea     eax, [ecx+edx*4]
.text$mn:0000443C                 push    eax
.text$mn:0000443D                 call    ??$_Uninitialized_copy@PAPAURecentItem@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAPAPAURecentItem@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z ; std::_Uninitialized_copy<RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &)
.text$mn:00004442                 add     esp, 10h
.text$mn:00004445                 mov     [ebp+var_C], eax
.text$mn:00004448                 lea     ecx, [ebp+var_1]
.text$mn:0000444B                 push    ecx
.text$mn:0000444C                 mov     edx, [ebp+arg_0]
.text$mn:0000444F                 push    edx
.text$mn:00004450                 mov     eax, [ebp+var_C]
.text$mn:00004453                 push    eax
.text$mn:00004454                 call    ??$_Uninitialized_default_fill_n@PAPAURecentItem@@IU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAXPAPAURecentItem@@IAAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<RecentItem * *,uint,std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,uint,std::_Wrap_alloc<std::allocator<RecentItem *>> &)
.text$mn:00004459                 add     esp, 0Ch
.text$mn:0000445C
.text$mn:0000445C loc_445C:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+135j
.text$mn:0000445C                 lea     ecx, [ebp+var_1]
.text$mn:0000445F                 push    ecx
.text$mn:00004460                 mov     edx, [ebp+var_8]
.text$mn:00004463                 mov     eax, [edx+8]
.text$mn:00004466                 mov     ecx, [ebp+var_8]
.text$mn:00004469                 mov     edx, [ecx+4]
.text$mn:0000446C                 lea     eax, [edx+eax*4]
.text$mn:0000446F                 push    eax
.text$mn:00004470                 mov     ecx, [ebp+var_8]
.text$mn:00004473                 mov     edx, [ecx+4]
.text$mn:00004476                 mov     eax, [ebp+var_10]
.text$mn:00004479                 lea     ecx, [edx+eax*4]
.text$mn:0000447C                 push    ecx
.text$mn:0000447D                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@@std@@YAXPAPAURecentItem@@0AAU?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<RecentItem *>>>(RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &)
.text$mn:00004482                 add     esp, 0Ch
.text$mn:00004485                 mov     edx, [ebp+var_8]
.text$mn:00004488                 cmp     dword ptr [edx+4], 0
.text$mn:0000448C                 jz      short loc_44A4
.text$mn:0000448E                 mov     eax, [ebp+var_8]
.text$mn:00004491                 mov     ecx, [eax+8]
.text$mn:00004494                 push    ecx             ; int
.text$mn:00004495                 mov     edx, [ebp+var_8]
.text$mn:00004498                 mov     eax, [edx+4]
.text$mn:0000449B                 push    eax             ; void *
.text$mn:0000449C                 lea     ecx, [ebp+var_1]
.text$mn:0000449F                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@QAEXPAPAURecentItem@@I@Z ; std::_Wrap_alloc<std::allocator<RecentItem *>>::deallocate(RecentItem * *,uint)
.text$mn:000044A4
.text$mn:000044A4 loc_44A4:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+1CCj
.text$mn:000044A4                 mov     ecx, [ebp+var_8]
.text$mn:000044A7                 mov     edx, [ebp+var_18]
.text$mn:000044AA                 mov     [ecx+4], edx
.text$mn:000044AD                 mov     eax, [ebp+var_8]
.text$mn:000044B0                 mov     ecx, [eax+8]
.text$mn:000044B3                 add     ecx, [ebp+arg_0]
.text$mn:000044B6                 mov     edx, [ebp+var_8]
.text$mn:000044B9                 mov     [edx+8], ecx
.text$mn:000044BC                 mov     esp, ebp
.text$mn:000044BE                 pop     ebp
.text$mn:000044BF                 retn    4
.text$mn:000044BF ?_Growmap@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IAEXI@Z endp
.text$mn:000044BF
.text$mn:000044BF ; ---------------------------------------------------------------------------
.text$mn:000044C2                 align 4
.text$mn:000044C2 _text$mn        ends
.text$mn:000044C2
.text$mn:000044C4 ; ===========================================================================
.text$mn:000044C4
.text$mn:000044C4 ; Segment type: Pure code
.text$mn:000044C4 ; Segment permissions: Read/Execute
.text$mn:000044C4 _text$mn        segment para public 'CODE' use32
.text$mn:000044C4                 assume cs:_text$mn
.text$mn:000044C4                 ;org 44C4h
.text$mn:000044C4 ; COMDAT (pick any)
.text$mn:000044C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000044C4
.text$mn:000044C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000044C4
.text$mn:000044C4 ; Attributes: bp-based frame
.text$mn:000044C4
.text$mn:000044C4 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:000044C4                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:000044C4 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:000044C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:000044C4
.text$mn:000044C4 var_4           = dword ptr -4
.text$mn:000044C4 arg_0           = dword ptr  8
.text$mn:000044C4
.text$mn:000044C4                 push    ebp
.text$mn:000044C5                 mov     ebp, esp
.text$mn:000044C7                 push    ecx
.text$mn:000044C8                 mov     [ebp+var_4], ecx
.text$mn:000044CB                 cmp     [ebp+arg_0], 0
.text$mn:000044CF                 jz      short loc_44F1
.text$mn:000044D1                 mov     ecx, [ebp+var_4]
.text$mn:000044D4                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000044D9                 cmp     [ebp+arg_0], eax
.text$mn:000044DC                 jb      short loc_44F1
.text$mn:000044DE                 mov     ecx, [ebp+var_4]
.text$mn:000044E1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000044E6                 mov     ecx, [ebp+var_4]
.text$mn:000044E9                 add     eax, [ecx+14h]
.text$mn:000044EC                 cmp     eax, [ebp+arg_0]
.text$mn:000044EF                 ja      short loc_44F7
.text$mn:000044F1
.text$mn:000044F1 loc_44F1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:000044F1                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:000044F1                 xor     al, al
.text$mn:000044F3                 jmp     short loc_44F9
.text$mn:000044F5 ; ---------------------------------------------------------------------------
.text$mn:000044F5                 jmp     short loc_44F9
.text$mn:000044F7 ; ---------------------------------------------------------------------------
.text$mn:000044F7
.text$mn:000044F7 loc_44F7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:000044F7                 mov     al, 1
.text$mn:000044F9
.text$mn:000044F9 loc_44F9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:000044F9                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:000044F9                 mov     esp, ebp
.text$mn:000044FB                 pop     ebp
.text$mn:000044FC                 retn    4
.text$mn:000044FC ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:000044FC
.text$mn:000044FC ; ---------------------------------------------------------------------------
.text$mn:000044FF                 align 10h
.text$mn:000044FF _text$mn        ends
.text$mn:000044FF
.text$mn:00004500 ; ===========================================================================
.text$mn:00004500
.text$mn:00004500 ; Segment type: Pure code
.text$mn:00004500 ; Segment permissions: Read/Execute
.text$mn:00004500 _text$mn        segment para public 'CODE' use32
.text$mn:00004500                 assume cs:_text$mn
.text$mn:00004500                 ;org 4500h
.text$mn:00004500 ; COMDAT (pick any)
.text$mn:00004500                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004500
.text$mn:00004500 ; =============== S U B R O U T I N E =======================================
.text$mn:00004500
.text$mn:00004500 ; Attributes: bp-based frame
.text$mn:00004500
.text$mn:00004500 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00004500                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:00004500 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:00004500                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap
.text$mn:00004500
.text$mn:00004500 var_4           = dword ptr -4
.text$mn:00004500 arg_0           = dword ptr  8
.text$mn:00004500
.text$mn:00004500                 push    ebp
.text$mn:00004501                 mov     ebp, esp
.text$mn:00004503                 push    ecx
.text$mn:00004504                 mov     [ebp+var_4], ecx
.text$mn:00004507                 cmp     [ebp+arg_0], 0
.text$mn:0000450B                 jz      short loc_4530
.text$mn:0000450D                 mov     ecx, [ebp+var_4]
.text$mn:00004510                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004515                 cmp     [ebp+arg_0], eax
.text$mn:00004518                 jb      short loc_4530
.text$mn:0000451A                 mov     ecx, [ebp+var_4]
.text$mn:0000451D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004522                 mov     ecx, [ebp+var_4]
.text$mn:00004525                 mov     edx, [ecx+14h]
.text$mn:00004528                 lea     eax, [eax+edx*2]
.text$mn:0000452B                 cmp     eax, [ebp+arg_0]
.text$mn:0000452E                 ja      short loc_4536
.text$mn:00004530
.text$mn:00004530 loc_4530:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:00004530                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:00004530                 xor     al, al
.text$mn:00004532                 jmp     short loc_4538
.text$mn:00004534 ; ---------------------------------------------------------------------------
.text$mn:00004534                 jmp     short loc_4538
.text$mn:00004536 ; ---------------------------------------------------------------------------
.text$mn:00004536
.text$mn:00004536 loc_4536:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:00004536                 mov     al, 1
.text$mn:00004538
.text$mn:00004538 loc_4538:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:00004538                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:00004538                 mov     esp, ebp
.text$mn:0000453A                 pop     ebp
.text$mn:0000453B                 retn    4
.text$mn:0000453B ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:0000453B
.text$mn:0000453B ; ---------------------------------------------------------------------------
.text$mn:0000453E                 align 10h
.text$mn:0000453E _text$mn        ends
.text$mn:0000453E
.text$mn:00004540 ; ===========================================================================
.text$mn:00004540
.text$mn:00004540 ; Segment type: Pure code
.text$mn:00004540 ; Segment permissions: Read/Execute
.text$mn:00004540 _text$mn        segment para public 'CODE' use32
.text$mn:00004540                 assume cs:_text$mn
.text$mn:00004540                 ;org 4540h
.text$mn:00004540 ; COMDAT (pick any)
.text$mn:00004540                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004540
.text$mn:00004540 ; =============== S U B R O U T I N E =======================================
.text$mn:00004540
.text$mn:00004540 ; Attributes: bp-based frame
.text$mn:00004540
.text$mn:00004540 ; public: class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::_Make_iter(class std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>)const
.text$mn:00004540                 public ?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z
.text$mn:00004540 ?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z proc near
.text$mn:00004540                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+68p
.text$mn:00004540                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+ACp
.text$mn:00004540
.text$mn:00004540 var_14          = dword ptr -14h
.text$mn:00004540 var_10          = dword ptr -10h
.text$mn:00004540 var_C           = dword ptr -0Ch
.text$mn:00004540 var_4           = dword ptr -4
.text$mn:00004540 arg_0           = dword ptr  8
.text$mn:00004540 arg_4           = byte ptr  0Ch
.text$mn:00004540 arg_C           = dword ptr  14h
.text$mn:00004540
.text$mn:00004540                 push    ebp
.text$mn:00004541                 mov     ebp, esp
.text$mn:00004543                 push    0FFFFFFFFh
.text$mn:00004545                 push    offset __ehhandler$?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z
.text$mn:0000454A                 mov     eax, large fs:0
.text$mn:00004550                 push    eax
.text$mn:00004551                 sub     esp, 8
.text$mn:00004554                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004559                 xor     eax, ebp
.text$mn:0000455B                 push    eax
.text$mn:0000455C                 lea     eax, [ebp+var_C]
.text$mn:0000455F                 mov     large fs:0, eax
.text$mn:00004565                 mov     [ebp+var_14], ecx
.text$mn:00004568                 mov     [ebp+var_10], 0
.text$mn:0000456F                 mov     [ebp+var_4], 1
.text$mn:00004576                 mov     eax, [ebp+var_14]
.text$mn:00004579                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000457A                 mov     ecx, [ebp+arg_C]
.text$mn:0000457D                 push    ecx             ; int
.text$mn:0000457E                 mov     ecx, [ebp+arg_0]
.text$mn:00004581                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(uint,std::_Container_base12 const *)
.text$mn:00004586                 mov     edx, [ebp+var_10]
.text$mn:00004589                 or      edx, 1
.text$mn:0000458C                 mov     [ebp+var_10], edx
.text$mn:0000458F                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004593                 lea     ecx, [ebp+arg_4]
.text$mn:00004596                 call    ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:0000459B                 mov     eax, [ebp+arg_0]
.text$mn:0000459E                 mov     ecx, [ebp+var_C]
.text$mn:000045A1                 mov     large fs:0, ecx
.text$mn:000045A8                 pop     ecx
.text$mn:000045A9                 mov     esp, ebp
.text$mn:000045AB                 pop     ebp
.text$mn:000045AC                 retn    10h
.text$mn:000045AC ?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z endp
.text$mn:000045AC
.text$mn:000045AC ; ---------------------------------------------------------------------------
.text$mn:000045AF                 align 10h
.text$mn:000045AF _text$mn        ends
.text$mn:000045AF
.text$x:000045B0 ; ===========================================================================
.text$x:000045B0
.text$x:000045B0 ; Segment type: Pure code
.text$x:000045B0 ; Segment permissions: Read/Execute
.text$x:000045B0 _text$x         segment para public 'CODE' use32
.text$x:000045B0                 assume cs:_text$x
.text$x:000045B0                 ;org 45B0h
.text$x:000045B0 ; COMDAT (pick associative to section at 4540)
.text$x:000045B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000045B0
.text$x:000045B0 ; =============== S U B R O U T I N E =======================================
.text$x:000045B0
.text$x:000045B0
.text$x:000045B0 __unwindfunclet$?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$0 proc near
.text$x:000045B0                                         ; DATA XREF: .xdata$x:00006FC8o
.text$x:000045B0                 lea     ecx, [ebp+0Ch]
.text$x:000045B3                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000045B3 __unwindfunclet$?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$0 endp
.text$x:000045B3
.text$x:000045B8
.text$x:000045B8 ; =============== S U B R O U T I N E =======================================
.text$x:000045B8
.text$x:000045B8
.text$x:000045B8 __unwindfunclet$?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$1 proc near
.text$x:000045B8                                         ; DATA XREF: .xdata$x:00006FC0o
.text$x:000045B8                 mov     eax, [ebp-10h]
.text$x:000045BB                 and     eax, 1
.text$x:000045BE                 jz      $LN5
.text$x:000045C4                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000045C8                 mov     ecx, [ebp+8]
.text$x:000045CB                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000045D0 ; ---------------------------------------------------------------------------
.text$x:000045D0
.text$x:000045D0 $LN5:                                   ; CODE XREF: __unwindfunclet$?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$1+6j
.text$x:000045D0                 retn
.text$x:000045D0 __unwindfunclet$?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$1 endp
.text$x:000045D0
.text$x:000045D1
.text$x:000045D1 ; =============== S U B R O U T I N E =======================================
.text$x:000045D1
.text$x:000045D1
.text$x:000045D1 __ehhandler$?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z proc near
.text$x:000045D1                                         ; DATA XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Make_iter(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+5o
.text$x:000045D1
.text$x:000045D1 arg_4           = dword ptr  8
.text$x:000045D1
.text$x:000045D1                 mov     edx, [esp+arg_4]
.text$x:000045D5                 lea     eax, [edx+0Ch]
.text$x:000045D8                 mov     ecx, [edx-0Ch]
.text$x:000045DB                 xor     ecx, eax
.text$x:000045DD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000045E2                 mov     eax, offset __ehfuncinfo$?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z
.text$x:000045E7                 jmp     ___CxxFrameHandler3
.text$x:000045E7 __ehhandler$?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z endp
.text$x:000045E7
.text$x:000045E7 _text$x         ends
.text$x:000045E7
.text$mn:000045EC ; ===========================================================================
.text$mn:000045EC
.text$mn:000045EC ; Segment type: Pure code
.text$mn:000045EC ; Segment permissions: Read/Execute
.text$mn:000045EC _text$mn        segment para public 'CODE' use32
.text$mn:000045EC                 assume cs:_text$mn
.text$mn:000045EC                 ;org 45ECh
.text$mn:000045EC ; COMDAT (pick any)
.text$mn:000045EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000045EC
.text$mn:000045EC ; =============== S U B R O U T I N E =======================================
.text$mn:000045EC
.text$mn:000045EC ; Attributes: bp-based frame
.text$mn:000045EC
.text$mn:000045EC ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:000045EC                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:000045EC ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:000045EC                                         ; CODE XREF: $LN19+14p
.text$mn:000045EC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:000045EC
.text$mn:000045EC var_8           = dword ptr -8
.text$mn:000045EC var_4           = dword ptr -4
.text$mn:000045EC
.text$mn:000045EC                 push    ebp
.text$mn:000045ED                 mov     ebp, esp
.text$mn:000045EF                 sub     esp, 8
.text$mn:000045F2                 mov     [ebp+var_4], ecx
.text$mn:000045F5                 mov     eax, [ebp+var_4]
.text$mn:000045F8                 cmp     dword ptr [eax+18h], 10h
.text$mn:000045FC                 jb      short loc_4612
.text$mn:000045FE                 mov     ecx, [ebp+var_4]
.text$mn:00004601                 mov     edx, [ecx+4]
.text$mn:00004604                 push    edx
.text$mn:00004605                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000460A                 add     esp, 4
.text$mn:0000460D                 mov     [ebp+var_8], eax
.text$mn:00004610                 jmp     short loc_461B
.text$mn:00004612 ; ---------------------------------------------------------------------------
.text$mn:00004612
.text$mn:00004612 loc_4612:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00004612                 mov     eax, [ebp+var_4]
.text$mn:00004615                 add     eax, 4
.text$mn:00004618                 mov     [ebp+var_8], eax
.text$mn:0000461B
.text$mn:0000461B loc_461B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000461B                 mov     eax, [ebp+var_8]
.text$mn:0000461E                 mov     esp, ebp
.text$mn:00004620                 pop     ebp
.text$mn:00004621                 retn
.text$mn:00004621 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00004621
.text$mn:00004621 ; ---------------------------------------------------------------------------
.text$mn:00004622                 align 4
.text$mn:00004622 _text$mn        ends
.text$mn:00004622
.text$mn:00004624 ; ===========================================================================
.text$mn:00004624
.text$mn:00004624 ; Segment type: Pure code
.text$mn:00004624 ; Segment permissions: Read/Execute
.text$mn:00004624 _text$mn        segment para public 'CODE' use32
.text$mn:00004624                 assume cs:_text$mn
.text$mn:00004624                 ;org 4624h
.text$mn:00004624 ; COMDAT (pick any)
.text$mn:00004624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004624
.text$mn:00004624 ; =============== S U B R O U T I N E =======================================
.text$mn:00004624
.text$mn:00004624 ; Attributes: bp-based frame
.text$mn:00004624
.text$mn:00004624 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00004624                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00004624 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00004624                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00004624
.text$mn:00004624 var_8           = dword ptr -8
.text$mn:00004624 var_4           = dword ptr -4
.text$mn:00004624
.text$mn:00004624                 push    ebp
.text$mn:00004625                 mov     ebp, esp
.text$mn:00004627                 sub     esp, 8
.text$mn:0000462A                 mov     [ebp+var_4], ecx
.text$mn:0000462D                 mov     eax, [ebp+var_4]
.text$mn:00004630                 cmp     dword ptr [eax+18h], 10h
.text$mn:00004634                 jb      short loc_464A
.text$mn:00004636                 mov     ecx, [ebp+var_4]
.text$mn:00004639                 mov     edx, [ecx+4]
.text$mn:0000463C                 push    edx
.text$mn:0000463D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00004642                 add     esp, 4
.text$mn:00004645                 mov     [ebp+var_8], eax
.text$mn:00004648                 jmp     short loc_4653
.text$mn:0000464A ; ---------------------------------------------------------------------------
.text$mn:0000464A
.text$mn:0000464A loc_464A:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000464A                 mov     eax, [ebp+var_4]
.text$mn:0000464D                 add     eax, 4
.text$mn:00004650                 mov     [ebp+var_8], eax
.text$mn:00004653
.text$mn:00004653 loc_4653:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00004653                 mov     eax, [ebp+var_8]
.text$mn:00004656                 mov     esp, ebp
.text$mn:00004658                 pop     ebp
.text$mn:00004659                 retn
.text$mn:00004659 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00004659
.text$mn:00004659 ; ---------------------------------------------------------------------------
.text$mn:0000465A                 align 4
.text$mn:0000465A _text$mn        ends
.text$mn:0000465A
.text$mn:0000465C ; ===========================================================================
.text$mn:0000465C
.text$mn:0000465C ; Segment type: Pure code
.text$mn:0000465C ; Segment permissions: Read/Execute
.text$mn:0000465C _text$mn        segment para public 'CODE' use32
.text$mn:0000465C                 assume cs:_text$mn
.text$mn:0000465C                 ;org 465Ch
.text$mn:0000465C ; COMDAT (pick any)
.text$mn:0000465C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000465C
.text$mn:0000465C ; =============== S U B R O U T I N E =======================================
.text$mn:0000465C
.text$mn:0000465C ; Attributes: bp-based frame
.text$mn:0000465C
.text$mn:0000465C ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000465C                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:0000465C ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:0000465C                                         ; CODE XREF: $LN19_0+14p
.text$mn:0000465C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp ...
.text$mn:0000465C
.text$mn:0000465C var_8           = dword ptr -8
.text$mn:0000465C var_4           = dword ptr -4
.text$mn:0000465C
.text$mn:0000465C                 push    ebp
.text$mn:0000465D                 mov     ebp, esp
.text$mn:0000465F                 sub     esp, 8
.text$mn:00004662                 mov     [ebp+var_4], ecx
.text$mn:00004665                 mov     eax, [ebp+var_4]
.text$mn:00004668                 cmp     dword ptr [eax+18h], 8
.text$mn:0000466C                 jb      short loc_4682
.text$mn:0000466E                 mov     ecx, [ebp+var_4]
.text$mn:00004671                 mov     edx, [ecx+4]
.text$mn:00004674                 push    edx
.text$mn:00004675                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000467A                 add     esp, 4
.text$mn:0000467D                 mov     [ebp+var_8], eax
.text$mn:00004680                 jmp     short loc_468B
.text$mn:00004682 ; ---------------------------------------------------------------------------
.text$mn:00004682
.text$mn:00004682 loc_4682:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00004682                 mov     eax, [ebp+var_4]
.text$mn:00004685                 add     eax, 4
.text$mn:00004688                 mov     [ebp+var_8], eax
.text$mn:0000468B
.text$mn:0000468B loc_468B:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:0000468B                 mov     eax, [ebp+var_8]
.text$mn:0000468E                 mov     esp, ebp
.text$mn:00004690                 pop     ebp
.text$mn:00004691                 retn
.text$mn:00004691 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:00004691
.text$mn:00004691 ; ---------------------------------------------------------------------------
.text$mn:00004692                 align 4
.text$mn:00004692 _text$mn        ends
.text$mn:00004692
.text$mn:00004694 ; ===========================================================================
.text$mn:00004694
.text$mn:00004694 ; Segment type: Pure code
.text$mn:00004694 ; Segment permissions: Read/Execute
.text$mn:00004694 _text$mn        segment para public 'CODE' use32
.text$mn:00004694                 assume cs:_text$mn
.text$mn:00004694                 ;org 4694h
.text$mn:00004694 ; COMDAT (pick any)
.text$mn:00004694                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004694
.text$mn:00004694 ; =============== S U B R O U T I N E =======================================
.text$mn:00004694
.text$mn:00004694 ; Attributes: bp-based frame
.text$mn:00004694
.text$mn:00004694 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:00004694                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:00004694 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:00004694                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp
.text$mn:00004694                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)+Ap ...
.text$mn:00004694
.text$mn:00004694 var_8           = dword ptr -8
.text$mn:00004694 var_4           = dword ptr -4
.text$mn:00004694
.text$mn:00004694                 push    ebp
.text$mn:00004695                 mov     ebp, esp
.text$mn:00004697                 sub     esp, 8
.text$mn:0000469A                 mov     [ebp+var_4], ecx
.text$mn:0000469D                 mov     eax, [ebp+var_4]
.text$mn:000046A0                 cmp     dword ptr [eax+18h], 8
.text$mn:000046A4                 jb      short loc_46BA
.text$mn:000046A6                 mov     ecx, [ebp+var_4]
.text$mn:000046A9                 mov     edx, [ecx+4]
.text$mn:000046AC                 push    edx
.text$mn:000046AD                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:000046B2                 add     esp, 4
.text$mn:000046B5                 mov     [ebp+var_8], eax
.text$mn:000046B8                 jmp     short loc_46C3
.text$mn:000046BA ; ---------------------------------------------------------------------------
.text$mn:000046BA
.text$mn:000046BA loc_46BA:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:000046BA                 mov     eax, [ebp+var_4]
.text$mn:000046BD                 add     eax, 4
.text$mn:000046C0                 mov     [ebp+var_8], eax
.text$mn:000046C3
.text$mn:000046C3 loc_46C3:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:000046C3                 mov     eax, [ebp+var_8]
.text$mn:000046C6                 mov     esp, ebp
.text$mn:000046C8                 pop     ebp
.text$mn:000046C9                 retn
.text$mn:000046C9 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:000046C9
.text$mn:000046C9 ; ---------------------------------------------------------------------------
.text$mn:000046CA                 align 4
.text$mn:000046CA _text$mn        ends
.text$mn:000046CA
.text$mn:000046CC ; ===========================================================================
.text$mn:000046CC
.text$mn:000046CC ; Segment type: Pure code
.text$mn:000046CC ; Segment permissions: Read/Execute
.text$mn:000046CC _text$mn        segment para public 'CODE' use32
.text$mn:000046CC                 assume cs:_text$mn
.text$mn:000046CC                 ;org 46CCh
.text$mn:000046CC ; COMDAT (pick any)
.text$mn:000046CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046CC
.text$mn:000046CC ; =============== S U B R O U T I N E =======================================
.text$mn:000046CC
.text$mn:000046CC ; Attributes: bp-based frame
.text$mn:000046CC
.text$mn:000046CC ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:000046CC                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000046CC ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:000046CC                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:000046CC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:000046CC
.text$mn:000046CC var_18          = byte ptr -18h
.text$mn:000046CC var_14          = dword ptr -14h
.text$mn:000046CC var_10          = dword ptr -10h
.text$mn:000046CC var_C           = dword ptr -0Ch
.text$mn:000046CC var_4           = dword ptr -4
.text$mn:000046CC
.text$mn:000046CC                 push    ebp
.text$mn:000046CD                 mov     ebp, esp
.text$mn:000046CF                 push    0FFFFFFFFh
.text$mn:000046D1                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000046D6                 mov     eax, large fs:0
.text$mn:000046DC                 push    eax
.text$mn:000046DD                 sub     esp, 0Ch
.text$mn:000046E0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000046E5                 xor     eax, ebp
.text$mn:000046E7                 push    eax
.text$mn:000046E8                 lea     eax, [ebp+var_C]
.text$mn:000046EB                 mov     large fs:0, eax
.text$mn:000046F1                 mov     [ebp+var_14], ecx
.text$mn:000046F4                 mov     eax, [ebp+var_14]
.text$mn:000046F7                 cmp     dword ptr [eax], 0
.text$mn:000046FA                 jz      short loc_4757
.text$mn:000046FC                 push    3               ; int
.text$mn:000046FE                 lea     ecx, [ebp+var_18] ; this
.text$mn:00004701                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00004706                 mov     [ebp+var_4], 0
.text$mn:0000470D                 mov     ecx, [ebp+var_14]
.text$mn:00004710                 mov     edx, [ecx]
.text$mn:00004712                 add     edx, 4
.text$mn:00004715                 mov     [ebp+var_10], edx
.text$mn:00004718                 jmp     short loc_4727
.text$mn:0000471A ; ---------------------------------------------------------------------------
.text$mn:0000471A
.text$mn:0000471A loc_471A:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:0000471A                 mov     eax, [ebp+var_10]
.text$mn:0000471D                 mov     ecx, [eax]
.text$mn:0000471F                 mov     edx, [ebp+var_10]
.text$mn:00004722                 mov     eax, [ecx+4]
.text$mn:00004725                 mov     [edx], eax
.text$mn:00004727
.text$mn:00004727 loc_4727:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00004727                 mov     ecx, [ebp+var_10]
.text$mn:0000472A                 cmp     dword ptr [ecx], 0
.text$mn:0000472D                 jz      short loc_473C
.text$mn:0000472F                 mov     edx, [ebp+var_10]
.text$mn:00004732                 mov     eax, [edx]
.text$mn:00004734                 mov     dword ptr [eax], 0
.text$mn:0000473A                 jmp     short loc_471A
.text$mn:0000473C ; ---------------------------------------------------------------------------
.text$mn:0000473C
.text$mn:0000473C loc_473C:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:0000473C                 mov     ecx, [ebp+var_14]
.text$mn:0000473F                 mov     edx, [ecx]
.text$mn:00004741                 mov     dword ptr [edx+4], 0
.text$mn:00004748                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000474F                 lea     ecx, [ebp+var_18] ; this
.text$mn:00004752                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00004757
.text$mn:00004757 loc_4757:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00004757                 mov     ecx, [ebp+var_C]
.text$mn:0000475A                 mov     large fs:0, ecx
.text$mn:00004761                 pop     ecx
.text$mn:00004762                 mov     esp, ebp
.text$mn:00004764                 pop     ebp
.text$mn:00004765                 retn
.text$mn:00004765 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00004765
.text$mn:00004765 ; ---------------------------------------------------------------------------
.text$mn:00004766                 align 4
.text$mn:00004766 _text$mn        ends
.text$mn:00004766
.text$x:00004768 ; ===========================================================================
.text$x:00004768
.text$x:00004768 ; Segment type: Pure code
.text$x:00004768 ; Segment permissions: Read/Execute
.text$x:00004768 _text$x         segment para public 'CODE' use32
.text$x:00004768                 assume cs:_text$x
.text$x:00004768                 ;org 4768h
.text$x:00004768 ; COMDAT (pick associative to section at 46CC)
.text$x:00004768                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004768
.text$x:00004768 ; =============== S U B R O U T I N E =======================================
.text$x:00004768
.text$x:00004768
.text$x:00004768 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00004768                                         ; DATA XREF: .xdata$x:00006830o
.text$x:00004768                 lea     ecx, [ebp-18h]  ; this
.text$x:0000476B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000476B __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:0000476B
.text$x:00004770
.text$x:00004770 ; =============== S U B R O U T I N E =======================================
.text$x:00004770
.text$x:00004770
.text$x:00004770 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00004770                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00004770
.text$x:00004770 arg_4           = dword ptr  8
.text$x:00004770
.text$x:00004770                 mov     edx, [esp+arg_4]
.text$x:00004774                 lea     eax, [edx+0Ch]
.text$x:00004777                 mov     ecx, [edx-10h]
.text$x:0000477A                 xor     ecx, eax
.text$x:0000477C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004781                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00004786                 jmp     ___CxxFrameHandler3
.text$x:00004786 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00004786
.text$x:00004786 ; ---------------------------------------------------------------------------
.text$x:0000478B                 align 4
.text$x:0000478B _text$x         ends
.text$x:0000478B
.text$mn:0000478C ; ===========================================================================
.text$mn:0000478C
.text$mn:0000478C ; Segment type: Pure code
.text$mn:0000478C ; Segment permissions: Read/Execute
.text$mn:0000478C _text$mn        segment para public 'CODE' use32
.text$mn:0000478C                 assume cs:_text$mn
.text$mn:0000478C                 ;org 478Ch
.text$mn:0000478C ; COMDAT (pick any)
.text$mn:0000478C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000478C
.text$mn:0000478C ; =============== S U B R O U T I N E =======================================
.text$mn:0000478C
.text$mn:0000478C ; Attributes: bp-based frame
.text$mn:0000478C
.text$mn:0000478C ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:0000478C                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:0000478C ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:0000478C                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:0000478C                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:0000478C
.text$mn:0000478C var_8           = dword ptr -8
.text$mn:0000478C var_4           = dword ptr -4
.text$mn:0000478C
.text$mn:0000478C                 push    ebp
.text$mn:0000478D                 mov     ebp, esp
.text$mn:0000478F                 sub     esp, 8
.text$mn:00004792                 mov     [ebp+var_8], ecx
.text$mn:00004795                 mov     eax, [ebp+var_8]
.text$mn:00004798                 cmp     dword ptr [eax], 0
.text$mn:0000479B                 jz      short loc_47FA
.text$mn:0000479D                 mov     ecx, [ebp+var_8]
.text$mn:000047A0                 mov     edx, [ecx]
.text$mn:000047A2                 add     edx, 4
.text$mn:000047A5                 mov     [ebp+var_4], edx
.text$mn:000047A8
.text$mn:000047A8 loc_47A8:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:000047A8                 mov     eax, [ebp+var_4]
.text$mn:000047AB                 cmp     dword ptr [eax], 0
.text$mn:000047AE                 jz      short loc_47C7
.text$mn:000047B0                 mov     ecx, [ebp+var_4]
.text$mn:000047B3                 mov     edx, [ecx]
.text$mn:000047B5                 cmp     edx, [ebp+var_8]
.text$mn:000047B8                 jz      short loc_47C7
.text$mn:000047BA                 mov     eax, [ebp+var_4]
.text$mn:000047BD                 mov     ecx, [eax]
.text$mn:000047BF                 add     ecx, 4
.text$mn:000047C2                 mov     [ebp+var_4], ecx
.text$mn:000047C5                 jmp     short loc_47A8
.text$mn:000047C7 ; ---------------------------------------------------------------------------
.text$mn:000047C7
.text$mn:000047C7 loc_47C7:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:000047C7                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:000047C7                 mov     edx, [ebp+var_4]
.text$mn:000047CA                 cmp     dword ptr [edx], 0
.text$mn:000047CD                 jnz     short loc_47E6
.text$mn:000047CF                 push    0C9h ; '+'      ; unsigned int
.text$mn:000047D4                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000047D9                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:000047DE                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000047E3                 add     esp, 0Ch
.text$mn:000047E6
.text$mn:000047E6 loc_47E6:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:000047E6                 mov     eax, [ebp+var_4]
.text$mn:000047E9                 mov     ecx, [ebp+var_8]
.text$mn:000047EC                 mov     edx, [ecx+4]
.text$mn:000047EF                 mov     [eax], edx
.text$mn:000047F1                 mov     eax, [ebp+var_8]
.text$mn:000047F4                 mov     dword ptr [eax], 0
.text$mn:000047FA
.text$mn:000047FA loc_47FA:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:000047FA                 mov     esp, ebp
.text$mn:000047FC                 pop     ebp
.text$mn:000047FD                 retn
.text$mn:000047FD ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:000047FD
.text$mn:000047FD ; ---------------------------------------------------------------------------
.text$mn:000047FE                 align 10h
.text$mn:000047FE _text$mn        ends
.text$mn:000047FE
.text$mn:00004800 ; ===========================================================================
.text$mn:00004800
.text$mn:00004800 ; Segment type: Pure code
.text$mn:00004800 ; Segment permissions: Read/Execute
.text$mn:00004800 _text$mn        segment para public 'CODE' use32
.text$mn:00004800                 assume cs:_text$mn
.text$mn:00004800                 ;org 4800h
.text$mn:00004800 ; COMDAT (pick any)
.text$mn:00004800                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004800
.text$mn:00004800 ; =============== S U B R O U T I N E =======================================
.text$mn:00004800
.text$mn:00004800 ; Attributes: bp-based frame
.text$mn:00004800
.text$mn:00004800 ; protected: void __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::_Orphan_off(unsigned int)const
.text$mn:00004800                 public ?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z
.text$mn:00004800 ?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z proc near
.text$mn:00004800                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::pop_back(void)+4Fp
.text$mn:00004800                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::pop_front(void)+3Fp
.text$mn:00004800
.text$mn:00004800 var_20          = byte ptr -20h
.text$mn:00004800 var_1C          = dword ptr -1Ch
.text$mn:00004800 var_18          = dword ptr -18h
.text$mn:00004800 var_14          = dword ptr -14h
.text$mn:00004800 var_10          = dword ptr -10h
.text$mn:00004800 var_C           = dword ptr -0Ch
.text$mn:00004800 var_4           = dword ptr -4
.text$mn:00004800 arg_0           = dword ptr  8
.text$mn:00004800
.text$mn:00004800                 push    ebp
.text$mn:00004801                 mov     ebp, esp
.text$mn:00004803                 push    0FFFFFFFFh
.text$mn:00004805                 push    offset __ehhandler$?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z
.text$mn:0000480A                 mov     eax, large fs:0
.text$mn:00004810                 push    eax
.text$mn:00004811                 sub     esp, 14h
.text$mn:00004814                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004819                 xor     eax, ebp
.text$mn:0000481B                 push    eax
.text$mn:0000481C                 lea     eax, [ebp+var_C]
.text$mn:0000481F                 mov     large fs:0, eax
.text$mn:00004825                 mov     [ebp+var_14], ecx
.text$mn:00004828                 mov     eax, [ebp+var_14]
.text$mn:0000482B                 mov     ecx, [eax+0Ch]
.text$mn:0000482E                 mov     edx, [ebp+var_14]
.text$mn:00004831                 add     ecx, [edx+10h]
.text$mn:00004834                 mov     eax, [ebp+arg_0]
.text$mn:00004837                 add     eax, 1
.text$mn:0000483A                 cmp     ecx, eax
.text$mn:0000483C                 ja      short loc_4847
.text$mn:0000483E                 mov     [ebp+var_18], 0FFFFFFFFh
.text$mn:00004845                 jmp     short loc_484D
.text$mn:00004847 ; ---------------------------------------------------------------------------
.text$mn:00004847
.text$mn:00004847 loc_4847:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint)+3Cj
.text$mn:00004847                 mov     ecx, [ebp+arg_0]
.text$mn:0000484A                 mov     [ebp+var_18], ecx
.text$mn:0000484D
.text$mn:0000484D loc_484D:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint)+45j
.text$mn:0000484D                 mov     edx, [ebp+var_18]
.text$mn:00004850                 mov     [ebp+var_1C], edx
.text$mn:00004853                 mov     eax, [ebp+var_14]
.text$mn:00004856                 mov     ecx, [ebp+arg_0]
.text$mn:00004859                 cmp     ecx, [eax+0Ch]
.text$mn:0000485C                 jnz     short loc_4865
.text$mn:0000485E                 mov     [ebp+arg_0], 0
.text$mn:00004865
.text$mn:00004865 loc_4865:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint)+5Cj
.text$mn:00004865                 push    3               ; int
.text$mn:00004867                 lea     ecx, [ebp+var_20] ; this
.text$mn:0000486A                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000486F                 mov     [ebp+var_4], 0
.text$mn:00004876                 mov     ecx, [ebp+var_14] ; this
.text$mn:00004879                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:0000487E                 mov     [ebp+var_10], eax
.text$mn:00004881                 cmp     [ebp+var_10], 0
.text$mn:00004885                 jz      short loc_48D5
.text$mn:00004887
.text$mn:00004887 loc_4887:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint):loc_48D3j
.text$mn:00004887                 mov     edx, [ebp+var_10]
.text$mn:0000488A                 cmp     dword ptr [edx], 0
.text$mn:0000488D                 jz      short loc_48D5
.text$mn:0000488F                 mov     eax, [ebp+var_10]
.text$mn:00004892                 mov     ecx, [eax]
.text$mn:00004894                 mov     edx, [ecx+8]
.text$mn:00004897                 cmp     edx, [ebp+arg_0]
.text$mn:0000489A                 jb      short loc_48A9
.text$mn:0000489C                 mov     eax, [ebp+var_10]
.text$mn:0000489F                 mov     ecx, [eax]
.text$mn:000048A1                 mov     edx, [ebp+var_1C]
.text$mn:000048A4                 cmp     edx, [ecx+8]
.text$mn:000048A7                 jnb     short loc_48B8
.text$mn:000048A9
.text$mn:000048A9 loc_48A9:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint)+9Aj
.text$mn:000048A9                 mov     eax, [ebp+var_10]
.text$mn:000048AC                 mov     ecx, [eax]      ; this
.text$mn:000048AE                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:000048B3                 mov     [ebp+var_10], eax
.text$mn:000048B6                 jmp     short loc_48D3
.text$mn:000048B8 ; ---------------------------------------------------------------------------
.text$mn:000048B8
.text$mn:000048B8 loc_48B8:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint)+A7j
.text$mn:000048B8                 mov     ecx, [ebp+var_10]
.text$mn:000048BB                 mov     ecx, [ecx]      ; this
.text$mn:000048BD                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:000048C2                 mov     edx, [ebp+var_10]
.text$mn:000048C5                 mov     ecx, [edx]      ; this
.text$mn:000048C7                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:000048CC                 mov     ecx, [ebp+var_10]
.text$mn:000048CF                 mov     edx, [eax]
.text$mn:000048D1                 mov     [ecx], edx
.text$mn:000048D3
.text$mn:000048D3 loc_48D3:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint)+B6j
.text$mn:000048D3                 jmp     short loc_4887
.text$mn:000048D5 ; ---------------------------------------------------------------------------
.text$mn:000048D5
.text$mn:000048D5 loc_48D5:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint)+85j
.text$mn:000048D5                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint)+8Dj
.text$mn:000048D5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000048DC                 lea     ecx, [ebp+var_20] ; this
.text$mn:000048DF                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000048E4                 mov     ecx, [ebp+var_C]
.text$mn:000048E7                 mov     large fs:0, ecx
.text$mn:000048EE                 pop     ecx
.text$mn:000048EF                 mov     esp, ebp
.text$mn:000048F1                 pop     ebp
.text$mn:000048F2                 retn    4
.text$mn:000048F2 ?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z endp
.text$mn:000048F2
.text$mn:000048F2 ; ---------------------------------------------------------------------------
.text$mn:000048F5                 align 4
.text$mn:000048F5 _text$mn        ends
.text$mn:000048F5
.text$x:000048F8 ; ===========================================================================
.text$x:000048F8
.text$x:000048F8 ; Segment type: Pure code
.text$x:000048F8 ; Segment permissions: Read/Execute
.text$x:000048F8 _text$x         segment para public 'CODE' use32
.text$x:000048F8                 assume cs:_text$x
.text$x:000048F8                 ;org 48F8h
.text$x:000048F8 ; COMDAT (pick associative to section at 4800)
.text$x:000048F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000048F8
.text$x:000048F8 ; =============== S U B R O U T I N E =======================================
.text$x:000048F8
.text$x:000048F8
.text$x:000048F8 __unwindfunclet$?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z$0 proc near
.text$x:000048F8                                         ; DATA XREF: .xdata$x:00007164o
.text$x:000048F8                 lea     ecx, [ebp-20h]  ; this
.text$x:000048FB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000048FB __unwindfunclet$?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z$0 endp
.text$x:000048FB
.text$x:00004900
.text$x:00004900 ; =============== S U B R O U T I N E =======================================
.text$x:00004900
.text$x:00004900
.text$x:00004900 __ehhandler$?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z proc near
.text$x:00004900                                         ; DATA XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint)+5o
.text$x:00004900
.text$x:00004900 arg_4           = dword ptr  8
.text$x:00004900
.text$x:00004900                 mov     edx, [esp+arg_4]
.text$x:00004904                 lea     eax, [edx+0Ch]
.text$x:00004907                 mov     ecx, [edx-18h]
.text$x:0000490A                 xor     ecx, eax
.text$x:0000490C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004911                 mov     eax, offset __ehfuncinfo$?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z
.text$x:00004916                 jmp     ___CxxFrameHandler3
.text$x:00004916 __ehhandler$?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z endp
.text$x:00004916
.text$x:00004916 ; ---------------------------------------------------------------------------
.text$x:0000491B                 align 4
.text$x:0000491B _text$x         ends
.text$x:0000491B
.text$mn:0000491C ; ===========================================================================
.text$mn:0000491C
.text$mn:0000491C ; Segment type: Pure code
.text$mn:0000491C ; Segment permissions: Read/Execute
.text$mn:0000491C _text$mn        segment para public 'CODE' use32
.text$mn:0000491C                 assume cs:_text$mn
.text$mn:0000491C                 ;org 491Ch
.text$mn:0000491C ; COMDAT (pick any)
.text$mn:0000491C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000491C
.text$mn:0000491C ; =============== S U B R O U T I N E =======================================
.text$mn:0000491C
.text$mn:0000491C ; Attributes: bp-based frame
.text$mn:0000491C
.text$mn:0000491C ; int __stdcall std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Setcont(struct std::_Container_base12 *)
.text$mn:0000491C                 public ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@2@@Z
.text$mn:0000491C ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@2@@Z proc near
.text$mn:0000491C                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(uint,std::_Container_base12 const *)+3Cp
.text$mn:0000491C
.text$mn:0000491C var_4           = dword ptr -4
.text$mn:0000491C arg_0           = dword ptr  8
.text$mn:0000491C
.text$mn:0000491C                 push    ebp
.text$mn:0000491D                 mov     ebp, esp
.text$mn:0000491F                 push    ecx
.text$mn:00004920                 mov     [ebp+var_4], ecx
.text$mn:00004923                 mov     eax, [ebp+arg_0]
.text$mn:00004926                 push    eax             ; struct std::_Container_base12 *
.text$mn:00004927                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000492A                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:0000492F                 mov     esp, ebp
.text$mn:00004931                 pop     ebp
.text$mn:00004932                 retn    4
.text$mn:00004932 ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@2@@Z endp
.text$mn:00004932
.text$mn:00004932 ; ---------------------------------------------------------------------------
.text$mn:00004935                 align 4
.text$mn:00004935 _text$mn        ends
.text$mn:00004935
.text$mn:00004938 ; ===========================================================================
.text$mn:00004938
.text$mn:00004938 ; Segment type: Pure code
.text$mn:00004938 ; Segment permissions: Read/Execute
.text$mn:00004938 _text$mn        segment para public 'CODE' use32
.text$mn:00004938                 assume cs:_text$mn
.text$mn:00004938                 ;org 4938h
.text$mn:00004938 ; COMDAT (pick any)
.text$mn:00004938                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004938
.text$mn:00004938 ; =============== S U B R O U T I N E =======================================
.text$mn:00004938
.text$mn:00004938 ; Attributes: bp-based frame
.text$mn:00004938
.text$mn:00004938 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00004938                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00004938 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00004938                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00004938                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00004938
.text$mn:00004938 var_C           = dword ptr -0Ch
.text$mn:00004938 var_8           = dword ptr -8
.text$mn:00004938 var_2           = byte ptr -2
.text$mn:00004938 var_1           = byte ptr -1
.text$mn:00004938 arg_0           = byte ptr  8
.text$mn:00004938 Size            = dword ptr  0Ch
.text$mn:00004938
.text$mn:00004938                 push    ebp
.text$mn:00004939                 mov     ebp, esp
.text$mn:0000493B                 sub     esp, 0Ch
.text$mn:0000493E                 mov     [ebp+var_8], ecx
.text$mn:00004941                 movzx   eax, [ebp+arg_0]
.text$mn:00004945                 test    eax, eax
.text$mn:00004947                 jnz     short loc_494B
.text$mn:00004949                 jmp     short loc_49BE
.text$mn:0000494B ; ---------------------------------------------------------------------------
.text$mn:0000494B
.text$mn:0000494B loc_494B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000494B                 mov     ecx, [ebp+var_8]
.text$mn:0000494E                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00004952                 jb      short loc_49BE
.text$mn:00004954                 mov     edx, [ebp+var_8]
.text$mn:00004957                 mov     eax, [edx+4]
.text$mn:0000495A                 mov     [ebp+var_C], eax
.text$mn:0000495D                 mov     ecx, [ebp+var_8]
.text$mn:00004960                 add     ecx, 4
.text$mn:00004963                 push    ecx
.text$mn:00004964                 lea     edx, [ebp+var_1]
.text$mn:00004967                 push    edx
.text$mn:00004968                 mov     ecx, [ebp+var_8]
.text$mn:0000496B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00004970                 mov     ecx, eax
.text$mn:00004972                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00004977                 cmp     [ebp+Size], 0
.text$mn:0000497B                 jbe     short loc_499D
.text$mn:0000497D                 mov     eax, [ebp+Size]
.text$mn:00004980                 push    eax             ; Size
.text$mn:00004981                 mov     ecx, [ebp+var_C]
.text$mn:00004984                 push    ecx
.text$mn:00004985                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000498A                 add     esp, 4
.text$mn:0000498D                 push    eax             ; Src
.text$mn:0000498E                 mov     edx, [ebp+var_8]
.text$mn:00004991                 add     edx, 4
.text$mn:00004994                 push    edx             ; Dst
.text$mn:00004995                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000499A                 add     esp, 0Ch
.text$mn:0000499D
.text$mn:0000499D loc_499D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:0000499D                 mov     eax, [ebp+var_8]
.text$mn:000049A0                 mov     ecx, [eax+18h]
.text$mn:000049A3                 add     ecx, 1
.text$mn:000049A6                 push    ecx             ; int
.text$mn:000049A7                 mov     edx, [ebp+var_C]
.text$mn:000049AA                 push    edx             ; void *
.text$mn:000049AB                 lea     eax, [ebp+var_2]
.text$mn:000049AE                 push    eax
.text$mn:000049AF                 mov     ecx, [ebp+var_8]
.text$mn:000049B2                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000049B7                 mov     ecx, eax
.text$mn:000049B9                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:000049BE
.text$mn:000049BE loc_49BE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:000049BE                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:000049BE                 mov     ecx, [ebp+var_8]
.text$mn:000049C1                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:000049C8                 mov     edx, [ebp+Size]
.text$mn:000049CB                 push    edx
.text$mn:000049CC                 mov     ecx, [ebp+var_8]
.text$mn:000049CF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000049D4                 mov     esp, ebp
.text$mn:000049D6                 pop     ebp
.text$mn:000049D7                 retn    8
.text$mn:000049D7 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:000049D7
.text$mn:000049D7 ; ---------------------------------------------------------------------------
.text$mn:000049DA                 align 4
.text$mn:000049DA _text$mn        ends
.text$mn:000049DA
.text$mn:000049DC ; ===========================================================================
.text$mn:000049DC
.text$mn:000049DC ; Segment type: Pure code
.text$mn:000049DC ; Segment permissions: Read/Execute
.text$mn:000049DC _text$mn        segment para public 'CODE' use32
.text$mn:000049DC                 assume cs:_text$mn
.text$mn:000049DC                 ;org 49DCh
.text$mn:000049DC ; COMDAT (pick any)
.text$mn:000049DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000049DC
.text$mn:000049DC ; =============== S U B R O U T I N E =======================================
.text$mn:000049DC
.text$mn:000049DC ; Attributes: bp-based frame
.text$mn:000049DC
.text$mn:000049DC ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:000049DC                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:000049DC ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:000049DC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+56p
.text$mn:000049DC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+47p ...
.text$mn:000049DC
.text$mn:000049DC var_C           = dword ptr -0Ch
.text$mn:000049DC var_8           = dword ptr -8
.text$mn:000049DC var_2           = byte ptr -2
.text$mn:000049DC var_1           = byte ptr -1
.text$mn:000049DC arg_0           = byte ptr  8
.text$mn:000049DC arg_4           = dword ptr  0Ch
.text$mn:000049DC
.text$mn:000049DC                 push    ebp
.text$mn:000049DD                 mov     ebp, esp
.text$mn:000049DF                 sub     esp, 0Ch
.text$mn:000049E2                 mov     [ebp+var_8], ecx
.text$mn:000049E5                 movzx   eax, [ebp+arg_0]
.text$mn:000049E9                 test    eax, eax
.text$mn:000049EB                 jnz     short loc_49EF
.text$mn:000049ED                 jmp     short loc_4A62
.text$mn:000049EF ; ---------------------------------------------------------------------------
.text$mn:000049EF
.text$mn:000049EF loc_49EF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:000049EF                 mov     ecx, [ebp+var_8]
.text$mn:000049F2                 cmp     dword ptr [ecx+18h], 8
.text$mn:000049F6                 jb      short loc_4A62
.text$mn:000049F8                 mov     edx, [ebp+var_8]
.text$mn:000049FB                 mov     eax, [edx+4]
.text$mn:000049FE                 mov     [ebp+var_C], eax
.text$mn:00004A01                 mov     ecx, [ebp+var_8]
.text$mn:00004A04                 add     ecx, 4
.text$mn:00004A07                 push    ecx
.text$mn:00004A08                 lea     edx, [ebp+var_1]
.text$mn:00004A0B                 push    edx
.text$mn:00004A0C                 mov     ecx, [ebp+var_8]
.text$mn:00004A0F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00004A14                 mov     ecx, eax
.text$mn:00004A16                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00004A1B                 cmp     [ebp+arg_4], 0
.text$mn:00004A1F                 jbe     short loc_4A41
.text$mn:00004A21                 mov     eax, [ebp+arg_4]
.text$mn:00004A24                 push    eax             ; int
.text$mn:00004A25                 mov     ecx, [ebp+var_C]
.text$mn:00004A28                 push    ecx
.text$mn:00004A29                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00004A2E                 add     esp, 4
.text$mn:00004A31                 push    eax             ; Src
.text$mn:00004A32                 mov     edx, [ebp+var_8]
.text$mn:00004A35                 add     edx, 4
.text$mn:00004A38                 push    edx             ; Dst
.text$mn:00004A39                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00004A3E                 add     esp, 0Ch
.text$mn:00004A41
.text$mn:00004A41 loc_4A41:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:00004A41                 mov     eax, [ebp+var_8]
.text$mn:00004A44                 mov     ecx, [eax+18h]
.text$mn:00004A47                 add     ecx, 1
.text$mn:00004A4A                 push    ecx             ; int
.text$mn:00004A4B                 mov     edx, [ebp+var_C]
.text$mn:00004A4E                 push    edx             ; void *
.text$mn:00004A4F                 lea     eax, [ebp+var_2]
.text$mn:00004A52                 push    eax
.text$mn:00004A53                 mov     ecx, [ebp+var_8]
.text$mn:00004A56                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00004A5B                 mov     ecx, eax
.text$mn:00004A5D                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:00004A62
.text$mn:00004A62 loc_4A62:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:00004A62                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:00004A62                 mov     ecx, [ebp+var_8]
.text$mn:00004A65                 mov     dword ptr [ecx+18h], 7
.text$mn:00004A6C                 mov     edx, [ebp+arg_4]
.text$mn:00004A6F                 push    edx
.text$mn:00004A70                 mov     ecx, [ebp+var_8]
.text$mn:00004A73                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00004A78                 mov     esp, ebp
.text$mn:00004A7A                 pop     ebp
.text$mn:00004A7B                 retn    8
.text$mn:00004A7B ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:00004A7B
.text$mn:00004A7B ; ---------------------------------------------------------------------------
.text$mn:00004A7E                 align 10h
.text$mn:00004A7E _text$mn        ends
.text$mn:00004A7E
.text$mn:00004A80 ; ===========================================================================
.text$mn:00004A80
.text$mn:00004A80 ; Segment type: Pure code
.text$mn:00004A80 ; Segment permissions: Read/Execute
.text$mn:00004A80 _text$mn        segment para public 'CODE' use32
.text$mn:00004A80                 assume cs:_text$mn
.text$mn:00004A80                 ;org 4A80h
.text$mn:00004A80 ; COMDAT (pick any)
.text$mn:00004A80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A80
.text$mn:00004A80 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A80
.text$mn:00004A80 ; Attributes: bp-based frame
.text$mn:00004A80
.text$mn:00004A80 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00004A80                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00004A80 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00004A80                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00004A80
.text$mn:00004A80 var_4           = dword ptr -4
.text$mn:00004A80
.text$mn:00004A80                 push    ebp
.text$mn:00004A81                 mov     ebp, esp
.text$mn:00004A83                 push    ecx
.text$mn:00004A84                 mov     [ebp+var_4], ecx
.text$mn:00004A87                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00004A8C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00004A91                 mov     esp, ebp
.text$mn:00004A93                 pop     ebp
.text$mn:00004A94                 retn
.text$mn:00004A94 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00004A94
.text$mn:00004A94 ; ---------------------------------------------------------------------------
.text$mn:00004A95                 align 4
.text$mn:00004A95 _text$mn        ends
.text$mn:00004A95
.text$mn:00004A98 ; ===========================================================================
.text$mn:00004A98
.text$mn:00004A98 ; Segment type: Pure code
.text$mn:00004A98 ; Segment permissions: Read/Execute
.text$mn:00004A98 _text$mn        segment para public 'CODE' use32
.text$mn:00004A98                 assume cs:_text$mn
.text$mn:00004A98                 ;org 4A98h
.text$mn:00004A98 ; COMDAT (pick any)
.text$mn:00004A98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A98
.text$mn:00004A98 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A98
.text$mn:00004A98 ; Attributes: bp-based frame
.text$mn:00004A98
.text$mn:00004A98 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:00004A98                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00004A98 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00004A98                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:00004A98
.text$mn:00004A98 var_4           = dword ptr -4
.text$mn:00004A98
.text$mn:00004A98                 push    ebp
.text$mn:00004A99                 mov     ebp, esp
.text$mn:00004A9B                 push    ecx
.text$mn:00004A9C                 mov     [ebp+var_4], ecx
.text$mn:00004A9F                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00004AA4                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00004AA9                 mov     esp, ebp
.text$mn:00004AAB                 pop     ebp
.text$mn:00004AAC                 retn
.text$mn:00004AAC ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00004AAC
.text$mn:00004AAC ; ---------------------------------------------------------------------------
.text$mn:00004AAD                 align 10h
.text$mn:00004AAD _text$mn        ends
.text$mn:00004AAD
.text$mn:00004AB0 ; ===========================================================================
.text$mn:00004AB0
.text$mn:00004AB0 ; Segment type: Pure code
.text$mn:00004AB0 ; Segment permissions: Read/Execute
.text$mn:00004AB0 _text$mn        segment para public 'CODE' use32
.text$mn:00004AB0                 assume cs:_text$mn
.text$mn:00004AB0                 ;org 4AB0h
.text$mn:00004AB0 ; COMDAT (pick any)
.text$mn:00004AB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AB0
.text$mn:00004AB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AB0
.text$mn:00004AB0 ; Attributes: bp-based frame
.text$mn:00004AB0
.text$mn:00004AB0 ; protected: void __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::_Xlen(void)const
.text$mn:00004AB0                 public ?_Xlen@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXXZ
.text$mn:00004AB0 ?_Xlen@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXXZ proc near
.text$mn:00004AB0                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+66p
.text$mn:00004AB0
.text$mn:00004AB0 var_4           = dword ptr -4
.text$mn:00004AB0
.text$mn:00004AB0                 push    ebp
.text$mn:00004AB1                 mov     ebp, esp
.text$mn:00004AB3                 push    ecx
.text$mn:00004AB4                 mov     [ebp+var_4], ecx
.text$mn:00004AB7                 push    offset ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; "deque<T> too long"
.text$mn:00004ABC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00004AC1                 mov     esp, ebp
.text$mn:00004AC3                 pop     ebp
.text$mn:00004AC4                 retn
.text$mn:00004AC4 ?_Xlen@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXXZ endp
.text$mn:00004AC4
.text$mn:00004AC4 ; ---------------------------------------------------------------------------
.text$mn:00004AC5                 align 4
.text$mn:00004AC5 _text$mn        ends
.text$mn:00004AC5
.text$mn:00004AC8 ; ===========================================================================
.text$mn:00004AC8
.text$mn:00004AC8 ; Segment type: Pure code
.text$mn:00004AC8 ; Segment permissions: Read/Execute
.text$mn:00004AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00004AC8                 assume cs:_text$mn
.text$mn:00004AC8                 ;org 4AC8h
.text$mn:00004AC8 ; COMDAT (pick any)
.text$mn:00004AC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AC8
.text$mn:00004AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AC8
.text$mn:00004AC8 ; Attributes: bp-based frame
.text$mn:00004AC8
.text$mn:00004AC8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00004AC8                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00004AC8 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00004AC8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00004AC8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00004AC8
.text$mn:00004AC8 var_4           = dword ptr -4
.text$mn:00004AC8
.text$mn:00004AC8                 push    ebp
.text$mn:00004AC9                 mov     ebp, esp
.text$mn:00004ACB                 push    ecx
.text$mn:00004ACC                 mov     [ebp+var_4], ecx
.text$mn:00004ACF                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00004AD4                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00004AD9                 mov     esp, ebp
.text$mn:00004ADB                 pop     ebp
.text$mn:00004ADC                 retn
.text$mn:00004ADC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00004ADC
.text$mn:00004ADC ; ---------------------------------------------------------------------------
.text$mn:00004ADD                 align 10h
.text$mn:00004ADD _text$mn        ends
.text$mn:00004ADD
.text$mn:00004AE0 ; ===========================================================================
.text$mn:00004AE0
.text$mn:00004AE0 ; Segment type: Pure code
.text$mn:00004AE0 ; Segment permissions: Read/Execute
.text$mn:00004AE0 _text$mn        segment para public 'CODE' use32
.text$mn:00004AE0                 assume cs:_text$mn
.text$mn:00004AE0                 ;org 4AE0h
.text$mn:00004AE0 ; COMDAT (pick any)
.text$mn:00004AE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AE0
.text$mn:00004AE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AE0
.text$mn:00004AE0 ; Attributes: bp-based frame
.text$mn:00004AE0
.text$mn:00004AE0 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:00004AE0                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00004AE0 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00004AE0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:00004AE0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+33p ...
.text$mn:00004AE0
.text$mn:00004AE0 var_4           = dword ptr -4
.text$mn:00004AE0
.text$mn:00004AE0                 push    ebp
.text$mn:00004AE1                 mov     ebp, esp
.text$mn:00004AE3                 push    ecx
.text$mn:00004AE4                 mov     [ebp+var_4], ecx
.text$mn:00004AE7                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00004AEC                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00004AF1                 mov     esp, ebp
.text$mn:00004AF3                 pop     ebp
.text$mn:00004AF4                 retn
.text$mn:00004AF4 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00004AF4
.text$mn:00004AF4 ; ---------------------------------------------------------------------------
.text$mn:00004AF5                 align 4
.text$mn:00004AF5 _text$mn        ends
.text$mn:00004AF5
.text$mn:00004AF8 ; ===========================================================================
.text$mn:00004AF8
.text$mn:00004AF8 ; Segment type: Pure code
.text$mn:00004AF8 ; Segment permissions: Read/Execute
.text$mn:00004AF8 _text$mn        segment para public 'CODE' use32
.text$mn:00004AF8                 assume cs:_text$mn
.text$mn:00004AF8                 ;org 4AF8h
.text$mn:00004AF8 ; COMDAT (pick any)
.text$mn:00004AF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AF8
.text$mn:00004AF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AF8
.text$mn:00004AF8 ; Attributes: bp-based frame
.text$mn:00004AF8
.text$mn:00004AF8 ; protected: void __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::_Xran(void)const
.text$mn:00004AF8                 public ?_Xran@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXXZ
.text$mn:00004AF8 ?_Xran@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXXZ proc near
.text$mn:00004AF8                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)+36p
.text$mn:00004AF8
.text$mn:00004AF8 var_4           = dword ptr -4
.text$mn:00004AF8
.text$mn:00004AF8                 push    ebp
.text$mn:00004AF9                 mov     ebp, esp
.text$mn:00004AFB                 push    ecx
.text$mn:00004AFC                 mov     [ebp+var_4], ecx
.text$mn:00004AFF                 push    offset ??_C@_0BL@KOKKEGGO@invalid?5deque?$DMT?$DO?5subscript?$AA@ ; "invalid deque<T> subscript"
.text$mn:00004B04                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00004B09                 mov     esp, ebp
.text$mn:00004B0B                 pop     ebp
.text$mn:00004B0C                 retn
.text$mn:00004B0C ?_Xran@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXXZ endp
.text$mn:00004B0C
.text$mn:00004B0C ; ---------------------------------------------------------------------------
.text$mn:00004B0D                 align 10h
.text$mn:00004B0D _text$mn        ends
.text$mn:00004B0D
.text$mn:00004B10 ; ===========================================================================
.text$mn:00004B10
.text$mn:00004B10 ; Segment type: Pure code
.text$mn:00004B10 ; Segment permissions: Read/Execute
.text$mn:00004B10 _text$mn        segment para public 'CODE' use32
.text$mn:00004B10                 assume cs:_text$mn
.text$mn:00004B10                 ;org 4B10h
.text$mn:00004B10 ; COMDAT (pick any)
.text$mn:00004B10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B10
.text$mn:00004B10 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B10
.text$mn:00004B10 ; Attributes: bp-based frame
.text$mn:00004B10
.text$mn:00004B10 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00004B10                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00004B10 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00004B10                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00004B10                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00004B10
.text$mn:00004B10 var_4           = dword ptr -4
.text$mn:00004B10 arg_0           = dword ptr  8
.text$mn:00004B10
.text$mn:00004B10                 push    ebp
.text$mn:00004B11                 mov     ebp, esp
.text$mn:00004B13                 push    ecx
.text$mn:00004B14                 mov     [ebp+var_4], ecx
.text$mn:00004B17                 mov     eax, [ebp+arg_0]
.text$mn:00004B1A                 push    eax
.text$mn:00004B1B                 mov     ecx, [ebp+var_4]
.text$mn:00004B1E                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00004B23                 mov     esp, ebp
.text$mn:00004B25                 pop     ebp
.text$mn:00004B26                 retn    4
.text$mn:00004B26 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00004B26
.text$mn:00004B26 ; ---------------------------------------------------------------------------
.text$mn:00004B29                 align 4
.text$mn:00004B29 _text$mn        ends
.text$mn:00004B29
.text$mn:00004B2C ; ===========================================================================
.text$mn:00004B2C
.text$mn:00004B2C ; Segment type: Pure code
.text$mn:00004B2C ; Segment permissions: Read/Execute
.text$mn:00004B2C _text$mn        segment para public 'CODE' use32
.text$mn:00004B2C                 assume cs:_text$mn
.text$mn:00004B2C                 ;org 4B2Ch
.text$mn:00004B2C ; COMDAT (pick any)
.text$mn:00004B2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B2C
.text$mn:00004B2C ; =============== S U B R O U T I N E =======================================
.text$mn:00004B2C
.text$mn:00004B2C ; Attributes: bp-based frame
.text$mn:00004B2C
.text$mn:00004B2C ; public: struct RecentItem * * __thiscall std::_Wrap_alloc<class std::allocator<struct RecentItem *>>::allocate(unsigned int)
.text$mn:00004B2C                 public ?allocate@?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@QAEPAPAURecentItem@@I@Z
.text$mn:00004B2C ?allocate@?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@QAEPAPAURecentItem@@I@Z proc near
.text$mn:00004B2C                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+97p
.text$mn:00004B2C
.text$mn:00004B2C var_4           = dword ptr -4
.text$mn:00004B2C arg_0           = dword ptr  8
.text$mn:00004B2C
.text$mn:00004B2C                 push    ebp
.text$mn:00004B2D                 mov     ebp, esp
.text$mn:00004B2F                 push    ecx
.text$mn:00004B30                 mov     [ebp+var_4], ecx
.text$mn:00004B33                 mov     eax, [ebp+arg_0]
.text$mn:00004B36                 push    eax
.text$mn:00004B37                 mov     ecx, [ebp+var_4]
.text$mn:00004B3A                 call    ?allocate@?$allocator@PAURecentItem@@@std@@QAEPAPAURecentItem@@I@Z ; std::allocator<RecentItem *>::allocate(uint)
.text$mn:00004B3F                 mov     esp, ebp
.text$mn:00004B41                 pop     ebp
.text$mn:00004B42                 retn    4
.text$mn:00004B42 ?allocate@?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@QAEPAPAURecentItem@@I@Z endp
.text$mn:00004B42
.text$mn:00004B42 ; ---------------------------------------------------------------------------
.text$mn:00004B45                 align 4
.text$mn:00004B45 _text$mn        ends
.text$mn:00004B45
.text$mn:00004B48 ; ===========================================================================
.text$mn:00004B48
.text$mn:00004B48 ; Segment type: Pure code
.text$mn:00004B48 ; Segment permissions: Read/Execute
.text$mn:00004B48 _text$mn        segment para public 'CODE' use32
.text$mn:00004B48                 assume cs:_text$mn
.text$mn:00004B48                 ;org 4B48h
.text$mn:00004B48 ; COMDAT (pick any)
.text$mn:00004B48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B48
.text$mn:00004B48 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B48
.text$mn:00004B48 ; Attributes: bp-based frame
.text$mn:00004B48
.text$mn:00004B48 ; public: struct RecentItem * __thiscall std::_Wrap_alloc<class std::allocator<struct RecentItem>>::allocate(unsigned int)
.text$mn:00004B48                 public ?allocate@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAEPAURecentItem@@I@Z
.text$mn:00004B48 ?allocate@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAEPAURecentItem@@I@Z proc near
.text$mn:00004B48                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::push_front(RecentItem const &)+AFp
.text$mn:00004B48
.text$mn:00004B48 var_4           = dword ptr -4
.text$mn:00004B48 arg_0           = dword ptr  8
.text$mn:00004B48
.text$mn:00004B48                 push    ebp
.text$mn:00004B49                 mov     ebp, esp
.text$mn:00004B4B                 push    ecx
.text$mn:00004B4C                 mov     [ebp+var_4], ecx
.text$mn:00004B4F                 mov     eax, [ebp+arg_0]
.text$mn:00004B52                 push    eax
.text$mn:00004B53                 mov     ecx, [ebp+var_4]
.text$mn:00004B56                 call    ?allocate@?$allocator@URecentItem@@@std@@QAEPAURecentItem@@I@Z ; std::allocator<RecentItem>::allocate(uint)
.text$mn:00004B5B                 mov     esp, ebp
.text$mn:00004B5D                 pop     ebp
.text$mn:00004B5E                 retn    4
.text$mn:00004B5E ?allocate@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAEPAURecentItem@@I@Z endp
.text$mn:00004B5E
.text$mn:00004B5E ; ---------------------------------------------------------------------------
.text$mn:00004B61                 align 4
.text$mn:00004B61 _text$mn        ends
.text$mn:00004B61
.text$mn:00004B64 ; ===========================================================================
.text$mn:00004B64
.text$mn:00004B64 ; Segment type: Pure code
.text$mn:00004B64 ; Segment permissions: Read/Execute
.text$mn:00004B64 _text$mn        segment para public 'CODE' use32
.text$mn:00004B64                 assume cs:_text$mn
.text$mn:00004B64                 ;org 4B64h
.text$mn:00004B64 ; COMDAT (pick any)
.text$mn:00004B64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B64
.text$mn:00004B64 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B64
.text$mn:00004B64 ; Attributes: bp-based frame
.text$mn:00004B64
.text$mn:00004B64 ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:00004B64                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:00004B64 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:00004B64                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:00004B64                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:00004B64
.text$mn:00004B64 var_4           = dword ptr -4
.text$mn:00004B64 arg_0           = dword ptr  8
.text$mn:00004B64
.text$mn:00004B64                 push    ebp
.text$mn:00004B65                 mov     ebp, esp
.text$mn:00004B67                 push    ecx
.text$mn:00004B68                 mov     [ebp+var_4], ecx
.text$mn:00004B6B                 mov     eax, [ebp+arg_0]
.text$mn:00004B6E                 push    eax
.text$mn:00004B6F                 mov     ecx, [ebp+var_4]
.text$mn:00004B72                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:00004B77                 mov     esp, ebp
.text$mn:00004B79                 pop     ebp
.text$mn:00004B7A                 retn    4
.text$mn:00004B7A ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:00004B7A
.text$mn:00004B7A ; ---------------------------------------------------------------------------
.text$mn:00004B7D                 align 10h
.text$mn:00004B7D _text$mn        ends
.text$mn:00004B7D
.text$mn:00004B80 ; ===========================================================================
.text$mn:00004B80
.text$mn:00004B80 ; Segment type: Pure code
.text$mn:00004B80 ; Segment permissions: Read/Execute
.text$mn:00004B80 _text$mn        segment para public 'CODE' use32
.text$mn:00004B80                 assume cs:_text$mn
.text$mn:00004B80                 ;org 4B80h
.text$mn:00004B80 ; COMDAT (pick any)
.text$mn:00004B80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B80
.text$mn:00004B80 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B80
.text$mn:00004B80 ; Attributes: bp-based frame
.text$mn:00004B80
.text$mn:00004B80 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00004B80                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00004B80 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00004B80                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00004B80
.text$mn:00004B80 var_4           = dword ptr -4
.text$mn:00004B80 arg_0           = dword ptr  8
.text$mn:00004B80
.text$mn:00004B80                 push    ebp
.text$mn:00004B81                 mov     ebp, esp
.text$mn:00004B83                 push    ecx
.text$mn:00004B84                 mov     [ebp+var_4], ecx
.text$mn:00004B87                 push    0
.text$mn:00004B89                 mov     eax, [ebp+arg_0]
.text$mn:00004B8C                 push    eax
.text$mn:00004B8D                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00004B92                 add     esp, 8
.text$mn:00004B95                 mov     esp, ebp
.text$mn:00004B97                 pop     ebp
.text$mn:00004B98                 retn    4
.text$mn:00004B98 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00004B98
.text$mn:00004B98 ; ---------------------------------------------------------------------------
.text$mn:00004B9B                 align 4
.text$mn:00004B9B _text$mn        ends
.text$mn:00004B9B
.text$mn:00004B9C ; ===========================================================================
.text$mn:00004B9C
.text$mn:00004B9C ; Segment type: Pure code
.text$mn:00004B9C ; Segment permissions: Read/Execute
.text$mn:00004B9C _text$mn        segment para public 'CODE' use32
.text$mn:00004B9C                 assume cs:_text$mn
.text$mn:00004B9C                 ;org 4B9Ch
.text$mn:00004B9C ; COMDAT (pick any)
.text$mn:00004B9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B9C
.text$mn:00004B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00004B9C
.text$mn:00004B9C ; Attributes: bp-based frame
.text$mn:00004B9C
.text$mn:00004B9C ; public: struct RecentItem * * __thiscall std::allocator<struct RecentItem *>::allocate(unsigned int)
.text$mn:00004B9C                 public ?allocate@?$allocator@PAURecentItem@@@std@@QAEPAPAURecentItem@@I@Z
.text$mn:00004B9C ?allocate@?$allocator@PAURecentItem@@@std@@QAEPAPAURecentItem@@I@Z proc near
.text$mn:00004B9C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<RecentItem *>>::allocate(uint)+Ep
.text$mn:00004B9C
.text$mn:00004B9C var_4           = dword ptr -4
.text$mn:00004B9C arg_0           = dword ptr  8
.text$mn:00004B9C
.text$mn:00004B9C                 push    ebp
.text$mn:00004B9D                 mov     ebp, esp
.text$mn:00004B9F                 push    ecx
.text$mn:00004BA0                 mov     [ebp+var_4], ecx
.text$mn:00004BA3                 push    0
.text$mn:00004BA5                 mov     eax, [ebp+arg_0]
.text$mn:00004BA8                 push    eax
.text$mn:00004BA9                 call    ??$_Allocate@PAURecentItem@@@std@@YAPAPAURecentItem@@IPAPAU1@@Z ; std::_Allocate<RecentItem *>(uint,RecentItem * *)
.text$mn:00004BAE                 add     esp, 8
.text$mn:00004BB1                 mov     esp, ebp
.text$mn:00004BB3                 pop     ebp
.text$mn:00004BB4                 retn    4
.text$mn:00004BB4 ?allocate@?$allocator@PAURecentItem@@@std@@QAEPAPAURecentItem@@I@Z endp
.text$mn:00004BB4
.text$mn:00004BB4 ; ---------------------------------------------------------------------------
.text$mn:00004BB7                 align 4
.text$mn:00004BB7 _text$mn        ends
.text$mn:00004BB7
.text$mn:00004BB8 ; ===========================================================================
.text$mn:00004BB8
.text$mn:00004BB8 ; Segment type: Pure code
.text$mn:00004BB8 ; Segment permissions: Read/Execute
.text$mn:00004BB8 _text$mn        segment para public 'CODE' use32
.text$mn:00004BB8                 assume cs:_text$mn
.text$mn:00004BB8                 ;org 4BB8h
.text$mn:00004BB8 ; COMDAT (pick any)
.text$mn:00004BB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BB8
.text$mn:00004BB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BB8
.text$mn:00004BB8 ; Attributes: bp-based frame
.text$mn:00004BB8
.text$mn:00004BB8 ; public: struct RecentItem * __thiscall std::allocator<struct RecentItem>::allocate(unsigned int)
.text$mn:00004BB8                 public ?allocate@?$allocator@URecentItem@@@std@@QAEPAURecentItem@@I@Z
.text$mn:00004BB8 ?allocate@?$allocator@URecentItem@@@std@@QAEPAURecentItem@@I@Z proc near
.text$mn:00004BB8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<RecentItem>>::allocate(uint)+Ep
.text$mn:00004BB8
.text$mn:00004BB8 var_4           = dword ptr -4
.text$mn:00004BB8 arg_0           = dword ptr  8
.text$mn:00004BB8
.text$mn:00004BB8                 push    ebp
.text$mn:00004BB9                 mov     ebp, esp
.text$mn:00004BBB                 push    ecx
.text$mn:00004BBC                 mov     [ebp+var_4], ecx
.text$mn:00004BBF                 push    0
.text$mn:00004BC1                 mov     eax, [ebp+arg_0]
.text$mn:00004BC4                 push    eax
.text$mn:00004BC5                 call    ??$_Allocate@URecentItem@@@std@@YAPAURecentItem@@IPAU1@@Z ; std::_Allocate<RecentItem>(uint,RecentItem *)
.text$mn:00004BCA                 add     esp, 8
.text$mn:00004BCD                 mov     esp, ebp
.text$mn:00004BCF                 pop     ebp
.text$mn:00004BD0                 retn    4
.text$mn:00004BD0 ?allocate@?$allocator@URecentItem@@@std@@QAEPAURecentItem@@I@Z endp
.text$mn:00004BD0
.text$mn:00004BD0 ; ---------------------------------------------------------------------------
.text$mn:00004BD3                 align 4
.text$mn:00004BD3 _text$mn        ends
.text$mn:00004BD3
.text$mn:00004BD4 ; ===========================================================================
.text$mn:00004BD4
.text$mn:00004BD4 ; Segment type: Pure code
.text$mn:00004BD4 ; Segment permissions: Read/Execute
.text$mn:00004BD4 _text$mn        segment para public 'CODE' use32
.text$mn:00004BD4                 assume cs:_text$mn
.text$mn:00004BD4                 ;org 4BD4h
.text$mn:00004BD4 ; COMDAT (pick any)
.text$mn:00004BD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BD4
.text$mn:00004BD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BD4
.text$mn:00004BD4 ; Attributes: bp-based frame
.text$mn:00004BD4
.text$mn:00004BD4 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00004BD4                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00004BD4 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00004BD4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00004BD4                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p
.text$mn:00004BD4
.text$mn:00004BD4 var_4           = dword ptr -4
.text$mn:00004BD4 arg_0           = dword ptr  8
.text$mn:00004BD4
.text$mn:00004BD4                 push    ebp
.text$mn:00004BD5                 mov     ebp, esp
.text$mn:00004BD7                 push    ecx
.text$mn:00004BD8                 mov     [ebp+var_4], ecx
.text$mn:00004BDB                 push    0
.text$mn:00004BDD                 mov     eax, [ebp+arg_0]
.text$mn:00004BE0                 push    eax
.text$mn:00004BE1                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00004BE6                 add     esp, 8
.text$mn:00004BE9                 mov     esp, ebp
.text$mn:00004BEB                 pop     ebp
.text$mn:00004BEC                 retn    4
.text$mn:00004BEC ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00004BEC
.text$mn:00004BEC ; ---------------------------------------------------------------------------
.text$mn:00004BEF                 align 10h
.text$mn:00004BEF _text$mn        ends
.text$mn:00004BEF
.text$mn:00004BF0 ; ===========================================================================
.text$mn:00004BF0
.text$mn:00004BF0 ; Segment type: Pure code
.text$mn:00004BF0 ; Segment permissions: Read/Execute
.text$mn:00004BF0 _text$mn        segment para public 'CODE' use32
.text$mn:00004BF0                 assume cs:_text$mn
.text$mn:00004BF0                 ;org 4BF0h
.text$mn:00004BF0 ; COMDAT (pick any)
.text$mn:00004BF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BF0
.text$mn:00004BF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BF0
.text$mn:00004BF0 ; Attributes: bp-based frame
.text$mn:00004BF0
.text$mn:00004BF0 ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:00004BF0                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:00004BF0 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:00004BF0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:00004BF0
.text$mn:00004BF0 var_4           = dword ptr -4
.text$mn:00004BF0 arg_0           = dword ptr  8
.text$mn:00004BF0
.text$mn:00004BF0                 push    ebp
.text$mn:00004BF1                 mov     ebp, esp
.text$mn:00004BF3                 push    ecx
.text$mn:00004BF4                 mov     [ebp+var_4], ecx
.text$mn:00004BF7                 push    0
.text$mn:00004BF9                 mov     eax, [ebp+arg_0]
.text$mn:00004BFC                 push    eax
.text$mn:00004BFD                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:00004C02                 add     esp, 8
.text$mn:00004C05                 mov     esp, ebp
.text$mn:00004C07                 pop     ebp
.text$mn:00004C08                 retn    4
.text$mn:00004C08 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:00004C08
.text$mn:00004C08 ; ---------------------------------------------------------------------------
.text$mn:00004C0B                 align 4
.text$mn:00004C0B _text$mn        ends
.text$mn:00004C0B
.text$mn:00004C0C ; ===========================================================================
.text$mn:00004C0C
.text$mn:00004C0C ; Segment type: Pure code
.text$mn:00004C0C ; Segment permissions: Read/Execute
.text$mn:00004C0C _text$mn        segment para public 'CODE' use32
.text$mn:00004C0C                 assume cs:_text$mn
.text$mn:00004C0C                 ;org 4C0Ch
.text$mn:00004C0C ; COMDAT (pick any)
.text$mn:00004C0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C0C
.text$mn:00004C0C ; =============== S U B R O U T I N E =======================================
.text$mn:00004C0C
.text$mn:00004C0C ; Attributes: bp-based frame
.text$mn:00004C0C
.text$mn:00004C0C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00004C0C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00004C0C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00004C0C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00004C0C
.text$mn:00004C0C Size            = dword ptr -8
.text$mn:00004C0C var_4           = dword ptr -4
.text$mn:00004C0C arg_0           = dword ptr  8
.text$mn:00004C0C arg_4           = dword ptr  0Ch
.text$mn:00004C0C arg_8           = dword ptr  10h
.text$mn:00004C0C
.text$mn:00004C0C                 push    ebp
.text$mn:00004C0D                 mov     ebp, esp
.text$mn:00004C0F                 sub     esp, 8
.text$mn:00004C12                 mov     [ebp+var_4], ecx
.text$mn:00004C15                 mov     ecx, [ebp+arg_0]
.text$mn:00004C18                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00004C1D                 cmp     eax, [ebp+arg_4]
.text$mn:00004C20                 jnb     short loc_4C2A
.text$mn:00004C22                 mov     ecx, [ebp+var_4]
.text$mn:00004C25                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00004C2A
.text$mn:00004C2A loc_4C2A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00004C2A                 mov     ecx, [ebp+arg_0]
.text$mn:00004C2D                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00004C32                 sub     eax, [ebp+arg_4]
.text$mn:00004C35                 mov     [ebp+Size], eax
.text$mn:00004C38                 mov     eax, [ebp+arg_8]
.text$mn:00004C3B                 cmp     eax, [ebp+Size]
.text$mn:00004C3E                 jnb     short loc_4C46
.text$mn:00004C40                 mov     ecx, [ebp+arg_8]
.text$mn:00004C43                 mov     [ebp+Size], ecx
.text$mn:00004C46
.text$mn:00004C46 loc_4C46:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00004C46                 mov     edx, [ebp+var_4]
.text$mn:00004C49                 cmp     edx, [ebp+arg_0]
.text$mn:00004C4C                 jnz     short loc_4C6D
.text$mn:00004C4E                 mov     eax, [ebp+arg_4]
.text$mn:00004C51                 add     eax, [ebp+Size]
.text$mn:00004C54                 push    eax
.text$mn:00004C55                 mov     ecx, [ebp+var_4]
.text$mn:00004C58                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00004C5D                 mov     ecx, [ebp+arg_4]
.text$mn:00004C60                 push    ecx
.text$mn:00004C61                 push    0
.text$mn:00004C63                 mov     ecx, [ebp+var_4]
.text$mn:00004C66                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00004C6B                 jmp     short loc_4CAF
.text$mn:00004C6D ; ---------------------------------------------------------------------------
.text$mn:00004C6D
.text$mn:00004C6D loc_4C6D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00004C6D                 push    0
.text$mn:00004C6F                 mov     edx, [ebp+Size]
.text$mn:00004C72                 push    edx
.text$mn:00004C73                 mov     ecx, [ebp+var_4]
.text$mn:00004C76                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00004C7B                 movzx   eax, al
.text$mn:00004C7E                 test    eax, eax
.text$mn:00004C80                 jz      short loc_4CAF
.text$mn:00004C82                 mov     ecx, [ebp+Size]
.text$mn:00004C85                 push    ecx             ; Size
.text$mn:00004C86                 mov     ecx, [ebp+arg_0]
.text$mn:00004C89                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004C8E                 add     eax, [ebp+arg_4]
.text$mn:00004C91                 push    eax             ; Src
.text$mn:00004C92                 mov     ecx, [ebp+var_4]
.text$mn:00004C95                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004C9A                 push    eax             ; Dst
.text$mn:00004C9B                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00004CA0                 add     esp, 0Ch
.text$mn:00004CA3                 mov     edx, [ebp+Size]
.text$mn:00004CA6                 push    edx
.text$mn:00004CA7                 mov     ecx, [ebp+var_4]
.text$mn:00004CAA                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00004CAF
.text$mn:00004CAF loc_4CAF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00004CAF                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00004CAF                 mov     eax, [ebp+var_4]
.text$mn:00004CB2                 mov     esp, ebp
.text$mn:00004CB4                 pop     ebp
.text$mn:00004CB5                 retn    0Ch
.text$mn:00004CB5 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00004CB5
.text$mn:00004CB5 _text$mn        ends
.text$mn:00004CB5
.text$mn:00004CB8 ; ===========================================================================
.text$mn:00004CB8
.text$mn:00004CB8 ; Segment type: Pure code
.text$mn:00004CB8 ; Segment permissions: Read/Execute
.text$mn:00004CB8 _text$mn        segment para public 'CODE' use32
.text$mn:00004CB8                 assume cs:_text$mn
.text$mn:00004CB8                 ;org 4CB8h
.text$mn:00004CB8 ; COMDAT (pick any)
.text$mn:00004CB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004CB8
.text$mn:00004CB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CB8
.text$mn:00004CB8 ; Attributes: bp-based frame
.text$mn:00004CB8
.text$mn:00004CB8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00004CB8                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00004CB8 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00004CB8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00004CB8
.text$mn:00004CB8 var_4           = dword ptr -4
.text$mn:00004CB8 Str             = dword ptr  8
.text$mn:00004CB8
.text$mn:00004CB8                 push    ebp
.text$mn:00004CB9                 mov     ebp, esp
.text$mn:00004CBB                 push    ecx
.text$mn:00004CBC                 mov     [ebp+var_4], ecx
.text$mn:00004CBF                 push    490h            ; unsigned int
.text$mn:00004CC4                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004CC9                 mov     eax, [ebp+Str]
.text$mn:00004CCC                 push    eax             ; int
.text$mn:00004CCD                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00004CD2                 add     esp, 0Ch
.text$mn:00004CD5                 mov     ecx, [ebp+Str]
.text$mn:00004CD8                 push    ecx             ; Str
.text$mn:00004CD9                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00004CDE                 add     esp, 4
.text$mn:00004CE1                 push    eax             ; Size
.text$mn:00004CE2                 mov     edx, [ebp+Str]
.text$mn:00004CE5                 push    edx             ; Src
.text$mn:00004CE6                 mov     ecx, [ebp+var_4]
.text$mn:00004CE9                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00004CEE                 mov     esp, ebp
.text$mn:00004CF0                 pop     ebp
.text$mn:00004CF1                 retn    4
.text$mn:00004CF1 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00004CF1
.text$mn:00004CF1 _text$mn        ends
.text$mn:00004CF1
.text$mn:00004CF4 ; ===========================================================================
.text$mn:00004CF4
.text$mn:00004CF4 ; Segment type: Pure code
.text$mn:00004CF4 ; Segment permissions: Read/Execute
.text$mn:00004CF4 _text$mn        segment para public 'CODE' use32
.text$mn:00004CF4                 assume cs:_text$mn
.text$mn:00004CF4                 ;org 4CF4h
.text$mn:00004CF4 ; COMDAT (pick any)
.text$mn:00004CF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004CF4
.text$mn:00004CF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CF4
.text$mn:00004CF4 ; Attributes: bp-based frame
.text$mn:00004CF4
.text$mn:00004CF4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00004CF4                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00004CF4 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00004CF4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00004CF4
.text$mn:00004CF4 var_4           = dword ptr -4
.text$mn:00004CF4 Src             = dword ptr  8
.text$mn:00004CF4 Size            = dword ptr  0Ch
.text$mn:00004CF4
.text$mn:00004CF4                 push    ebp
.text$mn:00004CF5                 mov     ebp, esp
.text$mn:00004CF7                 push    ecx
.text$mn:00004CF8                 mov     [ebp+var_4], ecx
.text$mn:00004CFB                 cmp     [ebp+Size], 0
.text$mn:00004CFF                 jz      short loc_4D17
.text$mn:00004D01                 push    47Fh            ; unsigned int
.text$mn:00004D06                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004D0B                 mov     eax, [ebp+Src]
.text$mn:00004D0E                 push    eax             ; int
.text$mn:00004D0F                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00004D14                 add     esp, 0Ch
.text$mn:00004D17
.text$mn:00004D17 loc_4D17:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00004D17                 mov     ecx, [ebp+Src]
.text$mn:00004D1A                 push    ecx
.text$mn:00004D1B                 mov     ecx, [ebp+var_4]
.text$mn:00004D1E                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00004D23                 movzx   edx, al
.text$mn:00004D26                 test    edx, edx
.text$mn:00004D28                 jz      short loc_4D4A
.text$mn:00004D2A                 mov     eax, [ebp+Size]
.text$mn:00004D2D                 push    eax
.text$mn:00004D2E                 mov     ecx, [ebp+var_4]
.text$mn:00004D31                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004D36                 mov     ecx, [ebp+Src]
.text$mn:00004D39                 sub     ecx, eax
.text$mn:00004D3B                 push    ecx
.text$mn:00004D3C                 mov     edx, [ebp+var_4]
.text$mn:00004D3F                 push    edx
.text$mn:00004D40                 mov     ecx, [ebp+var_4]
.text$mn:00004D43                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00004D48                 jmp     short loc_4D87
.text$mn:00004D4A ; ---------------------------------------------------------------------------
.text$mn:00004D4A
.text$mn:00004D4A loc_4D4A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00004D4A                 push    0
.text$mn:00004D4C                 mov     eax, [ebp+Size]
.text$mn:00004D4F                 push    eax
.text$mn:00004D50                 mov     ecx, [ebp+var_4]
.text$mn:00004D53                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00004D58                 movzx   ecx, al
.text$mn:00004D5B                 test    ecx, ecx
.text$mn:00004D5D                 jz      short loc_4D84
.text$mn:00004D5F                 mov     edx, [ebp+Size]
.text$mn:00004D62                 push    edx             ; Size
.text$mn:00004D63                 mov     eax, [ebp+Src]
.text$mn:00004D66                 push    eax             ; Src
.text$mn:00004D67                 mov     ecx, [ebp+var_4]
.text$mn:00004D6A                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004D6F                 push    eax             ; Dst
.text$mn:00004D70                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00004D75                 add     esp, 0Ch
.text$mn:00004D78                 mov     ecx, [ebp+Size]
.text$mn:00004D7B                 push    ecx
.text$mn:00004D7C                 mov     ecx, [ebp+var_4]
.text$mn:00004D7F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00004D84
.text$mn:00004D84 loc_4D84:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00004D84                 mov     eax, [ebp+var_4]
.text$mn:00004D87
.text$mn:00004D87 loc_4D87:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00004D87                 mov     esp, ebp
.text$mn:00004D89                 pop     ebp
.text$mn:00004D8A                 retn    8
.text$mn:00004D8A ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00004D8A
.text$mn:00004D8A ; ---------------------------------------------------------------------------
.text$mn:00004D8D                 align 10h
.text$mn:00004D8D _text$mn        ends
.text$mn:00004D8D
.text$mn:00004D90 ; ===========================================================================
.text$mn:00004D90
.text$mn:00004D90 ; Segment type: Pure code
.text$mn:00004D90 ; Segment permissions: Read/Execute
.text$mn:00004D90 _text$mn        segment para public 'CODE' use32
.text$mn:00004D90                 assume cs:_text$mn
.text$mn:00004D90                 ;org 4D90h
.text$mn:00004D90 ; COMDAT (pick any)
.text$mn:00004D90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D90
.text$mn:00004D90 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D90
.text$mn:00004D90 ; Attributes: bp-based frame
.text$mn:00004D90
.text$mn:00004D90 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00004D90                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
.text$mn:00004D90 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z proc near
.text$mn:00004D90                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+66p
.text$mn:00004D90
.text$mn:00004D90 var_4           = dword ptr -4
.text$mn:00004D90 arg_0           = dword ptr  8
.text$mn:00004D90
.text$mn:00004D90                 push    ebp
.text$mn:00004D91                 mov     ebp, esp
.text$mn:00004D93                 push    ecx
.text$mn:00004D94                 mov     [ebp+var_4], ecx
.text$mn:00004D97                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00004D9C                 push    eax
.text$mn:00004D9D                 push    0
.text$mn:00004D9F                 mov     ecx, [ebp+arg_0]
.text$mn:00004DA2                 push    ecx
.text$mn:00004DA3                 mov     ecx, [ebp+var_4]
.text$mn:00004DA6                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00004DAB                 mov     esp, ebp
.text$mn:00004DAD                 pop     ebp
.text$mn:00004DAE                 retn    4
.text$mn:00004DAE ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z endp
.text$mn:00004DAE
.text$mn:00004DAE ; ---------------------------------------------------------------------------
.text$mn:00004DB1                 align 4
.text$mn:00004DB1 _text$mn        ends
.text$mn:00004DB1
.text$mn:00004DB4 ; ===========================================================================
.text$mn:00004DB4
.text$mn:00004DB4 ; Segment type: Pure code
.text$mn:00004DB4 ; Segment permissions: Read/Execute
.text$mn:00004DB4 _text$mn        segment para public 'CODE' use32
.text$mn:00004DB4                 assume cs:_text$mn
.text$mn:00004DB4                 ;org 4DB4h
.text$mn:00004DB4 ; COMDAT (pick any)
.text$mn:00004DB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004DB4
.text$mn:00004DB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004DB4
.text$mn:00004DB4 ; Attributes: bp-based frame
.text$mn:00004DB4
.text$mn:00004DB4 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:00004DB4                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00004DB4 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00004DB4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Bp
.text$mn:00004DB4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+16p ...
.text$mn:00004DB4
.text$mn:00004DB4 var_8           = dword ptr -8
.text$mn:00004DB4 var_4           = dword ptr -4
.text$mn:00004DB4 arg_0           = dword ptr  8
.text$mn:00004DB4 arg_4           = dword ptr  0Ch
.text$mn:00004DB4 arg_8           = dword ptr  10h
.text$mn:00004DB4
.text$mn:00004DB4                 push    ebp
.text$mn:00004DB5                 mov     ebp, esp
.text$mn:00004DB7                 sub     esp, 8
.text$mn:00004DBA                 mov     [ebp+var_4], ecx
.text$mn:00004DBD                 mov     ecx, [ebp+arg_0]
.text$mn:00004DC0                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00004DC5                 cmp     eax, [ebp+arg_4]
.text$mn:00004DC8                 jnb     short loc_4DD2
.text$mn:00004DCA                 mov     ecx, [ebp+var_4]
.text$mn:00004DCD                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00004DD2
.text$mn:00004DD2 loc_4DD2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:00004DD2                 mov     ecx, [ebp+arg_0]
.text$mn:00004DD5                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00004DDA                 sub     eax, [ebp+arg_4]
.text$mn:00004DDD                 mov     [ebp+var_8], eax
.text$mn:00004DE0                 mov     eax, [ebp+arg_8]
.text$mn:00004DE3                 cmp     eax, [ebp+var_8]
.text$mn:00004DE6                 jnb     short loc_4DEE
.text$mn:00004DE8                 mov     ecx, [ebp+arg_8]
.text$mn:00004DEB                 mov     [ebp+var_8], ecx
.text$mn:00004DEE
.text$mn:00004DEE loc_4DEE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:00004DEE                 mov     edx, [ebp+var_4]
.text$mn:00004DF1                 cmp     edx, [ebp+arg_0]
.text$mn:00004DF4                 jnz     short loc_4E15
.text$mn:00004DF6                 mov     eax, [ebp+arg_4]
.text$mn:00004DF9                 add     eax, [ebp+var_8]
.text$mn:00004DFC                 push    eax
.text$mn:00004DFD                 mov     ecx, [ebp+var_4]
.text$mn:00004E00                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00004E05                 mov     ecx, [ebp+arg_4]
.text$mn:00004E08                 push    ecx
.text$mn:00004E09                 push    0
.text$mn:00004E0B                 mov     ecx, [ebp+var_4]
.text$mn:00004E0E                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:00004E13                 jmp     short loc_4E5A
.text$mn:00004E15 ; ---------------------------------------------------------------------------
.text$mn:00004E15
.text$mn:00004E15 loc_4E15:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:00004E15                 push    0
.text$mn:00004E17                 mov     edx, [ebp+var_8]
.text$mn:00004E1A                 push    edx
.text$mn:00004E1B                 mov     ecx, [ebp+var_4]
.text$mn:00004E1E                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00004E23                 movzx   eax, al
.text$mn:00004E26                 test    eax, eax
.text$mn:00004E28                 jz      short loc_4E5A
.text$mn:00004E2A                 mov     ecx, [ebp+var_8]
.text$mn:00004E2D                 push    ecx             ; int
.text$mn:00004E2E                 mov     ecx, [ebp+arg_0]
.text$mn:00004E31                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004E36                 mov     edx, [ebp+arg_4]
.text$mn:00004E39                 lea     eax, [eax+edx*2]
.text$mn:00004E3C                 push    eax             ; Src
.text$mn:00004E3D                 mov     ecx, [ebp+var_4]
.text$mn:00004E40                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004E45                 push    eax             ; Dst
.text$mn:00004E46                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00004E4B                 add     esp, 0Ch
.text$mn:00004E4E                 mov     ecx, [ebp+var_8]
.text$mn:00004E51                 push    ecx
.text$mn:00004E52                 mov     ecx, [ebp+var_4]
.text$mn:00004E55                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00004E5A
.text$mn:00004E5A loc_4E5A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:00004E5A                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:00004E5A                 mov     eax, [ebp+var_4]
.text$mn:00004E5D                 mov     esp, ebp
.text$mn:00004E5F                 pop     ebp
.text$mn:00004E60                 retn    0Ch
.text$mn:00004E60 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00004E60
.text$mn:00004E60 ; ---------------------------------------------------------------------------
.text$mn:00004E63                 align 4
.text$mn:00004E63 _text$mn        ends
.text$mn:00004E63
.text$mn:00004E64 ; ===========================================================================
.text$mn:00004E64
.text$mn:00004E64 ; Segment type: Pure code
.text$mn:00004E64 ; Segment permissions: Read/Execute
.text$mn:00004E64 _text$mn        segment para public 'CODE' use32
.text$mn:00004E64                 assume cs:_text$mn
.text$mn:00004E64                 ;org 4E64h
.text$mn:00004E64 ; COMDAT (pick any)
.text$mn:00004E64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E64
.text$mn:00004E64 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E64
.text$mn:00004E64 ; Attributes: bp-based frame
.text$mn:00004E64
.text$mn:00004E64 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:00004E64                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:00004E64 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:00004E64                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+53p
.text$mn:00004E64                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)+Ep
.text$mn:00004E64
.text$mn:00004E64 var_4           = dword ptr -4
.text$mn:00004E64 Str             = dword ptr  8
.text$mn:00004E64
.text$mn:00004E64                 push    ebp
.text$mn:00004E65                 mov     ebp, esp
.text$mn:00004E67                 push    ecx
.text$mn:00004E68                 mov     [ebp+var_4], ecx
.text$mn:00004E6B                 push    490h            ; unsigned int
.text$mn:00004E70                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004E75                 mov     eax, [ebp+Str]
.text$mn:00004E78                 push    eax             ; int
.text$mn:00004E79                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00004E7E                 add     esp, 0Ch
.text$mn:00004E81                 mov     ecx, [ebp+Str]
.text$mn:00004E84                 push    ecx             ; Str
.text$mn:00004E85                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:00004E8A                 add     esp, 4
.text$mn:00004E8D                 push    eax             ; int
.text$mn:00004E8E                 mov     edx, [ebp+Str]
.text$mn:00004E91                 push    edx             ; Src
.text$mn:00004E92                 mov     ecx, [ebp+var_4]
.text$mn:00004E95                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:00004E9A                 mov     esp, ebp
.text$mn:00004E9C                 pop     ebp
.text$mn:00004E9D                 retn    4
.text$mn:00004E9D ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:00004E9D
.text$mn:00004E9D _text$mn        ends
.text$mn:00004E9D
.text$mn:00004EA0 ; ===========================================================================
.text$mn:00004EA0
.text$mn:00004EA0 ; Segment type: Pure code
.text$mn:00004EA0 ; Segment permissions: Read/Execute
.text$mn:00004EA0 _text$mn        segment para public 'CODE' use32
.text$mn:00004EA0                 assume cs:_text$mn
.text$mn:00004EA0                 ;org 4EA0h
.text$mn:00004EA0 ; COMDAT (pick any)
.text$mn:00004EA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004EA0
.text$mn:00004EA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004EA0
.text$mn:00004EA0 ; Attributes: bp-based frame
.text$mn:00004EA0
.text$mn:00004EA0 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:00004EA0                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:00004EA0 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:00004EA0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:00004EA0
.text$mn:00004EA0 var_4           = dword ptr -4
.text$mn:00004EA0 Src             = dword ptr  8
.text$mn:00004EA0 arg_4           = dword ptr  0Ch
.text$mn:00004EA0
.text$mn:00004EA0                 push    ebp
.text$mn:00004EA1                 mov     ebp, esp
.text$mn:00004EA3                 push    ecx
.text$mn:00004EA4                 mov     [ebp+var_4], ecx
.text$mn:00004EA7                 cmp     [ebp+arg_4], 0
.text$mn:00004EAB                 jz      short loc_4EC3
.text$mn:00004EAD                 push    47Fh            ; unsigned int
.text$mn:00004EB2                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004EB7                 mov     eax, [ebp+Src]
.text$mn:00004EBA                 push    eax             ; int
.text$mn:00004EBB                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00004EC0                 add     esp, 0Ch
.text$mn:00004EC3
.text$mn:00004EC3 loc_4EC3:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:00004EC3                 mov     ecx, [ebp+Src]
.text$mn:00004EC6                 push    ecx
.text$mn:00004EC7                 mov     ecx, [ebp+var_4]
.text$mn:00004ECA                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00004ECF                 movzx   edx, al
.text$mn:00004ED2                 test    edx, edx
.text$mn:00004ED4                 jz      short loc_4EF8
.text$mn:00004ED6                 mov     eax, [ebp+arg_4]
.text$mn:00004ED9                 push    eax
.text$mn:00004EDA                 mov     ecx, [ebp+var_4]
.text$mn:00004EDD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004EE2                 mov     ecx, [ebp+Src]
.text$mn:00004EE5                 sub     ecx, eax
.text$mn:00004EE7                 sar     ecx, 1
.text$mn:00004EE9                 push    ecx
.text$mn:00004EEA                 mov     edx, [ebp+var_4]
.text$mn:00004EED                 push    edx
.text$mn:00004EEE                 mov     ecx, [ebp+var_4]
.text$mn:00004EF1                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00004EF6                 jmp     short loc_4F35
.text$mn:00004EF8 ; ---------------------------------------------------------------------------
.text$mn:00004EF8
.text$mn:00004EF8 loc_4EF8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:00004EF8                 push    0
.text$mn:00004EFA                 mov     eax, [ebp+arg_4]
.text$mn:00004EFD                 push    eax
.text$mn:00004EFE                 mov     ecx, [ebp+var_4]
.text$mn:00004F01                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00004F06                 movzx   ecx, al
.text$mn:00004F09                 test    ecx, ecx
.text$mn:00004F0B                 jz      short loc_4F32
.text$mn:00004F0D                 mov     edx, [ebp+arg_4]
.text$mn:00004F10                 push    edx             ; int
.text$mn:00004F11                 mov     eax, [ebp+Src]
.text$mn:00004F14                 push    eax             ; Src
.text$mn:00004F15                 mov     ecx, [ebp+var_4]
.text$mn:00004F18                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004F1D                 push    eax             ; Dst
.text$mn:00004F1E                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00004F23                 add     esp, 0Ch
.text$mn:00004F26                 mov     ecx, [ebp+arg_4]
.text$mn:00004F29                 push    ecx
.text$mn:00004F2A                 mov     ecx, [ebp+var_4]
.text$mn:00004F2D                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00004F32
.text$mn:00004F32 loc_4F32:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:00004F32                 mov     eax, [ebp+var_4]
.text$mn:00004F35
.text$mn:00004F35 loc_4F35:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:00004F35                 mov     esp, ebp
.text$mn:00004F37                 pop     ebp
.text$mn:00004F38                 retn    8
.text$mn:00004F38 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:00004F38
.text$mn:00004F38 ; ---------------------------------------------------------------------------
.text$mn:00004F3B                 align 4
.text$mn:00004F3B _text$mn        ends
.text$mn:00004F3B
.text$mn:00004F3C ; ===========================================================================
.text$mn:00004F3C
.text$mn:00004F3C ; Segment type: Pure code
.text$mn:00004F3C ; Segment permissions: Read/Execute
.text$mn:00004F3C _text$mn        segment para public 'CODE' use32
.text$mn:00004F3C                 assume cs:_text$mn
.text$mn:00004F3C                 ;org 4F3Ch
.text$mn:00004F3C ; COMDAT (pick any)
.text$mn:00004F3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F3C
.text$mn:00004F3C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F3C
.text$mn:00004F3C ; Attributes: bp-based frame
.text$mn:00004F3C
.text$mn:00004F3C ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00004F3C                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00004F3C ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00004F3C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00004F3C
.text$mn:00004F3C arg_0           = dword ptr  8
.text$mn:00004F3C arg_4           = dword ptr  0Ch
.text$mn:00004F3C
.text$mn:00004F3C                 push    ebp
.text$mn:00004F3D                 mov     ebp, esp
.text$mn:00004F3F                 mov     eax, [ebp+arg_0]
.text$mn:00004F42                 mov     ecx, [ebp+arg_4]
.text$mn:00004F45                 mov     dl, [ecx]
.text$mn:00004F47                 mov     [eax], dl
.text$mn:00004F49                 pop     ebp
.text$mn:00004F4A                 retn
.text$mn:00004F4A ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00004F4A
.text$mn:00004F4A ; ---------------------------------------------------------------------------
.text$mn:00004F4B                 align 4
.text$mn:00004F4B _text$mn        ends
.text$mn:00004F4B
.text$mn:00004F4C ; ===========================================================================
.text$mn:00004F4C
.text$mn:00004F4C ; Segment type: Pure code
.text$mn:00004F4C ; Segment permissions: Read/Execute
.text$mn:00004F4C _text$mn        segment para public 'CODE' use32
.text$mn:00004F4C                 assume cs:_text$mn
.text$mn:00004F4C                 ;org 4F4Ch
.text$mn:00004F4C ; COMDAT (pick any)
.text$mn:00004F4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F4C
.text$mn:00004F4C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F4C
.text$mn:00004F4C ; Attributes: bp-based frame
.text$mn:00004F4C
.text$mn:00004F4C ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:00004F4C                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:00004F4C ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:00004F4C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:00004F4C
.text$mn:00004F4C arg_0           = dword ptr  8
.text$mn:00004F4C arg_4           = dword ptr  0Ch
.text$mn:00004F4C
.text$mn:00004F4C                 push    ebp
.text$mn:00004F4D                 mov     ebp, esp
.text$mn:00004F4F                 mov     eax, [ebp+arg_0]
.text$mn:00004F52                 mov     ecx, [ebp+arg_4]
.text$mn:00004F55                 mov     dx, [ecx]
.text$mn:00004F58                 mov     [eax], dx
.text$mn:00004F5B                 pop     ebp
.text$mn:00004F5C                 retn
.text$mn:00004F5C ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:00004F5C
.text$mn:00004F5C ; ---------------------------------------------------------------------------
.text$mn:00004F5D                 align 10h
.text$mn:00004F5D _text$mn        ends
.text$mn:00004F5D
.text$mn:00004F60 ; ===========================================================================
.text$mn:00004F60
.text$mn:00004F60 ; Segment type: Pure code
.text$mn:00004F60 ; Segment permissions: Read/Execute
.text$mn:00004F60 _text$mn        segment para public 'CODE' use32
.text$mn:00004F60                 assume cs:_text$mn
.text$mn:00004F60                 ;org 4F60h
.text$mn:00004F60 ; COMDAT (pick any)
.text$mn:00004F60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F60
.text$mn:00004F60 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F60
.text$mn:00004F60 ; Attributes: bp-based frame
.text$mn:00004F60
.text$mn:00004F60 ; public: struct RecentItem & __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::at(unsigned int)
.text$mn:00004F60                 public ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z
.text$mn:00004F60 ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z proc near
.text$mn:00004F60                                         ; CODE XREF: LastRecentFileList::switchMode(void)+6Bp
.text$mn:00004F60                                         ; LastRecentFileList::updateMenu(void)+462p ...
.text$mn:00004F60
.text$mn:00004F60 var_3C          = byte ptr -3Ch
.text$mn:00004F60 var_30          = byte ptr -30h
.text$mn:00004F60 var_24          = dword ptr -24h
.text$mn:00004F60 var_20          = dword ptr -20h
.text$mn:00004F60 var_1C          = dword ptr -1Ch
.text$mn:00004F60 var_18          = dword ptr -18h
.text$mn:00004F60 var_14          = dword ptr -14h
.text$mn:00004F60 var_10          = dword ptr -10h
.text$mn:00004F60 var_C           = dword ptr -0Ch
.text$mn:00004F60 var_4           = dword ptr -4
.text$mn:00004F60 arg_0           = dword ptr  8
.text$mn:00004F60
.text$mn:00004F60                 push    ebp
.text$mn:00004F61                 mov     ebp, esp
.text$mn:00004F63                 push    0FFFFFFFFh
.text$mn:00004F65                 push    offset __ehhandler$?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z
.text$mn:00004F6A                 mov     eax, large fs:0
.text$mn:00004F70                 push    eax
.text$mn:00004F71                 sub     esp, 30h
.text$mn:00004F74                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004F79                 xor     eax, ebp
.text$mn:00004F7B                 push    eax
.text$mn:00004F7C                 lea     eax, [ebp+var_C]
.text$mn:00004F7F                 mov     large fs:0, eax
.text$mn:00004F85                 mov     [ebp+var_10], ecx
.text$mn:00004F88                 mov     eax, [ebp+var_10]
.text$mn:00004F8B                 mov     ecx, [eax+10h]
.text$mn:00004F8E                 cmp     ecx, [ebp+arg_0]
.text$mn:00004F91                 ja      short loc_4F9B
.text$mn:00004F93                 mov     ecx, [ebp+var_10]
.text$mn:00004F96                 call    ?_Xran@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXXZ ; std::deque<RecentItem,std::allocator<RecentItem>>::_Xran(void)
.text$mn:00004F9B
.text$mn:00004F9B loc_4F9B:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)+31j
.text$mn:00004F9B                 mov     edx, [ebp+arg_0]
.text$mn:00004F9E                 push    edx
.text$mn:00004F9F                 lea     eax, [ebp+var_30]
.text$mn:00004FA2                 push    eax
.text$mn:00004FA3                 lea     ecx, [ebp+var_3C]
.text$mn:00004FA6                 push    ecx
.text$mn:00004FA7                 mov     ecx, [ebp+var_10]
.text$mn:00004FAA                 call    ?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ ; std::deque<RecentItem,std::allocator<RecentItem>>::begin(void)
.text$mn:00004FAF                 mov     [ebp+var_14], eax
.text$mn:00004FB2                 mov     edx, [ebp+var_14]
.text$mn:00004FB5                 mov     [ebp+var_18], edx
.text$mn:00004FB8                 mov     [ebp+var_4], 0
.text$mn:00004FBF                 mov     ecx, [ebp+var_18]
.text$mn:00004FC2                 call    ??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+(int)
.text$mn:00004FC7                 mov     [ebp+var_1C], eax
.text$mn:00004FCA                 mov     eax, [ebp+var_1C]
.text$mn:00004FCD                 mov     [ebp+var_20], eax
.text$mn:00004FD0                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004FD4                 mov     ecx, [ebp+var_20]
.text$mn:00004FD7                 call    ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEAAURecentItem@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)
.text$mn:00004FDC                 mov     [ebp+var_24], eax
.text$mn:00004FDF                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004FE3                 lea     ecx, [ebp+var_30]
.text$mn:00004FE6                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00004FEB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004FF2                 lea     ecx, [ebp+var_3C]
.text$mn:00004FF5                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00004FFA                 mov     eax, [ebp+var_24]
.text$mn:00004FFD                 mov     ecx, [ebp+var_C]
.text$mn:00005000                 mov     large fs:0, ecx
.text$mn:00005007                 pop     ecx
.text$mn:00005008                 mov     esp, ebp
.text$mn:0000500A                 pop     ebp
.text$mn:0000500B                 retn    4
.text$mn:0000500B ?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z endp
.text$mn:0000500B
.text$mn:0000500B ; ---------------------------------------------------------------------------
.text$mn:0000500E                 align 10h
.text$mn:0000500E _text$mn        ends
.text$mn:0000500E
.text$x:00005010 ; ===========================================================================
.text$x:00005010
.text$x:00005010 ; Segment type: Pure code
.text$x:00005010 ; Segment permissions: Read/Execute
.text$x:00005010 _text$x         segment para public 'CODE' use32
.text$x:00005010                 assume cs:_text$x
.text$x:00005010                 ;org 5010h
.text$x:00005010 ; COMDAT (pick associative to section at 4F60)
.text$x:00005010                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005010
.text$x:00005010 ; =============== S U B R O U T I N E =======================================
.text$x:00005010
.text$x:00005010
.text$x:00005010 __unwindfunclet$?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z$0 proc near
.text$x:00005010                                         ; DATA XREF: .xdata$x:00006FF4o
.text$x:00005010                 lea     ecx, [ebp-3Ch]
.text$x:00005013                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005013 __unwindfunclet$?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z$0 endp
.text$x:00005013
.text$x:00005018
.text$x:00005018 ; =============== S U B R O U T I N E =======================================
.text$x:00005018
.text$x:00005018
.text$x:00005018 __unwindfunclet$?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z$1 proc near
.text$x:00005018                                         ; DATA XREF: .xdata$x:00006FFCo
.text$x:00005018                 lea     ecx, [ebp-30h]
.text$x:0000501B                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:0000501B __unwindfunclet$?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z$1 endp
.text$x:0000501B
.text$x:00005020
.text$x:00005020 ; =============== S U B R O U T I N E =======================================
.text$x:00005020
.text$x:00005020
.text$x:00005020 __ehhandler$?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z proc near
.text$x:00005020                                         ; DATA XREF: std::deque<RecentItem,std::allocator<RecentItem>>::at(uint)+5o
.text$x:00005020
.text$x:00005020 arg_4           = dword ptr  8
.text$x:00005020
.text$x:00005020                 mov     edx, [esp+arg_4]
.text$x:00005024                 lea     eax, [edx+0Ch]
.text$x:00005027                 mov     ecx, [edx-34h]
.text$x:0000502A                 xor     ecx, eax
.text$x:0000502C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005031                 mov     eax, offset __ehfuncinfo$?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z
.text$x:00005036                 jmp     ___CxxFrameHandler3
.text$x:00005036 __ehhandler$?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z endp
.text$x:00005036
.text$x:00005036 ; ---------------------------------------------------------------------------
.text$x:0000503B                 align 4
.text$x:0000503B _text$x         ends
.text$x:0000503B
.text$mn:0000503C ; ===========================================================================
.text$mn:0000503C
.text$mn:0000503C ; Segment type: Pure code
.text$mn:0000503C ; Segment permissions: Read/Execute
.text$mn:0000503C _text$mn        segment para public 'CODE' use32
.text$mn:0000503C                 assume cs:_text$mn
.text$mn:0000503C                 ;org 503Ch
.text$mn:0000503C ; COMDAT (pick any)
.text$mn:0000503C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000503C
.text$mn:0000503C ; =============== S U B R O U T I N E =======================================
.text$mn:0000503C
.text$mn:0000503C ; Attributes: bp-based frame
.text$mn:0000503C
.text$mn:0000503C ; public: struct RecentItem & __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::back(void)
.text$mn:0000503C                 public ?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ
.text$mn:0000503C ?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ proc near
.text$mn:0000503C                                         ; CODE XREF: LastRecentFileList::add(wchar_t const *)+89p
.text$mn:0000503C                                         ; LastRecentFileList::setUserMaxNbLRF(int)+3Ap ...
.text$mn:0000503C
.text$mn:0000503C var_3C          = byte ptr -3Ch
.text$mn:0000503C var_30          = byte ptr -30h
.text$mn:0000503C var_24          = dword ptr -24h
.text$mn:0000503C var_20          = dword ptr -20h
.text$mn:0000503C var_1C          = dword ptr -1Ch
.text$mn:0000503C var_18          = dword ptr -18h
.text$mn:0000503C var_14          = dword ptr -14h
.text$mn:0000503C var_10          = dword ptr -10h
.text$mn:0000503C var_C           = dword ptr -0Ch
.text$mn:0000503C var_4           = dword ptr -4
.text$mn:0000503C
.text$mn:0000503C                 push    ebp
.text$mn:0000503D                 mov     ebp, esp
.text$mn:0000503F                 push    0FFFFFFFFh
.text$mn:00005041                 push    offset __ehhandler$?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ
.text$mn:00005046                 mov     eax, large fs:0
.text$mn:0000504C                 push    eax
.text$mn:0000504D                 sub     esp, 30h
.text$mn:00005050                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005055                 xor     eax, ebp
.text$mn:00005057                 push    eax
.text$mn:00005058                 lea     eax, [ebp+var_C]
.text$mn:0000505B                 mov     large fs:0, eax
.text$mn:00005061                 mov     [ebp+var_10], ecx
.text$mn:00005064                 push    1
.text$mn:00005066                 lea     eax, [ebp+var_30]
.text$mn:00005069                 push    eax
.text$mn:0000506A                 lea     ecx, [ebp+var_3C]
.text$mn:0000506D                 push    ecx
.text$mn:0000506E                 mov     ecx, [ebp+var_10]
.text$mn:00005071                 call    ?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ ; std::deque<RecentItem,std::allocator<RecentItem>>::end(void)
.text$mn:00005076                 mov     [ebp+var_14], eax
.text$mn:00005079                 mov     edx, [ebp+var_14]
.text$mn:0000507C                 mov     [ebp+var_18], edx
.text$mn:0000507F                 mov     [ebp+var_4], 0
.text$mn:00005086                 mov     ecx, [ebp+var_18]
.text$mn:00005089                 call    ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator-(int)
.text$mn:0000508E                 mov     [ebp+var_1C], eax
.text$mn:00005091                 mov     eax, [ebp+var_1C]
.text$mn:00005094                 mov     [ebp+var_20], eax
.text$mn:00005097                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000509B                 mov     ecx, [ebp+var_20]
.text$mn:0000509E                 call    ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEAAURecentItem@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)
.text$mn:000050A3                 mov     [ebp+var_24], eax
.text$mn:000050A6                 mov     byte ptr [ebp+var_4], 0
.text$mn:000050AA                 lea     ecx, [ebp+var_30]
.text$mn:000050AD                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:000050B2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000050B9                 lea     ecx, [ebp+var_3C]
.text$mn:000050BC                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:000050C1                 mov     eax, [ebp+var_24]
.text$mn:000050C4                 mov     ecx, [ebp+var_C]
.text$mn:000050C7                 mov     large fs:0, ecx
.text$mn:000050CE                 pop     ecx
.text$mn:000050CF                 mov     esp, ebp
.text$mn:000050D1                 pop     ebp
.text$mn:000050D2                 retn
.text$mn:000050D2 ?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ endp
.text$mn:000050D2
.text$mn:000050D2 ; ---------------------------------------------------------------------------
.text$mn:000050D3                 align 4
.text$mn:000050D3 _text$mn        ends
.text$mn:000050D3
.text$x:000050D4 ; ===========================================================================
.text$x:000050D4
.text$x:000050D4 ; Segment type: Pure code
.text$x:000050D4 ; Segment permissions: Read/Execute
.text$x:000050D4 _text$x         segment para public 'CODE' use32
.text$x:000050D4                 assume cs:_text$x
.text$x:000050D4                 ;org 50D4h
.text$x:000050D4 ; COMDAT (pick associative to section at 503C)
.text$x:000050D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000050D4
.text$x:000050D4 ; =============== S U B R O U T I N E =======================================
.text$x:000050D4
.text$x:000050D4
.text$x:000050D4 __unwindfunclet$?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ$0 proc near
.text$x:000050D4                                         ; DATA XREF: .xdata$x:00007028o
.text$x:000050D4                 lea     ecx, [ebp-3Ch]
.text$x:000050D7                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000050D7 __unwindfunclet$?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ$0 endp
.text$x:000050D7
.text$x:000050DC
.text$x:000050DC ; =============== S U B R O U T I N E =======================================
.text$x:000050DC
.text$x:000050DC
.text$x:000050DC __unwindfunclet$?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ$1 proc near
.text$x:000050DC                                         ; DATA XREF: .xdata$x:00007030o
.text$x:000050DC                 lea     ecx, [ebp-30h]
.text$x:000050DF                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:000050DF __unwindfunclet$?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ$1 endp
.text$x:000050DF
.text$x:000050E4
.text$x:000050E4 ; =============== S U B R O U T I N E =======================================
.text$x:000050E4
.text$x:000050E4
.text$x:000050E4 __ehhandler$?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ proc near
.text$x:000050E4                                         ; DATA XREF: std::deque<RecentItem,std::allocator<RecentItem>>::back(void)+5o
.text$x:000050E4
.text$x:000050E4 arg_4           = dword ptr  8
.text$x:000050E4
.text$x:000050E4                 mov     edx, [esp+arg_4]
.text$x:000050E8                 lea     eax, [edx+0Ch]
.text$x:000050EB                 mov     ecx, [edx-34h]
.text$x:000050EE                 xor     ecx, eax
.text$x:000050F0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000050F5                 mov     eax, offset __ehfuncinfo$?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ
.text$x:000050FA                 jmp     ___CxxFrameHandler3
.text$x:000050FA __ehhandler$?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ endp
.text$x:000050FA
.text$x:000050FA ; ---------------------------------------------------------------------------
.text$x:000050FF                 align 10h
.text$x:000050FF _text$x         ends
.text$x:000050FF
.text$mn:00005100 ; ===========================================================================
.text$mn:00005100
.text$mn:00005100 ; Segment type: Pure code
.text$mn:00005100 ; Segment permissions: Read/Execute
.text$mn:00005100 _text$mn        segment para public 'CODE' use32
.text$mn:00005100                 assume cs:_text$mn
.text$mn:00005100                 ;org 5100h
.text$mn:00005100 ; COMDAT (pick any)
.text$mn:00005100                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005100
.text$mn:00005100 ; =============== S U B R O U T I N E =======================================
.text$mn:00005100
.text$mn:00005100 ; Attributes: bp-based frame
.text$mn:00005100
.text$mn:00005100 ; public: class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::begin(void)
.text$mn:00005100                 public ?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ
.text$mn:00005100 ?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ proc near
.text$mn:00005100                                         ; CODE XREF: LastRecentFileList::remove(int)+A0p
.text$mn:00005100                                         ; LastRecentFileList::clear(void)+9Bp ...
.text$mn:00005100
.text$mn:00005100 var_14          = dword ptr -14h
.text$mn:00005100 var_10          = dword ptr -10h
.text$mn:00005100 var_C           = dword ptr -0Ch
.text$mn:00005100 var_4           = dword ptr -4
.text$mn:00005100 arg_0           = dword ptr  8
.text$mn:00005100
.text$mn:00005100                 push    ebp
.text$mn:00005101                 mov     ebp, esp
.text$mn:00005103                 push    0FFFFFFFFh
.text$mn:00005105                 push    offset __ehhandler$?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ
.text$mn:0000510A                 mov     eax, large fs:0
.text$mn:00005110                 push    eax
.text$mn:00005111                 sub     esp, 8
.text$mn:00005114                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005119                 xor     eax, ebp
.text$mn:0000511B                 push    eax
.text$mn:0000511C                 lea     eax, [ebp+var_C]
.text$mn:0000511F                 mov     large fs:0, eax
.text$mn:00005125                 mov     [ebp+var_10], ecx
.text$mn:00005128                 mov     [ebp+var_14], 0
.text$mn:0000512F                 mov     eax, [ebp+var_10]
.text$mn:00005132                 push    eax             ; struct std::_Container_base12 *
.text$mn:00005133                 mov     ecx, [ebp+var_10]
.text$mn:00005136                 mov     edx, [ecx+0Ch]
.text$mn:00005139                 push    edx             ; int
.text$mn:0000513A                 mov     ecx, [ebp+arg_0]
.text$mn:0000513D                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(uint,std::_Container_base12 const *)
.text$mn:00005142                 mov     [ebp+var_4], 0
.text$mn:00005149                 mov     eax, [ebp+var_14]
.text$mn:0000514C                 or      eax, 1
.text$mn:0000514F                 mov     [ebp+var_14], eax
.text$mn:00005152                 mov     eax, [ebp+arg_0]
.text$mn:00005155                 mov     ecx, [ebp+var_C]
.text$mn:00005158                 mov     large fs:0, ecx
.text$mn:0000515F                 pop     ecx
.text$mn:00005160                 mov     esp, ebp
.text$mn:00005162                 pop     ebp
.text$mn:00005163                 retn    4
.text$mn:00005163 ?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ endp
.text$mn:00005163
.text$mn:00005163 ; ---------------------------------------------------------------------------
.text$mn:00005166                 align 4
.text$mn:00005166 _text$mn        ends
.text$mn:00005166
.text$x:00005168 ; ===========================================================================
.text$x:00005168
.text$x:00005168 ; Segment type: Pure code
.text$x:00005168 ; Segment permissions: Read/Execute
.text$x:00005168 _text$x         segment para public 'CODE' use32
.text$x:00005168                 assume cs:_text$x
.text$x:00005168                 ;org 5168h
.text$x:00005168 ; COMDAT (pick associative to section at 5100)
.text$x:00005168                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005168
.text$x:00005168 ; =============== S U B R O U T I N E =======================================
.text$x:00005168
.text$x:00005168
.text$x:00005168 __unwindfunclet$?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ$0 proc near
.text$x:00005168                                         ; DATA XREF: .xdata$x:00006F68o
.text$x:00005168                 mov     eax, [ebp-14h]
.text$x:0000516B                 and     eax, 1
.text$x:0000516E                 jz      $LN4
.text$x:00005174                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00005178                 mov     ecx, [ebp+8]
.text$x:0000517B                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005180 ; ---------------------------------------------------------------------------
.text$x:00005180
.text$x:00005180 $LN4:                                   ; CODE XREF: __unwindfunclet$?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ$0+6j
.text$x:00005180                 retn
.text$x:00005180 __unwindfunclet$?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ$0 endp
.text$x:00005180
.text$x:00005181
.text$x:00005181 ; =============== S U B R O U T I N E =======================================
.text$x:00005181
.text$x:00005181
.text$x:00005181 __ehhandler$?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ proc near
.text$x:00005181                                         ; DATA XREF: std::deque<RecentItem,std::allocator<RecentItem>>::begin(void)+5o
.text$x:00005181
.text$x:00005181 arg_4           = dword ptr  8
.text$x:00005181
.text$x:00005181                 mov     edx, [esp+arg_4]
.text$x:00005185                 lea     eax, [edx+0Ch]
.text$x:00005188                 mov     ecx, [edx-0Ch]
.text$x:0000518B                 xor     ecx, eax
.text$x:0000518D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005192                 mov     eax, offset __ehfuncinfo$?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ
.text$x:00005197                 jmp     ___CxxFrameHandler3
.text$x:00005197 __ehhandler$?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ endp
.text$x:00005197
.text$x:00005197 _text$x         ends
.text$x:00005197
.text$mn:0000519C ; ===========================================================================
.text$mn:0000519C
.text$mn:0000519C ; Segment type: Pure code
.text$mn:0000519C ; Segment permissions: Read/Execute
.text$mn:0000519C _text$mn        segment para public 'CODE' use32
.text$mn:0000519C                 assume cs:_text$mn
.text$mn:0000519C                 ;org 519Ch
.text$mn:0000519C ; COMDAT (pick any)
.text$mn:0000519C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000519C
.text$mn:0000519C ; =============== S U B R O U T I N E =======================================
.text$mn:0000519C
.text$mn:0000519C ; Attributes: bp-based frame
.text$mn:0000519C
.text$mn:0000519C ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:0000519C                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:0000519C ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:0000519C                                         ; CODE XREF: LastRecentFileList::updateMenu(void)+19Ep
.text$mn:0000519C                                         ; LastRecentFileList::updateMenu(void)+1CEp ...
.text$mn:0000519C
.text$mn:0000519C var_4           = dword ptr -4
.text$mn:0000519C
.text$mn:0000519C                 push    ebp
.text$mn:0000519D                 mov     ebp, esp
.text$mn:0000519F                 push    ecx
.text$mn:000051A0                 mov     [ebp+var_4], ecx
.text$mn:000051A3                 mov     ecx, [ebp+var_4]
.text$mn:000051A6                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000051AB                 mov     esp, ebp
.text$mn:000051AD                 pop     ebp
.text$mn:000051AE                 retn
.text$mn:000051AE ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:000051AE
.text$mn:000051AE ; ---------------------------------------------------------------------------
.text$mn:000051AF                 align 10h
.text$mn:000051AF _text$mn        ends
.text$mn:000051AF
.text$mn:000051B0 ; ===========================================================================
.text$mn:000051B0
.text$mn:000051B0 ; Segment type: Pure code
.text$mn:000051B0 ; Segment permissions: Read/Execute
.text$mn:000051B0 _text$mn        segment para public 'CODE' use32
.text$mn:000051B0                 assume cs:_text$mn
.text$mn:000051B0                 ;org 51B0h
.text$mn:000051B0 ; COMDAT (pick any)
.text$mn:000051B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000051B0
.text$mn:000051B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000051B0
.text$mn:000051B0 ; Attributes: bp-based frame
.text$mn:000051B0
.text$mn:000051B0 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:000051B0                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:000051B0 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000051B0                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:000051B0
.text$mn:000051B0 var_4           = dword ptr -4
.text$mn:000051B0
.text$mn:000051B0                 push    ebp
.text$mn:000051B1                 mov     ebp, esp
.text$mn:000051B3                 push    ecx
.text$mn:000051B4                 mov     [ebp+var_4], ecx
.text$mn:000051B7                 mov     eax, [ebp+var_4]
.text$mn:000051BA                 mov     eax, [eax+4]
.text$mn:000051BD                 mov     esp, ebp
.text$mn:000051BF                 pop     ebp
.text$mn:000051C0                 retn
.text$mn:000051C0 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:000051C0
.text$mn:000051C0 ; ---------------------------------------------------------------------------
.text$mn:000051C1                 align 4
.text$mn:000051C1 _text$mn        ends
.text$mn:000051C1
.text$mn:000051C4 ; ===========================================================================
.text$mn:000051C4
.text$mn:000051C4 ; Segment type: Pure code
.text$mn:000051C4 ; Segment permissions: Read/Execute
.text$mn:000051C4 _text$mn        segment para public 'CODE' use32
.text$mn:000051C4                 assume cs:_text$mn
.text$mn:000051C4                 ;org 51C4h
.text$mn:000051C4 ; COMDAT (pick any)
.text$mn:000051C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000051C4
.text$mn:000051C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000051C4
.text$mn:000051C4 ; Attributes: bp-based frame
.text$mn:000051C4
.text$mn:000051C4 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:000051C4                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:000051C4 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000051C4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:000051C4                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:000051C4
.text$mn:000051C4 var_4           = dword ptr -4
.text$mn:000051C4
.text$mn:000051C4                 push    ebp
.text$mn:000051C5                 mov     ebp, esp
.text$mn:000051C7                 push    ecx
.text$mn:000051C8                 mov     [ebp+var_4], ecx
.text$mn:000051CB                 mov     eax, [ebp+var_4]
.text$mn:000051CE                 mov     eax, [eax+4]
.text$mn:000051D1                 mov     esp, ebp
.text$mn:000051D3                 pop     ebp
.text$mn:000051D4                 retn
.text$mn:000051D4 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:000051D4
.text$mn:000051D4 ; ---------------------------------------------------------------------------
.text$mn:000051D5                 align 4
.text$mn:000051D5 _text$mn        ends
.text$mn:000051D5
.text$mn:000051D8 ; ===========================================================================
.text$mn:000051D8
.text$mn:000051D8 ; Segment type: Pure code
.text$mn:000051D8 ; Segment permissions: Read/Execute
.text$mn:000051D8 _text$mn        segment para public 'CODE' use32
.text$mn:000051D8                 assume cs:_text$mn
.text$mn:000051D8                 ;org 51D8h
.text$mn:000051D8 ; COMDAT (pick any)
.text$mn:000051D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000051D8
.text$mn:000051D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000051D8
.text$mn:000051D8 ; Attributes: bp-based frame
.text$mn:000051D8
.text$mn:000051D8 ; public: int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::compare(unsigned int, unsigned int, wchar_t const *, unsigned int)const
.text$mn:000051D8                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z
.text$mn:000051D8 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z proc near
.text$mn:000051D8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)+3Ap
.text$mn:000051D8
.text$mn:000051D8 var_18          = dword ptr -18h
.text$mn:000051D8 var_14          = dword ptr -14h
.text$mn:000051D8 var_10          = dword ptr -10h
.text$mn:000051D8 var_C           = dword ptr -0Ch
.text$mn:000051D8 var_8           = dword ptr -8
.text$mn:000051D8 var_4           = dword ptr -4
.text$mn:000051D8 arg_0           = dword ptr  8
.text$mn:000051D8 arg_4           = dword ptr  0Ch
.text$mn:000051D8 arg_8           = dword ptr  10h
.text$mn:000051D8 arg_C           = dword ptr  14h
.text$mn:000051D8
.text$mn:000051D8                 push    ebp
.text$mn:000051D9                 mov     ebp, esp
.text$mn:000051DB                 sub     esp, 18h
.text$mn:000051DE                 mov     [ebp+var_4], ecx
.text$mn:000051E1                 cmp     [ebp+arg_C], 0
.text$mn:000051E5                 jz      short loc_51FD
.text$mn:000051E7                 push    87Dh            ; unsigned int
.text$mn:000051EC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000051F1                 mov     eax, [ebp+arg_8]
.text$mn:000051F4                 push    eax             ; int
.text$mn:000051F5                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000051FA                 add     esp, 0Ch
.text$mn:000051FD
.text$mn:000051FD loc_51FD:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+Dj
.text$mn:000051FD                 mov     ecx, [ebp+var_4]
.text$mn:00005200                 mov     edx, [ecx+14h]
.text$mn:00005203                 cmp     edx, [ebp+arg_0]
.text$mn:00005206                 jnb     short loc_5210
.text$mn:00005208                 mov     ecx, [ebp+var_4]
.text$mn:0000520B                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00005210
.text$mn:00005210 loc_5210:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+2Ej
.text$mn:00005210                 mov     eax, [ebp+var_4]
.text$mn:00005213                 mov     ecx, [eax+14h]
.text$mn:00005216                 sub     ecx, [ebp+arg_0]
.text$mn:00005219                 cmp     ecx, [ebp+arg_4]
.text$mn:0000521C                 jnb     short loc_522A
.text$mn:0000521E                 mov     edx, [ebp+var_4]
.text$mn:00005221                 mov     eax, [edx+14h]
.text$mn:00005224                 sub     eax, [ebp+arg_0]
.text$mn:00005227                 mov     [ebp+arg_4], eax
.text$mn:0000522A
.text$mn:0000522A loc_522A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+44j
.text$mn:0000522A                 mov     ecx, [ebp+arg_4]
.text$mn:0000522D                 cmp     ecx, [ebp+arg_C]
.text$mn:00005230                 jnb     short loc_523A
.text$mn:00005232                 mov     edx, [ebp+arg_4]
.text$mn:00005235                 mov     [ebp+var_8], edx
.text$mn:00005238                 jmp     short loc_5240
.text$mn:0000523A ; ---------------------------------------------------------------------------
.text$mn:0000523A
.text$mn:0000523A loc_523A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+58j
.text$mn:0000523A                 mov     eax, [ebp+arg_C]
.text$mn:0000523D                 mov     [ebp+var_8], eax
.text$mn:00005240
.text$mn:00005240 loc_5240:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+60j
.text$mn:00005240                 mov     ecx, [ebp+var_8]
.text$mn:00005243                 push    ecx
.text$mn:00005244                 mov     edx, [ebp+arg_8]
.text$mn:00005247                 push    edx
.text$mn:00005248                 mov     ecx, [ebp+var_4]
.text$mn:0000524B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00005250                 mov     ecx, [ebp+arg_0]
.text$mn:00005253                 lea     edx, [eax+ecx*2]
.text$mn:00005256                 push    edx
.text$mn:00005257                 call    ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z ; std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)
.text$mn:0000525C                 add     esp, 0Ch
.text$mn:0000525F                 mov     [ebp+var_C], eax
.text$mn:00005262                 cmp     [ebp+var_C], 0
.text$mn:00005266                 jz      short loc_5270
.text$mn:00005268                 mov     eax, [ebp+var_C]
.text$mn:0000526B                 mov     [ebp+var_18], eax
.text$mn:0000526E                 jmp     short loc_52A5
.text$mn:00005270 ; ---------------------------------------------------------------------------
.text$mn:00005270
.text$mn:00005270 loc_5270:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+8Ej
.text$mn:00005270                 mov     ecx, [ebp+arg_4]
.text$mn:00005273                 cmp     ecx, [ebp+arg_C]
.text$mn:00005276                 jnb     short loc_5281
.text$mn:00005278                 mov     [ebp+var_14], 0FFFFFFFFh
.text$mn:0000527F                 jmp     short loc_529F
.text$mn:00005281 ; ---------------------------------------------------------------------------
.text$mn:00005281
.text$mn:00005281 loc_5281:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+9Ej
.text$mn:00005281                 mov     edx, [ebp+arg_4]
.text$mn:00005284                 cmp     edx, [ebp+arg_C]
.text$mn:00005287                 jnz     short loc_5292
.text$mn:00005289                 mov     [ebp+var_10], 0
.text$mn:00005290                 jmp     short loc_5299
.text$mn:00005292 ; ---------------------------------------------------------------------------
.text$mn:00005292
.text$mn:00005292 loc_5292:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+AFj
.text$mn:00005292                 mov     [ebp+var_10], 1
.text$mn:00005299
.text$mn:00005299 loc_5299:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+B8j
.text$mn:00005299                 mov     eax, [ebp+var_10]
.text$mn:0000529C                 mov     [ebp+var_14], eax
.text$mn:0000529F
.text$mn:0000529F loc_529F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+A7j
.text$mn:0000529F                 mov     ecx, [ebp+var_14]
.text$mn:000052A2                 mov     [ebp+var_18], ecx
.text$mn:000052A5
.text$mn:000052A5 loc_52A5:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+96j
.text$mn:000052A5                 mov     eax, [ebp+var_18]
.text$mn:000052A8                 mov     esp, ebp
.text$mn:000052AA                 pop     ebp
.text$mn:000052AB                 retn    10h
.text$mn:000052AB ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z endp
.text$mn:000052AB
.text$mn:000052AB ; ---------------------------------------------------------------------------
.text$mn:000052AE                 align 10h
.text$mn:000052AE _text$mn        ends
.text$mn:000052AE
.text$mn:000052B0 ; ===========================================================================
.text$mn:000052B0
.text$mn:000052B0 ; Segment type: Pure code
.text$mn:000052B0 ; Segment permissions: Read/Execute
.text$mn:000052B0 _text$mn        segment para public 'CODE' use32
.text$mn:000052B0                 assume cs:_text$mn
.text$mn:000052B0                 ;org 52B0h
.text$mn:000052B0 ; COMDAT (pick any)
.text$mn:000052B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000052B0
.text$mn:000052B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000052B0
.text$mn:000052B0 ; Attributes: bp-based frame
.text$mn:000052B0
.text$mn:000052B0 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t *Str)
.text$mn:000052B0                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z
.text$mn:000052B0 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z proc near
.text$mn:000052B0                                         ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+Bp
.text$mn:000052B0
.text$mn:000052B0 var_4           = dword ptr -4
.text$mn:000052B0 Str             = dword ptr  8
.text$mn:000052B0
.text$mn:000052B0                 push    ebp
.text$mn:000052B1                 mov     ebp, esp
.text$mn:000052B3                 push    ecx
.text$mn:000052B4                 mov     [ebp+var_4], ecx
.text$mn:000052B7                 push    86Eh            ; unsigned int
.text$mn:000052BC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000052C1                 mov     eax, [ebp+Str]
.text$mn:000052C4                 push    eax             ; int
.text$mn:000052C5                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000052CA                 add     esp, 0Ch
.text$mn:000052CD                 mov     ecx, [ebp+Str]
.text$mn:000052D0                 push    ecx             ; Str
.text$mn:000052D1                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:000052D6                 add     esp, 4
.text$mn:000052D9                 push    eax
.text$mn:000052DA                 mov     edx, [ebp+Str]
.text$mn:000052DD                 push    edx
.text$mn:000052DE                 mov     eax, [ebp+var_4]
.text$mn:000052E1                 mov     ecx, [eax+14h]
.text$mn:000052E4                 push    ecx
.text$mn:000052E5                 push    0
.text$mn:000052E7                 mov     ecx, [ebp+var_4]
.text$mn:000052EA                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)
.text$mn:000052EF                 mov     esp, ebp
.text$mn:000052F1                 pop     ebp
.text$mn:000052F2                 retn    4
.text$mn:000052F2 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z endp
.text$mn:000052F2
.text$mn:000052F2 ; ---------------------------------------------------------------------------
.text$mn:000052F5                 align 4
.text$mn:000052F5 _text$mn        ends
.text$mn:000052F5
.text$mn:000052F8 ; ===========================================================================
.text$mn:000052F8
.text$mn:000052F8 ; Segment type: Pure code
.text$mn:000052F8 ; Segment permissions: Read/Execute
.text$mn:000052F8 _text$mn        segment para public 'CODE' use32
.text$mn:000052F8                 assume cs:_text$mn
.text$mn:000052F8                 ;org 52F8h
.text$mn:000052F8 ; COMDAT (pick any)
.text$mn:000052F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000052F8
.text$mn:000052F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000052F8
.text$mn:000052F8 ; Attributes: bp-based frame
.text$mn:000052F8
.text$mn:000052F8 ; public: static int __cdecl std::char_traits<wchar_t>::compare(wchar_t const *, wchar_t const *, unsigned int)
.text$mn:000052F8                 public ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z
.text$mn:000052F8 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z proc near
.text$mn:000052F8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+7Fp
.text$mn:000052F8
.text$mn:000052F8 var_4           = dword ptr -4
.text$mn:000052F8 arg_0           = dword ptr  8
.text$mn:000052F8 arg_4           = dword ptr  0Ch
.text$mn:000052F8 arg_8           = dword ptr  10h
.text$mn:000052F8
.text$mn:000052F8                 push    ebp
.text$mn:000052F9                 mov     ebp, esp
.text$mn:000052FB                 push    ecx
.text$mn:000052FC                 cmp     [ebp+arg_8], 0
.text$mn:00005300                 jnz     short loc_530B
.text$mn:00005302                 mov     [ebp+var_4], 0
.text$mn:00005309                 jmp     short loc_5322
.text$mn:0000530B ; ---------------------------------------------------------------------------
.text$mn:0000530B
.text$mn:0000530B loc_530B:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+8j
.text$mn:0000530B                 mov     eax, [ebp+arg_8]
.text$mn:0000530E                 push    eax
.text$mn:0000530F                 mov     ecx, [ebp+arg_4]
.text$mn:00005312                 push    ecx
.text$mn:00005313                 mov     edx, [ebp+arg_0]
.text$mn:00005316                 push    edx
.text$mn:00005317                 call    _wmemcmp
.text$mn:0000531C                 add     esp, 0Ch
.text$mn:0000531F                 mov     [ebp+var_4], eax
.text$mn:00005322
.text$mn:00005322 loc_5322:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+11j
.text$mn:00005322                 mov     eax, [ebp+var_4]
.text$mn:00005325                 mov     esp, ebp
.text$mn:00005327                 pop     ebp
.text$mn:00005328                 retn
.text$mn:00005328 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z endp
.text$mn:00005328
.text$mn:00005328 ; ---------------------------------------------------------------------------
.text$mn:00005329                 align 4
.text$mn:00005329 _text$mn        ends
.text$mn:00005329
.text$mn:0000532C ; ===========================================================================
.text$mn:0000532C
.text$mn:0000532C ; Segment type: Pure code
.text$mn:0000532C ; Segment permissions: Read/Execute
.text$mn:0000532C _text$mn        segment para public 'CODE' use32
.text$mn:0000532C                 assume cs:_text$mn
.text$mn:0000532C                 ;org 532Ch
.text$mn:0000532C ; COMDAT (pick any)
.text$mn:0000532C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000532C
.text$mn:0000532C ; =============== S U B R O U T I N E =======================================
.text$mn:0000532C
.text$mn:0000532C ; Attributes: bp-based frame
.text$mn:0000532C
.text$mn:0000532C ; int __stdcall std::allocator<RecentItem>::construct(void *, int)
.text$mn:0000532C                 public ?construct@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@ABU3@@Z
.text$mn:0000532C ?construct@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@ABU3@@Z proc near
.text$mn:0000532C                                         ; CODE XREF: std::allocator_traits<std::allocator<RecentItem>>::construct<RecentItem,RecentItem const &>(std::allocator<RecentItem> &,RecentItem *,RecentItem const &)+17p
.text$mn:0000532C
.text$mn:0000532C var_1C          = dword ptr -1Ch
.text$mn:0000532C var_18          = dword ptr -18h
.text$mn:0000532C var_14          = dword ptr -14h
.text$mn:0000532C var_10          = dword ptr -10h
.text$mn:0000532C var_C           = dword ptr -0Ch
.text$mn:0000532C var_4           = dword ptr -4
.text$mn:0000532C arg_0           = dword ptr  8
.text$mn:0000532C arg_4           = dword ptr  0Ch
.text$mn:0000532C
.text$mn:0000532C                 push    ebp
.text$mn:0000532D                 mov     ebp, esp
.text$mn:0000532F                 push    0FFFFFFFFh
.text$mn:00005331                 push    offset __ehhandler$?construct@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@ABU3@@Z
.text$mn:00005336                 mov     eax, large fs:0
.text$mn:0000533C                 push    eax
.text$mn:0000533D                 sub     esp, 10h
.text$mn:00005340                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005345                 xor     eax, ebp
.text$mn:00005347                 push    eax
.text$mn:00005348                 lea     eax, [ebp+var_C]
.text$mn:0000534B                 mov     large fs:0, eax
.text$mn:00005351                 mov     [ebp+var_18], ecx
.text$mn:00005354                 mov     eax, [ebp+arg_0]
.text$mn:00005357                 push    eax             ; void *
.text$mn:00005358                 push    20h ; ' '       ; unsigned int
.text$mn:0000535A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000535F                 add     esp, 8
.text$mn:00005362                 mov     [ebp+var_10], eax
.text$mn:00005365                 mov     [ebp+var_4], 0
.text$mn:0000536C                 cmp     [ebp+var_10], 0
.text$mn:00005370                 jz      short loc_5383
.text$mn:00005372                 mov     ecx, [ebp+arg_4]
.text$mn:00005375                 push    ecx
.text$mn:00005376                 mov     ecx, [ebp+var_10]
.text$mn:00005379                 call    ??0RecentItem@@QAE@ABU0@@Z ; RecentItem::RecentItem(RecentItem const &)
.text$mn:0000537E                 mov     [ebp+var_14], eax
.text$mn:00005381                 jmp     short loc_538A
.text$mn:00005383 ; ---------------------------------------------------------------------------
.text$mn:00005383
.text$mn:00005383 loc_5383:                               ; CODE XREF: std::allocator<RecentItem>::construct(RecentItem *,RecentItem const &)+44j
.text$mn:00005383                 mov     [ebp+var_14], 0
.text$mn:0000538A
.text$mn:0000538A loc_538A:                               ; CODE XREF: std::allocator<RecentItem>::construct(RecentItem *,RecentItem const &)+55j
.text$mn:0000538A                 mov     edx, [ebp+var_14]
.text$mn:0000538D                 mov     [ebp+var_1C], edx
.text$mn:00005390                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005397                 mov     ecx, [ebp+var_C]
.text$mn:0000539A                 mov     large fs:0, ecx
.text$mn:000053A1                 pop     ecx
.text$mn:000053A2                 mov     esp, ebp
.text$mn:000053A4                 pop     ebp
.text$mn:000053A5                 retn    8
.text$mn:000053A5 ?construct@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@ABU3@@Z endp
.text$mn:000053A5
.text$mn:000053A5 _text$mn        ends
.text$mn:000053A5
.text$x:000053A8 ; ===========================================================================
.text$x:000053A8
.text$x:000053A8 ; Segment type: Pure code
.text$x:000053A8 ; Segment permissions: Read/Execute
.text$x:000053A8 _text$x         segment para public 'CODE' use32
.text$x:000053A8                 assume cs:_text$x
.text$x:000053A8                 ;org 53A8h
.text$x:000053A8 ; COMDAT (pick associative to section at 532C)
.text$x:000053A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000053A8
.text$x:000053A8 ; =============== S U B R O U T I N E =======================================
.text$x:000053A8
.text$x:000053A8
.text$x:000053A8 __unwindfunclet$?construct@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@ABU3@@Z$0 proc near
.text$x:000053A8                                         ; DATA XREF: .xdata$x:00006F3Co
.text$x:000053A8                 mov     eax, [ebp+8]
.text$x:000053AB                 push    eax
.text$x:000053AC                 mov     eax, [ebp-10h]
.text$x:000053AF                 push    eax             ; void *
.text$x:000053B0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000053B5                 add     esp, 8
.text$x:000053B8                 retn
.text$x:000053B8 __unwindfunclet$?construct@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@ABU3@@Z$0 endp
.text$x:000053B8
.text$x:000053B9
.text$x:000053B9 ; =============== S U B R O U T I N E =======================================
.text$x:000053B9
.text$x:000053B9
.text$x:000053B9 __ehhandler$?construct@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@ABU3@@Z proc near
.text$x:000053B9                                         ; DATA XREF: std::allocator<RecentItem>::construct(RecentItem *,RecentItem const &)+5o
.text$x:000053B9
.text$x:000053B9 arg_4           = dword ptr  8
.text$x:000053B9
.text$x:000053B9                 mov     edx, [esp+arg_4]
.text$x:000053BD                 lea     eax, [edx+0Ch]
.text$x:000053C0                 mov     ecx, [edx-14h]
.text$x:000053C3                 xor     ecx, eax
.text$x:000053C5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000053CA                 mov     eax, offset __ehfuncinfo$?construct@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@ABU3@@Z
.text$x:000053CF                 jmp     ___CxxFrameHandler3
.text$x:000053CF __ehhandler$?construct@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@ABU3@@Z endp
.text$x:000053CF
.text$x:000053CF _text$x         ends
.text$x:000053CF
.text$mn:000053D4 ; ===========================================================================
.text$mn:000053D4
.text$mn:000053D4 ; Segment type: Pure code
.text$mn:000053D4 ; Segment permissions: Read/Execute
.text$mn:000053D4 _text$mn        segment para public 'CODE' use32
.text$mn:000053D4                 assume cs:_text$mn
.text$mn:000053D4                 ;org 53D4h
.text$mn:000053D4 ; COMDAT (pick any)
.text$mn:000053D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000053D4
.text$mn:000053D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000053D4
.text$mn:000053D4 ; Attributes: bp-based frame
.text$mn:000053D4
.text$mn:000053D4 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:000053D4                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000053D4 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:000053D4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:000053D4
.text$mn:000053D4 var_4           = dword ptr -4
.text$mn:000053D4 Dst             = dword ptr  8
.text$mn:000053D4 Src             = dword ptr  0Ch
.text$mn:000053D4 Size            = dword ptr  10h
.text$mn:000053D4
.text$mn:000053D4                 push    ebp
.text$mn:000053D5                 mov     ebp, esp
.text$mn:000053D7                 push    ecx
.text$mn:000053D8                 cmp     [ebp+Size], 0
.text$mn:000053DC                 jnz     short loc_53E6
.text$mn:000053DE                 mov     eax, [ebp+Dst]
.text$mn:000053E1                 mov     [ebp+var_4], eax
.text$mn:000053E4                 jmp     short loc_53FD
.text$mn:000053E6 ; ---------------------------------------------------------------------------
.text$mn:000053E6
.text$mn:000053E6 loc_53E6:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:000053E6                 mov     ecx, [ebp+Size]
.text$mn:000053E9                 push    ecx             ; Size
.text$mn:000053EA                 mov     edx, [ebp+Src]
.text$mn:000053ED                 push    edx             ; Src
.text$mn:000053EE                 mov     eax, [ebp+Dst]
.text$mn:000053F1                 push    eax             ; Dst
.text$mn:000053F2                 call    _memcpy
.text$mn:000053F7                 add     esp, 0Ch
.text$mn:000053FA                 mov     [ebp+var_4], eax
.text$mn:000053FD
.text$mn:000053FD loc_53FD:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:000053FD                 mov     eax, [ebp+var_4]
.text$mn:00005400                 mov     esp, ebp
.text$mn:00005402                 pop     ebp
.text$mn:00005403                 retn
.text$mn:00005403 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00005403
.text$mn:00005403 _text$mn        ends
.text$mn:00005403
.text$mn:00005404 ; ===========================================================================
.text$mn:00005404
.text$mn:00005404 ; Segment type: Pure code
.text$mn:00005404 ; Segment permissions: Read/Execute
.text$mn:00005404 _text$mn        segment para public 'CODE' use32
.text$mn:00005404                 assume cs:_text$mn
.text$mn:00005404                 ;org 5404h
.text$mn:00005404 ; COMDAT (pick any)
.text$mn:00005404                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005404
.text$mn:00005404 ; =============== S U B R O U T I N E =======================================
.text$mn:00005404
.text$mn:00005404 ; Attributes: bp-based frame
.text$mn:00005404
.text$mn:00005404 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:00005404                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00005404 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00005404                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:00005404                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00005404
.text$mn:00005404 var_4           = dword ptr -4
.text$mn:00005404 Dst             = dword ptr  8
.text$mn:00005404 Src             = dword ptr  0Ch
.text$mn:00005404 arg_8           = dword ptr  10h
.text$mn:00005404
.text$mn:00005404                 push    ebp
.text$mn:00005405                 mov     ebp, esp
.text$mn:00005407                 push    ecx
.text$mn:00005408                 cmp     [ebp+arg_8], 0
.text$mn:0000540C                 jnz     short loc_5416
.text$mn:0000540E                 mov     eax, [ebp+Dst]
.text$mn:00005411                 mov     [ebp+var_4], eax
.text$mn:00005414                 jmp     short loc_542D
.text$mn:00005416 ; ---------------------------------------------------------------------------
.text$mn:00005416
.text$mn:00005416 loc_5416:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00005416                 mov     ecx, [ebp+arg_8]
.text$mn:00005419                 push    ecx             ; int
.text$mn:0000541A                 mov     edx, [ebp+Src]
.text$mn:0000541D                 push    edx             ; Src
.text$mn:0000541E                 mov     eax, [ebp+Dst]
.text$mn:00005421                 push    eax             ; Dst
.text$mn:00005422                 call    _wmemcpy
.text$mn:00005427                 add     esp, 0Ch
.text$mn:0000542A                 mov     [ebp+var_4], eax
.text$mn:0000542D
.text$mn:0000542D loc_542D:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:0000542D                 mov     eax, [ebp+var_4]
.text$mn:00005430                 mov     esp, ebp
.text$mn:00005432                 pop     ebp
.text$mn:00005433                 retn
.text$mn:00005433 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00005433
.text$mn:00005433 _text$mn        ends
.text$mn:00005433
.text$mn:00005434 ; ===========================================================================
.text$mn:00005434
.text$mn:00005434 ; Segment type: Pure code
.text$mn:00005434 ; Segment permissions: Read/Execute
.text$mn:00005434 _text$mn        segment para public 'CODE' use32
.text$mn:00005434                 assume cs:_text$mn
.text$mn:00005434                 ;org 5434h
.text$mn:00005434 ; COMDAT (pick any)
.text$mn:00005434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005434
.text$mn:00005434 ; =============== S U B R O U T I N E =======================================
.text$mn:00005434
.text$mn:00005434 ; Attributes: bp-based frame
.text$mn:00005434
.text$mn:00005434 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00005434                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00005434 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00005434                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00005434
.text$mn:00005434 var_4           = dword ptr -4
.text$mn:00005434 arg_0           = dword ptr  8
.text$mn:00005434 arg_4           = dword ptr  0Ch
.text$mn:00005434
.text$mn:00005434                 push    ebp
.text$mn:00005435                 mov     ebp, esp
.text$mn:00005437                 push    ecx
.text$mn:00005438                 mov     [ebp+var_4], ecx
.text$mn:0000543B                 mov     eax, [ebp+arg_4]
.text$mn:0000543E                 push    eax             ; int
.text$mn:0000543F                 mov     ecx, [ebp+arg_0]
.text$mn:00005442                 push    ecx             ; void *
.text$mn:00005443                 mov     ecx, [ebp+var_4]
.text$mn:00005446                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000544B                 mov     esp, ebp
.text$mn:0000544D                 pop     ebp
.text$mn:0000544E                 retn    8
.text$mn:0000544E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000544E
.text$mn:0000544E ; ---------------------------------------------------------------------------
.text$mn:00005451                 align 4
.text$mn:00005451 _text$mn        ends
.text$mn:00005451
.text$mn:00005454 ; ===========================================================================
.text$mn:00005454
.text$mn:00005454 ; Segment type: Pure code
.text$mn:00005454 ; Segment permissions: Read/Execute
.text$mn:00005454 _text$mn        segment para public 'CODE' use32
.text$mn:00005454                 assume cs:_text$mn
.text$mn:00005454                 ;org 5454h
.text$mn:00005454 ; COMDAT (pick any)
.text$mn:00005454                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005454
.text$mn:00005454 ; =============== S U B R O U T I N E =======================================
.text$mn:00005454
.text$mn:00005454 ; Attributes: bp-based frame
.text$mn:00005454
.text$mn:00005454 ; int __stdcall std::_Wrap_alloc<std::allocator<RecentItem *>>::deallocate(void *, int)
.text$mn:00005454                 public ?deallocate@?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@QAEXPAPAURecentItem@@I@Z
.text$mn:00005454 ?deallocate@?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@QAEXPAPAURecentItem@@I@Z proc near
.text$mn:00005454                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+1DFp
.text$mn:00005454
.text$mn:00005454 var_4           = dword ptr -4
.text$mn:00005454 arg_0           = dword ptr  8
.text$mn:00005454 arg_4           = dword ptr  0Ch
.text$mn:00005454
.text$mn:00005454                 push    ebp
.text$mn:00005455                 mov     ebp, esp
.text$mn:00005457                 push    ecx
.text$mn:00005458                 mov     [ebp+var_4], ecx
.text$mn:0000545B                 mov     eax, [ebp+arg_4]
.text$mn:0000545E                 push    eax             ; int
.text$mn:0000545F                 mov     ecx, [ebp+arg_0]
.text$mn:00005462                 push    ecx             ; void *
.text$mn:00005463                 mov     ecx, [ebp+var_4]
.text$mn:00005466                 call    ?deallocate@?$allocator@PAURecentItem@@@std@@QAEXPAPAURecentItem@@I@Z ; std::allocator<RecentItem *>::deallocate(RecentItem * *,uint)
.text$mn:0000546B                 mov     esp, ebp
.text$mn:0000546D                 pop     ebp
.text$mn:0000546E                 retn    8
.text$mn:0000546E ?deallocate@?$_Wrap_alloc@V?$allocator@PAURecentItem@@@std@@@std@@QAEXPAPAURecentItem@@I@Z endp
.text$mn:0000546E
.text$mn:0000546E ; ---------------------------------------------------------------------------
.text$mn:00005471                 align 4
.text$mn:00005471 _text$mn        ends
.text$mn:00005471
.text$mn:00005474 ; ===========================================================================
.text$mn:00005474
.text$mn:00005474 ; Segment type: Pure code
.text$mn:00005474 ; Segment permissions: Read/Execute
.text$mn:00005474 _text$mn        segment para public 'CODE' use32
.text$mn:00005474                 assume cs:_text$mn
.text$mn:00005474                 ;org 5474h
.text$mn:00005474 ; COMDAT (pick any)
.text$mn:00005474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005474
.text$mn:00005474 ; =============== S U B R O U T I N E =======================================
.text$mn:00005474
.text$mn:00005474 ; Attributes: bp-based frame
.text$mn:00005474
.text$mn:00005474 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:00005474                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:00005474 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:00005474                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:00005474
.text$mn:00005474 var_4           = dword ptr -4
.text$mn:00005474 arg_0           = dword ptr  8
.text$mn:00005474 arg_4           = dword ptr  0Ch
.text$mn:00005474
.text$mn:00005474                 push    ebp
.text$mn:00005475                 mov     ebp, esp
.text$mn:00005477                 push    ecx
.text$mn:00005478                 mov     [ebp+var_4], ecx
.text$mn:0000547B                 mov     eax, [ebp+arg_4]
.text$mn:0000547E                 push    eax             ; int
.text$mn:0000547F                 mov     ecx, [ebp+arg_0]
.text$mn:00005482                 push    ecx             ; void *
.text$mn:00005483                 mov     ecx, [ebp+var_4]
.text$mn:00005486                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:0000548B                 mov     esp, ebp
.text$mn:0000548D                 pop     ebp
.text$mn:0000548E                 retn    8
.text$mn:0000548E ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:0000548E
.text$mn:0000548E ; ---------------------------------------------------------------------------
.text$mn:00005491                 align 4
.text$mn:00005491 _text$mn        ends
.text$mn:00005491
.text$mn:00005494 ; ===========================================================================
.text$mn:00005494
.text$mn:00005494 ; Segment type: Pure code
.text$mn:00005494 ; Segment permissions: Read/Execute
.text$mn:00005494 _text$mn        segment para public 'CODE' use32
.text$mn:00005494                 assume cs:_text$mn
.text$mn:00005494                 ;org 5494h
.text$mn:00005494 ; COMDAT (pick any)
.text$mn:00005494                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005494
.text$mn:00005494 ; =============== S U B R O U T I N E =======================================
.text$mn:00005494
.text$mn:00005494 ; Attributes: bp-based frame
.text$mn:00005494
.text$mn:00005494 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00005494                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00005494 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00005494                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00005494
.text$mn:00005494 var_4           = dword ptr -4
.text$mn:00005494 arg_0           = dword ptr  8
.text$mn:00005494
.text$mn:00005494                 push    ebp
.text$mn:00005495                 mov     ebp, esp
.text$mn:00005497                 push    ecx
.text$mn:00005498                 mov     [ebp+var_4], ecx
.text$mn:0000549B                 mov     eax, [ebp+arg_0]
.text$mn:0000549E                 push    eax             ; void *
.text$mn:0000549F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000054A4                 add     esp, 4
.text$mn:000054A7                 mov     esp, ebp
.text$mn:000054A9                 pop     ebp
.text$mn:000054AA                 retn    8
.text$mn:000054AA ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:000054AA
.text$mn:000054AA ; ---------------------------------------------------------------------------
.text$mn:000054AD                 align 10h
.text$mn:000054AD _text$mn        ends
.text$mn:000054AD
.text$mn:000054B0 ; ===========================================================================
.text$mn:000054B0
.text$mn:000054B0 ; Segment type: Pure code
.text$mn:000054B0 ; Segment permissions: Read/Execute
.text$mn:000054B0 _text$mn        segment para public 'CODE' use32
.text$mn:000054B0                 assume cs:_text$mn
.text$mn:000054B0                 ;org 54B0h
.text$mn:000054B0 ; COMDAT (pick any)
.text$mn:000054B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000054B0
.text$mn:000054B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054B0
.text$mn:000054B0 ; Attributes: bp-based frame
.text$mn:000054B0
.text$mn:000054B0 ; int __stdcall std::allocator<RecentItem *>::deallocate(void *, int)
.text$mn:000054B0                 public ?deallocate@?$allocator@PAURecentItem@@@std@@QAEXPAPAURecentItem@@I@Z
.text$mn:000054B0 ?deallocate@?$allocator@PAURecentItem@@@std@@QAEXPAPAURecentItem@@I@Z proc near
.text$mn:000054B0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<RecentItem *>>::deallocate(RecentItem * *,uint)+12p
.text$mn:000054B0
.text$mn:000054B0 var_4           = dword ptr -4
.text$mn:000054B0 arg_0           = dword ptr  8
.text$mn:000054B0
.text$mn:000054B0                 push    ebp
.text$mn:000054B1                 mov     ebp, esp
.text$mn:000054B3                 push    ecx
.text$mn:000054B4                 mov     [ebp+var_4], ecx
.text$mn:000054B7                 mov     eax, [ebp+arg_0]
.text$mn:000054BA                 push    eax             ; void *
.text$mn:000054BB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000054C0                 add     esp, 4
.text$mn:000054C3                 mov     esp, ebp
.text$mn:000054C5                 pop     ebp
.text$mn:000054C6                 retn    8
.text$mn:000054C6 ?deallocate@?$allocator@PAURecentItem@@@std@@QAEXPAPAURecentItem@@I@Z endp
.text$mn:000054C6
.text$mn:000054C6 ; ---------------------------------------------------------------------------
.text$mn:000054C9                 align 4
.text$mn:000054C9 _text$mn        ends
.text$mn:000054C9
.text$mn:000054CC ; ===========================================================================
.text$mn:000054CC
.text$mn:000054CC ; Segment type: Pure code
.text$mn:000054CC ; Segment permissions: Read/Execute
.text$mn:000054CC _text$mn        segment para public 'CODE' use32
.text$mn:000054CC                 assume cs:_text$mn
.text$mn:000054CC                 ;org 54CCh
.text$mn:000054CC ; COMDAT (pick any)
.text$mn:000054CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000054CC
.text$mn:000054CC ; =============== S U B R O U T I N E =======================================
.text$mn:000054CC
.text$mn:000054CC ; Attributes: bp-based frame
.text$mn:000054CC
.text$mn:000054CC ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:000054CC                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:000054CC ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:000054CC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:000054CC                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p
.text$mn:000054CC
.text$mn:000054CC var_4           = dword ptr -4
.text$mn:000054CC arg_0           = dword ptr  8
.text$mn:000054CC
.text$mn:000054CC                 push    ebp
.text$mn:000054CD                 mov     ebp, esp
.text$mn:000054CF                 push    ecx
.text$mn:000054D0                 mov     [ebp+var_4], ecx
.text$mn:000054D3                 mov     eax, [ebp+arg_0]
.text$mn:000054D6                 push    eax             ; void *
.text$mn:000054D7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000054DC                 add     esp, 4
.text$mn:000054DF                 mov     esp, ebp
.text$mn:000054E1                 pop     ebp
.text$mn:000054E2                 retn    8
.text$mn:000054E2 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:000054E2
.text$mn:000054E2 ; ---------------------------------------------------------------------------
.text$mn:000054E5                 align 4
.text$mn:000054E5 _text$mn        ends
.text$mn:000054E5
.text$mn:000054E8 ; ===========================================================================
.text$mn:000054E8
.text$mn:000054E8 ; Segment type: Pure code
.text$mn:000054E8 ; Segment permissions: Read/Execute
.text$mn:000054E8 _text$mn        segment para public 'CODE' use32
.text$mn:000054E8                 assume cs:_text$mn
.text$mn:000054E8                 ;org 54E8h
.text$mn:000054E8 ; COMDAT (pick any)
.text$mn:000054E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000054E8
.text$mn:000054E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000054E8
.text$mn:000054E8 ; Attributes: bp-based frame
.text$mn:000054E8
.text$mn:000054E8 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:000054E8                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:000054E8 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:000054E8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:000054E8
.text$mn:000054E8 var_4           = dword ptr -4
.text$mn:000054E8 arg_0           = dword ptr  8
.text$mn:000054E8
.text$mn:000054E8                 push    ebp
.text$mn:000054E9                 mov     ebp, esp
.text$mn:000054EB                 push    ecx
.text$mn:000054EC                 mov     [ebp+var_4], ecx
.text$mn:000054EF                 mov     eax, [ebp+arg_0]
.text$mn:000054F2                 push    eax             ; void *
.text$mn:000054F3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000054F8                 add     esp, 4
.text$mn:000054FB                 mov     esp, ebp
.text$mn:000054FD                 pop     ebp
.text$mn:000054FE                 retn    8
.text$mn:000054FE ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:000054FE
.text$mn:000054FE ; ---------------------------------------------------------------------------
.text$mn:00005501                 align 4
.text$mn:00005501 _text$mn        ends
.text$mn:00005501
.text$mn:00005504 ; ===========================================================================
.text$mn:00005504
.text$mn:00005504 ; Segment type: Pure code
.text$mn:00005504 ; Segment permissions: Read/Execute
.text$mn:00005504 _text$mn        segment para public 'CODE' use32
.text$mn:00005504                 assume cs:_text$mn
.text$mn:00005504                 ;org 5504h
.text$mn:00005504 ; COMDAT (pick any)
.text$mn:00005504                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005504
.text$mn:00005504 ; =============== S U B R O U T I N E =======================================
.text$mn:00005504
.text$mn:00005504 ; Attributes: bp-based frame
.text$mn:00005504
.text$mn:00005504 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00005504                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00005504 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00005504                                         ; DATA XREF: .rdata:000076D4o
.text$mn:00005504
.text$mn:00005504 var_4           = dword ptr -4
.text$mn:00005504 arg_0           = dword ptr  8
.text$mn:00005504 arg_4           = dword ptr  0Ch
.text$mn:00005504
.text$mn:00005504                 push    ebp
.text$mn:00005505                 mov     ebp, esp
.text$mn:00005507                 push    ecx
.text$mn:00005508                 mov     [ebp+var_4], ecx
.text$mn:0000550B                 mov     eax, [ebp+arg_4]
.text$mn:0000550E                 push    eax             ; int
.text$mn:0000550F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00005514                 add     esp, 4
.text$mn:00005517                 test    eax, eax
.text$mn:00005519                 jz      short loc_5534
.text$mn:0000551B                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00005520                 push    eax             ; struct std::error_category *
.text$mn:00005521                 mov     ecx, [ebp+arg_4]
.text$mn:00005524                 push    ecx             ; int
.text$mn:00005525                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005528                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000552D                 mov     eax, [ebp+arg_0]
.text$mn:00005530                 jmp     short loc_5549
.text$mn:00005532 ; ---------------------------------------------------------------------------
.text$mn:00005532                 jmp     short loc_5549
.text$mn:00005534 ; ---------------------------------------------------------------------------
.text$mn:00005534
.text$mn:00005534 loc_5534:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00005534                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00005539                 push    eax             ; struct std::error_category *
.text$mn:0000553A                 mov     edx, [ebp+arg_4]
.text$mn:0000553D                 push    edx             ; int
.text$mn:0000553E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005541                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00005546                 mov     eax, [ebp+arg_0]
.text$mn:00005549
.text$mn:00005549 loc_5549:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00005549                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00005549                 mov     esp, ebp
.text$mn:0000554B                 pop     ebp
.text$mn:0000554C                 retn    8
.text$mn:0000554C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000554C
.text$mn:0000554C ; ---------------------------------------------------------------------------
.text$mn:0000554F                 align 10h
.text$mn:0000554F _text$mn        ends
.text$mn:0000554F
.text$mn:00005550 ; ===========================================================================
.text$mn:00005550
.text$mn:00005550 ; Segment type: Pure code
.text$mn:00005550 ; Segment permissions: Read/Execute
.text$mn:00005550 _text$mn        segment para public 'CODE' use32
.text$mn:00005550                 assume cs:_text$mn
.text$mn:00005550                 ;org 5550h
.text$mn:00005550 ; COMDAT (pick any)
.text$mn:00005550                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005550
.text$mn:00005550 ; =============== S U B R O U T I N E =======================================
.text$mn:00005550
.text$mn:00005550 ; Attributes: bp-based frame
.text$mn:00005550
.text$mn:00005550 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00005550                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00005550 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00005550                                         ; DATA XREF: .rdata:00007644o
.text$mn:00005550                                         ; .rdata:00007660o ...
.text$mn:00005550
.text$mn:00005550 var_4           = dword ptr -4
.text$mn:00005550 arg_0           = dword ptr  8
.text$mn:00005550 arg_4           = dword ptr  0Ch
.text$mn:00005550
.text$mn:00005550                 push    ebp
.text$mn:00005551                 mov     ebp, esp
.text$mn:00005553                 push    ecx
.text$mn:00005554                 mov     [ebp+var_4], ecx
.text$mn:00005557                 mov     eax, [ebp+var_4]
.text$mn:0000555A                 push    eax             ; struct std::error_category *
.text$mn:0000555B                 mov     ecx, [ebp+arg_4]
.text$mn:0000555E                 push    ecx             ; int
.text$mn:0000555F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005562                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00005567                 mov     eax, [ebp+arg_0]
.text$mn:0000556A                 mov     esp, ebp
.text$mn:0000556C                 pop     ebp
.text$mn:0000556D                 retn    8
.text$mn:0000556D ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000556D
.text$mn:0000556D _text$mn        ends
.text$mn:0000556D
.text$mn:00005570 ; ===========================================================================
.text$mn:00005570
.text$mn:00005570 ; Segment type: Pure code
.text$mn:00005570 ; Segment permissions: Read/Execute
.text$mn:00005570 _text$mn        segment para public 'CODE' use32
.text$mn:00005570                 assume cs:_text$mn
.text$mn:00005570                 ;org 5570h
.text$mn:00005570 ; COMDAT (pick any)
.text$mn:00005570                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005570
.text$mn:00005570 ; =============== S U B R O U T I N E =======================================
.text$mn:00005570
.text$mn:00005570 ; Attributes: bp-based frame
.text$mn:00005570
.text$mn:00005570 ; public: bool __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::empty(void)const
.text$mn:00005570                 public ?empty@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE_NXZ
.text$mn:00005570 ?empty@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE_NXZ proc near
.text$mn:00005570                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::pop_back(void)+Dp
.text$mn:00005570                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::pop_front(void)+Dp
.text$mn:00005570
.text$mn:00005570 var_8           = dword ptr -8
.text$mn:00005570 var_4           = dword ptr -4
.text$mn:00005570
.text$mn:00005570                 push    ebp
.text$mn:00005571                 mov     ebp, esp
.text$mn:00005573                 sub     esp, 8
.text$mn:00005576                 mov     [ebp+var_8], ecx
.text$mn:00005579                 mov     eax, [ebp+var_8]
.text$mn:0000557C                 cmp     dword ptr [eax+10h], 0
.text$mn:00005580                 jnz     short loc_558B
.text$mn:00005582                 mov     [ebp+var_4], 1
.text$mn:00005589                 jmp     short loc_5592
.text$mn:0000558B ; ---------------------------------------------------------------------------
.text$mn:0000558B
.text$mn:0000558B loc_558B:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::empty(void)+10j
.text$mn:0000558B                 mov     [ebp+var_4], 0
.text$mn:00005592
.text$mn:00005592 loc_5592:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::empty(void)+19j
.text$mn:00005592                 mov     al, byte ptr [ebp+var_4]
.text$mn:00005595                 mov     esp, ebp
.text$mn:00005597                 pop     ebp
.text$mn:00005598                 retn
.text$mn:00005598 ?empty@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE_NXZ endp
.text$mn:00005598
.text$mn:00005598 ; ---------------------------------------------------------------------------
.text$mn:00005599                 align 4
.text$mn:00005599 _text$mn        ends
.text$mn:00005599
.text$mn:0000559C ; ===========================================================================
.text$mn:0000559C
.text$mn:0000559C ; Segment type: Pure code
.text$mn:0000559C ; Segment permissions: Read/Execute
.text$mn:0000559C _text$mn        segment para public 'CODE' use32
.text$mn:0000559C                 assume cs:_text$mn
.text$mn:0000559C                 ;org 559Ch
.text$mn:0000559C ; COMDAT (pick any)
.text$mn:0000559C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000559C
.text$mn:0000559C ; =============== S U B R O U T I N E =======================================
.text$mn:0000559C
.text$mn:0000559C ; Attributes: bp-based frame
.text$mn:0000559C
.text$mn:0000559C ; public: class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::end(void)
.text$mn:0000559C                 public ?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ
.text$mn:0000559C ?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ proc near
.text$mn:0000559C                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::back(void)+35p
.text$mn:0000559C                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+11Ep ...
.text$mn:0000559C
.text$mn:0000559C var_14          = dword ptr -14h
.text$mn:0000559C var_10          = dword ptr -10h
.text$mn:0000559C var_C           = dword ptr -0Ch
.text$mn:0000559C var_4           = dword ptr -4
.text$mn:0000559C arg_0           = dword ptr  8
.text$mn:0000559C
.text$mn:0000559C                 push    ebp
.text$mn:0000559D                 mov     ebp, esp
.text$mn:0000559F                 push    0FFFFFFFFh
.text$mn:000055A1                 push    offset __ehhandler$?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ
.text$mn:000055A6                 mov     eax, large fs:0
.text$mn:000055AC                 push    eax
.text$mn:000055AD                 sub     esp, 8
.text$mn:000055B0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000055B5                 xor     eax, ebp
.text$mn:000055B7                 push    eax
.text$mn:000055B8                 lea     eax, [ebp+var_C]
.text$mn:000055BB                 mov     large fs:0, eax
.text$mn:000055C1                 mov     [ebp+var_10], ecx
.text$mn:000055C4                 mov     [ebp+var_14], 0
.text$mn:000055CB                 mov     eax, [ebp+var_10]
.text$mn:000055CE                 push    eax             ; struct std::_Container_base12 *
.text$mn:000055CF                 mov     ecx, [ebp+var_10]
.text$mn:000055D2                 mov     edx, [ecx+0Ch]
.text$mn:000055D5                 mov     eax, [ebp+var_10]
.text$mn:000055D8                 add     edx, [eax+10h]
.text$mn:000055DB                 push    edx             ; int
.text$mn:000055DC                 mov     ecx, [ebp+arg_0]
.text$mn:000055DF                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(uint,std::_Container_base12 const *)
.text$mn:000055E4                 mov     [ebp+var_4], 0
.text$mn:000055EB                 mov     ecx, [ebp+var_14]
.text$mn:000055EE                 or      ecx, 1
.text$mn:000055F1                 mov     [ebp+var_14], ecx
.text$mn:000055F4                 mov     eax, [ebp+arg_0]
.text$mn:000055F7                 mov     ecx, [ebp+var_C]
.text$mn:000055FA                 mov     large fs:0, ecx
.text$mn:00005601                 pop     ecx
.text$mn:00005602                 mov     esp, ebp
.text$mn:00005604                 pop     ebp
.text$mn:00005605                 retn    4
.text$mn:00005605 ?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ endp
.text$mn:00005605
.text$mn:00005605 _text$mn        ends
.text$mn:00005605
.text$x:00005608 ; ===========================================================================
.text$x:00005608
.text$x:00005608 ; Segment type: Pure code
.text$x:00005608 ; Segment permissions: Read/Execute
.text$x:00005608 _text$x         segment para public 'CODE' use32
.text$x:00005608                 assume cs:_text$x
.text$x:00005608                 ;org 5608h
.text$x:00005608 ; COMDAT (pick associative to section at 559C)
.text$x:00005608                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005608
.text$x:00005608 ; =============== S U B R O U T I N E =======================================
.text$x:00005608
.text$x:00005608
.text$x:00005608 __unwindfunclet$?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ$0 proc near
.text$x:00005608                                         ; DATA XREF: .xdata$x:00006F94o
.text$x:00005608                 mov     eax, [ebp-14h]
.text$x:0000560B                 and     eax, 1
.text$x:0000560E                 jz      $LN4_0
.text$x:00005614                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00005618                 mov     ecx, [ebp+8]
.text$x:0000561B                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005620 ; ---------------------------------------------------------------------------
.text$x:00005620
.text$x:00005620 $LN4_0:                                 ; CODE XREF: __unwindfunclet$?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ$0+6j
.text$x:00005620                 retn
.text$x:00005620 __unwindfunclet$?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ$0 endp
.text$x:00005620
.text$x:00005621
.text$x:00005621 ; =============== S U B R O U T I N E =======================================
.text$x:00005621
.text$x:00005621
.text$x:00005621 __ehhandler$?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ proc near
.text$x:00005621                                         ; DATA XREF: std::deque<RecentItem,std::allocator<RecentItem>>::end(void)+5o
.text$x:00005621
.text$x:00005621 arg_4           = dword ptr  8
.text$x:00005621
.text$x:00005621                 mov     edx, [esp+arg_4]
.text$x:00005625                 lea     eax, [edx+0Ch]
.text$x:00005628                 mov     ecx, [edx-0Ch]
.text$x:0000562B                 xor     ecx, eax
.text$x:0000562D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005632                 mov     eax, offset __ehfuncinfo$?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ
.text$x:00005637                 jmp     ___CxxFrameHandler3
.text$x:00005637 __ehhandler$?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ endp
.text$x:00005637
.text$x:00005637 _text$x         ends
.text$x:00005637
.text$mn:0000563C ; ===========================================================================
.text$mn:0000563C
.text$mn:0000563C ; Segment type: Pure code
.text$mn:0000563C ; Segment permissions: Read/Execute
.text$mn:0000563C _text$mn        segment para public 'CODE' use32
.text$mn:0000563C                 assume cs:_text$mn
.text$mn:0000563C                 ;org 563Ch
.text$mn:0000563C ; COMDAT (pick any)
.text$mn:0000563C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000563C
.text$mn:0000563C ; =============== S U B R O U T I N E =======================================
.text$mn:0000563C
.text$mn:0000563C ; Attributes: bp-based frame
.text$mn:0000563C
.text$mn:0000563C ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:0000563C                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:0000563C ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:0000563C                                         ; DATA XREF: .rdata:00007648o
.text$mn:0000563C                                         ; .rdata:00007664o ...
.text$mn:0000563C
.text$mn:0000563C var_8           = dword ptr -8
.text$mn:0000563C var_4           = dword ptr -4
.text$mn:0000563C arg_0           = dword ptr  8
.text$mn:0000563C arg_4           = dword ptr  0Ch
.text$mn:0000563C
.text$mn:0000563C                 push    ebp
.text$mn:0000563D                 mov     ebp, esp
.text$mn:0000563F                 sub     esp, 8
.text$mn:00005642                 mov     [ebp+var_8], ecx
.text$mn:00005645                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005648                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:0000564D                 push    eax
.text$mn:0000564E                 mov     ecx, [ebp+var_8]
.text$mn:00005651                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00005656                 movzx   eax, al
.text$mn:00005659                 test    eax, eax
.text$mn:0000565B                 jz      short loc_5673
.text$mn:0000565D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005660                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00005665                 cmp     eax, [ebp+arg_4]
.text$mn:00005668                 jnz     short loc_5673
.text$mn:0000566A                 mov     [ebp+var_4], 1
.text$mn:00005671                 jmp     short loc_567A
.text$mn:00005673 ; ---------------------------------------------------------------------------
.text$mn:00005673
.text$mn:00005673 loc_5673:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00005673                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00005673                 mov     [ebp+var_4], 0
.text$mn:0000567A
.text$mn:0000567A loc_567A:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:0000567A                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000567D                 mov     esp, ebp
.text$mn:0000567F                 pop     ebp
.text$mn:00005680                 retn    8
.text$mn:00005680 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00005680
.text$mn:00005680 ; ---------------------------------------------------------------------------
.text$mn:00005683                 align 4
.text$mn:00005683 _text$mn        ends
.text$mn:00005683
.text$mn:00005684 ; ===========================================================================
.text$mn:00005684
.text$mn:00005684 ; Segment type: Pure code
.text$mn:00005684 ; Segment permissions: Read/Execute
.text$mn:00005684 _text$mn        segment para public 'CODE' use32
.text$mn:00005684                 assume cs:_text$mn
.text$mn:00005684                 ;org 5684h
.text$mn:00005684 ; COMDAT (pick any)
.text$mn:00005684                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005684
.text$mn:00005684 ; =============== S U B R O U T I N E =======================================
.text$mn:00005684
.text$mn:00005684 ; Attributes: bp-based frame
.text$mn:00005684
.text$mn:00005684 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00005684                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00005684 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00005684                                         ; DATA XREF: .rdata:0000764Co
.text$mn:00005684                                         ; .rdata:00007668o ...
.text$mn:00005684
.text$mn:00005684 var_C           = byte ptr -0Ch
.text$mn:00005684 var_4           = dword ptr -4
.text$mn:00005684 arg_0           = dword ptr  8
.text$mn:00005684 arg_4           = dword ptr  0Ch
.text$mn:00005684
.text$mn:00005684                 push    ebp
.text$mn:00005685                 mov     ebp, esp
.text$mn:00005687                 sub     esp, 0Ch
.text$mn:0000568A                 mov     [ebp+var_4], ecx
.text$mn:0000568D                 mov     eax, [ebp+arg_4]
.text$mn:00005690                 push    eax             ; std::error_condition *
.text$mn:00005691                 mov     ecx, [ebp+arg_0]
.text$mn:00005694                 push    ecx
.text$mn:00005695                 lea     edx, [ebp+var_C]
.text$mn:00005698                 push    edx
.text$mn:00005699                 mov     eax, [ebp+var_4]
.text$mn:0000569C                 mov     edx, [eax]
.text$mn:0000569E                 mov     ecx, [ebp+var_4]
.text$mn:000056A1                 mov     eax, [edx+0Ch]
.text$mn:000056A4                 call    eax
.text$mn:000056A6                 mov     ecx, eax
.text$mn:000056A8                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:000056AD                 mov     esp, ebp
.text$mn:000056AF                 pop     ebp
.text$mn:000056B0                 retn    8
.text$mn:000056B0 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:000056B0
.text$mn:000056B0 ; ---------------------------------------------------------------------------
.text$mn:000056B3                 align 4
.text$mn:000056B3 _text$mn        ends
.text$mn:000056B3
.text$mn:000056B4 ; ===========================================================================
.text$mn:000056B4
.text$mn:000056B4 ; Segment type: Pure code
.text$mn:000056B4 ; Segment permissions: Read/Execute
.text$mn:000056B4 _text$mn        segment para public 'CODE' use32
.text$mn:000056B4                 assume cs:_text$mn
.text$mn:000056B4                 ;org 56B4h
.text$mn:000056B4 ; COMDAT (pick any)
.text$mn:000056B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000056B4
.text$mn:000056B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000056B4
.text$mn:000056B4 ; Attributes: bp-based frame
.text$mn:000056B4
.text$mn:000056B4 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:000056B4                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:000056B4 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000056B4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:000056B4
.text$mn:000056B4 var_4           = dword ptr -4
.text$mn:000056B4 arg_0           = dword ptr  8
.text$mn:000056B4
.text$mn:000056B4                 push    ebp
.text$mn:000056B5                 mov     ebp, esp
.text$mn:000056B7                 push    ecx
.text$mn:000056B8                 mov     [ebp+var_4], ecx
.text$mn:000056BB                 mov     eax, [ebp+var_4]
.text$mn:000056BE                 mov     ecx, [eax+14h]
.text$mn:000056C1                 cmp     ecx, [ebp+arg_0]
.text$mn:000056C4                 jnb     short loc_56CE
.text$mn:000056C6                 mov     ecx, [ebp+var_4]
.text$mn:000056C9                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000056CE
.text$mn:000056CE loc_56CE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:000056CE                 mov     edx, [ebp+arg_0]
.text$mn:000056D1                 push    edx
.text$mn:000056D2                 mov     ecx, [ebp+var_4]
.text$mn:000056D5                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000056DA                 mov     eax, [ebp+var_4]
.text$mn:000056DD                 mov     esp, ebp
.text$mn:000056DF                 pop     ebp
.text$mn:000056E0                 retn    4
.text$mn:000056E0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:000056E0
.text$mn:000056E0 ; ---------------------------------------------------------------------------
.text$mn:000056E3                 align 4
.text$mn:000056E3 _text$mn        ends
.text$mn:000056E3
.text$mn:000056E4 ; ===========================================================================
.text$mn:000056E4
.text$mn:000056E4 ; Segment type: Pure code
.text$mn:000056E4 ; Segment permissions: Read/Execute
.text$mn:000056E4 _text$mn        segment para public 'CODE' use32
.text$mn:000056E4                 assume cs:_text$mn
.text$mn:000056E4                 ;org 56E4h
.text$mn:000056E4 ; COMDAT (pick any)
.text$mn:000056E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000056E4
.text$mn:000056E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000056E4
.text$mn:000056E4 ; Attributes: bp-based frame
.text$mn:000056E4
.text$mn:000056E4 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:000056E4                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:000056E4 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:000056E4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:000056E4
.text$mn:000056E4 var_C           = dword ptr -0Ch
.text$mn:000056E4 Dst             = dword ptr -8
.text$mn:000056E4 var_4           = dword ptr -4
.text$mn:000056E4 arg_0           = dword ptr  8
.text$mn:000056E4 arg_4           = dword ptr  0Ch
.text$mn:000056E4
.text$mn:000056E4                 push    ebp
.text$mn:000056E5                 mov     ebp, esp
.text$mn:000056E7                 sub     esp, 0Ch
.text$mn:000056EA                 mov     [ebp+var_4], ecx
.text$mn:000056ED                 mov     eax, [ebp+var_4]
.text$mn:000056F0                 mov     ecx, [eax+14h]
.text$mn:000056F3                 cmp     ecx, [ebp+arg_0]
.text$mn:000056F6                 jnb     short loc_5700
.text$mn:000056F8                 mov     ecx, [ebp+var_4]
.text$mn:000056FB                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00005700
.text$mn:00005700 loc_5700:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00005700                 mov     edx, [ebp+var_4]
.text$mn:00005703                 mov     eax, [edx+14h]
.text$mn:00005706                 sub     eax, [ebp+arg_0]
.text$mn:00005709                 cmp     eax, [ebp+arg_4]
.text$mn:0000570C                 ja      short loc_571C
.text$mn:0000570E                 mov     ecx, [ebp+arg_0]
.text$mn:00005711                 push    ecx
.text$mn:00005712                 mov     ecx, [ebp+var_4]
.text$mn:00005715                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000571A                 jmp     short loc_5762
.text$mn:0000571C ; ---------------------------------------------------------------------------
.text$mn:0000571C
.text$mn:0000571C loc_571C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:0000571C                 cmp     [ebp+arg_4], 0
.text$mn:00005720                 jbe     short loc_5762
.text$mn:00005722                 mov     ecx, [ebp+var_4]
.text$mn:00005725                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000572A                 add     eax, [ebp+arg_0]
.text$mn:0000572D                 mov     [ebp+Dst], eax
.text$mn:00005730                 mov     edx, [ebp+var_4]
.text$mn:00005733                 mov     eax, [edx+14h]
.text$mn:00005736                 sub     eax, [ebp+arg_4]
.text$mn:00005739                 mov     [ebp+var_C], eax
.text$mn:0000573C                 mov     ecx, [ebp+var_C]
.text$mn:0000573F                 sub     ecx, [ebp+arg_0]
.text$mn:00005742                 push    ecx             ; Size
.text$mn:00005743                 mov     edx, [ebp+Dst]
.text$mn:00005746                 add     edx, [ebp+arg_4]
.text$mn:00005749                 push    edx             ; Src
.text$mn:0000574A                 mov     eax, [ebp+Dst]
.text$mn:0000574D                 push    eax             ; Dst
.text$mn:0000574E                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00005753                 add     esp, 0Ch
.text$mn:00005756                 mov     ecx, [ebp+var_C]
.text$mn:00005759                 push    ecx
.text$mn:0000575A                 mov     ecx, [ebp+var_4]
.text$mn:0000575D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00005762
.text$mn:00005762 loc_5762:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00005762                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00005762                 mov     eax, [ebp+var_4]
.text$mn:00005765                 mov     esp, ebp
.text$mn:00005767                 pop     ebp
.text$mn:00005768                 retn    8
.text$mn:00005768 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00005768
.text$mn:00005768 ; ---------------------------------------------------------------------------
.text$mn:0000576B                 align 4
.text$mn:0000576B _text$mn        ends
.text$mn:0000576B
.text$mn:0000576C ; ===========================================================================
.text$mn:0000576C
.text$mn:0000576C ; Segment type: Pure code
.text$mn:0000576C ; Segment permissions: Read/Execute
.text$mn:0000576C _text$mn        segment para public 'CODE' use32
.text$mn:0000576C                 assume cs:_text$mn
.text$mn:0000576C                 ;org 576Ch
.text$mn:0000576C ; COMDAT (pick any)
.text$mn:0000576C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000576C
.text$mn:0000576C ; =============== S U B R O U T I N E =======================================
.text$mn:0000576C
.text$mn:0000576C ; Attributes: bp-based frame
.text$mn:0000576C
.text$mn:0000576C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:0000576C                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:0000576C ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000576C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:0000576C
.text$mn:0000576C var_4           = dword ptr -4
.text$mn:0000576C arg_0           = dword ptr  8
.text$mn:0000576C
.text$mn:0000576C                 push    ebp
.text$mn:0000576D                 mov     ebp, esp
.text$mn:0000576F                 push    ecx
.text$mn:00005770                 mov     [ebp+var_4], ecx
.text$mn:00005773                 mov     eax, [ebp+var_4]
.text$mn:00005776                 mov     ecx, [eax+14h]
.text$mn:00005779                 cmp     ecx, [ebp+arg_0]
.text$mn:0000577C                 jnb     short loc_5786
.text$mn:0000577E                 mov     ecx, [ebp+var_4]
.text$mn:00005781                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00005786
.text$mn:00005786 loc_5786:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:00005786                 mov     edx, [ebp+arg_0]
.text$mn:00005789                 push    edx
.text$mn:0000578A                 mov     ecx, [ebp+var_4]
.text$mn:0000578D                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00005792                 mov     eax, [ebp+var_4]
.text$mn:00005795                 mov     esp, ebp
.text$mn:00005797                 pop     ebp
.text$mn:00005798                 retn    4
.text$mn:00005798 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:00005798
.text$mn:00005798 ; ---------------------------------------------------------------------------
.text$mn:0000579B                 align 4
.text$mn:0000579B _text$mn        ends
.text$mn:0000579B
.text$mn:0000579C ; ===========================================================================
.text$mn:0000579C
.text$mn:0000579C ; Segment type: Pure code
.text$mn:0000579C ; Segment permissions: Read/Execute
.text$mn:0000579C _text$mn        segment para public 'CODE' use32
.text$mn:0000579C                 assume cs:_text$mn
.text$mn:0000579C                 ;org 579Ch
.text$mn:0000579C ; COMDAT (pick any)
.text$mn:0000579C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000579C
.text$mn:0000579C ; =============== S U B R O U T I N E =======================================
.text$mn:0000579C
.text$mn:0000579C ; Attributes: bp-based frame
.text$mn:0000579C
.text$mn:0000579C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:0000579C                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:0000579C ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000579C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:0000579C
.text$mn:0000579C var_C           = dword ptr -0Ch
.text$mn:0000579C Dst             = dword ptr -8
.text$mn:0000579C var_4           = dword ptr -4
.text$mn:0000579C arg_0           = dword ptr  8
.text$mn:0000579C arg_4           = dword ptr  0Ch
.text$mn:0000579C
.text$mn:0000579C                 push    ebp
.text$mn:0000579D                 mov     ebp, esp
.text$mn:0000579F                 sub     esp, 0Ch
.text$mn:000057A2                 mov     [ebp+var_4], ecx
.text$mn:000057A5                 mov     eax, [ebp+var_4]
.text$mn:000057A8                 mov     ecx, [eax+14h]
.text$mn:000057AB                 cmp     ecx, [ebp+arg_0]
.text$mn:000057AE                 jnb     short loc_57B8
.text$mn:000057B0                 mov     ecx, [ebp+var_4]
.text$mn:000057B3                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:000057B8
.text$mn:000057B8 loc_57B8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:000057B8                 mov     edx, [ebp+var_4]
.text$mn:000057BB                 mov     eax, [edx+14h]
.text$mn:000057BE                 sub     eax, [ebp+arg_0]
.text$mn:000057C1                 cmp     eax, [ebp+arg_4]
.text$mn:000057C4                 ja      short loc_57D4
.text$mn:000057C6                 mov     ecx, [ebp+arg_0]
.text$mn:000057C9                 push    ecx
.text$mn:000057CA                 mov     ecx, [ebp+var_4]
.text$mn:000057CD                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000057D2                 jmp     short loc_5820
.text$mn:000057D4 ; ---------------------------------------------------------------------------
.text$mn:000057D4
.text$mn:000057D4 loc_57D4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:000057D4                 cmp     [ebp+arg_4], 0
.text$mn:000057D8                 jbe     short loc_5820
.text$mn:000057DA                 mov     ecx, [ebp+var_4]
.text$mn:000057DD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000057E2                 mov     edx, [ebp+arg_0]
.text$mn:000057E5                 lea     eax, [eax+edx*2]
.text$mn:000057E8                 mov     [ebp+Dst], eax
.text$mn:000057EB                 mov     ecx, [ebp+var_4]
.text$mn:000057EE                 mov     edx, [ecx+14h]
.text$mn:000057F1                 sub     edx, [ebp+arg_4]
.text$mn:000057F4                 mov     [ebp+var_C], edx
.text$mn:000057F7                 mov     eax, [ebp+var_C]
.text$mn:000057FA                 sub     eax, [ebp+arg_0]
.text$mn:000057FD                 push    eax             ; int
.text$mn:000057FE                 mov     ecx, [ebp+arg_4]
.text$mn:00005801                 mov     edx, [ebp+Dst]
.text$mn:00005804                 lea     eax, [edx+ecx*2]
.text$mn:00005807                 push    eax             ; Src
.text$mn:00005808                 mov     ecx, [ebp+Dst]
.text$mn:0000580B                 push    ecx             ; Dst
.text$mn:0000580C                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00005811                 add     esp, 0Ch
.text$mn:00005814                 mov     edx, [ebp+var_C]
.text$mn:00005817                 push    edx
.text$mn:00005818                 mov     ecx, [ebp+var_4]
.text$mn:0000581B                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00005820
.text$mn:00005820 loc_5820:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:00005820                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:00005820                 mov     eax, [ebp+var_4]
.text$mn:00005823                 mov     esp, ebp
.text$mn:00005825                 pop     ebp
.text$mn:00005826                 retn    8
.text$mn:00005826 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:00005826
.text$mn:00005826 ; ---------------------------------------------------------------------------
.text$mn:00005829                 align 4
.text$mn:00005829 _text$mn        ends
.text$mn:00005829
.text$mn:0000582C ; ===========================================================================
.text$mn:0000582C
.text$mn:0000582C ; Segment type: Pure code
.text$mn:0000582C ; Segment permissions: Read/Execute
.text$mn:0000582C _text$mn        segment para public 'CODE' use32
.text$mn:0000582C                 assume cs:_text$mn
.text$mn:0000582C                 ;org 582Ch
.text$mn:0000582C ; COMDAT (pick any)
.text$mn:0000582C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000582C
.text$mn:0000582C ; =============== S U B R O U T I N E =======================================
.text$mn:0000582C
.text$mn:0000582C ; Attributes: bp-based frame
.text$mn:0000582C
.text$mn:0000582C ; public: class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::erase(class std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>, class std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>)
.text$mn:0000582C                 public ?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z
.text$mn:0000582C ?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z proc near
.text$mn:0000582C                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+7Fp
.text$mn:0000582C
.text$mn:0000582C var_148         = byte ptr -148h
.text$mn:0000582C var_13C         = byte ptr -13Ch
.text$mn:0000582C var_130         = byte ptr -130h
.text$mn:0000582C var_124         = byte ptr -124h
.text$mn:0000582C var_118         = byte ptr -118h
.text$mn:0000582C var_10C         = byte ptr -10Ch
.text$mn:0000582C var_100         = byte ptr -100h
.text$mn:0000582C var_F4          = dword ptr -0F4h
.text$mn:0000582C var_F0          = dword ptr -0F0h
.text$mn:0000582C var_EC          = dword ptr -0ECh
.text$mn:0000582C var_E8          = dword ptr -0E8h
.text$mn:0000582C var_E4          = dword ptr -0E4h
.text$mn:0000582C var_E0          = dword ptr -0E0h
.text$mn:0000582C var_DC          = dword ptr -0DCh
.text$mn:0000582C var_D8          = dword ptr -0D8h
.text$mn:0000582C var_D4          = dword ptr -0D4h
.text$mn:0000582C var_D0          = dword ptr -0D0h
.text$mn:0000582C var_CC          = dword ptr -0CCh
.text$mn:0000582C var_C8          = dword ptr -0C8h
.text$mn:0000582C var_C4          = dword ptr -0C4h
.text$mn:0000582C var_C0          = dword ptr -0C0h
.text$mn:0000582C var_BC          = dword ptr -0BCh
.text$mn:0000582C var_B8          = dword ptr -0B8h
.text$mn:0000582C var_B4          = dword ptr -0B4h
.text$mn:0000582C var_B0          = dword ptr -0B0h
.text$mn:0000582C var_AC          = dword ptr -0ACh
.text$mn:0000582C var_A8          = dword ptr -0A8h
.text$mn:0000582C var_A4          = dword ptr -0A4h
.text$mn:0000582C var_A0          = dword ptr -0A0h
.text$mn:0000582C var_9C          = dword ptr -9Ch
.text$mn:0000582C var_98          = dword ptr -98h
.text$mn:0000582C var_94          = dword ptr -94h
.text$mn:0000582C var_90          = dword ptr -90h
.text$mn:0000582C var_8C          = dword ptr -8Ch
.text$mn:0000582C var_88          = dword ptr -88h
.text$mn:0000582C var_84          = dword ptr -84h
.text$mn:0000582C var_80          = dword ptr -80h
.text$mn:0000582C var_7C          = dword ptr -7Ch
.text$mn:0000582C var_78          = dword ptr -78h
.text$mn:0000582C var_74          = dword ptr -74h
.text$mn:0000582C var_70          = dword ptr -70h
.text$mn:0000582C var_6C          = dword ptr -6Ch
.text$mn:0000582C var_68          = dword ptr -68h
.text$mn:0000582C var_64          = dword ptr -64h
.text$mn:0000582C var_60          = dword ptr -60h
.text$mn:0000582C var_5C          = dword ptr -5Ch
.text$mn:0000582C var_58          = dword ptr -58h
.text$mn:0000582C var_54          = dword ptr -54h
.text$mn:0000582C var_50          = dword ptr -50h
.text$mn:0000582C var_4C          = dword ptr -4Ch
.text$mn:0000582C var_48          = dword ptr -48h
.text$mn:0000582C var_44          = dword ptr -44h
.text$mn:0000582C var_38          = dword ptr -38h
.text$mn:0000582C var_34          = byte ptr -34h
.text$mn:0000582C var_28          = dword ptr -28h
.text$mn:0000582C var_24          = dword ptr -24h
.text$mn:0000582C var_20          = dword ptr -20h
.text$mn:0000582C var_1B          = byte ptr -1Bh
.text$mn:0000582C var_1A          = byte ptr -1Ah
.text$mn:0000582C var_19          = byte ptr -19h
.text$mn:0000582C var_18          = dword ptr -18h
.text$mn:0000582C var_14          = dword ptr -14h
.text$mn:0000582C var_10          = dword ptr -10h
.text$mn:0000582C var_C           = dword ptr -0Ch
.text$mn:0000582C var_4           = dword ptr -4
.text$mn:0000582C arg_0           = dword ptr  8
.text$mn:0000582C arg_4           = byte ptr  0Ch
.text$mn:0000582C arg_10          = byte ptr  18h
.text$mn:0000582C
.text$mn:0000582C                 push    ebp
.text$mn:0000582D                 mov     ebp, esp
.text$mn:0000582F                 push    0FFFFFFFFh
.text$mn:00005831                 push    offset __ehhandler$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z
.text$mn:00005836                 mov     eax, large fs:0
.text$mn:0000583C                 push    eax
.text$mn:0000583D                 sub     esp, 13Ch
.text$mn:00005843                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005848                 xor     eax, ebp
.text$mn:0000584A                 push    eax
.text$mn:0000584B                 lea     eax, [ebp+var_C]
.text$mn:0000584E                 mov     large fs:0, eax
.text$mn:00005854                 mov     [ebp+var_10], ecx
.text$mn:00005857                 mov     [ebp+var_14], 0
.text$mn:0000585E                 mov     [ebp+var_4], 2
.text$mn:00005865                 sub     esp, 0Ch
.text$mn:00005868                 mov     ecx, esp
.text$mn:0000586A                 mov     [ebp+var_D0], esp
.text$mn:00005870                 lea     eax, [ebp+arg_4]
.text$mn:00005873                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005874                 call    ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00005879                 mov     [ebp+var_58], eax
.text$mn:0000587C                 mov     ecx, [ebp+var_58]
.text$mn:0000587F                 mov     [ebp+var_98], ecx
.text$mn:00005885                 mov     byte ptr [ebp+var_4], 3
.text$mn:00005889                 lea     edx, [ebp+var_34]
.text$mn:0000588C                 push    edx
.text$mn:0000588D                 mov     byte ptr [ebp+var_4], 2
.text$mn:00005891                 mov     ecx, [ebp+var_10]
.text$mn:00005894                 call    ?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::_Make_iter(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)
.text$mn:00005899                 mov     [ebp+var_D8], eax
.text$mn:0000589F                 mov     byte ptr [ebp+var_4], 4
.text$mn:000058A3                 sub     esp, 0Ch
.text$mn:000058A6                 mov     ecx, esp
.text$mn:000058A8                 mov     [ebp+var_EC], esp
.text$mn:000058AE                 lea     eax, [ebp+arg_10]
.text$mn:000058B1                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000058B2                 call    ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:000058B7                 mov     [ebp+var_8C], eax
.text$mn:000058BD                 mov     ecx, [ebp+var_8C]
.text$mn:000058C3                 mov     [ebp+var_A4], ecx
.text$mn:000058C9                 mov     byte ptr [ebp+var_4], 5
.text$mn:000058CD                 lea     edx, [ebp+var_44]
.text$mn:000058D0                 push    edx             ; int
.text$mn:000058D1                 mov     byte ptr [ebp+var_4], 4
.text$mn:000058D5                 mov     ecx, [ebp+var_10]
.text$mn:000058D8                 call    ?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::_Make_iter(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)
.text$mn:000058DD                 mov     [ebp+var_DC], eax
.text$mn:000058E3                 mov     byte ptr [ebp+var_4], 6
.text$mn:000058E7                 lea     eax, [ebp+var_34]
.text$mn:000058EA                 push    eax             ; std::_Iterator_base12 *
.text$mn:000058EB                 lea     ecx, [ebp+var_44]
.text$mn:000058EE                 call    ??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator<(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:000058F3                 movzx   ecx, al
.text$mn:000058F6                 test    ecx, ecx
.text$mn:000058F8                 jnz     loc_5986
.text$mn:000058FE                 lea     edx, [ebp+var_13C]
.text$mn:00005904                 push    edx
.text$mn:00005905                 mov     ecx, [ebp+var_10]
.text$mn:00005908                 call    ?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ ; std::deque<RecentItem,std::allocator<RecentItem>>::begin(void)
.text$mn:0000590D                 mov     [ebp+var_94], eax
.text$mn:00005913                 mov     eax, [ebp+var_94]
.text$mn:00005919                 mov     [ebp+var_50], eax
.text$mn:0000591C                 mov     byte ptr [ebp+var_4], 7
.text$mn:00005920                 mov     ecx, [ebp+var_14]
.text$mn:00005923                 or      ecx, 1
.text$mn:00005926                 mov     [ebp+var_14], ecx
.text$mn:00005929                 mov     edx, [ebp+var_50]
.text$mn:0000592C                 push    edx             ; std::_Iterator_base12 *
.text$mn:0000592D                 lea     ecx, [ebp+var_34]
.text$mn:00005930                 call    ??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator<(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00005935                 movzx   eax, al
.text$mn:00005938                 test    eax, eax
.text$mn:0000593A                 jnz     short loc_5986
.text$mn:0000593C                 lea     ecx, [ebp+var_44]
.text$mn:0000593F                 push    ecx             ; std::_Iterator_base12 *
.text$mn:00005940                 lea     edx, [ebp+var_100]
.text$mn:00005946                 push    edx
.text$mn:00005947                 mov     ecx, [ebp+var_10]
.text$mn:0000594A                 call    ?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ ; std::deque<RecentItem,std::allocator<RecentItem>>::end(void)
.text$mn:0000594F                 mov     [ebp+var_90], eax
.text$mn:00005955                 mov     eax, [ebp+var_90]
.text$mn:0000595B                 mov     [ebp+var_48], eax
.text$mn:0000595E                 mov     [ebp+var_4], 8
.text$mn:00005965                 mov     ecx, [ebp+var_14]
.text$mn:00005968                 or      ecx, 2
.text$mn:0000596B                 mov     [ebp+var_14], ecx
.text$mn:0000596E                 mov     ecx, [ebp+var_48]
.text$mn:00005971                 call    ??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator<(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00005976                 movzx   edx, al
.text$mn:00005979                 test    edx, edx
.text$mn:0000597B                 jnz     short loc_5986
.text$mn:0000597D                 mov     [ebp+var_24], 0
.text$mn:00005984                 jmp     short loc_598D
.text$mn:00005986 ; ---------------------------------------------------------------------------
.text$mn:00005986
.text$mn:00005986 loc_5986:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+CCj
.text$mn:00005986                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+10Ej ...
.text$mn:00005986                 mov     [ebp+var_24], 1
.text$mn:0000598D
.text$mn:0000598D loc_598D:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+158j
.text$mn:0000598D                 mov     al, byte ptr [ebp+var_24]
.text$mn:00005990                 mov     [ebp+var_1B], al
.text$mn:00005993                 mov     [ebp+var_4], 7
.text$mn:0000599A                 mov     ecx, [ebp+var_14]
.text$mn:0000599D                 and     ecx, 2
.text$mn:000059A0                 jz      short loc_59B1
.text$mn:000059A2                 and     [ebp+var_14], 0FFFFFFFDh
.text$mn:000059A6                 lea     ecx, [ebp+var_100]
.text$mn:000059AC                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:000059B1
.text$mn:000059B1 loc_59B1:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+174j
.text$mn:000059B1                 mov     [ebp+var_4], 6
.text$mn:000059B8                 mov     edx, [ebp+var_14]
.text$mn:000059BB                 and     edx, 1
.text$mn:000059BE                 jz      short loc_59CF
.text$mn:000059C0                 and     [ebp+var_14], 0FFFFFFFEh
.text$mn:000059C4                 lea     ecx, [ebp+var_13C]
.text$mn:000059CA                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:000059CF
.text$mn:000059CF loc_59CF:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+192j
.text$mn:000059CF                 movzx   eax, [ebp+var_1B]
.text$mn:000059D3                 test    eax, eax
.text$mn:000059D5                 jz      short loc_59EE
.text$mn:000059D7                 push    648h            ; unsigned int
.text$mn:000059DC                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000059E1                 push    offset ??_C@_1EG@IIKPBBHP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa?$AAn@ ; "deque erase iterator outside range"
.text$mn:000059E6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000059EB                 add     esp, 0Ch
.text$mn:000059EE
.text$mn:000059EE loc_59EE:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+1A9j
.text$mn:000059EE                 push    649h            ; unsigned int
.text$mn:000059F3                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000059F8                 sub     esp, 0Ch
.text$mn:000059FB                 mov     ecx, esp
.text$mn:000059FD                 mov     [ebp+var_AC], esp
.text$mn:00005A03                 lea     edx, [ebp+var_44]
.text$mn:00005A06                 push    edx             ; int
.text$mn:00005A07                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00005A0C                 mov     [ebp+var_78], eax
.text$mn:00005A0F                 mov     eax, [ebp+var_78]
.text$mn:00005A12                 mov     [ebp+var_F4], eax
.text$mn:00005A18                 mov     byte ptr [ebp+var_4], 9
.text$mn:00005A1C                 sub     esp, 0Ch
.text$mn:00005A1F                 mov     ecx, esp
.text$mn:00005A21                 mov     [ebp+var_B4], esp
.text$mn:00005A27                 lea     edx, [ebp+var_34]
.text$mn:00005A2A                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005A2B                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00005A30                 mov     [ebp+var_60], eax
.text$mn:00005A33                 mov     eax, [ebp+var_60]
.text$mn:00005A36                 mov     [ebp+var_F0], eax
.text$mn:00005A3C                 mov     byte ptr [ebp+var_4], 0Ah
.text$mn:00005A40                 mov     byte ptr [ebp+var_4], 6
.text$mn:00005A44                 call    ??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,wchar_t const *,uint)
.text$mn:00005A49                 add     esp, 20h
.text$mn:00005A4C                 lea     ecx, [ebp+var_124]
.text$mn:00005A52                 push    ecx
.text$mn:00005A53                 mov     ecx, [ebp+var_10]
.text$mn:00005A56                 call    ?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ ; std::deque<RecentItem,std::allocator<RecentItem>>::begin(void)
.text$mn:00005A5B                 mov     [ebp+var_88], eax
.text$mn:00005A61                 mov     edx, [ebp+var_88]
.text$mn:00005A67                 mov     [ebp+var_68], edx
.text$mn:00005A6A                 mov     byte ptr [ebp+var_4], 0Bh
.text$mn:00005A6E                 mov     eax, [ebp+var_68]
.text$mn:00005A71                 push    eax             ; std::_Iterator_base12 *
.text$mn:00005A72                 lea     ecx, [ebp+var_34]
.text$mn:00005A75                 call    ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator-(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00005A7A                 mov     [ebp+var_20], eax
.text$mn:00005A7D                 mov     byte ptr [ebp+var_4], 6
.text$mn:00005A81                 lea     ecx, [ebp+var_124]
.text$mn:00005A87                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00005A8C                 lea     ecx, [ebp+var_34]
.text$mn:00005A8F                 push    ecx             ; std::_Iterator_base12 *
.text$mn:00005A90                 lea     ecx, [ebp+var_44]
.text$mn:00005A93                 call    ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator-(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00005A98                 mov     [ebp+var_18], eax
.text$mn:00005A9B                 cmp     [ebp+var_20], 0
.text$mn:00005A9F                 jbe     short loc_5AB8
.text$mn:00005AA1                 mov     edx, [ebp+var_20]
.text$mn:00005AA4                 add     edx, [ebp+var_18]
.text$mn:00005AA7                 mov     eax, [ebp+var_10]
.text$mn:00005AAA                 cmp     edx, [eax+10h]
.text$mn:00005AAD                 jnb     short loc_5AB8
.text$mn:00005AAF                 mov     [ebp+var_38], 1
.text$mn:00005AB6                 jmp     short loc_5ABF
.text$mn:00005AB8 ; ---------------------------------------------------------------------------
.text$mn:00005AB8
.text$mn:00005AB8 loc_5AB8:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+273j
.text$mn:00005AB8                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+281j
.text$mn:00005AB8                 mov     [ebp+var_38], 0
.text$mn:00005ABF
.text$mn:00005ABF loc_5ABF:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+28Aj
.text$mn:00005ABF                 mov     cl, byte ptr [ebp+var_38]
.text$mn:00005AC2                 mov     [ebp+var_19], cl
.text$mn:00005AC5                 lea     edx, [ebp+var_44]
.text$mn:00005AC8                 push    edx             ; std::_Iterator_base12 *
.text$mn:00005AC9                 lea     eax, [ebp+var_10C]
.text$mn:00005ACF                 push    eax
.text$mn:00005AD0                 mov     ecx, [ebp+var_10]
.text$mn:00005AD3                 call    ?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ ; std::deque<RecentItem,std::allocator<RecentItem>>::end(void)
.text$mn:00005AD8                 mov     [ebp+var_80], eax
.text$mn:00005ADB                 mov     ecx, [ebp+var_80]
.text$mn:00005ADE                 mov     [ebp+var_70], ecx
.text$mn:00005AE1                 mov     byte ptr [ebp+var_4], 0Ch
.text$mn:00005AE5                 mov     ecx, [ebp+var_70]
.text$mn:00005AE8                 call    ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator-(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00005AED                 cmp     [ebp+var_20], eax
.text$mn:00005AF0                 jnb     short loc_5AFB
.text$mn:00005AF2                 mov     [ebp+var_28], 1
.text$mn:00005AF9                 jmp     short loc_5B02
.text$mn:00005AFB ; ---------------------------------------------------------------------------
.text$mn:00005AFB
.text$mn:00005AFB loc_5AFB:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+2C4j
.text$mn:00005AFB                 mov     [ebp+var_28], 0
.text$mn:00005B02
.text$mn:00005B02 loc_5B02:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+2CDj
.text$mn:00005B02                 mov     dl, byte ptr [ebp+var_28]
.text$mn:00005B05                 mov     [ebp+var_1A], dl
.text$mn:00005B08                 mov     byte ptr [ebp+var_4], 6
.text$mn:00005B0C                 lea     ecx, [ebp+var_10C]
.text$mn:00005B12                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00005B17                 movzx   eax, [ebp+var_1A]
.text$mn:00005B1B                 test    eax, eax
.text$mn:00005B1D                 jz      loc_5BD3
.text$mn:00005B23                 sub     esp, 0Ch
.text$mn:00005B26                 mov     ecx, esp
.text$mn:00005B28                 mov     [ebp+var_BC], esp
.text$mn:00005B2E                 lea     edx, [ebp+var_44]
.text$mn:00005B31                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005B32                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00005B37                 mov     [ebp+var_4C], eax
.text$mn:00005B3A                 mov     eax, [ebp+var_4C]
.text$mn:00005B3D                 mov     [ebp+var_E8], eax
.text$mn:00005B43                 mov     byte ptr [ebp+var_4], 0Dh
.text$mn:00005B47                 sub     esp, 0Ch
.text$mn:00005B4A                 mov     ecx, esp
.text$mn:00005B4C                 mov     [ebp+var_C4], esp
.text$mn:00005B52                 lea     edx, [ebp+var_34]
.text$mn:00005B55                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005B56                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00005B5B                 mov     [ebp+var_54], eax
.text$mn:00005B5E                 mov     eax, [ebp+var_54]
.text$mn:00005B61                 mov     [ebp+var_E0], eax
.text$mn:00005B67                 mov     byte ptr [ebp+var_4], 0Eh
.text$mn:00005B6B                 sub     esp, 0Ch
.text$mn:00005B6E                 mov     ecx, esp
.text$mn:00005B70                 mov     [ebp+var_CC], esp
.text$mn:00005B76                 push    ecx
.text$mn:00005B77                 mov     ecx, [ebp+var_10]
.text$mn:00005B7A                 call    ?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ ; std::deque<RecentItem,std::allocator<RecentItem>>::begin(void)
.text$mn:00005B7F                 mov     [ebp+var_5C], eax
.text$mn:00005B82                 mov     edx, [ebp+var_5C]
.text$mn:00005B85                 mov     [ebp+var_E4], edx
.text$mn:00005B8B                 mov     byte ptr [ebp+var_4], 0Fh
.text$mn:00005B8F                 lea     eax, [ebp+var_118]
.text$mn:00005B95                 push    eax
.text$mn:00005B96                 mov     byte ptr [ebp+var_4], 6
.text$mn:00005B9A                 call    ??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)
.text$mn:00005B9F                 add     esp, 28h
.text$mn:00005BA2                 mov     [ebp+var_D4], eax
.text$mn:00005BA8                 lea     ecx, [ebp+var_118]
.text$mn:00005BAE                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00005BB3                 jmp     short loc_5BBE
.text$mn:00005BB5 ; ---------------------------------------------------------------------------
.text$mn:00005BB5
.text$mn:00005BB5 loc_5BB5:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+3A0j
.text$mn:00005BB5                 mov     ecx, [ebp+var_18]
.text$mn:00005BB8                 sub     ecx, 1
.text$mn:00005BBB                 mov     [ebp+var_18], ecx
.text$mn:00005BBE
.text$mn:00005BBE loc_5BBE:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+387j
.text$mn:00005BBE                 cmp     [ebp+var_18], 0
.text$mn:00005BC2                 jbe     short loc_5BCE
.text$mn:00005BC4                 mov     ecx, [ebp+var_10]
.text$mn:00005BC7                 call    ?pop_front@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEXXZ ; std::deque<RecentItem,std::allocator<RecentItem>>::pop_front(void)
.text$mn:00005BCC                 jmp     short loc_5BB5
.text$mn:00005BCE ; ---------------------------------------------------------------------------
.text$mn:00005BCE
.text$mn:00005BCE loc_5BCE:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+396j
.text$mn:00005BCE                 jmp     loc_5C7E
.text$mn:00005BD3 ; ---------------------------------------------------------------------------
.text$mn:00005BD3
.text$mn:00005BD3 loc_5BD3:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+2F1j
.text$mn:00005BD3                 sub     esp, 0Ch
.text$mn:00005BD6                 mov     ecx, esp
.text$mn:00005BD8                 mov     [ebp+var_9C], esp
.text$mn:00005BDE                 lea     edx, [ebp+var_34]
.text$mn:00005BE1                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005BE2                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00005BE7                 mov     [ebp+var_64], eax
.text$mn:00005BEA                 mov     eax, [ebp+var_64]
.text$mn:00005BED                 mov     [ebp+var_A0], eax
.text$mn:00005BF3                 mov     byte ptr [ebp+var_4], 10h
.text$mn:00005BF7                 sub     esp, 0Ch
.text$mn:00005BFA                 mov     ecx, esp
.text$mn:00005BFC                 mov     [ebp+var_A8], esp
.text$mn:00005C02                 push    ecx
.text$mn:00005C03                 mov     ecx, [ebp+var_10]
.text$mn:00005C06                 call    ?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ ; std::deque<RecentItem,std::allocator<RecentItem>>::end(void)
.text$mn:00005C0B                 mov     [ebp+var_6C], eax
.text$mn:00005C0E                 mov     edx, [ebp+var_6C]
.text$mn:00005C11                 mov     [ebp+var_B0], edx
.text$mn:00005C17                 mov     byte ptr [ebp+var_4], 11h
.text$mn:00005C1B                 sub     esp, 0Ch
.text$mn:00005C1E                 mov     ecx, esp
.text$mn:00005C20                 mov     [ebp+var_B8], esp
.text$mn:00005C26                 lea     eax, [ebp+var_44]
.text$mn:00005C29                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005C2A                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00005C2F                 mov     [ebp+var_74], eax
.text$mn:00005C32                 mov     ecx, [ebp+var_74]
.text$mn:00005C35                 mov     [ebp+var_C0], ecx
.text$mn:00005C3B                 mov     byte ptr [ebp+var_4], 12h
.text$mn:00005C3F                 lea     edx, [ebp+var_130]
.text$mn:00005C45                 push    edx
.text$mn:00005C46                 mov     byte ptr [ebp+var_4], 6
.text$mn:00005C4A                 call    ??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)
.text$mn:00005C4F                 add     esp, 28h
.text$mn:00005C52                 mov     [ebp+var_C8], eax
.text$mn:00005C58                 lea     ecx, [ebp+var_130]
.text$mn:00005C5E                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00005C63                 jmp     short loc_5C6E
.text$mn:00005C65 ; ---------------------------------------------------------------------------
.text$mn:00005C65
.text$mn:00005C65 loc_5C65:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+450j
.text$mn:00005C65                 mov     eax, [ebp+var_18]
.text$mn:00005C68                 sub     eax, 1
.text$mn:00005C6B                 mov     [ebp+var_18], eax
.text$mn:00005C6E
.text$mn:00005C6E loc_5C6E:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+437j
.text$mn:00005C6E                 cmp     [ebp+var_18], 0
.text$mn:00005C72                 jbe     short loc_5C7E
.text$mn:00005C74                 mov     ecx, [ebp+var_10]
.text$mn:00005C77                 call    ?pop_back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEXXZ ; std::deque<RecentItem,std::allocator<RecentItem>>::pop_back(void)
.text$mn:00005C7C                 jmp     short loc_5C65
.text$mn:00005C7E ; ---------------------------------------------------------------------------
.text$mn:00005C7E
.text$mn:00005C7E loc_5C7E:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>):loc_5BCEj
.text$mn:00005C7E                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+446j
.text$mn:00005C7E                 movzx   ecx, [ebp+var_19]
.text$mn:00005C82                 test    ecx, ecx
.text$mn:00005C84                 jz      short loc_5C8E
.text$mn:00005C86                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005C89                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00005C8E
.text$mn:00005C8E loc_5C8E:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+458j
.text$mn:00005C8E                 mov     edx, [ebp+var_20]
.text$mn:00005C91                 push    edx
.text$mn:00005C92                 mov     eax, [ebp+arg_0]
.text$mn:00005C95                 push    eax
.text$mn:00005C96                 lea     ecx, [ebp+var_148]
.text$mn:00005C9C                 push    ecx
.text$mn:00005C9D                 mov     ecx, [ebp+var_10]
.text$mn:00005CA0                 call    ?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ ; std::deque<RecentItem,std::allocator<RecentItem>>::begin(void)
.text$mn:00005CA5                 mov     [ebp+var_7C], eax
.text$mn:00005CA8                 mov     edx, [ebp+var_7C]
.text$mn:00005CAB                 mov     [ebp+var_84], edx
.text$mn:00005CB1                 mov     byte ptr [ebp+var_4], 13h
.text$mn:00005CB5                 mov     ecx, [ebp+var_84]
.text$mn:00005CBB                 call    ??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+(int)
.text$mn:00005CC0                 mov     eax, [ebp+var_14]
.text$mn:00005CC3                 or      eax, 4
.text$mn:00005CC6                 mov     [ebp+var_14], eax
.text$mn:00005CC9                 mov     byte ptr [ebp+var_4], 6
.text$mn:00005CCD                 lea     ecx, [ebp+var_148]
.text$mn:00005CD3                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00005CD8                 mov     byte ptr [ebp+var_4], 4
.text$mn:00005CDC                 lea     ecx, [ebp+var_44]
.text$mn:00005CDF                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00005CE4                 mov     byte ptr [ebp+var_4], 2
.text$mn:00005CE8                 lea     ecx, [ebp+var_34]
.text$mn:00005CEB                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00005CF0                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005CF4                 lea     ecx, [ebp+arg_4]
.text$mn:00005CF7                 call    ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00005CFC                 mov     byte ptr [ebp+var_4], 0
.text$mn:00005D00                 lea     ecx, [ebp+arg_10]
.text$mn:00005D03                 call    ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00005D08                 mov     eax, [ebp+arg_0]
.text$mn:00005D0B                 mov     ecx, [ebp+var_C]
.text$mn:00005D0E                 mov     large fs:0, ecx
.text$mn:00005D15                 pop     ecx
.text$mn:00005D16                 mov     esp, ebp
.text$mn:00005D18                 pop     ebp
.text$mn:00005D19                 retn    1Ch
.text$mn:00005D19 ?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z endp
.text$mn:00005D19
.text$mn:00005D19 _text$mn        ends
.text$mn:00005D19
.text$x:00005D1C ; ===========================================================================
.text$x:00005D1C
.text$x:00005D1C ; Segment type: Pure code
.text$x:00005D1C ; Segment permissions: Read/Execute
.text$x:00005D1C _text$x         segment para public 'CODE' use32
.text$x:00005D1C                 assume cs:_text$x
.text$x:00005D1C                 ;org 5D1Ch
.text$x:00005D1C ; COMDAT (pick associative to section at 582C)
.text$x:00005D1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005D1C
.text$x:00005D1C ; =============== S U B R O U T I N E =======================================
.text$x:00005D1C
.text$x:00005D1C
.text$x:00005D1C __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$0 proc near
.text$x:00005D1C                                         ; DATA XREF: .xdata$x:000070CCo
.text$x:00005D1C                 lea     ecx, [ebp+18h]
.text$x:00005D1F                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005D1F __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$0 endp
.text$x:00005D1F
.text$x:00005D24
.text$x:00005D24 ; =============== S U B R O U T I N E =======================================
.text$x:00005D24
.text$x:00005D24
.text$x:00005D24 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$1 proc near
.text$x:00005D24                                         ; DATA XREF: .xdata$x:000070D4o
.text$x:00005D24                 lea     ecx, [ebp+0Ch]
.text$x:00005D27                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005D27 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$1 endp
.text$x:00005D27
.text$x:00005D2C
.text$x:00005D2C ; =============== S U B R O U T I N E =======================================
.text$x:00005D2C
.text$x:00005D2C
.text$x:00005D2C __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$2 proc near
.text$x:00005D2C                                         ; DATA XREF: .xdata$x:000070DCo
.text$x:00005D2C                 mov     ecx, [ebp-0D0h]
.text$x:00005D32                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005D32 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$2 endp
.text$x:00005D32
.text$x:00005D37
.text$x:00005D37 ; =============== S U B R O U T I N E =======================================
.text$x:00005D37
.text$x:00005D37
.text$x:00005D37 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$3 proc near
.text$x:00005D37                                         ; DATA XREF: .xdata$x:000070E4o
.text$x:00005D37                 lea     ecx, [ebp-34h]
.text$x:00005D3A                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005D3A __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$3 endp
.text$x:00005D3A
.text$x:00005D3F
.text$x:00005D3F ; =============== S U B R O U T I N E =======================================
.text$x:00005D3F
.text$x:00005D3F
.text$x:00005D3F __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$4 proc near
.text$x:00005D3F                                         ; DATA XREF: .xdata$x:000070ECo
.text$x:00005D3F                 mov     ecx, [ebp-0ECh]
.text$x:00005D45                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005D45 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$4 endp
.text$x:00005D45
.text$x:00005D4A
.text$x:00005D4A ; =============== S U B R O U T I N E =======================================
.text$x:00005D4A
.text$x:00005D4A
.text$x:00005D4A __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$5 proc near
.text$x:00005D4A                                         ; DATA XREF: .xdata$x:000070F4o
.text$x:00005D4A                 lea     ecx, [ebp-44h]
.text$x:00005D4D                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005D4D __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$5 endp
.text$x:00005D4D
.text$x:00005D52
.text$x:00005D52 ; =============== S U B R O U T I N E =======================================
.text$x:00005D52
.text$x:00005D52
.text$x:00005D52 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$6 proc near
.text$x:00005D52                                         ; DATA XREF: .xdata$x:000070FCo
.text$x:00005D52                 mov     eax, [ebp-14h]
.text$x:00005D55                 and     eax, 1
.text$x:00005D58                 jz      $LN26
.text$x:00005D5E                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00005D62                 lea     ecx, [ebp-13Ch]
.text$x:00005D68                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005D6D ; ---------------------------------------------------------------------------
.text$x:00005D6D
.text$x:00005D6D $LN26:                                  ; CODE XREF: __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$6+6j
.text$x:00005D6D                 retn
.text$x:00005D6D __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$6 endp
.text$x:00005D6D
.text$x:00005D6E
.text$x:00005D6E ; =============== S U B R O U T I N E =======================================
.text$x:00005D6E
.text$x:00005D6E
.text$x:00005D6E __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$7 proc near
.text$x:00005D6E                                         ; DATA XREF: .xdata$x:00007104o
.text$x:00005D6E                 mov     eax, [ebp-14h]
.text$x:00005D71                 and     eax, 2
.text$x:00005D74                 jz      $LN28
.text$x:00005D7A                 and     dword ptr [ebp-14h], 0FFFFFFFDh
.text$x:00005D7E                 lea     ecx, [ebp-100h]
.text$x:00005D84                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005D89 ; ---------------------------------------------------------------------------
.text$x:00005D89
.text$x:00005D89 $LN28:                                  ; CODE XREF: __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$7+6j
.text$x:00005D89                 retn
.text$x:00005D89 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$7 endp
.text$x:00005D89
.text$x:00005D8A
.text$x:00005D8A ; =============== S U B R O U T I N E =======================================
.text$x:00005D8A
.text$x:00005D8A
.text$x:00005D8A __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$8 proc near
.text$x:00005D8A                                         ; DATA XREF: .xdata$x:0000710Co
.text$x:00005D8A                 mov     ecx, [ebp-0ACh]
.text$x:00005D90                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005D90 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$8 endp
.text$x:00005D90
.text$x:00005D95
.text$x:00005D95 ; =============== S U B R O U T I N E =======================================
.text$x:00005D95
.text$x:00005D95
.text$x:00005D95 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$9 proc near
.text$x:00005D95                                         ; DATA XREF: .xdata$x:00007114o
.text$x:00005D95                 mov     ecx, [ebp-0B4h]
.text$x:00005D9B                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005D9B __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$9 endp
.text$x:00005D9B
.text$x:00005DA0
.text$x:00005DA0 ; =============== S U B R O U T I N E =======================================
.text$x:00005DA0
.text$x:00005DA0
.text$x:00005DA0 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$10 proc near
.text$x:00005DA0                                         ; DATA XREF: .xdata$x:0000711Co
.text$x:00005DA0                 lea     ecx, [ebp-124h]
.text$x:00005DA6                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005DA6 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$10 endp
.text$x:00005DA6
.text$x:00005DAB
.text$x:00005DAB ; =============== S U B R O U T I N E =======================================
.text$x:00005DAB
.text$x:00005DAB
.text$x:00005DAB __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$11 proc near
.text$x:00005DAB                                         ; DATA XREF: .xdata$x:00007124o
.text$x:00005DAB                 lea     ecx, [ebp-10Ch]
.text$x:00005DB1                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005DB1 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$11 endp
.text$x:00005DB1
.text$x:00005DB6
.text$x:00005DB6 ; =============== S U B R O U T I N E =======================================
.text$x:00005DB6
.text$x:00005DB6
.text$x:00005DB6 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$12 proc near
.text$x:00005DB6                                         ; DATA XREF: .xdata$x:0000712Co
.text$x:00005DB6                 mov     ecx, [ebp-0BCh]
.text$x:00005DBC                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005DBC __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$12 endp
.text$x:00005DBC
.text$x:00005DC1
.text$x:00005DC1 ; =============== S U B R O U T I N E =======================================
.text$x:00005DC1
.text$x:00005DC1
.text$x:00005DC1 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$13 proc near
.text$x:00005DC1                                         ; DATA XREF: .xdata$x:00007134o
.text$x:00005DC1                 mov     ecx, [ebp-0C4h]
.text$x:00005DC7                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005DC7 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$13 endp
.text$x:00005DC7
.text$x:00005DCC
.text$x:00005DCC ; =============== S U B R O U T I N E =======================================
.text$x:00005DCC
.text$x:00005DCC
.text$x:00005DCC __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$14 proc near
.text$x:00005DCC                                         ; DATA XREF: .xdata$x:0000713Co
.text$x:00005DCC                 mov     ecx, [ebp-0CCh]
.text$x:00005DD2                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005DD2 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$14 endp
.text$x:00005DD2
.text$x:00005DD7
.text$x:00005DD7 ; =============== S U B R O U T I N E =======================================
.text$x:00005DD7
.text$x:00005DD7
.text$x:00005DD7 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$16 proc near
.text$x:00005DD7                                         ; DATA XREF: .xdata$x:00007144o
.text$x:00005DD7                 mov     ecx, [ebp-9Ch]
.text$x:00005DDD                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005DDD __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$16 endp
.text$x:00005DDD
.text$x:00005DE2
.text$x:00005DE2 ; =============== S U B R O U T I N E =======================================
.text$x:00005DE2
.text$x:00005DE2
.text$x:00005DE2 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$17 proc near
.text$x:00005DE2                                         ; DATA XREF: .xdata$x:0000714Co
.text$x:00005DE2                 mov     ecx, [ebp-0A8h]
.text$x:00005DE8                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005DE8 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$17 endp
.text$x:00005DE8
.text$x:00005DED
.text$x:00005DED ; =============== S U B R O U T I N E =======================================
.text$x:00005DED
.text$x:00005DED
.text$x:00005DED __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$18 proc near
.text$x:00005DED                                         ; DATA XREF: .xdata$x:00007154o
.text$x:00005DED                 mov     ecx, [ebp-0B8h]
.text$x:00005DF3                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005DF3 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$18 endp
.text$x:00005DF3
.text$x:00005DF8
.text$x:00005DF8 ; =============== S U B R O U T I N E =======================================
.text$x:00005DF8
.text$x:00005DF8
.text$x:00005DF8 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$20 proc near
.text$x:00005DF8                                         ; DATA XREF: .xdata$x:0000715Co
.text$x:00005DF8                 lea     ecx, [ebp-148h]
.text$x:00005DFE                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005DFE __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$20 endp
.text$x:00005DFE
.text$x:00005E03
.text$x:00005E03 ; =============== S U B R O U T I N E =======================================
.text$x:00005E03
.text$x:00005E03
.text$x:00005E03 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$21 proc near
.text$x:00005E03                                         ; DATA XREF: .xdata$x:000070C4o
.text$x:00005E03                 mov     eax, [ebp-14h]
.text$x:00005E06                 and     eax, 4
.text$x:00005E09                 jz      $LN45
.text$x:00005E0F                 and     dword ptr [ebp-14h], 0FFFFFFFBh
.text$x:00005E13                 mov     ecx, [ebp+8]
.text$x:00005E16                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005E1B ; ---------------------------------------------------------------------------
.text$x:00005E1B
.text$x:00005E1B $LN45:                                  ; CODE XREF: __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$21+6j
.text$x:00005E1B                 retn
.text$x:00005E1B __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$21 endp
.text$x:00005E1B
.text$x:00005E1C
.text$x:00005E1C ; =============== S U B R O U T I N E =======================================
.text$x:00005E1C
.text$x:00005E1C
.text$x:00005E1C __ehhandler$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z proc near
.text$x:00005E1C                                         ; DATA XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+5o
.text$x:00005E1C
.text$x:00005E1C arg_4           = dword ptr  8
.text$x:00005E1C
.text$x:00005E1C                 mov     edx, [esp+arg_4]
.text$x:00005E20                 lea     eax, [edx+0Ch]
.text$x:00005E23                 mov     ecx, [edx-140h]
.text$x:00005E29                 xor     ecx, eax
.text$x:00005E2B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005E30                 mov     eax, offset __ehfuncinfo$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z
.text$x:00005E35                 jmp     ___CxxFrameHandler3
.text$x:00005E35 __ehhandler$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z endp
.text$x:00005E35
.text$x:00005E35 ; ---------------------------------------------------------------------------
.text$x:00005E3A                 align 4
.text$x:00005E3A _text$x         ends
.text$x:00005E3A
.text$mn:00005E3C ; ===========================================================================
.text$mn:00005E3C
.text$mn:00005E3C ; Segment type: Pure code
.text$mn:00005E3C ; Segment permissions: Read/Execute
.text$mn:00005E3C _text$mn        segment para public 'CODE' use32
.text$mn:00005E3C                 assume cs:_text$mn
.text$mn:00005E3C                 ;org 5E3Ch
.text$mn:00005E3C ; COMDAT (pick any)
.text$mn:00005E3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E3C
.text$mn:00005E3C ; =============== S U B R O U T I N E =======================================
.text$mn:00005E3C
.text$mn:00005E3C ; Attributes: bp-based frame
.text$mn:00005E3C
.text$mn:00005E3C ; public: class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>> __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::erase(class std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<struct RecentItem>>>)
.text$mn:00005E3C                 public ?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z
.text$mn:00005E3C ?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z proc near
.text$mn:00005E3C                                         ; CODE XREF: LastRecentFileList::remove(int)+F3p
.text$mn:00005E3C                                         ; LastRecentFileList::clear(void)+EEp
.text$mn:00005E3C
.text$mn:00005E3C var_30          = dword ptr -30h
.text$mn:00005E3C var_2C          = dword ptr -2Ch
.text$mn:00005E3C var_28          = dword ptr -28h
.text$mn:00005E3C var_24          = dword ptr -24h
.text$mn:00005E3C var_20          = dword ptr -20h
.text$mn:00005E3C var_1C          = dword ptr -1Ch
.text$mn:00005E3C var_18          = dword ptr -18h
.text$mn:00005E3C var_14          = dword ptr -14h
.text$mn:00005E3C var_10          = dword ptr -10h
.text$mn:00005E3C var_C           = dword ptr -0Ch
.text$mn:00005E3C var_4           = dword ptr -4
.text$mn:00005E3C arg_0           = dword ptr  8
.text$mn:00005E3C arg_4           = byte ptr  0Ch
.text$mn:00005E3C
.text$mn:00005E3C                 push    ebp
.text$mn:00005E3D                 mov     ebp, esp
.text$mn:00005E3F                 push    0FFFFFFFFh
.text$mn:00005E41                 push    offset __ehhandler$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z
.text$mn:00005E46                 mov     eax, large fs:0
.text$mn:00005E4C                 push    eax
.text$mn:00005E4D                 sub     esp, 24h
.text$mn:00005E50                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005E55                 xor     eax, ebp
.text$mn:00005E57                 push    eax
.text$mn:00005E58                 lea     eax, [ebp+var_C]
.text$mn:00005E5B                 mov     large fs:0, eax
.text$mn:00005E61                 mov     [ebp+var_1C], ecx
.text$mn:00005E64                 mov     [ebp+var_10], 0
.text$mn:00005E6B                 mov     [ebp+var_4], 1
.text$mn:00005E72                 sub     esp, 0Ch
.text$mn:00005E75                 mov     eax, esp
.text$mn:00005E77                 mov     [ebp+var_20], esp
.text$mn:00005E7A                 push    1
.text$mn:00005E7C                 push    eax
.text$mn:00005E7D                 lea     ecx, [ebp+arg_4]
.text$mn:00005E80                 call    ??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+(int)
.text$mn:00005E85                 mov     [ebp+var_14], eax
.text$mn:00005E88                 mov     ecx, [ebp+var_14]
.text$mn:00005E8B                 mov     [ebp+var_24], ecx
.text$mn:00005E8E                 mov     byte ptr [ebp+var_4], 2
.text$mn:00005E92                 sub     esp, 0Ch
.text$mn:00005E95                 mov     ecx, esp
.text$mn:00005E97                 mov     [ebp+var_28], esp
.text$mn:00005E9A                 lea     edx, [ebp+arg_4]
.text$mn:00005E9D                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005E9E                 call    ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)
.text$mn:00005EA3                 mov     [ebp+var_18], eax
.text$mn:00005EA6                 mov     eax, [ebp+var_18]
.text$mn:00005EA9                 mov     [ebp+var_2C], eax
.text$mn:00005EAC                 mov     byte ptr [ebp+var_4], 3
.text$mn:00005EB0                 mov     ecx, [ebp+arg_0]
.text$mn:00005EB3                 push    ecx
.text$mn:00005EB4                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005EB8                 mov     ecx, [ebp+var_1C]
.text$mn:00005EBB                 call    ?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)
.text$mn:00005EC0                 mov     [ebp+var_30], eax
.text$mn:00005EC3                 mov     edx, [ebp+var_10]
.text$mn:00005EC6                 or      edx, 1
.text$mn:00005EC9                 mov     [ebp+var_10], edx
.text$mn:00005ECC                 mov     byte ptr [ebp+var_4], 0
.text$mn:00005ED0                 lea     ecx, [ebp+arg_4]
.text$mn:00005ED3                 call    ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$mn:00005ED8                 mov     eax, [ebp+arg_0]
.text$mn:00005EDB                 mov     ecx, [ebp+var_C]
.text$mn:00005EDE                 mov     large fs:0, ecx
.text$mn:00005EE5                 pop     ecx
.text$mn:00005EE6                 mov     esp, ebp
.text$mn:00005EE8                 pop     ebp
.text$mn:00005EE9                 retn    10h
.text$mn:00005EE9 ?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z endp
.text$mn:00005EE9
.text$mn:00005EE9 _text$mn        ends
.text$mn:00005EE9
.text$x:00005EEC ; ===========================================================================
.text$x:00005EEC
.text$x:00005EEC ; Segment type: Pure code
.text$x:00005EEC ; Segment permissions: Read/Execute
.text$x:00005EEC _text$x         segment para public 'CODE' use32
.text$x:00005EEC                 assume cs:_text$x
.text$x:00005EEC                 ;org 5EECh
.text$x:00005EEC ; COMDAT (pick associative to section at 5E3C)
.text$x:00005EEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005EEC
.text$x:00005EEC ; =============== S U B R O U T I N E =======================================
.text$x:00005EEC
.text$x:00005EEC
.text$x:00005EEC __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$0 proc near
.text$x:00005EEC                                         ; DATA XREF: .xdata$x:00007064o
.text$x:00005EEC                 lea     ecx, [ebp+0Ch]
.text$x:00005EEF                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005EEF __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$0 endp
.text$x:00005EEF
.text$x:00005EF4
.text$x:00005EF4 ; =============== S U B R O U T I N E =======================================
.text$x:00005EF4
.text$x:00005EF4
.text$x:00005EF4 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$1 proc near
.text$x:00005EF4                                         ; DATA XREF: .xdata$x:0000706Co
.text$x:00005EF4                 mov     ecx, [ebp-20h]
.text$x:00005EF7                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005EF7 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$1 endp
.text$x:00005EF7
.text$x:00005EFC
.text$x:00005EFC ; =============== S U B R O U T I N E =======================================
.text$x:00005EFC
.text$x:00005EFC
.text$x:00005EFC __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$2 proc near
.text$x:00005EFC                                         ; DATA XREF: .xdata$x:00007074o
.text$x:00005EFC                 mov     ecx, [ebp-28h]
.text$x:00005EFF                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005EFF __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$2 endp
.text$x:00005EFF
.text$x:00005F04
.text$x:00005F04 ; =============== S U B R O U T I N E =======================================
.text$x:00005F04
.text$x:00005F04
.text$x:00005F04 __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$3 proc near
.text$x:00005F04                                         ; DATA XREF: .xdata$x:0000705Co
.text$x:00005F04                 mov     eax, [ebp-10h]
.text$x:00005F07                 and     eax, 1
.text$x:00005F0A                 jz      $LN7
.text$x:00005F10                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00005F14                 mov     ecx, [ebp+8]
.text$x:00005F17                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>(void)
.text$x:00005F1C ; ---------------------------------------------------------------------------
.text$x:00005F1C
.text$x:00005F1C $LN7:                                   ; CODE XREF: __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$3+6j
.text$x:00005F1C                 retn
.text$x:00005F1C __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$3 endp
.text$x:00005F1C
.text$x:00005F1D
.text$x:00005F1D ; =============== S U B R O U T I N E =======================================
.text$x:00005F1D
.text$x:00005F1D
.text$x:00005F1D __ehhandler$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z proc near
.text$x:00005F1D                                         ; DATA XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+5o
.text$x:00005F1D
.text$x:00005F1D arg_4           = dword ptr  8
.text$x:00005F1D
.text$x:00005F1D                 mov     edx, [esp+arg_4]
.text$x:00005F21                 lea     eax, [edx+0Ch]
.text$x:00005F24                 mov     ecx, [edx-28h]
.text$x:00005F27                 xor     ecx, eax
.text$x:00005F29                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005F2E                 mov     eax, offset __ehfuncinfo$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z
.text$x:00005F33                 jmp     ___CxxFrameHandler3
.text$x:00005F33 __ehhandler$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z endp
.text$x:00005F33
.text$x:00005F33 _text$x         ends
.text$x:00005F33
.text$mn:00005F38 ; ===========================================================================
.text$mn:00005F38
.text$mn:00005F38 ; Segment type: Pure code
.text$mn:00005F38 ; Segment permissions: Read/Execute
.text$mn:00005F38 _text$mn        segment para public 'CODE' use32
.text$mn:00005F38                 assume cs:_text$mn
.text$mn:00005F38                 ;org 5F38h
.text$mn:00005F38 ; COMDAT (pick any)
.text$mn:00005F38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F38
.text$mn:00005F38 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F38
.text$mn:00005F38 ; Attributes: bp-based frame
.text$mn:00005F38
.text$mn:00005F38 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00005F38                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00005F38 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00005F38                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00005F38                 push    ebp
.text$mn:00005F39                 mov     ebp, esp
.text$mn:00005F3B                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00005F40                 pop     ebp
.text$mn:00005F41                 retn
.text$mn:00005F41 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00005F41
.text$mn:00005F41 ; ---------------------------------------------------------------------------
.text$mn:00005F42                 align 4
.text$mn:00005F42 _text$mn        ends
.text$mn:00005F42
.text$mn:00005F44 ; ===========================================================================
.text$mn:00005F44
.text$mn:00005F44 ; Segment type: Pure code
.text$mn:00005F44 ; Segment permissions: Read/Execute
.text$mn:00005F44 _text$mn        segment para public 'CODE' use32
.text$mn:00005F44                 assume cs:_text$mn
.text$mn:00005F44                 ;org 5F44h
.text$mn:00005F44 ; COMDAT (pick any)
.text$mn:00005F44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F44
.text$mn:00005F44 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F44
.text$mn:00005F44 ; Attributes: bp-based frame
.text$mn:00005F44
.text$mn:00005F44 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:00005F44                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:00005F44 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:00005F44                                         ; CODE XREF: LastRecentFileList::updateMenu(void)+31p
.text$mn:00005F44                                         ; LastRecentFileList::saveLRFL(void)+9p
.text$mn:00005F44                 push    ebp
.text$mn:00005F45                 mov     ebp, esp
.text$mn:00005F47                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:00005F4C                 pop     ebp
.text$mn:00005F4D                 retn
.text$mn:00005F4D ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:00005F4D
.text$mn:00005F4D ; ---------------------------------------------------------------------------
.text$mn:00005F4E                 align 10h
.text$mn:00005F4E _text$mn        ends
.text$mn:00005F4E
.text$mn:00005F50 ; ===========================================================================
.text$mn:00005F50
.text$mn:00005F50 ; Segment type: Pure code
.text$mn:00005F50 ; Segment permissions: Read/Execute
.text$mn:00005F50 _text$mn        segment para public 'CODE' use32
.text$mn:00005F50                 assume cs:_text$mn
.text$mn:00005F50                 ;org 5F50h
.text$mn:00005F50 ; COMDAT (pick any)
.text$mn:00005F50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F50
.text$mn:00005F50 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F50
.text$mn:00005F50 ; Attributes: bp-based frame
.text$mn:00005F50
.text$mn:00005F50 ; struct NativeLangSpeaker *__thiscall NppParameters::getNativeLangSpeaker(NppParameters *__hidden this)
.text$mn:00005F50                 public ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ
.text$mn:00005F50 ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ proc near
.text$mn:00005F50                                         ; CODE XREF: LastRecentFileList::updateMenu(void)+64p
.text$mn:00005F50
.text$mn:00005F50 var_4           = dword ptr -4
.text$mn:00005F50
.text$mn:00005F50                 push    ebp
.text$mn:00005F51                 mov     ebp, esp
.text$mn:00005F53                 push    ecx
.text$mn:00005F54                 mov     [ebp+var_4], ecx
.text$mn:00005F57                 mov     eax, [ebp+var_4]
.text$mn:00005F5A                 mov     eax, [eax+1CC20h]
.text$mn:00005F60                 mov     esp, ebp
.text$mn:00005F62                 pop     ebp
.text$mn:00005F63                 retn
.text$mn:00005F63 ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ endp
.text$mn:00005F63
.text$mn:00005F63 _text$mn        ends
.text$mn:00005F63
.text$mn:00005F64 ; ===========================================================================
.text$mn:00005F64
.text$mn:00005F64 ; Segment type: Pure code
.text$mn:00005F64 ; Segment permissions: Read/Execute
.text$mn:00005F64 _text$mn        segment para public 'CODE' use32
.text$mn:00005F64                 assume cs:_text$mn
.text$mn:00005F64                 ;org 5F64h
.text$mn:00005F64 ; COMDAT (pick any)
.text$mn:00005F64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F64
.text$mn:00005F64 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F64
.text$mn:00005F64 ; Attributes: bp-based frame
.text$mn:00005F64
.text$mn:00005F64 ; int __thiscall NppParameters::getRecentFileCustomLength(NppParameters *__hidden this)
.text$mn:00005F64                 public ?getRecentFileCustomLength@NppParameters@@QBEHXZ
.text$mn:00005F64 ?getRecentFileCustomLength@NppParameters@@QBEHXZ proc near
.text$mn:00005F64                                         ; CODE XREF: LastRecentFileList::updateMenu(void)+4CFp
.text$mn:00005F64
.text$mn:00005F64 var_4           = dword ptr -4
.text$mn:00005F64
.text$mn:00005F64                 push    ebp
.text$mn:00005F65                 mov     ebp, esp
.text$mn:00005F67                 push    ecx
.text$mn:00005F68                 mov     [ebp+var_4], ecx
.text$mn:00005F6B                 mov     eax, [ebp+var_4]
.text$mn:00005F6E                 mov     eax, [eax+9B4h]
.text$mn:00005F74                 mov     esp, ebp
.text$mn:00005F76                 pop     ebp
.text$mn:00005F77                 retn
.text$mn:00005F77 ?getRecentFileCustomLength@NppParameters@@QBEHXZ endp
.text$mn:00005F77
.text$mn:00005F77 _text$mn        ends
.text$mn:00005F77
.text$mn:00005F78 ; ===========================================================================
.text$mn:00005F78
.text$mn:00005F78 ; Segment type: Pure code
.text$mn:00005F78 ; Segment permissions: Read/Execute
.text$mn:00005F78 _text$mn        segment para public 'CODE' use32
.text$mn:00005F78                 assume cs:_text$mn
.text$mn:00005F78                 ;org 5F78h
.text$mn:00005F78 ; COMDAT (pick any)
.text$mn:00005F78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F78
.text$mn:00005F78 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F78
.text$mn:00005F78 ; Attributes: bp-based frame
.text$mn:00005F78
.text$mn:00005F78 ; bool __thiscall LastRecentFileList::isSubMenuMode(LastRecentFileList *__hidden this)
.text$mn:00005F78                 public ?isSubMenuMode@LastRecentFileList@@QBE_NXZ
.text$mn:00005F78 ?isSubMenuMode@LastRecentFileList@@QBE_NXZ proc near
.text$mn:00005F78                                         ; CODE XREF: LastRecentFileList::updateMenu(void)+16Cp
.text$mn:00005F78                                         ; LastRecentFileList::updateMenu(void)+261p ...
.text$mn:00005F78
.text$mn:00005F78 var_8           = dword ptr -8
.text$mn:00005F78 var_4           = dword ptr -4
.text$mn:00005F78
.text$mn:00005F78                 push    ebp
.text$mn:00005F79                 mov     ebp, esp
.text$mn:00005F7B                 sub     esp, 8
.text$mn:00005F7E                 mov     [ebp+var_8], ecx
.text$mn:00005F81                 mov     eax, [ebp+var_8]
.text$mn:00005F84                 cmp     dword ptr [eax+24h], 0
.text$mn:00005F88                 jz      short loc_5F93
.text$mn:00005F8A                 mov     [ebp+var_4], 1
.text$mn:00005F91                 jmp     short loc_5F9A
.text$mn:00005F93 ; ---------------------------------------------------------------------------
.text$mn:00005F93
.text$mn:00005F93 loc_5F93:                               ; CODE XREF: LastRecentFileList::isSubMenuMode(void)+10j
.text$mn:00005F93                 mov     [ebp+var_4], 0
.text$mn:00005F9A
.text$mn:00005F9A loc_5F9A:                               ; CODE XREF: LastRecentFileList::isSubMenuMode(void)+19j
.text$mn:00005F9A                 mov     al, byte ptr [ebp+var_4]
.text$mn:00005F9D                 mov     esp, ebp
.text$mn:00005F9F                 pop     ebp
.text$mn:00005FA0                 retn
.text$mn:00005FA0 ?isSubMenuMode@LastRecentFileList@@QBE_NXZ endp
.text$mn:00005FA0
.text$mn:00005FA0 ; ---------------------------------------------------------------------------
.text$mn:00005FA1                 align 4
.text$mn:00005FA1 _text$mn        ends
.text$mn:00005FA1
.text$mn:00005FA4 ; ===========================================================================
.text$mn:00005FA4
.text$mn:00005FA4 ; Segment type: Pure code
.text$mn:00005FA4 ; Segment permissions: Read/Execute
.text$mn:00005FA4 _text$mn        segment para public 'CODE' use32
.text$mn:00005FA4                 assume cs:_text$mn
.text$mn:00005FA4                 ;org 5FA4h
.text$mn:00005FA4 ; COMDAT (pick any)
.text$mn:00005FA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005FA4
.text$mn:00005FA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005FA4
.text$mn:00005FA4 ; Attributes: bp-based frame
.text$mn:00005FA4
.text$mn:00005FA4 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00005FA4                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00005FA4 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00005FA4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00005FA4
.text$mn:00005FA4 var_4           = dword ptr -4
.text$mn:00005FA4 Str             = dword ptr  8
.text$mn:00005FA4
.text$mn:00005FA4                 push    ebp
.text$mn:00005FA5                 mov     ebp, esp
.text$mn:00005FA7                 push    ecx
.text$mn:00005FA8                 mov     eax, [ebp+Str]
.text$mn:00005FAB                 movsx   ecx, byte ptr [eax]
.text$mn:00005FAE                 test    ecx, ecx
.text$mn:00005FB0                 jnz     short loc_5FBB
.text$mn:00005FB2                 mov     [ebp+var_4], 0
.text$mn:00005FB9                 jmp     short loc_5FCA
.text$mn:00005FBB ; ---------------------------------------------------------------------------
.text$mn:00005FBB
.text$mn:00005FBB loc_5FBB:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00005FBB                 mov     edx, [ebp+Str]
.text$mn:00005FBE                 push    edx             ; Str
.text$mn:00005FBF                 call    _strlen
.text$mn:00005FC4                 add     esp, 4
.text$mn:00005FC7                 mov     [ebp+var_4], eax
.text$mn:00005FCA
.text$mn:00005FCA loc_5FCA:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00005FCA                 mov     eax, [ebp+var_4]
.text$mn:00005FCD                 mov     esp, ebp
.text$mn:00005FCF                 pop     ebp
.text$mn:00005FD0                 retn
.text$mn:00005FD0 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00005FD0
.text$mn:00005FD0 ; ---------------------------------------------------------------------------
.text$mn:00005FD1                 align 4
.text$mn:00005FD1 _text$mn        ends
.text$mn:00005FD1
.text$mn:00005FD4 ; ===========================================================================
.text$mn:00005FD4
.text$mn:00005FD4 ; Segment type: Pure code
.text$mn:00005FD4 ; Segment permissions: Read/Execute
.text$mn:00005FD4 _text$mn        segment para public 'CODE' use32
.text$mn:00005FD4                 assume cs:_text$mn
.text$mn:00005FD4                 ;org 5FD4h
.text$mn:00005FD4 ; COMDAT (pick any)
.text$mn:00005FD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005FD4
.text$mn:00005FD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005FD4
.text$mn:00005FD4 ; Attributes: bp-based frame
.text$mn:00005FD4
.text$mn:00005FD4 ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:00005FD4                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:00005FD4 ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:00005FD4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p
.text$mn:00005FD4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)+21p
.text$mn:00005FD4
.text$mn:00005FD4 var_4           = dword ptr -4
.text$mn:00005FD4 Str             = dword ptr  8
.text$mn:00005FD4
.text$mn:00005FD4                 push    ebp
.text$mn:00005FD5                 mov     ebp, esp
.text$mn:00005FD7                 push    ecx
.text$mn:00005FD8                 mov     eax, [ebp+Str]
.text$mn:00005FDB                 movzx   ecx, word ptr [eax]
.text$mn:00005FDE                 test    ecx, ecx
.text$mn:00005FE0                 jnz     short loc_5FEB
.text$mn:00005FE2                 mov     [ebp+var_4], 0
.text$mn:00005FE9                 jmp     short loc_5FFA
.text$mn:00005FEB ; ---------------------------------------------------------------------------
.text$mn:00005FEB
.text$mn:00005FEB loc_5FEB:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:00005FEB                 mov     edx, [ebp+Str]
.text$mn:00005FEE                 push    edx             ; Str
.text$mn:00005FEF                 call    _wcslen
.text$mn:00005FF4                 add     esp, 4
.text$mn:00005FF7                 mov     [ebp+var_4], eax
.text$mn:00005FFA
.text$mn:00005FFA loc_5FFA:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:00005FFA                 mov     eax, [ebp+var_4]
.text$mn:00005FFD                 mov     esp, ebp
.text$mn:00005FFF                 pop     ebp
.text$mn:00006000                 retn
.text$mn:00006000 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:00006000
.text$mn:00006000 ; ---------------------------------------------------------------------------
.text$mn:00006001                 align 4
.text$mn:00006001 _text$mn        ends
.text$mn:00006001
.text$mn:00006004 ; ===========================================================================
.text$mn:00006004
.text$mn:00006004 ; Segment type: Pure code
.text$mn:00006004 ; Segment permissions: Read/Execute
.text$mn:00006004 _text$mn        segment para public 'CODE' use32
.text$mn:00006004                 assume cs:_text$mn
.text$mn:00006004                 ;org 6004h
.text$mn:00006004 ; COMDAT (pick any)
.text$mn:00006004                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006004
.text$mn:00006004 ; =============== S U B R O U T I N E =======================================
.text$mn:00006004
.text$mn:00006004 ; Attributes: bp-based frame
.text$mn:00006004
.text$mn:00006004 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00006004                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00006004 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00006004                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00006004
.text$mn:00006004 var_4           = dword ptr -4
.text$mn:00006004
.text$mn:00006004                 push    ebp
.text$mn:00006005                 mov     ebp, esp
.text$mn:00006007                 push    ecx
.text$mn:00006008                 mov     [ebp+var_4], ecx
.text$mn:0000600B                 mov     eax, [ebp+var_4]
.text$mn:0000600E                 push    eax
.text$mn:0000600F                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00006014                 add     esp, 4
.text$mn:00006017                 mov     esp, ebp
.text$mn:00006019                 pop     ebp
.text$mn:0000601A                 retn
.text$mn:0000601A ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000601A
.text$mn:0000601A ; ---------------------------------------------------------------------------
.text$mn:0000601B                 align 4
.text$mn:0000601B _text$mn        ends
.text$mn:0000601B
.text$mn:0000601C ; ===========================================================================
.text$mn:0000601C
.text$mn:0000601C ; Segment type: Pure code
.text$mn:0000601C ; Segment permissions: Read/Execute
.text$mn:0000601C _text$mn        segment para public 'CODE' use32
.text$mn:0000601C                 assume cs:_text$mn
.text$mn:0000601C                 ;org 601Ch
.text$mn:0000601C ; COMDAT (pick any)
.text$mn:0000601C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000601C
.text$mn:0000601C ; =============== S U B R O U T I N E =======================================
.text$mn:0000601C
.text$mn:0000601C ; Attributes: bp-based frame
.text$mn:0000601C
.text$mn:0000601C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct RecentItem>>::max_size(void)const
.text$mn:0000601C                 public ?max_size@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QBEIXZ
.text$mn:0000601C ?max_size@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QBEIXZ proc near
.text$mn:0000601C                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::max_size(void)+17p
.text$mn:0000601C
.text$mn:0000601C var_4           = dword ptr -4
.text$mn:0000601C
.text$mn:0000601C                 push    ebp
.text$mn:0000601D                 mov     ebp, esp
.text$mn:0000601F                 push    ecx
.text$mn:00006020                 mov     [ebp+var_4], ecx
.text$mn:00006023                 mov     eax, [ebp+var_4]
.text$mn:00006026                 push    eax
.text$mn:00006027                 call    ?max_size@?$allocator_traits@V?$allocator@URecentItem@@@std@@@std@@SAIABV?$allocator@URecentItem@@@2@@Z ; std::allocator_traits<std::allocator<RecentItem>>::max_size(std::allocator<RecentItem> const &)
.text$mn:0000602C                 add     esp, 4
.text$mn:0000602F                 mov     esp, ebp
.text$mn:00006031                 pop     ebp
.text$mn:00006032                 retn
.text$mn:00006032 ?max_size@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QBEIXZ endp
.text$mn:00006032
.text$mn:00006032 ; ---------------------------------------------------------------------------
.text$mn:00006033                 align 4
.text$mn:00006033 _text$mn        ends
.text$mn:00006033
.text$mn:00006034 ; ===========================================================================
.text$mn:00006034
.text$mn:00006034 ; Segment type: Pure code
.text$mn:00006034 ; Segment permissions: Read/Execute
.text$mn:00006034 _text$mn        segment para public 'CODE' use32
.text$mn:00006034                 assume cs:_text$mn
.text$mn:00006034                 ;org 6034h
.text$mn:00006034 ; COMDAT (pick any)
.text$mn:00006034                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006034
.text$mn:00006034 ; =============== S U B R O U T I N E =======================================
.text$mn:00006034
.text$mn:00006034 ; Attributes: bp-based frame
.text$mn:00006034
.text$mn:00006034 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:00006034                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:00006034 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:00006034                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:00006034
.text$mn:00006034 var_4           = dword ptr -4
.text$mn:00006034
.text$mn:00006034                 push    ebp
.text$mn:00006035                 mov     ebp, esp
.text$mn:00006037                 push    ecx
.text$mn:00006038                 mov     [ebp+var_4], ecx
.text$mn:0000603B                 mov     eax, [ebp+var_4]
.text$mn:0000603E                 push    eax
.text$mn:0000603F                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:00006044                 add     esp, 4
.text$mn:00006047                 mov     esp, ebp
.text$mn:00006049                 pop     ebp
.text$mn:0000604A                 retn
.text$mn:0000604A ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000604A
.text$mn:0000604A ; ---------------------------------------------------------------------------
.text$mn:0000604B                 align 4
.text$mn:0000604B _text$mn        ends
.text$mn:0000604B
.text$mn:0000604C ; ===========================================================================
.text$mn:0000604C
.text$mn:0000604C ; Segment type: Pure code
.text$mn:0000604C ; Segment permissions: Read/Execute
.text$mn:0000604C _text$mn        segment para public 'CODE' use32
.text$mn:0000604C                 assume cs:_text$mn
.text$mn:0000604C                 ;org 604Ch
.text$mn:0000604C ; COMDAT (pick any)
.text$mn:0000604C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000604C
.text$mn:0000604C ; =============== S U B R O U T I N E =======================================
.text$mn:0000604C
.text$mn:0000604C ; Attributes: bp-based frame
.text$mn:0000604C
.text$mn:0000604C ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:0000604C                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:0000604C ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:0000604C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:0000604C
.text$mn:0000604C var_4           = dword ptr -4
.text$mn:0000604C
.text$mn:0000604C                 push    ebp
.text$mn:0000604D                 mov     ebp, esp
.text$mn:0000604F                 push    ecx
.text$mn:00006050                 mov     [ebp+var_4], ecx
.text$mn:00006053                 or      eax, 0FFFFFFFFh
.text$mn:00006056                 mov     esp, ebp
.text$mn:00006058                 pop     ebp
.text$mn:00006059                 retn
.text$mn:00006059 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00006059
.text$mn:00006059 ; ---------------------------------------------------------------------------
.text$mn:0000605A                 align 4
.text$mn:0000605A _text$mn        ends
.text$mn:0000605A
.text$mn:0000605C ; ===========================================================================
.text$mn:0000605C
.text$mn:0000605C ; Segment type: Pure code
.text$mn:0000605C ; Segment permissions: Read/Execute
.text$mn:0000605C _text$mn        segment para public 'CODE' use32
.text$mn:0000605C                 assume cs:_text$mn
.text$mn:0000605C                 ;org 605Ch
.text$mn:0000605C ; COMDAT (pick any)
.text$mn:0000605C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000605C
.text$mn:0000605C ; =============== S U B R O U T I N E =======================================
.text$mn:0000605C
.text$mn:0000605C ; Attributes: bp-based frame
.text$mn:0000605C
.text$mn:0000605C ; public: unsigned int __thiscall std::allocator<struct RecentItem>::max_size(void)const
.text$mn:0000605C                 public ?max_size@?$allocator@URecentItem@@@std@@QBEIXZ
.text$mn:0000605C ?max_size@?$allocator@URecentItem@@@std@@QBEIXZ proc near
.text$mn:0000605C                                         ; CODE XREF: std::allocator_traits<std::allocator<RecentItem>>::max_size(std::allocator<RecentItem> const &)+6p
.text$mn:0000605C
.text$mn:0000605C var_4           = dword ptr -4
.text$mn:0000605C
.text$mn:0000605C                 push    ebp
.text$mn:0000605D                 mov     ebp, esp
.text$mn:0000605F                 push    ecx
.text$mn:00006060                 mov     [ebp+var_4], ecx
.text$mn:00006063                 mov     eax, 7FFFFFFh
.text$mn:00006068                 mov     esp, ebp
.text$mn:0000606A                 pop     ebp
.text$mn:0000606B                 retn
.text$mn:0000606B ?max_size@?$allocator@URecentItem@@@std@@QBEIXZ endp
.text$mn:0000606B
.text$mn:0000606B _text$mn        ends
.text$mn:0000606B
.text$mn:0000606C ; ===========================================================================
.text$mn:0000606C
.text$mn:0000606C ; Segment type: Pure code
.text$mn:0000606C ; Segment permissions: Read/Execute
.text$mn:0000606C _text$mn        segment para public 'CODE' use32
.text$mn:0000606C                 assume cs:_text$mn
.text$mn:0000606C                 ;org 606Ch
.text$mn:0000606C ; COMDAT (pick any)
.text$mn:0000606C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000606C
.text$mn:0000606C ; =============== S U B R O U T I N E =======================================
.text$mn:0000606C
.text$mn:0000606C ; Attributes: bp-based frame
.text$mn:0000606C
.text$mn:0000606C ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:0000606C                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:0000606C ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:0000606C                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:0000606C
.text$mn:0000606C var_4           = dword ptr -4
.text$mn:0000606C
.text$mn:0000606C                 push    ebp
.text$mn:0000606D                 mov     ebp, esp
.text$mn:0000606F                 push    ecx
.text$mn:00006070                 mov     [ebp+var_4], ecx
.text$mn:00006073                 mov     eax, 7FFFFFFFh
.text$mn:00006078                 mov     esp, ebp
.text$mn:0000607A                 pop     ebp
.text$mn:0000607B                 retn
.text$mn:0000607B ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:0000607B
.text$mn:0000607B _text$mn        ends
.text$mn:0000607B
.text$mn:0000607C ; ===========================================================================
.text$mn:0000607C
.text$mn:0000607C ; Segment type: Pure code
.text$mn:0000607C ; Segment permissions: Read/Execute
.text$mn:0000607C _text$mn        segment para public 'CODE' use32
.text$mn:0000607C                 assume cs:_text$mn
.text$mn:0000607C                 ;org 607Ch
.text$mn:0000607C ; COMDAT (pick any)
.text$mn:0000607C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000607C
.text$mn:0000607C ; =============== S U B R O U T I N E =======================================
.text$mn:0000607C
.text$mn:0000607C ; Attributes: bp-based frame
.text$mn:0000607C
.text$mn:0000607C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:0000607C                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:0000607C ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:0000607C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:0000607C
.text$mn:0000607C arg_0           = dword ptr  8
.text$mn:0000607C
.text$mn:0000607C                 push    ebp
.text$mn:0000607D                 mov     ebp, esp
.text$mn:0000607F                 mov     ecx, [ebp+arg_0]
.text$mn:00006082                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00006087                 pop     ebp
.text$mn:00006088                 retn
.text$mn:00006088 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00006088
.text$mn:00006088 ; ---------------------------------------------------------------------------
.text$mn:00006089                 align 4
.text$mn:00006089 _text$mn        ends
.text$mn:00006089
.text$mn:0000608C ; ===========================================================================
.text$mn:0000608C
.text$mn:0000608C ; Segment type: Pure code
.text$mn:0000608C ; Segment permissions: Read/Execute
.text$mn:0000608C _text$mn        segment para public 'CODE' use32
.text$mn:0000608C                 assume cs:_text$mn
.text$mn:0000608C                 ;org 608Ch
.text$mn:0000608C ; COMDAT (pick any)
.text$mn:0000608C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000608C
.text$mn:0000608C ; =============== S U B R O U T I N E =======================================
.text$mn:0000608C
.text$mn:0000608C ; Attributes: bp-based frame
.text$mn:0000608C
.text$mn:0000608C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct RecentItem>>::max_size(class std::allocator<struct RecentItem> const &)
.text$mn:0000608C                 public ?max_size@?$allocator_traits@V?$allocator@URecentItem@@@std@@@std@@SAIABV?$allocator@URecentItem@@@2@@Z
.text$mn:0000608C ?max_size@?$allocator_traits@V?$allocator@URecentItem@@@std@@@std@@SAIABV?$allocator@URecentItem@@@2@@Z proc near
.text$mn:0000608C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<RecentItem>>::max_size(void)+Bp
.text$mn:0000608C
.text$mn:0000608C arg_0           = dword ptr  8
.text$mn:0000608C
.text$mn:0000608C                 push    ebp
.text$mn:0000608D                 mov     ebp, esp
.text$mn:0000608F                 mov     ecx, [ebp+arg_0]
.text$mn:00006092                 call    ?max_size@?$allocator@URecentItem@@@std@@QBEIXZ ; std::allocator<RecentItem>::max_size(void)
.text$mn:00006097                 pop     ebp
.text$mn:00006098                 retn
.text$mn:00006098 ?max_size@?$allocator_traits@V?$allocator@URecentItem@@@std@@@std@@SAIABV?$allocator@URecentItem@@@2@@Z endp
.text$mn:00006098
.text$mn:00006098 ; ---------------------------------------------------------------------------
.text$mn:00006099                 align 4
.text$mn:00006099 _text$mn        ends
.text$mn:00006099
.text$mn:0000609C ; ===========================================================================
.text$mn:0000609C
.text$mn:0000609C ; Segment type: Pure code
.text$mn:0000609C ; Segment permissions: Read/Execute
.text$mn:0000609C _text$mn        segment para public 'CODE' use32
.text$mn:0000609C                 assume cs:_text$mn
.text$mn:0000609C                 ;org 609Ch
.text$mn:0000609C ; COMDAT (pick any)
.text$mn:0000609C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000609C
.text$mn:0000609C ; =============== S U B R O U T I N E =======================================
.text$mn:0000609C
.text$mn:0000609C ; Attributes: bp-based frame
.text$mn:0000609C
.text$mn:0000609C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:0000609C                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:0000609C ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:0000609C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:0000609C
.text$mn:0000609C arg_0           = dword ptr  8
.text$mn:0000609C
.text$mn:0000609C                 push    ebp
.text$mn:0000609D                 mov     ebp, esp
.text$mn:0000609F                 mov     ecx, [ebp+arg_0]
.text$mn:000060A2                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:000060A7                 pop     ebp
.text$mn:000060A8                 retn
.text$mn:000060A8 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:000060A8
.text$mn:000060A8 ; ---------------------------------------------------------------------------
.text$mn:000060A9                 align 4
.text$mn:000060A9 _text$mn        ends
.text$mn:000060A9
.text$mn:000060AC ; ===========================================================================
.text$mn:000060AC
.text$mn:000060AC ; Segment type: Pure code
.text$mn:000060AC ; Segment permissions: Read/Execute
.text$mn:000060AC _text$mn        segment para public 'CODE' use32
.text$mn:000060AC                 assume cs:_text$mn
.text$mn:000060AC                 ;org 60ACh
.text$mn:000060AC ; COMDAT (pick any)
.text$mn:000060AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000060AC
.text$mn:000060AC ; =============== S U B R O U T I N E =======================================
.text$mn:000060AC
.text$mn:000060AC ; Attributes: bp-based frame
.text$mn:000060AC
.text$mn:000060AC ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000060AC                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000060AC ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000060AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000060AC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000060AC
.text$mn:000060AC var_10          = dword ptr -10h
.text$mn:000060AC var_C           = dword ptr -0Ch
.text$mn:000060AC var_8           = dword ptr -8
.text$mn:000060AC var_1           = byte ptr -1
.text$mn:000060AC
.text$mn:000060AC                 push    ebp
.text$mn:000060AD                 mov     ebp, esp
.text$mn:000060AF                 sub     esp, 10h
.text$mn:000060B2                 mov     [ebp+var_10], ecx
.text$mn:000060B5                 lea     eax, [ebp+var_1]
.text$mn:000060B8                 push    eax
.text$mn:000060B9                 mov     ecx, [ebp+var_10]
.text$mn:000060BC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000060C1                 mov     ecx, eax
.text$mn:000060C3                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:000060C8                 mov     [ebp+var_8], eax
.text$mn:000060CB                 cmp     [ebp+var_8], 1
.text$mn:000060CF                 ja      short loc_60DA
.text$mn:000060D1                 mov     [ebp+var_C], 1
.text$mn:000060D8                 jmp     short loc_60E3
.text$mn:000060DA ; ---------------------------------------------------------------------------
.text$mn:000060DA
.text$mn:000060DA loc_60DA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:000060DA                 mov     ecx, [ebp+var_8]
.text$mn:000060DD                 sub     ecx, 1
.text$mn:000060E0                 mov     [ebp+var_C], ecx
.text$mn:000060E3
.text$mn:000060E3 loc_60E3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:000060E3                 mov     eax, [ebp+var_C]
.text$mn:000060E6                 mov     esp, ebp
.text$mn:000060E8                 pop     ebp
.text$mn:000060E9                 retn
.text$mn:000060E9 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:000060E9
.text$mn:000060E9 ; ---------------------------------------------------------------------------
.text$mn:000060EA                 align 4
.text$mn:000060EA _text$mn        ends
.text$mn:000060EA
.text$mn:000060EC ; ===========================================================================
.text$mn:000060EC
.text$mn:000060EC ; Segment type: Pure code
.text$mn:000060EC ; Segment permissions: Read/Execute
.text$mn:000060EC _text$mn        segment para public 'CODE' use32
.text$mn:000060EC                 assume cs:_text$mn
.text$mn:000060EC                 ;org 60ECh
.text$mn:000060EC ; COMDAT (pick any)
.text$mn:000060EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000060EC
.text$mn:000060EC ; =============== S U B R O U T I N E =======================================
.text$mn:000060EC
.text$mn:000060EC ; Attributes: bp-based frame
.text$mn:000060EC
.text$mn:000060EC ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:000060EC                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:000060EC ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:000060EC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:000060EC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:000060EC
.text$mn:000060EC var_10          = dword ptr -10h
.text$mn:000060EC var_C           = dword ptr -0Ch
.text$mn:000060EC var_8           = dword ptr -8
.text$mn:000060EC var_1           = byte ptr -1
.text$mn:000060EC
.text$mn:000060EC                 push    ebp
.text$mn:000060ED                 mov     ebp, esp
.text$mn:000060EF                 sub     esp, 10h
.text$mn:000060F2                 mov     [ebp+var_10], ecx
.text$mn:000060F5                 lea     eax, [ebp+var_1]
.text$mn:000060F8                 push    eax
.text$mn:000060F9                 mov     ecx, [ebp+var_10]
.text$mn:000060FC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00006101                 mov     ecx, eax
.text$mn:00006103                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:00006108                 mov     [ebp+var_8], eax
.text$mn:0000610B                 cmp     [ebp+var_8], 1
.text$mn:0000610F                 ja      short loc_611A
.text$mn:00006111                 mov     [ebp+var_C], 1
.text$mn:00006118                 jmp     short loc_6123
.text$mn:0000611A ; ---------------------------------------------------------------------------
.text$mn:0000611A
.text$mn:0000611A loc_611A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:0000611A                 mov     ecx, [ebp+var_8]
.text$mn:0000611D                 sub     ecx, 1
.text$mn:00006120                 mov     [ebp+var_C], ecx
.text$mn:00006123
.text$mn:00006123 loc_6123:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:00006123                 mov     eax, [ebp+var_C]
.text$mn:00006126                 mov     esp, ebp
.text$mn:00006128                 pop     ebp
.text$mn:00006129                 retn
.text$mn:00006129 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00006129
.text$mn:00006129 ; ---------------------------------------------------------------------------
.text$mn:0000612A                 align 4
.text$mn:0000612A _text$mn        ends
.text$mn:0000612A
.text$mn:0000612C ; ===========================================================================
.text$mn:0000612C
.text$mn:0000612C ; Segment type: Pure code
.text$mn:0000612C ; Segment permissions: Read/Execute
.text$mn:0000612C _text$mn        segment para public 'CODE' use32
.text$mn:0000612C                 assume cs:_text$mn
.text$mn:0000612C                 ;org 612Ch
.text$mn:0000612C ; COMDAT (pick any)
.text$mn:0000612C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000612C
.text$mn:0000612C ; =============== S U B R O U T I N E =======================================
.text$mn:0000612C
.text$mn:0000612C ; Attributes: bp-based frame
.text$mn:0000612C
.text$mn:0000612C ; public: unsigned int __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::max_size(void)const
.text$mn:0000612C                 public ?max_size@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBEIXZ
.text$mn:0000612C ?max_size@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBEIXZ proc near
.text$mn:0000612C                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)+56p
.text$mn:0000612C
.text$mn:0000612C var_8           = dword ptr -8
.text$mn:0000612C var_1           = byte ptr -1
.text$mn:0000612C
.text$mn:0000612C                 push    ebp
.text$mn:0000612D                 mov     ebp, esp
.text$mn:0000612F                 sub     esp, 8
.text$mn:00006132                 mov     [ebp+var_8], ecx
.text$mn:00006135                 lea     eax, [ebp+var_1]
.text$mn:00006138                 push    eax
.text$mn:00006139                 mov     ecx, [ebp+var_8]
.text$mn:0000613C                 call    ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<RecentItem,std::allocator<RecentItem>>>::_Getal(void)
.text$mn:00006141                 mov     ecx, eax
.text$mn:00006143                 call    ?max_size@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<RecentItem>>::max_size(void)
.text$mn:00006148                 mov     esp, ebp
.text$mn:0000614A                 pop     ebp
.text$mn:0000614B                 retn
.text$mn:0000614B ?max_size@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBEIXZ endp
.text$mn:0000614B
.text$mn:0000614B _text$mn        ends
.text$mn:0000614B
.text$mn:0000614C ; ===========================================================================
.text$mn:0000614C
.text$mn:0000614C ; Segment type: Pure code
.text$mn:0000614C ; Segment permissions: Read/Execute
.text$mn:0000614C _text$mn        segment para public 'CODE' use32
.text$mn:0000614C                 assume cs:_text$mn
.text$mn:0000614C                 ;org 614Ch
.text$mn:0000614C ; COMDAT (pick any)
.text$mn:0000614C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000614C
.text$mn:0000614C ; =============== S U B R O U T I N E =======================================
.text$mn:0000614C
.text$mn:0000614C ; Attributes: bp-based frame
.text$mn:0000614C
.text$mn:0000614C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:0000614C                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000614C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000614C                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:0000614C                                         ; DATA XREF: .rdata:0000765Co
.text$mn:0000614C
.text$mn:0000614C var_1C          = dword ptr -1Ch
.text$mn:0000614C var_18          = dword ptr -18h
.text$mn:0000614C Str             = dword ptr -14h
.text$mn:0000614C var_10          = dword ptr -10h
.text$mn:0000614C var_C           = dword ptr -0Ch
.text$mn:0000614C var_4           = dword ptr -4
.text$mn:0000614C arg_0           = dword ptr  8
.text$mn:0000614C arg_4           = dword ptr  0Ch
.text$mn:0000614C
.text$mn:0000614C                 push    ebp
.text$mn:0000614D                 mov     ebp, esp
.text$mn:0000614F                 push    0FFFFFFFFh
.text$mn:00006151                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00006156                 mov     eax, large fs:0
.text$mn:0000615C                 push    eax
.text$mn:0000615D                 sub     esp, 10h
.text$mn:00006160                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006165                 xor     eax, ebp
.text$mn:00006167                 push    eax
.text$mn:00006168                 lea     eax, [ebp+var_C]
.text$mn:0000616B                 mov     large fs:0, eax
.text$mn:00006171                 mov     [ebp+var_1C], ecx
.text$mn:00006174                 mov     [ebp+var_18], 0
.text$mn:0000617B                 mov     eax, [ebp+arg_4]
.text$mn:0000617E                 push    eax             ; int
.text$mn:0000617F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00006184                 add     esp, 4
.text$mn:00006187                 mov     [ebp+var_10], eax
.text$mn:0000618A                 cmp     [ebp+var_10], 0
.text$mn:0000618E                 jz      short loc_6198
.text$mn:00006190                 mov     ecx, [ebp+var_10]
.text$mn:00006193                 mov     [ebp+Str], ecx
.text$mn:00006196                 jmp     short loc_619F
.text$mn:00006198 ; ---------------------------------------------------------------------------
.text$mn:00006198
.text$mn:00006198 loc_6198:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00006198                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000619F
.text$mn:0000619F loc_619F:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0000619F                 mov     edx, [ebp+Str]
.text$mn:000061A2                 push    edx             ; Str
.text$mn:000061A3                 mov     ecx, [ebp+arg_0]
.text$mn:000061A6                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000061AB                 mov     [ebp+var_4], 0
.text$mn:000061B2                 mov     eax, [ebp+var_18]
.text$mn:000061B5                 or      eax, 1
.text$mn:000061B8                 mov     [ebp+var_18], eax
.text$mn:000061BB                 mov     eax, [ebp+arg_0]
.text$mn:000061BE                 mov     ecx, [ebp+var_C]
.text$mn:000061C1                 mov     large fs:0, ecx
.text$mn:000061C8                 pop     ecx
.text$mn:000061C9                 mov     esp, ebp
.text$mn:000061CB                 pop     ebp
.text$mn:000061CC                 retn    8
.text$mn:000061CC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000061CC
.text$mn:000061CC ; ---------------------------------------------------------------------------
.text$mn:000061CF                 align 10h
.text$mn:000061CF _text$mn        ends
.text$mn:000061CF
.text$x:000061D0 ; ===========================================================================
.text$x:000061D0
.text$x:000061D0 ; Segment type: Pure code
.text$x:000061D0 ; Segment permissions: Read/Execute
.text$x:000061D0 _text$x         segment para public 'CODE' use32
.text$x:000061D0                 assume cs:_text$x
.text$x:000061D0                 ;org 61D0h
.text$x:000061D0 ; COMDAT (pick associative to section at 614C)
.text$x:000061D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000061D0
.text$x:000061D0 ; =============== S U B R O U T I N E =======================================
.text$x:000061D0
.text$x:000061D0
.text$x:000061D0 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000061D0                                         ; DATA XREF: .xdata$x:00006AA8o
.text$x:000061D0                 mov     eax, [ebp-18h]
.text$x:000061D3                 and     eax, 1
.text$x:000061D6                 jz      $LN6
.text$x:000061DC                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000061E0                 mov     ecx, [ebp+8]
.text$x:000061E3                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000061E8 ; ---------------------------------------------------------------------------
.text$x:000061E8
.text$x:000061E8 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000061E8                 retn
.text$x:000061E8 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000061E8
.text$x:000061E9
.text$x:000061E9 ; =============== S U B R O U T I N E =======================================
.text$x:000061E9
.text$x:000061E9
.text$x:000061E9 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000061E9                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:000061E9
.text$x:000061E9 arg_4           = dword ptr  8
.text$x:000061E9
.text$x:000061E9                 mov     edx, [esp+arg_4]
.text$x:000061ED                 lea     eax, [edx+0Ch]
.text$x:000061F0                 mov     ecx, [edx-14h]
.text$x:000061F3                 xor     ecx, eax
.text$x:000061F5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000061FA                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000061FF                 jmp     ___CxxFrameHandler3
.text$x:000061FF __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000061FF
.text$x:000061FF _text$x         ends
.text$x:000061FF
.text$mn:00006204 ; ===========================================================================
.text$mn:00006204
.text$mn:00006204 ; Segment type: Pure code
.text$mn:00006204 ; Segment permissions: Read/Execute
.text$mn:00006204 _text$mn        segment para public 'CODE' use32
.text$mn:00006204                 assume cs:_text$mn
.text$mn:00006204                 ;org 6204h
.text$mn:00006204 ; COMDAT (pick any)
.text$mn:00006204                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006204
.text$mn:00006204 ; =============== S U B R O U T I N E =======================================
.text$mn:00006204
.text$mn:00006204 ; Attributes: bp-based frame
.text$mn:00006204
.text$mn:00006204 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00006204                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00006204 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00006204                                         ; DATA XREF: .rdata:00007690o
.text$mn:00006204
.text$mn:00006204 var_14          = dword ptr -14h
.text$mn:00006204 var_10          = dword ptr -10h
.text$mn:00006204 var_C           = dword ptr -0Ch
.text$mn:00006204 var_4           = dword ptr -4
.text$mn:00006204 arg_0           = dword ptr  8
.text$mn:00006204 arg_4           = dword ptr  0Ch
.text$mn:00006204
.text$mn:00006204                 push    ebp
.text$mn:00006205                 mov     ebp, esp
.text$mn:00006207                 push    0FFFFFFFFh
.text$mn:00006209                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000620E                 mov     eax, large fs:0
.text$mn:00006214                 push    eax
.text$mn:00006215                 sub     esp, 8
.text$mn:00006218                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000621D                 xor     eax, ebp
.text$mn:0000621F                 push    eax
.text$mn:00006220                 lea     eax, [ebp+var_C]
.text$mn:00006223                 mov     large fs:0, eax
.text$mn:00006229                 mov     [ebp+var_14], ecx
.text$mn:0000622C                 mov     [ebp+var_10], 0
.text$mn:00006233                 cmp     [ebp+arg_4], 1
.text$mn:00006237                 jnz     short loc_625D
.text$mn:00006239                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:0000623E                 mov     ecx, [ebp+arg_0]
.text$mn:00006241                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00006246                 mov     [ebp+var_4], 0
.text$mn:0000624D                 mov     eax, [ebp+var_10]
.text$mn:00006250                 or      eax, 1
.text$mn:00006253                 mov     [ebp+var_10], eax
.text$mn:00006256                 mov     eax, [ebp+arg_0]
.text$mn:00006259                 jmp     short loc_6280
.text$mn:0000625B ; ---------------------------------------------------------------------------
.text$mn:0000625B                 jmp     short loc_6280
.text$mn:0000625D ; ---------------------------------------------------------------------------
.text$mn:0000625D
.text$mn:0000625D loc_625D:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:0000625D                 mov     ecx, [ebp+arg_4]
.text$mn:00006260                 push    ecx
.text$mn:00006261                 mov     edx, [ebp+arg_0]
.text$mn:00006264                 push    edx
.text$mn:00006265                 mov     ecx, [ebp+var_14]
.text$mn:00006268                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:0000626D                 mov     [ebp+var_4], 0
.text$mn:00006274                 mov     eax, [ebp+var_10]
.text$mn:00006277                 or      eax, 1
.text$mn:0000627A                 mov     [ebp+var_10], eax
.text$mn:0000627D                 mov     eax, [ebp+arg_0]
.text$mn:00006280
.text$mn:00006280 loc_6280:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00006280                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00006280                 mov     ecx, [ebp+var_C]
.text$mn:00006283                 mov     large fs:0, ecx
.text$mn:0000628A                 pop     ecx
.text$mn:0000628B                 mov     esp, ebp
.text$mn:0000628D                 pop     ebp
.text$mn:0000628E                 retn    8
.text$mn:0000628E ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000628E
.text$mn:0000628E ; ---------------------------------------------------------------------------
.text$mn:00006291                 align 4
.text$mn:00006291 _text$mn        ends
.text$mn:00006291
.text$x:00006294 ; ===========================================================================
.text$x:00006294
.text$x:00006294 ; Segment type: Pure code
.text$x:00006294 ; Segment permissions: Read/Execute
.text$x:00006294 _text$x         segment para public 'CODE' use32
.text$x:00006294                 assume cs:_text$x
.text$x:00006294                 ;org 6294h
.text$x:00006294 ; COMDAT (pick associative to section at 6204)
.text$x:00006294                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006294
.text$x:00006294 ; =============== S U B R O U T I N E =======================================
.text$x:00006294
.text$x:00006294
.text$x:00006294 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00006294                                         ; DATA XREF: .xdata$x:00006B2Co
.text$x:00006294                 mov     eax, [ebp-10h]
.text$x:00006297                 and     eax, 1
.text$x:0000629A                 jz      $LN6_0
.text$x:000062A0                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000062A4                 mov     ecx, [ebp+8]
.text$x:000062A7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000062AC ; ---------------------------------------------------------------------------
.text$x:000062AC
.text$x:000062AC $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000062AC                 retn
.text$x:000062AC __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000062AC
.text$x:000062AD
.text$x:000062AD ; =============== S U B R O U T I N E =======================================
.text$x:000062AD
.text$x:000062AD
.text$x:000062AD __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000062AD                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:000062AD
.text$x:000062AD arg_4           = dword ptr  8
.text$x:000062AD
.text$x:000062AD                 mov     edx, [esp+arg_4]
.text$x:000062B1                 lea     eax, [edx+0Ch]
.text$x:000062B4                 mov     ecx, [edx-0Ch]
.text$x:000062B7                 xor     ecx, eax
.text$x:000062B9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000062BE                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000062C3                 jmp     ___CxxFrameHandler3
.text$x:000062C3 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000062C3
.text$x:000062C3 _text$x         ends
.text$x:000062C3
.text$mn:000062C8 ; ===========================================================================
.text$mn:000062C8
.text$mn:000062C8 ; Segment type: Pure code
.text$mn:000062C8 ; Segment permissions: Read/Execute
.text$mn:000062C8 _text$mn        segment para public 'CODE' use32
.text$mn:000062C8                 assume cs:_text$mn
.text$mn:000062C8                 ;org 62C8h
.text$mn:000062C8 ; COMDAT (pick any)
.text$mn:000062C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000062C8
.text$mn:000062C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000062C8
.text$mn:000062C8 ; Attributes: bp-based frame
.text$mn:000062C8
.text$mn:000062C8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:000062C8                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000062C8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000062C8                                         ; DATA XREF: .rdata:000076D0o
.text$mn:000062C8
.text$mn:000062C8 var_1C          = dword ptr -1Ch
.text$mn:000062C8 var_18          = dword ptr -18h
.text$mn:000062C8 Str             = dword ptr -14h
.text$mn:000062C8 var_10          = dword ptr -10h
.text$mn:000062C8 var_C           = dword ptr -0Ch
.text$mn:000062C8 var_4           = dword ptr -4
.text$mn:000062C8 arg_0           = dword ptr  8
.text$mn:000062C8 arg_4           = dword ptr  0Ch
.text$mn:000062C8
.text$mn:000062C8                 push    ebp
.text$mn:000062C9                 mov     ebp, esp
.text$mn:000062CB                 push    0FFFFFFFFh
.text$mn:000062CD                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000062D2                 mov     eax, large fs:0
.text$mn:000062D8                 push    eax
.text$mn:000062D9                 sub     esp, 10h
.text$mn:000062DC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000062E1                 xor     eax, ebp
.text$mn:000062E3                 push    eax
.text$mn:000062E4                 lea     eax, [ebp+var_C]
.text$mn:000062E7                 mov     large fs:0, eax
.text$mn:000062ED                 mov     [ebp+var_1C], ecx
.text$mn:000062F0                 mov     [ebp+var_18], 0
.text$mn:000062F7                 mov     eax, [ebp+arg_4]
.text$mn:000062FA                 push    eax             ; int
.text$mn:000062FB                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00006300                 add     esp, 4
.text$mn:00006303                 mov     [ebp+var_10], eax
.text$mn:00006306                 cmp     [ebp+var_10], 0
.text$mn:0000630A                 jz      short loc_6314
.text$mn:0000630C                 mov     ecx, [ebp+var_10]
.text$mn:0000630F                 mov     [ebp+Str], ecx
.text$mn:00006312                 jmp     short loc_631B
.text$mn:00006314 ; ---------------------------------------------------------------------------
.text$mn:00006314
.text$mn:00006314 loc_6314:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00006314                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000631B
.text$mn:0000631B loc_631B:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:0000631B                 mov     edx, [ebp+Str]
.text$mn:0000631E                 push    edx             ; Str
.text$mn:0000631F                 mov     ecx, [ebp+arg_0]
.text$mn:00006322                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00006327                 mov     [ebp+var_4], 0
.text$mn:0000632E                 mov     eax, [ebp+var_18]
.text$mn:00006331                 or      eax, 1
.text$mn:00006334                 mov     [ebp+var_18], eax
.text$mn:00006337                 mov     eax, [ebp+arg_0]
.text$mn:0000633A                 mov     ecx, [ebp+var_C]
.text$mn:0000633D                 mov     large fs:0, ecx
.text$mn:00006344                 pop     ecx
.text$mn:00006345                 mov     esp, ebp
.text$mn:00006347                 pop     ebp
.text$mn:00006348                 retn    8
.text$mn:00006348 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00006348
.text$mn:00006348 ; ---------------------------------------------------------------------------
.text$mn:0000634B                 align 4
.text$mn:0000634B _text$mn        ends
.text$mn:0000634B
.text$x:0000634C ; ===========================================================================
.text$x:0000634C
.text$x:0000634C ; Segment type: Pure code
.text$x:0000634C ; Segment permissions: Read/Execute
.text$x:0000634C _text$x         segment para public 'CODE' use32
.text$x:0000634C                 assume cs:_text$x
.text$x:0000634C                 ;org 634Ch
.text$x:0000634C ; COMDAT (pick associative to section at 62C8)
.text$x:0000634C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000634C
.text$x:0000634C ; =============== S U B R O U T I N E =======================================
.text$x:0000634C
.text$x:0000634C
.text$x:0000634C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000634C                                         ; DATA XREF: .xdata$x:00006BB0o
.text$x:0000634C                 mov     eax, [ebp-18h]
.text$x:0000634F                 and     eax, 1
.text$x:00006352                 jz      $LN6_1
.text$x:00006358                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000635C                 mov     ecx, [ebp+8]
.text$x:0000635F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00006364 ; ---------------------------------------------------------------------------
.text$x:00006364
.text$x:00006364 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00006364                 retn
.text$x:00006364 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00006364
.text$x:00006365
.text$x:00006365 ; =============== S U B R O U T I N E =======================================
.text$x:00006365
.text$x:00006365
.text$x:00006365 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00006365                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00006365
.text$x:00006365 arg_4           = dword ptr  8
.text$x:00006365
.text$x:00006365                 mov     edx, [esp+arg_4]
.text$x:00006369                 lea     eax, [edx+0Ch]
.text$x:0000636C                 mov     ecx, [edx-14h]
.text$x:0000636F                 xor     ecx, eax
.text$x:00006371                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006376                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000637B                 jmp     ___CxxFrameHandler3
.text$x:0000637B __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000637B
.text$x:0000637B _text$x         ends
.text$x:0000637B
.text$mn:00006380 ; ===========================================================================
.text$mn:00006380
.text$mn:00006380 ; Segment type: Pure code
.text$mn:00006380 ; Segment permissions: Read/Execute
.text$mn:00006380 _text$mn        segment para public 'CODE' use32
.text$mn:00006380                 assume cs:_text$mn
.text$mn:00006380                 ;org 6380h
.text$mn:00006380 ; COMDAT (pick any)
.text$mn:00006380                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006380
.text$mn:00006380 ; =============== S U B R O U T I N E =======================================
.text$mn:00006380
.text$mn:00006380 ; Attributes: bp-based frame
.text$mn:00006380
.text$mn:00006380 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00006380                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00006380 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00006380                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00006380
.text$mn:00006380 var_4           = dword ptr -4
.text$mn:00006380 Dst             = dword ptr  8
.text$mn:00006380 Src             = dword ptr  0Ch
.text$mn:00006380 Size            = dword ptr  10h
.text$mn:00006380
.text$mn:00006380                 push    ebp
.text$mn:00006381                 mov     ebp, esp
.text$mn:00006383                 push    ecx
.text$mn:00006384                 cmp     [ebp+Size], 0
.text$mn:00006388                 jnz     short loc_6392
.text$mn:0000638A                 mov     eax, [ebp+Dst]
.text$mn:0000638D                 mov     [ebp+var_4], eax
.text$mn:00006390                 jmp     short loc_63A9
.text$mn:00006392 ; ---------------------------------------------------------------------------
.text$mn:00006392
.text$mn:00006392 loc_6392:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00006392                 mov     ecx, [ebp+Size]
.text$mn:00006395                 push    ecx             ; Size
.text$mn:00006396                 mov     edx, [ebp+Src]
.text$mn:00006399                 push    edx             ; Src
.text$mn:0000639A                 mov     eax, [ebp+Dst]
.text$mn:0000639D                 push    eax             ; Dst
.text$mn:0000639E                 call    _memmove
.text$mn:000063A3                 add     esp, 0Ch
.text$mn:000063A6                 mov     [ebp+var_4], eax
.text$mn:000063A9
.text$mn:000063A9 loc_63A9:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:000063A9                 mov     eax, [ebp+var_4]
.text$mn:000063AC                 mov     esp, ebp
.text$mn:000063AE                 pop     ebp
.text$mn:000063AF                 retn
.text$mn:000063AF ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000063AF
.text$mn:000063AF _text$mn        ends
.text$mn:000063AF
.text$mn:000063B0 ; ===========================================================================
.text$mn:000063B0
.text$mn:000063B0 ; Segment type: Pure code
.text$mn:000063B0 ; Segment permissions: Read/Execute
.text$mn:000063B0 _text$mn        segment para public 'CODE' use32
.text$mn:000063B0                 assume cs:_text$mn
.text$mn:000063B0                 ;org 63B0h
.text$mn:000063B0 ; COMDAT (pick any)
.text$mn:000063B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000063B0
.text$mn:000063B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000063B0
.text$mn:000063B0 ; Attributes: bp-based frame
.text$mn:000063B0
.text$mn:000063B0 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:000063B0                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:000063B0 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:000063B0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:000063B0
.text$mn:000063B0 var_4           = dword ptr -4
.text$mn:000063B0 Dst             = dword ptr  8
.text$mn:000063B0 Src             = dword ptr  0Ch
.text$mn:000063B0 arg_8           = dword ptr  10h
.text$mn:000063B0
.text$mn:000063B0                 push    ebp
.text$mn:000063B1                 mov     ebp, esp
.text$mn:000063B3                 push    ecx
.text$mn:000063B4                 cmp     [ebp+arg_8], 0
.text$mn:000063B8                 jnz     short loc_63C2
.text$mn:000063BA                 mov     eax, [ebp+Dst]
.text$mn:000063BD                 mov     [ebp+var_4], eax
.text$mn:000063C0                 jmp     short loc_63D9
.text$mn:000063C2 ; ---------------------------------------------------------------------------
.text$mn:000063C2
.text$mn:000063C2 loc_63C2:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:000063C2                 mov     ecx, [ebp+arg_8]
.text$mn:000063C5                 push    ecx             ; int
.text$mn:000063C6                 mov     edx, [ebp+Src]
.text$mn:000063C9                 push    edx             ; Src
.text$mn:000063CA                 mov     eax, [ebp+Dst]
.text$mn:000063CD                 push    eax             ; Dst
.text$mn:000063CE                 call    _wmemmove
.text$mn:000063D3                 add     esp, 0Ch
.text$mn:000063D6                 mov     [ebp+var_4], eax
.text$mn:000063D9
.text$mn:000063D9 loc_63D9:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:000063D9                 mov     eax, [ebp+var_4]
.text$mn:000063DC                 mov     esp, ebp
.text$mn:000063DE                 pop     ebp
.text$mn:000063DF                 retn
.text$mn:000063DF ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:000063DF
.text$mn:000063DF _text$mn        ends
.text$mn:000063DF
.text$mn:000063E0 ; ===========================================================================
.text$mn:000063E0
.text$mn:000063E0 ; Segment type: Pure code
.text$mn:000063E0 ; Segment permissions: Read/Execute
.text$mn:000063E0 _text$mn        segment para public 'CODE' use32
.text$mn:000063E0                 assume cs:_text$mn
.text$mn:000063E0                 ;org 63E0h
.text$mn:000063E0 ; COMDAT (pick any)
.text$mn:000063E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000063E0
.text$mn:000063E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000063E0
.text$mn:000063E0 ; Attributes: bp-based frame
.text$mn:000063E0
.text$mn:000063E0 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:000063E0                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:000063E0 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:000063E0                                         ; DATA XREF: .rdata:00007658o
.text$mn:000063E0
.text$mn:000063E0 var_4           = dword ptr -4
.text$mn:000063E0
.text$mn:000063E0                 push    ebp
.text$mn:000063E1                 mov     ebp, esp
.text$mn:000063E3                 push    ecx
.text$mn:000063E4                 mov     [ebp+var_4], ecx
.text$mn:000063E7                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:000063EC                 mov     esp, ebp
.text$mn:000063EE                 pop     ebp
.text$mn:000063EF                 retn
.text$mn:000063EF ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:000063EF
.text$mn:000063EF _text$mn        ends
.text$mn:000063EF
.text$mn:000063F0 ; ===========================================================================
.text$mn:000063F0
.text$mn:000063F0 ; Segment type: Pure code
.text$mn:000063F0 ; Segment permissions: Read/Execute
.text$mn:000063F0 _text$mn        segment para public 'CODE' use32
.text$mn:000063F0                 assume cs:_text$mn
.text$mn:000063F0                 ;org 63F0h
.text$mn:000063F0 ; COMDAT (pick any)
.text$mn:000063F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000063F0
.text$mn:000063F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000063F0
.text$mn:000063F0 ; Attributes: bp-based frame
.text$mn:000063F0
.text$mn:000063F0 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:000063F0                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:000063F0 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:000063F0                                         ; DATA XREF: .rdata:0000768Co
.text$mn:000063F0
.text$mn:000063F0 var_4           = dword ptr -4
.text$mn:000063F0
.text$mn:000063F0                 push    ebp
.text$mn:000063F1                 mov     ebp, esp
.text$mn:000063F3                 push    ecx
.text$mn:000063F4                 mov     [ebp+var_4], ecx
.text$mn:000063F7                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:000063FC                 mov     esp, ebp
.text$mn:000063FE                 pop     ebp
.text$mn:000063FF                 retn
.text$mn:000063FF ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:000063FF
.text$mn:000063FF _text$mn        ends
.text$mn:000063FF
.text$mn:00006400 ; ===========================================================================
.text$mn:00006400
.text$mn:00006400 ; Segment type: Pure code
.text$mn:00006400 ; Segment permissions: Read/Execute
.text$mn:00006400 _text$mn        segment para public 'CODE' use32
.text$mn:00006400                 assume cs:_text$mn
.text$mn:00006400                 ;org 6400h
.text$mn:00006400 ; COMDAT (pick any)
.text$mn:00006400                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006400
.text$mn:00006400 ; =============== S U B R O U T I N E =======================================
.text$mn:00006400
.text$mn:00006400 ; Attributes: bp-based frame
.text$mn:00006400
.text$mn:00006400 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00006400                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00006400 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00006400                                         ; DATA XREF: .rdata:000076CCo
.text$mn:00006400
.text$mn:00006400 var_4           = dword ptr -4
.text$mn:00006400
.text$mn:00006400                 push    ebp
.text$mn:00006401                 mov     ebp, esp
.text$mn:00006403                 push    ecx
.text$mn:00006404                 mov     [ebp+var_4], ecx
.text$mn:00006407                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:0000640C                 mov     esp, ebp
.text$mn:0000640E                 pop     ebp
.text$mn:0000640F                 retn
.text$mn:0000640F ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000640F
.text$mn:0000640F _text$mn        ends
.text$mn:0000640F
.text$mn:00006410 ; ===========================================================================
.text$mn:00006410
.text$mn:00006410 ; Segment type: Pure code
.text$mn:00006410 ; Segment permissions: Read/Execute
.text$mn:00006410 _text$mn        segment para public 'CODE' use32
.text$mn:00006410                 assume cs:_text$mn
.text$mn:00006410                 ;org 6410h
.text$mn:00006410 ; COMDAT (pick any)
.text$mn:00006410                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006410
.text$mn:00006410 ; =============== S U B R O U T I N E =======================================
.text$mn:00006410
.text$mn:00006410 ; Attributes: bp-based frame
.text$mn:00006410
.text$mn:00006410 ; public: void __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::pop_back(void)
.text$mn:00006410                 public ?pop_back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEXXZ
.text$mn:00006410 ?pop_back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEXXZ proc near
.text$mn:00006410                                         ; CODE XREF: LastRecentFileList::add(wchar_t const *)+96p
.text$mn:00006410                                         ; LastRecentFileList::setUserMaxNbLRF(int)+65p ...
.text$mn:00006410
.text$mn:00006410 var_14          = dword ptr -14h
.text$mn:00006410 var_10          = dword ptr -10h
.text$mn:00006410 var_C           = dword ptr -0Ch
.text$mn:00006410 var_8           = dword ptr -8
.text$mn:00006410 var_1           = byte ptr -1
.text$mn:00006410
.text$mn:00006410                 push    ebp
.text$mn:00006411                 mov     ebp, esp
.text$mn:00006413                 sub     esp, 14h
.text$mn:00006416                 push    esi
.text$mn:00006417                 mov     [ebp+var_8], ecx
.text$mn:0000641A                 mov     ecx, [ebp+var_8]
.text$mn:0000641D                 call    ?empty@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE_NXZ ; std::deque<RecentItem,std::allocator<RecentItem>>::empty(void)
.text$mn:00006422                 movzx   eax, al
.text$mn:00006425                 test    eax, eax
.text$mn:00006427                 jz      short loc_6445
.text$mn:00006429                 push    5C2h            ; unsigned int
.text$mn:0000642E                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006433                 push    offset ??_C@_1CO@FNIDKHMC@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@ ; "deque empty before pop"
.text$mn:00006438                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000643D                 add     esp, 0Ch
.text$mn:00006440                 jmp     loc_64C7
.text$mn:00006445 ; ---------------------------------------------------------------------------
.text$mn:00006445
.text$mn:00006445 loc_6445:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::pop_back(void)+17j
.text$mn:00006445                 mov     ecx, [ebp+var_8]
.text$mn:00006448                 mov     edx, [ecx+0Ch]
.text$mn:0000644B                 mov     eax, [ebp+var_8]
.text$mn:0000644E                 mov     ecx, [eax+10h]
.text$mn:00006451                 lea     edx, [edx+ecx-1]
.text$mn:00006455                 mov     [ebp+var_C], edx
.text$mn:00006458                 mov     eax, [ebp+var_C]
.text$mn:0000645B                 push    eax
.text$mn:0000645C                 mov     ecx, [ebp+var_8]
.text$mn:0000645F                 call    ?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint)
.text$mn:00006464                 mov     ecx, [ebp+var_C]
.text$mn:00006467                 push    ecx
.text$mn:00006468                 mov     ecx, [ebp+var_8]
.text$mn:0000646B                 call    ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<RecentItem>>::_Getblock(uint)
.text$mn:00006470                 mov     [ebp+var_14], eax
.text$mn:00006473                 mov     edx, [ebp+var_8]
.text$mn:00006476                 mov     ecx, [edx+4]
.text$mn:00006479                 mov     eax, [ebp+var_C]
.text$mn:0000647C                 xor     edx, edx
.text$mn:0000647E                 mov     esi, 1
.text$mn:00006483                 div     esi
.text$mn:00006485                 shl     edx, 5
.text$mn:00006488                 mov     eax, [ebp+var_14]
.text$mn:0000648B                 add     edx, [ecx+eax*4]
.text$mn:0000648E                 push    edx
.text$mn:0000648F                 lea     ecx, [ebp+var_1]
.text$mn:00006492                 push    ecx
.text$mn:00006493                 mov     ecx, [ebp+var_8]
.text$mn:00006496                 call    ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<RecentItem,std::allocator<RecentItem>>>::_Getal(void)
.text$mn:0000649B                 mov     ecx, eax
.text$mn:0000649D                 call    ??$destroy@URecentItem@@@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAEXPAURecentItem@@@Z ; std::_Wrap_alloc<std::allocator<RecentItem>>::destroy<RecentItem>(RecentItem *)
.text$mn:000064A2                 mov     edx, [ebp+var_8]
.text$mn:000064A5                 mov     eax, [edx+10h]
.text$mn:000064A8                 sub     eax, 1
.text$mn:000064AB                 mov     [ebp+var_10], eax
.text$mn:000064AE                 mov     ecx, [ebp+var_8]
.text$mn:000064B1                 mov     edx, [ebp+var_10]
.text$mn:000064B4                 mov     [ecx+10h], edx
.text$mn:000064B7                 cmp     [ebp+var_10], 0
.text$mn:000064BB                 jnz     short loc_64C7
.text$mn:000064BD                 mov     eax, [ebp+var_8]
.text$mn:000064C0                 mov     dword ptr [eax+0Ch], 0
.text$mn:000064C7
.text$mn:000064C7 loc_64C7:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::pop_back(void)+30j
.text$mn:000064C7                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::pop_back(void)+ABj
.text$mn:000064C7                 pop     esi
.text$mn:000064C8                 mov     esp, ebp
.text$mn:000064CA                 pop     ebp
.text$mn:000064CB                 retn
.text$mn:000064CB ?pop_back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEXXZ endp
.text$mn:000064CB
.text$mn:000064CB _text$mn        ends
.text$mn:000064CB
.text$mn:000064CC ; ===========================================================================
.text$mn:000064CC
.text$mn:000064CC ; Segment type: Pure code
.text$mn:000064CC ; Segment permissions: Read/Execute
.text$mn:000064CC _text$mn        segment para public 'CODE' use32
.text$mn:000064CC                 assume cs:_text$mn
.text$mn:000064CC                 ;org 64CCh
.text$mn:000064CC ; COMDAT (pick any)
.text$mn:000064CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000064CC
.text$mn:000064CC ; =============== S U B R O U T I N E =======================================
.text$mn:000064CC
.text$mn:000064CC ; Attributes: bp-based frame
.text$mn:000064CC
.text$mn:000064CC ; public: void __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::pop_front(void)
.text$mn:000064CC                 public ?pop_front@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEXXZ
.text$mn:000064CC ?pop_front@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEXXZ proc near
.text$mn:000064CC                                         ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+39Bp
.text$mn:000064CC
.text$mn:000064CC var_10          = dword ptr -10h
.text$mn:000064CC var_C           = dword ptr -0Ch
.text$mn:000064CC var_8           = dword ptr -8
.text$mn:000064CC var_1           = byte ptr -1
.text$mn:000064CC
.text$mn:000064CC                 push    ebp
.text$mn:000064CD                 mov     ebp, esp
.text$mn:000064CF                 sub     esp, 10h
.text$mn:000064D2                 push    esi
.text$mn:000064D3                 mov     [ebp+var_8], ecx
.text$mn:000064D6                 mov     ecx, [ebp+var_8]
.text$mn:000064D9                 call    ?empty@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE_NXZ ; std::deque<RecentItem,std::allocator<RecentItem>>::empty(void)
.text$mn:000064DE                 movzx   eax, al
.text$mn:000064E1                 test    eax, eax
.text$mn:000064E3                 jz      short loc_6501
.text$mn:000064E5                 push    59Dh            ; unsigned int
.text$mn:000064EA                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000064EF                 push    offset ??_C@_1CO@FNIDKHMC@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@ ; "deque empty before pop"
.text$mn:000064F4                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000064F9                 add     esp, 0Ch
.text$mn:000064FC                 jmp     loc_658A
.text$mn:00006501 ; ---------------------------------------------------------------------------
.text$mn:00006501
.text$mn:00006501 loc_6501:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::pop_front(void)+17j
.text$mn:00006501                 mov     ecx, [ebp+var_8]
.text$mn:00006504                 mov     edx, [ecx+0Ch]
.text$mn:00006507                 push    edx
.text$mn:00006508                 mov     ecx, [ebp+var_8]
.text$mn:0000650B                 call    ?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::_Orphan_off(uint)
.text$mn:00006510                 mov     eax, [ebp+var_8]
.text$mn:00006513                 mov     ecx, [eax+0Ch]
.text$mn:00006516                 push    ecx
.text$mn:00006517                 mov     ecx, [ebp+var_8]
.text$mn:0000651A                 call    ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<RecentItem>>::_Getblock(uint)
.text$mn:0000651F                 mov     [ebp+var_10], eax
.text$mn:00006522                 mov     edx, [ebp+var_8]
.text$mn:00006525                 mov     ecx, [edx+4]
.text$mn:00006528                 mov     edx, [ebp+var_8]
.text$mn:0000652B                 mov     eax, [edx+0Ch]
.text$mn:0000652E                 xor     edx, edx
.text$mn:00006530                 mov     esi, 1
.text$mn:00006535                 div     esi
.text$mn:00006537                 shl     edx, 5
.text$mn:0000653A                 mov     eax, [ebp+var_10]
.text$mn:0000653D                 add     edx, [ecx+eax*4]
.text$mn:00006540                 push    edx
.text$mn:00006541                 lea     ecx, [ebp+var_1]
.text$mn:00006544                 push    ecx
.text$mn:00006545                 mov     ecx, [ebp+var_8]
.text$mn:00006548                 call    ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<RecentItem,std::allocator<RecentItem>>>::_Getal(void)
.text$mn:0000654D                 mov     ecx, eax
.text$mn:0000654F                 call    ??$destroy@URecentItem@@@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAEXPAURecentItem@@@Z ; std::_Wrap_alloc<std::allocator<RecentItem>>::destroy<RecentItem>(RecentItem *)
.text$mn:00006554                 mov     edx, [ebp+var_8]
.text$mn:00006557                 mov     eax, [edx+10h]
.text$mn:0000655A                 sub     eax, 1
.text$mn:0000655D                 mov     [ebp+var_C], eax
.text$mn:00006560                 mov     ecx, [ebp+var_8]
.text$mn:00006563                 mov     edx, [ebp+var_C]
.text$mn:00006566                 mov     [ecx+10h], edx
.text$mn:00006569                 cmp     [ebp+var_C], 0
.text$mn:0000656D                 jnz     short loc_657B
.text$mn:0000656F                 mov     eax, [ebp+var_8]
.text$mn:00006572                 mov     dword ptr [eax+0Ch], 0
.text$mn:00006579                 jmp     short loc_658A
.text$mn:0000657B ; ---------------------------------------------------------------------------
.text$mn:0000657B
.text$mn:0000657B loc_657B:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::pop_front(void)+A1j
.text$mn:0000657B                 mov     ecx, [ebp+var_8]
.text$mn:0000657E                 mov     edx, [ecx+0Ch]
.text$mn:00006581                 add     edx, 1
.text$mn:00006584                 mov     eax, [ebp+var_8]
.text$mn:00006587                 mov     [eax+0Ch], edx
.text$mn:0000658A
.text$mn:0000658A loc_658A:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::pop_front(void)+30j
.text$mn:0000658A                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::pop_front(void)+ADj
.text$mn:0000658A                 pop     esi
.text$mn:0000658B                 mov     esp, ebp
.text$mn:0000658D                 pop     ebp
.text$mn:0000658E                 retn
.text$mn:0000658E ?pop_front@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEXXZ endp
.text$mn:0000658E
.text$mn:0000658E ; ---------------------------------------------------------------------------
.text$mn:0000658F                 align 10h
.text$mn:0000658F _text$mn        ends
.text$mn:0000658F
.text$mn:00006590 ; ===========================================================================
.text$mn:00006590
.text$mn:00006590 ; Segment type: Pure code
.text$mn:00006590 ; Segment permissions: Read/Execute
.text$mn:00006590 _text$mn        segment para public 'CODE' use32
.text$mn:00006590                 assume cs:_text$mn
.text$mn:00006590                 ;org 6590h
.text$mn:00006590 ; COMDAT (pick any)
.text$mn:00006590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006590
.text$mn:00006590 ; =============== S U B R O U T I N E =======================================
.text$mn:00006590
.text$mn:00006590 ; Attributes: bp-based frame
.text$mn:00006590
.text$mn:00006590 ; public: void __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::push_front(struct RecentItem const &)
.text$mn:00006590                 public ?push_front@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEXABURecentItem@@@Z
.text$mn:00006590 ?push_front@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEXABURecentItem@@@Z proc near
.text$mn:00006590                                         ; CODE XREF: LastRecentFileList::add(wchar_t const *)+BEp
.text$mn:00006590
.text$mn:00006590 var_14          = dword ptr -14h
.text$mn:00006590 var_10          = dword ptr -10h
.text$mn:00006590 var_C           = dword ptr -0Ch
.text$mn:00006590 var_8           = dword ptr -8
.text$mn:00006590 var_2           = byte ptr -2
.text$mn:00006590 var_1           = byte ptr -1
.text$mn:00006590 arg_0           = dword ptr  8
.text$mn:00006590
.text$mn:00006590                 push    ebp
.text$mn:00006591                 mov     ebp, esp
.text$mn:00006593                 sub     esp, 14h
.text$mn:00006596                 push    esi
.text$mn:00006597                 mov     [ebp+var_8], ecx
.text$mn:0000659A                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000659D                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000065A2                 mov     eax, [ebp+var_8]
.text$mn:000065A5                 mov     eax, [eax+0Ch]
.text$mn:000065A8                 xor     edx, edx
.text$mn:000065AA                 mov     ecx, 1
.text$mn:000065AF                 div     ecx
.text$mn:000065B1                 test    edx, edx
.text$mn:000065B3                 jnz     short loc_65D0
.text$mn:000065B5                 mov     edx, [ebp+var_8]
.text$mn:000065B8                 mov     eax, [edx+10h]
.text$mn:000065BB                 add     eax, 1
.text$mn:000065BE                 mov     ecx, [ebp+var_8]
.text$mn:000065C1                 cmp     [ecx+8], eax
.text$mn:000065C4                 ja      short loc_65D0
.text$mn:000065C6                 push    1
.text$mn:000065C8                 mov     ecx, [ebp+var_8]
.text$mn:000065CB                 call    ?_Growmap@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IAEXI@Z ; std::deque<RecentItem,std::allocator<RecentItem>>::_Growmap(uint)
.text$mn:000065D0
.text$mn:000065D0 loc_65D0:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::push_front(RecentItem const &)+23j
.text$mn:000065D0                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::push_front(RecentItem const &)+34j
.text$mn:000065D0                 mov     edx, [ebp+var_8]
.text$mn:000065D3                 mov     eax, [edx+8]
.text$mn:000065D6                 sub     eax, 1
.text$mn:000065D9                 mov     ecx, [ebp+var_8]
.text$mn:000065DC                 and     eax, [ecx+0Ch]
.text$mn:000065DF                 mov     edx, [ebp+var_8]
.text$mn:000065E2                 mov     [edx+0Ch], eax
.text$mn:000065E5                 mov     eax, [ebp+var_8]
.text$mn:000065E8                 cmp     dword ptr [eax+0Ch], 0
.text$mn:000065EC                 jz      short loc_65F9
.text$mn:000065EE                 mov     ecx, [ebp+var_8]
.text$mn:000065F1                 mov     edx, [ecx+0Ch]
.text$mn:000065F4                 mov     [ebp+var_14], edx
.text$mn:000065F7                 jmp     short loc_6602
.text$mn:000065F9 ; ---------------------------------------------------------------------------
.text$mn:000065F9
.text$mn:000065F9 loc_65F9:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::push_front(RecentItem const &)+5Cj
.text$mn:000065F9                 mov     eax, [ebp+var_8]
.text$mn:000065FC                 mov     ecx, [eax+8]
.text$mn:000065FF                 mov     [ebp+var_14], ecx
.text$mn:00006602
.text$mn:00006602 loc_6602:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::push_front(RecentItem const &)+67j
.text$mn:00006602                 mov     edx, [ebp+var_14]
.text$mn:00006605                 mov     [ebp+var_C], edx
.text$mn:00006608                 mov     eax, [ebp+var_C]
.text$mn:0000660B                 sub     eax, 1
.text$mn:0000660E                 mov     [ebp+var_C], eax
.text$mn:00006611                 mov     ecx, [ebp+var_C]
.text$mn:00006614                 push    ecx
.text$mn:00006615                 mov     ecx, [ebp+var_8]
.text$mn:00006618                 call    ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<RecentItem>>::_Getblock(uint)
.text$mn:0000661D                 mov     [ebp+var_10], eax
.text$mn:00006620                 mov     edx, [ebp+var_8]
.text$mn:00006623                 mov     eax, [edx+4]
.text$mn:00006626                 mov     ecx, [ebp+var_10]
.text$mn:00006629                 cmp     dword ptr [eax+ecx*4], 0
.text$mn:0000662D                 jnz     short loc_6650
.text$mn:0000662F                 push    1
.text$mn:00006631                 lea     edx, [ebp+var_1]
.text$mn:00006634                 push    edx
.text$mn:00006635                 mov     ecx, [ebp+var_8]
.text$mn:00006638                 call    ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<RecentItem,std::allocator<RecentItem>>>::_Getal(void)
.text$mn:0000663D                 mov     ecx, eax
.text$mn:0000663F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAEPAURecentItem@@I@Z ; std::_Wrap_alloc<std::allocator<RecentItem>>::allocate(uint)
.text$mn:00006644                 mov     ecx, [ebp+var_8]
.text$mn:00006647                 mov     edx, [ecx+4]
.text$mn:0000664A                 mov     ecx, [ebp+var_10]
.text$mn:0000664D                 mov     [edx+ecx*4], eax
.text$mn:00006650
.text$mn:00006650 loc_6650:                               ; CODE XREF: std::deque<RecentItem,std::allocator<RecentItem>>::push_front(RecentItem const &)+9Dj
.text$mn:00006650                 mov     edx, [ebp+arg_0]
.text$mn:00006653                 push    edx             ; int
.text$mn:00006654                 mov     eax, [ebp+var_8]
.text$mn:00006657                 mov     ecx, [eax+4]
.text$mn:0000665A                 mov     eax, [ebp+var_C]
.text$mn:0000665D                 xor     edx, edx
.text$mn:0000665F                 mov     esi, 1
.text$mn:00006664                 div     esi
.text$mn:00006666                 shl     edx, 5
.text$mn:00006669                 mov     eax, [ebp+var_10]
.text$mn:0000666C                 add     edx, [ecx+eax*4]
.text$mn:0000666F                 push    edx             ; void *
.text$mn:00006670                 lea     ecx, [ebp+var_2]
.text$mn:00006673                 push    ecx
.text$mn:00006674                 mov     ecx, [ebp+var_8]
.text$mn:00006677                 call    ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<RecentItem,std::allocator<RecentItem>>>::_Getal(void)
.text$mn:0000667C                 mov     ecx, eax
.text$mn:0000667E                 call    ??$construct@URecentItem@@ABU1@@?$_Wrap_alloc@V?$allocator@URecentItem@@@std@@@std@@QAEXPAURecentItem@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<RecentItem>>::construct<RecentItem,RecentItem const &>(RecentItem *,RecentItem const &)
.text$mn:00006683                 mov     edx, [ebp+var_8]
.text$mn:00006686                 mov     eax, [ebp+var_C]
.text$mn:00006689                 mov     [edx+0Ch], eax
.text$mn:0000668C                 mov     ecx, [ebp+var_8]
.text$mn:0000668F                 mov     edx, [ecx+10h]
.text$mn:00006692                 add     edx, 1
.text$mn:00006695                 mov     eax, [ebp+var_8]
.text$mn:00006698                 mov     [eax+10h], edx
.text$mn:0000669B                 pop     esi
.text$mn:0000669C                 mov     esp, ebp
.text$mn:0000669E                 pop     ebp
.text$mn:0000669F                 retn    4
.text$mn:0000669F ?push_front@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEXABURecentItem@@@Z endp
.text$mn:0000669F
.text$mn:0000669F ; ---------------------------------------------------------------------------
.text$mn:000066A2                 align 4
.text$mn:000066A2 _text$mn        ends
.text$mn:000066A2
.text$mn:000066A4 ; ===========================================================================
.text$mn:000066A4
.text$mn:000066A4 ; Segment type: Pure code
.text$mn:000066A4 ; Segment permissions: Read/Execute
.text$mn:000066A4 _text$mn        segment para public 'CODE' use32
.text$mn:000066A4                 assume cs:_text$mn
.text$mn:000066A4                 ;org 66A4h
.text$mn:000066A4 ; COMDAT (pick any)
.text$mn:000066A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066A4
.text$mn:000066A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000066A4
.text$mn:000066A4 ; Attributes: bp-based frame
.text$mn:000066A4
.text$mn:000066A4 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::select_on_container_copy_construction(void)const
.text$mn:000066A4                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ
.text$mn:000066A4 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ proc near
.text$mn:000066A4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Ap
.text$mn:000066A4
.text$mn:000066A4 var_8           = dword ptr -8
.text$mn:000066A4 var_1           = byte ptr -1
.text$mn:000066A4 arg_0           = dword ptr  8
.text$mn:000066A4
.text$mn:000066A4                 push    ebp
.text$mn:000066A5                 mov     ebp, esp
.text$mn:000066A7                 sub     esp, 8
.text$mn:000066AA                 mov     [ebp+var_8], ecx
.text$mn:000066AD                 mov     eax, [ebp+var_8]
.text$mn:000066B0                 push    eax
.text$mn:000066B1                 lea     ecx, [ebp+var_1]
.text$mn:000066B4                 push    ecx
.text$mn:000066B5                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ; std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)
.text$mn:000066BA                 add     esp, 8
.text$mn:000066BD                 push    eax
.text$mn:000066BE                 mov     ecx, [ebp+arg_0]
.text$mn:000066C1                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(std::allocator<wchar_t> const &)
.text$mn:000066C6                 mov     eax, [ebp+arg_0]
.text$mn:000066C9                 mov     esp, ebp
.text$mn:000066CB                 pop     ebp
.text$mn:000066CC                 retn    4
.text$mn:000066CC ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ endp
.text$mn:000066CC
.text$mn:000066CC ; ---------------------------------------------------------------------------
.text$mn:000066CF                 align 10h
.text$mn:000066CF _text$mn        ends
.text$mn:000066CF
.text$mn:000066D0 ; ===========================================================================
.text$mn:000066D0
.text$mn:000066D0 ; Segment type: Pure code
.text$mn:000066D0 ; Segment permissions: Read/Execute
.text$mn:000066D0 _text$mn        segment para public 'CODE' use32
.text$mn:000066D0                 assume cs:_text$mn
.text$mn:000066D0                 ;org 66D0h
.text$mn:000066D0 ; COMDAT (pick any)
.text$mn:000066D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066D0
.text$mn:000066D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000066D0
.text$mn:000066D0 ; Attributes: bp-based frame
.text$mn:000066D0
.text$mn:000066D0 ; public: class std::allocator<wchar_t> __thiscall std::allocator<wchar_t>::select_on_container_copy_construction(void)const
.text$mn:000066D0                 public ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ
.text$mn:000066D0 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ proc near
.text$mn:000066D0                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)+Ap
.text$mn:000066D0
.text$mn:000066D0 var_4           = dword ptr -4
.text$mn:000066D0 arg_0           = dword ptr  8
.text$mn:000066D0
.text$mn:000066D0                 push    ebp
.text$mn:000066D1                 mov     ebp, esp
.text$mn:000066D3                 push    ecx
.text$mn:000066D4                 mov     [ebp+var_4], ecx
.text$mn:000066D7                 mov     eax, [ebp+var_4]
.text$mn:000066DA                 push    eax
.text$mn:000066DB                 mov     ecx, [ebp+arg_0]
.text$mn:000066DE                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:000066E3                 mov     eax, [ebp+arg_0]
.text$mn:000066E6                 mov     esp, ebp
.text$mn:000066E8                 pop     ebp
.text$mn:000066E9                 retn    4
.text$mn:000066E9 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ endp
.text$mn:000066E9
.text$mn:000066E9 _text$mn        ends
.text$mn:000066E9
.text$mn:000066EC ; ===========================================================================
.text$mn:000066EC
.text$mn:000066EC ; Segment type: Pure code
.text$mn:000066EC ; Segment permissions: Read/Execute
.text$mn:000066EC _text$mn        segment para public 'CODE' use32
.text$mn:000066EC                 assume cs:_text$mn
.text$mn:000066EC                 ;org 66ECh
.text$mn:000066EC ; COMDAT (pick any)
.text$mn:000066EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066EC
.text$mn:000066EC ; =============== S U B R O U T I N E =======================================
.text$mn:000066EC
.text$mn:000066EC ; Attributes: bp-based frame
.text$mn:000066EC
.text$mn:000066EC ; public: static class std::allocator<wchar_t> __cdecl std::allocator_traits<class std::allocator<wchar_t>>::select_on_container_copy_construction(class std::allocator<wchar_t> const &)
.text$mn:000066EC                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
.text$mn:000066EC ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z proc near
.text$mn:000066EC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+11p
.text$mn:000066EC
.text$mn:000066EC arg_0           = dword ptr  8
.text$mn:000066EC arg_4           = dword ptr  0Ch
.text$mn:000066EC
.text$mn:000066EC                 push    ebp
.text$mn:000066ED                 mov     ebp, esp
.text$mn:000066EF                 mov     eax, [ebp+arg_0]
.text$mn:000066F2                 push    eax
.text$mn:000066F3                 mov     ecx, [ebp+arg_4]
.text$mn:000066F6                 call    ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ ; std::allocator<wchar_t>::select_on_container_copy_construction(void)
.text$mn:000066FB                 mov     eax, [ebp+arg_0]
.text$mn:000066FE                 pop     ebp
.text$mn:000066FF                 retn
.text$mn:000066FF ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z endp
.text$mn:000066FF
.text$mn:000066FF _text$mn        ends
.text$mn:000066FF
.text$mn:00006700 ; ===========================================================================
.text$mn:00006700
.text$mn:00006700 ; Segment type: Pure code
.text$mn:00006700 ; Segment permissions: Read/Execute
.text$mn:00006700 _text$mn        segment para public 'CODE' use32
.text$mn:00006700                 assume cs:_text$mn
.text$mn:00006700                 ;org 6700h
.text$mn:00006700 ; COMDAT (pick any)
.text$mn:00006700                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006700
.text$mn:00006700 ; =============== S U B R O U T I N E =======================================
.text$mn:00006700
.text$mn:00006700 ; Attributes: bp-based frame
.text$mn:00006700
.text$mn:00006700 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00006700                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00006700 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00006700                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00006700                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00006700
.text$mn:00006700 var_4           = dword ptr -4
.text$mn:00006700
.text$mn:00006700                 push    ebp
.text$mn:00006701                 mov     ebp, esp
.text$mn:00006703                 push    ecx
.text$mn:00006704                 mov     [ebp+var_4], ecx
.text$mn:00006707                 mov     eax, [ebp+var_4]
.text$mn:0000670A                 mov     eax, [eax+14h]
.text$mn:0000670D                 mov     esp, ebp
.text$mn:0000670F                 pop     ebp
.text$mn:00006710                 retn
.text$mn:00006710 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00006710
.text$mn:00006710 ; ---------------------------------------------------------------------------
.text$mn:00006711                 align 4
.text$mn:00006711 _text$mn        ends
.text$mn:00006711
.text$mn:00006714 ; ===========================================================================
.text$mn:00006714
.text$mn:00006714 ; Segment type: Pure code
.text$mn:00006714 ; Segment permissions: Read/Execute
.text$mn:00006714 _text$mn        segment para public 'CODE' use32
.text$mn:00006714                 assume cs:_text$mn
.text$mn:00006714                 ;org 6714h
.text$mn:00006714 ; COMDAT (pick any)
.text$mn:00006714                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006714
.text$mn:00006714 ; =============== S U B R O U T I N E =======================================
.text$mn:00006714
.text$mn:00006714 ; Attributes: bp-based frame
.text$mn:00006714
.text$mn:00006714 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:00006714                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00006714 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00006714                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:00006714                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p
.text$mn:00006714
.text$mn:00006714 var_4           = dword ptr -4
.text$mn:00006714
.text$mn:00006714                 push    ebp
.text$mn:00006715                 mov     ebp, esp
.text$mn:00006717                 push    ecx
.text$mn:00006718                 mov     [ebp+var_4], ecx
.text$mn:0000671B                 mov     eax, [ebp+var_4]
.text$mn:0000671E                 mov     eax, [eax+14h]
.text$mn:00006721                 mov     esp, ebp
.text$mn:00006723                 pop     ebp
.text$mn:00006724                 retn
.text$mn:00006724 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00006724
.text$mn:00006724 ; ---------------------------------------------------------------------------
.text$mn:00006725                 align 4
.text$mn:00006725 _text$mn        ends
.text$mn:00006725
.text$mn:00006728 ; ===========================================================================
.text$mn:00006728
.text$mn:00006728 ; Segment type: Pure code
.text$mn:00006728 ; Segment permissions: Read/Execute
.text$mn:00006728 _text$mn        segment para public 'CODE' use32
.text$mn:00006728                 assume cs:_text$mn
.text$mn:00006728                 ;org 6728h
.text$mn:00006728 ; COMDAT (pick any)
.text$mn:00006728                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006728
.text$mn:00006728 ; =============== S U B R O U T I N E =======================================
.text$mn:00006728
.text$mn:00006728 ; Attributes: bp-based frame
.text$mn:00006728
.text$mn:00006728 ; public: unsigned int __thiscall std::deque<struct RecentItem, class std::allocator<struct RecentItem>>::size(void)const
.text$mn:00006728                 public ?size@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBEIXZ
.text$mn:00006728 ?size@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBEIXZ proc near
.text$mn:00006728                                         ; CODE XREF: LastRecentFileList::remove(int)+4Ep
.text$mn:00006728
.text$mn:00006728 var_4           = dword ptr -4
.text$mn:00006728
.text$mn:00006728                 push    ebp
.text$mn:00006729                 mov     ebp, esp
.text$mn:0000672B                 push    ecx
.text$mn:0000672C                 mov     [ebp+var_4], ecx
.text$mn:0000672F                 mov     eax, [ebp+var_4]
.text$mn:00006732                 mov     eax, [eax+10h]
.text$mn:00006735                 mov     esp, ebp
.text$mn:00006737                 pop     ebp
.text$mn:00006738                 retn
.text$mn:00006738 ?size@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBEIXZ endp
.text$mn:00006738
.text$mn:00006738 ; ---------------------------------------------------------------------------
.text$mn:00006739                 align 4
.text$mn:00006739 _text$mn        ends
.text$mn:00006739
.text$mn:0000673C ; ===========================================================================
.text$mn:0000673C
.text$mn:0000673C ; Segment type: Pure code
.text$mn:0000673C ; Segment permissions: Read/Execute
.text$mn:0000673C _text$mn        segment para public 'CODE' use32
.text$mn:0000673C                 assume cs:_text$mn
.text$mn:0000673C                 ;org 673Ch
.text$mn:0000673C ; COMDAT (pick any)
.text$mn:0000673C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000673C
.text$mn:0000673C ; =============== S U B R O U T I N E =======================================
.text$mn:0000673C
.text$mn:0000673C ; Attributes: bp-based frame
.text$mn:0000673C
.text$mn:0000673C ; const struct std::error_category *__cdecl std::system_category()
.text$mn:0000673C                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:0000673C ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:0000673C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_5534p
.text$mn:0000673C                 push    ebp
.text$mn:0000673D                 mov     ebp, esp
.text$mn:0000673F                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00006744                 pop     ebp
.text$mn:00006745                 retn
.text$mn:00006745 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00006745
.text$mn:00006745 ; ---------------------------------------------------------------------------
.text$mn:00006746                 align 4
.text$mn:00006746 _text$mn        ends
.text$mn:00006746
.text$mn:00006748 ; ===========================================================================
.text$mn:00006748
.text$mn:00006748 ; Segment type: Pure code
.text$mn:00006748 ; Segment permissions: Read/Execute
.text$mn:00006748 _text$mn        segment para public 'CODE' use32
.text$mn:00006748                 assume cs:_text$mn
.text$mn:00006748                 ;org 6748h
.text$mn:00006748 ; COMDAT (pick any)
.text$mn:00006748                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006748
.text$mn:00006748 ; =============== S U B R O U T I N E =======================================
.text$mn:00006748
.text$mn:00006748 ; Attributes: bp-based frame
.text$mn:00006748
.text$mn:00006748 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00006748                 public ?value@error_code@std@@QBEHXZ
.text$mn:00006748 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00006748
.text$mn:00006748 var_4           = dword ptr -4
.text$mn:00006748
.text$mn:00006748                 push    ebp
.text$mn:00006749                 mov     ebp, esp
.text$mn:0000674B                 push    ecx
.text$mn:0000674C                 mov     [ebp+var_4], ecx
.text$mn:0000674F                 mov     eax, [ebp+var_4]
.text$mn:00006752                 mov     eax, [eax]
.text$mn:00006754                 mov     esp, ebp
.text$mn:00006756                 pop     ebp
.text$mn:00006757                 retn
.text$mn:00006757 ?value@error_code@std@@QBEHXZ endp
.text$mn:00006757
.text$mn:00006757 _text$mn        ends
.text$mn:00006757
.text$mn:00006758 ; ===========================================================================
.text$mn:00006758
.text$mn:00006758 ; Segment type: Pure code
.text$mn:00006758 ; Segment permissions: Read/Execute
.text$mn:00006758 _text$mn        segment para public 'CODE' use32
.text$mn:00006758                 assume cs:_text$mn
.text$mn:00006758                 ;org 6758h
.text$mn:00006758 ; COMDAT (pick any)
.text$mn:00006758                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006758
.text$mn:00006758 ; =============== S U B R O U T I N E =======================================
.text$mn:00006758
.text$mn:00006758 ; Attributes: bp-based frame
.text$mn:00006758
.text$mn:00006758 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00006758                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00006758 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00006758                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00006758                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00006758
.text$mn:00006758 var_4           = dword ptr -4
.text$mn:00006758
.text$mn:00006758                 push    ebp
.text$mn:00006759                 mov     ebp, esp
.text$mn:0000675B                 push    ecx
.text$mn:0000675C                 mov     [ebp+var_4], ecx
.text$mn:0000675F                 mov     eax, [ebp+var_4]
.text$mn:00006762                 mov     eax, [eax]
.text$mn:00006764                 mov     esp, ebp
.text$mn:00006766                 pop     ebp
.text$mn:00006767                 retn
.text$mn:00006767 ?value@error_condition@std@@QBEHXZ endp
.text$mn:00006767
.text$mn:00006767 _text$mn        ends
.text$mn:00006767
.text$mn:00006768 ; ===========================================================================
.text$mn:00006768
.text$mn:00006768 ; Segment type: Pure code
.text$mn:00006768 ; Segment permissions: Read/Execute
.text$mn:00006768 _text$mn        segment para public 'CODE' use32
.text$mn:00006768                 assume cs:_text$mn
.text$mn:00006768                 ;org 6768h
.text$mn:00006768 ; COMDAT (pick any)
.text$mn:00006768                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006768
.text$mn:00006768 ; =============== S U B R O U T I N E =======================================
.text$mn:00006768
.text$mn:00006768 ; Attributes: bp-based frame
.text$mn:00006768
.text$mn:00006768                 public _hypot
.text$mn:00006768 _hypot          proc near
.text$mn:00006768
.text$mn:00006768 var_10          = qword ptr -10h
.text$mn:00006768 var_8           = qword ptr -8
.text$mn:00006768 arg_0           = qword ptr  8
.text$mn:00006768 arg_8           = qword ptr  10h
.text$mn:00006768
.text$mn:00006768                 push    ebp
.text$mn:00006769                 mov     ebp, esp
.text$mn:0000676B                 sub     esp, 8
.text$mn:0000676E                 movsd   xmm0, [ebp+arg_8]
.text$mn:00006773                 movsd   [esp+8+var_8], xmm0
.text$mn:00006778                 sub     esp, 8
.text$mn:0000677B                 movsd   xmm0, [ebp+arg_0]
.text$mn:00006780                 movsd   [esp+10h+var_10], xmm0
.text$mn:00006785                 call    __hypot
.text$mn:0000678A                 add     esp, 10h
.text$mn:0000678D                 pop     ebp
.text$mn:0000678E                 retn
.text$mn:0000678E _hypot          endp
.text$mn:0000678E
.text$mn:0000678E ; ---------------------------------------------------------------------------
.text$mn:0000678F                 align 10h
.text$mn:0000678F _text$mn        ends
.text$mn:0000678F
.text$mn:00006790 ; ===========================================================================
.text$mn:00006790
.text$mn:00006790 ; Segment type: Pure code
.text$mn:00006790 ; Segment permissions: Read/Execute
.text$mn:00006790 _text$mn        segment para public 'CODE' use32
.text$mn:00006790                 assume cs:_text$mn
.text$mn:00006790                 ;org 6790h
.text$mn:00006790 ; COMDAT (pick any)
.text$mn:00006790                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006790
.text$mn:00006790 ; =============== S U B R O U T I N E =======================================
.text$mn:00006790
.text$mn:00006790 ; Attributes: bp-based frame
.text$mn:00006790
.text$mn:00006790                 public _wmemcmp
.text$mn:00006790 _wmemcmp        proc near               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+1Fp
.text$mn:00006790
.text$mn:00006790 var_4           = dword ptr -4
.text$mn:00006790 arg_0           = dword ptr  8
.text$mn:00006790 arg_4           = dword ptr  0Ch
.text$mn:00006790 arg_8           = dword ptr  10h
.text$mn:00006790
.text$mn:00006790                 push    ebp
.text$mn:00006791                 mov     ebp, esp
.text$mn:00006793                 push    ecx
.text$mn:00006794                 jmp     short loc_67B1
.text$mn:00006796 ; ---------------------------------------------------------------------------
.text$mn:00006796
.text$mn:00006796 loc_6796:                               ; CODE XREF: _wmemcmp:loc_67ECj
.text$mn:00006796                 mov     eax, [ebp+arg_0]
.text$mn:00006799                 add     eax, 2
.text$mn:0000679C                 mov     [ebp+arg_0], eax
.text$mn:0000679F                 mov     ecx, [ebp+arg_4]
.text$mn:000067A2                 add     ecx, 2
.text$mn:000067A5                 mov     [ebp+arg_4], ecx
.text$mn:000067A8                 mov     edx, [ebp+arg_8]
.text$mn:000067AB                 sub     edx, 1
.text$mn:000067AE                 mov     [ebp+arg_8], edx
.text$mn:000067B1
.text$mn:000067B1 loc_67B1:                               ; CODE XREF: _wmemcmp+4j
.text$mn:000067B1                 cmp     [ebp+arg_8], 0
.text$mn:000067B5                 jbe     short loc_67EE
.text$mn:000067B7                 mov     eax, [ebp+arg_0]
.text$mn:000067BA                 movzx   ecx, word ptr [eax]
.text$mn:000067BD                 mov     edx, [ebp+arg_4]
.text$mn:000067C0                 movzx   eax, word ptr [edx]
.text$mn:000067C3                 cmp     ecx, eax
.text$mn:000067C5                 jz      short loc_67EC
.text$mn:000067C7                 mov     ecx, [ebp+arg_0]
.text$mn:000067CA                 movzx   edx, word ptr [ecx]
.text$mn:000067CD                 mov     eax, [ebp+arg_4]
.text$mn:000067D0                 movzx   ecx, word ptr [eax]
.text$mn:000067D3                 cmp     edx, ecx
.text$mn:000067D5                 jge     short loc_67E0
.text$mn:000067D7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000067DE                 jmp     short loc_67E7
.text$mn:000067E0 ; ---------------------------------------------------------------------------
.text$mn:000067E0
.text$mn:000067E0 loc_67E0:                               ; CODE XREF: _wmemcmp+45j
.text$mn:000067E0                 mov     [ebp+var_4], 1
.text$mn:000067E7
.text$mn:000067E7 loc_67E7:                               ; CODE XREF: _wmemcmp+4Ej
.text$mn:000067E7                 mov     eax, [ebp+var_4]
.text$mn:000067EA                 jmp     short loc_67F0
.text$mn:000067EC ; ---------------------------------------------------------------------------
.text$mn:000067EC
.text$mn:000067EC loc_67EC:                               ; CODE XREF: _wmemcmp+35j
.text$mn:000067EC                 jmp     short loc_6796
.text$mn:000067EE ; ---------------------------------------------------------------------------
.text$mn:000067EE
.text$mn:000067EE loc_67EE:                               ; CODE XREF: _wmemcmp+25j
.text$mn:000067EE                 xor     eax, eax
.text$mn:000067F0
.text$mn:000067F0 loc_67F0:                               ; CODE XREF: _wmemcmp+5Aj
.text$mn:000067F0                 mov     esp, ebp
.text$mn:000067F2                 pop     ebp
.text$mn:000067F3                 retn
.text$mn:000067F3 _wmemcmp        endp
.text$mn:000067F3
.text$mn:000067F3 _text$mn        ends
.text$mn:000067F3
.text$mn:000067F4 ; ===========================================================================
.text$mn:000067F4
.text$mn:000067F4 ; Segment type: Pure code
.text$mn:000067F4 ; Segment permissions: Read/Execute
.text$mn:000067F4 _text$mn        segment para public 'CODE' use32
.text$mn:000067F4                 assume cs:_text$mn
.text$mn:000067F4                 ;org 67F4h
.text$mn:000067F4 ; COMDAT (pick any)
.text$mn:000067F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000067F4
.text$mn:000067F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000067F4
.text$mn:000067F4 ; Attributes: bp-based frame
.text$mn:000067F4
.text$mn:000067F4 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:000067F4                 public _wmemcpy
.text$mn:000067F4 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:000067F4
.text$mn:000067F4 Dst             = dword ptr  8
.text$mn:000067F4 Src             = dword ptr  0Ch
.text$mn:000067F4 arg_8           = dword ptr  10h
.text$mn:000067F4
.text$mn:000067F4                 push    ebp
.text$mn:000067F5                 mov     ebp, esp
.text$mn:000067F7                 mov     eax, [ebp+arg_8]
.text$mn:000067FA                 shl     eax, 1
.text$mn:000067FC                 push    eax             ; Size
.text$mn:000067FD                 mov     ecx, [ebp+Src]
.text$mn:00006800                 push    ecx             ; Src
.text$mn:00006801                 mov     edx, [ebp+Dst]
.text$mn:00006804                 push    edx             ; Dst
.text$mn:00006805                 call    _memcpy
.text$mn:0000680A                 add     esp, 0Ch
.text$mn:0000680D                 pop     ebp
.text$mn:0000680E                 retn
.text$mn:0000680E _wmemcpy        endp
.text$mn:0000680E
.text$mn:0000680E ; ---------------------------------------------------------------------------
.text$mn:0000680F                 align 10h
.text$mn:0000680F _text$mn        ends
.text$mn:0000680F
.text$mn:00006810 ; ===========================================================================
.text$mn:00006810
.text$mn:00006810 ; Segment type: Pure code
.text$mn:00006810 ; Segment permissions: Read/Execute
.text$mn:00006810 _text$mn        segment para public 'CODE' use32
.text$mn:00006810                 assume cs:_text$mn
.text$mn:00006810                 ;org 6810h
.text$mn:00006810 ; COMDAT (pick any)
.text$mn:00006810                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006810
.text$mn:00006810 ; =============== S U B R O U T I N E =======================================
.text$mn:00006810
.text$mn:00006810 ; Attributes: bp-based frame
.text$mn:00006810
.text$mn:00006810 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:00006810                 public _wmemmove
.text$mn:00006810 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00006810
.text$mn:00006810 Dst             = dword ptr  8
.text$mn:00006810 Src             = dword ptr  0Ch
.text$mn:00006810 arg_8           = dword ptr  10h
.text$mn:00006810
.text$mn:00006810                 push    ebp
.text$mn:00006811                 mov     ebp, esp
.text$mn:00006813                 mov     eax, [ebp+arg_8]
.text$mn:00006816                 shl     eax, 1
.text$mn:00006818                 push    eax             ; Size
.text$mn:00006819                 mov     ecx, [ebp+Src]
.text$mn:0000681C                 push    ecx             ; Src
.text$mn:0000681D                 mov     edx, [ebp+Dst]
.text$mn:00006820                 push    edx             ; Dst
.text$mn:00006821                 call    _memmove
.text$mn:00006826                 add     esp, 0Ch
.text$mn:00006829                 pop     ebp
.text$mn:0000682A                 retn
.text$mn:0000682A _wmemmove       endp
.text$mn:0000682A
.text$mn:0000682A ; ---------------------------------------------------------------------------
.text$mn:0000682B                 align 4
.text$mn:0000682B _text$mn        ends
.text$mn:0000682B
.xdata$x:0000682C ; ===========================================================================
.xdata$x:0000682C
.xdata$x:0000682C ; Segment type: Pure data
.xdata$x:0000682C ; Segment permissions: Read
.xdata$x:0000682C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000682C                 assume cs:_xdata$x
.xdata$x:0000682C                 ;org 682Ch
.xdata$x:0000682C ; COMDAT (pick associative to section at 46CC)
.xdata$x:0000682C __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:0000682C                                         ; DATA XREF: .xdata$x:0000683Co
.xdata$x:0000682D                 db 0FFh
.xdata$x:0000682E                 db 0FFh
.xdata$x:0000682F                 db 0FFh
.xdata$x:00006830                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00006834 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00006834                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00006835                 db    5
.xdata$x:00006836                 db  93h ; ô
.xdata$x:00006837                 db  19h
.xdata$x:00006838                 db    1
.xdata$x:00006839                 db    0
.xdata$x:0000683A                 db    0
.xdata$x:0000683B                 db    0
.xdata$x:0000683C                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00006840                 db    0
.xdata$x:00006841                 db    0
.xdata$x:00006842                 db    0
.xdata$x:00006843                 db    0
.xdata$x:00006844                 db    0
.xdata$x:00006845                 db    0
.xdata$x:00006846                 db    0
.xdata$x:00006847                 db    0
.xdata$x:00006848                 db    0
.xdata$x:00006849                 db    0
.xdata$x:0000684A                 db    0
.xdata$x:0000684B                 db    0
.xdata$x:0000684C                 db    0
.xdata$x:0000684D                 db    0
.xdata$x:0000684E                 db    0
.xdata$x:0000684F                 db    0
.xdata$x:00006850                 db    0
.xdata$x:00006851                 db    0
.xdata$x:00006852                 db    0
.xdata$x:00006853                 db    0
.xdata$x:00006854                 db    0
.xdata$x:00006855                 db    0
.xdata$x:00006856                 db    0
.xdata$x:00006857                 db    0
.xdata$x:00006857 _xdata$x        ends
.xdata$x:00006857
.xdata$x:00006858 ; ===========================================================================
.xdata$x:00006858
.xdata$x:00006858 ; Segment type: Pure data
.xdata$x:00006858 ; Segment permissions: Read
.xdata$x:00006858 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006858                 assume cs:_xdata$x
.xdata$x:00006858                 ;org 6858h
.xdata$x:00006858 ; COMDAT (pick associative to section at 3020)
.xdata$x:00006858 __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:00006858                                         ; DATA XREF: .xdata$x:00006868o
.xdata$x:00006859                 db 0FFh
.xdata$x:0000685A                 db 0FFh
.xdata$x:0000685B                 db 0FFh
.xdata$x:0000685C                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:00006860 __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:00006860                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:00006861                 db    5
.xdata$x:00006862                 db  93h ; ô
.xdata$x:00006863                 db  19h
.xdata$x:00006864                 db    1
.xdata$x:00006865                 db    0
.xdata$x:00006866                 db    0
.xdata$x:00006867                 db    0
.xdata$x:00006868                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:0000686C                 db    0
.xdata$x:0000686D                 db    0
.xdata$x:0000686E                 db    0
.xdata$x:0000686F                 db    0
.xdata$x:00006870                 db    0
.xdata$x:00006871                 db    0
.xdata$x:00006872                 db    0
.xdata$x:00006873                 db    0
.xdata$x:00006874                 db    0
.xdata$x:00006875                 db    0
.xdata$x:00006876                 db    0
.xdata$x:00006877                 db    0
.xdata$x:00006878                 db    0
.xdata$x:00006879                 db    0
.xdata$x:0000687A                 db    0
.xdata$x:0000687B                 db    0
.xdata$x:0000687C                 db    0
.xdata$x:0000687D                 db    0
.xdata$x:0000687E                 db    0
.xdata$x:0000687F                 db    0
.xdata$x:00006880                 db    0
.xdata$x:00006881                 db    0
.xdata$x:00006882                 db    0
.xdata$x:00006883                 db    0
.xdata$x:00006883 _xdata$x        ends
.xdata$x:00006883
.xdata$x:00006884 ; ===========================================================================
.xdata$x:00006884
.xdata$x:00006884 ; Segment type: Pure data
.xdata$x:00006884 ; Segment permissions: Read
.xdata$x:00006884 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006884                 assume cs:_xdata$x
.xdata$x:00006884                 ;org 6884h
.xdata$x:00006884 ; COMDAT (pick associative to section at 2E4C)
.xdata$x:00006884 __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:00006884                                         ; DATA XREF: .xdata$x:00006894o
.xdata$x:00006885                 db 0FFh
.xdata$x:00006886                 db 0FFh
.xdata$x:00006887                 db 0FFh
.xdata$x:00006888                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:0000688C __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:0000688C                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:0000688D                 db    5
.xdata$x:0000688E                 db  93h ; ô
.xdata$x:0000688F                 db  19h
.xdata$x:00006890                 db    1
.xdata$x:00006891                 db    0
.xdata$x:00006892                 db    0
.xdata$x:00006893                 db    0
.xdata$x:00006894                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:00006898                 db    0
.xdata$x:00006899                 db    0
.xdata$x:0000689A                 db    0
.xdata$x:0000689B                 db    0
.xdata$x:0000689C                 db    0
.xdata$x:0000689D                 db    0
.xdata$x:0000689E                 db    0
.xdata$x:0000689F                 db    0
.xdata$x:000068A0                 db    0
.xdata$x:000068A1                 db    0
.xdata$x:000068A2                 db    0
.xdata$x:000068A3                 db    0
.xdata$x:000068A4                 db    0
.xdata$x:000068A5                 db    0
.xdata$x:000068A6                 db    0
.xdata$x:000068A7                 db    0
.xdata$x:000068A8                 db    0
.xdata$x:000068A9                 db    0
.xdata$x:000068AA                 db    0
.xdata$x:000068AB                 db    0
.xdata$x:000068AC                 db    0
.xdata$x:000068AD                 db    0
.xdata$x:000068AE                 db    0
.xdata$x:000068AF                 db    0
.xdata$x:000068AF _xdata$x        ends
.xdata$x:000068AF
.xdata$x:000068B0 ; ===========================================================================
.xdata$x:000068B0
.xdata$x:000068B0 ; Segment type: Pure data
.xdata$x:000068B0 ; Segment permissions: Read
.xdata$x:000068B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000068B0                 assume cs:_xdata$x
.xdata$x:000068B0                 ;org 68B0h
.xdata$x:000068B0 ; COMDAT (pick associative to section at 39F0)
.xdata$x:000068B0 __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:000068B0                                         ; DATA XREF: .xdata$x:000068C8o
.xdata$x:000068B1                 db 0FFh
.xdata$x:000068B2                 db 0FFh
.xdata$x:000068B3                 db 0FFh
.xdata$x:000068B4                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:000068B8                 db 0FFh
.xdata$x:000068B9                 db 0FFh
.xdata$x:000068BA                 db 0FFh
.xdata$x:000068BB                 db 0FFh
.xdata$x:000068BC                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:000068C0 __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:000068C0                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:000068C1                 db    5
.xdata$x:000068C2                 db  93h ; ô
.xdata$x:000068C3                 db  19h
.xdata$x:000068C4                 db    2
.xdata$x:000068C5                 db    0
.xdata$x:000068C6                 db    0
.xdata$x:000068C7                 db    0
.xdata$x:000068C8                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:000068CC                 db    0
.xdata$x:000068CD                 db    0
.xdata$x:000068CE                 db    0
.xdata$x:000068CF                 db    0
.xdata$x:000068D0                 db    0
.xdata$x:000068D1                 db    0
.xdata$x:000068D2                 db    0
.xdata$x:000068D3                 db    0
.xdata$x:000068D4                 db    0
.xdata$x:000068D5                 db    0
.xdata$x:000068D6                 db    0
.xdata$x:000068D7                 db    0
.xdata$x:000068D8                 db    0
.xdata$x:000068D9                 db    0
.xdata$x:000068DA                 db    0
.xdata$x:000068DB                 db    0
.xdata$x:000068DC                 db    0
.xdata$x:000068DD                 db    0
.xdata$x:000068DE                 db    0
.xdata$x:000068DF                 db    0
.xdata$x:000068E0                 db    0
.xdata$x:000068E1                 db    0
.xdata$x:000068E2                 db    0
.xdata$x:000068E3                 db    0
.xdata$x:000068E3 _xdata$x        ends
.xdata$x:000068E3
.xdata$x:000068E4 ; ===========================================================================
.xdata$x:000068E4
.xdata$x:000068E4 ; Segment type: Pure data
.xdata$x:000068E4 ; Segment permissions: Read
.xdata$x:000068E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000068E4                 assume cs:_xdata$x
.xdata$x:000068E4                 ;org 68E4h
.xdata$x:000068E4 ; COMDAT (pick associative to section at 2230)
.xdata$x:000068E4 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000068E4                                         ; DATA XREF: .xdata$x:000068F4o
.xdata$x:000068E5                 db 0FFh
.xdata$x:000068E6                 db 0FFh
.xdata$x:000068E7                 db 0FFh
.xdata$x:000068E8                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000068EC __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000068EC                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000068ED                 db    5
.xdata$x:000068EE                 db  93h ; ô
.xdata$x:000068EF                 db  19h
.xdata$x:000068F0                 db    1
.xdata$x:000068F1                 db    0
.xdata$x:000068F2                 db    0
.xdata$x:000068F3                 db    0
.xdata$x:000068F4                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:000068F8                 db    0
.xdata$x:000068F9                 db    0
.xdata$x:000068FA                 db    0
.xdata$x:000068FB                 db    0
.xdata$x:000068FC                 db    0
.xdata$x:000068FD                 db    0
.xdata$x:000068FE                 db    0
.xdata$x:000068FF                 db    0
.xdata$x:00006900                 db    0
.xdata$x:00006901                 db    0
.xdata$x:00006902                 db    0
.xdata$x:00006903                 db    0
.xdata$x:00006904                 db    0
.xdata$x:00006905                 db    0
.xdata$x:00006906                 db    0
.xdata$x:00006907                 db    0
.xdata$x:00006908                 db    0
.xdata$x:00006909                 db    0
.xdata$x:0000690A                 db    0
.xdata$x:0000690B                 db    0
.xdata$x:0000690C                 db    0
.xdata$x:0000690D                 db    0
.xdata$x:0000690E                 db    0
.xdata$x:0000690F                 db    0
.xdata$x:0000690F _xdata$x        ends
.xdata$x:0000690F
.xdata$x:00006910 ; ===========================================================================
.xdata$x:00006910
.xdata$x:00006910 ; Segment type: Pure data
.xdata$x:00006910 ; Segment permissions: Read
.xdata$x:00006910 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006910                 assume cs:_xdata$x
.xdata$x:00006910                 ;org 6910h
.xdata$x:00006910 ; COMDAT (pick associative to section at 2B08)
.xdata$x:00006910 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00006910                                         ; DATA XREF: .xdata$x:00006920o
.xdata$x:00006911                 db 0FFh
.xdata$x:00006912                 db 0FFh
.xdata$x:00006913                 db 0FFh
.xdata$x:00006914                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00006918 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00006918                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00006919                 db    5
.xdata$x:0000691A                 db  93h ; ô
.xdata$x:0000691B                 db  19h
.xdata$x:0000691C                 db    1
.xdata$x:0000691D                 db    0
.xdata$x:0000691E                 db    0
.xdata$x:0000691F                 db    0
.xdata$x:00006920                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00006924                 db    0
.xdata$x:00006925                 db    0
.xdata$x:00006926                 db    0
.xdata$x:00006927                 db    0
.xdata$x:00006928                 db    0
.xdata$x:00006929                 db    0
.xdata$x:0000692A                 db    0
.xdata$x:0000692B                 db    0
.xdata$x:0000692C                 db    0
.xdata$x:0000692D                 db    0
.xdata$x:0000692E                 db    0
.xdata$x:0000692F                 db    0
.xdata$x:00006930                 db    0
.xdata$x:00006931                 db    0
.xdata$x:00006932                 db    0
.xdata$x:00006933                 db    0
.xdata$x:00006934                 db    0
.xdata$x:00006935                 db    0
.xdata$x:00006936                 db    0
.xdata$x:00006937                 db    0
.xdata$x:00006938                 db    0
.xdata$x:00006939                 db    0
.xdata$x:0000693A                 db    0
.xdata$x:0000693B                 db    0
.xdata$x:0000693B _xdata$x        ends
.xdata$x:0000693B
.xdata$x:0000693C ; ===========================================================================
.xdata$x:0000693C
.xdata$x:0000693C ; Segment type: Pure data
.xdata$x:0000693C ; Segment permissions: Read
.xdata$x:0000693C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000693C                 assume cs:_xdata$x
.xdata$x:0000693C                 ;org 693Ch
.xdata$x:0000693C ; COMDAT (pick associative to section at 2138)
.xdata$x:0000693C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:0000693C                                         ; DATA XREF: .xdata$x:0000694Co
.xdata$x:0000693D                 db 0FFh
.xdata$x:0000693E                 db 0FFh
.xdata$x:0000693F                 db 0FFh
.xdata$x:00006940                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00006944 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00006944                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00006945                 db    5
.xdata$x:00006946                 db  93h ; ô
.xdata$x:00006947                 db  19h
.xdata$x:00006948                 db    1
.xdata$x:00006949                 db    0
.xdata$x:0000694A                 db    0
.xdata$x:0000694B                 db    0
.xdata$x:0000694C                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00006950                 db    0
.xdata$x:00006951                 db    0
.xdata$x:00006952                 db    0
.xdata$x:00006953                 db    0
.xdata$x:00006954                 db    0
.xdata$x:00006955                 db    0
.xdata$x:00006956                 db    0
.xdata$x:00006957                 db    0
.xdata$x:00006958                 db    0
.xdata$x:00006959                 db    0
.xdata$x:0000695A                 db    0
.xdata$x:0000695B                 db    0
.xdata$x:0000695C                 db    0
.xdata$x:0000695D                 db    0
.xdata$x:0000695E                 db    0
.xdata$x:0000695F                 db    0
.xdata$x:00006960                 db    0
.xdata$x:00006961                 db    0
.xdata$x:00006962                 db    0
.xdata$x:00006963                 db    0
.xdata$x:00006964                 db    0
.xdata$x:00006965                 db    0
.xdata$x:00006966                 db    0
.xdata$x:00006967                 db    0
.xdata$x:00006967 _xdata$x        ends
.xdata$x:00006967
.xdata$x:00006968 ; ===========================================================================
.xdata$x:00006968
.xdata$x:00006968 ; Segment type: Pure data
.xdata$x:00006968 ; Segment permissions: Read
.xdata$x:00006968 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006968                 assume cs:_xdata$x
.xdata$x:00006968                 ;org 6968h
.xdata$x:00006968 ; COMDAT (pick associative to section at 2A18)
.xdata$x:00006968 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00006968                                         ; DATA XREF: .xdata$x:00006978o
.xdata$x:00006969                 db 0FFh
.xdata$x:0000696A                 db 0FFh
.xdata$x:0000696B                 db 0FFh
.xdata$x:0000696C                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00006970 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00006970                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00006971                 db    5
.xdata$x:00006972                 db  93h ; ô
.xdata$x:00006973                 db  19h
.xdata$x:00006974                 db    1
.xdata$x:00006975                 db    0
.xdata$x:00006976                 db    0
.xdata$x:00006977                 db    0
.xdata$x:00006978                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:0000697C                 db    0
.xdata$x:0000697D                 db    0
.xdata$x:0000697E                 db    0
.xdata$x:0000697F                 db    0
.xdata$x:00006980                 db    0
.xdata$x:00006981                 db    0
.xdata$x:00006982                 db    0
.xdata$x:00006983                 db    0
.xdata$x:00006984                 db    0
.xdata$x:00006985                 db    0
.xdata$x:00006986                 db    0
.xdata$x:00006987                 db    0
.xdata$x:00006988                 db    0
.xdata$x:00006989                 db    0
.xdata$x:0000698A                 db    0
.xdata$x:0000698B                 db    0
.xdata$x:0000698C                 db    0
.xdata$x:0000698D                 db    0
.xdata$x:0000698E                 db    0
.xdata$x:0000698F                 db    0
.xdata$x:00006990                 db    0
.xdata$x:00006991                 db    0
.xdata$x:00006992                 db    0
.xdata$x:00006993                 db    0
.xdata$x:00006993 _xdata$x        ends
.xdata$x:00006993
.xdata$x:00006994 ; ===========================================================================
.xdata$x:00006994
.xdata$x:00006994 ; Segment type: Pure data
.xdata$x:00006994 ; Segment permissions: Read
.xdata$x:00006994 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006994                 assume cs:_xdata$x
.xdata$x:00006994                 ;org 6994h
.xdata$x:00006994 ; COMDAT (pick associative to section at 23F4)
.xdata$x:00006994 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00006994                                         ; DATA XREF: .xdata$x:000069A4o
.xdata$x:00006995                 db 0FFh
.xdata$x:00006996                 db 0FFh
.xdata$x:00006997                 db 0FFh
.xdata$x:00006998                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:0000699C __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000699C                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:0000699D                 db    5
.xdata$x:0000699E                 db  93h ; ô
.xdata$x:0000699F                 db  19h
.xdata$x:000069A0                 db    1
.xdata$x:000069A1                 db    0
.xdata$x:000069A2                 db    0
.xdata$x:000069A3                 db    0
.xdata$x:000069A4                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:000069A8                 align 20h
.xdata$x:000069A8 _xdata$x        ends
.xdata$x:000069A8
.xdata$x:000069C0 ; ===========================================================================
.xdata$x:000069C0
.xdata$x:000069C0 ; Segment type: Pure data
.xdata$x:000069C0 ; Segment permissions: Read
.xdata$x:000069C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000069C0                 assume cs:_xdata$x
.xdata$x:000069C0                 ;org 69C0h
.xdata$x:000069C0 ; COMDAT (pick associative to section at 2BE8)
.xdata$x:000069C0 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:000069C0                                         ; DATA XREF: .xdata$x:000069D0o
.xdata$x:000069C1                 db 0FFh
.xdata$x:000069C2                 db 0FFh
.xdata$x:000069C3                 db 0FFh
.xdata$x:000069C4                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:000069C8 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000069C8                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:000069C9                 db    5
.xdata$x:000069CA                 db  93h ; ô
.xdata$x:000069CB                 db  19h
.xdata$x:000069CC                 db    1
.xdata$x:000069CD                 db    0
.xdata$x:000069CE                 db    0
.xdata$x:000069CF                 db    0
.xdata$x:000069D0                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:000069D4                 db    0
.xdata$x:000069D5                 db    0
.xdata$x:000069D6                 db    0
.xdata$x:000069D7                 db    0
.xdata$x:000069D8                 db    0
.xdata$x:000069D9                 db    0
.xdata$x:000069DA                 db    0
.xdata$x:000069DB                 db    0
.xdata$x:000069DC                 db    0
.xdata$x:000069DD                 db    0
.xdata$x:000069DE                 db    0
.xdata$x:000069DF                 db    0
.xdata$x:000069E0                 db    0
.xdata$x:000069E1                 db    0
.xdata$x:000069E2                 db    0
.xdata$x:000069E3                 db    0
.xdata$x:000069E4                 db    0
.xdata$x:000069E5                 db    0
.xdata$x:000069E6                 db    0
.xdata$x:000069E7                 db    0
.xdata$x:000069E8                 db    0
.xdata$x:000069E9                 db    0
.xdata$x:000069EA                 db    0
.xdata$x:000069EB                 db    0
.xdata$x:000069EB _xdata$x        ends
.xdata$x:000069EB
.xdata$x:000069EC ; ===========================================================================
.xdata$x:000069EC
.xdata$x:000069EC ; Segment type: Pure data
.xdata$x:000069EC ; Segment permissions: Read
.xdata$x:000069EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000069EC                 assume cs:_xdata$x
.xdata$x:000069EC                 ;org 69ECh
.xdata$x:000069EC ; COMDAT (pick associative to section at 3C28)
.xdata$x:000069EC __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:000069EC                                         ; DATA XREF: .xdata$x:00006A74o
.xdata$x:000069ED                 db    0
.xdata$x:000069EE                 db    0
.xdata$x:000069EF                 db    0
.xdata$x:000069F0                 db    0
.xdata$x:000069F1                 db    0
.xdata$x:000069F2                 db    0
.xdata$x:000069F3                 db    0
.xdata$x:000069F4                 db    0
.xdata$x:000069F5                 db    0
.xdata$x:000069F6                 db    0
.xdata$x:000069F7                 db    0
.xdata$x:000069F8                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:000069FC __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:000069FC                                         ; DATA XREF: .xdata$x:00006A60o
.xdata$x:000069FD                 db    0
.xdata$x:000069FE                 db    0
.xdata$x:000069FF                 db    0
.xdata$x:00006A00                 db    0
.xdata$x:00006A01                 db    0
.xdata$x:00006A02                 db    0
.xdata$x:00006A03                 db    0
.xdata$x:00006A04                 db    0
.xdata$x:00006A05                 db    0
.xdata$x:00006A06                 db    0
.xdata$x:00006A07                 db    0
.xdata$x:00006A08                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00006A0C __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00006A0C                                         ; DATA XREF: .xdata$x:00006A34o
.xdata$x:00006A0D                 db 0FFh
.xdata$x:00006A0E                 db 0FFh
.xdata$x:00006A0F                 db 0FFh
.xdata$x:00006A10                 db    0
.xdata$x:00006A11                 db    0
.xdata$x:00006A12                 db    0
.xdata$x:00006A13                 db    0
.xdata$x:00006A14                 db 0FFh
.xdata$x:00006A15                 db 0FFh
.xdata$x:00006A16                 db 0FFh
.xdata$x:00006A17                 db 0FFh
.xdata$x:00006A18                 db    0
.xdata$x:00006A19                 db    0
.xdata$x:00006A1A                 db    0
.xdata$x:00006A1B                 db    0
.xdata$x:00006A1C                 db    1
.xdata$x:00006A1D                 db    0
.xdata$x:00006A1E                 db    0
.xdata$x:00006A1F                 db    0
.xdata$x:00006A20                 db    0
.xdata$x:00006A21                 db    0
.xdata$x:00006A22                 db    0
.xdata$x:00006A23                 db    0
.xdata$x:00006A24                 db    1
.xdata$x:00006A25                 db    0
.xdata$x:00006A26                 db    0
.xdata$x:00006A27                 db    0
.xdata$x:00006A28                 db    0
.xdata$x:00006A29                 db    0
.xdata$x:00006A2A                 db    0
.xdata$x:00006A2B                 db    0
.xdata$x:00006A2C __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00006A2C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00006A2D                 db    5
.xdata$x:00006A2E                 db  93h ; ô
.xdata$x:00006A2F                 db  19h
.xdata$x:00006A30                 db    4
.xdata$x:00006A31                 db    0
.xdata$x:00006A32                 db    0
.xdata$x:00006A33                 db    0
.xdata$x:00006A34                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00006A38                 db    2
.xdata$x:00006A39                 db    0
.xdata$x:00006A3A                 db    0
.xdata$x:00006A3B                 db    0
.xdata$x:00006A3C                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00006A40                 db    0
.xdata$x:00006A41                 db    0
.xdata$x:00006A42                 db    0
.xdata$x:00006A43                 db    0
.xdata$x:00006A44                 db    0
.xdata$x:00006A45                 db    0
.xdata$x:00006A46                 db    0
.xdata$x:00006A47                 db    0
.xdata$x:00006A48                 db    0
.xdata$x:00006A49                 db    0
.xdata$x:00006A4A                 db    0
.xdata$x:00006A4B                 db    0
.xdata$x:00006A4C                 db    0
.xdata$x:00006A4D                 db    0
.xdata$x:00006A4E                 db    0
.xdata$x:00006A4F                 db    0
.xdata$x:00006A50 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00006A50                                         ; DATA XREF: .xdata$x:00006A3Co
.xdata$x:00006A51                 db    0
.xdata$x:00006A52                 db    0
.xdata$x:00006A53                 db    0
.xdata$x:00006A54                 db    2
.xdata$x:00006A55                 db    0
.xdata$x:00006A56                 db    0
.xdata$x:00006A57                 db    0
.xdata$x:00006A58                 db    3
.xdata$x:00006A59                 db    0
.xdata$x:00006A5A                 db    0
.xdata$x:00006A5B                 db    0
.xdata$x:00006A5C                 db    1
.xdata$x:00006A5D                 db    0
.xdata$x:00006A5E                 db    0
.xdata$x:00006A5F                 db    0
.xdata$x:00006A60                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00006A64                 db    0
.xdata$x:00006A65                 db    0
.xdata$x:00006A66                 db    0
.xdata$x:00006A67                 db    0
.xdata$x:00006A68                 db    0
.xdata$x:00006A69                 db    0
.xdata$x:00006A6A                 db    0
.xdata$x:00006A6B                 db    0
.xdata$x:00006A6C                 db    3
.xdata$x:00006A6D                 db    0
.xdata$x:00006A6E                 db    0
.xdata$x:00006A6F                 db    0
.xdata$x:00006A70                 db    1
.xdata$x:00006A71                 db    0
.xdata$x:00006A72                 db    0
.xdata$x:00006A73                 db    0
.xdata$x:00006A74                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00006A74 _xdata$x        ends
.xdata$x:00006A74
.xdata$x:00006A78 ; ===========================================================================
.xdata$x:00006A78
.xdata$x:00006A78 ; Segment type: Pure data
.xdata$x:00006A78 ; Segment permissions: Read
.xdata$x:00006A78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006A78                 assume cs:_xdata$x
.xdata$x:00006A78                 ;org 6A78h
.xdata$x:00006A78 ; COMDAT (pick associative to section at 271C)
.xdata$x:00006A78 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00006A78                                         ; DATA XREF: .xdata$x:00006A88o
.xdata$x:00006A79                 db 0FFh
.xdata$x:00006A7A                 db 0FFh
.xdata$x:00006A7B                 db 0FFh
.xdata$x:00006A7C                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00006A80 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00006A80                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00006A81                 db    5
.xdata$x:00006A82                 db  93h ; ô
.xdata$x:00006A83                 db  19h
.xdata$x:00006A84                 db    1
.xdata$x:00006A85                 db    0
.xdata$x:00006A86                 db    0
.xdata$x:00006A87                 db    0
.xdata$x:00006A88                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00006A8C                 db    0
.xdata$x:00006A8D                 db    0
.xdata$x:00006A8E                 db    0
.xdata$x:00006A8F                 db    0
.xdata$x:00006A90                 db    0
.xdata$x:00006A91                 db    0
.xdata$x:00006A92                 db    0
.xdata$x:00006A93                 db    0
.xdata$x:00006A94                 db    0
.xdata$x:00006A95                 db    0
.xdata$x:00006A96                 db    0
.xdata$x:00006A97                 db    0
.xdata$x:00006A98                 db    0
.xdata$x:00006A99                 db    0
.xdata$x:00006A9A                 db    0
.xdata$x:00006A9B                 db    0
.xdata$x:00006A9C                 db    0
.xdata$x:00006A9D                 db    0
.xdata$x:00006A9E                 db    0
.xdata$x:00006A9F                 db    0
.xdata$x:00006AA0                 db    0
.xdata$x:00006AA1                 db    0
.xdata$x:00006AA2                 db    0
.xdata$x:00006AA3                 db    0
.xdata$x:00006AA3 _xdata$x        ends
.xdata$x:00006AA3
.xdata$x:00006AA4 ; ===========================================================================
.xdata$x:00006AA4
.xdata$x:00006AA4 ; Segment type: Pure data
.xdata$x:00006AA4 ; Segment permissions: Read
.xdata$x:00006AA4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006AA4                 assume cs:_xdata$x
.xdata$x:00006AA4                 ;org 6AA4h
.xdata$x:00006AA4 ; COMDAT (pick associative to section at 614C)
.xdata$x:00006AA4 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00006AA4                                         ; DATA XREF: .xdata$x:00006AB4o
.xdata$x:00006AA5                 db 0FFh
.xdata$x:00006AA6                 db 0FFh
.xdata$x:00006AA7                 db 0FFh
.xdata$x:00006AA8                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00006AAC __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00006AAC                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00006AAD                 db    5
.xdata$x:00006AAE                 db  93h ; ô
.xdata$x:00006AAF                 db  19h
.xdata$x:00006AB0                 db    1
.xdata$x:00006AB1                 db    0
.xdata$x:00006AB2                 db    0
.xdata$x:00006AB3                 db    0
.xdata$x:00006AB4                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00006AB8                 db    0
.xdata$x:00006AB9                 db    0
.xdata$x:00006ABA                 db    0
.xdata$x:00006ABB                 db    0
.xdata$x:00006ABC                 db    0
.xdata$x:00006ABD                 db    0
.xdata$x:00006ABE                 db    0
.xdata$x:00006ABF                 db    0
.xdata$x:00006AC0                 db    0
.xdata$x:00006AC1                 db    0
.xdata$x:00006AC2                 db    0
.xdata$x:00006AC3                 db    0
.xdata$x:00006AC4                 db    0
.xdata$x:00006AC5                 db    0
.xdata$x:00006AC6                 db    0
.xdata$x:00006AC7                 db    0
.xdata$x:00006AC8                 db    0
.xdata$x:00006AC9                 db    0
.xdata$x:00006ACA                 db    0
.xdata$x:00006ACB                 db    0
.xdata$x:00006ACC                 db    0
.xdata$x:00006ACD                 db    0
.xdata$x:00006ACE                 db    0
.xdata$x:00006ACF                 db    0
.xdata$x:00006ACF _xdata$x        ends
.xdata$x:00006ACF
.xdata$x:00006AD0 ; ===========================================================================
.xdata$x:00006AD0
.xdata$x:00006AD0 ; Segment type: Pure data
.xdata$x:00006AD0 ; Segment permissions: Read
.xdata$x:00006AD0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006AD0                 assume cs:_xdata$x
.xdata$x:00006AD0                 ;org 6AD0h
.xdata$x:00006AD0 ; COMDAT (pick associative to section at 2D6C)
.xdata$x:00006AD0 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00006AD0                                         ; DATA XREF: .xdata$x:00006AE0o
.xdata$x:00006AD1                 db 0FFh
.xdata$x:00006AD2                 db 0FFh
.xdata$x:00006AD3                 db 0FFh
.xdata$x:00006AD4                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00006AD8 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00006AD8                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00006AD9                 db    5
.xdata$x:00006ADA                 db  93h ; ô
.xdata$x:00006ADB                 db  19h
.xdata$x:00006ADC                 db    1
.xdata$x:00006ADD                 db    0
.xdata$x:00006ADE                 db    0
.xdata$x:00006ADF                 db    0
.xdata$x:00006AE0                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00006AE4                 db    0
.xdata$x:00006AE5                 db    0
.xdata$x:00006AE6                 db    0
.xdata$x:00006AE7                 db    0
.xdata$x:00006AE8                 db    0
.xdata$x:00006AE9                 db    0
.xdata$x:00006AEA                 db    0
.xdata$x:00006AEB                 db    0
.xdata$x:00006AEC                 db    0
.xdata$x:00006AED                 db    0
.xdata$x:00006AEE                 db    0
.xdata$x:00006AEF                 db    0
.xdata$x:00006AF0                 db    0
.xdata$x:00006AF1                 db    0
.xdata$x:00006AF2                 db    0
.xdata$x:00006AF3                 db    0
.xdata$x:00006AF4                 db    0
.xdata$x:00006AF5                 db    0
.xdata$x:00006AF6                 db    0
.xdata$x:00006AF7                 db    0
.xdata$x:00006AF8                 db    0
.xdata$x:00006AF9                 db    0
.xdata$x:00006AFA                 db    0
.xdata$x:00006AFB                 db    0
.xdata$x:00006AFB _xdata$x        ends
.xdata$x:00006AFB
.xdata$x:00006AFC ; ===========================================================================
.xdata$x:00006AFC
.xdata$x:00006AFC ; Segment type: Pure data
.xdata$x:00006AFC ; Segment permissions: Read
.xdata$x:00006AFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006AFC                 assume cs:_xdata$x
.xdata$x:00006AFC                 ;org 6AFCh
.xdata$x:00006AFC ; COMDAT (pick associative to section at 2798)
.xdata$x:00006AFC __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00006AFC                                         ; DATA XREF: .xdata$x:00006B0Co
.xdata$x:00006AFD                 db 0FFh
.xdata$x:00006AFE                 db 0FFh
.xdata$x:00006AFF                 db 0FFh
.xdata$x:00006B00                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00006B04 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00006B04                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00006B05                 db    5
.xdata$x:00006B06                 db  93h ; ô
.xdata$x:00006B07                 db  19h
.xdata$x:00006B08                 db    1
.xdata$x:00006B09                 db    0
.xdata$x:00006B0A                 db    0
.xdata$x:00006B0B                 db    0
.xdata$x:00006B0C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00006B10                 db    0
.xdata$x:00006B11                 db    0
.xdata$x:00006B12                 db    0
.xdata$x:00006B13                 db    0
.xdata$x:00006B14                 db    0
.xdata$x:00006B15                 db    0
.xdata$x:00006B16                 db    0
.xdata$x:00006B17                 db    0
.xdata$x:00006B18                 db    0
.xdata$x:00006B19                 db    0
.xdata$x:00006B1A                 db    0
.xdata$x:00006B1B                 db    0
.xdata$x:00006B1C                 db    0
.xdata$x:00006B1D                 db    0
.xdata$x:00006B1E                 db    0
.xdata$x:00006B1F                 db    0
.xdata$x:00006B20                 db    0
.xdata$x:00006B21                 db    0
.xdata$x:00006B22                 db    0
.xdata$x:00006B23                 db    0
.xdata$x:00006B24                 db    0
.xdata$x:00006B25                 db    0
.xdata$x:00006B26                 db    0
.xdata$x:00006B27                 db    0
.xdata$x:00006B27 _xdata$x        ends
.xdata$x:00006B27
.xdata$x:00006B28 ; ===========================================================================
.xdata$x:00006B28
.xdata$x:00006B28 ; Segment type: Pure data
.xdata$x:00006B28 ; Segment permissions: Read
.xdata$x:00006B28 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006B28                 assume cs:_xdata$x
.xdata$x:00006B28                 ;org 6B28h
.xdata$x:00006B28 ; COMDAT (pick associative to section at 6204)
.xdata$x:00006B28 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00006B28                                         ; DATA XREF: .xdata$x:00006B38o
.xdata$x:00006B29                 db 0FFh
.xdata$x:00006B2A                 db 0FFh
.xdata$x:00006B2B                 db 0FFh
.xdata$x:00006B2C                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00006B30 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00006B30                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00006B31                 db    5
.xdata$x:00006B32                 db  93h ; ô
.xdata$x:00006B33                 db  19h
.xdata$x:00006B34                 db    1
.xdata$x:00006B35                 db    0
.xdata$x:00006B36                 db    0
.xdata$x:00006B37                 db    0
.xdata$x:00006B38                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00006B3C                 db    0
.xdata$x:00006B3D                 db    0
.xdata$x:00006B3E                 db    0
.xdata$x:00006B3F                 db    0
.xdata$x:00006B40                 db    0
.xdata$x:00006B41                 db    0
.xdata$x:00006B42                 db    0
.xdata$x:00006B43                 db    0
.xdata$x:00006B44                 db    0
.xdata$x:00006B45                 db    0
.xdata$x:00006B46                 db    0
.xdata$x:00006B47                 db    0
.xdata$x:00006B48                 db    0
.xdata$x:00006B49                 db    0
.xdata$x:00006B4A                 db    0
.xdata$x:00006B4B                 db    0
.xdata$x:00006B4C                 db    0
.xdata$x:00006B4D                 db    0
.xdata$x:00006B4E                 db    0
.xdata$x:00006B4F                 db    0
.xdata$x:00006B50                 db    0
.xdata$x:00006B51                 db    0
.xdata$x:00006B52                 db    0
.xdata$x:00006B53                 db    0
.xdata$x:00006B53 _xdata$x        ends
.xdata$x:00006B53
.xdata$x:00006B54 ; ===========================================================================
.xdata$x:00006B54
.xdata$x:00006B54 ; Segment type: Pure data
.xdata$x:00006B54 ; Segment permissions: Read
.xdata$x:00006B54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006B54                 assume cs:_xdata$x
.xdata$x:00006B54                 ;org 6B54h
.xdata$x:00006B54 ; COMDAT (pick associative to section at 2DDC)
.xdata$x:00006B54 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00006B54                                         ; DATA XREF: .xdata$x:00006B64o
.xdata$x:00006B55                 db 0FFh
.xdata$x:00006B56                 db 0FFh
.xdata$x:00006B57                 db 0FFh
.xdata$x:00006B58                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00006B5C __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00006B5C                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00006B5D                 db    5
.xdata$x:00006B5E                 db  93h ; ô
.xdata$x:00006B5F                 db  19h
.xdata$x:00006B60                 db    1
.xdata$x:00006B61                 db    0
.xdata$x:00006B62                 db    0
.xdata$x:00006B63                 db    0
.xdata$x:00006B64                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00006B68                 align 20h
.xdata$x:00006B68 _xdata$x        ends
.xdata$x:00006B68
.xdata$x:00006B80 ; ===========================================================================
.xdata$x:00006B80
.xdata$x:00006B80 ; Segment type: Pure data
.xdata$x:00006B80 ; Segment permissions: Read
.xdata$x:00006B80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006B80                 assume cs:_xdata$x
.xdata$x:00006B80                 ;org 6B80h
.xdata$x:00006B80 ; COMDAT (pick associative to section at 2868)
.xdata$x:00006B80 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00006B80                                         ; DATA XREF: .xdata$x:00006B90o
.xdata$x:00006B81                 db 0FFh
.xdata$x:00006B82                 db 0FFh
.xdata$x:00006B83                 db 0FFh
.xdata$x:00006B84                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00006B88 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00006B88                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00006B89                 db    5
.xdata$x:00006B8A                 db  93h ; ô
.xdata$x:00006B8B                 db  19h
.xdata$x:00006B8C                 db    1
.xdata$x:00006B8D                 db    0
.xdata$x:00006B8E                 db    0
.xdata$x:00006B8F                 db    0
.xdata$x:00006B90                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00006B94                 db    0
.xdata$x:00006B95                 db    0
.xdata$x:00006B96                 db    0
.xdata$x:00006B97                 db    0
.xdata$x:00006B98                 db    0
.xdata$x:00006B99                 db    0
.xdata$x:00006B9A                 db    0
.xdata$x:00006B9B                 db    0
.xdata$x:00006B9C                 db    0
.xdata$x:00006B9D                 db    0
.xdata$x:00006B9E                 db    0
.xdata$x:00006B9F                 db    0
.xdata$x:00006BA0                 db    0
.xdata$x:00006BA1                 db    0
.xdata$x:00006BA2                 db    0
.xdata$x:00006BA3                 db    0
.xdata$x:00006BA4                 db    0
.xdata$x:00006BA5                 db    0
.xdata$x:00006BA6                 db    0
.xdata$x:00006BA7                 db    0
.xdata$x:00006BA8                 db    0
.xdata$x:00006BA9                 db    0
.xdata$x:00006BAA                 db    0
.xdata$x:00006BAB                 db    0
.xdata$x:00006BAB _xdata$x        ends
.xdata$x:00006BAB
.xdata$x:00006BAC ; ===========================================================================
.xdata$x:00006BAC
.xdata$x:00006BAC ; Segment type: Pure data
.xdata$x:00006BAC ; Segment permissions: Read
.xdata$x:00006BAC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006BAC                 assume cs:_xdata$x
.xdata$x:00006BAC                 ;org 6BACh
.xdata$x:00006BAC ; COMDAT (pick associative to section at 62C8)
.xdata$x:00006BAC __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00006BAC                                         ; DATA XREF: .xdata$x:00006BBCo
.xdata$x:00006BAD                 db 0FFh
.xdata$x:00006BAE                 db 0FFh
.xdata$x:00006BAF                 db 0FFh
.xdata$x:00006BB0                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00006BB4 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00006BB4                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00006BB5                 db    5
.xdata$x:00006BB6                 db  93h ; ô
.xdata$x:00006BB7                 db  19h
.xdata$x:00006BB8                 db    1
.xdata$x:00006BB9                 db    0
.xdata$x:00006BBA                 db    0
.xdata$x:00006BBB                 db    0
.xdata$x:00006BBC                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00006BC0                 db    0
.xdata$x:00006BC1                 db    0
.xdata$x:00006BC2                 db    0
.xdata$x:00006BC3                 db    0
.xdata$x:00006BC4                 db    0
.xdata$x:00006BC5                 db    0
.xdata$x:00006BC6                 db    0
.xdata$x:00006BC7                 db    0
.xdata$x:00006BC8                 db    0
.xdata$x:00006BC9                 db    0
.xdata$x:00006BCA                 db    0
.xdata$x:00006BCB                 db    0
.xdata$x:00006BCC                 db    0
.xdata$x:00006BCD                 db    0
.xdata$x:00006BCE                 db    0
.xdata$x:00006BCF                 db    0
.xdata$x:00006BD0                 db    0
.xdata$x:00006BD1                 db    0
.xdata$x:00006BD2                 db    0
.xdata$x:00006BD3                 db    0
.xdata$x:00006BD4                 db    0
.xdata$x:00006BD5                 db    0
.xdata$x:00006BD6                 db    0
.xdata$x:00006BD7                 db    0
.xdata$x:00006BD7 _xdata$x        ends
.xdata$x:00006BD7
.xdata$x:00006BD8 ; ===========================================================================
.xdata$x:00006BD8
.xdata$x:00006BD8 ; Segment type: Pure data
.xdata$x:00006BD8 ; Segment permissions: Read
.xdata$x:00006BD8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006BD8                 assume cs:_xdata$x
.xdata$x:00006BD8                 ;org 6BD8h
.xdata$x:00006BD8 ; COMDAT (pick associative to section at 2ED0)
.xdata$x:00006BD8 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00006BD8                                         ; DATA XREF: .xdata$x:00006BE8o
.xdata$x:00006BD9                 db 0FFh
.xdata$x:00006BDA                 db 0FFh
.xdata$x:00006BDB                 db 0FFh
.xdata$x:00006BDC                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00006BE0 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00006BE0                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00006BE1                 db    5
.xdata$x:00006BE2                 db  93h ; ô
.xdata$x:00006BE3                 db  19h
.xdata$x:00006BE4                 db    1
.xdata$x:00006BE5                 db    0
.xdata$x:00006BE6                 db    0
.xdata$x:00006BE7                 db    0
.xdata$x:00006BE8                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00006BEC                 db    0
.xdata$x:00006BED                 db    0
.xdata$x:00006BEE                 db    0
.xdata$x:00006BEF                 db    0
.xdata$x:00006BF0                 db    0
.xdata$x:00006BF1                 db    0
.xdata$x:00006BF2                 db    0
.xdata$x:00006BF3                 db    0
.xdata$x:00006BF4                 db    0
.xdata$x:00006BF5                 db    0
.xdata$x:00006BF6                 db    0
.xdata$x:00006BF7                 db    0
.xdata$x:00006BF8                 db    0
.xdata$x:00006BF9                 db    0
.xdata$x:00006BFA                 db    0
.xdata$x:00006BFB                 db    0
.xdata$x:00006BFC                 db    0
.xdata$x:00006BFD                 db    0
.xdata$x:00006BFE                 db    0
.xdata$x:00006BFF                 db    0
.xdata$x:00006C00                 db    0
.xdata$x:00006C01                 db    0
.xdata$x:00006C02                 db    0
.xdata$x:00006C03                 db    0
.xdata$x:00006C03 _xdata$x        ends
.xdata$x:00006C03
.xdata$x:00006C04 ; ===========================================================================
.xdata$x:00006C04
.xdata$x:00006C04 ; Segment type: Pure data
.xdata$x:00006C04 ; Segment permissions: Read
.xdata$x:00006C04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006C04                 assume cs:_xdata$x
.xdata$x:00006C04                 ;org 6C04h
.xdata$x:00006C04 ; COMDAT (pick associative to section at 22B8)
.xdata$x:00006C04 __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00006C04                                         ; DATA XREF: .xdata$x:00006C14o
.xdata$x:00006C05                 db 0FFh
.xdata$x:00006C06                 db 0FFh
.xdata$x:00006C07                 db 0FFh
.xdata$x:00006C08                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:00006C0C __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00006C0C                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:00006C0D                 db    5
.xdata$x:00006C0E                 db  93h ; ô
.xdata$x:00006C0F                 db  19h
.xdata$x:00006C10                 db    1
.xdata$x:00006C11                 db    0
.xdata$x:00006C12                 db    0
.xdata$x:00006C13                 db    0
.xdata$x:00006C14                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00006C18                 db    0
.xdata$x:00006C19                 db    0
.xdata$x:00006C1A                 db    0
.xdata$x:00006C1B                 db    0
.xdata$x:00006C1C                 db    0
.xdata$x:00006C1D                 db    0
.xdata$x:00006C1E                 db    0
.xdata$x:00006C1F                 db    0
.xdata$x:00006C20                 db    0
.xdata$x:00006C21                 db    0
.xdata$x:00006C22                 db    0
.xdata$x:00006C23                 db    0
.xdata$x:00006C24                 db    0
.xdata$x:00006C25                 db    0
.xdata$x:00006C26                 db    0
.xdata$x:00006C27                 db    0
.xdata$x:00006C28                 db    0
.xdata$x:00006C29                 db    0
.xdata$x:00006C2A                 db    0
.xdata$x:00006C2B                 db    0
.xdata$x:00006C2C                 db    0
.xdata$x:00006C2D                 db    0
.xdata$x:00006C2E                 db    0
.xdata$x:00006C2F                 db    0
.xdata$x:00006C2F _xdata$x        ends
.xdata$x:00006C2F
.xdata$x:00006C30 ; ===========================================================================
.xdata$x:00006C30
.xdata$x:00006C30 ; Segment type: Pure data
.xdata$x:00006C30 ; Segment permissions: Read
.xdata$x:00006C30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006C30                 assume cs:_xdata$x
.xdata$x:00006C30                 ;org 6C30h
.xdata$x:00006C30 ; COMDAT (pick associative to section at 2B78)
.xdata$x:00006C30 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00006C30                                         ; DATA XREF: .xdata$x:00006C40o
.xdata$x:00006C31                 db 0FFh
.xdata$x:00006C32                 db 0FFh
.xdata$x:00006C33                 db 0FFh
.xdata$x:00006C34                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:00006C38 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00006C38                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:00006C39                 db    5
.xdata$x:00006C3A                 db  93h ; ô
.xdata$x:00006C3B                 db  19h
.xdata$x:00006C3C                 db    1
.xdata$x:00006C3D                 db    0
.xdata$x:00006C3E                 db    0
.xdata$x:00006C3F                 db    0
.xdata$x:00006C40                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00006C44                 db    0
.xdata$x:00006C45                 db    0
.xdata$x:00006C46                 db    0
.xdata$x:00006C47                 db    0
.xdata$x:00006C48                 db    0
.xdata$x:00006C49                 db    0
.xdata$x:00006C4A                 db    0
.xdata$x:00006C4B                 db    0
.xdata$x:00006C4C                 db    0
.xdata$x:00006C4D                 db    0
.xdata$x:00006C4E                 db    0
.xdata$x:00006C4F                 db    0
.xdata$x:00006C50                 db    0
.xdata$x:00006C51                 db    0
.xdata$x:00006C52                 db    0
.xdata$x:00006C53                 db    0
.xdata$x:00006C54                 db    0
.xdata$x:00006C55                 db    0
.xdata$x:00006C56                 db    0
.xdata$x:00006C57                 db    0
.xdata$x:00006C58                 db    0
.xdata$x:00006C59                 db    0
.xdata$x:00006C5A                 db    0
.xdata$x:00006C5B                 db    0
.xdata$x:00006C5B _xdata$x        ends
.xdata$x:00006C5B
.xdata$x:00006C5C ; ===========================================================================
.xdata$x:00006C5C
.xdata$x:00006C5C ; Segment type: Pure data
.xdata$x:00006C5C ; Segment permissions: Read
.xdata$x:00006C5C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006C5C                 assume cs:_xdata$x
.xdata$x:00006C5C                 ;org 6C5Ch
.xdata$x:00006C5C ; COMDAT (pick associative to section at 21B4)
.xdata$x:00006C5C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:00006C5C                                         ; DATA XREF: .xdata$x:00006C6Co
.xdata$x:00006C5D                 db 0FFh
.xdata$x:00006C5E                 db 0FFh
.xdata$x:00006C5F                 db 0FFh
.xdata$x:00006C60                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:00006C64 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:00006C64                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:00006C65                 db    5
.xdata$x:00006C66                 db  93h ; ô
.xdata$x:00006C67                 db  19h
.xdata$x:00006C68                 db    1
.xdata$x:00006C69                 db    0
.xdata$x:00006C6A                 db    0
.xdata$x:00006C6B                 db    0
.xdata$x:00006C6C                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:00006C70                 db    0
.xdata$x:00006C71                 db    0
.xdata$x:00006C72                 db    0
.xdata$x:00006C73                 db    0
.xdata$x:00006C74                 db    0
.xdata$x:00006C75                 db    0
.xdata$x:00006C76                 db    0
.xdata$x:00006C77                 db    0
.xdata$x:00006C78                 db    0
.xdata$x:00006C79                 db    0
.xdata$x:00006C7A                 db    0
.xdata$x:00006C7B                 db    0
.xdata$x:00006C7C                 db    0
.xdata$x:00006C7D                 db    0
.xdata$x:00006C7E                 db    0
.xdata$x:00006C7F                 db    0
.xdata$x:00006C80                 db    0
.xdata$x:00006C81                 db    0
.xdata$x:00006C82                 db    0
.xdata$x:00006C83                 db    0
.xdata$x:00006C84                 db    0
.xdata$x:00006C85                 db    0
.xdata$x:00006C86                 db    0
.xdata$x:00006C87                 db    0
.xdata$x:00006C87 _xdata$x        ends
.xdata$x:00006C87
.xdata$x:00006C88 ; ===========================================================================
.xdata$x:00006C88
.xdata$x:00006C88 ; Segment type: Pure data
.xdata$x:00006C88 ; Segment permissions: Read
.xdata$x:00006C88 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006C88                 assume cs:_xdata$x
.xdata$x:00006C88                 ;org 6C88h
.xdata$x:00006C88 ; COMDAT (pick associative to section at 2A90)
.xdata$x:00006C88 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00006C88                                         ; DATA XREF: .xdata$x:00006C98o
.xdata$x:00006C89                 db 0FFh
.xdata$x:00006C8A                 db 0FFh
.xdata$x:00006C8B                 db 0FFh
.xdata$x:00006C8C                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00006C90 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00006C90                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00006C91                 db    5
.xdata$x:00006C92                 db  93h ; ô
.xdata$x:00006C93                 db  19h
.xdata$x:00006C94                 db    1
.xdata$x:00006C95                 db    0
.xdata$x:00006C96                 db    0
.xdata$x:00006C97                 db    0
.xdata$x:00006C98                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:00006C9C                 db    0
.xdata$x:00006C9D                 db    0
.xdata$x:00006C9E                 db    0
.xdata$x:00006C9F                 db    0
.xdata$x:00006CA0                 db    0
.xdata$x:00006CA1                 db    0
.xdata$x:00006CA2                 db    0
.xdata$x:00006CA3                 db    0
.xdata$x:00006CA4                 db    0
.xdata$x:00006CA5                 db    0
.xdata$x:00006CA6                 db    0
.xdata$x:00006CA7                 db    0
.xdata$x:00006CA8                 db    0
.xdata$x:00006CA9                 db    0
.xdata$x:00006CAA                 db    0
.xdata$x:00006CAB                 db    0
.xdata$x:00006CAC                 db    0
.xdata$x:00006CAD                 db    0
.xdata$x:00006CAE                 db    0
.xdata$x:00006CAF                 db    0
.xdata$x:00006CB0                 db    0
.xdata$x:00006CB1                 db    0
.xdata$x:00006CB2                 db    0
.xdata$x:00006CB3                 db    0
.xdata$x:00006CB3 _xdata$x        ends
.xdata$x:00006CB3
.xdata$x:00006CB4 ; ===========================================================================
.xdata$x:00006CB4
.xdata$x:00006CB4 ; Segment type: Pure data
.xdata$x:00006CB4 ; Segment permissions: Read
.xdata$x:00006CB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006CB4                 assume cs:_xdata$x
.xdata$x:00006CB4                 ;org 6CB4h
.xdata$x:00006CB4 ; COMDAT (pick associative to section at 248C)
.xdata$x:00006CB4 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00006CB4                                         ; DATA XREF: .xdata$x:00006CC4o
.xdata$x:00006CB5                 db 0FFh
.xdata$x:00006CB6                 db 0FFh
.xdata$x:00006CB7                 db 0FFh
.xdata$x:00006CB8                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0
.xdata$x:00006CBC __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00006CBC                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z+11o
.xdata$x:00006CBD                 db    5
.xdata$x:00006CBE                 db  93h ; ô
.xdata$x:00006CBF                 db  19h
.xdata$x:00006CC0                 db    1
.xdata$x:00006CC1                 db    0
.xdata$x:00006CC2                 db    0
.xdata$x:00006CC3                 db    0
.xdata$x:00006CC4                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.xdata$x:00006CC8                 align 20h
.xdata$x:00006CC8 _xdata$x        ends
.xdata$x:00006CC8
.xdata$x:00006CE0 ; ===========================================================================
.xdata$x:00006CE0
.xdata$x:00006CE0 ; Segment type: Pure data
.xdata$x:00006CE0 ; Segment permissions: Read
.xdata$x:00006CE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006CE0                 assume cs:_xdata$x
.xdata$x:00006CE0                 ;org 6CE0h
.xdata$x:00006CE0 ; COMDAT (pick associative to section at 253C)
.xdata$x:00006CE0 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db 0FFh
.xdata$x:00006CE0                                         ; DATA XREF: .xdata$x:00006CF0o
.xdata$x:00006CE1                 db 0FFh
.xdata$x:00006CE2                 db 0FFh
.xdata$x:00006CE3                 db 0FFh
.xdata$x:00006CE4                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0
.xdata$x:00006CE8 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db  22h ; "
.xdata$x:00006CE8                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z+11o
.xdata$x:00006CE9                 db    5
.xdata$x:00006CEA                 db  93h ; ô
.xdata$x:00006CEB                 db  19h
.xdata$x:00006CEC                 db    1
.xdata$x:00006CED                 db    0
.xdata$x:00006CEE                 db    0
.xdata$x:00006CEF                 db    0
.xdata$x:00006CF0                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.xdata$x:00006CF4                 db    0
.xdata$x:00006CF5                 db    0
.xdata$x:00006CF6                 db    0
.xdata$x:00006CF7                 db    0
.xdata$x:00006CF8                 db    0
.xdata$x:00006CF9                 db    0
.xdata$x:00006CFA                 db    0
.xdata$x:00006CFB                 db    0
.xdata$x:00006CFC                 db    0
.xdata$x:00006CFD                 db    0
.xdata$x:00006CFE                 db    0
.xdata$x:00006CFF                 db    0
.xdata$x:00006D00                 db    0
.xdata$x:00006D01                 db    0
.xdata$x:00006D02                 db    0
.xdata$x:00006D03                 db    0
.xdata$x:00006D04                 db    0
.xdata$x:00006D05                 db    0
.xdata$x:00006D06                 db    0
.xdata$x:00006D07                 db    0
.xdata$x:00006D08                 db    0
.xdata$x:00006D09                 db    0
.xdata$x:00006D0A                 db    0
.xdata$x:00006D0B                 db    0
.xdata$x:00006D0B _xdata$x        ends
.xdata$x:00006D0B
.xdata$x:00006D0C ; ===========================================================================
.xdata$x:00006D0C
.xdata$x:00006D0C ; Segment type: Pure data
.xdata$x:00006D0C ; Segment permissions: Read
.xdata$x:00006D0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006D0C                 assume cs:_xdata$x
.xdata$x:00006D0C                 ;org 6D0Ch
.xdata$x:00006D0C ; COMDAT (pick associative to section at 2C64)
.xdata$x:00006D0C __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:00006D0C                                         ; DATA XREF: .xdata$x:00006D1Co
.xdata$x:00006D0D                 db 0FFh
.xdata$x:00006D0E                 db 0FFh
.xdata$x:00006D0F                 db 0FFh
.xdata$x:00006D10                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:00006D14 __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00006D14                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:00006D15                 db    5
.xdata$x:00006D16                 db  93h ; ô
.xdata$x:00006D17                 db  19h
.xdata$x:00006D18                 db    1
.xdata$x:00006D19                 db    0
.xdata$x:00006D1A                 db    0
.xdata$x:00006D1B                 db    0
.xdata$x:00006D1C                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:00006D20                 db    0
.xdata$x:00006D21                 db    0
.xdata$x:00006D22                 db    0
.xdata$x:00006D23                 db    0
.xdata$x:00006D24                 db    0
.xdata$x:00006D25                 db    0
.xdata$x:00006D26                 db    0
.xdata$x:00006D27                 db    0
.xdata$x:00006D28                 db    0
.xdata$x:00006D29                 db    0
.xdata$x:00006D2A                 db    0
.xdata$x:00006D2B                 db    0
.xdata$x:00006D2C                 db    0
.xdata$x:00006D2D                 db    0
.xdata$x:00006D2E                 db    0
.xdata$x:00006D2F                 db    0
.xdata$x:00006D30                 db    0
.xdata$x:00006D31                 db    0
.xdata$x:00006D32                 db    0
.xdata$x:00006D33                 db    0
.xdata$x:00006D34                 db    0
.xdata$x:00006D35                 db    0
.xdata$x:00006D36                 db    0
.xdata$x:00006D37                 db    0
.xdata$x:00006D37 _xdata$x        ends
.xdata$x:00006D37
.xdata$x:00006D38 ; ===========================================================================
.xdata$x:00006D38
.xdata$x:00006D38 ; Segment type: Pure data
.xdata$x:00006D38 ; Segment permissions: Read
.xdata$x:00006D38 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006D38                 assume cs:_xdata$x
.xdata$x:00006D38                 ;org 6D38h
.xdata$x:00006D38 ; COMDAT (pick associative to section at 3DE8)
.xdata$x:00006D38 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00006D38                                         ; DATA XREF: .xdata$x:00006DC0o
.xdata$x:00006D39                 db    0
.xdata$x:00006D3A                 db    0
.xdata$x:00006D3B                 db    0
.xdata$x:00006D3C                 db    0
.xdata$x:00006D3D                 db    0
.xdata$x:00006D3E                 db    0
.xdata$x:00006D3F                 db    0
.xdata$x:00006D40                 db    0
.xdata$x:00006D41                 db    0
.xdata$x:00006D42                 db    0
.xdata$x:00006D43                 db    0
.xdata$x:00006D44                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:00006D48 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00006D48                                         ; DATA XREF: .xdata$x:00006DACo
.xdata$x:00006D49                 db    0
.xdata$x:00006D4A                 db    0
.xdata$x:00006D4B                 db    0
.xdata$x:00006D4C                 db    0
.xdata$x:00006D4D                 db    0
.xdata$x:00006D4E                 db    0
.xdata$x:00006D4F                 db    0
.xdata$x:00006D50                 db    0
.xdata$x:00006D51                 db    0
.xdata$x:00006D52                 db    0
.xdata$x:00006D53                 db    0
.xdata$x:00006D54                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:00006D58 __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00006D58                                         ; DATA XREF: .xdata$x:00006D80o
.xdata$x:00006D59                 db 0FFh
.xdata$x:00006D5A                 db 0FFh
.xdata$x:00006D5B                 db 0FFh
.xdata$x:00006D5C                 db    0
.xdata$x:00006D5D                 db    0
.xdata$x:00006D5E                 db    0
.xdata$x:00006D5F                 db    0
.xdata$x:00006D60                 db 0FFh
.xdata$x:00006D61                 db 0FFh
.xdata$x:00006D62                 db 0FFh
.xdata$x:00006D63                 db 0FFh
.xdata$x:00006D64                 db    0
.xdata$x:00006D65                 db    0
.xdata$x:00006D66                 db    0
.xdata$x:00006D67                 db    0
.xdata$x:00006D68                 db    1
.xdata$x:00006D69                 db    0
.xdata$x:00006D6A                 db    0
.xdata$x:00006D6B                 db    0
.xdata$x:00006D6C                 db    0
.xdata$x:00006D6D                 db    0
.xdata$x:00006D6E                 db    0
.xdata$x:00006D6F                 db    0
.xdata$x:00006D70                 db    1
.xdata$x:00006D71                 db    0
.xdata$x:00006D72                 db    0
.xdata$x:00006D73                 db    0
.xdata$x:00006D74                 db    0
.xdata$x:00006D75                 db    0
.xdata$x:00006D76                 db    0
.xdata$x:00006D77                 db    0
.xdata$x:00006D78 __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00006D78                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:00006D79                 db    5
.xdata$x:00006D7A                 db  93h ; ô
.xdata$x:00006D7B                 db  19h
.xdata$x:00006D7C                 db    4
.xdata$x:00006D7D                 db    0
.xdata$x:00006D7E                 db    0
.xdata$x:00006D7F                 db    0
.xdata$x:00006D80                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00006D84                 db    2
.xdata$x:00006D85                 db    0
.xdata$x:00006D86                 db    0
.xdata$x:00006D87                 db    0
.xdata$x:00006D88                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00006D8C                 db    0
.xdata$x:00006D8D                 db    0
.xdata$x:00006D8E                 db    0
.xdata$x:00006D8F                 db    0
.xdata$x:00006D90                 db    0
.xdata$x:00006D91                 db    0
.xdata$x:00006D92                 db    0
.xdata$x:00006D93                 db    0
.xdata$x:00006D94                 db    0
.xdata$x:00006D95                 db    0
.xdata$x:00006D96                 db    0
.xdata$x:00006D97                 db    0
.xdata$x:00006D98                 db    0
.xdata$x:00006D99                 db    0
.xdata$x:00006D9A                 db    0
.xdata$x:00006D9B                 db    0
.xdata$x:00006D9C __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:00006D9C                                         ; DATA XREF: .xdata$x:00006D88o
.xdata$x:00006D9D                 db    0
.xdata$x:00006D9E                 db    0
.xdata$x:00006D9F                 db    0
.xdata$x:00006DA0                 db    2
.xdata$x:00006DA1                 db    0
.xdata$x:00006DA2                 db    0
.xdata$x:00006DA3                 db    0
.xdata$x:00006DA4                 db    3
.xdata$x:00006DA5                 db    0
.xdata$x:00006DA6                 db    0
.xdata$x:00006DA7                 db    0
.xdata$x:00006DA8                 db    1
.xdata$x:00006DA9                 db    0
.xdata$x:00006DAA                 db    0
.xdata$x:00006DAB                 db    0
.xdata$x:00006DAC                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:00006DB0                 db    0
.xdata$x:00006DB1                 db    0
.xdata$x:00006DB2                 db    0
.xdata$x:00006DB3                 db    0
.xdata$x:00006DB4                 db    0
.xdata$x:00006DB5                 db    0
.xdata$x:00006DB6                 db    0
.xdata$x:00006DB7                 db    0
.xdata$x:00006DB8                 db    3
.xdata$x:00006DB9                 db    0
.xdata$x:00006DBA                 db    0
.xdata$x:00006DBB                 db    0
.xdata$x:00006DBC                 db    1
.xdata$x:00006DBD                 db    0
.xdata$x:00006DBE                 db    0
.xdata$x:00006DBF                 db    0
.xdata$x:00006DC0                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:00006DC0 _xdata$x        ends
.xdata$x:00006DC0
.xdata$x:00006DC4 ; ===========================================================================
.xdata$x:00006DC4
.xdata$x:00006DC4 ; Segment type: Pure data
.xdata$x:00006DC4 ; Segment permissions: Read
.xdata$x:00006DC4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006DC4                 assume cs:_xdata$x
.xdata$x:00006DC4                 ;org 6DC4h
.xdata$x:00006DC4 ; COMDAT (pick associative to section at 2660)
.xdata$x:00006DC4 __unwindtable$??0RecentItem@@QAE@PB_W@Z db 0FFh
.xdata$x:00006DC4                                         ; DATA XREF: .xdata$x:00006DD4o
.xdata$x:00006DC5                 db 0FFh
.xdata$x:00006DC6                 db 0FFh
.xdata$x:00006DC7                 db 0FFh
.xdata$x:00006DC8                 dd offset __unwindfunclet$??0RecentItem@@QAE@PB_W@Z$0
.xdata$x:00006DCC __ehfuncinfo$??0RecentItem@@QAE@PB_W@Z db  22h ; "
.xdata$x:00006DCC                                         ; DATA XREF: __ehhandler$??0RecentItem@@QAE@PB_W@Z+11o
.xdata$x:00006DCD                 db    5
.xdata$x:00006DCE                 db  93h ; ô
.xdata$x:00006DCF                 db  19h
.xdata$x:00006DD0                 db    1
.xdata$x:00006DD1                 db    0
.xdata$x:00006DD2                 db    0
.xdata$x:00006DD3                 db    0
.xdata$x:00006DD4                 dd offset __unwindtable$??0RecentItem@@QAE@PB_W@Z
.xdata$x:00006DD8                 db    0
.xdata$x:00006DD9                 db    0
.xdata$x:00006DDA                 db    0
.xdata$x:00006DDB                 db    0
.xdata$x:00006DDC                 db    0
.xdata$x:00006DDD                 db    0
.xdata$x:00006DDE                 db    0
.xdata$x:00006DDF                 db    0
.xdata$x:00006DE0                 db    0
.xdata$x:00006DE1                 db    0
.xdata$x:00006DE2                 db    0
.xdata$x:00006DE3                 db    0
.xdata$x:00006DE4                 db    0
.xdata$x:00006DE5                 db    0
.xdata$x:00006DE6                 db    0
.xdata$x:00006DE7                 db    0
.xdata$x:00006DE8                 db    0
.xdata$x:00006DE9                 db    0
.xdata$x:00006DEA                 db    0
.xdata$x:00006DEB                 db    0
.xdata$x:00006DEC                 db    0
.xdata$x:00006DED                 db    0
.xdata$x:00006DEE                 db    0
.xdata$x:00006DEF                 db    0
.xdata$x:00006DEF _xdata$x        ends
.xdata$x:00006DEF
.xdata$x:00006DF0 ; ===========================================================================
.xdata$x:00006DF0
.xdata$x:00006DF0 ; Segment type: Pure data
.xdata$x:00006DF0 ; Segment permissions: Read
.xdata$x:00006DF0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006DF0                 assume cs:_xdata$x
.xdata$x:00006DF0                 ;org 6DF0h
.xdata$x:00006DF0 ; COMDAT (pick associative to section at 2CE0)
.xdata$x:00006DF0 __unwindtable$??1RecentItem@@QAE@XZ db 0FFh
.xdata$x:00006DF0                                         ; DATA XREF: .xdata$x:00006E00o
.xdata$x:00006DF1                 db 0FFh
.xdata$x:00006DF2                 db 0FFh
.xdata$x:00006DF3                 db 0FFh
.xdata$x:00006DF4                 dd offset __unwindfunclet$??1RecentItem@@QAE@XZ$0
.xdata$x:00006DF8 __ehfuncinfo$??1RecentItem@@QAE@XZ db  22h ; "
.xdata$x:00006DF8                                         ; DATA XREF: __ehhandler$??1RecentItem@@QAE@XZ+11o
.xdata$x:00006DF9                 db    5
.xdata$x:00006DFA                 db  93h ; ô
.xdata$x:00006DFB                 db  19h
.xdata$x:00006DFC                 db    1
.xdata$x:00006DFD                 db    0
.xdata$x:00006DFE                 db    0
.xdata$x:00006DFF                 db    0
.xdata$x:00006E00                 dd offset __unwindtable$??1RecentItem@@QAE@XZ
.xdata$x:00006E04                 db    0
.xdata$x:00006E05                 db    0
.xdata$x:00006E06                 db    0
.xdata$x:00006E07                 db    0
.xdata$x:00006E08                 db    0
.xdata$x:00006E09                 db    0
.xdata$x:00006E0A                 db    0
.xdata$x:00006E0B                 db    0
.xdata$x:00006E0C                 db    0
.xdata$x:00006E0D                 db    0
.xdata$x:00006E0E                 db    0
.xdata$x:00006E0F                 db    0
.xdata$x:00006E10                 db    0
.xdata$x:00006E11                 db    0
.xdata$x:00006E12                 db    0
.xdata$x:00006E13                 db    0
.xdata$x:00006E14                 db    0
.xdata$x:00006E15                 db    0
.xdata$x:00006E16                 db    0
.xdata$x:00006E17                 db    0
.xdata$x:00006E18                 db    0
.xdata$x:00006E19                 db    0
.xdata$x:00006E1A                 db    0
.xdata$x:00006E1B                 db    0
.xdata$x:00006E1B _xdata$x        ends
.xdata$x:00006E1B
.xdata$x:00006E1C ; ===========================================================================
.xdata$x:00006E1C
.xdata$x:00006E1C ; Segment type: Pure data
.xdata$x:00006E1C ; Segment permissions: Read
.xdata$x:00006E1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006E1C                 assume cs:_xdata$x
.xdata$x:00006E1C                 ;org 6E1Ch
.xdata$x:00006E1C ; COMDAT (pick associative to section at 25D4)
.xdata$x:00006E1C __unwindtable$??0RecentItem@@QAE@ABU0@@Z db 0FFh
.xdata$x:00006E1C                                         ; DATA XREF: .xdata$x:00006E2Co
.xdata$x:00006E1D                 db 0FFh
.xdata$x:00006E1E                 db 0FFh
.xdata$x:00006E1F                 db 0FFh
.xdata$x:00006E20                 dd offset __unwindfunclet$??0RecentItem@@QAE@ABU0@@Z$0
.xdata$x:00006E24 __ehfuncinfo$??0RecentItem@@QAE@ABU0@@Z db  22h ; "
.xdata$x:00006E24                                         ; DATA XREF: __ehhandler$??0RecentItem@@QAE@ABU0@@Z+11o
.xdata$x:00006E25                 db    5
.xdata$x:00006E26                 db  93h ; ô
.xdata$x:00006E27                 db  19h
.xdata$x:00006E28                 db    1
.xdata$x:00006E29                 db    0
.xdata$x:00006E2A                 db    0
.xdata$x:00006E2B                 db    0
.xdata$x:00006E2C                 dd offset __unwindtable$??0RecentItem@@QAE@ABU0@@Z
.xdata$x:00006E30                 db    0
.xdata$x:00006E31                 db    0
.xdata$x:00006E32                 db    0
.xdata$x:00006E33                 db    0
.xdata$x:00006E34                 db    0
.xdata$x:00006E35                 db    0
.xdata$x:00006E36                 db    0
.xdata$x:00006E37                 db    0
.xdata$x:00006E38                 db    0
.xdata$x:00006E39                 db    0
.xdata$x:00006E3A                 db    0
.xdata$x:00006E3B                 db    0
.xdata$x:00006E3C                 db    0
.xdata$x:00006E3D                 db    0
.xdata$x:00006E3E                 db    0
.xdata$x:00006E3F                 db    0
.xdata$x:00006E40                 db    0
.xdata$x:00006E41                 db    0
.xdata$x:00006E42                 db    0
.xdata$x:00006E43                 db    0
.xdata$x:00006E44                 db    0
.xdata$x:00006E45                 db    0
.xdata$x:00006E46                 db    0
.xdata$x:00006E47                 db    0
.xdata$x:00006E47 _xdata$x        ends
.xdata$x:00006E47
.xdata$x:00006E48 ; ===========================================================================
.xdata$x:00006E48
.xdata$x:00006E48 ; Segment type: Pure data
.xdata$x:00006E48 ; Segment permissions: Read
.xdata$x:00006E48 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006E48                 assume cs:_xdata$x
.xdata$x:00006E48                 ;org 6E48h
.xdata$x:00006E48 __unwindtable$?add@LastRecentFileList@@QAEXPB_W@Z db 0FFh
.xdata$x:00006E48                                         ; DATA XREF: .xdata$x:00006ED0o
.xdata$x:00006E49                 db 0FFh
.xdata$x:00006E4A                 db 0FFh
.xdata$x:00006E4B                 db 0FFh
.xdata$x:00006E4C                 dd offset __unwindfunclet$?add@LastRecentFileList@@QAEXPB_W@Z$0
.xdata$x:00006E50 __unwindtable$?clear@LastRecentFileList@@QAEXXZ db 0FFh
.xdata$x:00006E50                                         ; DATA XREF: .xdata$x:00006E88o
.xdata$x:00006E51                 db 0FFh
.xdata$x:00006E52                 db 0FFh
.xdata$x:00006E53                 db 0FFh
.xdata$x:00006E54                 dd offset __unwindfunclet$?clear@LastRecentFileList@@QAEXXZ$0
.xdata$x:00006E58                 db    0
.xdata$x:00006E59                 db    0
.xdata$x:00006E5A                 db    0
.xdata$x:00006E5B                 db    0
.xdata$x:00006E5C                 dd offset __unwindfunclet$?clear@LastRecentFileList@@QAEXXZ$1
.xdata$x:00006E60                 db    1
.xdata$x:00006E61                 db    0
.xdata$x:00006E62                 db    0
.xdata$x:00006E63                 db    0
.xdata$x:00006E64                 dd offset __unwindfunclet$?clear@LastRecentFileList@@QAEXXZ$2
.xdata$x:00006E68 __unwindtable$?remove@LastRecentFileList@@QAEXH@Z db 0FFh
.xdata$x:00006E68                                         ; DATA XREF: .xdata$x:00006EACo
.xdata$x:00006E69                 db 0FFh
.xdata$x:00006E6A                 db 0FFh
.xdata$x:00006E6B                 db 0FFh
.xdata$x:00006E6C                 dd offset __unwindfunclet$?remove@LastRecentFileList@@QAEXH@Z$0
.xdata$x:00006E70                 db    0
.xdata$x:00006E71                 db    0
.xdata$x:00006E72                 db    0
.xdata$x:00006E73                 db    0
.xdata$x:00006E74                 dd offset __unwindfunclet$?remove@LastRecentFileList@@QAEXH@Z$1
.xdata$x:00006E78                 db    1
.xdata$x:00006E79                 db    0
.xdata$x:00006E7A                 db    0
.xdata$x:00006E7B                 db    0
.xdata$x:00006E7C                 dd offset __unwindfunclet$?remove@LastRecentFileList@@QAEXH@Z$2
.xdata$x:00006E80 __ehfuncinfo$?clear@LastRecentFileList@@QAEXXZ db  22h ; "
.xdata$x:00006E80                                         ; DATA XREF: __ehhandler$?clear@LastRecentFileList@@QAEXXZ+11o
.xdata$x:00006E81                 db    5
.xdata$x:00006E82                 db  93h ; ô
.xdata$x:00006E83                 db  19h
.xdata$x:00006E84                 db    3
.xdata$x:00006E85                 db    0
.xdata$x:00006E86                 db    0
.xdata$x:00006E87                 db    0
.xdata$x:00006E88                 dd offset __unwindtable$?clear@LastRecentFileList@@QAEXXZ
.xdata$x:00006E8C                 db    0
.xdata$x:00006E8D                 db    0
.xdata$x:00006E8E                 db    0
.xdata$x:00006E8F                 db    0
.xdata$x:00006E90                 db    0
.xdata$x:00006E91                 db    0
.xdata$x:00006E92                 db    0
.xdata$x:00006E93                 db    0
.xdata$x:00006E94                 db    0
.xdata$x:00006E95                 db    0
.xdata$x:00006E96                 db    0
.xdata$x:00006E97                 db    0
.xdata$x:00006E98                 db    0
.xdata$x:00006E99                 db    0
.xdata$x:00006E9A                 db    0
.xdata$x:00006E9B                 db    0
.xdata$x:00006E9C                 db    0
.xdata$x:00006E9D                 db    0
.xdata$x:00006E9E                 db    0
.xdata$x:00006E9F                 db    0
.xdata$x:00006EA0                 db    0
.xdata$x:00006EA1                 db    0
.xdata$x:00006EA2                 db    0
.xdata$x:00006EA3                 db    0
.xdata$x:00006EA4 __ehfuncinfo$?remove@LastRecentFileList@@QAEXH@Z db  22h ; "
.xdata$x:00006EA4                                         ; DATA XREF: __ehhandler$?remove@LastRecentFileList@@QAEXH@Z+11o
.xdata$x:00006EA5                 db    5
.xdata$x:00006EA6                 db  93h ; ô
.xdata$x:00006EA7                 db  19h
.xdata$x:00006EA8                 db    3
.xdata$x:00006EA9                 db    0
.xdata$x:00006EAA                 db    0
.xdata$x:00006EAB                 db    0
.xdata$x:00006EAC                 dd offset __unwindtable$?remove@LastRecentFileList@@QAEXH@Z
.xdata$x:00006EB0                 db    0
.xdata$x:00006EB1                 db    0
.xdata$x:00006EB2                 db    0
.xdata$x:00006EB3                 db    0
.xdata$x:00006EB4                 db    0
.xdata$x:00006EB5                 db    0
.xdata$x:00006EB6                 db    0
.xdata$x:00006EB7                 db    0
.xdata$x:00006EB8                 db    0
.xdata$x:00006EB9                 db    0
.xdata$x:00006EBA                 db    0
.xdata$x:00006EBB                 db    0
.xdata$x:00006EBC                 db    0
.xdata$x:00006EBD                 db    0
.xdata$x:00006EBE                 db    0
.xdata$x:00006EBF                 db    0
.xdata$x:00006EC0                 db    0
.xdata$x:00006EC1                 db    0
.xdata$x:00006EC2                 db    0
.xdata$x:00006EC3                 db    0
.xdata$x:00006EC4                 db    0
.xdata$x:00006EC5                 db    0
.xdata$x:00006EC6                 db    0
.xdata$x:00006EC7                 db    0
.xdata$x:00006EC8 __ehfuncinfo$?add@LastRecentFileList@@QAEXPB_W@Z db  22h ; "
.xdata$x:00006EC8                                         ; DATA XREF: __ehhandler$?add@LastRecentFileList@@QAEXPB_W@Z+1Bo
.xdata$x:00006EC9                 db    5
.xdata$x:00006ECA                 db  93h ; ô
.xdata$x:00006ECB                 db  19h
.xdata$x:00006ECC                 db    1
.xdata$x:00006ECD                 db    0
.xdata$x:00006ECE                 db    0
.xdata$x:00006ECF                 db    0
.xdata$x:00006ED0                 dd offset __unwindtable$?add@LastRecentFileList@@QAEXPB_W@Z
.xdata$x:00006ED4                 db    0
.xdata$x:00006ED5                 db    0
.xdata$x:00006ED6                 db    0
.xdata$x:00006ED7                 db    0
.xdata$x:00006ED8                 db    0
.xdata$x:00006ED9                 db    0
.xdata$x:00006EDA                 db    0
.xdata$x:00006EDB                 db    0
.xdata$x:00006EDC                 db    0
.xdata$x:00006EDD                 db    0
.xdata$x:00006EDE                 db    0
.xdata$x:00006EDF                 db    0
.xdata$x:00006EE0                 db    0
.xdata$x:00006EE1                 db    0
.xdata$x:00006EE2                 db    0
.xdata$x:00006EE3                 db    0
.xdata$x:00006EE4                 db    0
.xdata$x:00006EE5                 db    0
.xdata$x:00006EE6                 db    0
.xdata$x:00006EE7                 db    0
.xdata$x:00006EE8                 db    0
.xdata$x:00006EE9                 db    0
.xdata$x:00006EEA                 db    0
.xdata$x:00006EEB                 db    0
.xdata$x:00006EEC __ehfuncinfo$?updateMenu@LastRecentFileList@@QAEXXZ db  22h ; "
.xdata$x:00006EEC                                         ; DATA XREF: __ehhandler$?updateMenu@LastRecentFileList@@QAEXXZ+1Eo
.xdata$x:00006EED                 db    5
.xdata$x:00006EEE                 db  93h ; ô
.xdata$x:00006EEF                 db  19h
.xdata$x:00006EF0                 db    5
.xdata$x:00006EF1                 db    0
.xdata$x:00006EF2                 db    0
.xdata$x:00006EF3                 db    0
.xdata$x:00006EF4                 dd offset __unwindtable$?updateMenu@LastRecentFileList@@QAEXXZ
.xdata$x:00006EF8                 db    0
.xdata$x:00006EF9                 db    0
.xdata$x:00006EFA                 db    0
.xdata$x:00006EFB                 db    0
.xdata$x:00006EFC                 db    0
.xdata$x:00006EFD                 db    0
.xdata$x:00006EFE                 db    0
.xdata$x:00006EFF                 db    0
.xdata$x:00006F00                 db    0
.xdata$x:00006F01                 db    0
.xdata$x:00006F02                 db    0
.xdata$x:00006F03                 db    0
.xdata$x:00006F04                 db    0
.xdata$x:00006F05                 db    0
.xdata$x:00006F06                 db    0
.xdata$x:00006F07                 db    0
.xdata$x:00006F08                 db    0
.xdata$x:00006F09                 db    0
.xdata$x:00006F0A                 db    0
.xdata$x:00006F0B                 db    0
.xdata$x:00006F0C                 db    0
.xdata$x:00006F0D                 db    0
.xdata$x:00006F0E                 db    0
.xdata$x:00006F0F                 db    0
.xdata$x:00006F10 __unwindtable$?updateMenu@LastRecentFileList@@QAEXXZ db 0FFh
.xdata$x:00006F10                                         ; DATA XREF: .xdata$x:00006EF4o
.xdata$x:00006F11                 db 0FFh
.xdata$x:00006F12                 db 0FFh
.xdata$x:00006F13                 db 0FFh
.xdata$x:00006F14                 dd offset __unwindfunclet$?updateMenu@LastRecentFileList@@QAEXXZ$0
.xdata$x:00006F18                 db    0
.xdata$x:00006F19                 db    0
.xdata$x:00006F1A                 db    0
.xdata$x:00006F1B                 db    0
.xdata$x:00006F1C                 dd offset __unwindfunclet$?updateMenu@LastRecentFileList@@QAEXXZ$1
.xdata$x:00006F20                 db    1
.xdata$x:00006F21                 db    0
.xdata$x:00006F22                 db    0
.xdata$x:00006F23                 db    0
.xdata$x:00006F24                 dd offset __unwindfunclet$?updateMenu@LastRecentFileList@@QAEXXZ$2
.xdata$x:00006F28                 db    2
.xdata$x:00006F29                 db    0
.xdata$x:00006F2A                 db    0
.xdata$x:00006F2B                 db    0
.xdata$x:00006F2C                 dd offset __unwindfunclet$?updateMenu@LastRecentFileList@@QAEXXZ$3
.xdata$x:00006F30                 db 0FFh
.xdata$x:00006F31                 db 0FFh
.xdata$x:00006F32                 db 0FFh
.xdata$x:00006F33                 db 0FFh
.xdata$x:00006F34                 dd offset __unwindfunclet$?updateMenu@LastRecentFileList@@QAEXXZ$4
.xdata$x:00006F34 _xdata$x        ends
.xdata$x:00006F34
.xdata$x:00006F38 ; ===========================================================================
.xdata$x:00006F38
.xdata$x:00006F38 ; Segment type: Pure data
.xdata$x:00006F38 ; Segment permissions: Read
.xdata$x:00006F38 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006F38                 assume cs:_xdata$x
.xdata$x:00006F38                 ;org 6F38h
.xdata$x:00006F38 ; COMDAT (pick associative to section at 532C)
.xdata$x:00006F38 __unwindtable$?construct@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@ABU3@@Z db 0FFh
.xdata$x:00006F38                                         ; DATA XREF: .xdata$x:00006F48o
.xdata$x:00006F39                 db 0FFh
.xdata$x:00006F3A                 db 0FFh
.xdata$x:00006F3B                 db 0FFh
.xdata$x:00006F3C                 dd offset __unwindfunclet$?construct@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@ABU3@@Z$0
.xdata$x:00006F40 __ehfuncinfo$?construct@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@ABU3@@Z db  22h ; "
.xdata$x:00006F40                                         ; DATA XREF: __ehhandler$?construct@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@ABU3@@Z+11o
.xdata$x:00006F41                 db    5
.xdata$x:00006F42                 db  93h ; ô
.xdata$x:00006F43                 db  19h
.xdata$x:00006F44                 db    1
.xdata$x:00006F45                 db    0
.xdata$x:00006F46                 db    0
.xdata$x:00006F47                 db    0
.xdata$x:00006F48                 dd offset __unwindtable$?construct@?$allocator@URecentItem@@@std@@QAEXPAURecentItem@@ABU3@@Z
.xdata$x:00006F4C                 db    0
.xdata$x:00006F4D                 db    0
.xdata$x:00006F4E                 db    0
.xdata$x:00006F4F                 db    0
.xdata$x:00006F50                 db    0
.xdata$x:00006F51                 db    0
.xdata$x:00006F52                 db    0
.xdata$x:00006F53                 db    0
.xdata$x:00006F54                 db    0
.xdata$x:00006F55                 db    0
.xdata$x:00006F56                 db    0
.xdata$x:00006F57                 db    0
.xdata$x:00006F58                 db    0
.xdata$x:00006F59                 db    0
.xdata$x:00006F5A                 db    0
.xdata$x:00006F5B                 db    0
.xdata$x:00006F5C                 db    0
.xdata$x:00006F5D                 db    0
.xdata$x:00006F5E                 db    0
.xdata$x:00006F5F                 db    0
.xdata$x:00006F60                 db    0
.xdata$x:00006F61                 db    0
.xdata$x:00006F62                 db    0
.xdata$x:00006F63                 db    0
.xdata$x:00006F63 _xdata$x        ends
.xdata$x:00006F63
.xdata$x:00006F64 ; ===========================================================================
.xdata$x:00006F64
.xdata$x:00006F64 ; Segment type: Pure data
.xdata$x:00006F64 ; Segment permissions: Read
.xdata$x:00006F64 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006F64                 assume cs:_xdata$x
.xdata$x:00006F64                 ;org 6F64h
.xdata$x:00006F64 ; COMDAT (pick associative to section at 5100)
.xdata$x:00006F64 __unwindtable$?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:00006F64                                         ; DATA XREF: .xdata$x:00006F74o
.xdata$x:00006F65                 db 0FFh
.xdata$x:00006F66                 db 0FFh
.xdata$x:00006F67                 db 0FFh
.xdata$x:00006F68                 dd offset __unwindfunclet$?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ$0
.xdata$x:00006F6C __ehfuncinfo$?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00006F6C                                         ; DATA XREF: __ehhandler$?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ+11o
.xdata$x:00006F6D                 db    5
.xdata$x:00006F6E                 db  93h ; ô
.xdata$x:00006F6F                 db  19h
.xdata$x:00006F70                 db    1
.xdata$x:00006F71                 db    0
.xdata$x:00006F72                 db    0
.xdata$x:00006F73                 db    0
.xdata$x:00006F74                 dd offset __unwindtable$?begin@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ
.xdata$x:00006F78                 db    0
.xdata$x:00006F79                 db    0
.xdata$x:00006F7A                 db    0
.xdata$x:00006F7B                 db    0
.xdata$x:00006F7C                 db    0
.xdata$x:00006F7D                 db    0
.xdata$x:00006F7E                 db    0
.xdata$x:00006F7F                 db    0
.xdata$x:00006F80                 db    0
.xdata$x:00006F81                 db    0
.xdata$x:00006F82                 db    0
.xdata$x:00006F83                 db    0
.xdata$x:00006F84                 db    0
.xdata$x:00006F85                 db    0
.xdata$x:00006F86                 db    0
.xdata$x:00006F87                 db    0
.xdata$x:00006F88                 db    0
.xdata$x:00006F89                 db    0
.xdata$x:00006F8A                 db    0
.xdata$x:00006F8B                 db    0
.xdata$x:00006F8C                 db    0
.xdata$x:00006F8D                 db    0
.xdata$x:00006F8E                 db    0
.xdata$x:00006F8F                 db    0
.xdata$x:00006F8F _xdata$x        ends
.xdata$x:00006F8F
.xdata$x:00006F90 ; ===========================================================================
.xdata$x:00006F90
.xdata$x:00006F90 ; Segment type: Pure data
.xdata$x:00006F90 ; Segment permissions: Read
.xdata$x:00006F90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006F90                 assume cs:_xdata$x
.xdata$x:00006F90                 ;org 6F90h
.xdata$x:00006F90 ; COMDAT (pick associative to section at 559C)
.xdata$x:00006F90 __unwindtable$?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:00006F90                                         ; DATA XREF: .xdata$x:00006FA0o
.xdata$x:00006F91                 db 0FFh
.xdata$x:00006F92                 db 0FFh
.xdata$x:00006F93                 db 0FFh
.xdata$x:00006F94                 dd offset __unwindfunclet$?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ$0
.xdata$x:00006F98 __ehfuncinfo$?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00006F98                                         ; DATA XREF: __ehhandler$?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ+11o
.xdata$x:00006F99                 db    5
.xdata$x:00006F9A                 db  93h ; ô
.xdata$x:00006F9B                 db  19h
.xdata$x:00006F9C                 db    1
.xdata$x:00006F9D                 db    0
.xdata$x:00006F9E                 db    0
.xdata$x:00006F9F                 db    0
.xdata$x:00006FA0                 dd offset __unwindtable$?end@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@XZ
.xdata$x:00006FA4                 db    0
.xdata$x:00006FA5                 db    0
.xdata$x:00006FA6                 db    0
.xdata$x:00006FA7                 db    0
.xdata$x:00006FA8                 db    0
.xdata$x:00006FA9                 db    0
.xdata$x:00006FAA                 db    0
.xdata$x:00006FAB                 db    0
.xdata$x:00006FAC                 db    0
.xdata$x:00006FAD                 db    0
.xdata$x:00006FAE                 db    0
.xdata$x:00006FAF                 db    0
.xdata$x:00006FB0                 db    0
.xdata$x:00006FB1                 db    0
.xdata$x:00006FB2                 db    0
.xdata$x:00006FB3                 db    0
.xdata$x:00006FB4                 db    0
.xdata$x:00006FB5                 db    0
.xdata$x:00006FB6                 db    0
.xdata$x:00006FB7                 db    0
.xdata$x:00006FB8                 db    0
.xdata$x:00006FB9                 db    0
.xdata$x:00006FBA                 db    0
.xdata$x:00006FBB                 db    0
.xdata$x:00006FBB _xdata$x        ends
.xdata$x:00006FBB
.xdata$x:00006FBC ; ===========================================================================
.xdata$x:00006FBC
.xdata$x:00006FBC ; Segment type: Pure data
.xdata$x:00006FBC ; Segment permissions: Read
.xdata$x:00006FBC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006FBC                 assume cs:_xdata$x
.xdata$x:00006FBC                 ;org 6FBCh
.xdata$x:00006FBC ; COMDAT (pick associative to section at 4540)
.xdata$x:00006FBC __unwindtable$?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z db 0FFh
.xdata$x:00006FBC                                         ; DATA XREF: .xdata$x:00006FD4o
.xdata$x:00006FBD                 db 0FFh
.xdata$x:00006FBE                 db 0FFh
.xdata$x:00006FBF                 db 0FFh
.xdata$x:00006FC0                 dd offset __unwindfunclet$?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$1
.xdata$x:00006FC4                 align 8
.xdata$x:00006FC8                 dd offset __unwindfunclet$?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$0
.xdata$x:00006FCC __ehfuncinfo$?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z db  22h ; "
.xdata$x:00006FCC                                         ; DATA XREF: __ehhandler$?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z+11o
.xdata$x:00006FCD                 db    5
.xdata$x:00006FCE                 db  93h ; ô
.xdata$x:00006FCF                 db  19h
.xdata$x:00006FD0                 db    2
.xdata$x:00006FD1                 db    0
.xdata$x:00006FD2                 db    0
.xdata$x:00006FD3                 db    0
.xdata$x:00006FD4                 dd offset __unwindtable$?_Make_iter@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z
.xdata$x:00006FD8                 db    0
.xdata$x:00006FD9                 db    0
.xdata$x:00006FDA                 db    0
.xdata$x:00006FDB                 db    0
.xdata$x:00006FDC                 db    0
.xdata$x:00006FDD                 db    0
.xdata$x:00006FDE                 db    0
.xdata$x:00006FDF                 db    0
.xdata$x:00006FE0                 db    0
.xdata$x:00006FE1                 db    0
.xdata$x:00006FE2                 db    0
.xdata$x:00006FE3                 db    0
.xdata$x:00006FE4                 db    0
.xdata$x:00006FE5                 db    0
.xdata$x:00006FE6                 db    0
.xdata$x:00006FE7                 db    0
.xdata$x:00006FE8                 db    0
.xdata$x:00006FE9                 db    0
.xdata$x:00006FEA                 db    0
.xdata$x:00006FEB                 db    0
.xdata$x:00006FEC                 db    0
.xdata$x:00006FED                 db    0
.xdata$x:00006FEE                 db    0
.xdata$x:00006FEF                 db    0
.xdata$x:00006FEF _xdata$x        ends
.xdata$x:00006FEF
.xdata$x:00006FF0 ; ===========================================================================
.xdata$x:00006FF0
.xdata$x:00006FF0 ; Segment type: Pure data
.xdata$x:00006FF0 ; Segment permissions: Read
.xdata$x:00006FF0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006FF0                 assume cs:_xdata$x
.xdata$x:00006FF0                 ;org 6FF0h
.xdata$x:00006FF0 ; COMDAT (pick associative to section at 4F60)
.xdata$x:00006FF0 __unwindtable$?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z db 0FFh
.xdata$x:00006FF0                                         ; DATA XREF: .xdata$x:00007008o
.xdata$x:00006FF1                 db 0FFh
.xdata$x:00006FF2                 db 0FFh
.xdata$x:00006FF3                 db 0FFh
.xdata$x:00006FF4                 dd offset __unwindfunclet$?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z$0
.xdata$x:00006FF8                 db    0
.xdata$x:00006FF9                 db    0
.xdata$x:00006FFA                 db    0
.xdata$x:00006FFB                 db    0
.xdata$x:00006FFC                 dd offset __unwindfunclet$?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z$1
.xdata$x:00007000 __ehfuncinfo$?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z db  22h ; "
.xdata$x:00007000                                         ; DATA XREF: __ehhandler$?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z+11o
.xdata$x:00007001                 db    5
.xdata$x:00007002                 db  93h ; ô
.xdata$x:00007003                 db  19h
.xdata$x:00007004                 db    2
.xdata$x:00007005                 db    0
.xdata$x:00007006                 db    0
.xdata$x:00007007                 db    0
.xdata$x:00007008                 dd offset __unwindtable$?at@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@I@Z
.xdata$x:0000700C                 db    0
.xdata$x:0000700D                 db    0
.xdata$x:0000700E                 db    0
.xdata$x:0000700F                 db    0
.xdata$x:00007010                 db    0
.xdata$x:00007011                 db    0
.xdata$x:00007012                 db    0
.xdata$x:00007013                 db    0
.xdata$x:00007014                 db    0
.xdata$x:00007015                 db    0
.xdata$x:00007016                 db    0
.xdata$x:00007017                 db    0
.xdata$x:00007018                 db    0
.xdata$x:00007019                 db    0
.xdata$x:0000701A                 db    0
.xdata$x:0000701B                 db    0
.xdata$x:0000701C                 db    0
.xdata$x:0000701D                 db    0
.xdata$x:0000701E                 db    0
.xdata$x:0000701F                 db    0
.xdata$x:00007020                 db    0
.xdata$x:00007021                 db    0
.xdata$x:00007022                 db    0
.xdata$x:00007023                 db    0
.xdata$x:00007023 _xdata$x        ends
.xdata$x:00007023
.xdata$x:00007024 ; ===========================================================================
.xdata$x:00007024
.xdata$x:00007024 ; Segment type: Pure data
.xdata$x:00007024 ; Segment permissions: Read
.xdata$x:00007024 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007024                 assume cs:_xdata$x
.xdata$x:00007024                 ;org 7024h
.xdata$x:00007024 ; COMDAT (pick associative to section at 503C)
.xdata$x:00007024 __unwindtable$?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ db 0FFh
.xdata$x:00007024                                         ; DATA XREF: .xdata$x:0000703Co
.xdata$x:00007025                 db 0FFh
.xdata$x:00007026                 db 0FFh
.xdata$x:00007027                 db 0FFh
.xdata$x:00007028                 dd offset __unwindfunclet$?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ$0
.xdata$x:0000702C                 align 10h
.xdata$x:00007030                 dd offset __unwindfunclet$?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ$1
.xdata$x:00007034 __ehfuncinfo$?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ db  22h ; "
.xdata$x:00007034                                         ; DATA XREF: __ehhandler$?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ+11o
.xdata$x:00007035                 db    5
.xdata$x:00007036                 db  93h ; ô
.xdata$x:00007037                 db  19h
.xdata$x:00007038                 db    2
.xdata$x:00007039                 db    0
.xdata$x:0000703A                 db    0
.xdata$x:0000703B                 db    0
.xdata$x:0000703C                 dd offset __unwindtable$?back@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAEAAURecentItem@@XZ
.xdata$x:00007040                 db    0
.xdata$x:00007041                 db    0
.xdata$x:00007042                 db    0
.xdata$x:00007043                 db    0
.xdata$x:00007044                 db    0
.xdata$x:00007045                 db    0
.xdata$x:00007046                 db    0
.xdata$x:00007047                 db    0
.xdata$x:00007048                 db    0
.xdata$x:00007049                 db    0
.xdata$x:0000704A                 db    0
.xdata$x:0000704B                 db    0
.xdata$x:0000704C                 db    0
.xdata$x:0000704D                 db    0
.xdata$x:0000704E                 db    0
.xdata$x:0000704F                 db    0
.xdata$x:00007050                 db    0
.xdata$x:00007051                 db    0
.xdata$x:00007052                 db    0
.xdata$x:00007053                 db    0
.xdata$x:00007054                 db    0
.xdata$x:00007055                 db    0
.xdata$x:00007056                 db    0
.xdata$x:00007057                 db    0
.xdata$x:00007057 _xdata$x        ends
.xdata$x:00007057
.xdata$x:00007058 ; ===========================================================================
.xdata$x:00007058
.xdata$x:00007058 ; Segment type: Pure data
.xdata$x:00007058 ; Segment permissions: Read
.xdata$x:00007058 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007058                 assume cs:_xdata$x
.xdata$x:00007058                 ;org 7058h
.xdata$x:00007058 ; COMDAT (pick associative to section at 5E3C)
.xdata$x:00007058 __unwindtable$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z db 0FFh
.xdata$x:00007058                                         ; DATA XREF: .xdata$x:00007080o
.xdata$x:00007059                 db 0FFh
.xdata$x:0000705A                 db 0FFh
.xdata$x:0000705B                 db 0FFh
.xdata$x:0000705C                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$3
.xdata$x:00007060                 db    0
.xdata$x:00007061                 db    0
.xdata$x:00007062                 db    0
.xdata$x:00007063                 db    0
.xdata$x:00007064                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$0
.xdata$x:00007068                 db    1
.xdata$x:00007069                 db    0
.xdata$x:0000706A                 db    0
.xdata$x:0000706B                 db    0
.xdata$x:0000706C                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$1
.xdata$x:00007070                 db    2
.xdata$x:00007071                 db    0
.xdata$x:00007072                 db    0
.xdata$x:00007073                 db    0
.xdata$x:00007074                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z$2
.xdata$x:00007078 __ehfuncinfo$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z db  22h ; "
.xdata$x:00007078                                         ; DATA XREF: __ehhandler$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z+11o
.xdata$x:00007079                 db    5
.xdata$x:0000707A                 db  93h ; ô
.xdata$x:0000707B                 db  19h
.xdata$x:0000707C                 db    4
.xdata$x:0000707D                 db    0
.xdata$x:0000707E                 db    0
.xdata$x:0000707F                 db    0
.xdata$x:00007080                 dd offset __unwindtable$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@@Z
.xdata$x:00007084                 db    0
.xdata$x:00007085                 db    0
.xdata$x:00007086                 db    0
.xdata$x:00007087                 db    0
.xdata$x:00007088                 db    0
.xdata$x:00007089                 db    0
.xdata$x:0000708A                 db    0
.xdata$x:0000708B                 db    0
.xdata$x:0000708C                 db    0
.xdata$x:0000708D                 db    0
.xdata$x:0000708E                 db    0
.xdata$x:0000708F                 db    0
.xdata$x:00007090                 db    0
.xdata$x:00007091                 db    0
.xdata$x:00007092                 db    0
.xdata$x:00007093                 db    0
.xdata$x:00007094                 db    0
.xdata$x:00007095                 db    0
.xdata$x:00007096                 db    0
.xdata$x:00007097                 db    0
.xdata$x:00007098                 db    0
.xdata$x:00007099                 db    0
.xdata$x:0000709A                 db    0
.xdata$x:0000709B                 db    0
.xdata$x:0000709B _xdata$x        ends
.xdata$x:0000709B
.xdata$x:0000709C ; ===========================================================================
.xdata$x:0000709C
.xdata$x:0000709C ; Segment type: Pure data
.xdata$x:0000709C ; Segment permissions: Read
.xdata$x:0000709C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000709C                 assume cs:_xdata$x
.xdata$x:0000709C                 ;org 709Ch
.xdata$x:0000709C ; COMDAT (pick associative to section at 582C)
.xdata$x:0000709C __ehfuncinfo$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z db  22h ; "
.xdata$x:0000709C                                         ; DATA XREF: __ehhandler$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z+14o
.xdata$x:0000709D                 db    5
.xdata$x:0000709E                 db  93h ; ô
.xdata$x:0000709F                 db  19h
.xdata$x:000070A0                 db  14h
.xdata$x:000070A1                 db    0
.xdata$x:000070A2                 db    0
.xdata$x:000070A3                 db    0
.xdata$x:000070A4                 dd offset __unwindtable$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z
.xdata$x:000070A8                 align 20h
.xdata$x:000070C0 __unwindtable$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z db 0FFh
.xdata$x:000070C0                                         ; DATA XREF: .xdata$x:000070A4o
.xdata$x:000070C1                 db 0FFh
.xdata$x:000070C2                 db 0FFh
.xdata$x:000070C3                 db 0FFh
.xdata$x:000070C4                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$21
.xdata$x:000070C8                 db    0
.xdata$x:000070C9                 db    0
.xdata$x:000070CA                 db    0
.xdata$x:000070CB                 db    0
.xdata$x:000070CC                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$0
.xdata$x:000070D0                 db    1
.xdata$x:000070D1                 db    0
.xdata$x:000070D2                 db    0
.xdata$x:000070D3                 db    0
.xdata$x:000070D4                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$1
.xdata$x:000070D8                 db    2
.xdata$x:000070D9                 db    0
.xdata$x:000070DA                 db    0
.xdata$x:000070DB                 db    0
.xdata$x:000070DC                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$2
.xdata$x:000070E0                 db    2
.xdata$x:000070E1                 db    0
.xdata$x:000070E2                 db    0
.xdata$x:000070E3                 db    0
.xdata$x:000070E4                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$3
.xdata$x:000070E8                 db    4
.xdata$x:000070E9                 db    0
.xdata$x:000070EA                 db    0
.xdata$x:000070EB                 db    0
.xdata$x:000070EC                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$4
.xdata$x:000070F0                 db    4
.xdata$x:000070F1                 db    0
.xdata$x:000070F2                 db    0
.xdata$x:000070F3                 db    0
.xdata$x:000070F4                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$5
.xdata$x:000070F8                 db    6
.xdata$x:000070F9                 db    0
.xdata$x:000070FA                 db    0
.xdata$x:000070FB                 db    0
.xdata$x:000070FC                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$6
.xdata$x:00007100                 db    7
.xdata$x:00007101                 db    0
.xdata$x:00007102                 db    0
.xdata$x:00007103                 db    0
.xdata$x:00007104                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$7
.xdata$x:00007108                 db    6
.xdata$x:00007109                 db    0
.xdata$x:0000710A                 db    0
.xdata$x:0000710B                 db    0
.xdata$x:0000710C                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$8
.xdata$x:00007110                 db    9
.xdata$x:00007111                 db    0
.xdata$x:00007112                 db    0
.xdata$x:00007113                 db    0
.xdata$x:00007114                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$9
.xdata$x:00007118                 db    6
.xdata$x:00007119                 db    0
.xdata$x:0000711A                 db    0
.xdata$x:0000711B                 db    0
.xdata$x:0000711C                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$10
.xdata$x:00007120                 db    6
.xdata$x:00007121                 db    0
.xdata$x:00007122                 db    0
.xdata$x:00007123                 db    0
.xdata$x:00007124                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$11
.xdata$x:00007128                 db    6
.xdata$x:00007129                 db    0
.xdata$x:0000712A                 db    0
.xdata$x:0000712B                 db    0
.xdata$x:0000712C                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$12
.xdata$x:00007130                 db  0Dh
.xdata$x:00007131                 db    0
.xdata$x:00007132                 db    0
.xdata$x:00007133                 db    0
.xdata$x:00007134                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$13
.xdata$x:00007138                 db  0Eh
.xdata$x:00007139                 db    0
.xdata$x:0000713A                 db    0
.xdata$x:0000713B                 db    0
.xdata$x:0000713C                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$14
.xdata$x:00007140                 db    6
.xdata$x:00007141                 db    0
.xdata$x:00007142                 db    0
.xdata$x:00007143                 db    0
.xdata$x:00007144                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$16
.xdata$x:00007148                 db  10h
.xdata$x:00007149                 db    0
.xdata$x:0000714A                 db    0
.xdata$x:0000714B                 db    0
.xdata$x:0000714C                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$17
.xdata$x:00007150                 db  11h
.xdata$x:00007151                 db    0
.xdata$x:00007152                 db    0
.xdata$x:00007153                 db    0
.xdata$x:00007154                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$18
.xdata$x:00007158                 db    6
.xdata$x:00007159                 db    0
.xdata$x:0000715A                 db    0
.xdata$x:0000715B                 db    0
.xdata$x:0000715C                 dd offset __unwindfunclet$?erase@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@2@0@Z$20
.xdata$x:0000715C _xdata$x        ends
.xdata$x:0000715C
.xdata$x:00007160 ; ===========================================================================
.xdata$x:00007160
.xdata$x:00007160 ; Segment type: Pure data
.xdata$x:00007160 ; Segment permissions: Read
.xdata$x:00007160 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007160                 assume cs:_xdata$x
.xdata$x:00007160                 ;org 7160h
.xdata$x:00007160 ; COMDAT (pick associative to section at 4800)
.xdata$x:00007160 __unwindtable$?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z db 0FFh
.xdata$x:00007160                                         ; DATA XREF: .xdata$x:00007170o
.xdata$x:00007161                 db 0FFh
.xdata$x:00007162                 db 0FFh
.xdata$x:00007163                 db 0FFh
.xdata$x:00007164                 dd offset __unwindfunclet$?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z$0
.xdata$x:00007168 __ehfuncinfo$?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z db  22h ; "
.xdata$x:00007168                                         ; DATA XREF: __ehhandler$?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z+11o
.xdata$x:00007169                 db    5
.xdata$x:0000716A                 db  93h ; ô
.xdata$x:0000716B                 db  19h
.xdata$x:0000716C                 db    1
.xdata$x:0000716D                 db    0
.xdata$x:0000716E                 db    0
.xdata$x:0000716F                 db    0
.xdata$x:00007170                 dd offset __unwindtable$?_Orphan_off@?$deque@URecentItem@@V?$allocator@URecentItem@@@std@@@std@@IBEXI@Z
.xdata$x:00007174                 db    0
.xdata$x:00007175                 db    0
.xdata$x:00007176                 db    0
.xdata$x:00007177                 db    0
.xdata$x:00007178                 db    0
.xdata$x:00007179                 db    0
.xdata$x:0000717A                 db    0
.xdata$x:0000717B                 db    0
.xdata$x:0000717C                 db    0
.xdata$x:0000717D                 db    0
.xdata$x:0000717E                 db    0
.xdata$x:0000717F                 db    0
.xdata$x:00007180                 db    0
.xdata$x:00007181                 db    0
.xdata$x:00007182                 db    0
.xdata$x:00007183                 db    0
.xdata$x:00007184                 db    0
.xdata$x:00007185                 db    0
.xdata$x:00007186                 db    0
.xdata$x:00007187                 db    0
.xdata$x:00007188                 db    0
.xdata$x:00007189                 db    0
.xdata$x:0000718A                 db    0
.xdata$x:0000718B                 db    0
.xdata$x:0000718B _xdata$x        ends
.xdata$x:0000718B
.xdata$x:0000718C ; ===========================================================================
.xdata$x:0000718C
.xdata$x:0000718C ; Segment type: Pure data
.xdata$x:0000718C ; Segment permissions: Read
.xdata$x:0000718C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000718C                 assume cs:_xdata$x
.xdata$x:0000718C                 ;org 718Ch
.xdata$x:0000718C ; COMDAT (pick associative to section at 1FB8)
.xdata$x:0000718C __unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000718C                                         ; DATA XREF: .xdata$x:0000719Co
.xdata$x:0000718D                 db 0FFh
.xdata$x:0000718E                 db 0FFh
.xdata$x:0000718F                 db 0FFh
.xdata$x:00007190                 dd offset __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0
.xdata$x:00007194 __ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00007194                                         ; DATA XREF: __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z+11o
.xdata$x:00007195                 db    5
.xdata$x:00007196                 db  93h ; ô
.xdata$x:00007197                 db  19h
.xdata$x:00007198                 db    1
.xdata$x:00007199                 db    0
.xdata$x:0000719A                 db    0
.xdata$x:0000719B                 db    0
.xdata$x:0000719C                 dd offset __unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.xdata$x:000071A0                 db    0
.xdata$x:000071A1                 db    0
.xdata$x:000071A2                 db    0
.xdata$x:000071A3                 db    0
.xdata$x:000071A4                 db    0
.xdata$x:000071A5                 db    0
.xdata$x:000071A6                 db    0
.xdata$x:000071A7                 db    0
.xdata$x:000071A8                 db    0
.xdata$x:000071A9                 db    0
.xdata$x:000071AA                 db    0
.xdata$x:000071AB                 db    0
.xdata$x:000071AC                 db    0
.xdata$x:000071AD                 db    0
.xdata$x:000071AE                 db    0
.xdata$x:000071AF                 db    0
.xdata$x:000071B0                 db    0
.xdata$x:000071B1                 db    0
.xdata$x:000071B2                 db    0
.xdata$x:000071B3                 db    0
.xdata$x:000071B4                 db    0
.xdata$x:000071B5                 db    0
.xdata$x:000071B6                 db    0
.xdata$x:000071B7                 db    0
.xdata$x:000071B7 _xdata$x        ends
.xdata$x:000071B7
.xdata$x:000071B8 ; ===========================================================================
.xdata$x:000071B8
.xdata$x:000071B8 ; Segment type: Pure data
.xdata$x:000071B8 ; Segment permissions: Read
.xdata$x:000071B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000071B8                 assume cs:_xdata$x
.xdata$x:000071B8                 ;org 71B8h
.xdata$x:000071B8 ; COMDAT (pick associative to section at 356C)
.xdata$x:000071B8 __unwindtable$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:000071B8                                         ; DATA XREF: .xdata$x:000071D0o
.xdata$x:000071B9                 db 0FFh
.xdata$x:000071BA                 db 0FFh
.xdata$x:000071BB                 db 0FFh
.xdata$x:000071BC                 dd offset __unwindfunclet$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:000071C0                 db    0
.xdata$x:000071C1                 db    0
.xdata$x:000071C2                 db    0
.xdata$x:000071C3                 db    0
.xdata$x:000071C4                 dd offset __unwindfunclet$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:000071C8 __ehfuncinfo$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:000071C8                                         ; DATA XREF: __ehhandler$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:000071C9                 db    5
.xdata$x:000071CA                 db  93h ; ô
.xdata$x:000071CB                 db  19h
.xdata$x:000071CC                 db    2
.xdata$x:000071CD                 db    0
.xdata$x:000071CE                 db    0
.xdata$x:000071CF                 db    0
.xdata$x:000071D0                 dd offset __unwindtable$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:000071D4                 db    0
.xdata$x:000071D5                 db    0
.xdata$x:000071D6                 db    0
.xdata$x:000071D7                 db    0
.xdata$x:000071D8                 db    0
.xdata$x:000071D9                 db    0
.xdata$x:000071DA                 db    0
.xdata$x:000071DB                 db    0
.xdata$x:000071DC                 db    0
.xdata$x:000071DD                 db    0
.xdata$x:000071DE                 db    0
.xdata$x:000071DF                 db    0
.xdata$x:000071E0                 db    0
.xdata$x:000071E1                 db    0
.xdata$x:000071E2                 db    0
.xdata$x:000071E3                 db    0
.xdata$x:000071E4                 db    0
.xdata$x:000071E5                 db    0
.xdata$x:000071E6                 db    0
.xdata$x:000071E7                 db    0
.xdata$x:000071E8                 db    0
.xdata$x:000071E9                 db    0
.xdata$x:000071EA                 db    0
.xdata$x:000071EB                 db    0
.xdata$x:000071EB _xdata$x        ends
.xdata$x:000071EB
.xdata$x:000071EC ; ===========================================================================
.xdata$x:000071EC
.xdata$x:000071EC ; Segment type: Pure data
.xdata$x:000071EC ; Segment permissions: Read
.xdata$x:000071EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000071EC                 assume cs:_xdata$x
.xdata$x:000071EC                 ;org 71ECh
.xdata$x:000071EC ; COMDAT (pick associative to section at 2938)
.xdata$x:000071EC __unwindtable$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000071EC                                         ; DATA XREF: .xdata$x:000071FCo
.xdata$x:000071ED                 db 0FFh
.xdata$x:000071EE                 db 0FFh
.xdata$x:000071EF                 db 0FFh
.xdata$x:000071F0                 dd offset __unwindfunclet$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000071F4 __ehfuncinfo$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000071F4                                         ; DATA XREF: __ehhandler$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000071F5                 db    5
.xdata$x:000071F6                 db  93h ; ô
.xdata$x:000071F7                 db  19h
.xdata$x:000071F8                 db    1
.xdata$x:000071F9                 db    0
.xdata$x:000071FA                 db    0
.xdata$x:000071FB                 db    0
.xdata$x:000071FC                 dd offset __unwindtable$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00007200                 db    0
.xdata$x:00007201                 db    0
.xdata$x:00007202                 db    0
.xdata$x:00007203                 db    0
.xdata$x:00007204                 db    0
.xdata$x:00007205                 db    0
.xdata$x:00007206                 db    0
.xdata$x:00007207                 db    0
.xdata$x:00007208                 db    0
.xdata$x:00007209                 db    0
.xdata$x:0000720A                 db    0
.xdata$x:0000720B                 db    0
.xdata$x:0000720C                 db    0
.xdata$x:0000720D                 db    0
.xdata$x:0000720E                 db    0
.xdata$x:0000720F                 db    0
.xdata$x:00007210                 db    0
.xdata$x:00007211                 db    0
.xdata$x:00007212                 db    0
.xdata$x:00007213                 db    0
.xdata$x:00007214                 db    0
.xdata$x:00007215                 db    0
.xdata$x:00007216                 db    0
.xdata$x:00007217                 db    0
.xdata$x:00007217 _xdata$x        ends
.xdata$x:00007217
.xdata$x:00007218 ; ===========================================================================
.xdata$x:00007218
.xdata$x:00007218 ; Segment type: Pure data
.xdata$x:00007218 ; Segment permissions: Read
.xdata$x:00007218 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007218                 assume cs:_xdata$x
.xdata$x:00007218                 ;org 7218h
.xdata$x:00007218 ; COMDAT (pick associative to section at 1F34)
.xdata$x:00007218 __unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00007218                                         ; DATA XREF: .xdata$x:00007228o
.xdata$x:00007219                 db 0FFh
.xdata$x:0000721A                 db 0FFh
.xdata$x:0000721B                 db 0FFh
.xdata$x:0000721C                 dd offset __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00007220 __ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00007220                                         ; DATA XREF: __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00007221                 db    5
.xdata$x:00007222                 db  93h ; ô
.xdata$x:00007223                 db  19h
.xdata$x:00007224                 db    1
.xdata$x:00007225                 db    0
.xdata$x:00007226                 db    0
.xdata$x:00007227                 db    0
.xdata$x:00007228                 dd offset __unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000722C                 db    0
.xdata$x:0000722D                 db    0
.xdata$x:0000722E                 db    0
.xdata$x:0000722F                 db    0
.xdata$x:00007230                 db    0
.xdata$x:00007231                 db    0
.xdata$x:00007232                 db    0
.xdata$x:00007233                 db    0
.xdata$x:00007234                 db    0
.xdata$x:00007235                 db    0
.xdata$x:00007236                 db    0
.xdata$x:00007237                 db    0
.xdata$x:00007238                 db    0
.xdata$x:00007239                 db    0
.xdata$x:0000723A                 db    0
.xdata$x:0000723B                 db    0
.xdata$x:0000723C                 db    0
.xdata$x:0000723D                 db    0
.xdata$x:0000723E                 db    0
.xdata$x:0000723F                 db    0
.xdata$x:00007240                 db    0
.xdata$x:00007241                 db    0
.xdata$x:00007242                 db    0
.xdata$x:00007243                 db    0
.xdata$x:00007243 _xdata$x        ends
.xdata$x:00007243
.xdata$x:00007244 ; ===========================================================================
.xdata$x:00007244
.xdata$x:00007244 ; Segment type: Pure data
.xdata$x:00007244 ; Segment permissions: Read
.xdata$x:00007244 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007244                 assume cs:_xdata$x
.xdata$x:00007244                 ;org 7244h
.xdata$x:00007244 ; COMDAT (pick associative to section at 20BC)
.xdata$x:00007244 __unwindtable$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z db 0FFh
.xdata$x:00007244                                         ; DATA XREF: .xdata$x:00007254o
.xdata$x:00007245                 db 0FFh
.xdata$x:00007246                 db 0FFh
.xdata$x:00007247                 db 0FFh
.xdata$x:00007248                 dd offset __unwindfunclet$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0
.xdata$x:0000724C __ehfuncinfo$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000724C                                         ; DATA XREF: __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z+11o
.xdata$x:0000724D                 db    5
.xdata$x:0000724E                 db  93h ; ô
.xdata$x:0000724F                 db  19h
.xdata$x:00007250                 db    1
.xdata$x:00007251                 db    0
.xdata$x:00007252                 db    0
.xdata$x:00007253                 db    0
.xdata$x:00007254                 dd offset __unwindtable$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.xdata$x:00007258                 db    0
.xdata$x:00007259                 db    0
.xdata$x:0000725A                 db    0
.xdata$x:0000725B                 db    0
.xdata$x:0000725C                 db    0
.xdata$x:0000725D                 db    0
.xdata$x:0000725E                 db    0
.xdata$x:0000725F                 db    0
.xdata$x:00007260                 db    0
.xdata$x:00007261                 db    0
.xdata$x:00007262                 db    0
.xdata$x:00007263                 db    0
.xdata$x:00007264                 db    0
.xdata$x:00007265                 db    0
.xdata$x:00007266                 db    0
.xdata$x:00007267                 db    0
.xdata$x:00007268                 db    0
.xdata$x:00007269                 db    0
.xdata$x:0000726A                 db    0
.xdata$x:0000726B                 db    0
.xdata$x:0000726C                 db    0
.xdata$x:0000726D                 db    0
.xdata$x:0000726E                 db    0
.xdata$x:0000726F                 db    0
.xdata$x:0000726F _xdata$x        ends
.xdata$x:0000726F
.xdata$x:00007270 ; ===========================================================================
.xdata$x:00007270
.xdata$x:00007270 ; Segment type: Pure data
.xdata$x:00007270 ; Segment permissions: Read
.xdata$x:00007270 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007270                 assume cs:_xdata$x
.xdata$x:00007270                 ;org 7270h
.xdata$x:00007270 ; COMDAT (pick associative to section at 3628)
.xdata$x:00007270 __unwindtable$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:00007270                                         ; DATA XREF: .xdata$x:00007288o
.xdata$x:00007271                 db 0FFh
.xdata$x:00007272                 db 0FFh
.xdata$x:00007273                 db 0FFh
.xdata$x:00007274                 dd offset __unwindfunclet$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:00007278                 db    0
.xdata$x:00007279                 db    0
.xdata$x:0000727A                 db    0
.xdata$x:0000727B                 db    0
.xdata$x:0000727C                 dd offset __unwindfunclet$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:00007280 __ehfuncinfo$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:00007280                                         ; DATA XREF: __ehhandler$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:00007281                 db    5
.xdata$x:00007282                 db  93h ; ô
.xdata$x:00007283                 db  19h
.xdata$x:00007284                 db    2
.xdata$x:00007285                 db    0
.xdata$x:00007286                 db    0
.xdata$x:00007287                 db    0
.xdata$x:00007288                 dd offset __unwindtable$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:0000728C                 db    0
.xdata$x:0000728D                 db    0
.xdata$x:0000728E                 db    0
.xdata$x:0000728F                 db    0
.xdata$x:00007290                 db    0
.xdata$x:00007291                 db    0
.xdata$x:00007292                 db    0
.xdata$x:00007293                 db    0
.xdata$x:00007294                 db    0
.xdata$x:00007295                 db    0
.xdata$x:00007296                 db    0
.xdata$x:00007297                 db    0
.xdata$x:00007298                 db    0
.xdata$x:00007299                 db    0
.xdata$x:0000729A                 db    0
.xdata$x:0000729B                 db    0
.xdata$x:0000729C                 db    0
.xdata$x:0000729D                 db    0
.xdata$x:0000729E                 db    0
.xdata$x:0000729F                 db    0
.xdata$x:000072A0                 db    0
.xdata$x:000072A1                 db    0
.xdata$x:000072A2                 db    0
.xdata$x:000072A3                 db    0
.xdata$x:000072A3 _xdata$x        ends
.xdata$x:000072A3
.xdata$x:000072A4 ; ===========================================================================
.xdata$x:000072A4
.xdata$x:000072A4 ; Segment type: Pure data
.xdata$x:000072A4 ; Segment permissions: Read
.xdata$x:000072A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000072A4                 assume cs:_xdata$x
.xdata$x:000072A4                 ;org 72A4h
.xdata$x:000072A4 ; COMDAT (pick associative to section at 3494)
.xdata$x:000072A4 __unwindtable$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:000072A4                                         ; DATA XREF: .xdata$x:000072BCo
.xdata$x:000072A5                 db 0FFh
.xdata$x:000072A6                 db 0FFh
.xdata$x:000072A7                 db 0FFh
.xdata$x:000072A8                 dd offset __unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:000072AC                 align 10h
.xdata$x:000072B0                 dd offset __unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:000072B4 __ehfuncinfo$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:000072B4                                         ; DATA XREF: __ehhandler$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:000072B5                 db    5
.xdata$x:000072B6                 db  93h ; ô
.xdata$x:000072B7                 db  19h
.xdata$x:000072B8                 db    2
.xdata$x:000072B9                 db    0
.xdata$x:000072BA                 db    0
.xdata$x:000072BB                 db    0
.xdata$x:000072BC                 dd offset __unwindtable$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:000072C0                 db    0
.xdata$x:000072C1                 db    0
.xdata$x:000072C2                 db    0
.xdata$x:000072C3                 db    0
.xdata$x:000072C4                 db    0
.xdata$x:000072C5                 db    0
.xdata$x:000072C6                 db    0
.xdata$x:000072C7                 db    0
.xdata$x:000072C8                 db    0
.xdata$x:000072C9                 db    0
.xdata$x:000072CA                 db    0
.xdata$x:000072CB                 db    0
.xdata$x:000072CC                 db    0
.xdata$x:000072CD                 db    0
.xdata$x:000072CE                 db    0
.xdata$x:000072CF                 db    0
.xdata$x:000072D0                 db    0
.xdata$x:000072D1                 db    0
.xdata$x:000072D2                 db    0
.xdata$x:000072D3                 db    0
.xdata$x:000072D4                 db    0
.xdata$x:000072D5                 db    0
.xdata$x:000072D6                 db    0
.xdata$x:000072D7                 db    0
.xdata$x:000072D7 _xdata$x        ends
.xdata$x:000072D7
.xdata$x:000072D8 ; ===========================================================================
.xdata$x:000072D8
.xdata$x:000072D8 ; Segment type: Pure data
.xdata$x:000072D8 ; Segment permissions: Read
.xdata$x:000072D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000072D8                 assume cs:_xdata$x
.xdata$x:000072D8                 ;org 72D8h
.xdata$x:000072D8 ; COMDAT (pick associative to section at 29A8)
.xdata$x:000072D8 __unwindtable$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000072D8                                         ; DATA XREF: .xdata$x:000072E8o
.xdata$x:000072D9                 db 0FFh
.xdata$x:000072DA                 db 0FFh
.xdata$x:000072DB                 db 0FFh
.xdata$x:000072DC                 dd offset __unwindfunclet$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000072E0 __ehfuncinfo$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000072E0                                         ; DATA XREF: __ehhandler$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000072E1                 db    5
.xdata$x:000072E2                 db  93h ; ô
.xdata$x:000072E3                 db  19h
.xdata$x:000072E4                 db    1
.xdata$x:000072E5                 db    0
.xdata$x:000072E6                 db    0
.xdata$x:000072E7                 db    0
.xdata$x:000072E8                 dd offset __unwindtable$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@XZ
.xdata$x:000072EC                 db    0
.xdata$x:000072ED                 db    0
.xdata$x:000072EE                 db    0
.xdata$x:000072EF                 db    0
.xdata$x:000072F0                 db    0
.xdata$x:000072F1                 db    0
.xdata$x:000072F2                 db    0
.xdata$x:000072F3                 db    0
.xdata$x:000072F4                 db    0
.xdata$x:000072F5                 db    0
.xdata$x:000072F6                 db    0
.xdata$x:000072F7                 db    0
.xdata$x:000072F8                 db    0
.xdata$x:000072F9                 db    0
.xdata$x:000072FA                 db    0
.xdata$x:000072FB                 db    0
.xdata$x:000072FC                 db    0
.xdata$x:000072FD                 db    0
.xdata$x:000072FE                 db    0
.xdata$x:000072FF                 db    0
.xdata$x:00007300                 db    0
.xdata$x:00007301                 db    0
.xdata$x:00007302                 db    0
.xdata$x:00007303                 db    0
.xdata$x:00007303 _xdata$x        ends
.xdata$x:00007303
.xdata$x:00007304 ; ===========================================================================
.xdata$x:00007304
.xdata$x:00007304 ; Segment type: Pure data
.xdata$x:00007304 ; Segment permissions: Read
.xdata$x:00007304 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007304                 assume cs:_xdata$x
.xdata$x:00007304                 ;org 7304h
.xdata$x:00007304 ; COMDAT (pick associative to section at 2044)
.xdata$x:00007304 __unwindtable$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00007304                                         ; DATA XREF: .xdata$x:00007314o
.xdata$x:00007305                 db 0FFh
.xdata$x:00007306                 db 0FFh
.xdata$x:00007307                 db 0FFh
.xdata$x:00007308                 dd offset __unwindfunclet$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000730C __ehfuncinfo$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000730C                                         ; DATA XREF: __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000730D                 db    5
.xdata$x:0000730E                 db  93h ; ô
.xdata$x:0000730F                 db  19h
.xdata$x:00007310                 db    1
.xdata$x:00007311                 db    0
.xdata$x:00007312                 db    0
.xdata$x:00007313                 db    0
.xdata$x:00007314                 dd offset __unwindtable$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00007318                 db    0
.xdata$x:00007319                 db    0
.xdata$x:0000731A                 db    0
.xdata$x:0000731B                 db    0
.xdata$x:0000731C                 db    0
.xdata$x:0000731D                 db    0
.xdata$x:0000731E                 db    0
.xdata$x:0000731F                 db    0
.xdata$x:00007320                 db    0
.xdata$x:00007321                 db    0
.xdata$x:00007322                 db    0
.xdata$x:00007323                 db    0
.xdata$x:00007324                 db    0
.xdata$x:00007325                 db    0
.xdata$x:00007326                 db    0
.xdata$x:00007327                 db    0
.xdata$x:00007328                 db    0
.xdata$x:00007329                 db    0
.xdata$x:0000732A                 db    0
.xdata$x:0000732B                 db    0
.xdata$x:0000732C                 db    0
.xdata$x:0000732D                 db    0
.xdata$x:0000732E                 db    0
.xdata$x:0000732F                 db    0
.xdata$x:0000732F _xdata$x        ends
.xdata$x:0000732F
.xdata$x:00007330 ; ===========================================================================
.xdata$x:00007330
.xdata$x:00007330 ; Segment type: Pure data
.xdata$x:00007330 ; Segment permissions: Read
.xdata$x:00007330 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007330                 assume cs:_xdata$x
.xdata$x:00007330                 ;org 7330h
.xdata$x:00007330 ; COMDAT (pick associative to section at 1330)
.xdata$x:00007330 __unwindtable$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z db 0FFh
.xdata$x:00007330                                         ; DATA XREF: .xdata$x:00007358o
.xdata$x:00007331                 db 0FFh
.xdata$x:00007332                 db 0FFh
.xdata$x:00007333                 db 0FFh
.xdata$x:00007334                 dd offset __unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z$0
.xdata$x:00007338                 db    0
.xdata$x:00007339                 db    0
.xdata$x:0000733A                 db    0
.xdata$x:0000733B                 db    0
.xdata$x:0000733C                 dd offset __unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z$1
.xdata$x:00007340                 db    1
.xdata$x:00007341                 db    0
.xdata$x:00007342                 db    0
.xdata$x:00007343                 db    0
.xdata$x:00007344                 dd offset __unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z$2
.xdata$x:00007348                 db    2
.xdata$x:00007349                 db    0
.xdata$x:0000734A                 db    0
.xdata$x:0000734B                 db    0
.xdata$x:0000734C                 dd offset __unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z$3
.xdata$x:00007350 __ehfuncinfo$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z db  22h ; "
.xdata$x:00007350                                         ; DATA XREF: __ehhandler$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z+11o
.xdata$x:00007351                 db    5
.xdata$x:00007352                 db  93h ; ô
.xdata$x:00007353                 db  19h
.xdata$x:00007354                 db    4
.xdata$x:00007355                 db    0
.xdata$x:00007356                 db    0
.xdata$x:00007357                 db    0
.xdata$x:00007358                 dd offset __unwindtable$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WI@Z
.xdata$x:0000735C                 db    0
.xdata$x:0000735D                 db    0
.xdata$x:0000735E                 db    0
.xdata$x:0000735F                 db    0
.xdata$x:00007360                 db    0
.xdata$x:00007361                 db    0
.xdata$x:00007362                 db    0
.xdata$x:00007363                 db    0
.xdata$x:00007364                 db    0
.xdata$x:00007365                 db    0
.xdata$x:00007366                 db    0
.xdata$x:00007367                 db    0
.xdata$x:00007368                 db    0
.xdata$x:00007369                 db    0
.xdata$x:0000736A                 db    0
.xdata$x:0000736B                 db    0
.xdata$x:0000736C                 db    0
.xdata$x:0000736D                 db    0
.xdata$x:0000736E                 db    0
.xdata$x:0000736F                 db    0
.xdata$x:00007370                 db    0
.xdata$x:00007371                 db    0
.xdata$x:00007372                 db    0
.xdata$x:00007373                 db    0
.xdata$x:00007373 _xdata$x        ends
.xdata$x:00007373
.xdata$x:00007374 ; ===========================================================================
.xdata$x:00007374
.xdata$x:00007374 ; Segment type: Pure data
.xdata$x:00007374 ; Segment permissions: Read
.xdata$x:00007374 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007374                 assume cs:_xdata$x
.xdata$x:00007374                 ;org 7374h
.xdata$x:00007374 ; COMDAT (pick associative to section at 1728)
.xdata$x:00007374 __ehfuncinfo$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z db  22h ; "
.xdata$x:00007374                                         ; DATA XREF: __ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z+11o
.xdata$x:00007375                 db    5
.xdata$x:00007376                 db  93h ; ô
.xdata$x:00007377                 db  19h
.xdata$x:00007378                 db    7
.xdata$x:00007379                 db    0
.xdata$x:0000737A                 db    0
.xdata$x:0000737B                 db    0
.xdata$x:0000737C                 dd offset __unwindtable$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z
.xdata$x:00007380                 db    0
.xdata$x:00007381                 db    0
.xdata$x:00007382                 db    0
.xdata$x:00007383                 db    0
.xdata$x:00007384                 db    0
.xdata$x:00007385                 db    0
.xdata$x:00007386                 db    0
.xdata$x:00007387                 db    0
.xdata$x:00007388                 db    0
.xdata$x:00007389                 db    0
.xdata$x:0000738A                 db    0
.xdata$x:0000738B                 db    0
.xdata$x:0000738C                 db    0
.xdata$x:0000738D                 db    0
.xdata$x:0000738E                 db    0
.xdata$x:0000738F                 db    0
.xdata$x:00007390                 db    0
.xdata$x:00007391                 db    0
.xdata$x:00007392                 db    0
.xdata$x:00007393                 db    0
.xdata$x:00007394                 db    0
.xdata$x:00007395                 db    0
.xdata$x:00007396                 db    0
.xdata$x:00007397                 db    0
.xdata$x:00007398 __unwindtable$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z db 0FFh
.xdata$x:00007398                                         ; DATA XREF: .xdata$x:0000737Co
.xdata$x:00007399                 db 0FFh
.xdata$x:0000739A                 db 0FFh
.xdata$x:0000739B                 db 0FFh
.xdata$x:0000739C                 dd offset __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$6
.xdata$x:000073A0                 db    0
.xdata$x:000073A1                 db    0
.xdata$x:000073A2                 db    0
.xdata$x:000073A3                 db    0
.xdata$x:000073A4                 dd offset __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$0
.xdata$x:000073A8                 db    1
.xdata$x:000073A9                 db    0
.xdata$x:000073AA                 db    0
.xdata$x:000073AB                 db    0
.xdata$x:000073AC                 dd offset __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$1
.xdata$x:000073B0                 db    2
.xdata$x:000073B1                 db    0
.xdata$x:000073B2                 db    0
.xdata$x:000073B3                 db    0
.xdata$x:000073B4                 dd offset __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$2
.xdata$x:000073B8                 db    3
.xdata$x:000073B9                 db    0
.xdata$x:000073BA                 db    0
.xdata$x:000073BB                 db    0
.xdata$x:000073BC                 dd offset __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$3
.xdata$x:000073C0                 db    4
.xdata$x:000073C1                 db    0
.xdata$x:000073C2                 db    0
.xdata$x:000073C3                 db    0
.xdata$x:000073C4                 dd offset __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$4
.xdata$x:000073C8                 db    5
.xdata$x:000073C9                 db    0
.xdata$x:000073CA                 db    0
.xdata$x:000073CB                 db    0
.xdata$x:000073CC                 dd offset __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$5
.xdata$x:000073CC _xdata$x        ends
.xdata$x:000073CC
.xdata$x:000073D0 ; ===========================================================================
.xdata$x:000073D0
.xdata$x:000073D0 ; Segment type: Pure data
.xdata$x:000073D0 ; Segment permissions: Read
.xdata$x:000073D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000073D0                 assume cs:_xdata$x
.xdata$x:000073D0                 ;org 73D0h
.xdata$x:000073D0 ; COMDAT (pick associative to section at 14BC)
.xdata$x:000073D0 __ehfuncinfo$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z db  22h ; "
.xdata$x:000073D0                                         ; DATA XREF: __ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z+11o
.xdata$x:000073D1                 db    5
.xdata$x:000073D2                 db  93h ; ô
.xdata$x:000073D3                 db  19h
.xdata$x:000073D4                 db    7
.xdata$x:000073D5                 db    0
.xdata$x:000073D6                 db    0
.xdata$x:000073D7                 db    0
.xdata$x:000073D8                 dd offset __unwindtable$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z
.xdata$x:000073DC                 db    0
.xdata$x:000073DD                 db    0
.xdata$x:000073DE                 db    0
.xdata$x:000073DF                 db    0
.xdata$x:000073E0                 db    0
.xdata$x:000073E1                 db    0
.xdata$x:000073E2                 db    0
.xdata$x:000073E3                 db    0
.xdata$x:000073E4                 db    0
.xdata$x:000073E5                 db    0
.xdata$x:000073E6                 db    0
.xdata$x:000073E7                 db    0
.xdata$x:000073E8                 db    0
.xdata$x:000073E9                 db    0
.xdata$x:000073EA                 db    0
.xdata$x:000073EB                 db    0
.xdata$x:000073EC                 db    0
.xdata$x:000073ED                 db    0
.xdata$x:000073EE                 db    0
.xdata$x:000073EF                 db    0
.xdata$x:000073F0                 db    0
.xdata$x:000073F1                 db    0
.xdata$x:000073F2                 db    0
.xdata$x:000073F3                 db    0
.xdata$x:000073F4 __unwindtable$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z db 0FFh
.xdata$x:000073F4                                         ; DATA XREF: .xdata$x:000073D8o
.xdata$x:000073F5                 db 0FFh
.xdata$x:000073F6                 db 0FFh
.xdata$x:000073F7                 db 0FFh
.xdata$x:000073F8                 dd offset __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$6
.xdata$x:000073FC                 align 10h
.xdata$x:00007400                 dd offset __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$0
.xdata$x:00007404                 db    1
.xdata$x:00007405                 db    0
.xdata$x:00007406                 db    0
.xdata$x:00007407                 db    0
.xdata$x:00007408                 dd offset __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$1
.xdata$x:0000740C                 db    2
.xdata$x:0000740D                 db    0
.xdata$x:0000740E                 db    0
.xdata$x:0000740F                 db    0
.xdata$x:00007410                 dd offset __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$2
.xdata$x:00007414                 db    3
.xdata$x:00007415                 db    0
.xdata$x:00007416                 db    0
.xdata$x:00007417                 db    0
.xdata$x:00007418                 dd offset __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$3
.xdata$x:0000741C                 db    4
.xdata$x:0000741D                 db    0
.xdata$x:0000741E                 db    0
.xdata$x:0000741F                 db    0
.xdata$x:00007420                 dd offset __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$4
.xdata$x:00007424                 db    5
.xdata$x:00007425                 db    0
.xdata$x:00007426                 db    0
.xdata$x:00007427                 db    0
.xdata$x:00007428                 dd offset __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00@Z$5
.xdata$x:00007428 _xdata$x        ends
.xdata$x:00007428
.xdata$x:0000742C ; ===========================================================================
.xdata$x:0000742C
.xdata$x:0000742C ; Segment type: Pure data
.xdata$x:0000742C ; Segment permissions: Read
.xdata$x:0000742C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000742C                 assume cs:_xdata$x
.xdata$x:0000742C                 ;org 742Ch
.xdata$x:0000742C ; COMDAT (pick associative to section at 1D70)
.xdata$x:0000742C __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:0000742C                                         ; DATA XREF: .xdata$x:0000743Co
.xdata$x:0000742D                 db 0FFh
.xdata$x:0000742E                 db 0FFh
.xdata$x:0000742F                 db 0FFh
.xdata$x:00007430                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00007434 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00007434                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00007435                 db    5
.xdata$x:00007436                 db  93h ; ô
.xdata$x:00007437                 db  19h
.xdata$x:00007438                 db    1
.xdata$x:00007439                 db    0
.xdata$x:0000743A                 db    0
.xdata$x:0000743B                 db    0
.xdata$x:0000743C                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00007440                 db    0
.xdata$x:00007441                 db    0
.xdata$x:00007442                 db    0
.xdata$x:00007443                 db    0
.xdata$x:00007444                 db    0
.xdata$x:00007445                 db    0
.xdata$x:00007446                 db    0
.xdata$x:00007447                 db    0
.xdata$x:00007448                 db    0
.xdata$x:00007449                 db    0
.xdata$x:0000744A                 db    0
.xdata$x:0000744B                 db    0
.xdata$x:0000744C                 db    0
.xdata$x:0000744D                 db    0
.xdata$x:0000744E                 db    0
.xdata$x:0000744F                 db    0
.xdata$x:00007450                 db    0
.xdata$x:00007451                 db    0
.xdata$x:00007452                 db    0
.xdata$x:00007453                 db    0
.xdata$x:00007454                 db    0
.xdata$x:00007455                 db    0
.xdata$x:00007456                 db    0
.xdata$x:00007457                 db    0
.xdata$x:00007457 _xdata$x        ends
.xdata$x:00007457
.xdata$x:00007458 ; ===========================================================================
.xdata$x:00007458
.xdata$x:00007458 ; Segment type: Pure data
.xdata$x:00007458 ; Segment permissions: Read
.xdata$x:00007458 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007458                 assume cs:_xdata$x
.xdata$x:00007458                 ;org 7458h
.xdata$x:00007458 ; COMDAT (pick associative to section at 1214)
.xdata$x:00007458 __unwindtable$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z db 0FFh
.xdata$x:00007458                                         ; DATA XREF: .xdata$x:00007470o
.xdata$x:00007459                 db 0FFh
.xdata$x:0000745A                 db 0FFh
.xdata$x:0000745B                 db 0FFh
.xdata$x:0000745C                 dd offset __unwindfunclet$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
.xdata$x:00007460                 db    0
.xdata$x:00007461                 db    0
.xdata$x:00007462                 db    0
.xdata$x:00007463                 db    0
.xdata$x:00007464                 dd offset __unwindfunclet$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
.xdata$x:00007468 __ehfuncinfo$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z db  22h ; "
.xdata$x:00007468                                         ; DATA XREF: __ehhandler$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z+11o
.xdata$x:00007469                 db    5
.xdata$x:0000746A                 db  93h ; ô
.xdata$x:0000746B                 db  19h
.xdata$x:0000746C                 db    2
.xdata$x:0000746D                 db    0
.xdata$x:0000746E                 db    0
.xdata$x:0000746F                 db    0
.xdata$x:00007470                 dd offset __unwindtable$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.xdata$x:00007474                 db    0
.xdata$x:00007475                 db    0
.xdata$x:00007476                 db    0
.xdata$x:00007477                 db    0
.xdata$x:00007478                 db    0
.xdata$x:00007479                 db    0
.xdata$x:0000747A                 db    0
.xdata$x:0000747B                 db    0
.xdata$x:0000747C                 db    0
.xdata$x:0000747D                 db    0
.xdata$x:0000747E                 db    0
.xdata$x:0000747F                 db    0
.xdata$x:00007480                 db    0
.xdata$x:00007481                 db    0
.xdata$x:00007482                 db    0
.xdata$x:00007483                 db    0
.xdata$x:00007484                 db    0
.xdata$x:00007485                 db    0
.xdata$x:00007486                 db    0
.xdata$x:00007487                 db    0
.xdata$x:00007488                 db    0
.xdata$x:00007489                 db    0
.xdata$x:0000748A                 db    0
.xdata$x:0000748B                 db    0
.xdata$x:0000748B _xdata$x        ends
.xdata$x:0000748B
.xdata$x:0000748C ; ===========================================================================
.xdata$x:0000748C
.xdata$x:0000748C ; Segment type: Pure data
.xdata$x:0000748C ; Segment permissions: Read
.xdata$x:0000748C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000748C                 assume cs:_xdata$x
.xdata$x:0000748C                 ;org 748Ch
.xdata$x:0000748C ; COMDAT (pick associative to section at 1884)
.xdata$x:0000748C __unwindtable$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000748C                                         ; DATA XREF: .xdata$x:000074B4o
.xdata$x:0000748D                 db 0FFh
.xdata$x:0000748E                 db 0FFh
.xdata$x:0000748F                 db 0FFh
.xdata$x:00007490                 dd offset __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$3
.xdata$x:00007494                 align 8
.xdata$x:00007498                 dd offset __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000749C                 db    1
.xdata$x:0000749D                 db    0
.xdata$x:0000749E                 db    0
.xdata$x:0000749F                 db    0
.xdata$x:000074A0                 dd offset __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$1
.xdata$x:000074A4                 db    2
.xdata$x:000074A5                 db    0
.xdata$x:000074A6                 db    0
.xdata$x:000074A7                 db    0
.xdata$x:000074A8                 dd offset __unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:000074AC __ehfuncinfo$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:000074AC                                         ; DATA XREF: __ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:000074AD                 db    5
.xdata$x:000074AE                 db  93h ; ô
.xdata$x:000074AF                 db  19h
.xdata$x:000074B0                 db    4
.xdata$x:000074B1                 db    0
.xdata$x:000074B2                 db    0
.xdata$x:000074B3                 db    0
.xdata$x:000074B4                 dd offset __unwindtable$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:000074B8                 db    0
.xdata$x:000074B9                 db    0
.xdata$x:000074BA                 db    0
.xdata$x:000074BB                 db    0
.xdata$x:000074BC                 db    0
.xdata$x:000074BD                 db    0
.xdata$x:000074BE                 db    0
.xdata$x:000074BF                 db    0
.xdata$x:000074C0                 db    0
.xdata$x:000074C1                 db    0
.xdata$x:000074C2                 db    0
.xdata$x:000074C3                 db    0
.xdata$x:000074C4                 db    0
.xdata$x:000074C5                 db    0
.xdata$x:000074C6                 db    0
.xdata$x:000074C7                 db    0
.xdata$x:000074C8                 db    0
.xdata$x:000074C9                 db    0
.xdata$x:000074CA                 db    0
.xdata$x:000074CB                 db    0
.xdata$x:000074CC                 db    0
.xdata$x:000074CD                 db    0
.xdata$x:000074CE                 db    0
.xdata$x:000074CF                 db    0
.xdata$x:000074CF _xdata$x        ends
.xdata$x:000074CF
.xdata$x:000074D0 ; ===========================================================================
.xdata$x:000074D0
.xdata$x:000074D0 ; Segment type: Pure data
.xdata$x:000074D0 ; Segment permissions: Read
.xdata$x:000074D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000074D0                 assume cs:_xdata$x
.xdata$x:000074D0                 ;org 74D0h
.xdata$x:000074D0 ; COMDAT (pick associative to section at 1618)
.xdata$x:000074D0 __unwindtable$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:000074D0                                         ; DATA XREF: .xdata$x:000074F8o
.xdata$x:000074D1                 db 0FFh
.xdata$x:000074D2                 db 0FFh
.xdata$x:000074D3                 db 0FFh
.xdata$x:000074D4                 dd offset __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$3
.xdata$x:000074D8                 db    0
.xdata$x:000074D9                 db    0
.xdata$x:000074DA                 db    0
.xdata$x:000074DB                 db    0
.xdata$x:000074DC                 dd offset __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:000074E0                 db    1
.xdata$x:000074E1                 db    0
.xdata$x:000074E2                 db    0
.xdata$x:000074E3                 db    0
.xdata$x:000074E4                 dd offset __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$1
.xdata$x:000074E8                 db    2
.xdata$x:000074E9                 db    0
.xdata$x:000074EA                 db    0
.xdata$x:000074EB                 db    0
.xdata$x:000074EC                 dd offset __unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:000074F0 __ehfuncinfo$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:000074F0                                         ; DATA XREF: __ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:000074F1                 db    5
.xdata$x:000074F2                 db  93h ; ô
.xdata$x:000074F3                 db  19h
.xdata$x:000074F4                 db    4
.xdata$x:000074F5                 db    0
.xdata$x:000074F6                 db    0
.xdata$x:000074F7                 db    0
.xdata$x:000074F8                 dd offset __unwindtable$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@URecentItem@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:000074FC                 db    0
.xdata$x:000074FD                 db    0
.xdata$x:000074FE                 db    0
.xdata$x:000074FF                 db    0
.xdata$x:00007500                 db    0
.xdata$x:00007501                 db    0
.xdata$x:00007502                 db    0
.xdata$x:00007503                 db    0
.xdata$x:00007504                 db    0
.xdata$x:00007505                 db    0
.xdata$x:00007506                 db    0
.xdata$x:00007507                 db    0
.xdata$x:00007508                 db    0
.xdata$x:00007509                 db    0
.xdata$x:0000750A                 db    0
.xdata$x:0000750B                 db    0
.xdata$x:0000750C                 db    0
.xdata$x:0000750D                 db    0
.xdata$x:0000750E                 db    0
.xdata$x:0000750F                 db    0
.xdata$x:00007510                 db    0
.xdata$x:00007511                 db    0
.xdata$x:00007512                 db    0
.xdata$x:00007513                 db    0
.xdata$x:00007513 _xdata$x        ends
.xdata$x:00007513
.xdata$x:00007514 ; ===========================================================================
.xdata$x:00007514
.xdata$x:00007514 ; Segment type: Pure data
.xdata$x:00007514 ; Segment permissions: Read
.xdata$x:00007514 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007514                 assume cs:_xdata$x
.xdata$x:00007514                 ;org 7514h
.xdata$x:00007514 ; COMDAT (pick associative to section at 1B50)
.xdata$x:00007514 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00007514                                         ; DATA XREF: .xdata$x:00007524o
.xdata$x:00007515                 db 0FFh
.xdata$x:00007516                 db 0FFh
.xdata$x:00007517                 db 0FFh
.xdata$x:00007518                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:0000751C __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:0000751C                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:0000751D                 db    5
.xdata$x:0000751E                 db  93h ; ô
.xdata$x:0000751F                 db  19h
.xdata$x:00007520                 db    1
.xdata$x:00007521                 db    0
.xdata$x:00007522                 db    0
.xdata$x:00007523                 db    0
.xdata$x:00007524                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00007528                 align 20h
.xdata$x:00007528 _xdata$x        ends
.xdata$x:00007528
.xdata$x:00007540 ; ===========================================================================
.xdata$x:00007540
.xdata$x:00007540 ; Segment type: Pure data
.xdata$x:00007540 ; Segment permissions: Read
.xdata$x:00007540 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007540                 assume cs:_xdata$x
.xdata$x:00007540                 ;org 7540h
.xdata$x:00007540 ; COMDAT (pick associative to section at 1C50)
.xdata$x:00007540 __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:00007540                                         ; DATA XREF: .xdata$x:00007550o
.xdata$x:00007541                 db 0FFh
.xdata$x:00007542                 db 0FFh
.xdata$x:00007543                 db 0FFh
.xdata$x:00007544                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:00007548 __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:00007548                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:00007549                 db    5
.xdata$x:0000754A                 db  93h ; ô
.xdata$x:0000754B                 db  19h
.xdata$x:0000754C                 db    1
.xdata$x:0000754D                 db    0
.xdata$x:0000754E                 db    0
.xdata$x:0000754F                 db    0
.xdata$x:00007550                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:00007554                 db    0
.xdata$x:00007555                 db    0
.xdata$x:00007556                 db    0
.xdata$x:00007557                 db    0
.xdata$x:00007558                 db    0
.xdata$x:00007559                 db    0
.xdata$x:0000755A                 db    0
.xdata$x:0000755B                 db    0
.xdata$x:0000755C                 db    0
.xdata$x:0000755D                 db    0
.xdata$x:0000755E                 db    0
.xdata$x:0000755F                 db    0
.xdata$x:00007560                 db    0
.xdata$x:00007561                 db    0
.xdata$x:00007562                 db    0
.xdata$x:00007563                 db    0
.xdata$x:00007564                 db    0
.xdata$x:00007565                 db    0
.xdata$x:00007566                 db    0
.xdata$x:00007567                 db    0
.xdata$x:00007568                 db    0
.xdata$x:00007569                 db    0
.xdata$x:0000756A                 db    0
.xdata$x:0000756B                 db    0
.xdata$x:0000756B _xdata$x        ends
.xdata$x:0000756B
.bss:0000756C ; ===========================================================================
.bss:0000756C
.bss:0000756C ; Segment type: Uninitialized
.bss:0000756C ; Segment permissions: Read/Write
.bss:0000756C _bss            segment byte public 'BSS' use32
.bss:0000756C                 assume cs:_bss
.bss:0000756C                 ;org 756Ch
.bss:0000756C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000756C _allocator_arg  db    ? ;
.bss:0000756D _piecewise_construct db    ? ;
.bss:0000756E                 align 10h
.bss:0000756E _bss            ends
.bss:0000756E
.rdata:00007570 ; ===========================================================================
.rdata:00007570
.rdata:00007570 ; Segment type: Pure data
.rdata:00007570 ; Segment permissions: Read
.rdata:00007570 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007570 _rdata          segment para public 'DATA' use32
.rdata:00007570                 assume cs:_rdata
.rdata:00007570                 ;org 7570h
.rdata:00007570 ; COMDAT (pick any)
.rdata:00007570                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00007570 ; wchar_t `string'
.rdata:00007570 ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00007570                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+48o
.rdata:00007570                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00007570                 unicode 0, <clude\xutility>,0
.rdata:00007570 _rdata          ends
.rdata:00007570
.rdata:00007600 ; ===========================================================================
.rdata:00007600
.rdata:00007600 ; Segment type: Pure data
.rdata:00007600 ; Segment permissions: Read
.rdata:00007600 _rdata          segment dword public 'DATA' use32
.rdata:00007600                 assume cs:_rdata
.rdata:00007600                 ;org 7600h
.rdata:00007600 ; COMDAT (pick any)
.rdata:00007600                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:00007600 ; wchar_t `string'
.rdata:00007600 ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:00007600                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:00007600                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:00007632                 align 4
.rdata:00007632 _rdata          ends
.rdata:00007632
.rdata:00007634 ; ===========================================================================
.rdata:00007634
.rdata:00007634 ; Segment type: Pure data
.rdata:00007634 ; Segment permissions: Read
.rdata:00007634 _rdata          segment dword public 'DATA' use32
.rdata:00007634                 assume cs:_rdata
.rdata:00007634                 ;org 7634h
.rdata:00007634 ; COMDAT (pick largest)
.rdata:00007634                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00007638                 public ??_7error_category@std@@6B@
.rdata:00007638 ; const std::error_category::`vftable'
.rdata:00007638 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00007638                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00007638                                         ; std::error_category::~error_category(void)+Ao
.rdata:00007638                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:0000763C                 dd offset __purecall
.rdata:00007640                 dd offset __purecall
.rdata:00007644                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00007648                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000764C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000764C _rdata          ends
.rdata:0000764C
.rdata:00007650 ; ===========================================================================
.rdata:00007650
.rdata:00007650 ; Segment type: Pure data
.rdata:00007650 ; Segment permissions: Read
.rdata:00007650 _rdata          segment dword public 'DATA' use32
.rdata:00007650                 assume cs:_rdata
.rdata:00007650                 ;org 7650h
.rdata:00007650 ; COMDAT (pick largest)
.rdata:00007650                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00007654                 public ??_7_Generic_error_category@std@@6B@
.rdata:00007654 ; const std::_Generic_error_category::`vftable'
.rdata:00007654 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00007654                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00007654                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00007658                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:0000765C                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00007660                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00007664                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00007668                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00007668 _rdata          ends
.rdata:00007668
.rdata:0000766C ; ===========================================================================
.rdata:0000766C
.rdata:0000766C ; Segment type: Pure data
.rdata:0000766C ; Segment permissions: Read
.rdata:0000766C _rdata          segment dword public 'DATA' use32
.rdata:0000766C                 assume cs:_rdata
.rdata:0000766C                 ;org 766Ch
.rdata:0000766C ; COMDAT (pick any)
.rdata:0000766C                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:0000766C ; `string'
.rdata:0000766C ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:0000766C                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:0000766C _rdata          ends
.rdata:0000766C
.rdata:00007674 ; ===========================================================================
.rdata:00007674
.rdata:00007674 ; Segment type: Pure data
.rdata:00007674 ; Segment permissions: Read
.rdata:00007674 _rdata          segment dword public 'DATA' use32
.rdata:00007674                 assume cs:_rdata
.rdata:00007674                 ;org 7674h
.rdata:00007674 ; COMDAT (pick any)
.rdata:00007674                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00007674 ; `string'
.rdata:00007674 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00007674                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_6198o
.rdata:00007674                                         ; std::_System_error_category::message(int):loc_6314o
.rdata:00007682                 align 4
.rdata:00007682 _rdata          ends
.rdata:00007682
.rdata:00007684 ; ===========================================================================
.rdata:00007684
.rdata:00007684 ; Segment type: Pure data
.rdata:00007684 ; Segment permissions: Read
.rdata:00007684 _rdata          segment dword public 'DATA' use32
.rdata:00007684                 assume cs:_rdata
.rdata:00007684                 ;org 7684h
.rdata:00007684 ; COMDAT (pick largest)
.rdata:00007684                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00007688                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00007688 ; const std::_Iostream_error_category::`vftable'
.rdata:00007688 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00007688                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00007688                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:0000768C                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00007690                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00007694                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00007698                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000769C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000769C _rdata          ends
.rdata:0000769C
.rdata:000076A0 ; ===========================================================================
.rdata:000076A0
.rdata:000076A0 ; Segment type: Pure data
.rdata:000076A0 ; Segment permissions: Read
.rdata:000076A0 _rdata          segment dword public 'DATA' use32
.rdata:000076A0                 assume cs:_rdata
.rdata:000076A0                 ;org 76A0h
.rdata:000076A0 ; COMDAT (pick any)
.rdata:000076A0                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:000076A0 ; `string'
.rdata:000076A0 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:000076A0                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:000076A9                 align 4
.rdata:000076A9 _rdata          ends
.rdata:000076A9
.rdata:000076AC ; ===========================================================================
.rdata:000076AC
.rdata:000076AC ; Segment type: Pure data
.rdata:000076AC ; Segment permissions: Read
.rdata:000076AC _rdata          segment dword public 'DATA' use32
.rdata:000076AC                 assume cs:_rdata
.rdata:000076AC                 ;org 76ACh
.rdata:000076AC ; COMDAT (pick any)
.rdata:000076AC                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:000076AC ; char `string'[]
.rdata:000076AC ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:000076AC                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:000076C2                 align 4
.rdata:000076C2 _rdata          ends
.rdata:000076C2
.rdata:000076C4 ; ===========================================================================
.rdata:000076C4
.rdata:000076C4 ; Segment type: Pure data
.rdata:000076C4 ; Segment permissions: Read
.rdata:000076C4 _rdata          segment dword public 'DATA' use32
.rdata:000076C4                 assume cs:_rdata
.rdata:000076C4                 ;org 76C4h
.rdata:000076C4 ; COMDAT (pick largest)
.rdata:000076C4                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:000076C8                 public ??_7_System_error_category@std@@6B@
.rdata:000076C8 ; const std::_System_error_category::`vftable'
.rdata:000076C8 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:000076C8                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:000076C8                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:000076CC                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:000076D0                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:000076D4                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:000076D8                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000076DC                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000076DC _rdata          ends
.rdata:000076DC
.rdata:000076E0 ; ===========================================================================
.rdata:000076E0
.rdata:000076E0 ; Segment type: Pure data
.rdata:000076E0 ; Segment permissions: Read
.rdata:000076E0 _rdata          segment dword public 'DATA' use32
.rdata:000076E0                 assume cs:_rdata
.rdata:000076E0                 ;org 76E0h
.rdata:000076E0 ; COMDAT (pick any)
.rdata:000076E0                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:000076E0 ; `string'
.rdata:000076E0 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:000076E0                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:000076E7                 align 4
.rdata:000076E7 _rdata          ends
.rdata:000076E7
.bss:000076E8 ; ===========================================================================
.bss:000076E8
.bss:000076E8 ; Segment type: Uninitialized
.bss:000076E8 ; Segment permissions: Read/Write
.bss:000076E8 _bss            segment dword public 'BSS' use32
.bss:000076E8                 assume cs:_bss
.bss:000076E8                 ;org 76E8h
.bss:000076E8 ; COMDAT (pick any)
.bss:000076E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000076E8                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:000076E8 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:000076E8 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:000076E8                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:000076E8                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:000076E9                 db    ? ;
.bss:000076EA                 db    ? ;
.bss:000076EB                 db    ? ;
.bss:000076EB _bss            ends
.bss:000076EB
.bss:000076EC ; ===========================================================================
.bss:000076EC
.bss:000076EC ; Segment type: Uninitialized
.bss:000076EC ; Segment permissions: Read/Write
.bss:000076EC _bss            segment dword public 'BSS' use32
.bss:000076EC                 assume cs:_bss
.bss:000076EC                 ;org 76ECh
.bss:000076EC ; COMDAT (pick any)
.bss:000076EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000076EC                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:000076EC ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:000076EC ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:000076EC                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000076EC                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000076ED                 db    ? ;
.bss:000076EE                 db    ? ;
.bss:000076EF                 db    ? ;
.bss:000076EF _bss            ends
.bss:000076EF
.bss:000076F0 ; ===========================================================================
.bss:000076F0
.bss:000076F0 ; Segment type: Uninitialized
.bss:000076F0 ; Segment permissions: Read/Write
.bss:000076F0 _bss            segment dword public 'BSS' use32
.bss:000076F0                 assume cs:_bss
.bss:000076F0                 ;org 76F0h
.bss:000076F0 ; COMDAT (pick any)
.bss:000076F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000076F0                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:000076F0 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:000076F0 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:000076F0                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:000076F0                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:000076F1                 db    ? ;
.bss:000076F2                 db    ? ;
.bss:000076F3                 db    ? ;
.bss:000076F3 _bss            ends
.bss:000076F3
.rdata:000076F4 ; ===========================================================================
.rdata:000076F4
.rdata:000076F4 ; Segment type: Pure data
.rdata:000076F4 ; Segment permissions: Read
.rdata:000076F4 _rdata          segment dword public 'DATA' use32
.rdata:000076F4                 assume cs:_rdata
.rdata:000076F4                 ;org 76F4h
.rdata:000076F4 ; COMDAT (pick any)
.rdata:000076F4                 public ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
.rdata:000076F4 ; public: static unsigned int const std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::npos
.rdata:000076F4 ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB dd 0FFFFFFFFh
.rdata:000076F4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Br
.rdata:000076F4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+7r
.rdata:000076F4 _rdata          ends
.rdata:000076F4
.bss:000076F8 ; ===========================================================================
.bss:000076F8
.bss:000076F8 ; Segment type: Uninitialized
.bss:000076F8 ; Segment permissions: Read/Write
.bss:000076F8 _bss            segment dword public 'BSS' use32
.bss:000076F8                 assume cs:_bss
.bss:000076F8                 ;org 76F8h
.bss:000076F8 ; COMDAT (pick any)
.bss:000076F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000076F8                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:000076F8 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:000076F8 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:000076F8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:000076F9                 db    ? ;
.bss:000076FA                 db    ? ;
.bss:000076FB                 db    ? ;
.bss:000076FB _bss            ends
.bss:000076FB
.bss:000076FC ; ===========================================================================
.bss:000076FC
.bss:000076FC ; Segment type: Uninitialized
.bss:000076FC ; Segment permissions: Read/Write
.bss:000076FC _bss            segment dword public 'BSS' use32
.bss:000076FC                 assume cs:_bss
.bss:000076FC                 ;org 76FCh
.bss:000076FC ; COMDAT (pick any)
.bss:000076FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000076FC                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:000076FC ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:000076FC ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:000076FC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:000076FD                 db    ? ;
.bss:000076FE                 db    ? ;
.bss:000076FF                 db    ? ;
.bss:000076FF _bss            ends
.bss:000076FF
.rdata:00007700 ; ===========================================================================
.rdata:00007700
.rdata:00007700 ; Segment type: Pure data
.rdata:00007700 ; Segment permissions: Read
.rdata:00007700 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007700 _rdata          segment para public 'DATA' use32
.rdata:00007700                 assume cs:_rdata
.rdata:00007700                 ;org 7700h
.rdata:00007700 ; COMDAT (pick any)
.rdata:00007700                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00007700 ; wchar_t `string'
.rdata:00007700 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00007700                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00007700                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o ...
.rdata:00007700                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00007700                 unicode 0, <clude\xstring>,0
.rdata:0000778E                 align 10h
.rdata:0000778E _rdata          ends
.rdata:0000778E
.bss:00007790 ; ===========================================================================
.bss:00007790
.bss:00007790 ; Segment type: Uninitialized
.bss:00007790 ; Segment permissions: Read/Write
.bss:00007790 _bss            segment dword public 'BSS' use32
.bss:00007790                 assume cs:_bss
.bss:00007790                 ;org 7790h
.bss:00007790 ; COMDAT (pick any)
.bss:00007790                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00007790                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00007790 ; std::locale::id std::numpunct<char>::id
.bss:00007790 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00007790                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00007791                 db    ? ;
.bss:00007792                 db    ? ;
.bss:00007793                 db    ? ;
.bss:00007793 _bss            ends
.bss:00007793
.bss:00007794 ; ===========================================================================
.bss:00007794
.bss:00007794 ; Segment type: Uninitialized
.bss:00007794 ; Segment permissions: Read/Write
.bss:00007794 _bss            segment dword public 'BSS' use32
.bss:00007794                 assume cs:_bss
.bss:00007794                 ;org 7794h
.bss:00007794 ; COMDAT (pick any)
.bss:00007794                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00007794                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00007794 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00007794 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00007794                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00007795                 db    ? ;
.bss:00007796                 db    ? ;
.bss:00007797                 db    ? ;
.bss:00007797 _bss            ends
.bss:00007797
.rdata:00007798 ; ===========================================================================
.rdata:00007798
.rdata:00007798 ; Segment type: Pure data
.rdata:00007798 ; Segment permissions: Read
.rdata:00007798 _rdata          segment dword public 'DATA' use32
.rdata:00007798                 assume cs:_rdata
.rdata:00007798                 ;org 7798h
.rdata:00007798 ; COMDAT (pick any)
.rdata:00007798                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:00007798 ; `string'
.rdata:00007798 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:00007798                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+53o
.rdata:00007798                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)+45o ...
.rdata:00007798 _rdata          ends
.rdata:00007798
.rdata:000077BC ; ===========================================================================
.rdata:000077BC
.rdata:000077BC ; Segment type: Pure data
.rdata:000077BC ; Segment permissions: Read
.rdata:000077BC ; Segment alignment 'qword' can not be represented in assembly
.rdata:000077BC _rdata          segment para public 'DATA' use32
.rdata:000077BC                 assume cs:_rdata
.rdata:000077BC                 ;org 77BCh
.rdata:000077BC ; COMDAT (pick any)
.rdata:000077BC                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:000077BC ; `string'
.rdata:000077BC ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:000077BC                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void):loc_322Co
.rdata:000077BC                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void):loc_3312o ...
.rdata:000077BC                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:00007812                 align 4
.rdata:00007812 _rdata          ends
.rdata:00007812
.rdata:00007814 ; ===========================================================================
.rdata:00007814
.rdata:00007814 ; Segment type: Pure data
.rdata:00007814 ; Segment permissions: Read
.rdata:00007814 _rdata          segment dword public 'DATA' use32
.rdata:00007814                 assume cs:_rdata
.rdata:00007814                 ;org 7814h
.rdata:00007814 ; COMDAT (pick any)
.rdata:00007814                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:00007814 ; `string'
.rdata:00007814 ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:00007814                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+65o
.rdata:00007814                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)+57o ...
.rdata:00007814                 unicode 0, <%s>,0
.rdata:0000781A                 align 4
.rdata:0000781A _rdata          ends
.rdata:0000781A
.rdata:0000781C ; ===========================================================================
.rdata:0000781C
.rdata:0000781C ; Segment type: Pure data
.rdata:0000781C ; Segment permissions: Read
.rdata:0000781C _rdata          segment dword public 'DATA' use32
.rdata:0000781C                 assume cs:_rdata
.rdata:0000781C                 ;org 781Ch
.rdata:0000781C ; COMDAT (pick any)
.rdata:0000781C                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:0000781C ; `string'
.rdata:0000781C ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:0000781C                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+97o
.rdata:0000781C                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)+89o ...
.rdata:0000781C                 unicode 0, <"out of range">,0
.rdata:0000783A                 align 4
.rdata:0000783A _rdata          ends
.rdata:0000783A
.rdata:0000783C ; ===========================================================================
.rdata:0000783C
.rdata:0000783C ; Segment type: Pure data
.rdata:0000783C ; Segment permissions: Read
.rdata:0000783C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000783C _rdata          segment para public 'DATA' use32
.rdata:0000783C                 assume cs:_rdata
.rdata:0000783C                 ;org 783Ch
.rdata:0000783C ; COMDAT (pick any)
.rdata:0000783C                 public ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000783C ; wchar_t `string'
.rdata:0000783C ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000783C                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+41o
.rdata:0000783C                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+71o ...
.rdata:0000783C                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000783C                 unicode 0, <clude\deque>,0
.rdata:000078C6                 align 4
.rdata:000078C6 _rdata          ends
.rdata:000078C6
.rdata:000078C8 ; ===========================================================================
.rdata:000078C8
.rdata:000078C8 ; Segment type: Pure data
.rdata:000078C8 ; Segment permissions: Read
.rdata:000078C8 _rdata          segment dword public 'DATA' use32
.rdata:000078C8                 assume cs:_rdata
.rdata:000078C8                 ;org 78C8h
.rdata:000078C8 ; COMDAT (pick any)
.rdata:000078C8                 public ??_C@_1CO@FNIDKHMC@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@
.rdata:000078C8 ; wchar_t `string'
.rdata:000078C8 ??_C@_1CO@FNIDKHMC@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@:
.rdata:000078C8                                         ; DATA XREF: std::deque<RecentItem,std::allocator<RecentItem>>::pop_back(void)+23o
.rdata:000078C8                                         ; std::deque<RecentItem,std::allocator<RecentItem>>::pop_front(void)+23o
.rdata:000078C8                 unicode 0, <deque empty before pop>,0
.rdata:000078F6                 align 4
.rdata:000078F6 _rdata          ends
.rdata:000078F6
.rdata:000078F8 ; ===========================================================================
.rdata:000078F8
.rdata:000078F8 ; Segment type: Pure data
.rdata:000078F8 ; Segment permissions: Read
.rdata:000078F8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000078F8 _rdata          segment para public 'DATA' use32
.rdata:000078F8                 assume cs:_rdata
.rdata:000078F8                 ;org 78F8h
.rdata:000078F8 ; COMDAT (pick any)
.rdata:000078F8                 public ??_C@_1EG@IIKPBBHP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa?$AAn@
.rdata:000078F8 ; wchar_t `string'
.rdata:000078F8 ??_C@_1EG@IIKPBBHP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa?$AAn@:
.rdata:000078F8                                         ; DATA XREF: std::deque<RecentItem,std::allocator<RecentItem>>::erase(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>)+1B5o
.rdata:000078F8                 unicode 0, <deque erase iterator outside range>,0
.rdata:0000793E                 align 10h
.rdata:0000793E _rdata          ends
.rdata:0000793E
.rdata:00007940 ; ===========================================================================
.rdata:00007940
.rdata:00007940 ; Segment type: Pure data
.rdata:00007940 ; Segment permissions: Read
.rdata:00007940 _rdata          segment dword public 'DATA' use32
.rdata:00007940                 assume cs:_rdata
.rdata:00007940                 ;org 7940h
.rdata:00007940 ; COMDAT (pick any)
.rdata:00007940                 public ??_C@_0BL@KOKKEGGO@invalid?5deque?$DMT?$DO?5subscript?$AA@
.rdata:00007940 ; char `string'[]
.rdata:00007940 ??_C@_0BL@KOKKEGGO@invalid?5deque?$DMT?$DO?5subscript?$AA@ db 'invalid deque<T> subscript',0
.rdata:00007940                                         ; DATA XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Xran(void)+7o
.rdata:0000795B                 align 4
.rdata:0000795B _rdata          ends
.rdata:0000795B
.rdata:0000795C ; ===========================================================================
.rdata:0000795C
.rdata:0000795C ; Segment type: Pure data
.rdata:0000795C ; Segment permissions: Read
.rdata:0000795C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000795C _rdata          segment para public 'DATA' use32
.rdata:0000795C                 assume cs:_rdata
.rdata:0000795C                 ;org 795Ch
.rdata:0000795C ; COMDAT (pick any)
.rdata:0000795C                 public ??_C@_1EE@INPCGGNP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb?$AAl@
.rdata:0000795C ; wchar_t `string'
.rdata:0000795C ??_C@_1EE@INPCGGNP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb?$AAl@:
.rdata:0000795C                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+46o
.rdata:0000795C                 unicode 0, <deque iterator not dereferencable>,0
.rdata:0000795C _rdata          ends
.rdata:0000795C
.rdata:000079A0 ; ===========================================================================
.rdata:000079A0
.rdata:000079A0 ; Segment type: Pure data
.rdata:000079A0 ; Segment permissions: Read
.rdata:000079A0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000079A0 _rdata          segment para public 'DATA' use32
.rdata:000079A0                 assume cs:_rdata
.rdata:000079A0                 ;org 79A0h
.rdata:000079A0 ; COMDAT (pick any)
.rdata:000079A0                 public ??_C@_1OI@NHIMBGBK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
.rdata:000079A0 ; `string'
.rdata:000079A0 ??_C@_1OI@NHIMBGBK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@:
.rdata:000079A0                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+92o
.rdata:000079A0                 unicode 0, <std::_Deque_const_iterator>
.rdata:000079A0                 dw 3Ch
.rdata:000079A0                 unicode 0, <class std::_Deque_val>
.rdata:000079A0                 dw 3Ch
.rdata:000079A0                 unicode 0, <struct std::_Deque_simple_types>
.rdata:000079A0                 dw 3Ch
.rdata:000079A0                 unicode 0, <struct RecentItem>
.rdata:000079A0                 dw 3Eh
.rdata:000079A0                 unicode 0, < >
.rdata:000079A0                 dw 3Eh
.rdata:000079A0                 unicode 0, < >
.rdata:000079A0                 dw 3Eh
.rdata:000079A0                 unicode 0, <::operator *>,0
.rdata:000079A0 _rdata          ends
.rdata:000079A0
.rdata:00007A88 ; ===========================================================================
.rdata:00007A88
.rdata:00007A88 ; Segment type: Pure data
.rdata:00007A88 ; Segment permissions: Read
.rdata:00007A88 _rdata          segment dword public 'DATA' use32
.rdata:00007A88                 assume cs:_rdata
.rdata:00007A88                 ;org 7A88h
.rdata:00007A88 ; COMDAT (pick any)
.rdata:00007A88                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00007A88 ; char `string'[]
.rdata:00007A88 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00007A88                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00007A88                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:00007A88 _rdata          ends
.rdata:00007A88
.rdata:00007A98 ; ===========================================================================
.rdata:00007A98
.rdata:00007A98 ; Segment type: Pure data
.rdata:00007A98 ; Segment permissions: Read
.rdata:00007A98 _rdata          segment dword public 'DATA' use32
.rdata:00007A98                 assume cs:_rdata
.rdata:00007A98                 ;org 7A98h
.rdata:00007A98 ; COMDAT (pick any)
.rdata:00007A98                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00007A98 ; char `string'[]
.rdata:00007A98 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00007A98                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00007A98                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:00007A98 _rdata          ends
.rdata:00007A98
.rdata:00007AB0 ; ===========================================================================
.rdata:00007AB0
.rdata:00007AB0 ; Segment type: Pure data
.rdata:00007AB0 ; Segment permissions: Read
.rdata:00007AB0 _rdata          segment dword public 'DATA' use32
.rdata:00007AB0                 assume cs:_rdata
.rdata:00007AB0                 ;org 7AB0h
.rdata:00007AB0 ; COMDAT (pick any)
.rdata:00007AB0                 public ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
.rdata:00007AB0 ; `string'
.rdata:00007AB0 ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ db 'Standard C++ Libraries Invalid Argument',0
.rdata:00007AB0                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Compat(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+3Eo
.rdata:00007AB0 _rdata          ends
.rdata:00007AB0
.rdata:00007AD8 ; ===========================================================================
.rdata:00007AD8
.rdata:00007AD8 ; Segment type: Pure data
.rdata:00007AD8 ; Segment permissions: Read
.rdata:00007AD8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007AD8 _rdata          segment para public 'DATA' use32
.rdata:00007AD8                 assume cs:_rdata
.rdata:00007AD8                 ;org 7AD8h
.rdata:00007AD8 ; COMDAT (pick any)
.rdata:00007AD8                 public ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
.rdata:00007AD8 ; `string'
.rdata:00007AD8 ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@:
.rdata:00007AD8                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Compat(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &):loc_3BDBo
.rdata:00007AD8                 unicode 0, <"Standard C++ Libraries Invalid Argument" && 0>,0
.rdata:00007B36                 align 4
.rdata:00007B36 _rdata          ends
.rdata:00007B36
.rdata:00007B38 ; ===========================================================================
.rdata:00007B38
.rdata:00007B38 ; Segment type: Pure data
.rdata:00007B38 ; Segment permissions: Read
.rdata:00007B38 _rdata          segment dword public 'DATA' use32
.rdata:00007B38                 assume cs:_rdata
.rdata:00007B38                 ;org 7B38h
.rdata:00007B38 ; COMDAT (pick any)
.rdata:00007B38                 public ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
.rdata:00007B38 ; `string'
.rdata:00007B38 ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@:
.rdata:00007B38                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Compat(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+82o
.rdata:00007B38                 unicode 0, <"invalid argument">,0
.rdata:00007B5E                 align 10h
.rdata:00007B5E _rdata          ends
.rdata:00007B5E
.rdata:00007B60 ; ===========================================================================
.rdata:00007B60
.rdata:00007B60 ; Segment type: Pure data
.rdata:00007B60 ; Segment permissions: Read
.rdata:00007B60 _rdata          segment dword public 'DATA' use32
.rdata:00007B60                 assume cs:_rdata
.rdata:00007B60                 ;org 7B60h
.rdata:00007B60 ; COMDAT (pick any)
.rdata:00007B60                 public ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
.rdata:00007B60 ; char `string'[]
.rdata:00007B60 ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ db 'deque<T> too long',0
.rdata:00007B60                                         ; DATA XREF: std::deque<RecentItem,std::allocator<RecentItem>>::_Xlen(void)+7o
.rdata:00007B72                 align 4
.rdata:00007B72 _rdata          ends
.rdata:00007B72
.rdata:00007B74 ; ===========================================================================
.rdata:00007B74
.rdata:00007B74 ; Segment type: Pure data
.rdata:00007B74 ; Segment permissions: Read
.rdata:00007B74 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007B74 _rdata          segment para public 'DATA' use32
.rdata:00007B74                 assume cs:_rdata
.rdata:00007B74                 ;org 7B74h
.rdata:00007B74 ; COMDAT (pick any)
.rdata:00007B74                 public ??_C@_1EK@DEGNOCIK@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr@
.rdata:00007B74 ; wchar_t `string'
.rdata:00007B74 ??_C@_1EK@DEGNOCIK@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr@:
.rdata:00007B74                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+=(int)+4Eo
.rdata:00007B74                 unicode 0, <deque iterator + offset out of range>,0
.rdata:00007BBE                 align 10h
.rdata:00007BBE _rdata          ends
.rdata:00007BBE
.rdata:00007BC0 ; ===========================================================================
.rdata:00007BC0
.rdata:00007BC0 ; Segment type: Pure data
.rdata:00007BC0 ; Segment permissions: Read
.rdata:00007BC0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007BC0 _rdata          segment para public 'DATA' use32
.rdata:00007BC0                 assume cs:_rdata
.rdata:00007BC0                 ;org 7BC0h
.rdata:00007BC0 ; COMDAT (pick any)
.rdata:00007BC0                 public ??_C@_1OK@INOEGLNP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
.rdata:00007BC0 ; `string'
.rdata:00007BC0 ??_C@_1OK@INOEGLNP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@:
.rdata:00007BC0                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator+=(int)+9Ao
.rdata:00007BC0                 unicode 0, <std::_Deque_const_iterator>
.rdata:00007BC0                 dw 3Ch
.rdata:00007BC0                 unicode 0, <class std::_Deque_val>
.rdata:00007BC0                 dw 3Ch
.rdata:00007BC0                 unicode 0, <struct std::_Deque_simple_types>
.rdata:00007BC0                 dw 3Ch
.rdata:00007BC0                 unicode 0, <struct RecentItem>
.rdata:00007BC0                 dw 3Eh
.rdata:00007BC0                 unicode 0, < >
.rdata:00007BC0                 dw 3Eh
.rdata:00007BC0                 unicode 0, < >
.rdata:00007BC0                 dw 3Eh
.rdata:00007BC0                 unicode 0, <::operator +=>,0
.rdata:00007CAA                 align 4
.rdata:00007CAA _rdata          ends
.rdata:00007CAA
.rdata:00007CAC ; ===========================================================================
.rdata:00007CAC
.rdata:00007CAC ; Segment type: Pure data
.rdata:00007CAC ; Segment permissions: Read
.rdata:00007CAC _rdata          segment dword public 'DATA' use32
.rdata:00007CAC                 assume cs:_rdata
.rdata:00007CAC                 ;org 7CACh
.rdata:00007CAC ; COMDAT (pick any)
.rdata:00007CAC                 public ??_C@_1DK@CNDLFKCJ@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
.rdata:00007CAC ; wchar_t `string'
.rdata:00007CAC ??_C@_1DK@CNDLFKCJ@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@:
.rdata:00007CAC                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Compat(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+31o
.rdata:00007CAC                 unicode 0, <deque iterators incompatible>,0
.rdata:00007CE6                 align 4
.rdata:00007CE6 _rdata          ends
.rdata:00007CE6
.rdata:00007CE8 ; ===========================================================================
.rdata:00007CE8
.rdata:00007CE8 ; Segment type: Pure data
.rdata:00007CE8 ; Segment permissions: Read
.rdata:00007CE8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007CE8 _rdata          segment para public 'DATA' use32
.rdata:00007CE8                 assume cs:_rdata
.rdata:00007CE8                 ;org 7CE8h
.rdata:00007CE8 ; COMDAT (pick any)
.rdata:00007CE8                 public ??_C@_1OC@KALAPKNE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
.rdata:00007CE8 ; `string'
.rdata:00007CE8 ??_C@_1OC@KALAPKNE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@:
.rdata:00007CE8                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::_Compat(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>> const &)+7Do
.rdata:00007CE8                 unicode 0, <std::_Deque_const_iterator>
.rdata:00007CE8                 dw 3Ch
.rdata:00007CE8                 unicode 0, <class std::_Deque_val>
.rdata:00007CE8                 dw 3Ch
.rdata:00007CE8                 unicode 0, <struct std::_Deque_simple_types>
.rdata:00007CE8                 dw 3Ch
.rdata:00007CE8                 unicode 0, <struct RecentItem>
.rdata:00007CE8                 dw 3Eh
.rdata:00007CE8                 unicode 0, < >
.rdata:00007CE8                 dw 3Eh
.rdata:00007CE8                 unicode 0, < >
.rdata:00007CE8                 dw 3Eh
.rdata:00007CE8                 unicode 0, <::_Compat>,0
.rdata:00007DCA                 align 4
.rdata:00007DCA _rdata          ends
.rdata:00007DCA
.rdata:00007DCC ; ===========================================================================
.rdata:00007DCC
.rdata:00007DCC ; Segment type: Pure data
.rdata:00007DCC ; Segment permissions: Read
.rdata:00007DCC _rdata          segment dword public 'DATA' use32
.rdata:00007DCC                 assume cs:_rdata
.rdata:00007DCC                 ;org 7DCCh
.rdata:00007DCC ; COMDAT (pick any)
.rdata:00007DCC                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00007DCC ; wchar_t `string'
.rdata:00007DCC ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00007DCC                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00007DCC                                         ; std::_Debug_pointer<RecentItem *>(RecentItem * *,wchar_t const *,uint)+11o ...
.rdata:00007DCC                 unicode 0, <invalid null pointer>,0
.rdata:00007DF6                 align 4
.rdata:00007DF6 _rdata          ends
.rdata:00007DF6
.rdata:00007DF8 ; ===========================================================================
.rdata:00007DF8
.rdata:00007DF8 ; Segment type: Pure data
.rdata:00007DF8 ; Segment permissions: Read
.rdata:00007DF8 _rdata          segment dword public 'DATA' use32
.rdata:00007DF8                 assume cs:_rdata
.rdata:00007DF8                 ;org 7DF8h
.rdata:00007DF8 ; COMDAT (pick any)
.rdata:00007DF8                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:00007DF8 ; wchar_t `string'
.rdata:00007DF8 ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:00007DF8                                         ; DATA XREF: std::_Debug_range2<RecentItem * *>(RecentItem * *,RecentItem * *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:00007DF8                                         ; std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>,wchar_t const *,uint,std::random_access_iterator_tag)+7Fo
.rdata:00007DF8                 unicode 0, <invalid iterator range>,0
.rdata:00007E26                 align 4
.rdata:00007E26 _rdata          ends
.rdata:00007E26
.rdata:00007E28 ; ===========================================================================
.rdata:00007E28
.rdata:00007E28 ; Segment type: Pure data
.rdata:00007E28 ; Segment permissions: Read
.rdata:00007E28 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007E28 _rdata          segment para public 'DATA' use32
.rdata:00007E28                 assume cs:_rdata
.rdata:00007E28                 ;org 7E28h
.rdata:00007E28 ; COMDAT (pick any)
.rdata:00007E28                 public ??_C@_1EC@CEAHEOFL@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@
.rdata:00007E28 ; wchar_t `string'
.rdata:00007E28 ??_C@_1EC@CEAHEOFL@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@:
.rdata:00007E28                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)+38o
.rdata:00007E28                 unicode 0, <deque iterator not incrementable>,0
.rdata:00007E6A                 align 4
.rdata:00007E6A _rdata          ends
.rdata:00007E6A
.rdata:00007E6C ; ===========================================================================
.rdata:00007E6C
.rdata:00007E6C ; Segment type: Pure data
.rdata:00007E6C ; Segment permissions: Read
.rdata:00007E6C ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007E6C _rdata          segment para public 'DATA' use32
.rdata:00007E6C                 assume cs:_rdata
.rdata:00007E6C                 ;org 7E6Ch
.rdata:00007E6C ; COMDAT (pick any)
.rdata:00007E6C                 public ??_C@_1OK@PIJGGDJM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
.rdata:00007E6C ; `string'
.rdata:00007E6C ??_C@_1OK@PIJGGDJM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@:
.rdata:00007E6C                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)+84o
.rdata:00007E6C                 unicode 0, <std::_Deque_const_iterator>
.rdata:00007E6C                 dw 3Ch
.rdata:00007E6C                 unicode 0, <class std::_Deque_val>
.rdata:00007E6C                 dw 3Ch
.rdata:00007E6C                 unicode 0, <struct std::_Deque_simple_types>
.rdata:00007E6C                 dw 3Ch
.rdata:00007E6C                 unicode 0, <struct RecentItem>
.rdata:00007E6C                 dw 3Eh
.rdata:00007E6C                 unicode 0, < >
.rdata:00007E6C                 dw 3Eh
.rdata:00007E6C                 unicode 0, < >
.rdata:00007E6C                 dw 3Eh
.rdata:00007E6C                 unicode 0, <::operator ++>,0
.rdata:00007F56                 align 4
.rdata:00007F56 _rdata          ends
.rdata:00007F56
.rdata:00007F58 ; ===========================================================================
.rdata:00007F58
.rdata:00007F58 ; Segment type: Pure data
.rdata:00007F58 ; Segment permissions: Read
.rdata:00007F58 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007F58 _rdata          segment para public 'DATA' use32
.rdata:00007F58                 assume cs:_rdata
.rdata:00007F58                 ;org 7F58h
.rdata:00007F58 ; COMDAT (pick any)
.rdata:00007F58                 public ??_C@_1EC@IJLEGPJO@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@
.rdata:00007F58 ; wchar_t `string'
.rdata:00007F58 ??_C@_1EC@IJLEGPJO@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@:
.rdata:00007F58                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator--(void)+32o
.rdata:00007F58                 unicode 0, <deque iterator not decrementable>,0
.rdata:00007F9A                 align 4
.rdata:00007F9A _rdata          ends
.rdata:00007F9A
.rdata:00007F9C ; ===========================================================================
.rdata:00007F9C
.rdata:00007F9C ; Segment type: Pure data
.rdata:00007F9C ; Segment permissions: Read
.rdata:00007F9C ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007F9C _rdata          segment para public 'DATA' use32
.rdata:00007F9C                 assume cs:_rdata
.rdata:00007F9C                 ;org 7F9Ch
.rdata:00007F9C ; COMDAT (pick any)
.rdata:00007F9C                 public ??_C@_1OK@LKENPFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
.rdata:00007F9C ; `string'
.rdata:00007F9C ??_C@_1OK@LKENPFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@:
.rdata:00007F9C                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator--(void)+7Eo
.rdata:00007F9C                 unicode 0, <std::_Deque_const_iterator>
.rdata:00007F9C                 dw 3Ch
.rdata:00007F9C                 unicode 0, <class std::_Deque_val>
.rdata:00007F9C                 dw 3Ch
.rdata:00007F9C                 unicode 0, <struct std::_Deque_simple_types>
.rdata:00007F9C                 dw 3Ch
.rdata:00007F9C                 unicode 0, <struct RecentItem>
.rdata:00007F9C                 dw 3Eh
.rdata:00007F9C                 unicode 0, < >
.rdata:00007F9C                 dw 3Eh
.rdata:00007F9C                 unicode 0, < >
.rdata:00007F9C                 dw 3Eh
.rdata:00007F9C                 unicode 0, <::operator -->,0
.rdata:00008086                 align 4
.rdata:00008086 _rdata          ends
.rdata:00008086
.rdata:00008088 ; ===========================================================================
.rdata:00008088
.rdata:00008088 ; Segment type: Pure data
.rdata:00008088 ; Segment permissions: Read
.rdata:00008088 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00008088 _rdata          segment para public 'DATA' use32
.rdata:00008088                 assume cs:_rdata
.rdata:00008088                 ;org 8088h
.rdata:00008088 ; COMDAT (pick any)
.rdata:00008088                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00008088 ; wchar_t `string'
.rdata:00008088 ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00008088                                         ; DATA XREF: std::_Uninit_copy<RecentItem *,RecentItem *>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &,std::_Scalar_ptr_iterator_tag)+9o
.rdata:00008088                                         ; std::_Uninit_copy<RecentItem *,RecentItem *>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &,std::_Scalar_ptr_iterator_tag)+23o
.rdata:00008088                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00008088                 unicode 0, <clude\xmemory>,0
.rdata:00008116                 align 4
.rdata:00008116 _rdata          ends
.rdata:00008116
.rdata$r:00008118 ; ===========================================================================
.rdata$r:00008118
.rdata$r:00008118 ; Segment type: Pure data
.rdata$r:00008118 ; Segment permissions: Read
.rdata$r:00008118 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008118                 assume cs:_rdata$r
.rdata$r:00008118                 ;org 8118h
.rdata$r:00008118 ; COMDAT (pick any)
.rdata$r:00008118                 public ??_R4error_category@std@@6B@
.rdata$r:00008118 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00008118 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00007634o
.rdata$r:00008119                 db    0
.rdata$r:0000811A                 db    0
.rdata$r:0000811B                 db    0
.rdata$r:0000811C                 db    0
.rdata$r:0000811D                 db    0
.rdata$r:0000811E                 db    0
.rdata$r:0000811F                 db    0
.rdata$r:00008120                 db    0
.rdata$r:00008121                 db    0
.rdata$r:00008122                 db    0
.rdata$r:00008123                 db    0
.rdata$r:00008124                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00008128                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008128 _rdata$r        ends
.rdata$r:00008128
.data$r:0000812C ; ===========================================================================
.data$r:0000812C
.data$r:0000812C ; Segment type: Pure data
.data$r:0000812C ; Segment permissions: Read/Write
.data$r:0000812C _data$r         segment dword public 'DATA' use32
.data$r:0000812C                 assume cs:_data$r
.data$r:0000812C                 ;org 812Ch
.data$r:0000812C ; COMDAT (pick any)
.data$r:0000812C                 public ??_R0?AVerror_category@std@@@8
.data$r:0000812C ; class std::error_category `RTTI Type Descriptor'
.data$r:0000812C ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000812C                                         ; DATA XREF: .rdata$r:00008124o
.data$r:0000812C                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000812C                                         ; const type_info::`vftable'
.data$r:00008130                 db    0
.data$r:00008131                 db    0
.data$r:00008132                 db    0
.data$r:00008133                 db    0
.data$r:00008134                 db  2Eh ; .
.data$r:00008135                 db  3Fh ; ?
.data$r:00008136                 db  41h ; A
.data$r:00008137                 db  56h ; V
.data$r:00008138                 db  65h ; e
.data$r:00008139                 db  72h ; r
.data$r:0000813A                 db  72h ; r
.data$r:0000813B                 db  6Fh ; o
.data$r:0000813C                 db  72h ; r
.data$r:0000813D                 db  5Fh ; _
.data$r:0000813E                 db  63h ; c
.data$r:0000813F                 db  61h ; a
.data$r:00008140                 db  74h ; t
.data$r:00008141                 db  65h ; e
.data$r:00008142                 db  67h ; g
.data$r:00008143                 db  6Fh ; o
.data$r:00008144                 db  72h ; r
.data$r:00008145                 db  79h ; y
.data$r:00008146                 db  40h ; @
.data$r:00008147                 db  73h ; s
.data$r:00008148                 db  74h ; t
.data$r:00008149                 db  64h ; d
.data$r:0000814A                 db  40h ; @
.data$r:0000814B                 db  40h ; @
.data$r:0000814C                 db    0
.data$r:0000814D                 align 10h
.data$r:0000814D _data$r         ends
.data$r:0000814D
.rdata$r:00008150 ; ===========================================================================
.rdata$r:00008150
.rdata$r:00008150 ; Segment type: Pure data
.rdata$r:00008150 ; Segment permissions: Read
.rdata$r:00008150 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008150                 assume cs:_rdata$r
.rdata$r:00008150                 ;org 8150h
.rdata$r:00008150 ; COMDAT (pick any)
.rdata$r:00008150                 public ??_R3error_category@std@@8
.rdata$r:00008150 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008150 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00008128o
.rdata$r:00008150                                         ; .rdata$r:00008180o
.rdata$r:00008151                 db    0
.rdata$r:00008152                 db    0
.rdata$r:00008153                 db    0
.rdata$r:00008154                 db    0
.rdata$r:00008155                 db    0
.rdata$r:00008156                 db    0
.rdata$r:00008157                 db    0
.rdata$r:00008158                 db    1
.rdata$r:00008159                 db    0
.rdata$r:0000815A                 db    0
.rdata$r:0000815B                 db    0
.rdata$r:0000815C                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000815C _rdata$r        ends
.rdata$r:0000815C
.rdata$r:00008160 ; ===========================================================================
.rdata$r:00008160
.rdata$r:00008160 ; Segment type: Pure data
.rdata$r:00008160 ; Segment permissions: Read
.rdata$r:00008160 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008160                 assume cs:_rdata$r
.rdata$r:00008160                 ;org 8160h
.rdata$r:00008160 ; COMDAT (pick any)
.rdata$r:00008160                 public ??_R2error_category@std@@8
.rdata$r:00008160 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00008160 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00008160                                         ; DATA XREF: .rdata$r:0000815Co
.rdata$r:00008160                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008164                 db    0
.rdata$r:00008165                 align 4
.rdata$r:00008165 _rdata$r        ends
.rdata$r:00008165
.rdata$r:00008168 ; ===========================================================================
.rdata$r:00008168
.rdata$r:00008168 ; Segment type: Pure data
.rdata$r:00008168 ; Segment permissions: Read
.rdata$r:00008168 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008168                 assume cs:_rdata$r
.rdata$r:00008168                 ;org 8168h
.rdata$r:00008168 ; COMDAT (pick any)
.rdata$r:00008168                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00008168 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00008168 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00008168                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00008168                                         ; .rdata$r:000081D8o ...
.rdata$r:00008168                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000816C                 db    0
.rdata$r:0000816D                 db    0
.rdata$r:0000816E                 db    0
.rdata$r:0000816F                 db    0
.rdata$r:00008170                 db    0
.rdata$r:00008171                 db    0
.rdata$r:00008172                 db    0
.rdata$r:00008173                 db    0
.rdata$r:00008174                 db 0FFh
.rdata$r:00008175                 db 0FFh
.rdata$r:00008176                 db 0FFh
.rdata$r:00008177                 db 0FFh
.rdata$r:00008178                 db    0
.rdata$r:00008179                 db    0
.rdata$r:0000817A                 db    0
.rdata$r:0000817B                 db    0
.rdata$r:0000817C                 db  40h ; @
.rdata$r:0000817D                 db    0
.rdata$r:0000817E                 db    0
.rdata$r:0000817F                 db    0
.rdata$r:00008180                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008180 _rdata$r        ends
.rdata$r:00008180
.rdata$r:00008184 ; ===========================================================================
.rdata$r:00008184
.rdata$r:00008184 ; Segment type: Pure data
.rdata$r:00008184 ; Segment permissions: Read
.rdata$r:00008184 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008184                 assume cs:_rdata$r
.rdata$r:00008184                 ;org 8184h
.rdata$r:00008184 ; COMDAT (pick any)
.rdata$r:00008184                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00008184 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00008184 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00008184                                         ; DATA XREF: .rdata:00007650o
.rdata$r:00008185                 db    0
.rdata$r:00008186                 db    0
.rdata$r:00008187                 db    0
.rdata$r:00008188                 db    0
.rdata$r:00008189                 db    0
.rdata$r:0000818A                 db    0
.rdata$r:0000818B                 db    0
.rdata$r:0000818C                 db    0
.rdata$r:0000818D                 db    0
.rdata$r:0000818E                 db    0
.rdata$r:0000818F                 db    0
.rdata$r:00008190                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00008194                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008194 _rdata$r        ends
.rdata$r:00008194
.data$r:00008198 ; ===========================================================================
.data$r:00008198
.data$r:00008198 ; Segment type: Pure data
.data$r:00008198 ; Segment permissions: Read/Write
.data$r:00008198 _data$r         segment dword public 'DATA' use32
.data$r:00008198                 assume cs:_data$r
.data$r:00008198                 ;org 8198h
.data$r:00008198 ; COMDAT (pick any)
.data$r:00008198                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00008198 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00008198 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00008198                                         ; DATA XREF: .rdata$r:00008190o
.data$r:00008198                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00008198                                         ; const type_info::`vftable'
.data$r:0000819C                 align 10h
.data$r:000081A0 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:000081C2                 align 4
.data$r:000081C2 _data$r         ends
.data$r:000081C2
.rdata$r:000081C4 ; ===========================================================================
.rdata$r:000081C4
.rdata$r:000081C4 ; Segment type: Pure data
.rdata$r:000081C4 ; Segment permissions: Read
.rdata$r:000081C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000081C4                 assume cs:_rdata$r
.rdata$r:000081C4                 ;org 81C4h
.rdata$r:000081C4 ; COMDAT (pick any)
.rdata$r:000081C4                 public ??_R3_Generic_error_category@std@@8
.rdata$r:000081C4 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000081C4 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:000081C4                                         ; DATA XREF: .rdata$r:00008194o
.rdata$r:000081C4                                         ; .rdata$r:000081F8o
.rdata$r:000081C5                 db    0
.rdata$r:000081C6                 db    0
.rdata$r:000081C7                 db    0
.rdata$r:000081C8                 db    0
.rdata$r:000081C9                 db    0
.rdata$r:000081CA                 db    0
.rdata$r:000081CB                 db    0
.rdata$r:000081CC                 db    2
.rdata$r:000081CD                 db    0
.rdata$r:000081CE                 db    0
.rdata$r:000081CF                 db    0
.rdata$r:000081D0                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000081D0 _rdata$r        ends
.rdata$r:000081D0
.rdata$r:000081D4 ; ===========================================================================
.rdata$r:000081D4
.rdata$r:000081D4 ; Segment type: Pure data
.rdata$r:000081D4 ; Segment permissions: Read
.rdata$r:000081D4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000081D4                 assume cs:_rdata$r
.rdata$r:000081D4                 ;org 81D4h
.rdata$r:000081D4 ; COMDAT (pick any)
.rdata$r:000081D4                 public ??_R2_Generic_error_category@std@@8
.rdata$r:000081D4 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000081D4 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000081D4                                         ; DATA XREF: .rdata$r:000081D0o
.rdata$r:000081D4                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000081D8                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000081DC                 db    0
.rdata$r:000081DD                 align 10h
.rdata$r:000081DD _rdata$r        ends
.rdata$r:000081DD
.rdata$r:000081E0 ; ===========================================================================
.rdata$r:000081E0
.rdata$r:000081E0 ; Segment type: Pure data
.rdata$r:000081E0 ; Segment permissions: Read
.rdata$r:000081E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000081E0                 assume cs:_rdata$r
.rdata$r:000081E0                 ;org 81E0h
.rdata$r:000081E0 ; COMDAT (pick any)
.rdata$r:000081E0                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000081E0 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000081E0 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:000081E0                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:000081E0                                         ; .rdata$r:00008250o ...
.rdata$r:000081E0                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000081E4                 db    1
.rdata$r:000081E5                 db    0
.rdata$r:000081E6                 db    0
.rdata$r:000081E7                 db    0
.rdata$r:000081E8                 db    0
.rdata$r:000081E9                 db    0
.rdata$r:000081EA                 db    0
.rdata$r:000081EB                 db    0
.rdata$r:000081EC                 db 0FFh
.rdata$r:000081ED                 db 0FFh
.rdata$r:000081EE                 db 0FFh
.rdata$r:000081EF                 db 0FFh
.rdata$r:000081F0                 db    0
.rdata$r:000081F1                 db    0
.rdata$r:000081F2                 db    0
.rdata$r:000081F3                 db    0
.rdata$r:000081F4                 db  40h ; @
.rdata$r:000081F5                 db    0
.rdata$r:000081F6                 db    0
.rdata$r:000081F7                 db    0
.rdata$r:000081F8                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000081F8 _rdata$r        ends
.rdata$r:000081F8
.rdata$r:000081FC ; ===========================================================================
.rdata$r:000081FC
.rdata$r:000081FC ; Segment type: Pure data
.rdata$r:000081FC ; Segment permissions: Read
.rdata$r:000081FC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000081FC                 assume cs:_rdata$r
.rdata$r:000081FC                 ;org 81FCh
.rdata$r:000081FC ; COMDAT (pick any)
.rdata$r:000081FC                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:000081FC ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:000081FC ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:000081FC                                         ; DATA XREF: .rdata:00007684o
.rdata$r:000081FD                 db    0
.rdata$r:000081FE                 db    0
.rdata$r:000081FF                 db    0
.rdata$r:00008200                 db    0
.rdata$r:00008201                 db    0
.rdata$r:00008202                 db    0
.rdata$r:00008203                 db    0
.rdata$r:00008204                 db    0
.rdata$r:00008205                 db    0
.rdata$r:00008206                 db    0
.rdata$r:00008207                 db    0
.rdata$r:00008208                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000820C                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000820C _rdata$r        ends
.rdata$r:0000820C
.data$r:00008210 ; ===========================================================================
.data$r:00008210
.data$r:00008210 ; Segment type: Pure data
.data$r:00008210 ; Segment permissions: Read/Write
.data$r:00008210 _data$r         segment dword public 'DATA' use32
.data$r:00008210                 assume cs:_data$r
.data$r:00008210                 ;org 8210h
.data$r:00008210 ; COMDAT (pick any)
.data$r:00008210                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00008210 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00008210 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00008210                                         ; DATA XREF: .rdata$r:00008208o
.data$r:00008210                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00008210                                         ; const type_info::`vftable'
.data$r:00008214                 align 8
.data$r:00008218 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:0000823B                 align 4
.data$r:0000823B _data$r         ends
.data$r:0000823B
.rdata$r:0000823C ; ===========================================================================
.rdata$r:0000823C
.rdata$r:0000823C ; Segment type: Pure data
.rdata$r:0000823C ; Segment permissions: Read
.rdata$r:0000823C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000823C                 assume cs:_rdata$r
.rdata$r:0000823C                 ;org 823Ch
.rdata$r:0000823C ; COMDAT (pick any)
.rdata$r:0000823C                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:0000823C ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000823C ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:0000823C                                         ; DATA XREF: .rdata$r:0000820Co
.rdata$r:0000823C                                         ; .rdata$r:00008274o
.rdata$r:0000823D                 db    0
.rdata$r:0000823E                 db    0
.rdata$r:0000823F                 db    0
.rdata$r:00008240                 db    0
.rdata$r:00008241                 db    0
.rdata$r:00008242                 db    0
.rdata$r:00008243                 db    0
.rdata$r:00008244                 db    3
.rdata$r:00008245                 db    0
.rdata$r:00008246                 db    0
.rdata$r:00008247                 db    0
.rdata$r:00008248                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00008248 _rdata$r        ends
.rdata$r:00008248
.rdata$r:0000824C ; ===========================================================================
.rdata$r:0000824C
.rdata$r:0000824C ; Segment type: Pure data
.rdata$r:0000824C ; Segment permissions: Read
.rdata$r:0000824C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000824C                 assume cs:_rdata$r
.rdata$r:0000824C                 ;org 824Ch
.rdata$r:0000824C ; COMDAT (pick any)
.rdata$r:0000824C                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:0000824C ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000824C ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000824C                                         ; DATA XREF: .rdata$r:00008248o
.rdata$r:0000824C                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008250                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008254                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008258                 db    0
.rdata$r:00008259                 align 4
.rdata$r:00008259 _rdata$r        ends
.rdata$r:00008259
.rdata$r:0000825C ; ===========================================================================
.rdata$r:0000825C
.rdata$r:0000825C ; Segment type: Pure data
.rdata$r:0000825C ; Segment permissions: Read
.rdata$r:0000825C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000825C                 assume cs:_rdata$r
.rdata$r:0000825C                 ;org 825Ch
.rdata$r:0000825C ; COMDAT (pick any)
.rdata$r:0000825C                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000825C ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000825C ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:0000825C                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:0000825C                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00008260                 db    2
.rdata$r:00008261                 db    0
.rdata$r:00008262                 db    0
.rdata$r:00008263                 db    0
.rdata$r:00008264                 db    0
.rdata$r:00008265                 db    0
.rdata$r:00008266                 db    0
.rdata$r:00008267                 db    0
.rdata$r:00008268                 db 0FFh
.rdata$r:00008269                 db 0FFh
.rdata$r:0000826A                 db 0FFh
.rdata$r:0000826B                 db 0FFh
.rdata$r:0000826C                 db    0
.rdata$r:0000826D                 db    0
.rdata$r:0000826E                 db    0
.rdata$r:0000826F                 db    0
.rdata$r:00008270                 db  40h ; @
.rdata$r:00008271                 db    0
.rdata$r:00008272                 db    0
.rdata$r:00008273                 db    0
.rdata$r:00008274                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008274 _rdata$r        ends
.rdata$r:00008274
.rdata$r:00008278 ; ===========================================================================
.rdata$r:00008278
.rdata$r:00008278 ; Segment type: Pure data
.rdata$r:00008278 ; Segment permissions: Read
.rdata$r:00008278 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008278                 assume cs:_rdata$r
.rdata$r:00008278                 ;org 8278h
.rdata$r:00008278 ; COMDAT (pick any)
.rdata$r:00008278                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00008278 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00008278 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:000076C4o
.rdata$r:00008279                 db    0
.rdata$r:0000827A                 db    0
.rdata$r:0000827B                 db    0
.rdata$r:0000827C                 db    0
.rdata$r:0000827D                 db    0
.rdata$r:0000827E                 db    0
.rdata$r:0000827F                 db    0
.rdata$r:00008280                 db    0
.rdata$r:00008281                 db    0
.rdata$r:00008282                 db    0
.rdata$r:00008283                 db    0
.rdata$r:00008284                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00008288                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008288 _rdata$r        ends
.rdata$r:00008288
.data$r:0000828C ; ===========================================================================
.data$r:0000828C
.data$r:0000828C ; Segment type: Pure data
.data$r:0000828C ; Segment permissions: Read/Write
.data$r:0000828C _data$r         segment dword public 'DATA' use32
.data$r:0000828C                 assume cs:_data$r
.data$r:0000828C                 ;org 828Ch
.data$r:0000828C ; COMDAT (pick any)
.data$r:0000828C                 public ??_R0?AV_System_error_category@std@@@8
.data$r:0000828C ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:0000828C ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000828C                                         ; DATA XREF: .rdata$r:00008284o
.data$r:0000828C                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000828C                                         ; const type_info::`vftable'
.data$r:00008290                 db    0
.data$r:00008291                 db    0
.data$r:00008292                 db    0
.data$r:00008293                 db    0
.data$r:00008294                 db  2Eh ; .
.data$r:00008295                 db  3Fh ; ?
.data$r:00008296                 db  41h ; A
.data$r:00008297                 db  56h ; V
.data$r:00008298                 db  5Fh ; _
.data$r:00008299                 db  53h ; S
.data$r:0000829A                 db  79h ; y
.data$r:0000829B                 db  73h ; s
.data$r:0000829C                 db  74h ; t
.data$r:0000829D                 db  65h ; e
.data$r:0000829E                 db  6Dh ; m
.data$r:0000829F                 db  5Fh ; _
.data$r:000082A0                 db  65h ; e
.data$r:000082A1                 db  72h ; r
.data$r:000082A2                 db  72h ; r
.data$r:000082A3                 db  6Fh ; o
.data$r:000082A4                 db  72h ; r
.data$r:000082A5                 db  5Fh ; _
.data$r:000082A6                 db  63h ; c
.data$r:000082A7                 db  61h ; a
.data$r:000082A8                 db  74h ; t
.data$r:000082A9                 db  65h ; e
.data$r:000082AA                 db  67h ; g
.data$r:000082AB                 db  6Fh ; o
.data$r:000082AC                 db  72h ; r
.data$r:000082AD                 db  79h ; y
.data$r:000082AE                 db  40h ; @
.data$r:000082AF                 db  73h ; s
.data$r:000082B0                 db  74h ; t
.data$r:000082B1                 db  64h ; d
.data$r:000082B2                 db  40h ; @
.data$r:000082B3                 db  40h ; @
.data$r:000082B4                 db    0
.data$r:000082B5                 align 4
.data$r:000082B5 _data$r         ends
.data$r:000082B5
.rdata$r:000082B8 ; ===========================================================================
.rdata$r:000082B8
.rdata$r:000082B8 ; Segment type: Pure data
.rdata$r:000082B8 ; Segment permissions: Read
.rdata$r:000082B8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000082B8                 assume cs:_rdata$r
.rdata$r:000082B8                 ;org 82B8h
.rdata$r:000082B8 ; COMDAT (pick any)
.rdata$r:000082B8                 public ??_R3_System_error_category@std@@8
.rdata$r:000082B8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000082B8 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00008288o
.rdata$r:000082B8                                         ; .rdata$r:000082F0o
.rdata$r:000082B9                 db    0
.rdata$r:000082BA                 db    0
.rdata$r:000082BB                 db    0
.rdata$r:000082BC                 db    0
.rdata$r:000082BD                 db    0
.rdata$r:000082BE                 db    0
.rdata$r:000082BF                 db    0
.rdata$r:000082C0                 db    3
.rdata$r:000082C1                 db    0
.rdata$r:000082C2                 db    0
.rdata$r:000082C3                 db    0
.rdata$r:000082C4                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000082C4 _rdata$r        ends
.rdata$r:000082C4
.rdata$r:000082C8 ; ===========================================================================
.rdata$r:000082C8
.rdata$r:000082C8 ; Segment type: Pure data
.rdata$r:000082C8 ; Segment permissions: Read
.rdata$r:000082C8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000082C8                 assume cs:_rdata$r
.rdata$r:000082C8                 ;org 82C8h
.rdata$r:000082C8 ; COMDAT (pick any)
.rdata$r:000082C8                 public ??_R2_System_error_category@std@@8
.rdata$r:000082C8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000082C8 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000082C8                                         ; DATA XREF: .rdata$r:000082C4o
.rdata$r:000082C8                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000082CC                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000082D0                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000082D4                 db    0
.rdata$r:000082D5                 align 4
.rdata$r:000082D5 _rdata$r        ends
.rdata$r:000082D5
.rdata$r:000082D8 ; ===========================================================================
.rdata$r:000082D8
.rdata$r:000082D8 ; Segment type: Pure data
.rdata$r:000082D8 ; Segment permissions: Read
.rdata$r:000082D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000082D8                 assume cs:_rdata$r
.rdata$r:000082D8                 ;org 82D8h
.rdata$r:000082D8 ; COMDAT (pick any)
.rdata$r:000082D8                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000082D8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000082D8 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:000082D8                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:000082D8                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000082DC                 db    2
.rdata$r:000082DD                 db    0
.rdata$r:000082DE                 db    0
.rdata$r:000082DF                 db    0
.rdata$r:000082E0                 db    0
.rdata$r:000082E1                 db    0
.rdata$r:000082E2                 db    0
.rdata$r:000082E3                 db    0
.rdata$r:000082E4                 db 0FFh
.rdata$r:000082E5                 db 0FFh
.rdata$r:000082E6                 db 0FFh
.rdata$r:000082E7                 db 0FFh
.rdata$r:000082E8                 db    0
.rdata$r:000082E9                 db    0
.rdata$r:000082EA                 db    0
.rdata$r:000082EB                 db    0
.rdata$r:000082EC                 db  40h ; @
.rdata$r:000082ED                 db    0
.rdata$r:000082EE                 db    0
.rdata$r:000082EF                 db    0
.rdata$r:000082F0                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000082F0 _rdata$r        ends
.rdata$r:000082F0
.CRT$XCU:000082F4 ; ===========================================================================
.CRT$XCU:000082F4
.CRT$XCU:000082F4 ; Segment type: Pure data
.CRT$XCU:000082F4 ; Segment permissions: Read
.CRT$XCU:000082F4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000082F4                 assume cs:_CRT$XCU
.CRT$XCU:000082F4                 ;org 82F4h
.CRT$XCU:000082F4 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:000082F8 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:000082F8 _CRT$XCU        ends
.CRT$XCU:000082F8
.CRT$XCU:000082FC ; ===========================================================================
.CRT$XCU:000082FC
.CRT$XCU:000082FC ; Segment type: Pure data
.CRT$XCU:000082FC ; Segment permissions: Read
.CRT$XCU:000082FC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000082FC                 assume cs:_CRT$XCU
.CRT$XCU:000082FC                 ;org 82FCh
.CRT$XCU:000082FC ; COMDAT (pick associative to section at 76E8)
.CRT$XCU:000082FC ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:000082FC ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:000082FC _CRT$XCU        ends
.CRT$XCU:000082FC
.CRT$XCU:00008300 ; ===========================================================================
.CRT$XCU:00008300
.CRT$XCU:00008300 ; Segment type: Pure data
.CRT$XCU:00008300 ; Segment permissions: Read
.CRT$XCU:00008300 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00008300                 assume cs:_CRT$XCU
.CRT$XCU:00008300                 ;org 8300h
.CRT$XCU:00008300 ; COMDAT (pick associative to section at 76EC)
.CRT$XCU:00008300 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00008300 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00008300 _CRT$XCU        ends
.CRT$XCU:00008300
.CRT$XCU:00008304 ; ===========================================================================
.CRT$XCU:00008304
.CRT$XCU:00008304 ; Segment type: Pure data
.CRT$XCU:00008304 ; Segment permissions: Read
.CRT$XCU:00008304 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00008304                 assume cs:_CRT$XCU
.CRT$XCU:00008304                 ;org 8304h
.CRT$XCU:00008304 ; COMDAT (pick associative to section at 76F0)
.CRT$XCU:00008304 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00008304 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00008304 _CRT$XCU        ends
.CRT$XCU:00008304
.CRT$XCU:00008308 ; ===========================================================================
.CRT$XCU:00008308
.CRT$XCU:00008308 ; Segment type: Pure data
.CRT$XCU:00008308 ; Segment permissions: Read
.CRT$XCU:00008308 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00008308                 assume cs:_CRT$XCU
.CRT$XCU:00008308                 ;org 8308h
.CRT$XCU:00008308 ; COMDAT (pick associative to section at 76F8)
.CRT$XCU:00008308 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00008308 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00008308 _CRT$XCU        ends
.CRT$XCU:00008308
.CRT$XCU:0000830C ; ===========================================================================
.CRT$XCU:0000830C
.CRT$XCU:0000830C ; Segment type: Pure data
.CRT$XCU:0000830C ; Segment permissions: Read
.CRT$XCU:0000830C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000830C                 assume cs:_CRT$XCU
.CRT$XCU:0000830C                 ;org 830Ch
.CRT$XCU:0000830C ; COMDAT (pick associative to section at 76FC)
.CRT$XCU:0000830C ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:0000830C ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:0000830C _CRT$XCU        ends
.CRT$XCU:0000830C
.CRT$XCU:00008310 ; ===========================================================================
.CRT$XCU:00008310
.CRT$XCU:00008310 ; Segment type: Pure data
.CRT$XCU:00008310 ; Segment permissions: Read
.CRT$XCU:00008310 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00008310                 assume cs:_CRT$XCU
.CRT$XCU:00008310                 ;org 8310h
.CRT$XCU:00008310 ; COMDAT (pick associative to section at 7790)
.CRT$XCU:00008310 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00008310 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00008310 _CRT$XCU        ends
.CRT$XCU:00008310
.CRT$XCU:00008314 ; ===========================================================================
.CRT$XCU:00008314
.CRT$XCU:00008314 ; Segment type: Pure data
.CRT$XCU:00008314 ; Segment permissions: Read
.CRT$XCU:00008314 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00008314                 assume cs:_CRT$XCU
.CRT$XCU:00008314                 ;org 8314h
.CRT$XCU:00008314 ; COMDAT (pick associative to section at 7794)
.CRT$XCU:00008314 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00008314 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00008314 _CRT$XCU        ends
.CRT$XCU:00008314
UNDEF:00008320 ; ===========================================================================
UNDEF:00008320
UNDEF:00008320 ; Segment type: Externs
UNDEF:00008320 ; UNDEF
UNDEF:00008320                 extrn __purecall:near   ; DATA XREF: .rdata:0000763Co
UNDEF:00008320                                         ; .rdata:00007640o
UNDEF:00008324 ; void *__cdecl operator new(unsigned int)
UNDEF:00008324                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00008324                                         ; std::_Allocate<RecentItem *>(uint,RecentItem * *)+23p ...
UNDEF:00008328 ; void __cdecl operator delete(void *)
UNDEF:00008328                 extrn ??3@YAXPAX@Z:near ; CODE XREF: RecentItem::`scalar deleting destructor'(uint)+1Bp
UNDEF:00008328                                         ; std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000832C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000832C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000832C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00008330                 extrn __invalid_parameter:near
UNDEF:00008330                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+9Cp
UNDEF:00008330                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)+8Ep ...
UNDEF:00008334 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00008334                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00008334                                         ; _wmemcpy+11p
UNDEF:00008338 ; size_t __cdecl strlen(const char *Str)
UNDEF:00008338                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:0000833C ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:0000833C                 extrn _memmove:near     ; CODE XREF: std::_Uninit_copy<RecentItem *,RecentItem *>(RecentItem * *,RecentItem * *,RecentItem * *,std::_Wrap_alloc<std::allocator<RecentItem *>> &,std::_Scalar_ptr_iterator_tag)+4Fp
UNDEF:0000833C                                         ; std::char_traits<char>::move(char *,char const *,uint)+1Ep ...
UNDEF:00008340 ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:00008340                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:00008344 ; int __stdcall lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2)
UNDEF:00008344                 extrn __imp__lstrcmpiW@8:near
UNDEF:00008344                                         ; CODE XREF: LastRecentFileList::find(wchar_t const *)+41p
UNDEF:00008344                                         ; DATA XREF: LastRecentFileList::find(wchar_t const *)+41r
UNDEF:00008348 ; HMENU __stdcall CreatePopupMenu()
UNDEF:00008348                 extrn __imp__CreatePopupMenu@0:near
UNDEF:00008348                                         ; CODE XREF: LastRecentFileList::initMenu(HMENU__ *,int,int,Accelerator *,bool)+1Ap
UNDEF:00008348                                         ; LastRecentFileList::switchMode(void)+D2p
UNDEF:00008348                                         ; DATA XREF: ...
UNDEF:0000834C ; BOOL __stdcall DestroyMenu(HMENU hMenu)
UNDEF:0000834C                 extrn __imp__DestroyMenu@4:near
UNDEF:0000834C                                         ; CODE XREF: LastRecentFileList::switchMode(void)+13Ep
UNDEF:0000834C                                         ; DATA XREF: LastRecentFileList::switchMode(void)+13Er
UNDEF:00008350 ; BOOL __stdcall InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
UNDEF:00008350                 extrn __imp__InsertMenuW@20:near
UNDEF:00008350                                         ; CODE XREF: LastRecentFileList::updateMenu(void)+195p
UNDEF:00008350                                         ; LastRecentFileList::updateMenu(void)+1C5p ...
UNDEF:00008354 ; BOOL __stdcall RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
UNDEF:00008354                 extrn __imp__RemoveMenu@12:near
UNDEF:00008354                                         ; CODE XREF: LastRecentFileList::switchMode(void)+17p
UNDEF:00008354                                         ; LastRecentFileList::switchMode(void)+2Bp ...
UNDEF:00008358 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00008358                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00008358                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:00008358                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:0000835C ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:0000835C                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:0000835C                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:0000835C                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:00008360                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00008364                 extrn __CrtDbgReportW:near
UNDEF:00008364                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator*(void)+78p
UNDEF:00008364                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<RecentItem>>>::operator++(void)+6Ap ...
UNDEF:00008368 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00008368                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00008368                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00008368                                         ; std::_Debug_pointer<RecentItem *>(RecentItem * *,wchar_t const *,uint)+16p ...
UNDEF:0000836C ; void __cdecl std::_Xbad_alloc()
UNDEF:0000836C                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000836C                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_104Ap
UNDEF:0000836C                                         ; std::_Allocate<RecentItem *>(uint,RecentItem * *):loc_108Cp ...
UNDEF:00008370 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00008370                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00008370                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00008370                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp ...
UNDEF:00008374 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00008374                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00008374                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00008374                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp ...
UNDEF:00008378 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00008378                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00008378                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:0000837C ; const char *__cdecl std::_Syserror_map(int)
UNDEF:0000837C                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:0000837C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:0000837C                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00008380 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00008380                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00008380                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00008384 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00008384                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00008384                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00008388 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00008388                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00008388                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:0000838C ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000838C                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000838C                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00008390 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl BuildMenuFileName(int, unsigned int, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
UNDEF:00008390                 extrn ?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z:near
UNDEF:00008390                                         ; CODE XREF: LastRecentFileList::updateMenu(void)+4DCp
UNDEF:00008394 ; void __thiscall Accelerator::updateFullMenu(Accelerator *__hidden this)
UNDEF:00008394                 extrn ?updateFullMenu@Accelerator@@QAEXXZ:near
UNDEF:00008394                                         ; CODE XREF: LastRecentFileList::updateMenu(void)+2CEp
UNDEF:00008398 ; bool __thiscall NppParameters::writeRecentFileHistorySettings(NppParameters *__hidden this, int)
UNDEF:00008398                 extrn ?writeRecentFileHistorySettings@NppParameters@@QBE_NH@Z:near
UNDEF:00008398                                         ; CODE XREF: LastRecentFileList::saveLRFL(void)+1Bp
UNDEF:0000839C ; bool __thiscall NppParameters::writeHistory(NppParameters *__hidden this, const wchar_t *)
UNDEF:0000839C                 extrn ?writeHistory@NppParameters@@QAE_NPB_W@Z:near
UNDEF:0000839C                                         ; CODE XREF: LastRecentFileList::saveLRFL(void)+5Ep
UNDEF:000083A0 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall NativeLangSpeaker::getSpecialMenuEntryName(char const *)
UNDEF:000083A0                 extrn ?getSpecialMenuEntryName@NativeLangSpeaker@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PBD@Z:near
UNDEF:000083A0                                         ; CODE XREF: LastRecentFileList::updateMenu(void)+7Ep
UNDEF:000083A4 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall NativeLangSpeaker::getNativeLangMenuString(int)
UNDEF:000083A4                 extrn ?getNativeLangMenuString@NativeLangSpeaker@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z:near
UNDEF:000083A4                                         ; CODE XREF: LastRecentFileList::updateMenu(void)+99p
UNDEF:000083A4                                         ; LastRecentFileList::updateMenu(void)+B1p ...
UNDEF:000083A8 ; __fastcall __security_check_cookie(x)
UNDEF:000083A8                 extrn @__security_check_cookie@4:near
UNDEF:000083A8                                         ; CODE XREF: LastRecentFileList::updateMenu(void)+558p
UNDEF:000083A8                                         ; LastRecentFileList::add(wchar_t const *)+EAp ...
UNDEF:000083AC ; __stdcall _CxxThrowException(x, x)
UNDEF:000083AC                 extrn __CxxThrowException@8:near
UNDEF:000083AC                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:000083AC                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1+10p
UNDEF:000083B0                 extrn ___CxxFrameHandler3:near
UNDEF:000083B0                                         ; CODE XREF: __ehhandler$?updateMenu@LastRecentFileList@@QAEXXZ+23j
UNDEF:000083B0                                         ; __ehhandler$?add@LastRecentFileList@@QAEXPB_W@Z+20j ...
UNDEF:000083B4 ; const type_info::`vftable'
UNDEF:000083B4                 extrn ??_7type_info@@6B@:near
UNDEF:000083B4                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:000083B4                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:000083B8 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:000083B8                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:000083B8                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:000083BC                 extrn ___security_cookie:near
UNDEF:000083BC                                         ; DATA XREF: LastRecentFileList::updateMenu(void)+17r
UNDEF:000083BC                                         ; LastRecentFileList::add(wchar_t const *)+14r ...
UNDEF:000083C0                 extrn __fltused:near
UNDEF:000083C0
UNDEF:000083C0
UNDEF:000083C0                 end