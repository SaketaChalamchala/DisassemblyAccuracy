.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 81AE6F5D076B7BB5F135020EA78827A1
.rdata:00000000 ; Input CRC32 : D34875EC
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\TaskList.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; const WCHAR _SG123112
.rdata:00000000 $SG123112       dw 0                    ; DATA XREF: TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+6Bo
.rdata:00000002                 align 4
.rdata:00000004 ; const WCHAR _SG123113
.rdata:00000004 $SG123113:                              ; DATA XREF: TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+70o
.rdata:00000004                 unicode 0, <SysListView32>,0
.rdata:00000020 ; char _SG123117[]
.rdata:00000020 $SG123117       db 'TaskList::init : CreateWindowEx() function return null',0
.rdata:00000020                                         ; DATA XREF: TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+8Co
.rdata:00000057                 align 4
.rdata:00000057 _rdata          ends
.rdata:00000057
.text$mn:00000058 ; ===========================================================================
.text$mn:00000058
.text$mn:00000058 ; Segment type: Pure code
.text$mn:00000058 ; Segment permissions: Read/Execute
.text$mn:00000058 _text$mn        segment para public 'CODE' use32
.text$mn:00000058                 assume cs:_text$mn
.text$mn:00000058                 ;org 58h
.text$mn:00000058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000058
.text$mn:00000058 ; =============== S U B R O U T I N E =======================================
.text$mn:00000058
.text$mn:00000058 ; Attributes: bp-based frame
.text$mn:00000058
.text$mn:00000058 ; void __thiscall TaskList::init(TaskList *this, HINSTANCE hInstance, HWND, LPARAM, int, int)
.text$mn:00000058                 public ?init@TaskList@@QAEXPAUHINSTANCE__@@PAUHWND__@@PAU_IMAGELIST@@HH@Z
.text$mn:00000058 ?init@TaskList@@QAEXPAUHINSTANCE__@@PAUHWND__@@PAU_IMAGELIST@@HH@Z proc near
.text$mn:00000058
.text$mn:00000058 var_74          = dword ptr -74h
.text$mn:00000058 var_68          = dword ptr -68h
.text$mn:00000058 var_64          = dword ptr -64h
.text$mn:00000058 var_40          = dword ptr -40h
.text$mn:00000058 var_38          = dword ptr -38h
.text$mn:00000058 var_20          = byte ptr -20h
.text$mn:00000058 picce           = INITCOMMONCONTROLSEX ptr -14h
.text$mn:00000058 var_C           = dword ptr -0Ch
.text$mn:00000058 lParam          = dword ptr -8
.text$mn:00000058 dwNewLong       = dword ptr -4
.text$mn:00000058 hInstance       = dword ptr  8
.text$mn:00000058 arg_4           = dword ptr  0Ch
.text$mn:00000058 arg_8           = dword ptr  10h
.text$mn:00000058 arg_C           = dword ptr  14h
.text$mn:00000058 arg_10          = dword ptr  18h
.text$mn:00000058
.text$mn:00000058                 push    ebp
.text$mn:00000059                 mov     ebp, esp
.text$mn:0000005B                 sub     esp, 74h
.text$mn:0000005E                 mov     [ebp+dwNewLong], ecx
.text$mn:00000061                 mov     eax, [ebp+arg_4]
.text$mn:00000064                 push    eax             ; HWND
.text$mn:00000065                 mov     ecx, [ebp+hInstance]
.text$mn:00000068                 push    ecx             ; HINSTANCE
.text$mn:00000069                 mov     ecx, [ebp+dwNewLong] ; this
.text$mn:0000006C                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:00000071                 mov     edx, [ebp+dwNewLong]
.text$mn:00000074                 mov     eax, [ebp+arg_10]
.text$mn:00000077                 mov     [edx+20h], eax
.text$mn:0000007A                 mov     [ebp+picce.dwSize], 8
.text$mn:00000081                 mov     [ebp+picce.dwICC], 1
.text$mn:00000088                 lea     ecx, [ebp+picce]
.text$mn:0000008B                 push    ecx             ; picce
.text$mn:0000008C                 call    dword ptr ds:__imp__InitCommonControlsEx@4 ; InitCommonControlsEx(x)
.text$mn:00000092                 mov     edx, [ebp+dwNewLong]
.text$mn:00000095                 mov     eax, [ebp+arg_C]
.text$mn:00000098                 mov     [edx+1Ch], eax
.text$mn:0000009B                 mov     [ebp+var_C], 0D545h
.text$mn:000000A2                 push    0               ; lpParam
.text$mn:000000A4                 mov     ecx, [ebp+hInstance]
.text$mn:000000A7                 push    ecx             ; hInstance
.text$mn:000000A8                 push    0               ; hMenu
.text$mn:000000AA                 mov     edx, [ebp+dwNewLong]
.text$mn:000000AD                 mov     eax, [edx+8]
.text$mn:000000B0                 push    eax             ; hWndParent
.text$mn:000000B1                 push    0               ; nHeight
.text$mn:000000B3                 push    0               ; nWidth
.text$mn:000000B5                 push    0               ; Y
.text$mn:000000B7                 push    0               ; X
.text$mn:000000B9                 mov     ecx, [ebp+var_C]
.text$mn:000000BC                 or      ecx, 40000000h
.text$mn:000000C2                 push    ecx             ; dwStyle
.text$mn:000000C3                 push    offset $SG123112 ; lpWindowName
.text$mn:000000C8                 push    offset $SG123113 ; "SysListView32"
.text$mn:000000CD                 push    0               ; dwExStyle
.text$mn:000000CF                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:000000D5                 mov     edx, [ebp+dwNewLong]
.text$mn:000000D8                 mov     [edx+0Ch], eax
.text$mn:000000DB                 mov     eax, [ebp+dwNewLong]
.text$mn:000000DE                 cmp     dword ptr [eax+0Ch], 0
.text$mn:000000E2                 jnz     short loc_FF
.text$mn:000000E4                 push    offset $SG123117 ; "TaskList::init : CreateWindowEx() funct"...
.text$mn:000000E9                 lea     ecx, [ebp+var_20] ; this
.text$mn:000000EC                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:000000F1                 push    offset __TI2?AVruntime_error@std@@
.text$mn:000000F6                 lea     ecx, [ebp+var_20]
.text$mn:000000F9                 push    ecx
.text$mn:000000FA                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000000FF ; ---------------------------------------------------------------------------
.text$mn:000000FF
.text$mn:000000FF loc_FF:                                 ; CODE XREF: TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+8Aj
.text$mn:000000FF                 mov     edx, [ebp+dwNewLong]
.text$mn:00000102                 push    edx             ; dwNewLong
.text$mn:00000103                 push    0FFFFFFEBh      ; nIndex
.text$mn:00000105                 mov     eax, [ebp+dwNewLong]
.text$mn:00000108                 mov     ecx, [eax+0Ch]
.text$mn:0000010B                 push    ecx             ; hWnd
.text$mn:0000010C                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000112                 push    offset ?staticProc@TaskList@@KGJPAUHWND__@@IIJ@Z ; dwNewLong
.text$mn:00000117                 push    0FFFFFFFCh      ; nIndex
.text$mn:00000119                 mov     edx, [ebp+dwNewLong]
.text$mn:0000011C                 mov     eax, [edx+0Ch]
.text$mn:0000011F                 push    eax             ; hWnd
.text$mn:00000120                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000126                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000129                 mov     [ecx+10h], eax
.text$mn:0000012C                 push    0               ; lParam
.text$mn:0000012E                 push    0               ; wParam
.text$mn:00000130                 push    1037h           ; Msg
.text$mn:00000135                 mov     edx, [ebp+dwNewLong]
.text$mn:00000138                 mov     eax, [edx+0Ch]
.text$mn:0000013B                 push    eax             ; hWnd
.text$mn:0000013C                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000142                 mov     [ebp+lParam], eax
.text$mn:00000145                 mov     ecx, [ebp+lParam]
.text$mn:00000148                 or      ecx, 8020h
.text$mn:0000014E                 mov     [ebp+lParam], ecx
.text$mn:00000151                 mov     edx, [ebp+lParam]
.text$mn:00000154                 push    edx             ; lParam
.text$mn:00000155                 push    0               ; wParam
.text$mn:00000157                 push    1036h           ; Msg
.text$mn:0000015C                 mov     eax, [ebp+dwNewLong]
.text$mn:0000015F                 mov     ecx, [eax+0Ch]
.text$mn:00000162                 push    ecx             ; hWnd
.text$mn:00000163                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000169                 mov     [ebp+var_40], 2
.text$mn:00000170                 mov     [ebp+var_38], 1F4h
.text$mn:00000177                 lea     edx, [ebp+var_40]
.text$mn:0000017A                 push    edx             ; lParam
.text$mn:0000017B                 push    0               ; wParam
.text$mn:0000017D                 push    1061h           ; Msg
.text$mn:00000182                 mov     eax, [ebp+dwNewLong]
.text$mn:00000185                 mov     ecx, [eax+0Ch]
.text$mn:00000188                 push    ecx             ; hWnd
.text$mn:00000189                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000018F                 push    2               ; lParam
.text$mn:00000191                 mov     edx, [ebp+dwNewLong]
.text$mn:00000194                 mov     eax, [edx+1Ch]
.text$mn:00000197                 push    eax             ; wParam
.text$mn:00000198                 push    102Fh           ; Msg
.text$mn:0000019D                 mov     ecx, [ebp+dwNewLong]
.text$mn:000001A0                 mov     edx, [ecx+0Ch]
.text$mn:000001A3                 push    edx             ; hWnd
.text$mn:000001A4                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000001AA                 mov     eax, [ebp+arg_8]
.text$mn:000001AD                 push    eax             ; lParam
.text$mn:000001AE                 push    1               ; wParam
.text$mn:000001B0                 push    1003h           ; Msg
.text$mn:000001B5                 mov     ecx, [ebp+dwNewLong]
.text$mn:000001B8                 mov     edx, [ecx+0Ch]
.text$mn:000001BB                 push    edx             ; hWnd
.text$mn:000001BC                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000001C2                 mov     [ebp+var_64], 3
.text$mn:000001C9                 mov     [ebp+var_68], 3
.text$mn:000001D0                 lea     eax, [ebp+var_74]
.text$mn:000001D3                 push    eax             ; lParam
.text$mn:000001D4                 mov     ecx, [ebp+dwNewLong]
.text$mn:000001D7                 mov     edx, [ecx+20h]
.text$mn:000001DA                 push    edx             ; wParam
.text$mn:000001DB                 push    102Bh           ; Msg
.text$mn:000001E0                 mov     eax, [ebp+dwNewLong]
.text$mn:000001E3                 mov     ecx, [eax+0Ch]
.text$mn:000001E6                 push    ecx             ; hWnd
.text$mn:000001E7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000001ED                 push    0D5FFFFh        ; lParam
.text$mn:000001F2                 push    0               ; wParam
.text$mn:000001F4                 push    1001h           ; Msg
.text$mn:000001F9                 mov     edx, [ebp+dwNewLong]
.text$mn:000001FC                 mov     eax, [edx+0Ch]
.text$mn:000001FF                 push    eax             ; hWnd
.text$mn:00000200                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000206                 mov     esp, ebp
.text$mn:00000208                 pop     ebp
.text$mn:00000209                 retn    14h
.text$mn:00000209 ?init@TaskList@@QAEXPAUHINSTANCE__@@PAUHWND__@@PAU_IMAGELIST@@HH@Z endp
.text$mn:00000209
.text$mn:00000209 ; ---------------------------------------------------------------------------
.text$mn:0000020C                 db 0Ch dup(0CCh)
.text$mn:00000218
.text$mn:00000218 ; =============== S U B R O U T I N E =======================================
.text$mn:00000218
.text$mn:00000218 ; Attributes: bp-based frame
.text$mn:00000218
.text$mn:00000218 ; void __thiscall TaskList::destroy(TaskList *__hidden this)
.text$mn:00000218                 public ?destroy@TaskList@@UAEXXZ
.text$mn:00000218 ?destroy@TaskList@@UAEXXZ proc near
.text$mn:00000218
.text$mn:00000218 var_4           = dword ptr -4
.text$mn:00000218
.text$mn:00000218                 push    ebp
.text$mn:00000219                 mov     ebp, esp
.text$mn:0000021B                 push    ecx
.text$mn:0000021C                 mov     [ebp+var_4], ecx
.text$mn:0000021F                 mov     eax, [ebp+var_4]
.text$mn:00000222                 cmp     dword ptr [eax+14h], 0
.text$mn:00000226                 jz      short loc_235
.text$mn:00000228                 mov     ecx, [ebp+var_4]
.text$mn:0000022B                 mov     edx, [ecx+14h]
.text$mn:0000022E                 push    edx             ; ho
.text$mn:0000022F                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:00000235
.text$mn:00000235 loc_235:                                ; CODE XREF: TaskList::destroy(void)+Ej
.text$mn:00000235                 mov     eax, [ebp+var_4]
.text$mn:00000238                 cmp     dword ptr [eax+18h], 0
.text$mn:0000023C                 jz      short loc_24B
.text$mn:0000023E                 mov     ecx, [ebp+var_4]
.text$mn:00000241                 mov     edx, [ecx+18h]
.text$mn:00000244                 push    edx             ; ho
.text$mn:00000245                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:0000024B
.text$mn:0000024B loc_24B:                                ; CODE XREF: TaskList::destroy(void)+24j
.text$mn:0000024B                 mov     eax, [ebp+var_4]
.text$mn:0000024E                 mov     ecx, [eax+0Ch]
.text$mn:00000251                 push    ecx             ; hWnd
.text$mn:00000252                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:00000258                 mov     edx, [ebp+var_4]
.text$mn:0000025B                 mov     dword ptr [edx+0Ch], 0
.text$mn:00000262                 mov     esp, ebp
.text$mn:00000264                 pop     ebp
.text$mn:00000265                 retn
.text$mn:00000265 ?destroy@TaskList@@UAEXXZ endp
.text$mn:00000265
.text$mn:00000265 ; ---------------------------------------------------------------------------
.text$mn:00000266                 align 4
.text$mn:00000268
.text$mn:00000268 ; =============== S U B R O U T I N E =======================================
.text$mn:00000268
.text$mn:00000268 ; Attributes: bp-based frame
.text$mn:00000268
.text$mn:00000268 ; void __thiscall TaskList::setFont(TaskList *this, LPCWSTR pszFaceName, unsigned int)
.text$mn:00000268                 public ?setFont@TaskList@@QAEXPA_WI@Z
.text$mn:00000268 ?setFont@TaskList@@QAEXPA_WI@Z proc near
.text$mn:00000268
.text$mn:00000268 var_4           = dword ptr -4
.text$mn:00000268 pszFaceName     = dword ptr  8
.text$mn:00000268 cHeight         = dword ptr  0Ch
.text$mn:00000268
.text$mn:00000268                 push    ebp
.text$mn:00000269                 mov     ebp, esp
.text$mn:0000026B                 push    ecx
.text$mn:0000026C                 mov     [ebp+var_4], ecx
.text$mn:0000026F                 mov     eax, [ebp+var_4]
.text$mn:00000272                 cmp     dword ptr [eax+14h], 0
.text$mn:00000276                 jz      short loc_285
.text$mn:00000278                 mov     ecx, [ebp+var_4]
.text$mn:0000027B                 mov     edx, [ecx+14h]
.text$mn:0000027E                 push    edx             ; ho
.text$mn:0000027F                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:00000285
.text$mn:00000285 loc_285:                                ; CODE XREF: TaskList::setFont(wchar_t *,uint)+Ej
.text$mn:00000285                 mov     eax, [ebp+var_4]
.text$mn:00000288                 cmp     dword ptr [eax+18h], 0
.text$mn:0000028C                 jz      short loc_29B
.text$mn:0000028E                 mov     ecx, [ebp+var_4]
.text$mn:00000291                 mov     edx, [ecx+18h]
.text$mn:00000294                 push    edx             ; ho
.text$mn:00000295                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:0000029B
.text$mn:0000029B loc_29B:                                ; CODE XREF: TaskList::setFont(wchar_t *,uint)+24j
.text$mn:0000029B                 mov     eax, [ebp+pszFaceName]
.text$mn:0000029E                 push    eax             ; pszFaceName
.text$mn:0000029F                 push    0               ; iPitchAndFamily
.text$mn:000002A1                 push    0               ; iQuality
.text$mn:000002A3                 push    0               ; iClipPrecision
.text$mn:000002A5                 push    0               ; iOutPrecision
.text$mn:000002A7                 push    0               ; iCharSet
.text$mn:000002A9                 push    0               ; bStrikeOut
.text$mn:000002AB                 push    0               ; bUnderline
.text$mn:000002AD                 push    0               ; bItalic
.text$mn:000002AF                 push    190h            ; cWeight
.text$mn:000002B4                 push    0               ; cOrientation
.text$mn:000002B6                 push    0               ; cEscapement
.text$mn:000002B8                 push    0               ; cWidth
.text$mn:000002BA                 mov     ecx, [ebp+cHeight]
.text$mn:000002BD                 push    ecx             ; cHeight
.text$mn:000002BE                 call    dword ptr ds:__imp__CreateFontW@56 ; CreateFontW(x,x,x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:000002C4                 mov     edx, [ebp+var_4]
.text$mn:000002C7                 mov     [edx+14h], eax
.text$mn:000002CA                 mov     eax, [ebp+pszFaceName]
.text$mn:000002CD                 push    eax             ; pszFaceName
.text$mn:000002CE                 push    0               ; iPitchAndFamily
.text$mn:000002D0                 push    0               ; iQuality
.text$mn:000002D2                 push    0               ; iClipPrecision
.text$mn:000002D4                 push    0               ; iOutPrecision
.text$mn:000002D6                 push    0               ; iCharSet
.text$mn:000002D8                 push    0               ; bStrikeOut
.text$mn:000002DA                 push    0               ; bUnderline
.text$mn:000002DC                 push    0               ; bItalic
.text$mn:000002DE                 push    2BCh            ; cWeight
.text$mn:000002E3                 push    0               ; cOrientation
.text$mn:000002E5                 push    0               ; cEscapement
.text$mn:000002E7                 push    0               ; cWidth
.text$mn:000002E9                 mov     ecx, [ebp+cHeight]
.text$mn:000002EC                 push    ecx             ; cHeight
.text$mn:000002ED                 call    dword ptr ds:__imp__CreateFontW@56 ; CreateFontW(x,x,x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:000002F3                 mov     edx, [ebp+var_4]
.text$mn:000002F6                 mov     [edx+18h], eax
.text$mn:000002F9                 mov     eax, [ebp+var_4]
.text$mn:000002FC                 cmp     dword ptr [eax+14h], 0
.text$mn:00000300                 jz      short loc_31A
.text$mn:00000302                 push    0               ; lParam
.text$mn:00000304                 mov     ecx, [ebp+var_4]
.text$mn:00000307                 mov     edx, [ecx+14h]
.text$mn:0000030A                 push    edx             ; wParam
.text$mn:0000030B                 push    30h ; '0'       ; Msg
.text$mn:0000030D                 mov     eax, [ebp+var_4]
.text$mn:00000310                 mov     ecx, [eax+0Ch]
.text$mn:00000313                 push    ecx             ; hWnd
.text$mn:00000314                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000031A
.text$mn:0000031A loc_31A:                                ; CODE XREF: TaskList::setFont(wchar_t *,uint)+98j
.text$mn:0000031A                 mov     esp, ebp
.text$mn:0000031C                 pop     ebp
.text$mn:0000031D                 retn    8
.text$mn:0000031D ?setFont@TaskList@@QAEXPA_WI@Z endp
.text$mn:0000031D
.text$mn:0000031D ; ---------------------------------------------------------------------------
.text$mn:00000320                 db 8 dup(0CCh)
.text$mn:00000328
.text$mn:00000328 ; =============== S U B R O U T I N E =======================================
.text$mn:00000328
.text$mn:00000328 ; Attributes: bp-based frame
.text$mn:00000328
.text$mn:00000328 ; struct tagRECT *__thiscall TaskList::adjustSize(TaskList *this, struct tagRECT *__return_ptr __struct_ptr retstr)
.text$mn:00000328                 public ?adjustSize@TaskList@@QAE?AUtagRECT@@XZ
.text$mn:00000328 ?adjustSize@TaskList@@QAE?AUtagRECT@@XZ proc near
.text$mn:00000328
.text$mn:00000328 var_27C         = dword ptr -27Ch
.text$mn:00000328 var_274         = dword ptr -274h
.text$mn:00000328 var_268         = dword ptr -268h
.text$mn:00000328 var_264         = dword ptr -264h
.text$mn:00000328 var_248         = dword ptr -248h
.text$mn:00000328 var_244         = dword ptr -244h
.text$mn:00000328 var_240         = dword ptr -240h
.text$mn:00000328 var_23C         = dword ptr -23Ch
.text$mn:00000328 lParam          = dword ptr -238h
.text$mn:00000328 var_234         = dword ptr -234h
.text$mn:00000328 var_230         = dword ptr -230h
.text$mn:00000328 var_22C         = dword ptr -22Ch
.text$mn:00000328 var_228         = dword ptr -228h
.text$mn:00000328 wParam          = dword ptr -224h
.text$mn:00000328 var_220         = dword ptr -220h
.text$mn:00000328 var_21C         = dword ptr -21Ch
.text$mn:00000328 var_218         = dword ptr -218h
.text$mn:00000328 var_214         = dword ptr -214h
.text$mn:00000328 var_210         = dword ptr -210h
.text$mn:00000328 var_20C         = dword ptr -20Ch
.text$mn:00000328 var_4           = dword ptr -4
.text$mn:00000328 retstr          = dword ptr  8
.text$mn:00000328
.text$mn:00000328                 push    ebp
.text$mn:00000329                 mov     ebp, esp
.text$mn:0000032B                 sub     esp, 27Ch
.text$mn:00000331                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000336                 xor     eax, ebp
.text$mn:00000338                 mov     [ebp+var_4], eax
.text$mn:0000033B                 mov     [ebp+var_220], ecx
.text$mn:00000341                 lea     eax, [ebp+var_21C]
.text$mn:00000347                 test    eax, eax
.text$mn:00000349                 jz      short loc_363
.text$mn:0000034B                 mov     [ebp+var_21C], 1
.text$mn:00000355                 lea     ecx, [ebp+var_21C]
.text$mn:0000035B                 mov     [ebp+lParam], ecx
.text$mn:00000361                 jmp     short loc_36D
.text$mn:00000363 ; ---------------------------------------------------------------------------
.text$mn:00000363
.text$mn:00000363 loc_363:                                ; CODE XREF: TaskList::adjustSize(void)+21j
.text$mn:00000363                 mov     [ebp+lParam], 0
.text$mn:0000036D
.text$mn:0000036D loc_36D:                                ; CODE XREF: TaskList::adjustSize(void)+39j
.text$mn:0000036D                 mov     edx, [ebp+lParam]
.text$mn:00000373                 push    edx             ; lParam
.text$mn:00000374                 push    0               ; wParam
.text$mn:00000376                 push    100Eh           ; Msg
.text$mn:0000037B                 mov     eax, [ebp+var_220]
.text$mn:00000381                 mov     ecx, [eax+0Ch]
.text$mn:00000384                 push    ecx             ; hWnd
.text$mn:00000385                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000038B                 mov     edx, [ebp+var_214]
.text$mn:00000391                 sub     edx, [ebp+var_21C]
.text$mn:00000397                 mov     [ebp+var_23C], edx
.text$mn:0000039D                 mov     [ebp+var_248], 1Eh
.text$mn:000003A7                 mov     [ebp+var_240], 5
.text$mn:000003B1                 mov     [ebp+var_244], 0Fh
.text$mn:000003BB                 push    0               ; lParam
.text$mn:000003BD                 mov     eax, [ebp+var_220]
.text$mn:000003C3                 mov     ecx, [eax+18h]
.text$mn:000003C6                 push    ecx             ; wParam
.text$mn:000003C7                 push    30h ; '0'       ; Msg
.text$mn:000003C9                 mov     edx, [ebp+var_220]
.text$mn:000003CF                 mov     eax, [edx+0Ch]
.text$mn:000003D2                 push    eax             ; hWnd
.text$mn:000003D3                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000003D9                 mov     [ebp+var_228], 0FFFFFFFFh
.text$mn:000003E3                 mov     ecx, [ebp+var_220]
.text$mn:000003E9                 mov     dword ptr [ecx+24h], 0
.text$mn:000003F0                 mov     edx, [ebp+var_220]
.text$mn:000003F6                 mov     dword ptr [edx+28h], 0
.text$mn:000003FD                 mov     eax, [ebp+var_220]
.text$mn:00000403                 mov     dword ptr [eax+30h], 0
.text$mn:0000040A                 mov     [ebp+wParam], 0
.text$mn:00000414                 jmp     short loc_425
.text$mn:00000416 ; ---------------------------------------------------------------------------
.text$mn:00000416
.text$mn:00000416 loc_416:                                ; CODE XREF: TaskList::adjustSize(void)+1B1j
.text$mn:00000416                 mov     ecx, [ebp+wParam]
.text$mn:0000041C                 add     ecx, 1
.text$mn:0000041F                 mov     [ebp+wParam], ecx
.text$mn:00000425
.text$mn:00000425 loc_425:                                ; CODE XREF: TaskList::adjustSize(void)+ECj
.text$mn:00000425                 mov     edx, [ebp+var_220]
.text$mn:0000042B                 mov     eax, [ebp+wParam]
.text$mn:00000431                 cmp     eax, [edx+1Ch]
.text$mn:00000434                 jge     loc_4DE
.text$mn:0000043A                 mov     [ebp+var_274], 0
.text$mn:00000444                 mov     [ebp+var_264], 104h
.text$mn:0000044E                 lea     ecx, [ebp+var_20C]
.text$mn:00000454                 mov     [ebp+var_268], ecx
.text$mn:0000045A                 lea     edx, [ebp+var_27C]
.text$mn:00000460                 push    edx             ; lParam
.text$mn:00000461                 mov     eax, [ebp+wParam]
.text$mn:00000467                 push    eax             ; wParam
.text$mn:00000468                 push    1073h           ; Msg
.text$mn:0000046D                 mov     ecx, [ebp+var_220]
.text$mn:00000473                 mov     edx, [ecx+0Ch]
.text$mn:00000476                 push    edx             ; hWnd
.text$mn:00000477                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000047D                 lea     eax, [ebp+var_20C]
.text$mn:00000483                 push    eax             ; lParam
.text$mn:00000484                 push    0               ; wParam
.text$mn:00000486                 push    1057h           ; Msg
.text$mn:0000048B                 mov     ecx, [ebp+var_220]
.text$mn:00000491                 mov     edx, [ecx+0Ch]
.text$mn:00000494                 push    edx             ; hWnd
.text$mn:00000495                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000049B                 mov     [ebp+var_234], eax
.text$mn:000004A1                 mov     eax, [ebp+var_234]
.text$mn:000004A7                 cmp     eax, [ebp+var_228]
.text$mn:000004AD                 jle     short loc_4BB
.text$mn:000004AF                 mov     ecx, [ebp+var_234]
.text$mn:000004B5                 mov     [ebp+var_228], ecx
.text$mn:000004BB
.text$mn:000004BB loc_4BB:                                ; CODE XREF: TaskList::adjustSize(void)+185j
.text$mn:000004BB                 mov     edx, [ebp+var_210]
.text$mn:000004C1                 sub     edx, [ebp+var_218]
.text$mn:000004C7                 mov     eax, [ebp+var_220]
.text$mn:000004CD                 add     edx, [eax+30h]
.text$mn:000004D0                 mov     ecx, [ebp+var_220]
.text$mn:000004D6                 mov     [ecx+30h], edx
.text$mn:000004D9                 jmp     loc_416
.text$mn:000004DE ; ---------------------------------------------------------------------------
.text$mn:000004DE
.text$mn:000004DE loc_4DE:                                ; CODE XREF: TaskList::adjustSize(void)+10Cj
.text$mn:000004DE                 mov     edx, [ebp+var_23C]
.text$mn:000004E4                 mov     eax, [ebp+var_228]
.text$mn:000004EA                 lea     ecx, [eax+edx+1Eh]
.text$mn:000004EE                 mov     edx, [ebp+var_220]
.text$mn:000004F4                 mov     [edx+2Ch], ecx
.text$mn:000004F7                 mov     eax, [ebp+var_220]
.text$mn:000004FD                 mov     ecx, [eax+2Ch]
.text$mn:00000500                 and     ecx, 0FFFFh
.text$mn:00000506                 movzx   edx, cx
.text$mn:00000509                 push    edx             ; lParam
.text$mn:0000050A                 push    0               ; wParam
.text$mn:0000050C                 push    101Eh           ; Msg
.text$mn:00000511                 mov     eax, [ebp+var_220]
.text$mn:00000517                 mov     ecx, [eax+0Ch]
.text$mn:0000051A                 push    ecx             ; hWnd
.text$mn:0000051B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000521                 push    0               ; lParam
.text$mn:00000523                 mov     edx, [ebp+var_220]
.text$mn:00000529                 mov     eax, [edx+14h]
.text$mn:0000052C                 push    eax             ; wParam
.text$mn:0000052D                 push    30h ; '0'       ; Msg
.text$mn:0000052F                 mov     ecx, [ebp+var_220]
.text$mn:00000535                 mov     edx, [ecx+0Ch]
.text$mn:00000538                 push    edx             ; hWnd
.text$mn:00000539                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000053F                 mov     eax, [ebp+var_220]
.text$mn:00000545                 add     eax, 24h ; '$'
.text$mn:00000548                 push    eax
.text$mn:00000549                 mov     ecx, [ebp+var_220]
.text$mn:0000054F                 mov     edx, [ecx]
.text$mn:00000551                 mov     ecx, [ebp+var_220]
.text$mn:00000557                 mov     eax, [edx+10h]
.text$mn:0000055A                 call    eax
.text$mn:0000055C                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000561                 mov     ecx, eax
.text$mn:00000563                 call    ?getWinVersion@NppParameters@@QAE?AW4winVer@@XZ ; NppParameters::getWinVersion(void)
.text$mn:00000568                 mov     [ebp+var_230], eax
.text$mn:0000056E                 cmp     [ebp+var_230], 7
.text$mn:00000575                 jg      short loc_58C
.text$mn:00000577                 cmp     [ebp+var_230], 0
.text$mn:0000057E                 jz      short loc_58C
.text$mn:00000580                 mov     [ebp+var_22C], 5
.text$mn:0000058A                 jmp     short loc_596
.text$mn:0000058C ; ---------------------------------------------------------------------------
.text$mn:0000058C
.text$mn:0000058C loc_58C:                                ; CODE XREF: TaskList::adjustSize(void)+24Dj
.text$mn:0000058C                                         ; TaskList::adjustSize(void)+256j
.text$mn:0000058C                 mov     [ebp+var_22C], 0Fh
.text$mn:00000596
.text$mn:00000596 loc_596:                                ; CODE XREF: TaskList::adjustSize(void)+262j
.text$mn:00000596                 mov     ecx, [ebp+var_220]
.text$mn:0000059C                 mov     edx, [ecx+30h]
.text$mn:0000059F                 add     edx, [ebp+var_22C]
.text$mn:000005A5                 mov     eax, [ebp+var_220]
.text$mn:000005AB                 mov     [eax+30h], edx
.text$mn:000005AE                 mov     ecx, [ebp+var_220]
.text$mn:000005B4                 add     ecx, 24h ; '$'
.text$mn:000005B7                 mov     edx, [ebp+retstr]
.text$mn:000005BA                 mov     eax, [ecx]
.text$mn:000005BC                 mov     [edx], eax
.text$mn:000005BE                 mov     eax, [ecx+4]
.text$mn:000005C1                 mov     [edx+4], eax
.text$mn:000005C4                 mov     eax, [ecx+8]
.text$mn:000005C7                 mov     [edx+8], eax
.text$mn:000005CA                 mov     ecx, [ecx+0Ch]
.text$mn:000005CD                 mov     [edx+0Ch], ecx
.text$mn:000005D0                 mov     eax, [ebp+retstr]
.text$mn:000005D3                 mov     ecx, [ebp+var_4]
.text$mn:000005D6                 xor     ecx, ebp
.text$mn:000005D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000005DD                 mov     esp, ebp
.text$mn:000005DF                 pop     ebp
.text$mn:000005E0                 retn    4
.text$mn:000005E0 ?adjustSize@TaskList@@QAE?AUtagRECT@@XZ endp
.text$mn:000005E0
.text$mn:000005E0 ; ---------------------------------------------------------------------------
.text$mn:000005E3                 align 8
.text$mn:000005E8
.text$mn:000005E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000005E8
.text$mn:000005E8 ; Attributes: bp-based frame
.text$mn:000005E8
.text$mn:000005E8 ; int __thiscall TaskList::updateCurrentIndex(TaskList *__hidden this)
.text$mn:000005E8                 public ?updateCurrentIndex@TaskList@@QAEHXZ
.text$mn:000005E8 ?updateCurrentIndex@TaskList@@QAEHXZ proc near
.text$mn:000005E8
.text$mn:000005E8 var_C           = dword ptr -0Ch
.text$mn:000005E8 var_8           = dword ptr -8
.text$mn:000005E8 wParam          = dword ptr -4
.text$mn:000005E8
.text$mn:000005E8                 push    ebp
.text$mn:000005E9                 mov     ebp, esp
.text$mn:000005EB                 sub     esp, 0Ch
.text$mn:000005EE                 mov     [ebp+var_8], ecx
.text$mn:000005F1                 mov     [ebp+wParam], 0
.text$mn:000005F8                 jmp     short loc_603
.text$mn:000005FA ; ---------------------------------------------------------------------------
.text$mn:000005FA
.text$mn:000005FA loc_5FA:                                ; CODE XREF: TaskList::updateCurrentIndex(void):loc_640j
.text$mn:000005FA                 mov     eax, [ebp+wParam]
.text$mn:000005FD                 add     eax, 1
.text$mn:00000600                 mov     [ebp+wParam], eax
.text$mn:00000603
.text$mn:00000603 loc_603:                                ; CODE XREF: TaskList::updateCurrentIndex(void)+10j
.text$mn:00000603                 mov     ecx, [ebp+var_8]
.text$mn:00000606                 mov     edx, [ebp+wParam]
.text$mn:00000609                 cmp     edx, [ecx+1Ch]
.text$mn:0000060C                 jge     short loc_642
.text$mn:0000060E                 push    2               ; lParam
.text$mn:00000610                 mov     eax, [ebp+wParam]
.text$mn:00000613                 push    eax             ; wParam
.text$mn:00000614                 push    102Ch           ; Msg
.text$mn:00000619                 mov     ecx, [ebp+var_8]
.text$mn:0000061C                 mov     edx, [ecx+0Ch]
.text$mn:0000061F                 push    edx             ; hWnd
.text$mn:00000620                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000626                 mov     [ebp+var_C], eax
.text$mn:00000629                 cmp     [ebp+var_C], 2
.text$mn:0000062D                 jnz     short loc_640
.text$mn:0000062F                 mov     eax, [ebp+var_8]
.text$mn:00000632                 mov     ecx, [ebp+wParam]
.text$mn:00000635                 mov     [eax+20h], ecx
.text$mn:00000638                 mov     edx, [ebp+var_8]
.text$mn:0000063B                 mov     eax, [edx+20h]
.text$mn:0000063E                 jmp     short loc_648
.text$mn:00000640 ; ---------------------------------------------------------------------------
.text$mn:00000640
.text$mn:00000640 loc_640:                                ; CODE XREF: TaskList::updateCurrentIndex(void)+45j
.text$mn:00000640                 jmp     short loc_5FA
.text$mn:00000642 ; ---------------------------------------------------------------------------
.text$mn:00000642
.text$mn:00000642 loc_642:                                ; CODE XREF: TaskList::updateCurrentIndex(void)+24j
.text$mn:00000642                 mov     eax, [ebp+var_8]
.text$mn:00000645                 mov     eax, [eax+20h]
.text$mn:00000648
.text$mn:00000648 loc_648:                                ; CODE XREF: TaskList::updateCurrentIndex(void)+56j
.text$mn:00000648                 mov     esp, ebp
.text$mn:0000064A                 pop     ebp
.text$mn:0000064B                 retn
.text$mn:0000064B ?updateCurrentIndex@TaskList@@QAEHXZ endp
.text$mn:0000064B
.text$mn:0000064B ; ---------------------------------------------------------------------------
.text$mn:0000064C                 db 0Ch dup(0CCh)
.text$mn:00000658
.text$mn:00000658 ; =============== S U B R O U T I N E =======================================
.text$mn:00000658
.text$mn:00000658 ; Attributes: bp-based frame
.text$mn:00000658
.text$mn:00000658 ; __int32 __thiscall TaskList::runProc(TaskList *this, HWND hWnd, UINT Msg, WPARAM, __int32)
.text$mn:00000658                 public ?runProc@TaskList@@IAEJPAUHWND__@@IIJ@Z
.text$mn:00000658 ?runProc@TaskList@@IAEJPAUHWND__@@IIJ@Z proc near
.text$mn:00000658                                         ; CODE XREF: TaskList::staticProc(HWND__ *,uint,uint,long)+21p
.text$mn:00000658
.text$mn:00000658 var_1D0         = dword ptr -1D0h
.text$mn:00000658 var_1C4         = dword ptr -1C4h
.text$mn:00000658 var_1C0         = dword ptr -1C0h
.text$mn:00000658 lParam          = dword ptr -19Ch
.text$mn:00000658 var_190         = dword ptr -190h
.text$mn:00000658 var_18C         = dword ptr -18Ch
.text$mn:00000658 var_168         = dword ptr -168h
.text$mn:00000658 var_15C         = dword ptr -15Ch
.text$mn:00000658 var_158         = dword ptr -158h
.text$mn:00000658 var_134         = dword ptr -134h
.text$mn:00000658 var_128         = dword ptr -128h
.text$mn:00000658 var_124         = dword ptr -124h
.text$mn:00000658 var_100         = dword ptr -100h
.text$mn:00000658 var_F4          = dword ptr -0F4h
.text$mn:00000658 var_F0          = dword ptr -0F0h
.text$mn:00000658 var_CC          = dword ptr -0CCh
.text$mn:00000658 var_C0          = dword ptr -0C0h
.text$mn:00000658 var_BC          = dword ptr -0BCh
.text$mn:00000658 var_98          = dword ptr -98h
.text$mn:00000658 var_8C          = dword ptr -8Ch
.text$mn:00000658 var_88          = dword ptr -88h
.text$mn:00000658 var_64          = dword ptr -64h
.text$mn:00000658 var_58          = dword ptr -58h
.text$mn:00000658 var_54          = dword ptr -54h
.text$mn:00000658 var_30          = dword ptr -30h
.text$mn:00000658 var_2C          = dword ptr -2Ch
.text$mn:00000658 var_28          = dword ptr -28h
.text$mn:00000658 var_24          = dword ptr -24h
.text$mn:00000658 var_20          = word ptr -20h
.text$mn:00000658 var_1C          = dword ptr -1Ch
.text$mn:00000658 var_18          = dword ptr -18h
.text$mn:00000658 wParam          = dword ptr -14h
.text$mn:00000658 var_10          = dword ptr -10h
.text$mn:00000658 var_C           = dword ptr -0Ch
.text$mn:00000658 var_8           = dword ptr -8
.text$mn:00000658 var_4           = dword ptr -4
.text$mn:00000658 hWnd            = dword ptr  8
.text$mn:00000658 Msg             = dword ptr  0Ch
.text$mn:00000658 arg_8           = dword ptr  10h
.text$mn:00000658 arg_C           = dword ptr  14h
.text$mn:00000658
.text$mn:00000658                 push    ebp
.text$mn:00000659                 mov     ebp, esp
.text$mn:0000065B                 sub     esp, 1D0h
.text$mn:00000661                 mov     [ebp+var_4], ecx
.text$mn:00000664                 mov     eax, [ebp+Msg]
.text$mn:00000667                 mov     [ebp+var_C], eax
.text$mn:0000066A                 cmp     [ebp+var_C], 101h
.text$mn:00000671                 ja      short loc_69B
.text$mn:00000673                 cmp     [ebp+var_C], 101h
.text$mn:0000067A                 jz      short loc_6A9
.text$mn:0000067C                 cmp     [ebp+var_C], 87h ; 'ç'
.text$mn:00000683                 jz      loc_8E3
.text$mn:00000689                 cmp     [ebp+var_C], 100h
.text$mn:00000690                 jz      loc_8D9
.text$mn:00000696                 jmp     loc_B4B
.text$mn:0000069B ; ---------------------------------------------------------------------------
.text$mn:0000069B
.text$mn:0000069B loc_69B:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+19j
.text$mn:0000069B                 cmp     [ebp+var_C], 20Ah
.text$mn:000006A2                 jz      short loc_6D7
.text$mn:000006A4                 jmp     loc_B4B
.text$mn:000006A9 ; ---------------------------------------------------------------------------
.text$mn:000006A9
.text$mn:000006A9 loc_6A9:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+22j
.text$mn:000006A9                 cmp     [ebp+arg_8], 11h
.text$mn:000006AD                 jnz     short loc_6CD
.text$mn:000006AF                 mov     ecx, [ebp+var_4]
.text$mn:000006B2                 mov     edx, [ecx+20h]
.text$mn:000006B5                 push    edx             ; lParam
.text$mn:000006B6                 push    993h            ; wParam
.text$mn:000006BB                 push    111h            ; Msg
.text$mn:000006C0                 mov     eax, [ebp+var_4]
.text$mn:000006C3                 mov     ecx, [eax+8]
.text$mn:000006C6                 push    ecx             ; hWnd
.text$mn:000006C7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000006CD
.text$mn:000006CD loc_6CD:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+55j
.text$mn:000006CD                 mov     eax, 1
.text$mn:000006D2                 jmp     loc_B68
.text$mn:000006D7 ; ---------------------------------------------------------------------------
.text$mn:000006D7
.text$mn:000006D7 loc_6D7:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+4Aj
.text$mn:000006D7                 mov     edx, [ebp+arg_8]
.text$mn:000006DA                 shr     edx, 10h
.text$mn:000006DD                 and     edx, 0FFFFh
.text$mn:000006E3                 mov     [ebp+var_20], dx
.text$mn:000006E7                 movsx   eax, [ebp+var_20]
.text$mn:000006EB                 test    eax, eax
.text$mn:000006ED                 jle     loc_7E5
.text$mn:000006F3                 mov     ecx, [ebp+var_4]
.text$mn:000006F6                 mov     edx, [ecx+20h]
.text$mn:000006F9                 sub     edx, 1
.text$mn:000006FC                 jns     short loc_70C
.text$mn:000006FE                 mov     eax, [ebp+var_4]
.text$mn:00000701                 mov     ecx, [eax+1Ch]
.text$mn:00000704                 sub     ecx, 1
.text$mn:00000707                 mov     [ebp+var_2C], ecx
.text$mn:0000070A                 jmp     short loc_718
.text$mn:0000070C ; ---------------------------------------------------------------------------
.text$mn:0000070C
.text$mn:0000070C loc_70C:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+A4j
.text$mn:0000070C                 mov     edx, [ebp+var_4]
.text$mn:0000070F                 mov     eax, [edx+20h]
.text$mn:00000712                 sub     eax, 1
.text$mn:00000715                 mov     [ebp+var_2C], eax
.text$mn:00000718
.text$mn:00000718 loc_718:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+B2j
.text$mn:00000718                 mov     ecx, [ebp+var_2C]
.text$mn:0000071B                 mov     [ebp+wParam], ecx
.text$mn:0000071E                 mov     [ebp+var_18C], 3
.text$mn:00000728                 mov     [ebp+var_190], 0
.text$mn:00000732                 lea     edx, [ebp+lParam]
.text$mn:00000738                 push    edx             ; lParam
.text$mn:00000739                 mov     eax, [ebp+var_4]
.text$mn:0000073C                 mov     ecx, [eax+20h]
.text$mn:0000073F                 push    ecx             ; wParam
.text$mn:00000740                 push    102Bh           ; Msg
.text$mn:00000745                 mov     edx, [ebp+var_4]
.text$mn:00000748                 mov     eax, [edx+0Ch]
.text$mn:0000074B                 push    eax             ; hWnd
.text$mn:0000074C                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000752                 mov     ecx, [ebp+var_4]
.text$mn:00000755                 mov     edx, [ecx+20h]
.text$mn:00000758                 push    edx             ; lParam
.text$mn:00000759                 mov     eax, [ebp+var_4]
.text$mn:0000075C                 mov     ecx, [eax+20h]
.text$mn:0000075F                 push    ecx             ; wParam
.text$mn:00000760                 push    1015h           ; Msg
.text$mn:00000765                 mov     edx, [ebp+var_4]
.text$mn:00000768                 mov     eax, [edx+0Ch]
.text$mn:0000076B                 push    eax             ; hWnd
.text$mn:0000076C                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000772                 mov     ecx, [ebp+var_4]
.text$mn:00000775                 mov     edx, [ecx+0Ch]
.text$mn:00000778                 push    edx             ; hWnd
.text$mn:00000779                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:0000077F                 mov     [ebp+var_BC], 3
.text$mn:00000789                 mov     [ebp+var_C0], 3
.text$mn:00000793                 lea     eax, [ebp+var_CC]
.text$mn:00000799                 push    eax             ; lParam
.text$mn:0000079A                 mov     ecx, [ebp+wParam]
.text$mn:0000079D                 push    ecx             ; wParam
.text$mn:0000079E                 push    102Bh           ; Msg
.text$mn:000007A3                 mov     edx, [ebp+var_4]
.text$mn:000007A6                 mov     eax, [edx+0Ch]
.text$mn:000007A9                 push    eax             ; hWnd
.text$mn:000007AA                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000007B0                 mov     ecx, [ebp+wParam]
.text$mn:000007B3                 push    ecx             ; lParam
.text$mn:000007B4                 mov     edx, [ebp+wParam]
.text$mn:000007B7                 push    edx             ; wParam
.text$mn:000007B8                 push    1015h           ; Msg
.text$mn:000007BD                 mov     eax, [ebp+var_4]
.text$mn:000007C0                 mov     ecx, [eax+0Ch]
.text$mn:000007C3                 push    ecx             ; hWnd
.text$mn:000007C4                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000007CA                 mov     edx, [ebp+var_4]
.text$mn:000007CD                 mov     eax, [edx+0Ch]
.text$mn:000007D0                 push    eax             ; hWnd
.text$mn:000007D1                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:000007D7                 mov     ecx, [ebp+var_4]
.text$mn:000007DA                 mov     edx, [ebp+wParam]
.text$mn:000007DD                 mov     [ecx+20h], edx
.text$mn:000007E0                 jmp     loc_8CF
.text$mn:000007E5 ; ---------------------------------------------------------------------------
.text$mn:000007E5
.text$mn:000007E5 loc_7E5:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+95j
.text$mn:000007E5                 mov     eax, [ebp+var_4]
.text$mn:000007E8                 mov     ecx, [eax+20h]
.text$mn:000007EB                 add     ecx, 1
.text$mn:000007EE                 mov     edx, [ebp+var_4]
.text$mn:000007F1                 mov     eax, [edx+1Ch]
.text$mn:000007F4                 sub     eax, 1
.text$mn:000007F7                 cmp     ecx, eax
.text$mn:000007F9                 jle     short loc_804
.text$mn:000007FB                 mov     [ebp+var_24], 0
.text$mn:00000802                 jmp     short loc_810
.text$mn:00000804 ; ---------------------------------------------------------------------------
.text$mn:00000804
.text$mn:00000804 loc_804:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+1A1j
.text$mn:00000804                 mov     ecx, [ebp+var_4]
.text$mn:00000807                 mov     edx, [ecx+20h]
.text$mn:0000080A                 add     edx, 1
.text$mn:0000080D                 mov     [ebp+var_24], edx
.text$mn:00000810
.text$mn:00000810 loc_810:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+1AAj
.text$mn:00000810                 mov     eax, [ebp+var_24]
.text$mn:00000813                 mov     [ebp+var_10], eax
.text$mn:00000816                 mov     [ebp+var_54], 3
.text$mn:0000081D                 mov     [ebp+var_58], 0
.text$mn:00000824                 lea     ecx, [ebp+var_64]
.text$mn:00000827                 push    ecx             ; lParam
.text$mn:00000828                 mov     edx, [ebp+var_4]
.text$mn:0000082B                 mov     eax, [edx+20h]
.text$mn:0000082E                 push    eax             ; wParam
.text$mn:0000082F                 push    102Bh           ; Msg
.text$mn:00000834                 mov     ecx, [ebp+var_4]
.text$mn:00000837                 mov     edx, [ecx+0Ch]
.text$mn:0000083A                 push    edx             ; hWnd
.text$mn:0000083B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000841                 mov     eax, [ebp+var_4]
.text$mn:00000844                 mov     ecx, [eax+20h]
.text$mn:00000847                 push    ecx             ; lParam
.text$mn:00000848                 mov     edx, [ebp+var_4]
.text$mn:0000084B                 mov     eax, [edx+20h]
.text$mn:0000084E                 push    eax             ; wParam
.text$mn:0000084F                 push    1015h           ; Msg
.text$mn:00000854                 mov     ecx, [ebp+var_4]
.text$mn:00000857                 mov     edx, [ecx+0Ch]
.text$mn:0000085A                 push    edx             ; hWnd
.text$mn:0000085B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000861                 mov     eax, [ebp+var_4]
.text$mn:00000864                 mov     ecx, [eax+0Ch]
.text$mn:00000867                 push    ecx             ; hWnd
.text$mn:00000868                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:0000086E                 mov     [ebp+var_124], 3
.text$mn:00000878                 mov     [ebp+var_128], 3
.text$mn:00000882                 lea     edx, [ebp+var_134]
.text$mn:00000888                 push    edx             ; lParam
.text$mn:00000889                 mov     eax, [ebp+var_10]
.text$mn:0000088C                 push    eax             ; wParam
.text$mn:0000088D                 push    102Bh           ; Msg
.text$mn:00000892                 mov     ecx, [ebp+var_4]
.text$mn:00000895                 mov     edx, [ecx+0Ch]
.text$mn:00000898                 push    edx             ; hWnd
.text$mn:00000899                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000089F                 mov     eax, [ebp+var_10]
.text$mn:000008A2                 push    eax             ; lParam
.text$mn:000008A3                 mov     ecx, [ebp+var_10]
.text$mn:000008A6                 push    ecx             ; wParam
.text$mn:000008A7                 push    1015h           ; Msg
.text$mn:000008AC                 mov     edx, [ebp+var_4]
.text$mn:000008AF                 mov     eax, [edx+0Ch]
.text$mn:000008B2                 push    eax             ; hWnd
.text$mn:000008B3                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000008B9                 mov     ecx, [ebp+var_4]
.text$mn:000008BC                 mov     edx, [ecx+0Ch]
.text$mn:000008BF                 push    edx             ; hWnd
.text$mn:000008C0                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:000008C6                 mov     eax, [ebp+var_4]
.text$mn:000008C9                 mov     ecx, [ebp+var_10]
.text$mn:000008CC                 mov     [eax+20h], ecx
.text$mn:000008CF
.text$mn:000008CF loc_8CF:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+188j
.text$mn:000008CF                 mov     eax, 1
.text$mn:000008D4                 jmp     loc_B68
.text$mn:000008D9 ; ---------------------------------------------------------------------------
.text$mn:000008D9
.text$mn:000008D9 loc_8D9:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+38j
.text$mn:000008D9                 mov     eax, 1
.text$mn:000008DE                 jmp     loc_B68
.text$mn:000008E3 ; ---------------------------------------------------------------------------
.text$mn:000008E3
.text$mn:000008E3 loc_8E3:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+2Bj
.text$mn:000008E3                 mov     edx, [ebp+arg_C]
.text$mn:000008E6                 mov     [ebp+var_8], edx
.text$mn:000008E9                 cmp     [ebp+var_8], 0
.text$mn:000008ED                 jz      loc_B44
.text$mn:000008F3                 mov     eax, [ebp+var_8]
.text$mn:000008F6                 cmp     dword ptr [eax+4], 100h
.text$mn:000008FD                 jnz     loc_B3D
.text$mn:00000903                 push    11h             ; nVirtKey
.text$mn:00000905                 call    dword ptr ds:__imp__GetKeyState@4 ; GetKeyState(x)
.text$mn:0000090B                 movsx   ecx, ax
.text$mn:0000090E                 and     ecx, 80h
.text$mn:00000914                 jz      loc_B3D
.text$mn:0000091A                 mov     edx, [ebp+var_8]
.text$mn:0000091D                 cmp     dword ptr [edx+8], 9
.text$mn:00000921                 jnz     short loc_933
.text$mn:00000923                 push    10h             ; nVirtKey
.text$mn:00000925                 call    dword ptr ds:__imp__GetKeyState@4 ; GetKeyState(x)
.text$mn:0000092B                 cwde
.text$mn:0000092C                 and     eax, 80h
.text$mn:00000931                 jnz     short loc_940
.text$mn:00000933
.text$mn:00000933 loc_933:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+2C9j
.text$mn:00000933                 mov     ecx, [ebp+var_8]
.text$mn:00000936                 cmp     dword ptr [ecx+8], 26h ; '&'
.text$mn:0000093A                 jnz     loc_A32
.text$mn:00000940
.text$mn:00000940 loc_940:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+2D9j
.text$mn:00000940                 mov     edx, [ebp+var_4]
.text$mn:00000943                 mov     eax, [edx+20h]
.text$mn:00000946                 sub     eax, 1
.text$mn:00000949                 jns     short loc_959
.text$mn:0000094B                 mov     ecx, [ebp+var_4]
.text$mn:0000094E                 mov     edx, [ecx+1Ch]
.text$mn:00000951                 sub     edx, 1
.text$mn:00000954                 mov     [ebp+var_28], edx
.text$mn:00000957                 jmp     short loc_965
.text$mn:00000959 ; ---------------------------------------------------------------------------
.text$mn:00000959
.text$mn:00000959 loc_959:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+2F1j
.text$mn:00000959                 mov     eax, [ebp+var_4]
.text$mn:0000095C                 mov     ecx, [eax+20h]
.text$mn:0000095F                 sub     ecx, 1
.text$mn:00000962                 mov     [ebp+var_28], ecx
.text$mn:00000965
.text$mn:00000965 loc_965:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+2FFj
.text$mn:00000965                 mov     edx, [ebp+var_28]
.text$mn:00000968                 mov     [ebp+var_1C], edx
.text$mn:0000096B                 mov     [ebp+var_88], 3
.text$mn:00000975                 mov     [ebp+var_8C], 0
.text$mn:0000097F                 lea     eax, [ebp+var_98]
.text$mn:00000985                 push    eax             ; lParam
.text$mn:00000986                 mov     ecx, [ebp+var_4]
.text$mn:00000989                 mov     edx, [ecx+20h]
.text$mn:0000098C                 push    edx             ; wParam
.text$mn:0000098D                 push    102Bh           ; Msg
.text$mn:00000992                 mov     eax, [ebp+var_4]
.text$mn:00000995                 mov     ecx, [eax+0Ch]
.text$mn:00000998                 push    ecx             ; hWnd
.text$mn:00000999                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000099F                 mov     edx, [ebp+var_4]
.text$mn:000009A2                 mov     eax, [edx+20h]
.text$mn:000009A5                 push    eax             ; lParam
.text$mn:000009A6                 mov     ecx, [ebp+var_4]
.text$mn:000009A9                 mov     edx, [ecx+20h]
.text$mn:000009AC                 push    edx             ; wParam
.text$mn:000009AD                 push    1015h           ; Msg
.text$mn:000009B2                 mov     eax, [ebp+var_4]
.text$mn:000009B5                 mov     ecx, [eax+0Ch]
.text$mn:000009B8                 push    ecx             ; hWnd
.text$mn:000009B9                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000009BF                 mov     edx, [ebp+var_4]
.text$mn:000009C2                 mov     eax, [edx+0Ch]
.text$mn:000009C5                 push    eax             ; hWnd
.text$mn:000009C6                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:000009CC                 mov     [ebp+var_F0], 3
.text$mn:000009D6                 mov     [ebp+var_F4], 3
.text$mn:000009E0                 lea     ecx, [ebp+var_100]
.text$mn:000009E6                 push    ecx             ; lParam
.text$mn:000009E7                 mov     edx, [ebp+var_1C]
.text$mn:000009EA                 push    edx             ; wParam
.text$mn:000009EB                 push    102Bh           ; Msg
.text$mn:000009F0                 mov     eax, [ebp+var_4]
.text$mn:000009F3                 mov     ecx, [eax+0Ch]
.text$mn:000009F6                 push    ecx             ; hWnd
.text$mn:000009F7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000009FD                 mov     edx, [ebp+var_1C]
.text$mn:00000A00                 push    edx             ; lParam
.text$mn:00000A01                 mov     eax, [ebp+var_1C]
.text$mn:00000A04                 push    eax             ; wParam
.text$mn:00000A05                 push    1015h           ; Msg
.text$mn:00000A0A                 mov     ecx, [ebp+var_4]
.text$mn:00000A0D                 mov     edx, [ecx+0Ch]
.text$mn:00000A10                 push    edx             ; hWnd
.text$mn:00000A11                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000A17                 mov     eax, [ebp+var_4]
.text$mn:00000A1A                 mov     ecx, [eax+0Ch]
.text$mn:00000A1D                 push    ecx             ; hWnd
.text$mn:00000A1E                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:00000A24                 mov     edx, [ebp+var_4]
.text$mn:00000A27                 mov     eax, [ebp+var_1C]
.text$mn:00000A2A                 mov     [edx+20h], eax
.text$mn:00000A2D                 jmp     loc_B3B
.text$mn:00000A32 ; ---------------------------------------------------------------------------
.text$mn:00000A32
.text$mn:00000A32 loc_A32:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+2E2j
.text$mn:00000A32                 mov     ecx, [ebp+var_8]
.text$mn:00000A35                 cmp     dword ptr [ecx+8], 9
.text$mn:00000A39                 jz      short loc_A48
.text$mn:00000A3B                 mov     edx, [ebp+var_8]
.text$mn:00000A3E                 cmp     dword ptr [edx+8], 28h ; '('
.text$mn:00000A42                 jnz     loc_B3B
.text$mn:00000A48
.text$mn:00000A48 loc_A48:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+3E1j
.text$mn:00000A48                 mov     eax, [ebp+var_4]
.text$mn:00000A4B                 mov     ecx, [eax+20h]
.text$mn:00000A4E                 add     ecx, 1
.text$mn:00000A51                 mov     edx, [ebp+var_4]
.text$mn:00000A54                 mov     eax, [edx+1Ch]
.text$mn:00000A57                 sub     eax, 1
.text$mn:00000A5A                 cmp     ecx, eax
.text$mn:00000A5C                 jle     short loc_A67
.text$mn:00000A5E                 mov     [ebp+var_30], 0
.text$mn:00000A65                 jmp     short loc_A73
.text$mn:00000A67 ; ---------------------------------------------------------------------------
.text$mn:00000A67
.text$mn:00000A67 loc_A67:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+404j
.text$mn:00000A67                 mov     ecx, [ebp+var_4]
.text$mn:00000A6A                 mov     edx, [ecx+20h]
.text$mn:00000A6D                 add     edx, 1
.text$mn:00000A70                 mov     [ebp+var_30], edx
.text$mn:00000A73
.text$mn:00000A73 loc_A73:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+40Dj
.text$mn:00000A73                 mov     eax, [ebp+var_30]
.text$mn:00000A76                 mov     [ebp+var_18], eax
.text$mn:00000A79                 mov     [ebp+var_158], 3
.text$mn:00000A83                 mov     [ebp+var_15C], 0
.text$mn:00000A8D                 lea     ecx, [ebp+var_168]
.text$mn:00000A93                 push    ecx             ; lParam
.text$mn:00000A94                 mov     edx, [ebp+var_4]
.text$mn:00000A97                 mov     eax, [edx+20h]
.text$mn:00000A9A                 push    eax             ; wParam
.text$mn:00000A9B                 push    102Bh           ; Msg
.text$mn:00000AA0                 mov     ecx, [ebp+var_4]
.text$mn:00000AA3                 mov     edx, [ecx+0Ch]
.text$mn:00000AA6                 push    edx             ; hWnd
.text$mn:00000AA7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000AAD                 mov     eax, [ebp+var_4]
.text$mn:00000AB0                 mov     ecx, [eax+20h]
.text$mn:00000AB3                 push    ecx             ; lParam
.text$mn:00000AB4                 mov     edx, [ebp+var_4]
.text$mn:00000AB7                 mov     eax, [edx+20h]
.text$mn:00000ABA                 push    eax             ; wParam
.text$mn:00000ABB                 push    1015h           ; Msg
.text$mn:00000AC0                 mov     ecx, [ebp+var_4]
.text$mn:00000AC3                 mov     edx, [ecx+0Ch]
.text$mn:00000AC6                 push    edx             ; hWnd
.text$mn:00000AC7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000ACD                 mov     eax, [ebp+var_4]
.text$mn:00000AD0                 mov     ecx, [eax+0Ch]
.text$mn:00000AD3                 push    ecx             ; hWnd
.text$mn:00000AD4                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:00000ADA                 mov     [ebp+var_1C0], 3
.text$mn:00000AE4                 mov     [ebp+var_1C4], 3
.text$mn:00000AEE                 lea     edx, [ebp+var_1D0]
.text$mn:00000AF4                 push    edx             ; lParam
.text$mn:00000AF5                 mov     eax, [ebp+var_18]
.text$mn:00000AF8                 push    eax             ; wParam
.text$mn:00000AF9                 push    102Bh           ; Msg
.text$mn:00000AFE                 mov     ecx, [ebp+var_4]
.text$mn:00000B01                 mov     edx, [ecx+0Ch]
.text$mn:00000B04                 push    edx             ; hWnd
.text$mn:00000B05                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000B0B                 mov     eax, [ebp+var_18]
.text$mn:00000B0E                 push    eax             ; lParam
.text$mn:00000B0F                 mov     ecx, [ebp+var_18]
.text$mn:00000B12                 push    ecx             ; wParam
.text$mn:00000B13                 push    1015h           ; Msg
.text$mn:00000B18                 mov     edx, [ebp+var_4]
.text$mn:00000B1B                 mov     eax, [edx+0Ch]
.text$mn:00000B1E                 push    eax             ; hWnd
.text$mn:00000B1F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000B25                 mov     ecx, [ebp+var_4]
.text$mn:00000B28                 mov     edx, [ecx+0Ch]
.text$mn:00000B2B                 push    edx             ; hWnd
.text$mn:00000B2C                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:00000B32                 mov     eax, [ebp+var_4]
.text$mn:00000B35                 mov     ecx, [ebp+var_18]
.text$mn:00000B38                 mov     [eax+20h], ecx
.text$mn:00000B3B
.text$mn:00000B3B loc_B3B:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+3D5j
.text$mn:00000B3B                                         ; TaskList::runProc(HWND__ *,uint,uint,long)+3EAj
.text$mn:00000B3B                 jmp     short loc_B44
.text$mn:00000B3D ; ---------------------------------------------------------------------------
.text$mn:00000B3D
.text$mn:00000B3D loc_B3D:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+2A5j
.text$mn:00000B3D                                         ; TaskList::runProc(HWND__ *,uint,uint,long)+2BCj
.text$mn:00000B3D                 mov     eax, 1
.text$mn:00000B42                 jmp     short loc_B68
.text$mn:00000B44 ; ---------------------------------------------------------------------------
.text$mn:00000B44
.text$mn:00000B44 loc_B44:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+295j
.text$mn:00000B44                                         ; TaskList::runProc(HWND__ *,uint,uint,long):loc_B3Bj
.text$mn:00000B44                 mov     eax, 4
.text$mn:00000B49                 jmp     short loc_B68
.text$mn:00000B4B ; ---------------------------------------------------------------------------
.text$mn:00000B4B
.text$mn:00000B4B loc_B4B:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+3Ej
.text$mn:00000B4B                                         ; TaskList::runProc(HWND__ *,uint,uint,long)+4Cj
.text$mn:00000B4B                 mov     edx, [ebp+arg_C]
.text$mn:00000B4E                 push    edx             ; lParam
.text$mn:00000B4F                 mov     eax, [ebp+arg_8]
.text$mn:00000B52                 push    eax             ; wParam
.text$mn:00000B53                 mov     ecx, [ebp+Msg]
.text$mn:00000B56                 push    ecx             ; Msg
.text$mn:00000B57                 mov     edx, [ebp+hWnd]
.text$mn:00000B5A                 push    edx             ; hWnd
.text$mn:00000B5B                 mov     eax, [ebp+var_4]
.text$mn:00000B5E                 mov     ecx, [eax+10h]
.text$mn:00000B61                 push    ecx             ; lpPrevWndFunc
.text$mn:00000B62                 call    dword ptr ds:__imp__CallWindowProcW@20 ; CallWindowProcW(x,x,x,x,x)
.text$mn:00000B68
.text$mn:00000B68 loc_B68:                                ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+7Aj
.text$mn:00000B68                                         ; TaskList::runProc(HWND__ *,uint,uint,long)+27Cj ...
.text$mn:00000B68                 mov     esp, ebp
.text$mn:00000B6A                 pop     ebp
.text$mn:00000B6B                 retn    10h
.text$mn:00000B6B ?runProc@TaskList@@IAEJPAUHWND__@@IIJ@Z endp
.text$mn:00000B6B
.text$mn:00000B6B ; ---------------------------------------------------------------------------
.text$mn:00000B6E                 align 10h
.text$mn:00000B6E _text$mn        ends
.text$mn:00000B6E
.text$mn:00000B70 ; ===========================================================================
.text$mn:00000B70
.text$mn:00000B70 ; Segment type: Pure code
.text$mn:00000B70 ; Segment permissions: Read/Execute
.text$mn:00000B70 _text$mn        segment para public 'CODE' use32
.text$mn:00000B70                 assume cs:_text$mn
.text$mn:00000B70                 ;org 0B70h
.text$mn:00000B70 ; COMDAT (pick any)
.text$mn:00000B70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B70
.text$mn:00000B70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B70
.text$mn:00000B70 ; Attributes: bp-based frame
.text$mn:00000B70
.text$mn:00000B70 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00000B70                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00000B70 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00000B70                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00000B70
.text$mn:00000B70 var_4           = dword ptr -4
.text$mn:00000B70 arg_0           = dword ptr  8
.text$mn:00000B70
.text$mn:00000B70                 push    ebp
.text$mn:00000B71                 mov     ebp, esp
.text$mn:00000B73                 push    ecx
.text$mn:00000B74                 mov     [ebp+var_4], 0
.text$mn:00000B7B                 cmp     [ebp+arg_0], 0
.text$mn:00000B7F                 jnz     short loc_B83
.text$mn:00000B81                 jmp     short loc_BA3
.text$mn:00000B83 ; ---------------------------------------------------------------------------
.text$mn:00000B83
.text$mn:00000B83 loc_B83:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00000B83                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00000B87                 ja      short loc_B9E
.text$mn:00000B89                 mov     eax, [ebp+arg_0]
.text$mn:00000B8C                 push    eax             ; unsigned int
.text$mn:00000B8D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000B92                 add     esp, 4
.text$mn:00000B95                 mov     [ebp+var_4], eax
.text$mn:00000B98                 cmp     [ebp+var_4], 0
.text$mn:00000B9C                 jnz     short loc_BA3
.text$mn:00000B9E
.text$mn:00000B9E loc_B9E:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00000B9E                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000BA3
.text$mn:00000BA3 loc_BA3:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00000BA3                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00000BA3                 mov     eax, [ebp+var_4]
.text$mn:00000BA6                 mov     esp, ebp
.text$mn:00000BA8                 pop     ebp
.text$mn:00000BA9                 retn
.text$mn:00000BA9 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00000BA9
.text$mn:00000BA9 ; ---------------------------------------------------------------------------
.text$mn:00000BAA                 align 4
.text$mn:00000BAA _text$mn        ends
.text$mn:00000BAA
.text$mn:00000BAC ; ===========================================================================
.text$mn:00000BAC
.text$mn:00000BAC ; Segment type: Pure code
.text$mn:00000BAC ; Segment permissions: Read/Execute
.text$mn:00000BAC _text$mn        segment para public 'CODE' use32
.text$mn:00000BAC                 assume cs:_text$mn
.text$mn:00000BAC                 ;org 0BACh
.text$mn:00000BAC ; COMDAT (pick any)
.text$mn:00000BAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000BAC
.text$mn:00000BAC ; =============== S U B R O U T I N E =======================================
.text$mn:00000BAC
.text$mn:00000BAC ; Attributes: bp-based frame
.text$mn:00000BAC
.text$mn:00000BAC ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00000BAC                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00000BAC ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00000BAC                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00000BAC
.text$mn:00000BAC var_4           = dword ptr -4
.text$mn:00000BAC arg_0           = dword ptr  8
.text$mn:00000BAC
.text$mn:00000BAC                 push    ebp
.text$mn:00000BAD                 mov     ebp, esp
.text$mn:00000BAF                 push    ecx
.text$mn:00000BB0                 mov     [ebp+var_4], 0
.text$mn:00000BB7                 cmp     [ebp+arg_0], 0
.text$mn:00000BBB                 jnz     short loc_BBF
.text$mn:00000BBD                 jmp     short loc_BE5
.text$mn:00000BBF ; ---------------------------------------------------------------------------
.text$mn:00000BBF
.text$mn:00000BBF loc_BBF:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00000BBF                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00000BC6                 ja      short loc_BE0
.text$mn:00000BC8                 mov     eax, [ebp+arg_0]
.text$mn:00000BCB                 shl     eax, 3
.text$mn:00000BCE                 push    eax             ; unsigned int
.text$mn:00000BCF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000BD4                 add     esp, 4
.text$mn:00000BD7                 mov     [ebp+var_4], eax
.text$mn:00000BDA                 cmp     [ebp+var_4], 0
.text$mn:00000BDE                 jnz     short loc_BE5
.text$mn:00000BE0
.text$mn:00000BE0 loc_BE0:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00000BE0                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000BE5
.text$mn:00000BE5 loc_BE5:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00000BE5                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00000BE5                 mov     eax, [ebp+var_4]
.text$mn:00000BE8                 mov     esp, ebp
.text$mn:00000BEA                 pop     ebp
.text$mn:00000BEB                 retn
.text$mn:00000BEB ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00000BEB
.text$mn:00000BEB _text$mn        ends
.text$mn:00000BEB
.text$mn:00000BEC ; ===========================================================================
.text$mn:00000BEC
.text$mn:00000BEC ; Segment type: Pure code
.text$mn:00000BEC ; Segment permissions: Read/Execute
.text$mn:00000BEC _text$mn        segment para public 'CODE' use32
.text$mn:00000BEC                 assume cs:_text$mn
.text$mn:00000BEC                 ;org 0BECh
.text$mn:00000BEC ; COMDAT (pick any)
.text$mn:00000BEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000BEC
.text$mn:00000BEC ; =============== S U B R O U T I N E =======================================
.text$mn:00000BEC
.text$mn:00000BEC ; Attributes: bp-based frame
.text$mn:00000BEC
.text$mn:00000BEC ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00000BEC                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00000BEC ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00000BEC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00000BEC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00000BEC
.text$mn:00000BEC arg_0           = dword ptr  8
.text$mn:00000BEC arg_4           = dword ptr  0Ch
.text$mn:00000BEC arg_8           = dword ptr  10h
.text$mn:00000BEC
.text$mn:00000BEC                 push    ebp
.text$mn:00000BED                 mov     ebp, esp
.text$mn:00000BEF                 cmp     [ebp+arg_0], 0
.text$mn:00000BF3                 jnz     short loc_C0A
.text$mn:00000BF5                 mov     eax, [ebp+arg_8]
.text$mn:00000BF8                 push    eax             ; unsigned int
.text$mn:00000BF9                 mov     ecx, [ebp+arg_4]
.text$mn:00000BFC                 push    ecx             ; wchar_t *
.text$mn:00000BFD                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000C02                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00000C07                 add     esp, 0Ch
.text$mn:00000C0A
.text$mn:00000C0A loc_C0A:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00000C0A                 pop     ebp
.text$mn:00000C0B                 retn
.text$mn:00000C0B ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00000C0B
.text$mn:00000C0B _text$mn        ends
.text$mn:00000C0B
.text$mn:00000C0C ; ===========================================================================
.text$mn:00000C0C
.text$mn:00000C0C ; Segment type: Pure code
.text$mn:00000C0C ; Segment permissions: Read/Execute
.text$mn:00000C0C _text$mn        segment para public 'CODE' use32
.text$mn:00000C0C                 assume cs:_text$mn
.text$mn:00000C0C                 ;org 0C0Ch
.text$mn:00000C0C ; COMDAT (pick any)
.text$mn:00000C0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C0C
.text$mn:00000C0C ; =============== S U B R O U T I N E =======================================
.text$mn:00000C0C
.text$mn:00000C0C ; Attributes: bp-based frame
.text$mn:00000C0C
.text$mn:00000C0C ; char * __cdecl std::addressof<char>(char &)
.text$mn:00000C0C                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00000C0C ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00000C0C                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00000C0C                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00000C0C
.text$mn:00000C0C arg_0           = dword ptr  8
.text$mn:00000C0C
.text$mn:00000C0C                 push    ebp
.text$mn:00000C0D                 mov     ebp, esp
.text$mn:00000C0F                 mov     eax, [ebp+arg_0]
.text$mn:00000C12                 pop     ebp
.text$mn:00000C13                 retn
.text$mn:00000C13 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00000C13
.text$mn:00000C13 _text$mn        ends
.text$mn:00000C13
.text$mn:00000C14 ; ===========================================================================
.text$mn:00000C14
.text$mn:00000C14 ; Segment type: Pure code
.text$mn:00000C14 ; Segment permissions: Read/Execute
.text$mn:00000C14 _text$mn        segment para public 'CODE' use32
.text$mn:00000C14                 assume cs:_text$mn
.text$mn:00000C14                 ;org 0C14h
.text$mn:00000C14 ; COMDAT (pick any)
.text$mn:00000C14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C14
.text$mn:00000C14 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C14
.text$mn:00000C14 ; Attributes: bp-based frame
.text$mn:00000C14
.text$mn:00000C14 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00000C14                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00000C14 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000C14                                         ; CODE XREF: $LN19+4Bp
.text$mn:00000C14
.text$mn:00000C14 var_4           = dword ptr -4
.text$mn:00000C14 arg_0           = dword ptr  8
.text$mn:00000C14 arg_4           = dword ptr  0Ch
.text$mn:00000C14
.text$mn:00000C14                 push    ebp
.text$mn:00000C15                 mov     ebp, esp
.text$mn:00000C17                 push    ecx
.text$mn:00000C18                 mov     [ebp+var_4], ecx
.text$mn:00000C1B                 mov     eax, [ebp+arg_4]
.text$mn:00000C1E                 push    eax
.text$mn:00000C1F                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000C24                 add     esp, 4
.text$mn:00000C27                 push    eax             ; int
.text$mn:00000C28                 mov     ecx, [ebp+arg_0]
.text$mn:00000C2B                 push    ecx             ; void *
.text$mn:00000C2C                 mov     edx, [ebp+var_4]
.text$mn:00000C2F                 push    edx             ; int
.text$mn:00000C30                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00000C35                 add     esp, 0Ch
.text$mn:00000C38                 mov     esp, ebp
.text$mn:00000C3A                 pop     ebp
.text$mn:00000C3B                 retn    8
.text$mn:00000C3B ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000C3B
.text$mn:00000C3B ; ---------------------------------------------------------------------------
.text$mn:00000C3E                 align 10h
.text$mn:00000C3E _text$mn        ends
.text$mn:00000C3E
.text$mn:00000C40 ; ===========================================================================
.text$mn:00000C40
.text$mn:00000C40 ; Segment type: Pure code
.text$mn:00000C40 ; Segment permissions: Read/Execute
.text$mn:00000C40 _text$mn        segment para public 'CODE' use32
.text$mn:00000C40                 assume cs:_text$mn
.text$mn:00000C40                 ;org 0C40h
.text$mn:00000C40 ; COMDAT (pick any)
.text$mn:00000C40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C40
.text$mn:00000C40 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C40
.text$mn:00000C40 ; Attributes: bp-based frame
.text$mn:00000C40
.text$mn:00000C40 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00000C40                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000C40 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000C40                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00000C40
.text$mn:00000C40 var_1C          = dword ptr -1Ch
.text$mn:00000C40 var_18          = dword ptr -18h
.text$mn:00000C40 var_14          = dword ptr -14h
.text$mn:00000C40 var_10          = dword ptr -10h
.text$mn:00000C40 var_C           = dword ptr -0Ch
.text$mn:00000C40 var_4           = dword ptr -4
.text$mn:00000C40 arg_0           = dword ptr  8
.text$mn:00000C40 arg_4           = dword ptr  0Ch
.text$mn:00000C40
.text$mn:00000C40                 push    ebp
.text$mn:00000C41                 mov     ebp, esp
.text$mn:00000C43                 push    0FFFFFFFFh
.text$mn:00000C45                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000C4A                 mov     eax, large fs:0
.text$mn:00000C50                 push    eax
.text$mn:00000C51                 sub     esp, 10h
.text$mn:00000C54                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C59                 xor     eax, ebp
.text$mn:00000C5B                 push    eax
.text$mn:00000C5C                 lea     eax, [ebp+var_C]
.text$mn:00000C5F                 mov     large fs:0, eax
.text$mn:00000C65                 mov     [ebp+var_18], ecx
.text$mn:00000C68                 mov     eax, [ebp+arg_0]
.text$mn:00000C6B                 push    eax             ; void *
.text$mn:00000C6C                 push    4               ; unsigned int
.text$mn:00000C6E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000C73                 add     esp, 8
.text$mn:00000C76                 mov     [ebp+var_10], eax
.text$mn:00000C79                 mov     [ebp+var_4], 0
.text$mn:00000C80                 cmp     [ebp+var_10], 0
.text$mn:00000C84                 jz      short loc_CA1
.text$mn:00000C86                 mov     ecx, [ebp+arg_4]
.text$mn:00000C89                 push    ecx
.text$mn:00000C8A                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000C8F                 add     esp, 4
.text$mn:00000C92                 mov     edx, [ebp+var_10]
.text$mn:00000C95                 mov     eax, [eax]
.text$mn:00000C97                 mov     [edx], eax
.text$mn:00000C99                 mov     ecx, [ebp+var_10]
.text$mn:00000C9C                 mov     [ebp+var_14], ecx
.text$mn:00000C9F                 jmp     short loc_CA8
.text$mn:00000CA1 ; ---------------------------------------------------------------------------
.text$mn:00000CA1
.text$mn:00000CA1 loc_CA1:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00000CA1                 mov     [ebp+var_14], 0
.text$mn:00000CA8
.text$mn:00000CA8 loc_CA8:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00000CA8                 mov     edx, [ebp+var_14]
.text$mn:00000CAB                 mov     [ebp+var_1C], edx
.text$mn:00000CAE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000CB5                 mov     ecx, [ebp+var_C]
.text$mn:00000CB8                 mov     large fs:0, ecx
.text$mn:00000CBF                 pop     ecx
.text$mn:00000CC0                 mov     esp, ebp
.text$mn:00000CC2                 pop     ebp
.text$mn:00000CC3                 retn    8
.text$mn:00000CC3 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000CC3
.text$mn:00000CC3 ; ---------------------------------------------------------------------------
.text$mn:00000CC6                 align 4
.text$mn:00000CC6 _text$mn        ends
.text$mn:00000CC6
.text$x:00000CC8 ; ===========================================================================
.text$x:00000CC8
.text$x:00000CC8 ; Segment type: Pure code
.text$x:00000CC8 ; Segment permissions: Read/Execute
.text$x:00000CC8 _text$x         segment para public 'CODE' use32
.text$x:00000CC8                 assume cs:_text$x
.text$x:00000CC8                 ;org 0CC8h
.text$x:00000CC8 ; COMDAT (pick associative to section at C40)
.text$x:00000CC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000CC8
.text$x:00000CC8 ; =============== S U B R O U T I N E =======================================
.text$x:00000CC8
.text$x:00000CC8
.text$x:00000CC8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00000CC8                                         ; DATA XREF: .xdata$x:00002A94o
.text$x:00000CC8                 mov     eax, [ebp+8]
.text$x:00000CCB                 push    eax
.text$x:00000CCC                 mov     eax, [ebp-10h]
.text$x:00000CCF                 push    eax             ; void *
.text$x:00000CD0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000CD5                 add     esp, 8
.text$x:00000CD8                 retn
.text$x:00000CD8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00000CD8
.text$x:00000CD9
.text$x:00000CD9 ; =============== S U B R O U T I N E =======================================
.text$x:00000CD9
.text$x:00000CD9
.text$x:00000CD9 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00000CD9                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00000CD9
.text$x:00000CD9 arg_4           = dword ptr  8
.text$x:00000CD9
.text$x:00000CD9                 mov     edx, [esp+arg_4]
.text$x:00000CDD                 lea     eax, [edx+0Ch]
.text$x:00000CE0                 mov     ecx, [edx-14h]
.text$x:00000CE3                 xor     ecx, eax
.text$x:00000CE5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000CEA                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00000CEF                 jmp     ___CxxFrameHandler3
.text$x:00000CEF __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00000CEF
.text$x:00000CEF _text$x         ends
.text$x:00000CEF
.text$mn:00000CF4 ; ===========================================================================
.text$mn:00000CF4
.text$mn:00000CF4 ; Segment type: Pure code
.text$mn:00000CF4 ; Segment permissions: Read/Execute
.text$mn:00000CF4 _text$mn        segment para public 'CODE' use32
.text$mn:00000CF4                 assume cs:_text$mn
.text$mn:00000CF4                 ;org 0CF4h
.text$mn:00000CF4 ; COMDAT (pick any)
.text$mn:00000CF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CF4
.text$mn:00000CF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CF4
.text$mn:00000CF4 ; Attributes: bp-based frame
.text$mn:00000CF4
.text$mn:00000CF4 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00000CF4                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00000CF4 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00000CF4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00000CF4
.text$mn:00000CF4 arg_0           = dword ptr  8
.text$mn:00000CF4 arg_4           = dword ptr  0Ch
.text$mn:00000CF4 arg_8           = dword ptr  10h
.text$mn:00000CF4
.text$mn:00000CF4                 push    ebp
.text$mn:00000CF5                 mov     ebp, esp
.text$mn:00000CF7                 mov     eax, [ebp+arg_8]
.text$mn:00000CFA                 push    eax
.text$mn:00000CFB                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000D00                 add     esp, 4
.text$mn:00000D03                 push    eax             ; int
.text$mn:00000D04                 mov     ecx, [ebp+arg_4]
.text$mn:00000D07                 push    ecx             ; void *
.text$mn:00000D08                 mov     ecx, [ebp+arg_0]
.text$mn:00000D0B                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00000D10                 pop     ebp
.text$mn:00000D11                 retn
.text$mn:00000D11 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00000D11
.text$mn:00000D11 ; ---------------------------------------------------------------------------
.text$mn:00000D12                 align 4
.text$mn:00000D12 _text$mn        ends
.text$mn:00000D12
.text$mn:00000D14 ; ===========================================================================
.text$mn:00000D14
.text$mn:00000D14 ; Segment type: Pure code
.text$mn:00000D14 ; Segment permissions: Read/Execute
.text$mn:00000D14 _text$mn        segment para public 'CODE' use32
.text$mn:00000D14                 assume cs:_text$mn
.text$mn:00000D14                 ;org 0D14h
.text$mn:00000D14 ; COMDAT (pick any)
.text$mn:00000D14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D14
.text$mn:00000D14 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D14
.text$mn:00000D14 ; Attributes: bp-based frame
.text$mn:00000D14
.text$mn:00000D14 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00000D14                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000D14 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00000D14                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00000D14
.text$mn:00000D14 var_1C          = dword ptr -1Ch
.text$mn:00000D14 var_18          = dword ptr -18h
.text$mn:00000D14 var_14          = dword ptr -14h
.text$mn:00000D14 var_10          = dword ptr -10h
.text$mn:00000D14 var_C           = dword ptr -0Ch
.text$mn:00000D14 var_4           = dword ptr -4
.text$mn:00000D14 arg_0           = dword ptr  8
.text$mn:00000D14 arg_4           = dword ptr  0Ch
.text$mn:00000D14
.text$mn:00000D14                 push    ebp
.text$mn:00000D15                 mov     ebp, esp
.text$mn:00000D17                 push    0FFFFFFFFh
.text$mn:00000D19                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000D1E                 mov     eax, large fs:0
.text$mn:00000D24                 push    eax
.text$mn:00000D25                 sub     esp, 10h
.text$mn:00000D28                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D2D                 xor     eax, ebp
.text$mn:00000D2F                 push    eax
.text$mn:00000D30                 lea     eax, [ebp+var_C]
.text$mn:00000D33                 mov     large fs:0, eax
.text$mn:00000D39                 mov     [ebp+var_18], ecx
.text$mn:00000D3C                 mov     eax, [ebp+arg_0]
.text$mn:00000D3F                 push    eax             ; void *
.text$mn:00000D40                 push    8               ; unsigned int
.text$mn:00000D42                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000D47                 add     esp, 8
.text$mn:00000D4A                 mov     [ebp+var_10], eax
.text$mn:00000D4D                 mov     [ebp+var_4], 0
.text$mn:00000D54                 cmp     [ebp+var_10], 0
.text$mn:00000D58                 jz      short loc_D7B
.text$mn:00000D5A                 mov     ecx, [ebp+arg_4]
.text$mn:00000D5D                 push    ecx
.text$mn:00000D5E                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00000D63                 add     esp, 4
.text$mn:00000D66                 mov     edx, [eax]
.text$mn:00000D68                 mov     eax, [eax+4]
.text$mn:00000D6B                 mov     ecx, [ebp+var_10]
.text$mn:00000D6E                 mov     [ecx], edx
.text$mn:00000D70                 mov     [ecx+4], eax
.text$mn:00000D73                 mov     edx, [ebp+var_10]
.text$mn:00000D76                 mov     [ebp+var_14], edx
.text$mn:00000D79                 jmp     short loc_D82
.text$mn:00000D7B ; ---------------------------------------------------------------------------
.text$mn:00000D7B
.text$mn:00000D7B loc_D7B:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00000D7B                 mov     [ebp+var_14], 0
.text$mn:00000D82
.text$mn:00000D82 loc_D82:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00000D82                 mov     eax, [ebp+var_14]
.text$mn:00000D85                 mov     [ebp+var_1C], eax
.text$mn:00000D88                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000D8F                 mov     ecx, [ebp+var_C]
.text$mn:00000D92                 mov     large fs:0, ecx
.text$mn:00000D99                 pop     ecx
.text$mn:00000D9A                 mov     esp, ebp
.text$mn:00000D9C                 pop     ebp
.text$mn:00000D9D                 retn    8
.text$mn:00000D9D ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00000D9D
.text$mn:00000D9D _text$mn        ends
.text$mn:00000D9D
.text$x:00000DA0 ; ===========================================================================
.text$x:00000DA0
.text$x:00000DA0 ; Segment type: Pure code
.text$x:00000DA0 ; Segment permissions: Read/Execute
.text$x:00000DA0 _text$x         segment para public 'CODE' use32
.text$x:00000DA0                 assume cs:_text$x
.text$x:00000DA0                 ;org 0DA0h
.text$x:00000DA0 ; COMDAT (pick associative to section at D14)
.text$x:00000DA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000DA0
.text$x:00000DA0 ; =============== S U B R O U T I N E =======================================
.text$x:00000DA0
.text$x:00000DA0
.text$x:00000DA0 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00000DA0                                         ; DATA XREF: .xdata$x:00002A68o
.text$x:00000DA0                 mov     eax, [ebp+8]
.text$x:00000DA3                 push    eax
.text$x:00000DA4                 mov     eax, [ebp-10h]
.text$x:00000DA7                 push    eax             ; void *
.text$x:00000DA8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000DAD                 add     esp, 8
.text$x:00000DB0                 retn
.text$x:00000DB0 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00000DB0
.text$x:00000DB1
.text$x:00000DB1 ; =============== S U B R O U T I N E =======================================
.text$x:00000DB1
.text$x:00000DB1
.text$x:00000DB1 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00000DB1                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00000DB1
.text$x:00000DB1 arg_4           = dword ptr  8
.text$x:00000DB1
.text$x:00000DB1                 mov     edx, [esp+arg_4]
.text$x:00000DB5                 lea     eax, [edx+0Ch]
.text$x:00000DB8                 mov     ecx, [edx-14h]
.text$x:00000DBB                 xor     ecx, eax
.text$x:00000DBD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000DC2                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00000DC7                 jmp     ___CxxFrameHandler3
.text$x:00000DC7 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00000DC7
.text$x:00000DC7 _text$x         ends
.text$x:00000DC7
.text$mn:00000DCC ; ===========================================================================
.text$mn:00000DCC
.text$mn:00000DCC ; Segment type: Pure code
.text$mn:00000DCC ; Segment permissions: Read/Execute
.text$mn:00000DCC _text$mn        segment para public 'CODE' use32
.text$mn:00000DCC                 assume cs:_text$mn
.text$mn:00000DCC                 ;org 0DCCh
.text$mn:00000DCC ; COMDAT (pick any)
.text$mn:00000DCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DCC
.text$mn:00000DCC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DCC
.text$mn:00000DCC ; Attributes: bp-based frame
.text$mn:00000DCC
.text$mn:00000DCC ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00000DCC                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00000DCC ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00000DCC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00000DCC
.text$mn:00000DCC var_4           = dword ptr -4
.text$mn:00000DCC arg_0           = dword ptr  8
.text$mn:00000DCC
.text$mn:00000DCC                 push    ebp
.text$mn:00000DCD                 mov     ebp, esp
.text$mn:00000DCF                 push    ecx
.text$mn:00000DD0                 mov     [ebp+var_4], ecx
.text$mn:00000DD3                 mov     eax, [ebp+arg_0]
.text$mn:00000DD6                 push    eax
.text$mn:00000DD7                 mov     ecx, [ebp+var_4]
.text$mn:00000DDA                 push    ecx
.text$mn:00000DDB                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00000DE0                 add     esp, 8
.text$mn:00000DE3                 mov     esp, ebp
.text$mn:00000DE5                 pop     ebp
.text$mn:00000DE6                 retn    4
.text$mn:00000DE6 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00000DE6
.text$mn:00000DE6 ; ---------------------------------------------------------------------------
.text$mn:00000DE9                 align 4
.text$mn:00000DE9 _text$mn        ends
.text$mn:00000DE9
.text$mn:00000DEC ; ===========================================================================
.text$mn:00000DEC
.text$mn:00000DEC ; Segment type: Pure code
.text$mn:00000DEC ; Segment permissions: Read/Execute
.text$mn:00000DEC _text$mn        segment para public 'CODE' use32
.text$mn:00000DEC                 assume cs:_text$mn
.text$mn:00000DEC                 ;org 0DECh
.text$mn:00000DEC ; COMDAT (pick any)
.text$mn:00000DEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DEC
.text$mn:00000DEC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DEC
.text$mn:00000DEC ; Attributes: bp-based frame
.text$mn:00000DEC
.text$mn:00000DEC ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000DEC                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00000DEC ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00000DEC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00000DEC
.text$mn:00000DEC var_4           = dword ptr -4
.text$mn:00000DEC
.text$mn:00000DEC                 push    ebp
.text$mn:00000DED                 mov     ebp, esp
.text$mn:00000DEF                 push    ecx
.text$mn:00000DF0                 mov     [ebp+var_4], ecx
.text$mn:00000DF3                 mov     esp, ebp
.text$mn:00000DF5                 pop     ebp
.text$mn:00000DF6                 retn    4
.text$mn:00000DF6 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00000DF6
.text$mn:00000DF6 ; ---------------------------------------------------------------------------
.text$mn:00000DF9                 align 4
.text$mn:00000DF9 _text$mn        ends
.text$mn:00000DF9
.text$mn:00000DFC ; ===========================================================================
.text$mn:00000DFC
.text$mn:00000DFC ; Segment type: Pure code
.text$mn:00000DFC ; Segment permissions: Read/Execute
.text$mn:00000DFC _text$mn        segment para public 'CODE' use32
.text$mn:00000DFC                 assume cs:_text$mn
.text$mn:00000DFC                 ;org 0DFCh
.text$mn:00000DFC ; COMDAT (pick any)
.text$mn:00000DFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DFC
.text$mn:00000DFC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DFC
.text$mn:00000DFC ; Attributes: bp-based frame
.text$mn:00000DFC
.text$mn:00000DFC ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00000DFC                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00000DFC ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00000DFC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00000DFC
.text$mn:00000DFC arg_0           = dword ptr  8
.text$mn:00000DFC arg_4           = dword ptr  0Ch
.text$mn:00000DFC
.text$mn:00000DFC                 push    ebp
.text$mn:00000DFD                 mov     ebp, esp
.text$mn:00000DFF                 mov     eax, [ebp+arg_4]
.text$mn:00000E02                 push    eax
.text$mn:00000E03                 mov     ecx, [ebp+arg_0]
.text$mn:00000E06                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000E0B                 pop     ebp
.text$mn:00000E0C                 retn
.text$mn:00000E0C ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00000E0C
.text$mn:00000E0C ; ---------------------------------------------------------------------------
.text$mn:00000E0D                 align 10h
.text$mn:00000E0D _text$mn        ends
.text$mn:00000E0D
.text$mn:00000E10 ; ===========================================================================
.text$mn:00000E10
.text$mn:00000E10 ; Segment type: Pure code
.text$mn:00000E10 ; Segment permissions: Read/Execute
.text$mn:00000E10 _text$mn        segment para public 'CODE' use32
.text$mn:00000E10                 assume cs:_text$mn
.text$mn:00000E10                 ;org 0E10h
.text$mn:00000E10 ; COMDAT (pick any)
.text$mn:00000E10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E10
.text$mn:00000E10 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E10
.text$mn:00000E10 ; Attributes: bp-based frame
.text$mn:00000E10
.text$mn:00000E10 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00000E10                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00000E10 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00000E10                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00000E10
.text$mn:00000E10 var_4           = dword ptr -4
.text$mn:00000E10
.text$mn:00000E10                 push    ebp
.text$mn:00000E11                 mov     ebp, esp
.text$mn:00000E13                 push    ecx
.text$mn:00000E14                 mov     [ebp+var_4], ecx
.text$mn:00000E17                 mov     esp, ebp
.text$mn:00000E19                 pop     ebp
.text$mn:00000E1A                 retn    4
.text$mn:00000E1A ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00000E1A
.text$mn:00000E1A ; ---------------------------------------------------------------------------
.text$mn:00000E1D                 align 10h
.text$mn:00000E1D _text$mn        ends
.text$mn:00000E1D
.text$mn:00000E20 ; ===========================================================================
.text$mn:00000E20
.text$mn:00000E20 ; Segment type: Pure code
.text$mn:00000E20 ; Segment permissions: Read/Execute
.text$mn:00000E20 _text$mn        segment para public 'CODE' use32
.text$mn:00000E20                 assume cs:_text$mn
.text$mn:00000E20                 ;org 0E20h
.text$mn:00000E20 ; COMDAT (pick any)
.text$mn:00000E20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E20
.text$mn:00000E20 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E20
.text$mn:00000E20 ; Attributes: bp-based frame
.text$mn:00000E20
.text$mn:00000E20 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00000E20                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00000E20 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00000E20                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00000E20                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00000E20
.text$mn:00000E20 arg_0           = dword ptr  8
.text$mn:00000E20
.text$mn:00000E20                 push    ebp
.text$mn:00000E21                 mov     ebp, esp
.text$mn:00000E23                 mov     eax, [ebp+arg_0]
.text$mn:00000E26                 pop     ebp
.text$mn:00000E27                 retn
.text$mn:00000E27 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00000E27
.text$mn:00000E27 _text$mn        ends
.text$mn:00000E27
.text$mn:00000E28 ; ===========================================================================
.text$mn:00000E28
.text$mn:00000E28 ; Segment type: Pure code
.text$mn:00000E28 ; Segment permissions: Read/Execute
.text$mn:00000E28 _text$mn        segment para public 'CODE' use32
.text$mn:00000E28                 assume cs:_text$mn
.text$mn:00000E28                 ;org 0E28h
.text$mn:00000E28 ; COMDAT (pick any)
.text$mn:00000E28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E28
.text$mn:00000E28 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E28
.text$mn:00000E28 ; Attributes: bp-based frame
.text$mn:00000E28
.text$mn:00000E28 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00000E28                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00000E28 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00000E28                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00000E28
.text$mn:00000E28 arg_0           = dword ptr  8
.text$mn:00000E28
.text$mn:00000E28                 push    ebp
.text$mn:00000E29                 mov     ebp, esp
.text$mn:00000E2B                 mov     eax, [ebp+arg_0]
.text$mn:00000E2E                 pop     ebp
.text$mn:00000E2F                 retn
.text$mn:00000E2F ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00000E2F
.text$mn:00000E2F _text$mn        ends
.text$mn:00000E2F
.text$mn:00000E30 ; ===========================================================================
.text$mn:00000E30
.text$mn:00000E30 ; Segment type: Pure code
.text$mn:00000E30 ; Segment permissions: Read/Execute
.text$mn:00000E30 _text$mn        segment para public 'CODE' use32
.text$mn:00000E30                 assume cs:_text$mn
.text$mn:00000E30                 ;org 0E30h
.text$mn:00000E30 ; COMDAT (pick any)
.text$mn:00000E30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E30
.text$mn:00000E30 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E30
.text$mn:00000E30 ; Attributes: bp-based frame
.text$mn:00000E30
.text$mn:00000E30 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00000E30                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000E30 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00000E30                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00000E30
.text$mn:00000E30 var_10          = dword ptr -10h
.text$mn:00000E30 var_C           = dword ptr -0Ch
.text$mn:00000E30 var_4           = dword ptr -4
.text$mn:00000E30
.text$mn:00000E30                 push    ebp
.text$mn:00000E31                 mov     ebp, esp
.text$mn:00000E33                 push    0FFFFFFFFh
.text$mn:00000E35                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000E3A                 mov     eax, large fs:0
.text$mn:00000E40                 push    eax
.text$mn:00000E41                 push    ecx
.text$mn:00000E42                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000E47                 xor     eax, ebp
.text$mn:00000E49                 push    eax
.text$mn:00000E4A                 lea     eax, [ebp+var_C]
.text$mn:00000E4D                 mov     large fs:0, eax
.text$mn:00000E53                 mov     [ebp+var_10], ecx
.text$mn:00000E56                 mov     ecx, [ebp+var_10]
.text$mn:00000E59                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00000E5E                 mov     [ebp+var_4], 0
.text$mn:00000E65                 mov     ecx, [ebp+var_10]
.text$mn:00000E68                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000E6D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E74                 mov     eax, [ebp+var_10]
.text$mn:00000E77                 mov     ecx, [ebp+var_C]
.text$mn:00000E7A                 mov     large fs:0, ecx
.text$mn:00000E81                 pop     ecx
.text$mn:00000E82                 mov     esp, ebp
.text$mn:00000E84                 pop     ebp
.text$mn:00000E85                 retn    4
.text$mn:00000E85 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00000E85
.text$mn:00000E85 _text$mn        ends
.text$mn:00000E85
.text$x:00000E88 ; ===========================================================================
.text$x:00000E88
.text$x:00000E88 ; Segment type: Pure code
.text$x:00000E88 ; Segment permissions: Read/Execute
.text$x:00000E88 _text$x         segment para public 'CODE' use32
.text$x:00000E88                 assume cs:_text$x
.text$x:00000E88                 ;org 0E88h
.text$x:00000E88 ; COMDAT (pick associative to section at E30)
.text$x:00000E88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000E88
.text$x:00000E88 ; =============== S U B R O U T I N E =======================================
.text$x:00000E88
.text$x:00000E88
.text$x:00000E88 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00000E88                                         ; DATA XREF: .xdata$x:0000271Co
.text$x:00000E88                 mov     ecx, [ebp-10h]
.text$x:00000E8B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000E8B __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00000E8B
.text$x:00000E90
.text$x:00000E90 ; =============== S U B R O U T I N E =======================================
.text$x:00000E90
.text$x:00000E90
.text$x:00000E90 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00000E90                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00000E90
.text$x:00000E90 arg_4           = dword ptr  8
.text$x:00000E90
.text$x:00000E90                 mov     edx, [esp+arg_4]
.text$x:00000E94                 lea     eax, [edx+0Ch]
.text$x:00000E97                 mov     ecx, [edx-8]
.text$x:00000E9A                 xor     ecx, eax
.text$x:00000E9C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000EA1                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00000EA6                 jmp     ___CxxFrameHandler3
.text$x:00000EA6 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00000EA6
.text$x:00000EA6 ; ---------------------------------------------------------------------------
.text$x:00000EAB                 align 4
.text$x:00000EAB _text$x         ends
.text$x:00000EAB
.text$mn:00000EAC ; ===========================================================================
.text$mn:00000EAC
.text$mn:00000EAC ; Segment type: Pure code
.text$mn:00000EAC ; Segment permissions: Read/Execute
.text$mn:00000EAC _text$mn        segment para public 'CODE' use32
.text$mn:00000EAC                 assume cs:_text$mn
.text$mn:00000EAC                 ;org 0EACh
.text$mn:00000EAC ; COMDAT (pick any)
.text$mn:00000EAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000EAC
.text$mn:00000EAC ; =============== S U B R O U T I N E =======================================
.text$mn:00000EAC
.text$mn:00000EAC ; Attributes: bp-based frame
.text$mn:00000EAC
.text$mn:00000EAC ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000EAC                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000EAC ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000EAC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00000EAC
.text$mn:00000EAC var_10          = dword ptr -10h
.text$mn:00000EAC var_C           = dword ptr -0Ch
.text$mn:00000EAC var_4           = dword ptr -4
.text$mn:00000EAC
.text$mn:00000EAC                 push    ebp
.text$mn:00000EAD                 mov     ebp, esp
.text$mn:00000EAF                 push    0FFFFFFFFh
.text$mn:00000EB1                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000EB6                 mov     eax, large fs:0
.text$mn:00000EBC                 push    eax
.text$mn:00000EBD                 push    ecx
.text$mn:00000EBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000EC3                 xor     eax, ebp
.text$mn:00000EC5                 push    eax
.text$mn:00000EC6                 lea     eax, [ebp+var_C]
.text$mn:00000EC9                 mov     large fs:0, eax
.text$mn:00000ECF                 mov     [ebp+var_10], ecx
.text$mn:00000ED2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000ED5                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00000EDA                 mov     [ebp+var_4], 0
.text$mn:00000EE1                 mov     eax, [ebp+var_10]
.text$mn:00000EE4                 mov     dword ptr [eax+14h], 0
.text$mn:00000EEB                 mov     ecx, [ebp+var_10]
.text$mn:00000EEE                 mov     dword ptr [ecx+18h], 0
.text$mn:00000EF5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000EFC                 mov     eax, [ebp+var_10]
.text$mn:00000EFF                 mov     ecx, [ebp+var_C]
.text$mn:00000F02                 mov     large fs:0, ecx
.text$mn:00000F09                 pop     ecx
.text$mn:00000F0A                 mov     esp, ebp
.text$mn:00000F0C                 pop     ebp
.text$mn:00000F0D                 retn
.text$mn:00000F0D ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000F0D
.text$mn:00000F0D ; ---------------------------------------------------------------------------
.text$mn:00000F0E                 align 10h
.text$mn:00000F0E _text$mn        ends
.text$mn:00000F0E
.text$x:00000F10 ; ===========================================================================
.text$x:00000F10
.text$x:00000F10 ; Segment type: Pure code
.text$x:00000F10 ; Segment permissions: Read/Execute
.text$x:00000F10 _text$x         segment para public 'CODE' use32
.text$x:00000F10                 assume cs:_text$x
.text$x:00000F10                 ;org 0F10h
.text$x:00000F10 ; COMDAT (pick associative to section at EAC)
.text$x:00000F10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000F10
.text$x:00000F10 ; =============== S U B R O U T I N E =======================================
.text$x:00000F10
.text$x:00000F10
.text$x:00000F10 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000F10                                         ; DATA XREF: .xdata$x:000026C4o
.text$x:00000F10                 mov     ecx, [ebp-10h]  ; this
.text$x:00000F13                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000F13 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000F13
.text$x:00000F18
.text$x:00000F18 ; =============== S U B R O U T I N E =======================================
.text$x:00000F18
.text$x:00000F18
.text$x:00000F18 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000F18                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000F18
.text$x:00000F18 arg_4           = dword ptr  8
.text$x:00000F18
.text$x:00000F18                 mov     edx, [esp+arg_4]
.text$x:00000F1C                 lea     eax, [edx+0Ch]
.text$x:00000F1F                 mov     ecx, [edx-8]
.text$x:00000F22                 xor     ecx, eax
.text$x:00000F24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000F29                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000F2E                 jmp     ___CxxFrameHandler3
.text$x:00000F2E __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000F2E
.text$x:00000F2E ; ---------------------------------------------------------------------------
.text$x:00000F33                 align 4
.text$x:00000F33 _text$x         ends
.text$x:00000F33
.text$mn:00000F34 ; ===========================================================================
.text$mn:00000F34
.text$mn:00000F34 ; Segment type: Pure code
.text$mn:00000F34 ; Segment permissions: Read/Execute
.text$mn:00000F34 _text$mn        segment para public 'CODE' use32
.text$mn:00000F34                 assume cs:_text$mn
.text$mn:00000F34                 ;org 0F34h
.text$mn:00000F34 ; COMDAT (pick any)
.text$mn:00000F34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F34
.text$mn:00000F34 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F34
.text$mn:00000F34 ; Attributes: bp-based frame
.text$mn:00000F34
.text$mn:00000F34 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00000F34                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00000F34 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00000F34                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00000F34
.text$mn:00000F34 var_4           = dword ptr -4
.text$mn:00000F34
.text$mn:00000F34                 push    ebp
.text$mn:00000F35                 mov     ebp, esp
.text$mn:00000F37                 push    ecx
.text$mn:00000F38                 mov     [ebp+var_4], ecx
.text$mn:00000F3B                 mov     ecx, [ebp+var_4]
.text$mn:00000F3E                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000F43                 mov     eax, [ebp+var_4]
.text$mn:00000F46                 mov     esp, ebp
.text$mn:00000F48                 pop     ebp
.text$mn:00000F49                 retn
.text$mn:00000F49 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00000F49
.text$mn:00000F49 ; ---------------------------------------------------------------------------
.text$mn:00000F4A                 align 4
.text$mn:00000F4A _text$mn        ends
.text$mn:00000F4A
.text$mn:00000F4C ; ===========================================================================
.text$mn:00000F4C
.text$mn:00000F4C ; Segment type: Pure code
.text$mn:00000F4C ; Segment permissions: Read/Execute
.text$mn:00000F4C _text$mn        segment para public 'CODE' use32
.text$mn:00000F4C                 assume cs:_text$mn
.text$mn:00000F4C                 ;org 0F4Ch
.text$mn:00000F4C ; COMDAT (pick any)
.text$mn:00000F4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F4C
.text$mn:00000F4C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F4C
.text$mn:00000F4C ; Attributes: bp-based frame
.text$mn:00000F4C
.text$mn:00000F4C ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00000F4C                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00000F4C ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00000F4C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00000F4C
.text$mn:00000F4C var_4           = dword ptr -4
.text$mn:00000F4C
.text$mn:00000F4C                 push    ebp
.text$mn:00000F4D                 mov     ebp, esp
.text$mn:00000F4F                 push    ecx
.text$mn:00000F50                 mov     [ebp+var_4], ecx
.text$mn:00000F53                 mov     eax, [ebp+var_4]
.text$mn:00000F56                 mov     esp, ebp
.text$mn:00000F58                 pop     ebp
.text$mn:00000F59                 retn
.text$mn:00000F59 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00000F59
.text$mn:00000F59 ; ---------------------------------------------------------------------------
.text$mn:00000F5A                 align 4
.text$mn:00000F5A _text$mn        ends
.text$mn:00000F5A
.text$mn:00000F5C ; ===========================================================================
.text$mn:00000F5C
.text$mn:00000F5C ; Segment type: Pure code
.text$mn:00000F5C ; Segment permissions: Read/Execute
.text$mn:00000F5C _text$mn        segment para public 'CODE' use32
.text$mn:00000F5C                 assume cs:_text$mn
.text$mn:00000F5C                 ;org 0F5Ch
.text$mn:00000F5C ; COMDAT (pick any)
.text$mn:00000F5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F5C
.text$mn:00000F5C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F5C
.text$mn:00000F5C ; Attributes: bp-based frame
.text$mn:00000F5C
.text$mn:00000F5C ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00000F5C                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00000F5C ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00000F5C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00000F5C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:00000F5C
.text$mn:00000F5C var_4           = dword ptr -4
.text$mn:00000F5C
.text$mn:00000F5C                 push    ebp
.text$mn:00000F5D                 mov     ebp, esp
.text$mn:00000F5F                 push    ecx
.text$mn:00000F60                 mov     [ebp+var_4], ecx
.text$mn:00000F63                 mov     eax, [ebp+var_4]
.text$mn:00000F66                 mov     esp, ebp
.text$mn:00000F68                 pop     ebp
.text$mn:00000F69                 retn
.text$mn:00000F69 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00000F69
.text$mn:00000F69 ; ---------------------------------------------------------------------------
.text$mn:00000F6A                 align 4
.text$mn:00000F6A _text$mn        ends
.text$mn:00000F6A
.text$mn:00000F6C ; ===========================================================================
.text$mn:00000F6C
.text$mn:00000F6C ; Segment type: Pure code
.text$mn:00000F6C ; Segment permissions: Read/Execute
.text$mn:00000F6C _text$mn        segment para public 'CODE' use32
.text$mn:00000F6C                 assume cs:_text$mn
.text$mn:00000F6C                 ;org 0F6Ch
.text$mn:00000F6C ; COMDAT (pick any)
.text$mn:00000F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F6C
.text$mn:00000F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F6C
.text$mn:00000F6C ; Attributes: bp-based frame
.text$mn:00000F6C
.text$mn:00000F6C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00000F6C                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000F6C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00000F6C                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00000F6C                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00000F6C
.text$mn:00000F6C var_14          = dword ptr -14h
.text$mn:00000F6C var_D           = byte ptr -0Dh
.text$mn:00000F6C var_C           = dword ptr -0Ch
.text$mn:00000F6C var_4           = dword ptr -4
.text$mn:00000F6C Str             = dword ptr  8
.text$mn:00000F6C
.text$mn:00000F6C                 push    ebp
.text$mn:00000F6D                 mov     ebp, esp
.text$mn:00000F6F                 push    0FFFFFFFFh
.text$mn:00000F71                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000F76                 mov     eax, large fs:0
.text$mn:00000F7C                 push    eax
.text$mn:00000F7D                 sub     esp, 8
.text$mn:00000F80                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F85                 xor     eax, ebp
.text$mn:00000F87                 push    eax
.text$mn:00000F88                 lea     eax, [ebp+var_C]
.text$mn:00000F8B                 mov     large fs:0, eax
.text$mn:00000F91                 mov     [ebp+var_14], ecx
.text$mn:00000F94                 lea     ecx, [ebp+var_D]
.text$mn:00000F97                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000F9C                 push    eax
.text$mn:00000F9D                 mov     ecx, [ebp+var_14]
.text$mn:00000FA0                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00000FA5                 mov     [ebp+var_4], 0
.text$mn:00000FAC                 push    0               ; Size
.text$mn:00000FAE                 push    0               ; char
.text$mn:00000FB0                 mov     ecx, [ebp+var_14]
.text$mn:00000FB3                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000FB8                 mov     eax, [ebp+Str]
.text$mn:00000FBB                 push    eax             ; Str
.text$mn:00000FBC                 mov     ecx, [ebp+var_14]
.text$mn:00000FBF                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00000FC4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000FCB                 mov     eax, [ebp+var_14]
.text$mn:00000FCE                 mov     ecx, [ebp+var_C]
.text$mn:00000FD1                 mov     large fs:0, ecx
.text$mn:00000FD8                 pop     ecx
.text$mn:00000FD9                 mov     esp, ebp
.text$mn:00000FDB                 pop     ebp
.text$mn:00000FDC                 retn    4
.text$mn:00000FDC ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00000FDC
.text$mn:00000FDC ; ---------------------------------------------------------------------------
.text$mn:00000FDF                 align 10h
.text$mn:00000FDF _text$mn        ends
.text$mn:00000FDF
.text$x:00000FE0 ; ===========================================================================
.text$x:00000FE0
.text$x:00000FE0 ; Segment type: Pure code
.text$x:00000FE0 ; Segment permissions: Read/Execute
.text$x:00000FE0 _text$x         segment para public 'CODE' use32
.text$x:00000FE0                 assume cs:_text$x
.text$x:00000FE0                 ;org 0FE0h
.text$x:00000FE0 ; COMDAT (pick associative to section at F6C)
.text$x:00000FE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000FE0
.text$x:00000FE0 ; =============== S U B R O U T I N E =======================================
.text$x:00000FE0
.text$x:00000FE0
.text$x:00000FE0 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00000FE0                                         ; DATA XREF: .xdata$x:00002774o
.text$x:00000FE0                 mov     ecx, [ebp-14h]
.text$x:00000FE3                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000FE3 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00000FE3
.text$x:00000FE8
.text$x:00000FE8 ; =============== S U B R O U T I N E =======================================
.text$x:00000FE8
.text$x:00000FE8
.text$x:00000FE8 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00000FE8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00000FE8
.text$x:00000FE8 arg_4           = dword ptr  8
.text$x:00000FE8
.text$x:00000FE8                 mov     edx, [esp+arg_4]
.text$x:00000FEC                 lea     eax, [edx+0Ch]
.text$x:00000FEF                 mov     ecx, [edx-0Ch]
.text$x:00000FF2                 xor     ecx, eax
.text$x:00000FF4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000FF9                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00000FFE                 jmp     ___CxxFrameHandler3
.text$x:00000FFE __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00000FFE
.text$x:00000FFE ; ---------------------------------------------------------------------------
.text$x:00001003                 align 4
.text$x:00001003 _text$x         ends
.text$x:00001003
.text$mn:00001004 ; ===========================================================================
.text$mn:00001004
.text$mn:00001004 ; Segment type: Pure code
.text$mn:00001004 ; Segment permissions: Read/Execute
.text$mn:00001004 _text$mn        segment para public 'CODE' use32
.text$mn:00001004                 assume cs:_text$mn
.text$mn:00001004                 ;org 1004h
.text$mn:00001004 ; COMDAT (pick any)
.text$mn:00001004                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001004
.text$mn:00001004 ; =============== S U B R O U T I N E =======================================
.text$mn:00001004
.text$mn:00001004 ; Attributes: bp-based frame
.text$mn:00001004
.text$mn:00001004 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001004                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00001004 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00001004                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00001004
.text$mn:00001004 var_4           = dword ptr -4
.text$mn:00001004
.text$mn:00001004                 push    ebp
.text$mn:00001005                 mov     ebp, esp
.text$mn:00001007                 push    ecx
.text$mn:00001008                 mov     [ebp+var_4], ecx
.text$mn:0000100B                 mov     eax, [ebp+var_4]
.text$mn:0000100E                 mov     dword ptr [eax], 0
.text$mn:00001014                 mov     eax, [ebp+var_4]
.text$mn:00001017                 mov     esp, ebp
.text$mn:00001019                 pop     ebp
.text$mn:0000101A                 retn
.text$mn:0000101A ??0_Container_base12@std@@QAE@XZ endp
.text$mn:0000101A
.text$mn:0000101A ; ---------------------------------------------------------------------------
.text$mn:0000101B                 align 4
.text$mn:0000101B _text$mn        ends
.text$mn:0000101B
.text$mn:0000101C ; ===========================================================================
.text$mn:0000101C
.text$mn:0000101C ; Segment type: Pure code
.text$mn:0000101C ; Segment permissions: Read/Execute
.text$mn:0000101C _text$mn        segment para public 'CODE' use32
.text$mn:0000101C                 assume cs:_text$mn
.text$mn:0000101C                 ;org 101Ch
.text$mn:0000101C ; COMDAT (pick any)
.text$mn:0000101C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000101C
.text$mn:0000101C ; =============== S U B R O U T I N E =======================================
.text$mn:0000101C
.text$mn:0000101C ; Attributes: bp-based frame
.text$mn:0000101C
.text$mn:0000101C ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:0000101C                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:0000101C ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:0000101C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:0000101C
.text$mn:0000101C var_4           = dword ptr -4
.text$mn:0000101C
.text$mn:0000101C                 push    ebp
.text$mn:0000101D                 mov     ebp, esp
.text$mn:0000101F                 push    ecx
.text$mn:00001020                 mov     [ebp+var_4], ecx
.text$mn:00001023                 mov     eax, [ebp+var_4]
.text$mn:00001026                 mov     dword ptr [eax], 0
.text$mn:0000102C                 mov     ecx, [ebp+var_4]
.text$mn:0000102F                 mov     dword ptr [ecx+4], 0
.text$mn:00001036                 mov     eax, [ebp+var_4]
.text$mn:00001039                 mov     esp, ebp
.text$mn:0000103B                 pop     ebp
.text$mn:0000103C                 retn
.text$mn:0000103C ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:0000103C
.text$mn:0000103C ; ---------------------------------------------------------------------------
.text$mn:0000103D                 align 10h
.text$mn:0000103D _text$mn        ends
.text$mn:0000103D
.text$mn:00001040 ; ===========================================================================
.text$mn:00001040
.text$mn:00001040 ; Segment type: Pure code
.text$mn:00001040 ; Segment permissions: Read/Execute
.text$mn:00001040 _text$mn        segment para public 'CODE' use32
.text$mn:00001040                 assume cs:_text$mn
.text$mn:00001040                 ;org 1040h
.text$mn:00001040 ; COMDAT (pick any)
.text$mn:00001040                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001040
.text$mn:00001040 ; =============== S U B R O U T I N E =======================================
.text$mn:00001040
.text$mn:00001040 ; Attributes: bp-based frame
.text$mn:00001040
.text$mn:00001040 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001040                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00001040 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00001040                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00001040                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00001040
.text$mn:00001040 var_10          = dword ptr -10h
.text$mn:00001040 var_C           = dword ptr -0Ch
.text$mn:00001040 var_4           = dword ptr -4
.text$mn:00001040
.text$mn:00001040                 push    ebp
.text$mn:00001041                 mov     ebp, esp
.text$mn:00001043                 push    0FFFFFFFFh
.text$mn:00001045                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000104A                 mov     eax, large fs:0
.text$mn:00001050                 push    eax
.text$mn:00001051                 push    ecx
.text$mn:00001052                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001057                 xor     eax, ebp
.text$mn:00001059                 push    eax
.text$mn:0000105A                 lea     eax, [ebp+var_C]
.text$mn:0000105D                 mov     large fs:0, eax
.text$mn:00001063                 mov     [ebp+var_10], ecx
.text$mn:00001066                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001069                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:0000106E                 mov     [ebp+var_4], 0
.text$mn:00001075                 mov     eax, [ebp+var_10]
.text$mn:00001078                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:0000107E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001085                 mov     eax, [ebp+var_10]
.text$mn:00001088                 mov     ecx, [ebp+var_C]
.text$mn:0000108B                 mov     large fs:0, ecx
.text$mn:00001092                 pop     ecx
.text$mn:00001093                 mov     esp, ebp
.text$mn:00001095                 pop     ebp
.text$mn:00001096                 retn
.text$mn:00001096 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00001096
.text$mn:00001096 ; ---------------------------------------------------------------------------
.text$mn:00001097                 align 4
.text$mn:00001097 _text$mn        ends
.text$mn:00001097
.text$x:00001098 ; ===========================================================================
.text$x:00001098
.text$x:00001098 ; Segment type: Pure code
.text$x:00001098 ; Segment permissions: Read/Execute
.text$x:00001098 _text$x         segment para public 'CODE' use32
.text$x:00001098                 assume cs:_text$x
.text$x:00001098                 ;org 1098h
.text$x:00001098 ; COMDAT (pick associative to section at 1040)
.text$x:00001098                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001098
.text$x:00001098 ; =============== S U B R O U T I N E =======================================
.text$x:00001098
.text$x:00001098
.text$x:00001098 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00001098                                         ; DATA XREF: .xdata$x:000028DCo
.text$x:00001098                 mov     ecx, [ebp-10h]  ; this
.text$x:0000109B                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000109B __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:0000109B
.text$x:000010A0
.text$x:000010A0 ; =============== S U B R O U T I N E =======================================
.text$x:000010A0
.text$x:000010A0
.text$x:000010A0 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000010A0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000010A0
.text$x:000010A0 arg_4           = dword ptr  8
.text$x:000010A0
.text$x:000010A0                 mov     edx, [esp+arg_4]
.text$x:000010A4                 lea     eax, [edx+0Ch]
.text$x:000010A7                 mov     ecx, [edx-8]
.text$x:000010AA                 xor     ecx, eax
.text$x:000010AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000010B1                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000010B6                 jmp     ___CxxFrameHandler3
.text$x:000010B6 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000010B6
.text$x:000010B6 ; ---------------------------------------------------------------------------
.text$x:000010BB                 align 4
.text$x:000010BB _text$x         ends
.text$x:000010BB
.text$mn:000010BC ; ===========================================================================
.text$mn:000010BC
.text$mn:000010BC ; Segment type: Pure code
.text$mn:000010BC ; Segment permissions: Read/Execute
.text$mn:000010BC _text$mn        segment para public 'CODE' use32
.text$mn:000010BC                 assume cs:_text$mn
.text$mn:000010BC                 ;org 10BCh
.text$mn:000010BC ; COMDAT (pick any)
.text$mn:000010BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010BC
.text$mn:000010BC ; =============== S U B R O U T I N E =======================================
.text$mn:000010BC
.text$mn:000010BC ; Attributes: bp-based frame
.text$mn:000010BC
.text$mn:000010BC ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000010BC                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000010BC ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:000010BC                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000010BC
.text$mn:000010BC var_10          = dword ptr -10h
.text$mn:000010BC var_C           = dword ptr -0Ch
.text$mn:000010BC var_4           = dword ptr -4
.text$mn:000010BC
.text$mn:000010BC                 push    ebp
.text$mn:000010BD                 mov     ebp, esp
.text$mn:000010BF                 push    0FFFFFFFFh
.text$mn:000010C1                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000010C6                 mov     eax, large fs:0
.text$mn:000010CC                 push    eax
.text$mn:000010CD                 push    ecx
.text$mn:000010CE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000010D3                 xor     eax, ebp
.text$mn:000010D5                 push    eax
.text$mn:000010D6                 lea     eax, [ebp+var_C]
.text$mn:000010D9                 mov     large fs:0, eax
.text$mn:000010DF                 mov     [ebp+var_10], ecx
.text$mn:000010E2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000010E5                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000010EA                 mov     [ebp+var_4], 0
.text$mn:000010F1                 mov     eax, [ebp+var_10]
.text$mn:000010F4                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:000010FA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001101                 mov     eax, [ebp+var_10]
.text$mn:00001104                 mov     ecx, [ebp+var_C]
.text$mn:00001107                 mov     large fs:0, ecx
.text$mn:0000110E                 pop     ecx
.text$mn:0000110F                 mov     esp, ebp
.text$mn:00001111                 pop     ebp
.text$mn:00001112                 retn
.text$mn:00001112 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00001112
.text$mn:00001112 ; ---------------------------------------------------------------------------
.text$mn:00001113                 align 4
.text$mn:00001113 _text$mn        ends
.text$mn:00001113
.text$x:00001114 ; ===========================================================================
.text$x:00001114
.text$x:00001114 ; Segment type: Pure code
.text$x:00001114 ; Segment permissions: Read/Execute
.text$x:00001114 _text$x         segment para public 'CODE' use32
.text$x:00001114                 assume cs:_text$x
.text$x:00001114                 ;org 1114h
.text$x:00001114 ; COMDAT (pick associative to section at 10BC)
.text$x:00001114                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001114
.text$x:00001114 ; =============== S U B R O U T I N E =======================================
.text$x:00001114
.text$x:00001114
.text$x:00001114 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00001114                                         ; DATA XREF: .xdata$x:00002960o
.text$x:00001114                 mov     ecx, [ebp-10h]  ; this
.text$x:00001117                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001117 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00001117
.text$x:0000111C
.text$x:0000111C ; =============== S U B R O U T I N E =======================================
.text$x:0000111C
.text$x:0000111C
.text$x:0000111C __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:0000111C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:0000111C
.text$x:0000111C arg_4           = dword ptr  8
.text$x:0000111C
.text$x:0000111C                 mov     edx, [esp+arg_4]
.text$x:00001120                 lea     eax, [edx+0Ch]
.text$x:00001123                 mov     ecx, [edx-8]
.text$x:00001126                 xor     ecx, eax
.text$x:00001128                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000112D                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00001132                 jmp     ___CxxFrameHandler3
.text$x:00001132 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00001132
.text$x:00001132 ; ---------------------------------------------------------------------------
.text$x:00001137                 align 4
.text$x:00001137 _text$x         ends
.text$x:00001137
.text$mn:00001138 ; ===========================================================================
.text$mn:00001138
.text$mn:00001138 ; Segment type: Pure code
.text$mn:00001138 ; Segment permissions: Read/Execute
.text$mn:00001138 _text$mn        segment para public 'CODE' use32
.text$mn:00001138                 assume cs:_text$mn
.text$mn:00001138                 ;org 1138h
.text$mn:00001138 ; COMDAT (pick any)
.text$mn:00001138                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001138
.text$mn:00001138 ; =============== S U B R O U T I N E =======================================
.text$mn:00001138
.text$mn:00001138 ; Attributes: bp-based frame
.text$mn:00001138
.text$mn:00001138 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001138                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00001138 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00001138                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001138
.text$mn:00001138 var_10          = dword ptr -10h
.text$mn:00001138 var_C           = dword ptr -0Ch
.text$mn:00001138 var_4           = dword ptr -4
.text$mn:00001138
.text$mn:00001138                 push    ebp
.text$mn:00001139                 mov     ebp, esp
.text$mn:0000113B                 push    0FFFFFFFFh
.text$mn:0000113D                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00001142                 mov     eax, large fs:0
.text$mn:00001148                 push    eax
.text$mn:00001149                 push    ecx
.text$mn:0000114A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000114F                 xor     eax, ebp
.text$mn:00001151                 push    eax
.text$mn:00001152                 lea     eax, [ebp+var_C]
.text$mn:00001155                 mov     large fs:0, eax
.text$mn:0000115B                 mov     [ebp+var_10], ecx
.text$mn:0000115E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001161                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00001166                 mov     [ebp+var_4], 0
.text$mn:0000116D                 mov     eax, [ebp+var_10]
.text$mn:00001170                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00001176                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000117D                 mov     eax, [ebp+var_10]
.text$mn:00001180                 mov     ecx, [ebp+var_C]
.text$mn:00001183                 mov     large fs:0, ecx
.text$mn:0000118A                 pop     ecx
.text$mn:0000118B                 mov     esp, ebp
.text$mn:0000118D                 pop     ebp
.text$mn:0000118E                 retn
.text$mn:0000118E ??0_System_error_category@std@@QAE@XZ endp
.text$mn:0000118E
.text$mn:0000118E ; ---------------------------------------------------------------------------
.text$mn:0000118F                 align 10h
.text$mn:0000118F _text$mn        ends
.text$mn:0000118F
.text$x:00001190 ; ===========================================================================
.text$x:00001190
.text$x:00001190 ; Segment type: Pure code
.text$x:00001190 ; Segment permissions: Read/Execute
.text$x:00001190 _text$x         segment para public 'CODE' use32
.text$x:00001190                 assume cs:_text$x
.text$x:00001190                 ;org 1190h
.text$x:00001190 ; COMDAT (pick associative to section at 1138)
.text$x:00001190                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001190
.text$x:00001190 ; =============== S U B R O U T I N E =======================================
.text$x:00001190
.text$x:00001190
.text$x:00001190 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00001190                                         ; DATA XREF: .xdata$x:000029E4o
.text$x:00001190                 mov     ecx, [ebp-10h]  ; this
.text$x:00001193                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001193 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00001193
.text$x:00001198
.text$x:00001198 ; =============== S U B R O U T I N E =======================================
.text$x:00001198
.text$x:00001198
.text$x:00001198 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00001198                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00001198
.text$x:00001198 arg_4           = dword ptr  8
.text$x:00001198
.text$x:00001198                 mov     edx, [esp+arg_4]
.text$x:0000119C                 lea     eax, [edx+0Ch]
.text$x:0000119F                 mov     ecx, [edx-8]
.text$x:000011A2                 xor     ecx, eax
.text$x:000011A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000011A9                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:000011AE                 jmp     ___CxxFrameHandler3
.text$x:000011AE __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:000011AE
.text$x:000011AE ; ---------------------------------------------------------------------------
.text$x:000011B3                 align 4
.text$x:000011B3 _text$x         ends
.text$x:000011B3
.text$mn:000011B4 ; ===========================================================================
.text$mn:000011B4
.text$mn:000011B4 ; Segment type: Pure code
.text$mn:000011B4 ; Segment permissions: Read/Execute
.text$mn:000011B4 _text$mn        segment para public 'CODE' use32
.text$mn:000011B4                 assume cs:_text$mn
.text$mn:000011B4                 ;org 11B4h
.text$mn:000011B4 ; COMDAT (pick any)
.text$mn:000011B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011B4
.text$mn:000011B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000011B4
.text$mn:000011B4 ; Attributes: bp-based frame
.text$mn:000011B4
.text$mn:000011B4 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000011B4                 public ??0error_category@std@@QAE@XZ
.text$mn:000011B4 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000011B4
.text$mn:000011B4 var_4           = dword ptr -4
.text$mn:000011B4
.text$mn:000011B4                 push    ebp
.text$mn:000011B5                 mov     ebp, esp
.text$mn:000011B7                 push    ecx
.text$mn:000011B8                 mov     [ebp+var_4], ecx
.text$mn:000011BB                 mov     eax, [ebp+var_4]
.text$mn:000011BE                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000011C4                 mov     eax, [ebp+var_4]
.text$mn:000011C7                 mov     esp, ebp
.text$mn:000011C9                 pop     ebp
.text$mn:000011CA                 retn
.text$mn:000011CA ??0error_category@std@@QAE@XZ endp
.text$mn:000011CA
.text$mn:000011CA ; ---------------------------------------------------------------------------
.text$mn:000011CB                 align 4
.text$mn:000011CB _text$mn        ends
.text$mn:000011CB
.text$mn:000011CC ; ===========================================================================
.text$mn:000011CC
.text$mn:000011CC ; Segment type: Pure code
.text$mn:000011CC ; Segment permissions: Read/Execute
.text$mn:000011CC _text$mn        segment para public 'CODE' use32
.text$mn:000011CC                 assume cs:_text$mn
.text$mn:000011CC                 ;org 11CCh
.text$mn:000011CC ; COMDAT (pick any)
.text$mn:000011CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011CC
.text$mn:000011CC ; =============== S U B R O U T I N E =======================================
.text$mn:000011CC
.text$mn:000011CC ; Attributes: bp-based frame
.text$mn:000011CC
.text$mn:000011CC ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:000011CC                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:000011CC ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:000011CC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:000011CC                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:000011CC
.text$mn:000011CC var_4           = dword ptr -4
.text$mn:000011CC arg_0           = dword ptr  8
.text$mn:000011CC arg_4           = dword ptr  0Ch
.text$mn:000011CC
.text$mn:000011CC                 push    ebp
.text$mn:000011CD                 mov     ebp, esp
.text$mn:000011CF                 push    ecx
.text$mn:000011D0                 mov     [ebp+var_4], ecx
.text$mn:000011D3                 mov     eax, [ebp+var_4]
.text$mn:000011D6                 mov     ecx, [ebp+arg_0]
.text$mn:000011D9                 mov     [eax], ecx
.text$mn:000011DB                 mov     edx, [ebp+var_4]
.text$mn:000011DE                 mov     eax, [ebp+arg_4]
.text$mn:000011E1                 mov     [edx+4], eax
.text$mn:000011E4                 mov     eax, [ebp+var_4]
.text$mn:000011E7                 mov     esp, ebp
.text$mn:000011E9                 pop     ebp
.text$mn:000011EA                 retn    8
.text$mn:000011EA ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:000011EA
.text$mn:000011EA ; ---------------------------------------------------------------------------
.text$mn:000011ED                 align 10h
.text$mn:000011ED _text$mn        ends
.text$mn:000011ED
.text$mn:000011F0 ; ===========================================================================
.text$mn:000011F0
.text$mn:000011F0 ; Segment type: Pure code
.text$mn:000011F0 ; Segment permissions: Read/Execute
.text$mn:000011F0 _text$mn        segment para public 'CODE' use32
.text$mn:000011F0                 assume cs:_text$mn
.text$mn:000011F0                 ;org 11F0h
.text$mn:000011F0 ; COMDAT (pick any)
.text$mn:000011F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011F0
.text$mn:000011F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000011F0
.text$mn:000011F0 ; Attributes: bp-based frame
.text$mn:000011F0
.text$mn:000011F0 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:000011F0                 public ??0id@locale@std@@QAE@I@Z
.text$mn:000011F0 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:000011F0                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:000011F0
.text$mn:000011F0 var_4           = dword ptr -4
.text$mn:000011F0 arg_0           = dword ptr  8
.text$mn:000011F0
.text$mn:000011F0                 push    ebp
.text$mn:000011F1                 mov     ebp, esp
.text$mn:000011F3                 push    ecx
.text$mn:000011F4                 mov     [ebp+var_4], ecx
.text$mn:000011F7                 mov     eax, [ebp+var_4]
.text$mn:000011FA                 mov     ecx, [ebp+arg_0]
.text$mn:000011FD                 mov     [eax], ecx
.text$mn:000011FF                 mov     eax, [ebp+var_4]
.text$mn:00001202                 mov     esp, ebp
.text$mn:00001204                 pop     ebp
.text$mn:00001205                 retn    4
.text$mn:00001205 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00001205
.text$mn:00001205 _text$mn        ends
.text$mn:00001205
.text$mn:00001208 ; ===========================================================================
.text$mn:00001208
.text$mn:00001208 ; Segment type: Pure code
.text$mn:00001208 ; Segment permissions: Read/Execute
.text$mn:00001208 _text$mn        segment para public 'CODE' use32
.text$mn:00001208                 assume cs:_text$mn
.text$mn:00001208                 ;org 1208h
.text$mn:00001208 ; COMDAT (pick any)
.text$mn:00001208                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001208
.text$mn:00001208 ; =============== S U B R O U T I N E =======================================
.text$mn:00001208
.text$mn:00001208 ; Attributes: bp-based frame
.text$mn:00001208
.text$mn:00001208 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const struct std::runtime_error *)
.text$mn:00001208                 public ??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00001208 ??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$mn:00001208                                         ; DATA XREF: .xdata$x:00002B20o
.text$mn:00001208
.text$mn:00001208 var_10          = dword ptr -10h
.text$mn:00001208 var_C           = dword ptr -0Ch
.text$mn:00001208 var_4           = dword ptr -4
.text$mn:00001208 arg_0           = dword ptr  8
.text$mn:00001208
.text$mn:00001208                 push    ebp
.text$mn:00001209                 mov     ebp, esp
.text$mn:0000120B                 push    0FFFFFFFFh
.text$mn:0000120D                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00001212                 mov     eax, large fs:0
.text$mn:00001218                 push    eax
.text$mn:00001219                 push    ecx
.text$mn:0000121A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000121F                 xor     eax, ebp
.text$mn:00001221                 push    eax
.text$mn:00001222                 lea     eax, [ebp+var_C]
.text$mn:00001225                 mov     large fs:0, eax
.text$mn:0000122B                 mov     [ebp+var_10], ecx
.text$mn:0000122E                 mov     eax, [ebp+arg_0]
.text$mn:00001231                 push    eax             ; struct std::exception *
.text$mn:00001232                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001235                 call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.text$mn:0000123A                 mov     [ebp+var_4], 0
.text$mn:00001241                 mov     ecx, [ebp+var_10]
.text$mn:00001244                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:0000124A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001251                 mov     eax, [ebp+var_10]
.text$mn:00001254                 mov     ecx, [ebp+var_C]
.text$mn:00001257                 mov     large fs:0, ecx
.text$mn:0000125E                 pop     ecx
.text$mn:0000125F                 mov     esp, ebp
.text$mn:00001261                 pop     ebp
.text$mn:00001262                 retn    4
.text$mn:00001262 ??0runtime_error@std@@QAE@ABV01@@Z endp
.text$mn:00001262
.text$mn:00001262 ; ---------------------------------------------------------------------------
.text$mn:00001265                 align 4
.text$mn:00001265 _text$mn        ends
.text$mn:00001265
.text$x:00001268 ; ===========================================================================
.text$x:00001268
.text$x:00001268 ; Segment type: Pure code
.text$x:00001268 ; Segment permissions: Read/Execute
.text$x:00001268 _text$x         segment para public 'CODE' use32
.text$x:00001268                 assume cs:_text$x
.text$x:00001268                 ;org 1268h
.text$x:00001268 ; COMDAT (pick associative to section at 1208)
.text$x:00001268                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001268
.text$x:00001268 ; =============== S U B R O U T I N E =======================================
.text$x:00001268
.text$x:00001268
.text$x:00001268 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:00001268                                         ; DATA XREF: .xdata$x:000028B0o
.text$x:00001268                 mov     ecx, [ebp-10h]  ; this
.text$x:0000126B                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:0000126B __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 endp
.text$x:0000126B
.text$x:00001270
.text$x:00001270 ; =============== S U B R O U T I N E =======================================
.text$x:00001270
.text$x:00001270
.text$x:00001270 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$x:00001270                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+5o
.text$x:00001270
.text$x:00001270 arg_4           = dword ptr  8
.text$x:00001270
.text$x:00001270                 mov     edx, [esp+arg_4]
.text$x:00001274                 lea     eax, [edx+0Ch]
.text$x:00001277                 mov     ecx, [edx-8]
.text$x:0000127A                 xor     ecx, eax
.text$x:0000127C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001281                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
.text$x:00001286                 jmp     ___CxxFrameHandler3
.text$x:00001286 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z endp
.text$x:00001286
.text$x:00001286 ; ---------------------------------------------------------------------------
.text$x:0000128B                 align 4
.text$x:0000128B _text$x         ends
.text$x:0000128B
.text$mn:0000128C ; ===========================================================================
.text$mn:0000128C
.text$mn:0000128C ; Segment type: Pure code
.text$mn:0000128C ; Segment permissions: Read/Execute
.text$mn:0000128C _text$mn        segment para public 'CODE' use32
.text$mn:0000128C                 assume cs:_text$mn
.text$mn:0000128C                 ;org 128Ch
.text$mn:0000128C ; COMDAT (pick any)
.text$mn:0000128C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000128C
.text$mn:0000128C ; =============== S U B R O U T I N E =======================================
.text$mn:0000128C
.text$mn:0000128C ; Attributes: bp-based frame
.text$mn:0000128C
.text$mn:0000128C ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const char *)
.text$mn:0000128C                 public ??0runtime_error@std@@QAE@PBD@Z
.text$mn:0000128C ??0runtime_error@std@@QAE@PBD@Z proc near
.text$mn:0000128C                                         ; CODE XREF: TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+94p
.text$mn:0000128C
.text$mn:0000128C var_10          = dword ptr -10h
.text$mn:0000128C var_C           = dword ptr -0Ch
.text$mn:0000128C var_4           = dword ptr -4
.text$mn:0000128C arg_0           = dword ptr  8
.text$mn:0000128C
.text$mn:0000128C                 push    ebp
.text$mn:0000128D                 mov     ebp, esp
.text$mn:0000128F                 push    0FFFFFFFFh
.text$mn:00001291                 push    offset __ehhandler$??0runtime_error@std@@QAE@PBD@Z
.text$mn:00001296                 mov     eax, large fs:0
.text$mn:0000129C                 push    eax
.text$mn:0000129D                 push    ecx
.text$mn:0000129E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000012A3                 xor     eax, ebp
.text$mn:000012A5                 push    eax
.text$mn:000012A6                 lea     eax, [ebp+var_C]
.text$mn:000012A9                 mov     large fs:0, eax
.text$mn:000012AF                 mov     [ebp+var_10], ecx
.text$mn:000012B2                 lea     eax, [ebp+arg_0]
.text$mn:000012B5                 push    eax             ; char **
.text$mn:000012B6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000012B9                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:000012BE                 mov     [ebp+var_4], 0
.text$mn:000012C5                 mov     ecx, [ebp+var_10]
.text$mn:000012C8                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:000012CE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000012D5                 mov     eax, [ebp+var_10]
.text$mn:000012D8                 mov     ecx, [ebp+var_C]
.text$mn:000012DB                 mov     large fs:0, ecx
.text$mn:000012E2                 pop     ecx
.text$mn:000012E3                 mov     esp, ebp
.text$mn:000012E5                 pop     ebp
.text$mn:000012E6                 retn    4
.text$mn:000012E6 ??0runtime_error@std@@QAE@PBD@Z endp
.text$mn:000012E6
.text$mn:000012E6 ; ---------------------------------------------------------------------------
.text$mn:000012E9                 align 4
.text$mn:000012E9 _text$mn        ends
.text$mn:000012E9
.text$x:000012EC ; ===========================================================================
.text$x:000012EC
.text$x:000012EC ; Segment type: Pure code
.text$x:000012EC ; Segment permissions: Read/Execute
.text$x:000012EC _text$x         segment para public 'CODE' use32
.text$x:000012EC                 assume cs:_text$x
.text$x:000012EC                 ;org 12ECh
.text$x:000012EC ; COMDAT (pick associative to section at 128C)
.text$x:000012EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000012EC
.text$x:000012EC ; =============== S U B R O U T I N E =======================================
.text$x:000012EC
.text$x:000012EC
.text$x:000012EC __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 proc near
.text$x:000012EC                                         ; DATA XREF: .xdata$x:00002858o
.text$x:000012EC                 mov     ecx, [ebp-10h]  ; this
.text$x:000012EF                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:000012EF __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 endp
.text$x:000012EF
.text$x:000012F4
.text$x:000012F4 ; =============== S U B R O U T I N E =======================================
.text$x:000012F4
.text$x:000012F4
.text$x:000012F4 __ehhandler$??0runtime_error@std@@QAE@PBD@Z proc near
.text$x:000012F4                                         ; DATA XREF: std::runtime_error::runtime_error(char const *)+5o
.text$x:000012F4
.text$x:000012F4 arg_4           = dword ptr  8
.text$x:000012F4
.text$x:000012F4                 mov     edx, [esp+arg_4]
.text$x:000012F8                 lea     eax, [edx+0Ch]
.text$x:000012FB                 mov     ecx, [edx-8]
.text$x:000012FE                 xor     ecx, eax
.text$x:00001300                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001305                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z
.text$x:0000130A                 jmp     ___CxxFrameHandler3
.text$x:0000130A __ehhandler$??0runtime_error@std@@QAE@PBD@Z endp
.text$x:0000130A
.text$x:0000130A ; ---------------------------------------------------------------------------
.text$x:0000130F                 align 10h
.text$x:0000130F _text$x         ends
.text$x:0000130F
.text$mn:00001310 ; ===========================================================================
.text$mn:00001310
.text$mn:00001310 ; Segment type: Pure code
.text$mn:00001310 ; Segment permissions: Read/Execute
.text$mn:00001310 _text$mn        segment para public 'CODE' use32
.text$mn:00001310                 assume cs:_text$mn
.text$mn:00001310                 ;org 1310h
.text$mn:00001310 ; COMDAT (pick any)
.text$mn:00001310                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001310
.text$mn:00001310 ; =============== S U B R O U T I N E =======================================
.text$mn:00001310
.text$mn:00001310 ; Attributes: bp-based frame
.text$mn:00001310
.text$mn:00001310 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00001310                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001310 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00001310                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00001310                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00001310
.text$mn:00001310 var_10          = dword ptr -10h
.text$mn:00001310 var_C           = dword ptr -0Ch
.text$mn:00001310 var_4           = dword ptr -4
.text$mn:00001310
.text$mn:00001310                 push    ebp
.text$mn:00001311                 mov     ebp, esp
.text$mn:00001313                 push    0FFFFFFFFh
.text$mn:00001315                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000131A                 mov     eax, large fs:0
.text$mn:00001320                 push    eax
.text$mn:00001321                 push    ecx
.text$mn:00001322                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001327                 xor     eax, ebp
.text$mn:00001329                 push    eax
.text$mn:0000132A                 lea     eax, [ebp+var_C]
.text$mn:0000132D                 mov     large fs:0, eax
.text$mn:00001333                 mov     [ebp+var_10], ecx
.text$mn:00001336                 mov     [ebp+var_4], 0
.text$mn:0000133D                 mov     ecx, [ebp+var_10]
.text$mn:00001340                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001345                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000134C                 mov     ecx, [ebp+var_10]
.text$mn:0000134F                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00001354                 mov     ecx, [ebp+var_C]
.text$mn:00001357                 mov     large fs:0, ecx
.text$mn:0000135E                 pop     ecx
.text$mn:0000135F                 mov     esp, ebp
.text$mn:00001361                 pop     ebp
.text$mn:00001362                 retn
.text$mn:00001362 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00001362
.text$mn:00001362 ; ---------------------------------------------------------------------------
.text$mn:00001363                 align 4
.text$mn:00001363 _text$mn        ends
.text$mn:00001363
.text$x:00001364 ; ===========================================================================
.text$x:00001364
.text$x:00001364 ; Segment type: Pure code
.text$x:00001364 ; Segment permissions: Read/Execute
.text$x:00001364 _text$x         segment para public 'CODE' use32
.text$x:00001364                 assume cs:_text$x
.text$x:00001364                 ;org 1364h
.text$x:00001364 ; COMDAT (pick associative to section at 1310)
.text$x:00001364                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001364
.text$x:00001364 ; =============== S U B R O U T I N E =======================================
.text$x:00001364
.text$x:00001364
.text$x:00001364 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00001364                                         ; DATA XREF: .xdata$x:00002748o
.text$x:00001364                 mov     ecx, [ebp-10h]
.text$x:00001367                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00001367 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00001367
.text$x:0000136C
.text$x:0000136C ; =============== S U B R O U T I N E =======================================
.text$x:0000136C
.text$x:0000136C
.text$x:0000136C __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000136C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:0000136C
.text$x:0000136C arg_4           = dword ptr  8
.text$x:0000136C
.text$x:0000136C                 mov     edx, [esp+arg_4]
.text$x:00001370                 lea     eax, [edx+0Ch]
.text$x:00001373                 mov     ecx, [edx-8]
.text$x:00001376                 xor     ecx, eax
.text$x:00001378                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000137D                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00001382                 jmp     ___CxxFrameHandler3
.text$x:00001382 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00001382
.text$x:00001382 ; ---------------------------------------------------------------------------
.text$x:00001387                 align 4
.text$x:00001387 _text$x         ends
.text$x:00001387
.text$mn:00001388 ; ===========================================================================
.text$mn:00001388
.text$mn:00001388 ; Segment type: Pure code
.text$mn:00001388 ; Segment permissions: Read/Execute
.text$mn:00001388 _text$mn        segment para public 'CODE' use32
.text$mn:00001388                 assume cs:_text$mn
.text$mn:00001388                 ;org 1388h
.text$mn:00001388 ; COMDAT (pick any)
.text$mn:00001388                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001388
.text$mn:00001388 ; =============== S U B R O U T I N E =======================================
.text$mn:00001388
.text$mn:00001388 ; Attributes: bp-based frame
.text$mn:00001388
.text$mn:00001388 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001388                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001388 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001388                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00001388                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00001388
.text$mn:00001388 var_10          = dword ptr -10h
.text$mn:00001388 var_C           = dword ptr -0Ch
.text$mn:00001388 var_4           = dword ptr -4
.text$mn:00001388
.text$mn:00001388                 push    ebp
.text$mn:00001389                 mov     ebp, esp
.text$mn:0000138B                 push    0FFFFFFFFh
.text$mn:0000138D                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001392                 mov     eax, large fs:0
.text$mn:00001398                 push    eax
.text$mn:00001399                 push    ecx
.text$mn:0000139A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000139F                 xor     eax, ebp
.text$mn:000013A1                 push    eax
.text$mn:000013A2                 lea     eax, [ebp+var_C]
.text$mn:000013A5                 mov     large fs:0, eax
.text$mn:000013AB                 mov     [ebp+var_10], ecx
.text$mn:000013AE                 mov     [ebp+var_4], 0
.text$mn:000013B5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000013BC                 mov     ecx, [ebp+var_10] ; this
.text$mn:000013BF                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000013C4                 mov     ecx, [ebp+var_C]
.text$mn:000013C7                 mov     large fs:0, ecx
.text$mn:000013CE                 pop     ecx
.text$mn:000013CF                 mov     esp, ebp
.text$mn:000013D1                 pop     ebp
.text$mn:000013D2                 retn
.text$mn:000013D2 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000013D2
.text$mn:000013D2 ; ---------------------------------------------------------------------------
.text$mn:000013D3                 align 4
.text$mn:000013D3 _text$mn        ends
.text$mn:000013D3
.text$x:000013D4 ; ===========================================================================
.text$x:000013D4
.text$x:000013D4 ; Segment type: Pure code
.text$x:000013D4 ; Segment permissions: Read/Execute
.text$x:000013D4 _text$x         segment para public 'CODE' use32
.text$x:000013D4                 assume cs:_text$x
.text$x:000013D4                 ;org 13D4h
.text$x:000013D4 ; COMDAT (pick associative to section at 1388)
.text$x:000013D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000013D4
.text$x:000013D4 ; =============== S U B R O U T I N E =======================================
.text$x:000013D4
.text$x:000013D4
.text$x:000013D4 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000013D4                                         ; DATA XREF: .xdata$x:000026F0o
.text$x:000013D4                 mov     ecx, [ebp-10h]  ; this
.text$x:000013D7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000013D7 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000013D7
.text$x:000013DC
.text$x:000013DC ; =============== S U B R O U T I N E =======================================
.text$x:000013DC
.text$x:000013DC
.text$x:000013DC __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000013DC                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000013DC
.text$x:000013DC arg_4           = dword ptr  8
.text$x:000013DC
.text$x:000013DC                 mov     edx, [esp+arg_4]
.text$x:000013E0                 lea     eax, [edx+0Ch]
.text$x:000013E3                 mov     ecx, [edx-8]
.text$x:000013E6                 xor     ecx, eax
.text$x:000013E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000013ED                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000013F2                 jmp     ___CxxFrameHandler3
.text$x:000013F2 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000013F2
.text$x:000013F2 ; ---------------------------------------------------------------------------
.text$x:000013F7                 align 4
.text$x:000013F7 _text$x         ends
.text$x:000013F7
.text$mn:000013F8 ; ===========================================================================
.text$mn:000013F8
.text$mn:000013F8 ; Segment type: Pure code
.text$mn:000013F8 ; Segment permissions: Read/Execute
.text$mn:000013F8 _text$mn        segment para public 'CODE' use32
.text$mn:000013F8                 assume cs:_text$mn
.text$mn:000013F8                 ;org 13F8h
.text$mn:000013F8 ; COMDAT (pick any)
.text$mn:000013F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013F8
.text$mn:000013F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000013F8
.text$mn:000013F8 ; Attributes: bp-based frame
.text$mn:000013F8
.text$mn:000013F8 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:000013F8                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000013F8 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:000013F8                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:000013F8                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:000013F8
.text$mn:000013F8 var_10          = dword ptr -10h
.text$mn:000013F8 var_C           = dword ptr -0Ch
.text$mn:000013F8 var_4           = dword ptr -4
.text$mn:000013F8
.text$mn:000013F8                 push    ebp
.text$mn:000013F9                 mov     ebp, esp
.text$mn:000013FB                 push    0FFFFFFFFh
.text$mn:000013FD                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00001402                 mov     eax, large fs:0
.text$mn:00001408                 push    eax
.text$mn:00001409                 push    ecx
.text$mn:0000140A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000140F                 xor     eax, ebp
.text$mn:00001411                 push    eax
.text$mn:00001412                 lea     eax, [ebp+var_C]
.text$mn:00001415                 mov     large fs:0, eax
.text$mn:0000141B                 mov     [ebp+var_10], ecx
.text$mn:0000141E                 mov     [ebp+var_4], 0
.text$mn:00001425                 push    0               ; Size
.text$mn:00001427                 push    1               ; char
.text$mn:00001429                 mov     ecx, [ebp+var_10]
.text$mn:0000142C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001431                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001438                 mov     ecx, [ebp+var_10]
.text$mn:0000143B                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00001440                 mov     ecx, [ebp+var_C]
.text$mn:00001443                 mov     large fs:0, ecx
.text$mn:0000144A                 pop     ecx
.text$mn:0000144B                 mov     esp, ebp
.text$mn:0000144D                 pop     ebp
.text$mn:0000144E                 retn
.text$mn:0000144E ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:0000144E
.text$mn:0000144E ; ---------------------------------------------------------------------------
.text$mn:0000144F                 align 10h
.text$mn:0000144F _text$mn        ends
.text$mn:0000144F
.text$x:00001450 ; ===========================================================================
.text$x:00001450
.text$x:00001450 ; Segment type: Pure code
.text$x:00001450 ; Segment permissions: Read/Execute
.text$x:00001450 _text$x         segment para public 'CODE' use32
.text$x:00001450                 assume cs:_text$x
.text$x:00001450                 ;org 1450h
.text$x:00001450 ; COMDAT (pick associative to section at 13F8)
.text$x:00001450                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001450
.text$x:00001450 ; =============== S U B R O U T I N E =======================================
.text$x:00001450
.text$x:00001450
.text$x:00001450 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00001450                                         ; DATA XREF: .xdata$x:000027A0o
.text$x:00001450                 mov     ecx, [ebp-10h]
.text$x:00001453                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00001453 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00001453
.text$x:00001458
.text$x:00001458 ; =============== S U B R O U T I N E =======================================
.text$x:00001458
.text$x:00001458
.text$x:00001458 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00001458                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00001458
.text$x:00001458 arg_4           = dword ptr  8
.text$x:00001458
.text$x:00001458                 mov     edx, [esp+arg_4]
.text$x:0000145C                 lea     eax, [edx+0Ch]
.text$x:0000145F                 mov     ecx, [edx-8]
.text$x:00001462                 xor     ecx, eax
.text$x:00001464                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001469                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:0000146E                 jmp     ___CxxFrameHandler3
.text$x:0000146E __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:0000146E
.text$x:0000146E ; ---------------------------------------------------------------------------
.text$x:00001473                 align 4
.text$x:00001473 _text$x         ends
.text$x:00001473
.text$mn:00001474 ; ===========================================================================
.text$mn:00001474
.text$mn:00001474 ; Segment type: Pure code
.text$mn:00001474 ; Segment permissions: Read/Execute
.text$mn:00001474 _text$mn        segment para public 'CODE' use32
.text$mn:00001474                 assume cs:_text$mn
.text$mn:00001474                 ;org 1474h
.text$mn:00001474 ; COMDAT (pick any)
.text$mn:00001474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001474
.text$mn:00001474 ; =============== S U B R O U T I N E =======================================
.text$mn:00001474
.text$mn:00001474 ; Attributes: bp-based frame
.text$mn:00001474
.text$mn:00001474 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001474                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00001474 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00001474                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00001474                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00001474
.text$mn:00001474 var_4           = dword ptr -4
.text$mn:00001474
.text$mn:00001474                 push    ebp
.text$mn:00001475                 mov     ebp, esp
.text$mn:00001477                 push    ecx
.text$mn:00001478                 mov     [ebp+var_4], ecx
.text$mn:0000147B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000147E                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001483                 mov     esp, ebp
.text$mn:00001485                 pop     ebp
.text$mn:00001486                 retn
.text$mn:00001486 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00001486
.text$mn:00001486 ; ---------------------------------------------------------------------------
.text$mn:00001487                 align 4
.text$mn:00001487 _text$mn        ends
.text$mn:00001487
.text$mn:00001488 ; ===========================================================================
.text$mn:00001488
.text$mn:00001488 ; Segment type: Pure code
.text$mn:00001488 ; Segment permissions: Read/Execute
.text$mn:00001488 _text$mn        segment para public 'CODE' use32
.text$mn:00001488                 assume cs:_text$mn
.text$mn:00001488                 ;org 1488h
.text$mn:00001488 ; COMDAT (pick any)
.text$mn:00001488                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001488
.text$mn:00001488 ; =============== S U B R O U T I N E =======================================
.text$mn:00001488
.text$mn:00001488 ; Attributes: bp-based frame
.text$mn:00001488
.text$mn:00001488 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001488                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001488 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00001488                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00001488                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00001488
.text$mn:00001488 var_10          = dword ptr -10h
.text$mn:00001488 var_C           = dword ptr -0Ch
.text$mn:00001488 var_4           = dword ptr -4
.text$mn:00001488
.text$mn:00001488                 push    ebp
.text$mn:00001489                 mov     ebp, esp
.text$mn:0000148B                 push    0FFFFFFFFh
.text$mn:0000148D                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001492                 mov     eax, large fs:0
.text$mn:00001498                 push    eax
.text$mn:00001499                 push    ecx
.text$mn:0000149A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000149F                 xor     eax, ebp
.text$mn:000014A1                 push    eax
.text$mn:000014A2                 lea     eax, [ebp+var_C]
.text$mn:000014A5                 mov     large fs:0, eax
.text$mn:000014AB                 mov     [ebp+var_10], ecx
.text$mn:000014AE                 mov     [ebp+var_4], 0
.text$mn:000014B5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000014BC                 mov     ecx, [ebp+var_10] ; this
.text$mn:000014BF                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000014C4                 mov     ecx, [ebp+var_C]
.text$mn:000014C7                 mov     large fs:0, ecx
.text$mn:000014CE                 pop     ecx
.text$mn:000014CF                 mov     esp, ebp
.text$mn:000014D1                 pop     ebp
.text$mn:000014D2                 retn
.text$mn:000014D2 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:000014D2
.text$mn:000014D2 ; ---------------------------------------------------------------------------
.text$mn:000014D3                 align 4
.text$mn:000014D3 _text$mn        ends
.text$mn:000014D3
.text$x:000014D4 ; ===========================================================================
.text$x:000014D4
.text$x:000014D4 ; Segment type: Pure code
.text$x:000014D4 ; Segment permissions: Read/Execute
.text$x:000014D4 _text$x         segment para public 'CODE' use32
.text$x:000014D4                 assume cs:_text$x
.text$x:000014D4                 ;org 14D4h
.text$x:000014D4 ; COMDAT (pick associative to section at 1488)
.text$x:000014D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000014D4
.text$x:000014D4 ; =============== S U B R O U T I N E =======================================
.text$x:000014D4
.text$x:000014D4
.text$x:000014D4 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:000014D4                                         ; DATA XREF: .xdata$x:00002934o
.text$x:000014D4                 mov     ecx, [ebp-10h]  ; this
.text$x:000014D7                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000014D7 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:000014D7
.text$x:000014DC
.text$x:000014DC ; =============== S U B R O U T I N E =======================================
.text$x:000014DC
.text$x:000014DC
.text$x:000014DC __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:000014DC                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:000014DC
.text$x:000014DC arg_4           = dword ptr  8
.text$x:000014DC
.text$x:000014DC                 mov     edx, [esp+arg_4]
.text$x:000014E0                 lea     eax, [edx+0Ch]
.text$x:000014E3                 mov     ecx, [edx-8]
.text$x:000014E6                 xor     ecx, eax
.text$x:000014E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000014ED                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:000014F2                 jmp     ___CxxFrameHandler3
.text$x:000014F2 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:000014F2
.text$x:000014F2 ; ---------------------------------------------------------------------------
.text$x:000014F7                 align 4
.text$x:000014F7 _text$x         ends
.text$x:000014F7
.text$mn:000014F8 ; ===========================================================================
.text$mn:000014F8
.text$mn:000014F8 ; Segment type: Pure code
.text$mn:000014F8 ; Segment permissions: Read/Execute
.text$mn:000014F8 _text$mn        segment para public 'CODE' use32
.text$mn:000014F8                 assume cs:_text$mn
.text$mn:000014F8                 ;org 14F8h
.text$mn:000014F8 ; COMDAT (pick any)
.text$mn:000014F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014F8
.text$mn:000014F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014F8
.text$mn:000014F8 ; Attributes: bp-based frame
.text$mn:000014F8
.text$mn:000014F8 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000014F8                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000014F8 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:000014F8                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000014F8                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000014F8
.text$mn:000014F8 var_10          = dword ptr -10h
.text$mn:000014F8 var_C           = dword ptr -0Ch
.text$mn:000014F8 var_4           = dword ptr -4
.text$mn:000014F8
.text$mn:000014F8                 push    ebp
.text$mn:000014F9                 mov     ebp, esp
.text$mn:000014FB                 push    0FFFFFFFFh
.text$mn:000014FD                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00001502                 mov     eax, large fs:0
.text$mn:00001508                 push    eax
.text$mn:00001509                 push    ecx
.text$mn:0000150A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000150F                 xor     eax, ebp
.text$mn:00001511                 push    eax
.text$mn:00001512                 lea     eax, [ebp+var_C]
.text$mn:00001515                 mov     large fs:0, eax
.text$mn:0000151B                 mov     [ebp+var_10], ecx
.text$mn:0000151E                 mov     [ebp+var_4], 0
.text$mn:00001525                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000152C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000152F                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001534                 mov     ecx, [ebp+var_C]
.text$mn:00001537                 mov     large fs:0, ecx
.text$mn:0000153E                 pop     ecx
.text$mn:0000153F                 mov     esp, ebp
.text$mn:00001541                 pop     ebp
.text$mn:00001542                 retn
.text$mn:00001542 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00001542
.text$mn:00001542 ; ---------------------------------------------------------------------------
.text$mn:00001543                 align 4
.text$mn:00001543 _text$mn        ends
.text$mn:00001543
.text$x:00001544 ; ===========================================================================
.text$x:00001544
.text$x:00001544 ; Segment type: Pure code
.text$x:00001544 ; Segment permissions: Read/Execute
.text$x:00001544 _text$x         segment para public 'CODE' use32
.text$x:00001544                 assume cs:_text$x
.text$x:00001544                 ;org 1544h
.text$x:00001544 ; COMDAT (pick associative to section at 14F8)
.text$x:00001544                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001544
.text$x:00001544 ; =============== S U B R O U T I N E =======================================
.text$x:00001544
.text$x:00001544
.text$x:00001544 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00001544                                         ; DATA XREF: .xdata$x:000029B8o
.text$x:00001544                 mov     ecx, [ebp-10h]  ; this
.text$x:00001547                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001547 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00001547
.text$x:0000154C
.text$x:0000154C ; =============== S U B R O U T I N E =======================================
.text$x:0000154C
.text$x:0000154C
.text$x:0000154C __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:0000154C                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:0000154C
.text$x:0000154C arg_4           = dword ptr  8
.text$x:0000154C
.text$x:0000154C                 mov     edx, [esp+arg_4]
.text$x:00001550                 lea     eax, [edx+0Ch]
.text$x:00001553                 mov     ecx, [edx-8]
.text$x:00001556                 xor     ecx, eax
.text$x:00001558                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000155D                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00001562                 jmp     ___CxxFrameHandler3
.text$x:00001562 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00001562
.text$x:00001562 ; ---------------------------------------------------------------------------
.text$x:00001567                 align 4
.text$x:00001567 _text$x         ends
.text$x:00001567
.text$mn:00001568 ; ===========================================================================
.text$mn:00001568
.text$mn:00001568 ; Segment type: Pure code
.text$mn:00001568 ; Segment permissions: Read/Execute
.text$mn:00001568 _text$mn        segment para public 'CODE' use32
.text$mn:00001568                 assume cs:_text$mn
.text$mn:00001568                 ;org 1568h
.text$mn:00001568 ; COMDAT (pick any)
.text$mn:00001568                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001568
.text$mn:00001568 ; =============== S U B R O U T I N E =======================================
.text$mn:00001568
.text$mn:00001568 ; Attributes: bp-based frame
.text$mn:00001568
.text$mn:00001568 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001568                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00001568 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00001568                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001568                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001568
.text$mn:00001568 var_10          = dword ptr -10h
.text$mn:00001568 var_C           = dword ptr -0Ch
.text$mn:00001568 var_4           = dword ptr -4
.text$mn:00001568
.text$mn:00001568                 push    ebp
.text$mn:00001569                 mov     ebp, esp
.text$mn:0000156B                 push    0FFFFFFFFh
.text$mn:0000156D                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00001572                 mov     eax, large fs:0
.text$mn:00001578                 push    eax
.text$mn:00001579                 push    ecx
.text$mn:0000157A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000157F                 xor     eax, ebp
.text$mn:00001581                 push    eax
.text$mn:00001582                 lea     eax, [ebp+var_C]
.text$mn:00001585                 mov     large fs:0, eax
.text$mn:0000158B                 mov     [ebp+var_10], ecx
.text$mn:0000158E                 mov     [ebp+var_4], 0
.text$mn:00001595                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000159C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000159F                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000015A4                 mov     ecx, [ebp+var_C]
.text$mn:000015A7                 mov     large fs:0, ecx
.text$mn:000015AE                 pop     ecx
.text$mn:000015AF                 mov     esp, ebp
.text$mn:000015B1                 pop     ebp
.text$mn:000015B2                 retn
.text$mn:000015B2 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:000015B2
.text$mn:000015B2 ; ---------------------------------------------------------------------------
.text$mn:000015B3                 align 4
.text$mn:000015B3 _text$mn        ends
.text$mn:000015B3
.text$x:000015B4 ; ===========================================================================
.text$x:000015B4
.text$x:000015B4 ; Segment type: Pure code
.text$x:000015B4 ; Segment permissions: Read/Execute
.text$x:000015B4 _text$x         segment para public 'CODE' use32
.text$x:000015B4                 assume cs:_text$x
.text$x:000015B4                 ;org 15B4h
.text$x:000015B4 ; COMDAT (pick associative to section at 1568)
.text$x:000015B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000015B4
.text$x:000015B4 ; =============== S U B R O U T I N E =======================================
.text$x:000015B4
.text$x:000015B4
.text$x:000015B4 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:000015B4                                         ; DATA XREF: .xdata$x:00002A3Co
.text$x:000015B4                 mov     ecx, [ebp-10h]  ; this
.text$x:000015B7                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000015B7 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:000015B7
.text$x:000015BC
.text$x:000015BC ; =============== S U B R O U T I N E =======================================
.text$x:000015BC
.text$x:000015BC
.text$x:000015BC __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:000015BC                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:000015BC
.text$x:000015BC arg_4           = dword ptr  8
.text$x:000015BC
.text$x:000015BC                 mov     edx, [esp+arg_4]
.text$x:000015C0                 lea     eax, [edx+0Ch]
.text$x:000015C3                 mov     ecx, [edx-8]
.text$x:000015C6                 xor     ecx, eax
.text$x:000015C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000015CD                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:000015D2                 jmp     ___CxxFrameHandler3
.text$x:000015D2 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:000015D2
.text$x:000015D2 ; ---------------------------------------------------------------------------
.text$x:000015D7                 align 4
.text$x:000015D7 _text$x         ends
.text$x:000015D7
.text$mn:000015D8 ; ===========================================================================
.text$mn:000015D8
.text$mn:000015D8 ; Segment type: Pure code
.text$mn:000015D8 ; Segment permissions: Read/Execute
.text$mn:000015D8 _text$mn        segment para public 'CODE' use32
.text$mn:000015D8                 assume cs:_text$mn
.text$mn:000015D8                 ;org 15D8h
.text$mn:000015D8 ; COMDAT (pick any)
.text$mn:000015D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015D8
.text$mn:000015D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000015D8
.text$mn:000015D8 ; Attributes: bp-based frame
.text$mn:000015D8
.text$mn:000015D8 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:000015D8                 public ??1error_category@std@@UAE@XZ
.text$mn:000015D8 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:000015D8                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:000015D8
.text$mn:000015D8 var_4           = dword ptr -4
.text$mn:000015D8
.text$mn:000015D8                 push    ebp
.text$mn:000015D9                 mov     ebp, esp
.text$mn:000015DB                 push    ecx
.text$mn:000015DC                 mov     [ebp+var_4], ecx
.text$mn:000015DF                 mov     eax, [ebp+var_4]
.text$mn:000015E2                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000015E8                 mov     esp, ebp
.text$mn:000015EA                 pop     ebp
.text$mn:000015EB                 retn
.text$mn:000015EB ??1error_category@std@@UAE@XZ endp
.text$mn:000015EB
.text$mn:000015EB _text$mn        ends
.text$mn:000015EB
.text$mn:000015EC ; ===========================================================================
.text$mn:000015EC
.text$mn:000015EC ; Segment type: Pure code
.text$mn:000015EC ; Segment permissions: Read/Execute
.text$mn:000015EC _text$mn        segment para public 'CODE' use32
.text$mn:000015EC                 assume cs:_text$mn
.text$mn:000015EC                 ;org 15ECh
.text$mn:000015EC ; COMDAT (pick any)
.text$mn:000015EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015EC
.text$mn:000015EC ; =============== S U B R O U T I N E =======================================
.text$mn:000015EC
.text$mn:000015EC ; Attributes: bp-based frame
.text$mn:000015EC
.text$mn:000015EC ; _DWORD __thiscall std::runtime_error::~runtime_error(std::runtime_error *__hidden this)
.text$mn:000015EC                 public ??1runtime_error@std@@UAE@XZ
.text$mn:000015EC ??1runtime_error@std@@UAE@XZ proc near  ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+Ap
.text$mn:000015EC                                         ; DATA XREF: .xdata$x:00002AD0o
.text$mn:000015EC
.text$mn:000015EC var_10          = dword ptr -10h
.text$mn:000015EC var_C           = dword ptr -0Ch
.text$mn:000015EC var_4           = dword ptr -4
.text$mn:000015EC
.text$mn:000015EC                 push    ebp
.text$mn:000015ED                 mov     ebp, esp
.text$mn:000015EF                 push    0FFFFFFFFh
.text$mn:000015F1                 push    offset __ehhandler$??1runtime_error@std@@UAE@XZ
.text$mn:000015F6                 mov     eax, large fs:0
.text$mn:000015FC                 push    eax
.text$mn:000015FD                 push    ecx
.text$mn:000015FE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001603                 xor     eax, ebp
.text$mn:00001605                 push    eax
.text$mn:00001606                 lea     eax, [ebp+var_C]
.text$mn:00001609                 mov     large fs:0, eax
.text$mn:0000160F                 mov     [ebp+var_10], ecx
.text$mn:00001612                 mov     [ebp+var_4], 0
.text$mn:00001619                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001620                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001623                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:00001628                 mov     ecx, [ebp+var_C]
.text$mn:0000162B                 mov     large fs:0, ecx
.text$mn:00001632                 pop     ecx
.text$mn:00001633                 mov     esp, ebp
.text$mn:00001635                 pop     ebp
.text$mn:00001636                 retn
.text$mn:00001636 ??1runtime_error@std@@UAE@XZ endp
.text$mn:00001636
.text$mn:00001636 ; ---------------------------------------------------------------------------
.text$mn:00001637                 align 4
.text$mn:00001637 _text$mn        ends
.text$mn:00001637
.text$x:00001638 ; ===========================================================================
.text$x:00001638
.text$x:00001638 ; Segment type: Pure code
.text$x:00001638 ; Segment permissions: Read/Execute
.text$x:00001638 _text$x         segment para public 'CODE' use32
.text$x:00001638                 assume cs:_text$x
.text$x:00001638                 ;org 1638h
.text$x:00001638 ; COMDAT (pick associative to section at 15EC)
.text$x:00001638                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001638
.text$x:00001638 ; =============== S U B R O U T I N E =======================================
.text$x:00001638
.text$x:00001638
.text$x:00001638 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 proc near
.text$x:00001638                                         ; DATA XREF: .xdata$x:00002884o
.text$x:00001638                 mov     ecx, [ebp-10h]  ; this
.text$x:0000163B                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:0000163B __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 endp
.text$x:0000163B
.text$x:00001640
.text$x:00001640 ; =============== S U B R O U T I N E =======================================
.text$x:00001640
.text$x:00001640
.text$x:00001640 __ehhandler$??1runtime_error@std@@UAE@XZ proc near
.text$x:00001640                                         ; DATA XREF: std::runtime_error::~runtime_error(void)+5o
.text$x:00001640
.text$x:00001640 arg_4           = dword ptr  8
.text$x:00001640
.text$x:00001640                 mov     edx, [esp+arg_4]
.text$x:00001644                 lea     eax, [edx+0Ch]
.text$x:00001647                 mov     ecx, [edx-8]
.text$x:0000164A                 xor     ecx, eax
.text$x:0000164C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001651                 mov     eax, offset __ehfuncinfo$??1runtime_error@std@@UAE@XZ
.text$x:00001656                 jmp     ___CxxFrameHandler3
.text$x:00001656 __ehhandler$??1runtime_error@std@@UAE@XZ endp
.text$x:00001656
.text$x:00001656 ; ---------------------------------------------------------------------------
.text$x:0000165B                 align 4
.text$x:0000165B _text$x         ends
.text$x:0000165B
.text$mn:0000165C ; ===========================================================================
.text$mn:0000165C
.text$mn:0000165C ; Segment type: Pure code
.text$mn:0000165C ; Segment permissions: Read/Execute
.text$mn:0000165C _text$mn        segment para public 'CODE' use32
.text$mn:0000165C                 assume cs:_text$mn
.text$mn:0000165C                 ;org 165Ch
.text$mn:0000165C ; COMDAT (pick any)
.text$mn:0000165C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000165C
.text$mn:0000165C ; =============== S U B R O U T I N E =======================================
.text$mn:0000165C
.text$mn:0000165C ; Attributes: bp-based frame
.text$mn:0000165C
.text$mn:0000165C ; void *__cdecl operator new(unsigned int, void *)
.text$mn:0000165C                 public ??2@YAPAXIPAX@Z
.text$mn:0000165C ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:0000165C                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:0000165C
.text$mn:0000165C arg_4           = dword ptr  0Ch
.text$mn:0000165C
.text$mn:0000165C                 push    ebp
.text$mn:0000165D                 mov     ebp, esp
.text$mn:0000165F                 mov     eax, [ebp+arg_4]
.text$mn:00001662                 pop     ebp
.text$mn:00001663                 retn
.text$mn:00001663 ??2@YAPAXIPAX@Z endp
.text$mn:00001663
.text$mn:00001663 _text$mn        ends
.text$mn:00001663
.text$mn:00001664 ; ===========================================================================
.text$mn:00001664
.text$mn:00001664 ; Segment type: Pure code
.text$mn:00001664 ; Segment permissions: Read/Execute
.text$mn:00001664 _text$mn        segment para public 'CODE' use32
.text$mn:00001664                 assume cs:_text$mn
.text$mn:00001664                 ;org 1664h
.text$mn:00001664 ; COMDAT (pick any)
.text$mn:00001664                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001664
.text$mn:00001664 ; =============== S U B R O U T I N E =======================================
.text$mn:00001664
.text$mn:00001664 ; Attributes: bp-based frame
.text$mn:00001664
.text$mn:00001664 ; void __cdecl operator delete(void *)
.text$mn:00001664                 public ??3@YAXPAX0@Z
.text$mn:00001664 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00001664                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00001664                 push    ebp
.text$mn:00001665                 mov     ebp, esp
.text$mn:00001667                 pop     ebp
.text$mn:00001668                 retn
.text$mn:00001668 ??3@YAXPAX0@Z   endp
.text$mn:00001668
.text$mn:00001668 ; ---------------------------------------------------------------------------
.text$mn:00001669                 align 4
.text$mn:00001669 _text$mn        ends
.text$mn:00001669
.text$mn:0000166C ; ===========================================================================
.text$mn:0000166C
.text$mn:0000166C ; Segment type: Pure code
.text$mn:0000166C ; Segment permissions: Read/Execute
.text$mn:0000166C _text$mn        segment para public 'CODE' use32
.text$mn:0000166C                 assume cs:_text$mn
.text$mn:0000166C                 ;org 166Ch
.text$mn:0000166C ; COMDAT (pick any)
.text$mn:0000166C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000166C
.text$mn:0000166C ; =============== S U B R O U T I N E =======================================
.text$mn:0000166C
.text$mn:0000166C ; Attributes: bp-based frame
.text$mn:0000166C
.text$mn:0000166C ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:0000166C                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:0000166C ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:0000166C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:0000166C                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:0000166C
.text$mn:0000166C var_8           = dword ptr -8
.text$mn:0000166C var_4           = dword ptr -4
.text$mn:0000166C arg_0           = dword ptr  8
.text$mn:0000166C
.text$mn:0000166C                 push    ebp
.text$mn:0000166D                 mov     ebp, esp
.text$mn:0000166F                 sub     esp, 8
.text$mn:00001672                 mov     [ebp+var_8], ecx
.text$mn:00001675                 mov     eax, [ebp+var_8]
.text$mn:00001678                 cmp     eax, [ebp+arg_0]
.text$mn:0000167B                 jnz     short loc_1686
.text$mn:0000167D                 mov     [ebp+var_4], 1
.text$mn:00001684                 jmp     short loc_168D
.text$mn:00001686 ; ---------------------------------------------------------------------------
.text$mn:00001686
.text$mn:00001686 loc_1686:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00001686                 mov     [ebp+var_4], 0
.text$mn:0000168D
.text$mn:0000168D loc_168D:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:0000168D                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001690                 mov     esp, ebp
.text$mn:00001692                 pop     ebp
.text$mn:00001693                 retn    4
.text$mn:00001693 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00001693
.text$mn:00001693 ; ---------------------------------------------------------------------------
.text$mn:00001696                 align 4
.text$mn:00001696 _text$mn        ends
.text$mn:00001696
.text$mn:00001698 ; ===========================================================================
.text$mn:00001698
.text$mn:00001698 ; Segment type: Pure code
.text$mn:00001698 ; Segment permissions: Read/Execute
.text$mn:00001698 _text$mn        segment para public 'CODE' use32
.text$mn:00001698                 assume cs:_text$mn
.text$mn:00001698                 ;org 1698h
.text$mn:00001698 ; COMDAT (pick any)
.text$mn:00001698                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001698
.text$mn:00001698 ; =============== S U B R O U T I N E =======================================
.text$mn:00001698
.text$mn:00001698 ; Attributes: bp-based frame
.text$mn:00001698
.text$mn:00001698 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00001698                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00001698 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00001698                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00001698
.text$mn:00001698 var_8           = dword ptr -8
.text$mn:00001698 var_4           = dword ptr -4
.text$mn:00001698 arg_0           = dword ptr  8
.text$mn:00001698
.text$mn:00001698                 push    ebp
.text$mn:00001699                 mov     ebp, esp
.text$mn:0000169B                 sub     esp, 8
.text$mn:0000169E                 push    esi
.text$mn:0000169F                 mov     [ebp+var_4], ecx
.text$mn:000016A2                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000016A5                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000016AA                 push    eax
.text$mn:000016AB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000016AE                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000016B3                 mov     ecx, eax
.text$mn:000016B5                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000016BA                 movzx   eax, al
.text$mn:000016BD                 test    eax, eax
.text$mn:000016BF                 jz      short loc_16E0
.text$mn:000016C1                 mov     ecx, [ebp+var_4] ; this
.text$mn:000016C4                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000016C9                 mov     esi, eax
.text$mn:000016CB                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000016CE                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000016D3                 cmp     esi, eax
.text$mn:000016D5                 jnz     short loc_16E0
.text$mn:000016D7                 mov     [ebp+var_8], 1
.text$mn:000016DE                 jmp     short loc_16E7
.text$mn:000016E0 ; ---------------------------------------------------------------------------
.text$mn:000016E0
.text$mn:000016E0 loc_16E0:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:000016E0                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:000016E0                 mov     [ebp+var_8], 0
.text$mn:000016E7
.text$mn:000016E7 loc_16E7:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:000016E7                 mov     al, byte ptr [ebp+var_8]
.text$mn:000016EA                 pop     esi
.text$mn:000016EB                 mov     esp, ebp
.text$mn:000016ED                 pop     ebp
.text$mn:000016EE                 retn    4
.text$mn:000016EE ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:000016EE
.text$mn:000016EE ; ---------------------------------------------------------------------------
.text$mn:000016F1                 align 4
.text$mn:000016F1 _text$mn        ends
.text$mn:000016F1
.text$mn:000016F4 ; ===========================================================================
.text$mn:000016F4
.text$mn:000016F4 ; Segment type: Pure code
.text$mn:000016F4 ; Segment permissions: Read/Execute
.text$mn:000016F4 _text$mn        segment para public 'CODE' use32
.text$mn:000016F4                 assume cs:_text$mn
.text$mn:000016F4                 ;org 16F4h
.text$mn:000016F4 ; COMDAT (pick any)
.text$mn:000016F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016F4
.text$mn:000016F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000016F4
.text$mn:000016F4 ; Attributes: bp-based frame
.text$mn:000016F4
.text$mn:000016F4 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000016F4                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:000016F4 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:000016F4
.text$mn:000016F4 var_4           = dword ptr -4
.text$mn:000016F4 arg_0           = dword ptr  8
.text$mn:000016F4
.text$mn:000016F4                 push    ebp
.text$mn:000016F5                 mov     ebp, esp
.text$mn:000016F7                 push    ecx
.text$mn:000016F8                 mov     [ebp+var_4], ecx
.text$mn:000016FB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000016FE                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001703                 mov     eax, [ebp+arg_0]
.text$mn:00001706                 and     eax, 1
.text$mn:00001709                 jz      short loc_1717
.text$mn:0000170B                 mov     ecx, [ebp+var_4]
.text$mn:0000170E                 push    ecx             ; void *
.text$mn:0000170F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001714                 add     esp, 4
.text$mn:00001717
.text$mn:00001717 loc_1717:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001717                 mov     eax, [ebp+var_4]
.text$mn:0000171A                 mov     esp, ebp
.text$mn:0000171C                 pop     ebp
.text$mn:0000171D                 retn    4
.text$mn:0000171D ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:0000171D
.text$mn:0000171D _text$mn        ends
.text$mn:0000171D
.text$mn:00001720 ; ===========================================================================
.text$mn:00001720
.text$mn:00001720 ; Segment type: Pure code
.text$mn:00001720 ; Segment permissions: Read/Execute
.text$mn:00001720 _text$mn        segment para public 'CODE' use32
.text$mn:00001720                 assume cs:_text$mn
.text$mn:00001720                 ;org 1720h
.text$mn:00001720 ; COMDAT (pick any)
.text$mn:00001720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001720
.text$mn:00001720 ; =============== S U B R O U T I N E =======================================
.text$mn:00001720
.text$mn:00001720 ; Attributes: bp-based frame
.text$mn:00001720
.text$mn:00001720 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001720                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00001720 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001720
.text$mn:00001720 var_4           = dword ptr -4
.text$mn:00001720 arg_0           = dword ptr  8
.text$mn:00001720
.text$mn:00001720                 push    ebp
.text$mn:00001721                 mov     ebp, esp
.text$mn:00001723                 push    ecx
.text$mn:00001724                 mov     [ebp+var_4], ecx
.text$mn:00001727                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000172A                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:0000172F                 mov     eax, [ebp+arg_0]
.text$mn:00001732                 and     eax, 1
.text$mn:00001735                 jz      short loc_1743
.text$mn:00001737                 mov     ecx, [ebp+var_4]
.text$mn:0000173A                 push    ecx             ; void *
.text$mn:0000173B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001740                 add     esp, 4
.text$mn:00001743
.text$mn:00001743 loc_1743:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001743                 mov     eax, [ebp+var_4]
.text$mn:00001746                 mov     esp, ebp
.text$mn:00001748                 pop     ebp
.text$mn:00001749                 retn    4
.text$mn:00001749 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00001749
.text$mn:00001749 _text$mn        ends
.text$mn:00001749
.text$mn:0000174C ; ===========================================================================
.text$mn:0000174C
.text$mn:0000174C ; Segment type: Pure code
.text$mn:0000174C ; Segment permissions: Read/Execute
.text$mn:0000174C _text$mn        segment para public 'CODE' use32
.text$mn:0000174C                 assume cs:_text$mn
.text$mn:0000174C                 ;org 174Ch
.text$mn:0000174C ; COMDAT (pick any)
.text$mn:0000174C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000174C
.text$mn:0000174C ; =============== S U B R O U T I N E =======================================
.text$mn:0000174C
.text$mn:0000174C ; Attributes: bp-based frame
.text$mn:0000174C
.text$mn:0000174C ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000174C                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:0000174C ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000174C
.text$mn:0000174C var_4           = dword ptr -4
.text$mn:0000174C arg_0           = dword ptr  8
.text$mn:0000174C
.text$mn:0000174C                 push    ebp
.text$mn:0000174D                 mov     ebp, esp
.text$mn:0000174F                 push    ecx
.text$mn:00001750                 mov     [ebp+var_4], ecx
.text$mn:00001753                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001756                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:0000175B                 mov     eax, [ebp+arg_0]
.text$mn:0000175E                 and     eax, 1
.text$mn:00001761                 jz      short loc_176F
.text$mn:00001763                 mov     ecx, [ebp+var_4]
.text$mn:00001766                 push    ecx             ; void *
.text$mn:00001767                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000176C                 add     esp, 4
.text$mn:0000176F
.text$mn:0000176F loc_176F:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000176F                 mov     eax, [ebp+var_4]
.text$mn:00001772                 mov     esp, ebp
.text$mn:00001774                 pop     ebp
.text$mn:00001775                 retn    4
.text$mn:00001775 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00001775
.text$mn:00001775 _text$mn        ends
.text$mn:00001775
.text$mn:00001778 ; ===========================================================================
.text$mn:00001778
.text$mn:00001778 ; Segment type: Pure code
.text$mn:00001778 ; Segment permissions: Read/Execute
.text$mn:00001778 _text$mn        segment para public 'CODE' use32
.text$mn:00001778                 assume cs:_text$mn
.text$mn:00001778                 ;org 1778h
.text$mn:00001778 ; COMDAT (pick any)
.text$mn:00001778                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001778
.text$mn:00001778 ; =============== S U B R O U T I N E =======================================
.text$mn:00001778
.text$mn:00001778 ; Attributes: bp-based frame
.text$mn:00001778
.text$mn:00001778 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001778                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00001778 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00001778
.text$mn:00001778 var_4           = dword ptr -4
.text$mn:00001778 arg_0           = dword ptr  8
.text$mn:00001778
.text$mn:00001778                 push    ebp
.text$mn:00001779                 mov     ebp, esp
.text$mn:0000177B                 push    ecx
.text$mn:0000177C                 mov     [ebp+var_4], ecx
.text$mn:0000177F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001782                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001787                 mov     eax, [ebp+arg_0]
.text$mn:0000178A                 and     eax, 1
.text$mn:0000178D                 jz      short loc_179B
.text$mn:0000178F                 mov     ecx, [ebp+var_4]
.text$mn:00001792                 push    ecx             ; void *
.text$mn:00001793                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001798                 add     esp, 4
.text$mn:0000179B
.text$mn:0000179B loc_179B:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000179B                 mov     eax, [ebp+var_4]
.text$mn:0000179E                 mov     esp, ebp
.text$mn:000017A0                 pop     ebp
.text$mn:000017A1                 retn    4
.text$mn:000017A1 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:000017A1
.text$mn:000017A1 _text$mn        ends
.text$mn:000017A1
.text$mn:000017A4 ; ===========================================================================
.text$mn:000017A4
.text$mn:000017A4 ; Segment type: Pure code
.text$mn:000017A4 ; Segment permissions: Read/Execute
.text$mn:000017A4 _text$mn        segment para public 'CODE' use32
.text$mn:000017A4                 assume cs:_text$mn
.text$mn:000017A4                 ;org 17A4h
.text$mn:000017A4 ; COMDAT (pick any)
.text$mn:000017A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000017A4
.text$mn:000017A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000017A4
.text$mn:000017A4 ; Attributes: bp-based frame
.text$mn:000017A4
.text$mn:000017A4 ; public: virtual void * __thiscall std::runtime_error::`scalar deleting destructor'(unsigned int)
.text$mn:000017A4                 public ??_Gruntime_error@std@@UAEPAXI@Z
.text$mn:000017A4 ??_Gruntime_error@std@@UAEPAXI@Z proc near
.text$mn:000017A4
.text$mn:000017A4 var_4           = dword ptr -4
.text$mn:000017A4 arg_0           = dword ptr  8
.text$mn:000017A4
.text$mn:000017A4                 push    ebp
.text$mn:000017A5                 mov     ebp, esp
.text$mn:000017A7                 push    ecx
.text$mn:000017A8                 mov     [ebp+var_4], ecx
.text$mn:000017AB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000017AE                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:000017B3                 mov     eax, [ebp+arg_0]
.text$mn:000017B6                 and     eax, 1
.text$mn:000017B9                 jz      short loc_17C7
.text$mn:000017BB                 mov     ecx, [ebp+var_4]
.text$mn:000017BE                 push    ecx             ; void *
.text$mn:000017BF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000017C4                 add     esp, 4
.text$mn:000017C7
.text$mn:000017C7 loc_17C7:                               ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+15j
.text$mn:000017C7                 mov     eax, [ebp+var_4]
.text$mn:000017CA                 mov     esp, ebp
.text$mn:000017CC                 pop     ebp
.text$mn:000017CD                 retn    4
.text$mn:000017CD ??_Gruntime_error@std@@UAEPAXI@Z endp
.text$mn:000017CD
.text$mn:000017CD _text$mn        ends
.text$mn:000017CD
.text$di:000017D0 ; ===========================================================================
.text$di:000017D0
.text$di:000017D0 ; Segment type: Pure code
.text$di:000017D0 ; Segment permissions: Read/Execute
.text$di:000017D0 _text$di        segment para public 'CODE' use32
.text$di:000017D0                 assume cs:_text$di
.text$di:000017D0                 ;org 17D0h
.text$di:000017D0 ; COMDAT (pick any)
.text$di:000017D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000017D0
.text$di:000017D0 ; =============== S U B R O U T I N E =======================================
.text$di:000017D0
.text$di:000017D0 ; Attributes: bp-based frame
.text$di:000017D0
.text$di:000017D0 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:000017D0 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:000017D0                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:000017D0                 push    ebp
.text$di:000017D1                 mov     ebp, esp
.text$di:000017D3                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:000017D8                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:000017DD                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000017E2                 call    _atexit
.text$di:000017E7                 add     esp, 4
.text$di:000017EA                 pop     ebp
.text$di:000017EB                 retn
.text$di:000017EB ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:000017EB
.text$di:000017EB _text$di        ends
.text$di:000017EB
.text$di:000017EC ; ===========================================================================
.text$di:000017EC
.text$di:000017EC ; Segment type: Pure code
.text$di:000017EC ; Segment permissions: Read/Execute
.text$di:000017EC _text$di        segment para public 'CODE' use32
.text$di:000017EC                 assume cs:_text$di
.text$di:000017EC                 ;org 17ECh
.text$di:000017EC ; COMDAT (pick any)
.text$di:000017EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000017EC
.text$di:000017EC ; =============== S U B R O U T I N E =======================================
.text$di:000017EC
.text$di:000017EC ; Attributes: bp-based frame
.text$di:000017EC
.text$di:000017EC ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:000017EC ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:000017EC                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:000017EC                 push    ebp
.text$di:000017ED                 mov     ebp, esp
.text$di:000017EF                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:000017F4                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:000017F9                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000017FE                 call    _atexit
.text$di:00001803                 add     esp, 4
.text$di:00001806                 pop     ebp
.text$di:00001807                 retn
.text$di:00001807 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00001807
.text$di:00001807 _text$di        ends
.text$di:00001807
.text$di:00001808 ; ===========================================================================
.text$di:00001808
.text$di:00001808 ; Segment type: Pure code
.text$di:00001808 ; Segment permissions: Read/Execute
.text$di:00001808 _text$di        segment para public 'CODE' use32
.text$di:00001808                 assume cs:_text$di
.text$di:00001808                 ;org 1808h
.text$di:00001808 ; COMDAT (pick any)
.text$di:00001808                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001808
.text$di:00001808 ; =============== S U B R O U T I N E =======================================
.text$di:00001808
.text$di:00001808 ; Attributes: bp-based frame
.text$di:00001808
.text$di:00001808 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00001808 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00001808                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00001808                 push    ebp
.text$di:00001809                 mov     ebp, esp
.text$di:0000180B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00001810                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00001815                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000181A                 call    _atexit
.text$di:0000181F                 add     esp, 4
.text$di:00001822                 pop     ebp
.text$di:00001823                 retn
.text$di:00001823 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00001823
.text$di:00001823 _text$di        ends
.text$di:00001823
.text$di:00001824 ; ===========================================================================
.text$di:00001824
.text$di:00001824 ; Segment type: Pure code
.text$di:00001824 ; Segment permissions: Read/Execute
.text$di:00001824 _text$di        segment para public 'CODE' use32
.text$di:00001824                 assume cs:_text$di
.text$di:00001824                 ;org 1824h
.text$di:00001824 ; COMDAT (pick any)
.text$di:00001824                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001824
.text$di:00001824 ; =============== S U B R O U T I N E =======================================
.text$di:00001824
.text$di:00001824 ; Attributes: bp-based frame
.text$di:00001824
.text$di:00001824 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00001824 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001824                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00001824                 push    ebp
.text$di:00001825                 mov     ebp, esp
.text$di:00001827                 push    0               ; unsigned int
.text$di:00001829                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000182E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001833                 pop     ebp
.text$di:00001834                 retn
.text$di:00001834 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001834
.text$di:00001834 ; ---------------------------------------------------------------------------
.text$di:00001835                 align 4
.text$di:00001835 _text$di        ends
.text$di:00001835
.text$di:00001838 ; ===========================================================================
.text$di:00001838
.text$di:00001838 ; Segment type: Pure code
.text$di:00001838 ; Segment permissions: Read/Execute
.text$di:00001838 _text$di        segment para public 'CODE' use32
.text$di:00001838                 assume cs:_text$di
.text$di:00001838                 ;org 1838h
.text$di:00001838 ; COMDAT (pick any)
.text$di:00001838                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001838
.text$di:00001838 ; =============== S U B R O U T I N E =======================================
.text$di:00001838
.text$di:00001838 ; Attributes: bp-based frame
.text$di:00001838
.text$di:00001838 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00001838 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001838                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00001838                 push    ebp
.text$di:00001839                 mov     ebp, esp
.text$di:0000183B                 push    0               ; unsigned int
.text$di:0000183D                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001842                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001847                 pop     ebp
.text$di:00001848                 retn
.text$di:00001848 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001848
.text$di:00001848 ; ---------------------------------------------------------------------------
.text$di:00001849                 align 4
.text$di:00001849 _text$di        ends
.text$di:00001849
.text$di:0000184C ; ===========================================================================
.text$di:0000184C
.text$di:0000184C ; Segment type: Pure code
.text$di:0000184C ; Segment permissions: Read/Execute
.text$di:0000184C _text$di        segment para public 'CODE' use32
.text$di:0000184C                 assume cs:_text$di
.text$di:0000184C                 ;org 184Ch
.text$di:0000184C ; COMDAT (pick any)
.text$di:0000184C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000184C
.text$di:0000184C ; =============== S U B R O U T I N E =======================================
.text$di:0000184C
.text$di:0000184C ; Attributes: bp-based frame
.text$di:0000184C
.text$di:0000184C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:0000184C ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000184C                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:0000184C                 push    ebp
.text$di:0000184D                 mov     ebp, esp
.text$di:0000184F                 push    0               ; unsigned int
.text$di:00001851                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00001856                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000185B                 pop     ebp
.text$di:0000185C                 retn
.text$di:0000185C ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000185C
.text$di:0000185C ; ---------------------------------------------------------------------------
.text$di:0000185D                 align 10h
.text$di:0000185D _text$di        ends
.text$di:0000185D
.text$di:00001860 ; ===========================================================================
.text$di:00001860
.text$di:00001860 ; Segment type: Pure code
.text$di:00001860 ; Segment permissions: Read/Execute
.text$di:00001860 _text$di        segment para public 'CODE' use32
.text$di:00001860                 assume cs:_text$di
.text$di:00001860                 ;org 1860h
.text$di:00001860 ; COMDAT (pick any)
.text$di:00001860                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001860
.text$di:00001860 ; =============== S U B R O U T I N E =======================================
.text$di:00001860
.text$di:00001860 ; Attributes: bp-based frame
.text$di:00001860
.text$di:00001860 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00001860 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001860                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00001860                 push    ebp
.text$di:00001861                 mov     ebp, esp
.text$di:00001863                 push    0               ; unsigned int
.text$di:00001865                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:0000186A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000186F                 pop     ebp
.text$di:00001870                 retn
.text$di:00001870 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001870
.text$di:00001870 ; ---------------------------------------------------------------------------
.text$di:00001871                 align 4
.text$di:00001871 _text$di        ends
.text$di:00001871
.text$di:00001874 ; ===========================================================================
.text$di:00001874
.text$di:00001874 ; Segment type: Pure code
.text$di:00001874 ; Segment permissions: Read/Execute
.text$di:00001874 _text$di        segment para public 'CODE' use32
.text$di:00001874                 assume cs:_text$di
.text$di:00001874                 ;org 1874h
.text$di:00001874 ; COMDAT (pick any)
.text$di:00001874                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001874
.text$di:00001874 ; =============== S U B R O U T I N E =======================================
.text$di:00001874
.text$di:00001874 ; Attributes: bp-based frame
.text$di:00001874
.text$di:00001874 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00001874 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00001874
.text$di:00001874 var_1           = byte ptr -1
.text$di:00001874
.text$di:00001874                 push    ebp
.text$di:00001875                 mov     ebp, esp
.text$di:00001877                 push    ecx
.text$di:00001878                 xor     eax, eax
.text$di:0000187A                 mov     [ebp+var_1], al
.text$di:0000187D                 mov     esp, ebp
.text$di:0000187F                 pop     ebp
.text$di:00001880                 retn
.text$di:00001880 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00001880
.text$di:00001880 ; ---------------------------------------------------------------------------
.text$di:00001881                 align 4
.text$di:00001881 _text$di        ends
.text$di:00001881
.text$di:00001884 ; ===========================================================================
.text$di:00001884
.text$di:00001884 ; Segment type: Pure code
.text$di:00001884 ; Segment permissions: Read/Execute
.text$di:00001884 _text$di        segment para public 'CODE' use32
.text$di:00001884                 assume cs:_text$di
.text$di:00001884                 ;org 1884h
.text$di:00001884 ; COMDAT (pick any)
.text$di:00001884                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001884
.text$di:00001884 ; =============== S U B R O U T I N E =======================================
.text$di:00001884
.text$di:00001884 ; Attributes: bp-based frame
.text$di:00001884
.text$di:00001884 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00001884 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00001884                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00001884
.text$di:00001884 var_1           = byte ptr -1
.text$di:00001884
.text$di:00001884                 push    ebp
.text$di:00001885                 mov     ebp, esp
.text$di:00001887                 push    ecx
.text$di:00001888                 xor     eax, eax
.text$di:0000188A                 mov     [ebp+var_1], al
.text$di:0000188D                 mov     esp, ebp
.text$di:0000188F                 pop     ebp
.text$di:00001890                 retn
.text$di:00001890 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00001890
.text$di:00001890 ; ---------------------------------------------------------------------------
.text$di:00001891                 align 4
.text$di:00001891 _text$di        ends
.text$di:00001891
.text$yd:00001894 ; ===========================================================================
.text$yd:00001894
.text$yd:00001894 ; Segment type: Pure code
.text$yd:00001894 ; Segment permissions: Read/Execute
.text$yd:00001894 _text$yd        segment para public 'CODE' use32
.text$yd:00001894                 assume cs:_text$yd
.text$yd:00001894                 ;org 1894h
.text$yd:00001894 ; COMDAT (pick any)
.text$yd:00001894                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00001894
.text$yd:00001894 ; =============== S U B R O U T I N E =======================================
.text$yd:00001894
.text$yd:00001894 ; Attributes: bp-based frame
.text$yd:00001894
.text$yd:00001894 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00001894 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00001894                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00001894                 push    ebp
.text$yd:00001895                 mov     ebp, esp
.text$yd:00001897                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:0000189C                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:000018A1                 pop     ebp
.text$yd:000018A2                 retn
.text$yd:000018A2 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:000018A2
.text$yd:000018A2 ; ---------------------------------------------------------------------------
.text$yd:000018A3                 align 4
.text$yd:000018A3 _text$yd        ends
.text$yd:000018A3
.text$yd:000018A4 ; ===========================================================================
.text$yd:000018A4
.text$yd:000018A4 ; Segment type: Pure code
.text$yd:000018A4 ; Segment permissions: Read/Execute
.text$yd:000018A4 _text$yd        segment para public 'CODE' use32
.text$yd:000018A4                 assume cs:_text$yd
.text$yd:000018A4                 ;org 18A4h
.text$yd:000018A4 ; COMDAT (pick any)
.text$yd:000018A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000018A4
.text$yd:000018A4 ; =============== S U B R O U T I N E =======================================
.text$yd:000018A4
.text$yd:000018A4 ; Attributes: bp-based frame
.text$yd:000018A4
.text$yd:000018A4 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:000018A4 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:000018A4                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:000018A4                 push    ebp
.text$yd:000018A5                 mov     ebp, esp
.text$yd:000018A7                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:000018AC                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:000018B1                 pop     ebp
.text$yd:000018B2                 retn
.text$yd:000018B2 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:000018B2
.text$yd:000018B2 ; ---------------------------------------------------------------------------
.text$yd:000018B3                 align 4
.text$yd:000018B3 _text$yd        ends
.text$yd:000018B3
.text$yd:000018B4 ; ===========================================================================
.text$yd:000018B4
.text$yd:000018B4 ; Segment type: Pure code
.text$yd:000018B4 ; Segment permissions: Read/Execute
.text$yd:000018B4 _text$yd        segment para public 'CODE' use32
.text$yd:000018B4                 assume cs:_text$yd
.text$yd:000018B4                 ;org 18B4h
.text$yd:000018B4 ; COMDAT (pick any)
.text$yd:000018B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000018B4
.text$yd:000018B4 ; =============== S U B R O U T I N E =======================================
.text$yd:000018B4
.text$yd:000018B4 ; Attributes: bp-based frame
.text$yd:000018B4
.text$yd:000018B4 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:000018B4 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:000018B4                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:000018B4                 push    ebp
.text$yd:000018B5                 mov     ebp, esp
.text$yd:000018B7                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:000018BC                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:000018C1                 pop     ebp
.text$yd:000018C2                 retn
.text$yd:000018C2 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:000018C2
.text$yd:000018C2 ; ---------------------------------------------------------------------------
.text$yd:000018C3                 align 4
.text$yd:000018C3 _text$yd        ends
.text$yd:000018C3
.text$mn:000018C4 ; ===========================================================================
.text$mn:000018C4
.text$mn:000018C4 ; Segment type: Pure code
.text$mn:000018C4 ; Segment permissions: Read/Execute
.text$mn:000018C4 _text$mn        segment para public 'CODE' use32
.text$mn:000018C4                 assume cs:_text$mn
.text$mn:000018C4                 ;org 18C4h
.text$mn:000018C4 ; COMDAT (pick any)
.text$mn:000018C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018C4
.text$mn:000018C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000018C4
.text$mn:000018C4 ; Attributes: bp-based frame
.text$mn:000018C4
.text$mn:000018C4 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000018C4                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000018C4 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000018C4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:000018C4
.text$mn:000018C4 var_10          = byte ptr -10h
.text$mn:000018C4 var_8           = dword ptr -8
.text$mn:000018C4 var_1           = byte ptr -1
.text$mn:000018C4
.text$mn:000018C4                 push    ebp
.text$mn:000018C5                 mov     ebp, esp
.text$mn:000018C7                 sub     esp, 10h
.text$mn:000018CA                 mov     [ebp+var_8], ecx
.text$mn:000018CD                 lea     ecx, [ebp+var_1]
.text$mn:000018D0                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000018D5                 push    1
.text$mn:000018D7                 lea     ecx, [ebp+var_1]
.text$mn:000018DA                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000018DF                 mov     ecx, [ebp+var_8]
.text$mn:000018E2                 mov     [ecx], eax
.text$mn:000018E4                 lea     ecx, [ebp+var_10] ; this
.text$mn:000018E7                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000018EC                 push    eax             ; int
.text$mn:000018ED                 mov     edx, [ebp+var_8]
.text$mn:000018F0                 mov     eax, [edx]
.text$mn:000018F2                 push    eax             ; void *
.text$mn:000018F3                 lea     ecx, [ebp+var_1]
.text$mn:000018F6                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000018FB                 mov     ecx, [ebp+var_8]
.text$mn:000018FE                 mov     edx, [ecx]
.text$mn:00001900                 mov     eax, [ebp+var_8]
.text$mn:00001903                 mov     [edx], eax
.text$mn:00001905                 mov     esp, ebp
.text$mn:00001907                 pop     ebp
.text$mn:00001908                 retn
.text$mn:00001908 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001908
.text$mn:00001908 ; ---------------------------------------------------------------------------
.text$mn:00001909                 align 4
.text$mn:00001909 _text$mn        ends
.text$mn:00001909
.text$mn:0000190C ; ===========================================================================
.text$mn:0000190C
.text$mn:0000190C ; Segment type: Pure code
.text$mn:0000190C ; Segment permissions: Read/Execute
.text$mn:0000190C _text$mn        segment para public 'CODE' use32
.text$mn:0000190C                 assume cs:_text$mn
.text$mn:0000190C                 ;org 190Ch
.text$mn:0000190C ; COMDAT (pick any)
.text$mn:0000190C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000190C
.text$mn:0000190C ; =============== S U B R O U T I N E =======================================
.text$mn:0000190C
.text$mn:0000190C ; Attributes: bp-based frame
.text$mn:0000190C
.text$mn:0000190C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:0000190C                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000190C ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:0000190C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:0000190C
.text$mn:0000190C var_20          = dword ptr -20h
.text$mn:0000190C var_1C          = dword ptr -1Ch
.text$mn:0000190C var_18          = dword ptr -18h
.text$mn:0000190C var_11          = byte ptr -11h
.text$mn:0000190C var_10          = dword ptr -10h
.text$mn:0000190C var_C           = byte ptr -0Ch
.text$mn:0000190C var_4           = dword ptr -4
.text$mn:0000190C arg_0           = dword ptr  8
.text$mn:0000190C
.text$mn:0000190C ; FUNCTION CHUNK AT .text$mn:00001A2E SIZE 00000009 BYTES
.text$mn:0000190C
.text$mn:0000190C                 push    ebp
.text$mn:0000190D                 mov     ebp, esp
.text$mn:0000190F                 push    0FFFFFFFFh
.text$mn:00001911                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001916                 mov     eax, large fs:0
.text$mn:0000191C                 push    eax
.text$mn:0000191D                 push    ecx
.text$mn:0000191E                 sub     esp, 10h
.text$mn:00001921                 push    ebx
.text$mn:00001922                 push    esi
.text$mn:00001923                 push    edi
.text$mn:00001924                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001929                 xor     eax, ebp
.text$mn:0000192B                 push    eax
.text$mn:0000192C                 lea     eax, [ebp+var_C]
.text$mn:0000192F                 mov     large fs:0, eax
.text$mn:00001935                 mov     [ebp+var_10], esp
.text$mn:00001938                 mov     [ebp+var_18], ecx
.text$mn:0000193B                 mov     eax, [ebp+arg_0]
.text$mn:0000193E                 or      eax, 0Fh
.text$mn:00001941                 mov     [ebp+var_1C], eax
.text$mn:00001944                 mov     ecx, [ebp+var_18]
.text$mn:00001947                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000194C                 cmp     eax, [ebp+var_1C]
.text$mn:0000194F                 jnb     short loc_1959
.text$mn:00001951                 mov     ecx, [ebp+arg_0]
.text$mn:00001954                 mov     [ebp+var_1C], ecx
.text$mn:00001957                 jmp     short loc_19AB
.text$mn:00001959 ; ---------------------------------------------------------------------------
.text$mn:00001959
.text$mn:00001959 loc_1959:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00001959                 mov     edx, [ebp+var_18]
.text$mn:0000195C                 mov     ecx, [edx+18h]
.text$mn:0000195F                 shr     ecx, 1
.text$mn:00001961                 mov     eax, [ebp+var_1C]
.text$mn:00001964                 xor     edx, edx
.text$mn:00001966                 mov     esi, 3
.text$mn:0000196B                 div     esi
.text$mn:0000196D                 cmp     ecx, eax
.text$mn:0000196F                 ja      short loc_1973
.text$mn:00001971                 jmp     short loc_19AB
.text$mn:00001973 ; ---------------------------------------------------------------------------
.text$mn:00001973
.text$mn:00001973 loc_1973:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00001973                 mov     ecx, [ebp+var_18]
.text$mn:00001976                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000197B                 mov     edx, [ebp+var_18]
.text$mn:0000197E                 mov     ecx, [edx+18h]
.text$mn:00001981                 shr     ecx, 1
.text$mn:00001983                 sub     eax, ecx
.text$mn:00001985                 mov     edx, [ebp+var_18]
.text$mn:00001988                 cmp     [edx+18h], eax
.text$mn:0000198B                 ja      short loc_19A0
.text$mn:0000198D                 mov     eax, [ebp+var_18]
.text$mn:00001990                 mov     ecx, [eax+18h]
.text$mn:00001993                 shr     ecx, 1
.text$mn:00001995                 mov     edx, [ebp+var_18]
.text$mn:00001998                 add     ecx, [edx+18h]
.text$mn:0000199B                 mov     [ebp+var_1C], ecx
.text$mn:0000199E                 jmp     short loc_19AB
.text$mn:000019A0 ; ---------------------------------------------------------------------------
.text$mn:000019A0
.text$mn:000019A0 loc_19A0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:000019A0                 mov     ecx, [ebp+var_18]
.text$mn:000019A3                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000019A8                 mov     [ebp+var_1C], eax
.text$mn:000019AB
.text$mn:000019AB loc_19AB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:000019AB                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:000019AB                 mov     [ebp+var_4], 0
.text$mn:000019B2                 mov     eax, [ebp+var_1C]
.text$mn:000019B5                 add     eax, 1
.text$mn:000019B8                 push    eax
.text$mn:000019B9                 lea     ecx, [ebp+var_11]
.text$mn:000019BC                 push    ecx
.text$mn:000019BD                 mov     ecx, [ebp+var_18]
.text$mn:000019C0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000019C5                 mov     ecx, eax
.text$mn:000019C7                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000019CC                 mov     [ebp+var_20], eax
.text$mn:000019CF                 jmp     short loc_1A2E
.text$mn:000019CF ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:000019CF
.text$mn:000019D1
.text$mn:000019D1 ; =============== S U B R O U T I N E =======================================
.text$mn:000019D1
.text$mn:000019D1
.text$mn:000019D1 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:000019D1                                         ; DATA XREF: .xdata$x:000027D4o
.text$mn:000019D1
.text$mn:000019D1 ; FUNCTION CHUNK AT .text$mn:00001A18 SIZE 00000009 BYTES
.text$mn:000019D1 ; FUNCTION CHUNK AT .text$mn:00001A28 SIZE 00000006 BYTES
.text$mn:000019D1
.text$mn:000019D1                 mov     [ebp-10h], esp
.text$mn:000019D4                 mov     edx, [ebp+8]
.text$mn:000019D7                 mov     [ebp-1Ch], edx
.text$mn:000019DA                 mov     byte ptr [ebp-4], 2
.text$mn:000019DE                 mov     eax, [ebp-1Ch]
.text$mn:000019E1                 add     eax, 1
.text$mn:000019E4                 push    eax
.text$mn:000019E5                 lea     ecx, [ebp-12h]
.text$mn:000019E8                 push    ecx
.text$mn:000019E9                 mov     ecx, [ebp-18h]
.text$mn:000019EC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000019F1                 mov     ecx, eax
.text$mn:000019F3                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000019F8                 mov     [ebp-20h], eax
.text$mn:000019FB                 jmp     short loc_1A18
.text$mn:000019FB __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:000019FB
.text$mn:000019FD
.text$mn:000019FD ; =============== S U B R O U T I N E =======================================
.text$mn:000019FD
.text$mn:000019FD ; Attributes: noreturn
.text$mn:000019FD
.text$mn:000019FD __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:000019FD                                         ; DATA XREF: .xdata$x:000027E4o
.text$mn:000019FD                 push    0               ; Size
.text$mn:000019FF                 push    1               ; char
.text$mn:00001A01                 mov     ecx, [ebp-18h]
.text$mn:00001A04                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001A09                 push    0
.text$mn:00001A0B                 push    0
.text$mn:00001A0D                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001A0D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00001A0D
.text$mn:00001A12 ; ---------------------------------------------------------------------------
.text$mn:00001A12                 mov     eax, offset $LN17
.text$mn:00001A17                 retn
.text$mn:00001A18 ; ---------------------------------------------------------------------------
.text$mn:00001A18 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001A18
.text$mn:00001A18 loc_1A18:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00001A18                 mov     dword ptr [ebp-4], 1
.text$mn:00001A1F                 jmp     short loc_1A28
.text$mn:00001A1F ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001A21
.text$mn:00001A21 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A21
.text$mn:00001A21
.text$mn:00001A21 $LN17           proc near               ; DATA XREF: .text$mn:00001A12o
.text$mn:00001A21                 mov     dword ptr [ebp-4], 1
.text$mn:00001A21 $LN17           endp ; sp-analysis failed
.text$mn:00001A21
.text$mn:00001A28 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001A28
.text$mn:00001A28 loc_1A28:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00001A28                 mov     eax, offset $LN19
.text$mn:00001A2D                 retn
.text$mn:00001A2D ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001A2E ; ---------------------------------------------------------------------------
.text$mn:00001A2E ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001A2E
.text$mn:00001A2E loc_1A2E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00001A2E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A35                 jmp     short loc_1A3E
.text$mn:00001A35 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001A37
.text$mn:00001A37 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A37
.text$mn:00001A37
.text$mn:00001A37 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_1A28o
.text$mn:00001A37                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001A3E
.text$mn:00001A3E loc_1A3E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00001A3E                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00001A42                 jbe     short loc_1A5D
.text$mn:00001A44                 mov     edx, [ebp+0Ch]
.text$mn:00001A47                 push    edx             ; Size
.text$mn:00001A48                 mov     ecx, [ebp-18h]
.text$mn:00001A4B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001A50                 push    eax             ; Src
.text$mn:00001A51                 mov     eax, [ebp-20h]
.text$mn:00001A54                 push    eax             ; Dst
.text$mn:00001A55                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001A5A                 add     esp, 0Ch
.text$mn:00001A5D
.text$mn:00001A5D loc_1A5D:                               ; CODE XREF: $LN19+Bj
.text$mn:00001A5D                 push    0               ; Size
.text$mn:00001A5F                 push    1               ; char
.text$mn:00001A61                 mov     ecx, [ebp-18h]
.text$mn:00001A64                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001A69                 lea     ecx, [ebp-20h]
.text$mn:00001A6C                 push    ecx             ; int
.text$mn:00001A6D                 mov     edx, [ebp-18h]
.text$mn:00001A70                 add     edx, 4
.text$mn:00001A73                 push    edx             ; void *
.text$mn:00001A74                 lea     eax, [ebp-13h]
.text$mn:00001A77                 push    eax
.text$mn:00001A78                 mov     ecx, [ebp-18h]
.text$mn:00001A7B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001A80                 mov     ecx, eax
.text$mn:00001A82                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001A87                 mov     ecx, [ebp-18h]
.text$mn:00001A8A                 mov     edx, [ebp-1Ch]
.text$mn:00001A8D                 mov     [ecx+18h], edx
.text$mn:00001A90                 mov     eax, [ebp+0Ch]
.text$mn:00001A93                 push    eax
.text$mn:00001A94                 mov     ecx, [ebp-18h]
.text$mn:00001A97                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001A9C                 mov     ecx, [ebp-0Ch]
.text$mn:00001A9F                 mov     large fs:0, ecx
.text$mn:00001AA6                 pop     ecx
.text$mn:00001AA7                 pop     edi
.text$mn:00001AA8                 pop     esi
.text$mn:00001AA9                 pop     ebx
.text$mn:00001AAA                 mov     esp, ebp
.text$mn:00001AAC                 pop     ebp
.text$mn:00001AAD                 retn    8
.text$mn:00001AAD $LN19           endp ; sp-analysis failed
.text$mn:00001AAD
.text$mn:00001AAD _text$mn        ends
.text$mn:00001AAD
.text$x:00001AB0 ; ===========================================================================
.text$x:00001AB0
.text$x:00001AB0 ; Segment type: Pure code
.text$x:00001AB0 ; Segment permissions: Read/Execute
.text$x:00001AB0 _text$x         segment para public 'CODE' use32
.text$x:00001AB0                 assume cs:_text$x
.text$x:00001AB0                 ;org 1AB0h
.text$x:00001AB0 ; COMDAT (pick associative to section at 190C)
.text$x:00001AB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001AB0
.text$x:00001AB0 ; =============== S U B R O U T I N E =======================================
.text$x:00001AB0
.text$x:00001AB0
.text$x:00001AB0 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00001AB0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00001AB0
.text$x:00001AB0 arg_4           = dword ptr  8
.text$x:00001AB0
.text$x:00001AB0                 mov     edx, [esp+arg_4]
.text$x:00001AB4                 lea     eax, [edx+0Ch]
.text$x:00001AB7                 mov     ecx, [edx-24h]
.text$x:00001ABA                 xor     ecx, eax
.text$x:00001ABC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001AC1                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00001AC6                 jmp     ___CxxFrameHandler3
.text$x:00001AC6 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00001AC6
.text$x:00001AC6 ; ---------------------------------------------------------------------------
.text$x:00001ACB                 align 4
.text$x:00001ACB _text$x         ends
.text$x:00001ACB
.text$mn:00001ACC ; ===========================================================================
.text$mn:00001ACC
.text$mn:00001ACC ; Segment type: Pure code
.text$mn:00001ACC ; Segment permissions: Read/Execute
.text$mn:00001ACC _text$mn        segment para public 'CODE' use32
.text$mn:00001ACC                 assume cs:_text$mn
.text$mn:00001ACC                 ;org 1ACCh
.text$mn:00001ACC ; COMDAT (pick any)
.text$mn:00001ACC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001ACC
.text$mn:00001ACC ; =============== S U B R O U T I N E =======================================
.text$mn:00001ACC
.text$mn:00001ACC ; Attributes: bp-based frame
.text$mn:00001ACC
.text$mn:00001ACC ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00001ACC                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00001ACC ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00001ACC                                         ; CODE XREF: $LN19+60p
.text$mn:00001ACC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00001ACC
.text$mn:00001ACC var_8           = dword ptr -8
.text$mn:00001ACC var_1           = byte ptr -1
.text$mn:00001ACC arg_0           = dword ptr  8
.text$mn:00001ACC
.text$mn:00001ACC                 push    ebp
.text$mn:00001ACD                 mov     ebp, esp
.text$mn:00001ACF                 sub     esp, 8
.text$mn:00001AD2                 mov     [ebp+var_8], ecx
.text$mn:00001AD5                 mov     [ebp+var_1], 0
.text$mn:00001AD9                 mov     eax, [ebp+var_8]
.text$mn:00001ADC                 mov     ecx, [ebp+arg_0]
.text$mn:00001ADF                 mov     [eax+14h], ecx
.text$mn:00001AE2                 lea     edx, [ebp+var_1]
.text$mn:00001AE5                 push    edx
.text$mn:00001AE6                 mov     ecx, [ebp+var_8]
.text$mn:00001AE9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001AEE                 add     eax, [ebp+arg_0]
.text$mn:00001AF1                 push    eax
.text$mn:00001AF2                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00001AF7                 add     esp, 8
.text$mn:00001AFA                 mov     esp, ebp
.text$mn:00001AFC                 pop     ebp
.text$mn:00001AFD                 retn    4
.text$mn:00001AFD ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00001AFD
.text$mn:00001AFD _text$mn        ends
.text$mn:00001AFD
.text$mn:00001B00 ; ===========================================================================
.text$mn:00001B00
.text$mn:00001B00 ; Segment type: Pure code
.text$mn:00001B00 ; Segment permissions: Read/Execute
.text$mn:00001B00 _text$mn        segment para public 'CODE' use32
.text$mn:00001B00                 assume cs:_text$mn
.text$mn:00001B00                 ;org 1B00h
.text$mn:00001B00 ; COMDAT (pick any)
.text$mn:00001B00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B00
.text$mn:00001B00 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B00
.text$mn:00001B00 ; Attributes: bp-based frame
.text$mn:00001B00
.text$mn:00001B00 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001B00                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001B00 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001B00                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00001B00
.text$mn:00001B00 var_8           = dword ptr -8
.text$mn:00001B00 var_1           = byte ptr -1
.text$mn:00001B00
.text$mn:00001B00                 push    ebp
.text$mn:00001B01                 mov     ebp, esp
.text$mn:00001B03                 sub     esp, 8
.text$mn:00001B06                 mov     [ebp+var_8], ecx
.text$mn:00001B09                 lea     ecx, [ebp+var_1]
.text$mn:00001B0C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001B11                 mov     ecx, [ebp+var_8] ; this
.text$mn:00001B14                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001B19                 mov     eax, [ebp+var_8]
.text$mn:00001B1C                 mov     ecx, [eax]
.text$mn:00001B1E                 push    ecx
.text$mn:00001B1F                 lea     ecx, [ebp+var_1]
.text$mn:00001B22                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00001B27                 push    1               ; int
.text$mn:00001B29                 mov     edx, [ebp+var_8]
.text$mn:00001B2C                 mov     eax, [edx]
.text$mn:00001B2E                 push    eax             ; void *
.text$mn:00001B2F                 lea     ecx, [ebp+var_1]
.text$mn:00001B32                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00001B37                 mov     ecx, [ebp+var_8]
.text$mn:00001B3A                 mov     dword ptr [ecx], 0
.text$mn:00001B40                 mov     esp, ebp
.text$mn:00001B42                 pop     ebp
.text$mn:00001B43                 retn
.text$mn:00001B43 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001B43
.text$mn:00001B43 _text$mn        ends
.text$mn:00001B43
.text$mn:00001B44 ; ===========================================================================
.text$mn:00001B44
.text$mn:00001B44 ; Segment type: Pure code
.text$mn:00001B44 ; Segment permissions: Read/Execute
.text$mn:00001B44 _text$mn        segment para public 'CODE' use32
.text$mn:00001B44                 assume cs:_text$mn
.text$mn:00001B44                 ;org 1B44h
.text$mn:00001B44 ; COMDAT (pick any)
.text$mn:00001B44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B44
.text$mn:00001B44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B44
.text$mn:00001B44 ; Attributes: bp-based frame
.text$mn:00001B44
.text$mn:00001B44 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00001B44                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00001B44 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00001B44                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00001B44                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00001B44
.text$mn:00001B44 var_4           = dword ptr -4
.text$mn:00001B44 arg_0           = dword ptr  8
.text$mn:00001B44
.text$mn:00001B44                 push    ebp
.text$mn:00001B45                 mov     ebp, esp
.text$mn:00001B47                 push    ecx
.text$mn:00001B48                 mov     [ebp+var_4], ecx
.text$mn:00001B4B                 mov     ecx, [ebp+arg_0]
.text$mn:00001B4E                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00001B53                 mov     eax, [ebp+arg_0]
.text$mn:00001B56                 mov     esp, ebp
.text$mn:00001B58                 pop     ebp
.text$mn:00001B59                 retn    4
.text$mn:00001B59 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00001B59
.text$mn:00001B59 _text$mn        ends
.text$mn:00001B59
.text$mn:00001B5C ; ===========================================================================
.text$mn:00001B5C
.text$mn:00001B5C ; Segment type: Pure code
.text$mn:00001B5C ; Segment permissions: Read/Execute
.text$mn:00001B5C _text$mn        segment para public 'CODE' use32
.text$mn:00001B5C                 assume cs:_text$mn
.text$mn:00001B5C                 ;org 1B5Ch
.text$mn:00001B5C ; COMDAT (pick any)
.text$mn:00001B5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B5C
.text$mn:00001B5C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B5C
.text$mn:00001B5C ; Attributes: bp-based frame
.text$mn:00001B5C
.text$mn:00001B5C ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00001B5C                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00001B5C ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00001B5C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00001B5C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00001B5C
.text$mn:00001B5C var_C           = dword ptr -0Ch
.text$mn:00001B5C Size            = dword ptr -8
.text$mn:00001B5C var_4           = dword ptr -4
.text$mn:00001B5C arg_0           = dword ptr  8
.text$mn:00001B5C arg_4           = byte ptr  0Ch
.text$mn:00001B5C
.text$mn:00001B5C                 push    ebp
.text$mn:00001B5D                 mov     ebp, esp
.text$mn:00001B5F                 sub     esp, 0Ch
.text$mn:00001B62                 mov     [ebp+var_4], ecx
.text$mn:00001B65                 mov     ecx, [ebp+var_4]
.text$mn:00001B68                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001B6D                 cmp     eax, [ebp+arg_0]
.text$mn:00001B70                 jnb     short loc_1B7A
.text$mn:00001B72                 mov     ecx, [ebp+var_4]
.text$mn:00001B75                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00001B7A
.text$mn:00001B7A loc_1B7A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00001B7A                 mov     eax, [ebp+var_4]
.text$mn:00001B7D                 mov     ecx, [eax+18h]
.text$mn:00001B80                 cmp     ecx, [ebp+arg_0]
.text$mn:00001B83                 jnb     short loc_1B9A
.text$mn:00001B85                 mov     edx, [ebp+var_4]
.text$mn:00001B88                 mov     eax, [edx+14h]
.text$mn:00001B8B                 push    eax
.text$mn:00001B8C                 mov     ecx, [ebp+arg_0]
.text$mn:00001B8F                 push    ecx
.text$mn:00001B90                 mov     ecx, [ebp+var_4]
.text$mn:00001B93                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00001B98                 jmp     short loc_1BE4
.text$mn:00001B9A ; ---------------------------------------------------------------------------
.text$mn:00001B9A
.text$mn:00001B9A loc_1B9A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00001B9A                 movzx   edx, [ebp+arg_4]
.text$mn:00001B9E                 test    edx, edx
.text$mn:00001BA0                 jz      short loc_1BD4
.text$mn:00001BA2                 cmp     [ebp+arg_0], 10h
.text$mn:00001BA6                 jnb     short loc_1BD4
.text$mn:00001BA8                 mov     eax, [ebp+var_4]
.text$mn:00001BAB                 mov     ecx, [ebp+arg_0]
.text$mn:00001BAE                 cmp     ecx, [eax+14h]
.text$mn:00001BB1                 jnb     short loc_1BBB
.text$mn:00001BB3                 mov     edx, [ebp+arg_0]
.text$mn:00001BB6                 mov     [ebp+Size], edx
.text$mn:00001BB9                 jmp     short loc_1BC4
.text$mn:00001BBB ; ---------------------------------------------------------------------------
.text$mn:00001BBB
.text$mn:00001BBB loc_1BBB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00001BBB                 mov     eax, [ebp+var_4]
.text$mn:00001BBE                 mov     ecx, [eax+14h]
.text$mn:00001BC1                 mov     [ebp+Size], ecx
.text$mn:00001BC4
.text$mn:00001BC4 loc_1BC4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00001BC4                 mov     edx, [ebp+Size]
.text$mn:00001BC7                 push    edx             ; Size
.text$mn:00001BC8                 push    1               ; char
.text$mn:00001BCA                 mov     ecx, [ebp+var_4]
.text$mn:00001BCD                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001BD2                 jmp     short loc_1BE4
.text$mn:00001BD4 ; ---------------------------------------------------------------------------
.text$mn:00001BD4
.text$mn:00001BD4 loc_1BD4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00001BD4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00001BD4                 cmp     [ebp+arg_0], 0
.text$mn:00001BD8                 jnz     short loc_1BE4
.text$mn:00001BDA                 push    0
.text$mn:00001BDC                 mov     ecx, [ebp+var_4]
.text$mn:00001BDF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001BE4
.text$mn:00001BE4 loc_1BE4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00001BE4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00001BE4                 cmp     [ebp+arg_0], 0
.text$mn:00001BE8                 jbe     short loc_1BF3
.text$mn:00001BEA                 mov     [ebp+var_C], 1
.text$mn:00001BF1                 jmp     short loc_1BFA
.text$mn:00001BF3 ; ---------------------------------------------------------------------------
.text$mn:00001BF3
.text$mn:00001BF3 loc_1BF3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00001BF3                 mov     [ebp+var_C], 0
.text$mn:00001BFA
.text$mn:00001BFA loc_1BFA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00001BFA                 mov     al, byte ptr [ebp+var_C]
.text$mn:00001BFD                 mov     esp, ebp
.text$mn:00001BFF                 pop     ebp
.text$mn:00001C00                 retn    8
.text$mn:00001C00 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00001C00
.text$mn:00001C00 ; ---------------------------------------------------------------------------
.text$mn:00001C03                 align 4
.text$mn:00001C03 _text$mn        ends
.text$mn:00001C03
.text$mn:00001C04 ; ===========================================================================
.text$mn:00001C04
.text$mn:00001C04 ; Segment type: Pure code
.text$mn:00001C04 ; Segment permissions: Read/Execute
.text$mn:00001C04 _text$mn        segment para public 'CODE' use32
.text$mn:00001C04                 assume cs:_text$mn
.text$mn:00001C04                 ;org 1C04h
.text$mn:00001C04 ; COMDAT (pick any)
.text$mn:00001C04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C04
.text$mn:00001C04 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C04
.text$mn:00001C04 ; Attributes: bp-based frame
.text$mn:00001C04
.text$mn:00001C04 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00001C04                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00001C04 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00001C04                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00001C04
.text$mn:00001C04 var_4           = dword ptr -4
.text$mn:00001C04 arg_0           = dword ptr  8
.text$mn:00001C04
.text$mn:00001C04                 push    ebp
.text$mn:00001C05                 mov     ebp, esp
.text$mn:00001C07                 push    ecx
.text$mn:00001C08                 mov     [ebp+var_4], ecx
.text$mn:00001C0B                 cmp     [ebp+arg_0], 0
.text$mn:00001C0F                 jz      short loc_1C31
.text$mn:00001C11                 mov     ecx, [ebp+var_4]
.text$mn:00001C14                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001C19                 cmp     [ebp+arg_0], eax
.text$mn:00001C1C                 jb      short loc_1C31
.text$mn:00001C1E                 mov     ecx, [ebp+var_4]
.text$mn:00001C21                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001C26                 mov     ecx, [ebp+var_4]
.text$mn:00001C29                 add     eax, [ecx+14h]
.text$mn:00001C2C                 cmp     eax, [ebp+arg_0]
.text$mn:00001C2F                 ja      short loc_1C37
.text$mn:00001C31
.text$mn:00001C31 loc_1C31:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00001C31                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00001C31                 xor     al, al
.text$mn:00001C33                 jmp     short loc_1C39
.text$mn:00001C35 ; ---------------------------------------------------------------------------
.text$mn:00001C35                 jmp     short loc_1C39
.text$mn:00001C37 ; ---------------------------------------------------------------------------
.text$mn:00001C37
.text$mn:00001C37 loc_1C37:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00001C37                 mov     al, 1
.text$mn:00001C39
.text$mn:00001C39 loc_1C39:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00001C39                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00001C39                 mov     esp, ebp
.text$mn:00001C3B                 pop     ebp
.text$mn:00001C3C                 retn    4
.text$mn:00001C3C ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00001C3C
.text$mn:00001C3C ; ---------------------------------------------------------------------------
.text$mn:00001C3F                 align 10h
.text$mn:00001C3F _text$mn        ends
.text$mn:00001C3F
.text$mn:00001C40 ; ===========================================================================
.text$mn:00001C40
.text$mn:00001C40 ; Segment type: Pure code
.text$mn:00001C40 ; Segment permissions: Read/Execute
.text$mn:00001C40 _text$mn        segment para public 'CODE' use32
.text$mn:00001C40                 assume cs:_text$mn
.text$mn:00001C40                 ;org 1C40h
.text$mn:00001C40 ; COMDAT (pick any)
.text$mn:00001C40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C40
.text$mn:00001C40 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C40
.text$mn:00001C40 ; Attributes: bp-based frame
.text$mn:00001C40
.text$mn:00001C40 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001C40                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00001C40 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00001C40                                         ; CODE XREF: $LN19+14p
.text$mn:00001C40                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00001C40
.text$mn:00001C40 var_8           = dword ptr -8
.text$mn:00001C40 var_4           = dword ptr -4
.text$mn:00001C40
.text$mn:00001C40                 push    ebp
.text$mn:00001C41                 mov     ebp, esp
.text$mn:00001C43                 sub     esp, 8
.text$mn:00001C46                 mov     [ebp+var_4], ecx
.text$mn:00001C49                 mov     eax, [ebp+var_4]
.text$mn:00001C4C                 cmp     dword ptr [eax+18h], 10h
.text$mn:00001C50                 jb      short loc_1C66
.text$mn:00001C52                 mov     ecx, [ebp+var_4]
.text$mn:00001C55                 mov     edx, [ecx+4]
.text$mn:00001C58                 push    edx
.text$mn:00001C59                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001C5E                 add     esp, 4
.text$mn:00001C61                 mov     [ebp+var_8], eax
.text$mn:00001C64                 jmp     short loc_1C6F
.text$mn:00001C66 ; ---------------------------------------------------------------------------
.text$mn:00001C66
.text$mn:00001C66 loc_1C66:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00001C66                 mov     eax, [ebp+var_4]
.text$mn:00001C69                 add     eax, 4
.text$mn:00001C6C                 mov     [ebp+var_8], eax
.text$mn:00001C6F
.text$mn:00001C6F loc_1C6F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00001C6F                 mov     eax, [ebp+var_8]
.text$mn:00001C72                 mov     esp, ebp
.text$mn:00001C74                 pop     ebp
.text$mn:00001C75                 retn
.text$mn:00001C75 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00001C75
.text$mn:00001C75 ; ---------------------------------------------------------------------------
.text$mn:00001C76                 align 4
.text$mn:00001C76 _text$mn        ends
.text$mn:00001C76
.text$mn:00001C78 ; ===========================================================================
.text$mn:00001C78
.text$mn:00001C78 ; Segment type: Pure code
.text$mn:00001C78 ; Segment permissions: Read/Execute
.text$mn:00001C78 _text$mn        segment para public 'CODE' use32
.text$mn:00001C78                 assume cs:_text$mn
.text$mn:00001C78                 ;org 1C78h
.text$mn:00001C78 ; COMDAT (pick any)
.text$mn:00001C78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C78
.text$mn:00001C78 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C78
.text$mn:00001C78 ; Attributes: bp-based frame
.text$mn:00001C78
.text$mn:00001C78 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00001C78                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00001C78 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00001C78                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00001C78
.text$mn:00001C78 var_8           = dword ptr -8
.text$mn:00001C78 var_4           = dword ptr -4
.text$mn:00001C78
.text$mn:00001C78                 push    ebp
.text$mn:00001C79                 mov     ebp, esp
.text$mn:00001C7B                 sub     esp, 8
.text$mn:00001C7E                 mov     [ebp+var_4], ecx
.text$mn:00001C81                 mov     eax, [ebp+var_4]
.text$mn:00001C84                 cmp     dword ptr [eax+18h], 10h
.text$mn:00001C88                 jb      short loc_1C9E
.text$mn:00001C8A                 mov     ecx, [ebp+var_4]
.text$mn:00001C8D                 mov     edx, [ecx+4]
.text$mn:00001C90                 push    edx
.text$mn:00001C91                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001C96                 add     esp, 4
.text$mn:00001C99                 mov     [ebp+var_8], eax
.text$mn:00001C9C                 jmp     short loc_1CA7
.text$mn:00001C9E ; ---------------------------------------------------------------------------
.text$mn:00001C9E
.text$mn:00001C9E loc_1C9E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00001C9E                 mov     eax, [ebp+var_4]
.text$mn:00001CA1                 add     eax, 4
.text$mn:00001CA4                 mov     [ebp+var_8], eax
.text$mn:00001CA7
.text$mn:00001CA7 loc_1CA7:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00001CA7                 mov     eax, [ebp+var_8]
.text$mn:00001CAA                 mov     esp, ebp
.text$mn:00001CAC                 pop     ebp
.text$mn:00001CAD                 retn
.text$mn:00001CAD ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00001CAD
.text$mn:00001CAD ; ---------------------------------------------------------------------------
.text$mn:00001CAE                 align 10h
.text$mn:00001CAE _text$mn        ends
.text$mn:00001CAE
.text$mn:00001CB0 ; ===========================================================================
.text$mn:00001CB0
.text$mn:00001CB0 ; Segment type: Pure code
.text$mn:00001CB0 ; Segment permissions: Read/Execute
.text$mn:00001CB0 _text$mn        segment para public 'CODE' use32
.text$mn:00001CB0                 assume cs:_text$mn
.text$mn:00001CB0                 ;org 1CB0h
.text$mn:00001CB0 ; COMDAT (pick any)
.text$mn:00001CB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CB0
.text$mn:00001CB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CB0
.text$mn:00001CB0 ; Attributes: bp-based frame
.text$mn:00001CB0
.text$mn:00001CB0 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00001CB0                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001CB0 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00001CB0                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00001CB0                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:00001CB0
.text$mn:00001CB0 var_18          = byte ptr -18h
.text$mn:00001CB0 var_14          = dword ptr -14h
.text$mn:00001CB0 var_10          = dword ptr -10h
.text$mn:00001CB0 var_C           = dword ptr -0Ch
.text$mn:00001CB0 var_4           = dword ptr -4
.text$mn:00001CB0
.text$mn:00001CB0                 push    ebp
.text$mn:00001CB1                 mov     ebp, esp
.text$mn:00001CB3                 push    0FFFFFFFFh
.text$mn:00001CB5                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001CBA                 mov     eax, large fs:0
.text$mn:00001CC0                 push    eax
.text$mn:00001CC1                 sub     esp, 0Ch
.text$mn:00001CC4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001CC9                 xor     eax, ebp
.text$mn:00001CCB                 push    eax
.text$mn:00001CCC                 lea     eax, [ebp+var_C]
.text$mn:00001CCF                 mov     large fs:0, eax
.text$mn:00001CD5                 mov     [ebp+var_14], ecx
.text$mn:00001CD8                 mov     eax, [ebp+var_14]
.text$mn:00001CDB                 cmp     dword ptr [eax], 0
.text$mn:00001CDE                 jz      short loc_1D3B
.text$mn:00001CE0                 push    3               ; int
.text$mn:00001CE2                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001CE5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00001CEA                 mov     [ebp+var_4], 0
.text$mn:00001CF1                 mov     ecx, [ebp+var_14]
.text$mn:00001CF4                 mov     edx, [ecx]
.text$mn:00001CF6                 add     edx, 4
.text$mn:00001CF9                 mov     [ebp+var_10], edx
.text$mn:00001CFC                 jmp     short loc_1D0B
.text$mn:00001CFE ; ---------------------------------------------------------------------------
.text$mn:00001CFE
.text$mn:00001CFE loc_1CFE:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00001CFE                 mov     eax, [ebp+var_10]
.text$mn:00001D01                 mov     ecx, [eax]
.text$mn:00001D03                 mov     edx, [ebp+var_10]
.text$mn:00001D06                 mov     eax, [ecx+4]
.text$mn:00001D09                 mov     [edx], eax
.text$mn:00001D0B
.text$mn:00001D0B loc_1D0B:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00001D0B                 mov     ecx, [ebp+var_10]
.text$mn:00001D0E                 cmp     dword ptr [ecx], 0
.text$mn:00001D11                 jz      short loc_1D20
.text$mn:00001D13                 mov     edx, [ebp+var_10]
.text$mn:00001D16                 mov     eax, [edx]
.text$mn:00001D18                 mov     dword ptr [eax], 0
.text$mn:00001D1E                 jmp     short loc_1CFE
.text$mn:00001D20 ; ---------------------------------------------------------------------------
.text$mn:00001D20
.text$mn:00001D20 loc_1D20:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00001D20                 mov     ecx, [ebp+var_14]
.text$mn:00001D23                 mov     edx, [ecx]
.text$mn:00001D25                 mov     dword ptr [edx+4], 0
.text$mn:00001D2C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001D33                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001D36                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00001D3B
.text$mn:00001D3B loc_1D3B:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00001D3B                 mov     ecx, [ebp+var_C]
.text$mn:00001D3E                 mov     large fs:0, ecx
.text$mn:00001D45                 pop     ecx
.text$mn:00001D46                 mov     esp, ebp
.text$mn:00001D48                 pop     ebp
.text$mn:00001D49                 retn
.text$mn:00001D49 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00001D49
.text$mn:00001D49 ; ---------------------------------------------------------------------------
.text$mn:00001D4A                 align 4
.text$mn:00001D4A _text$mn        ends
.text$mn:00001D4A
.text$x:00001D4C ; ===========================================================================
.text$x:00001D4C
.text$x:00001D4C ; Segment type: Pure code
.text$x:00001D4C ; Segment permissions: Read/Execute
.text$x:00001D4C _text$x         segment para public 'CODE' use32
.text$x:00001D4C                 assume cs:_text$x
.text$x:00001D4C                 ;org 1D4Ch
.text$x:00001D4C ; COMDAT (pick associative to section at 1CB0)
.text$x:00001D4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001D4C
.text$x:00001D4C ; =============== S U B R O U T I N E =======================================
.text$x:00001D4C
.text$x:00001D4C
.text$x:00001D4C __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00001D4C                                         ; DATA XREF: .xdata$x:00002698o
.text$x:00001D4C                 lea     ecx, [ebp-18h]  ; this
.text$x:00001D4F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00001D4F __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00001D4F
.text$x:00001D54
.text$x:00001D54 ; =============== S U B R O U T I N E =======================================
.text$x:00001D54
.text$x:00001D54
.text$x:00001D54 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00001D54                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00001D54
.text$x:00001D54 arg_4           = dword ptr  8
.text$x:00001D54
.text$x:00001D54                 mov     edx, [esp+arg_4]
.text$x:00001D58                 lea     eax, [edx+0Ch]
.text$x:00001D5B                 mov     ecx, [edx-10h]
.text$x:00001D5E                 xor     ecx, eax
.text$x:00001D60                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001D65                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00001D6A                 jmp     ___CxxFrameHandler3
.text$x:00001D6A __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00001D6A
.text$x:00001D6A ; ---------------------------------------------------------------------------
.text$x:00001D6F                 align 10h
.text$x:00001D6F _text$x         ends
.text$x:00001D6F
.text$mn:00001D70 ; ===========================================================================
.text$mn:00001D70
.text$mn:00001D70 ; Segment type: Pure code
.text$mn:00001D70 ; Segment permissions: Read/Execute
.text$mn:00001D70 _text$mn        segment para public 'CODE' use32
.text$mn:00001D70                 assume cs:_text$mn
.text$mn:00001D70                 ;org 1D70h
.text$mn:00001D70 ; COMDAT (pick any)
.text$mn:00001D70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D70
.text$mn:00001D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D70
.text$mn:00001D70 ; Attributes: bp-based frame
.text$mn:00001D70
.text$mn:00001D70 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00001D70                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00001D70 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00001D70                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00001D70                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00001D70
.text$mn:00001D70 var_C           = dword ptr -0Ch
.text$mn:00001D70 var_8           = dword ptr -8
.text$mn:00001D70 var_2           = byte ptr -2
.text$mn:00001D70 var_1           = byte ptr -1
.text$mn:00001D70 arg_0           = byte ptr  8
.text$mn:00001D70 Size            = dword ptr  0Ch
.text$mn:00001D70
.text$mn:00001D70                 push    ebp
.text$mn:00001D71                 mov     ebp, esp
.text$mn:00001D73                 sub     esp, 0Ch
.text$mn:00001D76                 mov     [ebp+var_8], ecx
.text$mn:00001D79                 movzx   eax, [ebp+arg_0]
.text$mn:00001D7D                 test    eax, eax
.text$mn:00001D7F                 jnz     short loc_1D83
.text$mn:00001D81                 jmp     short loc_1DF6
.text$mn:00001D83 ; ---------------------------------------------------------------------------
.text$mn:00001D83
.text$mn:00001D83 loc_1D83:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00001D83                 mov     ecx, [ebp+var_8]
.text$mn:00001D86                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00001D8A                 jb      short loc_1DF6
.text$mn:00001D8C                 mov     edx, [ebp+var_8]
.text$mn:00001D8F                 mov     eax, [edx+4]
.text$mn:00001D92                 mov     [ebp+var_C], eax
.text$mn:00001D95                 mov     ecx, [ebp+var_8]
.text$mn:00001D98                 add     ecx, 4
.text$mn:00001D9B                 push    ecx
.text$mn:00001D9C                 lea     edx, [ebp+var_1]
.text$mn:00001D9F                 push    edx
.text$mn:00001DA0                 mov     ecx, [ebp+var_8]
.text$mn:00001DA3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001DA8                 mov     ecx, eax
.text$mn:00001DAA                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001DAF                 cmp     [ebp+Size], 0
.text$mn:00001DB3                 jbe     short loc_1DD5
.text$mn:00001DB5                 mov     eax, [ebp+Size]
.text$mn:00001DB8                 push    eax             ; Size
.text$mn:00001DB9                 mov     ecx, [ebp+var_C]
.text$mn:00001DBC                 push    ecx
.text$mn:00001DBD                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001DC2                 add     esp, 4
.text$mn:00001DC5                 push    eax             ; Src
.text$mn:00001DC6                 mov     edx, [ebp+var_8]
.text$mn:00001DC9                 add     edx, 4
.text$mn:00001DCC                 push    edx             ; Dst
.text$mn:00001DCD                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001DD2                 add     esp, 0Ch
.text$mn:00001DD5
.text$mn:00001DD5 loc_1DD5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00001DD5                 mov     eax, [ebp+var_8]
.text$mn:00001DD8                 mov     ecx, [eax+18h]
.text$mn:00001DDB                 add     ecx, 1
.text$mn:00001DDE                 push    ecx             ; int
.text$mn:00001DDF                 mov     edx, [ebp+var_C]
.text$mn:00001DE2                 push    edx             ; void *
.text$mn:00001DE3                 lea     eax, [ebp+var_2]
.text$mn:00001DE6                 push    eax
.text$mn:00001DE7                 mov     ecx, [ebp+var_8]
.text$mn:00001DEA                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001DEF                 mov     ecx, eax
.text$mn:00001DF1                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00001DF6
.text$mn:00001DF6 loc_1DF6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00001DF6                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00001DF6                 mov     ecx, [ebp+var_8]
.text$mn:00001DF9                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00001E00                 mov     edx, [ebp+Size]
.text$mn:00001E03                 push    edx
.text$mn:00001E04                 mov     ecx, [ebp+var_8]
.text$mn:00001E07                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001E0C                 mov     esp, ebp
.text$mn:00001E0E                 pop     ebp
.text$mn:00001E0F                 retn    8
.text$mn:00001E0F ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00001E0F
.text$mn:00001E0F ; ---------------------------------------------------------------------------
.text$mn:00001E12                 align 4
.text$mn:00001E12 _text$mn        ends
.text$mn:00001E12
.text$mn:00001E14 ; ===========================================================================
.text$mn:00001E14
.text$mn:00001E14 ; Segment type: Pure code
.text$mn:00001E14 ; Segment permissions: Read/Execute
.text$mn:00001E14 _text$mn        segment para public 'CODE' use32
.text$mn:00001E14                 assume cs:_text$mn
.text$mn:00001E14                 ;org 1E14h
.text$mn:00001E14 ; COMDAT (pick any)
.text$mn:00001E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E14
.text$mn:00001E14 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E14
.text$mn:00001E14 ; Attributes: bp-based frame
.text$mn:00001E14
.text$mn:00001E14 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00001E14                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001E14 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001E14                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00001E14
.text$mn:00001E14 var_4           = dword ptr -4
.text$mn:00001E14
.text$mn:00001E14                 push    ebp
.text$mn:00001E15                 mov     ebp, esp
.text$mn:00001E17                 push    ecx
.text$mn:00001E18                 mov     [ebp+var_4], ecx
.text$mn:00001E1B                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00001E20                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00001E25                 mov     esp, ebp
.text$mn:00001E27                 pop     ebp
.text$mn:00001E28                 retn
.text$mn:00001E28 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001E28
.text$mn:00001E28 ; ---------------------------------------------------------------------------
.text$mn:00001E29                 align 4
.text$mn:00001E29 _text$mn        ends
.text$mn:00001E29
.text$mn:00001E2C ; ===========================================================================
.text$mn:00001E2C
.text$mn:00001E2C ; Segment type: Pure code
.text$mn:00001E2C ; Segment permissions: Read/Execute
.text$mn:00001E2C _text$mn        segment para public 'CODE' use32
.text$mn:00001E2C                 assume cs:_text$mn
.text$mn:00001E2C                 ;org 1E2Ch
.text$mn:00001E2C ; COMDAT (pick any)
.text$mn:00001E2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E2C
.text$mn:00001E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E2C
.text$mn:00001E2C ; Attributes: bp-based frame
.text$mn:00001E2C
.text$mn:00001E2C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00001E2C                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001E2C ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001E2C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00001E2C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00001E2C
.text$mn:00001E2C var_4           = dword ptr -4
.text$mn:00001E2C
.text$mn:00001E2C                 push    ebp
.text$mn:00001E2D                 mov     ebp, esp
.text$mn:00001E2F                 push    ecx
.text$mn:00001E30                 mov     [ebp+var_4], ecx
.text$mn:00001E33                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00001E38                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00001E3D                 mov     esp, ebp
.text$mn:00001E3F                 pop     ebp
.text$mn:00001E40                 retn
.text$mn:00001E40 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001E40
.text$mn:00001E40 ; ---------------------------------------------------------------------------
.text$mn:00001E41                 align 4
.text$mn:00001E41 _text$mn        ends
.text$mn:00001E41
.text$mn:00001E44 ; ===========================================================================
.text$mn:00001E44
.text$mn:00001E44 ; Segment type: Pure code
.text$mn:00001E44 ; Segment permissions: Read/Execute
.text$mn:00001E44 _text$mn        segment para public 'CODE' use32
.text$mn:00001E44                 assume cs:_text$mn
.text$mn:00001E44                 ;org 1E44h
.text$mn:00001E44 ; COMDAT (pick any)
.text$mn:00001E44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E44
.text$mn:00001E44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E44
.text$mn:00001E44 ; Attributes: bp-based frame
.text$mn:00001E44
.text$mn:00001E44 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00001E44                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00001E44 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00001E44                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00001E44                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00001E44
.text$mn:00001E44 var_4           = dword ptr -4
.text$mn:00001E44 arg_0           = dword ptr  8
.text$mn:00001E44
.text$mn:00001E44                 push    ebp
.text$mn:00001E45                 mov     ebp, esp
.text$mn:00001E47                 push    ecx
.text$mn:00001E48                 mov     [ebp+var_4], ecx
.text$mn:00001E4B                 mov     eax, [ebp+arg_0]
.text$mn:00001E4E                 push    eax
.text$mn:00001E4F                 mov     ecx, [ebp+var_4]
.text$mn:00001E52                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00001E57                 mov     esp, ebp
.text$mn:00001E59                 pop     ebp
.text$mn:00001E5A                 retn    4
.text$mn:00001E5A ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00001E5A
.text$mn:00001E5A ; ---------------------------------------------------------------------------
.text$mn:00001E5D                 align 10h
.text$mn:00001E5D _text$mn        ends
.text$mn:00001E5D
.text$mn:00001E60 ; ===========================================================================
.text$mn:00001E60
.text$mn:00001E60 ; Segment type: Pure code
.text$mn:00001E60 ; Segment permissions: Read/Execute
.text$mn:00001E60 _text$mn        segment para public 'CODE' use32
.text$mn:00001E60                 assume cs:_text$mn
.text$mn:00001E60                 ;org 1E60h
.text$mn:00001E60 ; COMDAT (pick any)
.text$mn:00001E60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E60
.text$mn:00001E60 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E60
.text$mn:00001E60 ; Attributes: bp-based frame
.text$mn:00001E60
.text$mn:00001E60 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00001E60                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00001E60 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00001E60                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00001E60
.text$mn:00001E60 var_4           = dword ptr -4
.text$mn:00001E60 arg_0           = dword ptr  8
.text$mn:00001E60
.text$mn:00001E60                 push    ebp
.text$mn:00001E61                 mov     ebp, esp
.text$mn:00001E63                 push    ecx
.text$mn:00001E64                 mov     [ebp+var_4], ecx
.text$mn:00001E67                 push    0
.text$mn:00001E69                 mov     eax, [ebp+arg_0]
.text$mn:00001E6C                 push    eax
.text$mn:00001E6D                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00001E72                 add     esp, 8
.text$mn:00001E75                 mov     esp, ebp
.text$mn:00001E77                 pop     ebp
.text$mn:00001E78                 retn    4
.text$mn:00001E78 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00001E78
.text$mn:00001E78 ; ---------------------------------------------------------------------------
.text$mn:00001E7B                 align 4
.text$mn:00001E7B _text$mn        ends
.text$mn:00001E7B
.text$mn:00001E7C ; ===========================================================================
.text$mn:00001E7C
.text$mn:00001E7C ; Segment type: Pure code
.text$mn:00001E7C ; Segment permissions: Read/Execute
.text$mn:00001E7C _text$mn        segment para public 'CODE' use32
.text$mn:00001E7C                 assume cs:_text$mn
.text$mn:00001E7C                 ;org 1E7Ch
.text$mn:00001E7C ; COMDAT (pick any)
.text$mn:00001E7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E7C
.text$mn:00001E7C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E7C
.text$mn:00001E7C ; Attributes: bp-based frame
.text$mn:00001E7C
.text$mn:00001E7C ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00001E7C                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00001E7C ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00001E7C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00001E7C
.text$mn:00001E7C var_4           = dword ptr -4
.text$mn:00001E7C arg_0           = dword ptr  8
.text$mn:00001E7C
.text$mn:00001E7C                 push    ebp
.text$mn:00001E7D                 mov     ebp, esp
.text$mn:00001E7F                 push    ecx
.text$mn:00001E80                 mov     [ebp+var_4], ecx
.text$mn:00001E83                 push    0
.text$mn:00001E85                 mov     eax, [ebp+arg_0]
.text$mn:00001E88                 push    eax
.text$mn:00001E89                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00001E8E                 add     esp, 8
.text$mn:00001E91                 mov     esp, ebp
.text$mn:00001E93                 pop     ebp
.text$mn:00001E94                 retn    4
.text$mn:00001E94 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00001E94
.text$mn:00001E94 ; ---------------------------------------------------------------------------
.text$mn:00001E97                 align 4
.text$mn:00001E97 _text$mn        ends
.text$mn:00001E97
.text$mn:00001E98 ; ===========================================================================
.text$mn:00001E98
.text$mn:00001E98 ; Segment type: Pure code
.text$mn:00001E98 ; Segment permissions: Read/Execute
.text$mn:00001E98 _text$mn        segment para public 'CODE' use32
.text$mn:00001E98                 assume cs:_text$mn
.text$mn:00001E98                 ;org 1E98h
.text$mn:00001E98 ; COMDAT (pick any)
.text$mn:00001E98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E98
.text$mn:00001E98 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E98
.text$mn:00001E98 ; Attributes: bp-based frame
.text$mn:00001E98
.text$mn:00001E98 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00001E98                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00001E98 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00001E98                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00001E98
.text$mn:00001E98 Size            = dword ptr -8
.text$mn:00001E98 var_4           = dword ptr -4
.text$mn:00001E98 arg_0           = dword ptr  8
.text$mn:00001E98 arg_4           = dword ptr  0Ch
.text$mn:00001E98 arg_8           = dword ptr  10h
.text$mn:00001E98
.text$mn:00001E98                 push    ebp
.text$mn:00001E99                 mov     ebp, esp
.text$mn:00001E9B                 sub     esp, 8
.text$mn:00001E9E                 mov     [ebp+var_4], ecx
.text$mn:00001EA1                 mov     ecx, [ebp+arg_0]
.text$mn:00001EA4                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001EA9                 cmp     eax, [ebp+arg_4]
.text$mn:00001EAC                 jnb     short loc_1EB6
.text$mn:00001EAE                 mov     ecx, [ebp+var_4]
.text$mn:00001EB1                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001EB6
.text$mn:00001EB6 loc_1EB6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00001EB6                 mov     ecx, [ebp+arg_0]
.text$mn:00001EB9                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001EBE                 sub     eax, [ebp+arg_4]
.text$mn:00001EC1                 mov     [ebp+Size], eax
.text$mn:00001EC4                 mov     eax, [ebp+arg_8]
.text$mn:00001EC7                 cmp     eax, [ebp+Size]
.text$mn:00001ECA                 jnb     short loc_1ED2
.text$mn:00001ECC                 mov     ecx, [ebp+arg_8]
.text$mn:00001ECF                 mov     [ebp+Size], ecx
.text$mn:00001ED2
.text$mn:00001ED2 loc_1ED2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00001ED2                 mov     edx, [ebp+var_4]
.text$mn:00001ED5                 cmp     edx, [ebp+arg_0]
.text$mn:00001ED8                 jnz     short loc_1EF9
.text$mn:00001EDA                 mov     eax, [ebp+arg_4]
.text$mn:00001EDD                 add     eax, [ebp+Size]
.text$mn:00001EE0                 push    eax
.text$mn:00001EE1                 mov     ecx, [ebp+var_4]
.text$mn:00001EE4                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00001EE9                 mov     ecx, [ebp+arg_4]
.text$mn:00001EEC                 push    ecx
.text$mn:00001EED                 push    0
.text$mn:00001EEF                 mov     ecx, [ebp+var_4]
.text$mn:00001EF2                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00001EF7                 jmp     short loc_1F3B
.text$mn:00001EF9 ; ---------------------------------------------------------------------------
.text$mn:00001EF9
.text$mn:00001EF9 loc_1EF9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00001EF9                 push    0
.text$mn:00001EFB                 mov     edx, [ebp+Size]
.text$mn:00001EFE                 push    edx
.text$mn:00001EFF                 mov     ecx, [ebp+var_4]
.text$mn:00001F02                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001F07                 movzx   eax, al
.text$mn:00001F0A                 test    eax, eax
.text$mn:00001F0C                 jz      short loc_1F3B
.text$mn:00001F0E                 mov     ecx, [ebp+Size]
.text$mn:00001F11                 push    ecx             ; Size
.text$mn:00001F12                 mov     ecx, [ebp+arg_0]
.text$mn:00001F15                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001F1A                 add     eax, [ebp+arg_4]
.text$mn:00001F1D                 push    eax             ; Src
.text$mn:00001F1E                 mov     ecx, [ebp+var_4]
.text$mn:00001F21                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001F26                 push    eax             ; Dst
.text$mn:00001F27                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001F2C                 add     esp, 0Ch
.text$mn:00001F2F                 mov     edx, [ebp+Size]
.text$mn:00001F32                 push    edx
.text$mn:00001F33                 mov     ecx, [ebp+var_4]
.text$mn:00001F36                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001F3B
.text$mn:00001F3B loc_1F3B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00001F3B                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00001F3B                 mov     eax, [ebp+var_4]
.text$mn:00001F3E                 mov     esp, ebp
.text$mn:00001F40                 pop     ebp
.text$mn:00001F41                 retn    0Ch
.text$mn:00001F41 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00001F41
.text$mn:00001F41 _text$mn        ends
.text$mn:00001F41
.text$mn:00001F44 ; ===========================================================================
.text$mn:00001F44
.text$mn:00001F44 ; Segment type: Pure code
.text$mn:00001F44 ; Segment permissions: Read/Execute
.text$mn:00001F44 _text$mn        segment para public 'CODE' use32
.text$mn:00001F44                 assume cs:_text$mn
.text$mn:00001F44                 ;org 1F44h
.text$mn:00001F44 ; COMDAT (pick any)
.text$mn:00001F44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F44
.text$mn:00001F44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F44
.text$mn:00001F44 ; Attributes: bp-based frame
.text$mn:00001F44
.text$mn:00001F44 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00001F44                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00001F44 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00001F44                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00001F44
.text$mn:00001F44 var_4           = dword ptr -4
.text$mn:00001F44 Str             = dword ptr  8
.text$mn:00001F44
.text$mn:00001F44                 push    ebp
.text$mn:00001F45                 mov     ebp, esp
.text$mn:00001F47                 push    ecx
.text$mn:00001F48                 mov     [ebp+var_4], ecx
.text$mn:00001F4B                 push    490h            ; unsigned int
.text$mn:00001F50                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001F55                 mov     eax, [ebp+Str]
.text$mn:00001F58                 push    eax             ; int
.text$mn:00001F59                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001F5E                 add     esp, 0Ch
.text$mn:00001F61                 mov     ecx, [ebp+Str]
.text$mn:00001F64                 push    ecx             ; Str
.text$mn:00001F65                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00001F6A                 add     esp, 4
.text$mn:00001F6D                 push    eax             ; Size
.text$mn:00001F6E                 mov     edx, [ebp+Str]
.text$mn:00001F71                 push    edx             ; Src
.text$mn:00001F72                 mov     ecx, [ebp+var_4]
.text$mn:00001F75                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00001F7A                 mov     esp, ebp
.text$mn:00001F7C                 pop     ebp
.text$mn:00001F7D                 retn    4
.text$mn:00001F7D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00001F7D
.text$mn:00001F7D _text$mn        ends
.text$mn:00001F7D
.text$mn:00001F80 ; ===========================================================================
.text$mn:00001F80
.text$mn:00001F80 ; Segment type: Pure code
.text$mn:00001F80 ; Segment permissions: Read/Execute
.text$mn:00001F80 _text$mn        segment para public 'CODE' use32
.text$mn:00001F80                 assume cs:_text$mn
.text$mn:00001F80                 ;org 1F80h
.text$mn:00001F80 ; COMDAT (pick any)
.text$mn:00001F80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F80
.text$mn:00001F80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F80
.text$mn:00001F80 ; Attributes: bp-based frame
.text$mn:00001F80
.text$mn:00001F80 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00001F80                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00001F80 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00001F80                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00001F80
.text$mn:00001F80 var_4           = dword ptr -4
.text$mn:00001F80 Src             = dword ptr  8
.text$mn:00001F80 Size            = dword ptr  0Ch
.text$mn:00001F80
.text$mn:00001F80                 push    ebp
.text$mn:00001F81                 mov     ebp, esp
.text$mn:00001F83                 push    ecx
.text$mn:00001F84                 mov     [ebp+var_4], ecx
.text$mn:00001F87                 cmp     [ebp+Size], 0
.text$mn:00001F8B                 jz      short loc_1FA3
.text$mn:00001F8D                 push    47Fh            ; unsigned int
.text$mn:00001F92                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001F97                 mov     eax, [ebp+Src]
.text$mn:00001F9A                 push    eax             ; int
.text$mn:00001F9B                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001FA0                 add     esp, 0Ch
.text$mn:00001FA3
.text$mn:00001FA3 loc_1FA3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00001FA3                 mov     ecx, [ebp+Src]
.text$mn:00001FA6                 push    ecx
.text$mn:00001FA7                 mov     ecx, [ebp+var_4]
.text$mn:00001FAA                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00001FAF                 movzx   edx, al
.text$mn:00001FB2                 test    edx, edx
.text$mn:00001FB4                 jz      short loc_1FD6
.text$mn:00001FB6                 mov     eax, [ebp+Size]
.text$mn:00001FB9                 push    eax
.text$mn:00001FBA                 mov     ecx, [ebp+var_4]
.text$mn:00001FBD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001FC2                 mov     ecx, [ebp+Src]
.text$mn:00001FC5                 sub     ecx, eax
.text$mn:00001FC7                 push    ecx
.text$mn:00001FC8                 mov     edx, [ebp+var_4]
.text$mn:00001FCB                 push    edx
.text$mn:00001FCC                 mov     ecx, [ebp+var_4]
.text$mn:00001FCF                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00001FD4                 jmp     short loc_2013
.text$mn:00001FD6 ; ---------------------------------------------------------------------------
.text$mn:00001FD6
.text$mn:00001FD6 loc_1FD6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00001FD6                 push    0
.text$mn:00001FD8                 mov     eax, [ebp+Size]
.text$mn:00001FDB                 push    eax
.text$mn:00001FDC                 mov     ecx, [ebp+var_4]
.text$mn:00001FDF                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001FE4                 movzx   ecx, al
.text$mn:00001FE7                 test    ecx, ecx
.text$mn:00001FE9                 jz      short loc_2010
.text$mn:00001FEB                 mov     edx, [ebp+Size]
.text$mn:00001FEE                 push    edx             ; Size
.text$mn:00001FEF                 mov     eax, [ebp+Src]
.text$mn:00001FF2                 push    eax             ; Src
.text$mn:00001FF3                 mov     ecx, [ebp+var_4]
.text$mn:00001FF6                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001FFB                 push    eax             ; Dst
.text$mn:00001FFC                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002001                 add     esp, 0Ch
.text$mn:00002004                 mov     ecx, [ebp+Size]
.text$mn:00002007                 push    ecx
.text$mn:00002008                 mov     ecx, [ebp+var_4]
.text$mn:0000200B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002010
.text$mn:00002010 loc_2010:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00002010                 mov     eax, [ebp+var_4]
.text$mn:00002013
.text$mn:00002013 loc_2013:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00002013                 mov     esp, ebp
.text$mn:00002015                 pop     ebp
.text$mn:00002016                 retn    8
.text$mn:00002016 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00002016
.text$mn:00002016 ; ---------------------------------------------------------------------------
.text$mn:00002019                 align 4
.text$mn:00002019 _text$mn        ends
.text$mn:00002019
.text$mn:0000201C ; ===========================================================================
.text$mn:0000201C
.text$mn:0000201C ; Segment type: Pure code
.text$mn:0000201C ; Segment permissions: Read/Execute
.text$mn:0000201C _text$mn        segment para public 'CODE' use32
.text$mn:0000201C                 assume cs:_text$mn
.text$mn:0000201C                 ;org 201Ch
.text$mn:0000201C ; COMDAT (pick any)
.text$mn:0000201C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000201C
.text$mn:0000201C ; =============== S U B R O U T I N E =======================================
.text$mn:0000201C
.text$mn:0000201C ; Attributes: bp-based frame
.text$mn:0000201C
.text$mn:0000201C ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:0000201C                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:0000201C ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:0000201C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:0000201C
.text$mn:0000201C arg_0           = dword ptr  8
.text$mn:0000201C arg_4           = dword ptr  0Ch
.text$mn:0000201C
.text$mn:0000201C                 push    ebp
.text$mn:0000201D                 mov     ebp, esp
.text$mn:0000201F                 mov     eax, [ebp+arg_0]
.text$mn:00002022                 mov     ecx, [ebp+arg_4]
.text$mn:00002025                 mov     dl, [ecx]
.text$mn:00002027                 mov     [eax], dl
.text$mn:00002029                 pop     ebp
.text$mn:0000202A                 retn
.text$mn:0000202A ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:0000202A
.text$mn:0000202A ; ---------------------------------------------------------------------------
.text$mn:0000202B                 align 4
.text$mn:0000202B _text$mn        ends
.text$mn:0000202B
.text$mn:0000202C ; ===========================================================================
.text$mn:0000202C
.text$mn:0000202C ; Segment type: Pure code
.text$mn:0000202C ; Segment permissions: Read/Execute
.text$mn:0000202C _text$mn        segment para public 'CODE' use32
.text$mn:0000202C                 assume cs:_text$mn
.text$mn:0000202C                 ;org 202Ch
.text$mn:0000202C ; COMDAT (pick any)
.text$mn:0000202C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000202C
.text$mn:0000202C ; =============== S U B R O U T I N E =======================================
.text$mn:0000202C
.text$mn:0000202C ; Attributes: bp-based frame
.text$mn:0000202C
.text$mn:0000202C ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:0000202C                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:0000202C ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000202C                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:0000202C
.text$mn:0000202C var_4           = dword ptr -4
.text$mn:0000202C
.text$mn:0000202C                 push    ebp
.text$mn:0000202D                 mov     ebp, esp
.text$mn:0000202F                 push    ecx
.text$mn:00002030                 mov     [ebp+var_4], ecx
.text$mn:00002033                 mov     eax, [ebp+var_4]
.text$mn:00002036                 mov     eax, [eax+4]
.text$mn:00002039                 mov     esp, ebp
.text$mn:0000203B                 pop     ebp
.text$mn:0000203C                 retn
.text$mn:0000203C ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000203C
.text$mn:0000203C ; ---------------------------------------------------------------------------
.text$mn:0000203D                 align 10h
.text$mn:0000203D _text$mn        ends
.text$mn:0000203D
.text$mn:00002040 ; ===========================================================================
.text$mn:00002040
.text$mn:00002040 ; Segment type: Pure code
.text$mn:00002040 ; Segment permissions: Read/Execute
.text$mn:00002040 _text$mn        segment para public 'CODE' use32
.text$mn:00002040                 assume cs:_text$mn
.text$mn:00002040                 ;org 2040h
.text$mn:00002040 ; COMDAT (pick any)
.text$mn:00002040                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002040
.text$mn:00002040 ; =============== S U B R O U T I N E =======================================
.text$mn:00002040
.text$mn:00002040 ; Attributes: bp-based frame
.text$mn:00002040
.text$mn:00002040 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00002040                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00002040 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00002040                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00002040                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00002040
.text$mn:00002040 var_4           = dword ptr -4
.text$mn:00002040
.text$mn:00002040                 push    ebp
.text$mn:00002041                 mov     ebp, esp
.text$mn:00002043                 push    ecx
.text$mn:00002044                 mov     [ebp+var_4], ecx
.text$mn:00002047                 mov     eax, [ebp+var_4]
.text$mn:0000204A                 mov     eax, [eax+4]
.text$mn:0000204D                 mov     esp, ebp
.text$mn:0000204F                 pop     ebp
.text$mn:00002050                 retn
.text$mn:00002050 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00002050
.text$mn:00002050 ; ---------------------------------------------------------------------------
.text$mn:00002051                 align 4
.text$mn:00002051 _text$mn        ends
.text$mn:00002051
.text$mn:00002054 ; ===========================================================================
.text$mn:00002054
.text$mn:00002054 ; Segment type: Pure code
.text$mn:00002054 ; Segment permissions: Read/Execute
.text$mn:00002054 _text$mn        segment para public 'CODE' use32
.text$mn:00002054                 assume cs:_text$mn
.text$mn:00002054                 ;org 2054h
.text$mn:00002054 ; COMDAT (pick any)
.text$mn:00002054                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002054
.text$mn:00002054 ; =============== S U B R O U T I N E =======================================
.text$mn:00002054
.text$mn:00002054 ; Attributes: bp-based frame
.text$mn:00002054
.text$mn:00002054 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00002054                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002054 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00002054                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00002054
.text$mn:00002054 var_4           = dword ptr -4
.text$mn:00002054 Dst             = dword ptr  8
.text$mn:00002054 Src             = dword ptr  0Ch
.text$mn:00002054 Size            = dword ptr  10h
.text$mn:00002054
.text$mn:00002054                 push    ebp
.text$mn:00002055                 mov     ebp, esp
.text$mn:00002057                 push    ecx
.text$mn:00002058                 cmp     [ebp+Size], 0
.text$mn:0000205C                 jnz     short loc_2066
.text$mn:0000205E                 mov     eax, [ebp+Dst]
.text$mn:00002061                 mov     [ebp+var_4], eax
.text$mn:00002064                 jmp     short loc_207D
.text$mn:00002066 ; ---------------------------------------------------------------------------
.text$mn:00002066
.text$mn:00002066 loc_2066:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00002066                 mov     ecx, [ebp+Size]
.text$mn:00002069                 push    ecx             ; Size
.text$mn:0000206A                 mov     edx, [ebp+Src]
.text$mn:0000206D                 push    edx             ; Src
.text$mn:0000206E                 mov     eax, [ebp+Dst]
.text$mn:00002071                 push    eax             ; Dst
.text$mn:00002072                 call    _memcpy
.text$mn:00002077                 add     esp, 0Ch
.text$mn:0000207A                 mov     [ebp+var_4], eax
.text$mn:0000207D
.text$mn:0000207D loc_207D:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:0000207D                 mov     eax, [ebp+var_4]
.text$mn:00002080                 mov     esp, ebp
.text$mn:00002082                 pop     ebp
.text$mn:00002083                 retn
.text$mn:00002083 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00002083
.text$mn:00002083 _text$mn        ends
.text$mn:00002083
.text$mn:00002084 ; ===========================================================================
.text$mn:00002084
.text$mn:00002084 ; Segment type: Pure code
.text$mn:00002084 ; Segment permissions: Read/Execute
.text$mn:00002084 _text$mn        segment para public 'CODE' use32
.text$mn:00002084                 assume cs:_text$mn
.text$mn:00002084                 ;org 2084h
.text$mn:00002084 ; COMDAT (pick any)
.text$mn:00002084                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002084
.text$mn:00002084 ; =============== S U B R O U T I N E =======================================
.text$mn:00002084
.text$mn:00002084 ; Attributes: bp-based frame
.text$mn:00002084
.text$mn:00002084 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00002084                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00002084 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00002084                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00002084
.text$mn:00002084 var_4           = dword ptr -4
.text$mn:00002084 arg_0           = dword ptr  8
.text$mn:00002084 arg_4           = dword ptr  0Ch
.text$mn:00002084
.text$mn:00002084                 push    ebp
.text$mn:00002085                 mov     ebp, esp
.text$mn:00002087                 push    ecx
.text$mn:00002088                 mov     [ebp+var_4], ecx
.text$mn:0000208B                 mov     eax, [ebp+arg_4]
.text$mn:0000208E                 push    eax             ; int
.text$mn:0000208F                 mov     ecx, [ebp+arg_0]
.text$mn:00002092                 push    ecx             ; void *
.text$mn:00002093                 mov     ecx, [ebp+var_4]
.text$mn:00002096                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000209B                 mov     esp, ebp
.text$mn:0000209D                 pop     ebp
.text$mn:0000209E                 retn    8
.text$mn:0000209E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000209E
.text$mn:0000209E ; ---------------------------------------------------------------------------
.text$mn:000020A1                 align 4
.text$mn:000020A1 _text$mn        ends
.text$mn:000020A1
.text$mn:000020A4 ; ===========================================================================
.text$mn:000020A4
.text$mn:000020A4 ; Segment type: Pure code
.text$mn:000020A4 ; Segment permissions: Read/Execute
.text$mn:000020A4 _text$mn        segment para public 'CODE' use32
.text$mn:000020A4                 assume cs:_text$mn
.text$mn:000020A4                 ;org 20A4h
.text$mn:000020A4 ; COMDAT (pick any)
.text$mn:000020A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020A4
.text$mn:000020A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000020A4
.text$mn:000020A4 ; Attributes: bp-based frame
.text$mn:000020A4
.text$mn:000020A4 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:000020A4                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:000020A4 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:000020A4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:000020A4
.text$mn:000020A4 var_4           = dword ptr -4
.text$mn:000020A4 arg_0           = dword ptr  8
.text$mn:000020A4
.text$mn:000020A4                 push    ebp
.text$mn:000020A5                 mov     ebp, esp
.text$mn:000020A7                 push    ecx
.text$mn:000020A8                 mov     [ebp+var_4], ecx
.text$mn:000020AB                 mov     eax, [ebp+arg_0]
.text$mn:000020AE                 push    eax             ; void *
.text$mn:000020AF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000020B4                 add     esp, 4
.text$mn:000020B7                 mov     esp, ebp
.text$mn:000020B9                 pop     ebp
.text$mn:000020BA                 retn    8
.text$mn:000020BA ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:000020BA
.text$mn:000020BA ; ---------------------------------------------------------------------------
.text$mn:000020BD                 align 10h
.text$mn:000020BD _text$mn        ends
.text$mn:000020BD
.text$mn:000020C0 ; ===========================================================================
.text$mn:000020C0
.text$mn:000020C0 ; Segment type: Pure code
.text$mn:000020C0 ; Segment permissions: Read/Execute
.text$mn:000020C0 _text$mn        segment para public 'CODE' use32
.text$mn:000020C0                 assume cs:_text$mn
.text$mn:000020C0                 ;org 20C0h
.text$mn:000020C0 ; COMDAT (pick any)
.text$mn:000020C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020C0
.text$mn:000020C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000020C0
.text$mn:000020C0 ; Attributes: bp-based frame
.text$mn:000020C0
.text$mn:000020C0 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:000020C0                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:000020C0 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:000020C0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:000020C0
.text$mn:000020C0 var_4           = dword ptr -4
.text$mn:000020C0 arg_0           = dword ptr  8
.text$mn:000020C0
.text$mn:000020C0                 push    ebp
.text$mn:000020C1                 mov     ebp, esp
.text$mn:000020C3                 push    ecx
.text$mn:000020C4                 mov     [ebp+var_4], ecx
.text$mn:000020C7                 mov     eax, [ebp+arg_0]
.text$mn:000020CA                 push    eax             ; void *
.text$mn:000020CB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000020D0                 add     esp, 4
.text$mn:000020D3                 mov     esp, ebp
.text$mn:000020D5                 pop     ebp
.text$mn:000020D6                 retn    8
.text$mn:000020D6 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:000020D6
.text$mn:000020D6 ; ---------------------------------------------------------------------------
.text$mn:000020D9                 align 4
.text$mn:000020D9 _text$mn        ends
.text$mn:000020D9
.text$mn:000020DC ; ===========================================================================
.text$mn:000020DC
.text$mn:000020DC ; Segment type: Pure code
.text$mn:000020DC ; Segment permissions: Read/Execute
.text$mn:000020DC _text$mn        segment para public 'CODE' use32
.text$mn:000020DC                 assume cs:_text$mn
.text$mn:000020DC                 ;org 20DCh
.text$mn:000020DC ; COMDAT (pick any)
.text$mn:000020DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020DC
.text$mn:000020DC ; =============== S U B R O U T I N E =======================================
.text$mn:000020DC
.text$mn:000020DC ; Attributes: bp-based frame
.text$mn:000020DC
.text$mn:000020DC ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:000020DC                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000020DC ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000020DC                                         ; DATA XREF: .rdata:00002BFCo
.text$mn:000020DC
.text$mn:000020DC var_4           = dword ptr -4
.text$mn:000020DC arg_0           = dword ptr  8
.text$mn:000020DC arg_4           = dword ptr  0Ch
.text$mn:000020DC
.text$mn:000020DC                 push    ebp
.text$mn:000020DD                 mov     ebp, esp
.text$mn:000020DF                 push    ecx
.text$mn:000020E0                 mov     [ebp+var_4], ecx
.text$mn:000020E3                 mov     eax, [ebp+arg_4]
.text$mn:000020E6                 push    eax             ; int
.text$mn:000020E7                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000020EC                 add     esp, 4
.text$mn:000020EF                 test    eax, eax
.text$mn:000020F1                 jz      short loc_210C
.text$mn:000020F3                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:000020F8                 push    eax             ; struct std::error_category *
.text$mn:000020F9                 mov     ecx, [ebp+arg_4]
.text$mn:000020FC                 push    ecx             ; int
.text$mn:000020FD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002100                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002105                 mov     eax, [ebp+arg_0]
.text$mn:00002108                 jmp     short loc_2121
.text$mn:0000210A ; ---------------------------------------------------------------------------
.text$mn:0000210A                 jmp     short loc_2121
.text$mn:0000210C ; ---------------------------------------------------------------------------
.text$mn:0000210C
.text$mn:0000210C loc_210C:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:0000210C                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00002111                 push    eax             ; struct std::error_category *
.text$mn:00002112                 mov     edx, [ebp+arg_4]
.text$mn:00002115                 push    edx             ; int
.text$mn:00002116                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002119                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000211E                 mov     eax, [ebp+arg_0]
.text$mn:00002121
.text$mn:00002121 loc_2121:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00002121                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00002121                 mov     esp, ebp
.text$mn:00002123                 pop     ebp
.text$mn:00002124                 retn    8
.text$mn:00002124 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00002124
.text$mn:00002124 ; ---------------------------------------------------------------------------
.text$mn:00002127                 align 4
.text$mn:00002127 _text$mn        ends
.text$mn:00002127
.text$mn:00002128 ; ===========================================================================
.text$mn:00002128
.text$mn:00002128 ; Segment type: Pure code
.text$mn:00002128 ; Segment permissions: Read/Execute
.text$mn:00002128 _text$mn        segment para public 'CODE' use32
.text$mn:00002128                 assume cs:_text$mn
.text$mn:00002128                 ;org 2128h
.text$mn:00002128 ; COMDAT (pick any)
.text$mn:00002128                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002128
.text$mn:00002128 ; =============== S U B R O U T I N E =======================================
.text$mn:00002128
.text$mn:00002128 ; Attributes: bp-based frame
.text$mn:00002128
.text$mn:00002128 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00002128                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002128 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002128                                         ; DATA XREF: .rdata:00002B6Co
.text$mn:00002128                                         ; .rdata:00002B88o ...
.text$mn:00002128
.text$mn:00002128 var_4           = dword ptr -4
.text$mn:00002128 arg_0           = dword ptr  8
.text$mn:00002128 arg_4           = dword ptr  0Ch
.text$mn:00002128
.text$mn:00002128                 push    ebp
.text$mn:00002129                 mov     ebp, esp
.text$mn:0000212B                 push    ecx
.text$mn:0000212C                 mov     [ebp+var_4], ecx
.text$mn:0000212F                 mov     eax, [ebp+var_4]
.text$mn:00002132                 push    eax             ; struct std::error_category *
.text$mn:00002133                 mov     ecx, [ebp+arg_4]
.text$mn:00002136                 push    ecx             ; int
.text$mn:00002137                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000213A                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000213F                 mov     eax, [ebp+arg_0]
.text$mn:00002142                 mov     esp, ebp
.text$mn:00002144                 pop     ebp
.text$mn:00002145                 retn    8
.text$mn:00002145 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00002145
.text$mn:00002145 _text$mn        ends
.text$mn:00002145
.text$mn:00002148 ; ===========================================================================
.text$mn:00002148
.text$mn:00002148 ; Segment type: Pure code
.text$mn:00002148 ; Segment permissions: Read/Execute
.text$mn:00002148 _text$mn        segment para public 'CODE' use32
.text$mn:00002148                 assume cs:_text$mn
.text$mn:00002148                 ;org 2148h
.text$mn:00002148 ; COMDAT (pick any)
.text$mn:00002148                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002148
.text$mn:00002148 ; =============== S U B R O U T I N E =======================================
.text$mn:00002148
.text$mn:00002148 ; Attributes: bp-based frame
.text$mn:00002148
.text$mn:00002148 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00002148                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00002148 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00002148                                         ; DATA XREF: .rdata:00002B70o
.text$mn:00002148                                         ; .rdata:00002B8Co ...
.text$mn:00002148
.text$mn:00002148 var_8           = dword ptr -8
.text$mn:00002148 var_4           = dword ptr -4
.text$mn:00002148 arg_0           = dword ptr  8
.text$mn:00002148 arg_4           = dword ptr  0Ch
.text$mn:00002148
.text$mn:00002148                 push    ebp
.text$mn:00002149                 mov     ebp, esp
.text$mn:0000214B                 sub     esp, 8
.text$mn:0000214E                 mov     [ebp+var_8], ecx
.text$mn:00002151                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002154                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00002159                 push    eax
.text$mn:0000215A                 mov     ecx, [ebp+var_8]
.text$mn:0000215D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00002162                 movzx   eax, al
.text$mn:00002165                 test    eax, eax
.text$mn:00002167                 jz      short loc_217F
.text$mn:00002169                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000216C                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00002171                 cmp     eax, [ebp+arg_4]
.text$mn:00002174                 jnz     short loc_217F
.text$mn:00002176                 mov     [ebp+var_4], 1
.text$mn:0000217D                 jmp     short loc_2186
.text$mn:0000217F ; ---------------------------------------------------------------------------
.text$mn:0000217F
.text$mn:0000217F loc_217F:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000217F                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000217F                 mov     [ebp+var_4], 0
.text$mn:00002186
.text$mn:00002186 loc_2186:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00002186                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002189                 mov     esp, ebp
.text$mn:0000218B                 pop     ebp
.text$mn:0000218C                 retn    8
.text$mn:0000218C ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:0000218C
.text$mn:0000218C ; ---------------------------------------------------------------------------
.text$mn:0000218F                 align 10h
.text$mn:0000218F _text$mn        ends
.text$mn:0000218F
.text$mn:00002190 ; ===========================================================================
.text$mn:00002190
.text$mn:00002190 ; Segment type: Pure code
.text$mn:00002190 ; Segment permissions: Read/Execute
.text$mn:00002190 _text$mn        segment para public 'CODE' use32
.text$mn:00002190                 assume cs:_text$mn
.text$mn:00002190                 ;org 2190h
.text$mn:00002190 ; COMDAT (pick any)
.text$mn:00002190                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002190
.text$mn:00002190 ; =============== S U B R O U T I N E =======================================
.text$mn:00002190
.text$mn:00002190 ; Attributes: bp-based frame
.text$mn:00002190
.text$mn:00002190 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00002190                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00002190 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00002190                                         ; DATA XREF: .rdata:00002B74o
.text$mn:00002190                                         ; .rdata:00002B90o ...
.text$mn:00002190
.text$mn:00002190 var_C           = byte ptr -0Ch
.text$mn:00002190 var_4           = dword ptr -4
.text$mn:00002190 arg_0           = dword ptr  8
.text$mn:00002190 arg_4           = dword ptr  0Ch
.text$mn:00002190
.text$mn:00002190                 push    ebp
.text$mn:00002191                 mov     ebp, esp
.text$mn:00002193                 sub     esp, 0Ch
.text$mn:00002196                 mov     [ebp+var_4], ecx
.text$mn:00002199                 mov     eax, [ebp+arg_4]
.text$mn:0000219C                 push    eax             ; std::error_condition *
.text$mn:0000219D                 mov     ecx, [ebp+arg_0]
.text$mn:000021A0                 push    ecx
.text$mn:000021A1                 lea     edx, [ebp+var_C]
.text$mn:000021A4                 push    edx
.text$mn:000021A5                 mov     eax, [ebp+var_4]
.text$mn:000021A8                 mov     edx, [eax]
.text$mn:000021AA                 mov     ecx, [ebp+var_4]
.text$mn:000021AD                 mov     eax, [edx+0Ch]
.text$mn:000021B0                 call    eax
.text$mn:000021B2                 mov     ecx, eax
.text$mn:000021B4                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:000021B9                 mov     esp, ebp
.text$mn:000021BB                 pop     ebp
.text$mn:000021BC                 retn    8
.text$mn:000021BC ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:000021BC
.text$mn:000021BC ; ---------------------------------------------------------------------------
.text$mn:000021BF                 align 10h
.text$mn:000021BF _text$mn        ends
.text$mn:000021BF
.text$mn:000021C0 ; ===========================================================================
.text$mn:000021C0
.text$mn:000021C0 ; Segment type: Pure code
.text$mn:000021C0 ; Segment permissions: Read/Execute
.text$mn:000021C0 _text$mn        segment para public 'CODE' use32
.text$mn:000021C0                 assume cs:_text$mn
.text$mn:000021C0                 ;org 21C0h
.text$mn:000021C0 ; COMDAT (pick any)
.text$mn:000021C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021C0
.text$mn:000021C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000021C0
.text$mn:000021C0 ; Attributes: bp-based frame
.text$mn:000021C0
.text$mn:000021C0 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:000021C0                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:000021C0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000021C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:000021C0
.text$mn:000021C0 var_4           = dword ptr -4
.text$mn:000021C0 arg_0           = dword ptr  8
.text$mn:000021C0
.text$mn:000021C0                 push    ebp
.text$mn:000021C1                 mov     ebp, esp
.text$mn:000021C3                 push    ecx
.text$mn:000021C4                 mov     [ebp+var_4], ecx
.text$mn:000021C7                 mov     eax, [ebp+var_4]
.text$mn:000021CA                 mov     ecx, [eax+14h]
.text$mn:000021CD                 cmp     ecx, [ebp+arg_0]
.text$mn:000021D0                 jnb     short loc_21DA
.text$mn:000021D2                 mov     ecx, [ebp+var_4]
.text$mn:000021D5                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000021DA
.text$mn:000021DA loc_21DA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:000021DA                 mov     edx, [ebp+arg_0]
.text$mn:000021DD                 push    edx
.text$mn:000021DE                 mov     ecx, [ebp+var_4]
.text$mn:000021E1                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000021E6                 mov     eax, [ebp+var_4]
.text$mn:000021E9                 mov     esp, ebp
.text$mn:000021EB                 pop     ebp
.text$mn:000021EC                 retn    4
.text$mn:000021EC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:000021EC
.text$mn:000021EC ; ---------------------------------------------------------------------------
.text$mn:000021EF                 align 10h
.text$mn:000021EF _text$mn        ends
.text$mn:000021EF
.text$mn:000021F0 ; ===========================================================================
.text$mn:000021F0
.text$mn:000021F0 ; Segment type: Pure code
.text$mn:000021F0 ; Segment permissions: Read/Execute
.text$mn:000021F0 _text$mn        segment para public 'CODE' use32
.text$mn:000021F0                 assume cs:_text$mn
.text$mn:000021F0                 ;org 21F0h
.text$mn:000021F0 ; COMDAT (pick any)
.text$mn:000021F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021F0
.text$mn:000021F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000021F0
.text$mn:000021F0 ; Attributes: bp-based frame
.text$mn:000021F0
.text$mn:000021F0 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:000021F0                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:000021F0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:000021F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:000021F0
.text$mn:000021F0 var_C           = dword ptr -0Ch
.text$mn:000021F0 Dst             = dword ptr -8
.text$mn:000021F0 var_4           = dword ptr -4
.text$mn:000021F0 arg_0           = dword ptr  8
.text$mn:000021F0 arg_4           = dword ptr  0Ch
.text$mn:000021F0
.text$mn:000021F0                 push    ebp
.text$mn:000021F1                 mov     ebp, esp
.text$mn:000021F3                 sub     esp, 0Ch
.text$mn:000021F6                 mov     [ebp+var_4], ecx
.text$mn:000021F9                 mov     eax, [ebp+var_4]
.text$mn:000021FC                 mov     ecx, [eax+14h]
.text$mn:000021FF                 cmp     ecx, [ebp+arg_0]
.text$mn:00002202                 jnb     short loc_220C
.text$mn:00002204                 mov     ecx, [ebp+var_4]
.text$mn:00002207                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000220C
.text$mn:0000220C loc_220C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:0000220C                 mov     edx, [ebp+var_4]
.text$mn:0000220F                 mov     eax, [edx+14h]
.text$mn:00002212                 sub     eax, [ebp+arg_0]
.text$mn:00002215                 cmp     eax, [ebp+arg_4]
.text$mn:00002218                 ja      short loc_2228
.text$mn:0000221A                 mov     ecx, [ebp+arg_0]
.text$mn:0000221D                 push    ecx
.text$mn:0000221E                 mov     ecx, [ebp+var_4]
.text$mn:00002221                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002226                 jmp     short loc_226E
.text$mn:00002228 ; ---------------------------------------------------------------------------
.text$mn:00002228
.text$mn:00002228 loc_2228:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00002228                 cmp     [ebp+arg_4], 0
.text$mn:0000222C                 jbe     short loc_226E
.text$mn:0000222E                 mov     ecx, [ebp+var_4]
.text$mn:00002231                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002236                 add     eax, [ebp+arg_0]
.text$mn:00002239                 mov     [ebp+Dst], eax
.text$mn:0000223C                 mov     edx, [ebp+var_4]
.text$mn:0000223F                 mov     eax, [edx+14h]
.text$mn:00002242                 sub     eax, [ebp+arg_4]
.text$mn:00002245                 mov     [ebp+var_C], eax
.text$mn:00002248                 mov     ecx, [ebp+var_C]
.text$mn:0000224B                 sub     ecx, [ebp+arg_0]
.text$mn:0000224E                 push    ecx             ; Size
.text$mn:0000224F                 mov     edx, [ebp+Dst]
.text$mn:00002252                 add     edx, [ebp+arg_4]
.text$mn:00002255                 push    edx             ; Src
.text$mn:00002256                 mov     eax, [ebp+Dst]
.text$mn:00002259                 push    eax             ; Dst
.text$mn:0000225A                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000225F                 add     esp, 0Ch
.text$mn:00002262                 mov     ecx, [ebp+var_C]
.text$mn:00002265                 push    ecx
.text$mn:00002266                 mov     ecx, [ebp+var_4]
.text$mn:00002269                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000226E
.text$mn:0000226E loc_226E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000226E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000226E                 mov     eax, [ebp+var_4]
.text$mn:00002271                 mov     esp, ebp
.text$mn:00002273                 pop     ebp
.text$mn:00002274                 retn    8
.text$mn:00002274 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00002274
.text$mn:00002274 ; ---------------------------------------------------------------------------
.text$mn:00002277                 align 4
.text$mn:00002277 _text$mn        ends
.text$mn:00002277
.text$mn:00002278 ; ===========================================================================
.text$mn:00002278
.text$mn:00002278 ; Segment type: Pure code
.text$mn:00002278 ; Segment permissions: Read/Execute
.text$mn:00002278 _text$mn        segment para public 'CODE' use32
.text$mn:00002278                 assume cs:_text$mn
.text$mn:00002278                 ;org 2278h
.text$mn:00002278 ; COMDAT (pick any)
.text$mn:00002278                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002278
.text$mn:00002278 ; =============== S U B R O U T I N E =======================================
.text$mn:00002278
.text$mn:00002278 ; Attributes: bp-based frame
.text$mn:00002278
.text$mn:00002278 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00002278                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00002278 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002278                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00002278                 push    ebp
.text$mn:00002279                 mov     ebp, esp
.text$mn:0000227B                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00002280                 pop     ebp
.text$mn:00002281                 retn
.text$mn:00002281 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002281
.text$mn:00002281 ; ---------------------------------------------------------------------------
.text$mn:00002282                 align 4
.text$mn:00002282 _text$mn        ends
.text$mn:00002282
.text$mn:00002284 ; ===========================================================================
.text$mn:00002284
.text$mn:00002284 ; Segment type: Pure code
.text$mn:00002284 ; Segment permissions: Read/Execute
.text$mn:00002284 _text$mn        segment para public 'CODE' use32
.text$mn:00002284                 assume cs:_text$mn
.text$mn:00002284                 ;org 2284h
.text$mn:00002284 ; COMDAT (pick any)
.text$mn:00002284                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002284
.text$mn:00002284 ; =============== S U B R O U T I N E =======================================
.text$mn:00002284
.text$mn:00002284 ; Attributes: bp-based frame
.text$mn:00002284
.text$mn:00002284 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:00002284                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:00002284 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:00002284                                         ; CODE XREF: TaskList::adjustSize(void)+234p
.text$mn:00002284                 push    ebp
.text$mn:00002285                 mov     ebp, esp
.text$mn:00002287                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:0000228C                 pop     ebp
.text$mn:0000228D                 retn
.text$mn:0000228D ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:0000228D
.text$mn:0000228D ; ---------------------------------------------------------------------------
.text$mn:0000228E                 align 10h
.text$mn:0000228E _text$mn        ends
.text$mn:0000228E
.text$mn:00002290 ; ===========================================================================
.text$mn:00002290
.text$mn:00002290 ; Segment type: Pure code
.text$mn:00002290 ; Segment permissions: Read/Execute
.text$mn:00002290 _text$mn        segment para public 'CODE' use32
.text$mn:00002290                 assume cs:_text$mn
.text$mn:00002290                 ;org 2290h
.text$mn:00002290 ; COMDAT (pick any)
.text$mn:00002290                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002290
.text$mn:00002290 ; =============== S U B R O U T I N E =======================================
.text$mn:00002290
.text$mn:00002290 ; Attributes: bp-based frame
.text$mn:00002290
.text$mn:00002290 ; public: enum  winVer __thiscall NppParameters::getWinVersion(void)
.text$mn:00002290                 public ?getWinVersion@NppParameters@@QAE?AW4winVer@@XZ
.text$mn:00002290 ?getWinVersion@NppParameters@@QAE?AW4winVer@@XZ proc near
.text$mn:00002290                                         ; CODE XREF: TaskList::adjustSize(void)+23Bp
.text$mn:00002290
.text$mn:00002290 var_4           = dword ptr -4
.text$mn:00002290
.text$mn:00002290                 push    ebp
.text$mn:00002291                 mov     ebp, esp
.text$mn:00002293                 push    ecx
.text$mn:00002294                 mov     [ebp+var_4], ecx
.text$mn:00002297                 mov     eax, [ebp+var_4]
.text$mn:0000229A                 mov     eax, [eax+1CC1Ch]
.text$mn:000022A0                 mov     esp, ebp
.text$mn:000022A2                 pop     ebp
.text$mn:000022A3                 retn
.text$mn:000022A3 ?getWinVersion@NppParameters@@QAE?AW4winVer@@XZ endp
.text$mn:000022A3
.text$mn:000022A3 _text$mn        ends
.text$mn:000022A3
.text$mn:000022A4 ; ===========================================================================
.text$mn:000022A4
.text$mn:000022A4 ; Segment type: Pure code
.text$mn:000022A4 ; Segment permissions: Read/Execute
.text$mn:000022A4 _text$mn        segment para public 'CODE' use32
.text$mn:000022A4                 assume cs:_text$mn
.text$mn:000022A4                 ;org 22A4h
.text$mn:000022A4 ; COMDAT (pick any)
.text$mn:000022A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022A4
.text$mn:000022A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000022A4
.text$mn:000022A4 ; Attributes: bp-based frame
.text$mn:000022A4
.text$mn:000022A4 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:000022A4                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:000022A4 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:000022A4                                         ; CODE XREF: TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+14p
.text$mn:000022A4
.text$mn:000022A4 var_4           = dword ptr -4
.text$mn:000022A4 arg_0           = dword ptr  8
.text$mn:000022A4 arg_4           = dword ptr  0Ch
.text$mn:000022A4
.text$mn:000022A4                 push    ebp
.text$mn:000022A5                 mov     ebp, esp
.text$mn:000022A7                 push    ecx
.text$mn:000022A8                 mov     [ebp+var_4], ecx
.text$mn:000022AB                 mov     eax, [ebp+var_4]
.text$mn:000022AE                 mov     ecx, [ebp+arg_0]
.text$mn:000022B1                 mov     [eax+4], ecx
.text$mn:000022B4                 mov     edx, [ebp+var_4]
.text$mn:000022B7                 mov     eax, [ebp+arg_4]
.text$mn:000022BA                 mov     [edx+8], eax
.text$mn:000022BD                 mov     esp, ebp
.text$mn:000022BF                 pop     ebp
.text$mn:000022C0                 retn    8
.text$mn:000022C0 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:000022C0
.text$mn:000022C0 ; ---------------------------------------------------------------------------
.text$mn:000022C3                 align 4
.text$mn:000022C3 _text$mn        ends
.text$mn:000022C3
.text$mn:000022C4 ; ===========================================================================
.text$mn:000022C4
.text$mn:000022C4 ; Segment type: Pure code
.text$mn:000022C4 ; Segment permissions: Read/Execute
.text$mn:000022C4 _text$mn        segment para public 'CODE' use32
.text$mn:000022C4                 assume cs:_text$mn
.text$mn:000022C4                 ;org 22C4h
.text$mn:000022C4 ; COMDAT (pick any)
.text$mn:000022C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022C4
.text$mn:000022C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000022C4
.text$mn:000022C4 ; Attributes: bp-based frame
.text$mn:000022C4
.text$mn:000022C4 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:000022C4                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:000022C4 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:000022C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:000022C4
.text$mn:000022C4 var_4           = dword ptr -4
.text$mn:000022C4 Str             = dword ptr  8
.text$mn:000022C4
.text$mn:000022C4                 push    ebp
.text$mn:000022C5                 mov     ebp, esp
.text$mn:000022C7                 push    ecx
.text$mn:000022C8                 mov     eax, [ebp+Str]
.text$mn:000022CB                 movsx   ecx, byte ptr [eax]
.text$mn:000022CE                 test    ecx, ecx
.text$mn:000022D0                 jnz     short loc_22DB
.text$mn:000022D2                 mov     [ebp+var_4], 0
.text$mn:000022D9                 jmp     short loc_22EA
.text$mn:000022DB ; ---------------------------------------------------------------------------
.text$mn:000022DB
.text$mn:000022DB loc_22DB:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:000022DB                 mov     edx, [ebp+Str]
.text$mn:000022DE                 push    edx             ; Str
.text$mn:000022DF                 call    _strlen
.text$mn:000022E4                 add     esp, 4
.text$mn:000022E7                 mov     [ebp+var_4], eax
.text$mn:000022EA
.text$mn:000022EA loc_22EA:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:000022EA                 mov     eax, [ebp+var_4]
.text$mn:000022ED                 mov     esp, ebp
.text$mn:000022EF                 pop     ebp
.text$mn:000022F0                 retn
.text$mn:000022F0 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:000022F0
.text$mn:000022F0 ; ---------------------------------------------------------------------------
.text$mn:000022F1                 align 4
.text$mn:000022F1 _text$mn        ends
.text$mn:000022F1
.text$mn:000022F4 ; ===========================================================================
.text$mn:000022F4
.text$mn:000022F4 ; Segment type: Pure code
.text$mn:000022F4 ; Segment permissions: Read/Execute
.text$mn:000022F4 _text$mn        segment para public 'CODE' use32
.text$mn:000022F4                 assume cs:_text$mn
.text$mn:000022F4                 ;org 22F4h
.text$mn:000022F4 ; COMDAT (pick any)
.text$mn:000022F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022F4
.text$mn:000022F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000022F4
.text$mn:000022F4 ; Attributes: bp-based frame
.text$mn:000022F4
.text$mn:000022F4 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:000022F4                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:000022F4 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:000022F4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:000022F4
.text$mn:000022F4 var_4           = dword ptr -4
.text$mn:000022F4
.text$mn:000022F4                 push    ebp
.text$mn:000022F5                 mov     ebp, esp
.text$mn:000022F7                 push    ecx
.text$mn:000022F8                 mov     [ebp+var_4], ecx
.text$mn:000022FB                 mov     eax, [ebp+var_4]
.text$mn:000022FE                 push    eax
.text$mn:000022FF                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00002304                 add     esp, 4
.text$mn:00002307                 mov     esp, ebp
.text$mn:00002309                 pop     ebp
.text$mn:0000230A                 retn
.text$mn:0000230A ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000230A
.text$mn:0000230A ; ---------------------------------------------------------------------------
.text$mn:0000230B                 align 4
.text$mn:0000230B _text$mn        ends
.text$mn:0000230B
.text$mn:0000230C ; ===========================================================================
.text$mn:0000230C
.text$mn:0000230C ; Segment type: Pure code
.text$mn:0000230C ; Segment permissions: Read/Execute
.text$mn:0000230C _text$mn        segment para public 'CODE' use32
.text$mn:0000230C                 assume cs:_text$mn
.text$mn:0000230C                 ;org 230Ch
.text$mn:0000230C ; COMDAT (pick any)
.text$mn:0000230C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000230C
.text$mn:0000230C ; =============== S U B R O U T I N E =======================================
.text$mn:0000230C
.text$mn:0000230C ; Attributes: bp-based frame
.text$mn:0000230C
.text$mn:0000230C ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:0000230C                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:0000230C ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:0000230C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:0000230C
.text$mn:0000230C var_4           = dword ptr -4
.text$mn:0000230C
.text$mn:0000230C                 push    ebp
.text$mn:0000230D                 mov     ebp, esp
.text$mn:0000230F                 push    ecx
.text$mn:00002310                 mov     [ebp+var_4], ecx
.text$mn:00002313                 or      eax, 0FFFFFFFFh
.text$mn:00002316                 mov     esp, ebp
.text$mn:00002318                 pop     ebp
.text$mn:00002319                 retn
.text$mn:00002319 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00002319
.text$mn:00002319 ; ---------------------------------------------------------------------------
.text$mn:0000231A                 align 4
.text$mn:0000231A _text$mn        ends
.text$mn:0000231A
.text$mn:0000231C ; ===========================================================================
.text$mn:0000231C
.text$mn:0000231C ; Segment type: Pure code
.text$mn:0000231C ; Segment permissions: Read/Execute
.text$mn:0000231C _text$mn        segment para public 'CODE' use32
.text$mn:0000231C                 assume cs:_text$mn
.text$mn:0000231C                 ;org 231Ch
.text$mn:0000231C ; COMDAT (pick any)
.text$mn:0000231C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000231C
.text$mn:0000231C ; =============== S U B R O U T I N E =======================================
.text$mn:0000231C
.text$mn:0000231C ; Attributes: bp-based frame
.text$mn:0000231C
.text$mn:0000231C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:0000231C                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:0000231C ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:0000231C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:0000231C
.text$mn:0000231C arg_0           = dword ptr  8
.text$mn:0000231C
.text$mn:0000231C                 push    ebp
.text$mn:0000231D                 mov     ebp, esp
.text$mn:0000231F                 mov     ecx, [ebp+arg_0]
.text$mn:00002322                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00002327                 pop     ebp
.text$mn:00002328                 retn
.text$mn:00002328 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00002328
.text$mn:00002328 ; ---------------------------------------------------------------------------
.text$mn:00002329                 align 4
.text$mn:00002329 _text$mn        ends
.text$mn:00002329
.text$mn:0000232C ; ===========================================================================
.text$mn:0000232C
.text$mn:0000232C ; Segment type: Pure code
.text$mn:0000232C ; Segment permissions: Read/Execute
.text$mn:0000232C _text$mn        segment para public 'CODE' use32
.text$mn:0000232C                 assume cs:_text$mn
.text$mn:0000232C                 ;org 232Ch
.text$mn:0000232C ; COMDAT (pick any)
.text$mn:0000232C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000232C
.text$mn:0000232C ; =============== S U B R O U T I N E =======================================
.text$mn:0000232C
.text$mn:0000232C ; Attributes: bp-based frame
.text$mn:0000232C
.text$mn:0000232C ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:0000232C                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000232C ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000232C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:0000232C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000232C
.text$mn:0000232C var_10          = dword ptr -10h
.text$mn:0000232C var_C           = dword ptr -0Ch
.text$mn:0000232C var_8           = dword ptr -8
.text$mn:0000232C var_1           = byte ptr -1
.text$mn:0000232C
.text$mn:0000232C                 push    ebp
.text$mn:0000232D                 mov     ebp, esp
.text$mn:0000232F                 sub     esp, 10h
.text$mn:00002332                 mov     [ebp+var_10], ecx
.text$mn:00002335                 lea     eax, [ebp+var_1]
.text$mn:00002338                 push    eax
.text$mn:00002339                 mov     ecx, [ebp+var_10]
.text$mn:0000233C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002341                 mov     ecx, eax
.text$mn:00002343                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00002348                 mov     [ebp+var_8], eax
.text$mn:0000234B                 cmp     [ebp+var_8], 1
.text$mn:0000234F                 ja      short loc_235A
.text$mn:00002351                 mov     [ebp+var_C], 1
.text$mn:00002358                 jmp     short loc_2363
.text$mn:0000235A ; ---------------------------------------------------------------------------
.text$mn:0000235A
.text$mn:0000235A loc_235A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:0000235A                 mov     ecx, [ebp+var_8]
.text$mn:0000235D                 sub     ecx, 1
.text$mn:00002360                 mov     [ebp+var_C], ecx
.text$mn:00002363
.text$mn:00002363 loc_2363:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00002363                 mov     eax, [ebp+var_C]
.text$mn:00002366                 mov     esp, ebp
.text$mn:00002368                 pop     ebp
.text$mn:00002369                 retn
.text$mn:00002369 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002369
.text$mn:00002369 ; ---------------------------------------------------------------------------
.text$mn:0000236A                 align 4
.text$mn:0000236A _text$mn        ends
.text$mn:0000236A
.text$mn:0000236C ; ===========================================================================
.text$mn:0000236C
.text$mn:0000236C ; Segment type: Pure code
.text$mn:0000236C ; Segment permissions: Read/Execute
.text$mn:0000236C _text$mn        segment para public 'CODE' use32
.text$mn:0000236C                 assume cs:_text$mn
.text$mn:0000236C                 ;org 236Ch
.text$mn:0000236C ; COMDAT (pick any)
.text$mn:0000236C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000236C
.text$mn:0000236C ; =============== S U B R O U T I N E =======================================
.text$mn:0000236C
.text$mn:0000236C ; Attributes: bp-based frame
.text$mn:0000236C
.text$mn:0000236C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:0000236C                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000236C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000236C                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:0000236C                                         ; DATA XREF: .rdata:00002B84o
.text$mn:0000236C
.text$mn:0000236C var_1C          = dword ptr -1Ch
.text$mn:0000236C var_18          = dword ptr -18h
.text$mn:0000236C Str             = dword ptr -14h
.text$mn:0000236C var_10          = dword ptr -10h
.text$mn:0000236C var_C           = dword ptr -0Ch
.text$mn:0000236C var_4           = dword ptr -4
.text$mn:0000236C arg_0           = dword ptr  8
.text$mn:0000236C arg_4           = dword ptr  0Ch
.text$mn:0000236C
.text$mn:0000236C                 push    ebp
.text$mn:0000236D                 mov     ebp, esp
.text$mn:0000236F                 push    0FFFFFFFFh
.text$mn:00002371                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002376                 mov     eax, large fs:0
.text$mn:0000237C                 push    eax
.text$mn:0000237D                 sub     esp, 10h
.text$mn:00002380                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002385                 xor     eax, ebp
.text$mn:00002387                 push    eax
.text$mn:00002388                 lea     eax, [ebp+var_C]
.text$mn:0000238B                 mov     large fs:0, eax
.text$mn:00002391                 mov     [ebp+var_1C], ecx
.text$mn:00002394                 mov     [ebp+var_18], 0
.text$mn:0000239B                 mov     eax, [ebp+arg_4]
.text$mn:0000239E                 push    eax             ; int
.text$mn:0000239F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000023A4                 add     esp, 4
.text$mn:000023A7                 mov     [ebp+var_10], eax
.text$mn:000023AA                 cmp     [ebp+var_10], 0
.text$mn:000023AE                 jz      short loc_23B8
.text$mn:000023B0                 mov     ecx, [ebp+var_10]
.text$mn:000023B3                 mov     [ebp+Str], ecx
.text$mn:000023B6                 jmp     short loc_23BF
.text$mn:000023B8 ; ---------------------------------------------------------------------------
.text$mn:000023B8
.text$mn:000023B8 loc_23B8:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:000023B8                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000023BF
.text$mn:000023BF loc_23BF:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:000023BF                 mov     edx, [ebp+Str]
.text$mn:000023C2                 push    edx             ; Str
.text$mn:000023C3                 mov     ecx, [ebp+arg_0]
.text$mn:000023C6                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000023CB                 mov     [ebp+var_4], 0
.text$mn:000023D2                 mov     eax, [ebp+var_18]
.text$mn:000023D5                 or      eax, 1
.text$mn:000023D8                 mov     [ebp+var_18], eax
.text$mn:000023DB                 mov     eax, [ebp+arg_0]
.text$mn:000023DE                 mov     ecx, [ebp+var_C]
.text$mn:000023E1                 mov     large fs:0, ecx
.text$mn:000023E8                 pop     ecx
.text$mn:000023E9                 mov     esp, ebp
.text$mn:000023EB                 pop     ebp
.text$mn:000023EC                 retn    8
.text$mn:000023EC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000023EC
.text$mn:000023EC ; ---------------------------------------------------------------------------
.text$mn:000023EF                 align 10h
.text$mn:000023EF _text$mn        ends
.text$mn:000023EF
.text$x:000023F0 ; ===========================================================================
.text$x:000023F0
.text$x:000023F0 ; Segment type: Pure code
.text$x:000023F0 ; Segment permissions: Read/Execute
.text$x:000023F0 _text$x         segment para public 'CODE' use32
.text$x:000023F0                 assume cs:_text$x
.text$x:000023F0                 ;org 23F0h
.text$x:000023F0 ; COMDAT (pick associative to section at 236C)
.text$x:000023F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000023F0
.text$x:000023F0 ; =============== S U B R O U T I N E =======================================
.text$x:000023F0
.text$x:000023F0
.text$x:000023F0 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000023F0                                         ; DATA XREF: .xdata$x:00002908o
.text$x:000023F0                 mov     eax, [ebp-18h]
.text$x:000023F3                 and     eax, 1
.text$x:000023F6                 jz      $LN6
.text$x:000023FC                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002400                 mov     ecx, [ebp+8]
.text$x:00002403                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002408 ; ---------------------------------------------------------------------------
.text$x:00002408
.text$x:00002408 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002408                 retn
.text$x:00002408 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002408
.text$x:00002409
.text$x:00002409 ; =============== S U B R O U T I N E =======================================
.text$x:00002409
.text$x:00002409
.text$x:00002409 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002409                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00002409
.text$x:00002409 arg_4           = dword ptr  8
.text$x:00002409
.text$x:00002409                 mov     edx, [esp+arg_4]
.text$x:0000240D                 lea     eax, [edx+0Ch]
.text$x:00002410                 mov     ecx, [edx-14h]
.text$x:00002413                 xor     ecx, eax
.text$x:00002415                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000241A                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000241F                 jmp     ___CxxFrameHandler3
.text$x:0000241F __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000241F
.text$x:0000241F _text$x         ends
.text$x:0000241F
.text$mn:00002424 ; ===========================================================================
.text$mn:00002424
.text$mn:00002424 ; Segment type: Pure code
.text$mn:00002424 ; Segment permissions: Read/Execute
.text$mn:00002424 _text$mn        segment para public 'CODE' use32
.text$mn:00002424                 assume cs:_text$mn
.text$mn:00002424                 ;org 2424h
.text$mn:00002424 ; COMDAT (pick any)
.text$mn:00002424                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002424
.text$mn:00002424 ; =============== S U B R O U T I N E =======================================
.text$mn:00002424
.text$mn:00002424 ; Attributes: bp-based frame
.text$mn:00002424
.text$mn:00002424 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00002424                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002424 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002424                                         ; DATA XREF: .rdata:00002BB8o
.text$mn:00002424
.text$mn:00002424 var_14          = dword ptr -14h
.text$mn:00002424 var_10          = dword ptr -10h
.text$mn:00002424 var_C           = dword ptr -0Ch
.text$mn:00002424 var_4           = dword ptr -4
.text$mn:00002424 arg_0           = dword ptr  8
.text$mn:00002424 arg_4           = dword ptr  0Ch
.text$mn:00002424
.text$mn:00002424                 push    ebp
.text$mn:00002425                 mov     ebp, esp
.text$mn:00002427                 push    0FFFFFFFFh
.text$mn:00002429                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000242E                 mov     eax, large fs:0
.text$mn:00002434                 push    eax
.text$mn:00002435                 sub     esp, 8
.text$mn:00002438                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000243D                 xor     eax, ebp
.text$mn:0000243F                 push    eax
.text$mn:00002440                 lea     eax, [ebp+var_C]
.text$mn:00002443                 mov     large fs:0, eax
.text$mn:00002449                 mov     [ebp+var_14], ecx
.text$mn:0000244C                 mov     [ebp+var_10], 0
.text$mn:00002453                 cmp     [ebp+arg_4], 1
.text$mn:00002457                 jnz     short loc_247D
.text$mn:00002459                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:0000245E                 mov     ecx, [ebp+arg_0]
.text$mn:00002461                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002466                 mov     [ebp+var_4], 0
.text$mn:0000246D                 mov     eax, [ebp+var_10]
.text$mn:00002470                 or      eax, 1
.text$mn:00002473                 mov     [ebp+var_10], eax
.text$mn:00002476                 mov     eax, [ebp+arg_0]
.text$mn:00002479                 jmp     short loc_24A0
.text$mn:0000247B ; ---------------------------------------------------------------------------
.text$mn:0000247B                 jmp     short loc_24A0
.text$mn:0000247D ; ---------------------------------------------------------------------------
.text$mn:0000247D
.text$mn:0000247D loc_247D:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:0000247D                 mov     ecx, [ebp+arg_4]
.text$mn:00002480                 push    ecx
.text$mn:00002481                 mov     edx, [ebp+arg_0]
.text$mn:00002484                 push    edx
.text$mn:00002485                 mov     ecx, [ebp+var_14]
.text$mn:00002488                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:0000248D                 mov     [ebp+var_4], 0
.text$mn:00002494                 mov     eax, [ebp+var_10]
.text$mn:00002497                 or      eax, 1
.text$mn:0000249A                 mov     [ebp+var_10], eax
.text$mn:0000249D                 mov     eax, [ebp+arg_0]
.text$mn:000024A0
.text$mn:000024A0 loc_24A0:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:000024A0                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:000024A0                 mov     ecx, [ebp+var_C]
.text$mn:000024A3                 mov     large fs:0, ecx
.text$mn:000024AA                 pop     ecx
.text$mn:000024AB                 mov     esp, ebp
.text$mn:000024AD                 pop     ebp
.text$mn:000024AE                 retn    8
.text$mn:000024AE ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000024AE
.text$mn:000024AE ; ---------------------------------------------------------------------------
.text$mn:000024B1                 align 4
.text$mn:000024B1 _text$mn        ends
.text$mn:000024B1
.text$x:000024B4 ; ===========================================================================
.text$x:000024B4
.text$x:000024B4 ; Segment type: Pure code
.text$x:000024B4 ; Segment permissions: Read/Execute
.text$x:000024B4 _text$x         segment para public 'CODE' use32
.text$x:000024B4                 assume cs:_text$x
.text$x:000024B4                 ;org 24B4h
.text$x:000024B4 ; COMDAT (pick associative to section at 2424)
.text$x:000024B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000024B4
.text$x:000024B4 ; =============== S U B R O U T I N E =======================================
.text$x:000024B4
.text$x:000024B4
.text$x:000024B4 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000024B4                                         ; DATA XREF: .xdata$x:0000298Co
.text$x:000024B4                 mov     eax, [ebp-10h]
.text$x:000024B7                 and     eax, 1
.text$x:000024BA                 jz      $LN6_0
.text$x:000024C0                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000024C4                 mov     ecx, [ebp+8]
.text$x:000024C7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000024CC ; ---------------------------------------------------------------------------
.text$x:000024CC
.text$x:000024CC $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000024CC                 retn
.text$x:000024CC __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000024CC
.text$x:000024CD
.text$x:000024CD ; =============== S U B R O U T I N E =======================================
.text$x:000024CD
.text$x:000024CD
.text$x:000024CD __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000024CD                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:000024CD
.text$x:000024CD arg_4           = dword ptr  8
.text$x:000024CD
.text$x:000024CD                 mov     edx, [esp+arg_4]
.text$x:000024D1                 lea     eax, [edx+0Ch]
.text$x:000024D4                 mov     ecx, [edx-0Ch]
.text$x:000024D7                 xor     ecx, eax
.text$x:000024D9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000024DE                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000024E3                 jmp     ___CxxFrameHandler3
.text$x:000024E3 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000024E3
.text$x:000024E3 _text$x         ends
.text$x:000024E3
.text$mn:000024E8 ; ===========================================================================
.text$mn:000024E8
.text$mn:000024E8 ; Segment type: Pure code
.text$mn:000024E8 ; Segment permissions: Read/Execute
.text$mn:000024E8 _text$mn        segment para public 'CODE' use32
.text$mn:000024E8                 assume cs:_text$mn
.text$mn:000024E8                 ;org 24E8h
.text$mn:000024E8 ; COMDAT (pick any)
.text$mn:000024E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024E8
.text$mn:000024E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000024E8
.text$mn:000024E8 ; Attributes: bp-based frame
.text$mn:000024E8
.text$mn:000024E8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:000024E8                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000024E8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000024E8                                         ; DATA XREF: .rdata:00002BF8o
.text$mn:000024E8
.text$mn:000024E8 var_1C          = dword ptr -1Ch
.text$mn:000024E8 var_18          = dword ptr -18h
.text$mn:000024E8 Str             = dword ptr -14h
.text$mn:000024E8 var_10          = dword ptr -10h
.text$mn:000024E8 var_C           = dword ptr -0Ch
.text$mn:000024E8 var_4           = dword ptr -4
.text$mn:000024E8 arg_0           = dword ptr  8
.text$mn:000024E8 arg_4           = dword ptr  0Ch
.text$mn:000024E8
.text$mn:000024E8                 push    ebp
.text$mn:000024E9                 mov     ebp, esp
.text$mn:000024EB                 push    0FFFFFFFFh
.text$mn:000024ED                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000024F2                 mov     eax, large fs:0
.text$mn:000024F8                 push    eax
.text$mn:000024F9                 sub     esp, 10h
.text$mn:000024FC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002501                 xor     eax, ebp
.text$mn:00002503                 push    eax
.text$mn:00002504                 lea     eax, [ebp+var_C]
.text$mn:00002507                 mov     large fs:0, eax
.text$mn:0000250D                 mov     [ebp+var_1C], ecx
.text$mn:00002510                 mov     [ebp+var_18], 0
.text$mn:00002517                 mov     eax, [ebp+arg_4]
.text$mn:0000251A                 push    eax             ; int
.text$mn:0000251B                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00002520                 add     esp, 4
.text$mn:00002523                 mov     [ebp+var_10], eax
.text$mn:00002526                 cmp     [ebp+var_10], 0
.text$mn:0000252A                 jz      short loc_2534
.text$mn:0000252C                 mov     ecx, [ebp+var_10]
.text$mn:0000252F                 mov     [ebp+Str], ecx
.text$mn:00002532                 jmp     short loc_253B
.text$mn:00002534 ; ---------------------------------------------------------------------------
.text$mn:00002534
.text$mn:00002534 loc_2534:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00002534                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000253B
.text$mn:0000253B loc_253B:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:0000253B                 mov     edx, [ebp+Str]
.text$mn:0000253E                 push    edx             ; Str
.text$mn:0000253F                 mov     ecx, [ebp+arg_0]
.text$mn:00002542                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002547                 mov     [ebp+var_4], 0
.text$mn:0000254E                 mov     eax, [ebp+var_18]
.text$mn:00002551                 or      eax, 1
.text$mn:00002554                 mov     [ebp+var_18], eax
.text$mn:00002557                 mov     eax, [ebp+arg_0]
.text$mn:0000255A                 mov     ecx, [ebp+var_C]
.text$mn:0000255D                 mov     large fs:0, ecx
.text$mn:00002564                 pop     ecx
.text$mn:00002565                 mov     esp, ebp
.text$mn:00002567                 pop     ebp
.text$mn:00002568                 retn    8
.text$mn:00002568 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002568
.text$mn:00002568 ; ---------------------------------------------------------------------------
.text$mn:0000256B                 align 4
.text$mn:0000256B _text$mn        ends
.text$mn:0000256B
.text$x:0000256C ; ===========================================================================
.text$x:0000256C
.text$x:0000256C ; Segment type: Pure code
.text$x:0000256C ; Segment permissions: Read/Execute
.text$x:0000256C _text$x         segment para public 'CODE' use32
.text$x:0000256C                 assume cs:_text$x
.text$x:0000256C                 ;org 256Ch
.text$x:0000256C ; COMDAT (pick associative to section at 24E8)
.text$x:0000256C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000256C
.text$x:0000256C ; =============== S U B R O U T I N E =======================================
.text$x:0000256C
.text$x:0000256C
.text$x:0000256C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000256C                                         ; DATA XREF: .xdata$x:00002A10o
.text$x:0000256C                 mov     eax, [ebp-18h]
.text$x:0000256F                 and     eax, 1
.text$x:00002572                 jz      $LN6_1
.text$x:00002578                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000257C                 mov     ecx, [ebp+8]
.text$x:0000257F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002584 ; ---------------------------------------------------------------------------
.text$x:00002584
.text$x:00002584 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002584                 retn
.text$x:00002584 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002584
.text$x:00002585
.text$x:00002585 ; =============== S U B R O U T I N E =======================================
.text$x:00002585
.text$x:00002585
.text$x:00002585 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002585                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00002585
.text$x:00002585 arg_4           = dword ptr  8
.text$x:00002585
.text$x:00002585                 mov     edx, [esp+arg_4]
.text$x:00002589                 lea     eax, [edx+0Ch]
.text$x:0000258C                 mov     ecx, [edx-14h]
.text$x:0000258F                 xor     ecx, eax
.text$x:00002591                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002596                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000259B                 jmp     ___CxxFrameHandler3
.text$x:0000259B __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000259B
.text$x:0000259B _text$x         ends
.text$x:0000259B
.text$mn:000025A0 ; ===========================================================================
.text$mn:000025A0
.text$mn:000025A0 ; Segment type: Pure code
.text$mn:000025A0 ; Segment permissions: Read/Execute
.text$mn:000025A0 _text$mn        segment para public 'CODE' use32
.text$mn:000025A0                 assume cs:_text$mn
.text$mn:000025A0                 ;org 25A0h
.text$mn:000025A0 ; COMDAT (pick any)
.text$mn:000025A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025A0
.text$mn:000025A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025A0
.text$mn:000025A0 ; Attributes: bp-based frame
.text$mn:000025A0
.text$mn:000025A0 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:000025A0                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000025A0 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:000025A0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:000025A0
.text$mn:000025A0 var_4           = dword ptr -4
.text$mn:000025A0 Dst             = dword ptr  8
.text$mn:000025A0 Src             = dword ptr  0Ch
.text$mn:000025A0 Size            = dword ptr  10h
.text$mn:000025A0
.text$mn:000025A0                 push    ebp
.text$mn:000025A1                 mov     ebp, esp
.text$mn:000025A3                 push    ecx
.text$mn:000025A4                 cmp     [ebp+Size], 0
.text$mn:000025A8                 jnz     short loc_25B2
.text$mn:000025AA                 mov     eax, [ebp+Dst]
.text$mn:000025AD                 mov     [ebp+var_4], eax
.text$mn:000025B0                 jmp     short loc_25C9
.text$mn:000025B2 ; ---------------------------------------------------------------------------
.text$mn:000025B2
.text$mn:000025B2 loc_25B2:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:000025B2                 mov     ecx, [ebp+Size]
.text$mn:000025B5                 push    ecx             ; Size
.text$mn:000025B6                 mov     edx, [ebp+Src]
.text$mn:000025B9                 push    edx             ; Src
.text$mn:000025BA                 mov     eax, [ebp+Dst]
.text$mn:000025BD                 push    eax             ; Dst
.text$mn:000025BE                 call    _memmove
.text$mn:000025C3                 add     esp, 0Ch
.text$mn:000025C6                 mov     [ebp+var_4], eax
.text$mn:000025C9
.text$mn:000025C9 loc_25C9:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:000025C9                 mov     eax, [ebp+var_4]
.text$mn:000025CC                 mov     esp, ebp
.text$mn:000025CE                 pop     ebp
.text$mn:000025CF                 retn
.text$mn:000025CF ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000025CF
.text$mn:000025CF _text$mn        ends
.text$mn:000025CF
.text$mn:000025D0 ; ===========================================================================
.text$mn:000025D0
.text$mn:000025D0 ; Segment type: Pure code
.text$mn:000025D0 ; Segment permissions: Read/Execute
.text$mn:000025D0 _text$mn        segment para public 'CODE' use32
.text$mn:000025D0                 assume cs:_text$mn
.text$mn:000025D0                 ;org 25D0h
.text$mn:000025D0 ; COMDAT (pick any)
.text$mn:000025D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025D0
.text$mn:000025D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025D0
.text$mn:000025D0 ; Attributes: bp-based frame
.text$mn:000025D0
.text$mn:000025D0 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:000025D0                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:000025D0 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:000025D0                                         ; DATA XREF: .rdata:00002B80o
.text$mn:000025D0
.text$mn:000025D0 var_4           = dword ptr -4
.text$mn:000025D0
.text$mn:000025D0                 push    ebp
.text$mn:000025D1                 mov     ebp, esp
.text$mn:000025D3                 push    ecx
.text$mn:000025D4                 mov     [ebp+var_4], ecx
.text$mn:000025D7                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:000025DC                 mov     esp, ebp
.text$mn:000025DE                 pop     ebp
.text$mn:000025DF                 retn
.text$mn:000025DF ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:000025DF
.text$mn:000025DF _text$mn        ends
.text$mn:000025DF
.text$mn:000025E0 ; ===========================================================================
.text$mn:000025E0
.text$mn:000025E0 ; Segment type: Pure code
.text$mn:000025E0 ; Segment permissions: Read/Execute
.text$mn:000025E0 _text$mn        segment para public 'CODE' use32
.text$mn:000025E0                 assume cs:_text$mn
.text$mn:000025E0                 ;org 25E0h
.text$mn:000025E0 ; COMDAT (pick any)
.text$mn:000025E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025E0
.text$mn:000025E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025E0
.text$mn:000025E0 ; Attributes: bp-based frame
.text$mn:000025E0
.text$mn:000025E0 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:000025E0                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:000025E0 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:000025E0                                         ; DATA XREF: .rdata:00002BB4o
.text$mn:000025E0
.text$mn:000025E0 var_4           = dword ptr -4
.text$mn:000025E0
.text$mn:000025E0                 push    ebp
.text$mn:000025E1                 mov     ebp, esp
.text$mn:000025E3                 push    ecx
.text$mn:000025E4                 mov     [ebp+var_4], ecx
.text$mn:000025E7                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:000025EC                 mov     esp, ebp
.text$mn:000025EE                 pop     ebp
.text$mn:000025EF                 retn
.text$mn:000025EF ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:000025EF
.text$mn:000025EF _text$mn        ends
.text$mn:000025EF
.text$mn:000025F0 ; ===========================================================================
.text$mn:000025F0
.text$mn:000025F0 ; Segment type: Pure code
.text$mn:000025F0 ; Segment permissions: Read/Execute
.text$mn:000025F0 _text$mn        segment para public 'CODE' use32
.text$mn:000025F0                 assume cs:_text$mn
.text$mn:000025F0                 ;org 25F0h
.text$mn:000025F0 ; COMDAT (pick any)
.text$mn:000025F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025F0
.text$mn:000025F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025F0
.text$mn:000025F0 ; Attributes: bp-based frame
.text$mn:000025F0
.text$mn:000025F0 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:000025F0                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:000025F0 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:000025F0                                         ; DATA XREF: .rdata:00002BF4o
.text$mn:000025F0
.text$mn:000025F0 var_4           = dword ptr -4
.text$mn:000025F0
.text$mn:000025F0                 push    ebp
.text$mn:000025F1                 mov     ebp, esp
.text$mn:000025F3                 push    ecx
.text$mn:000025F4                 mov     [ebp+var_4], ecx
.text$mn:000025F7                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:000025FC                 mov     esp, ebp
.text$mn:000025FE                 pop     ebp
.text$mn:000025FF                 retn
.text$mn:000025FF ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:000025FF
.text$mn:000025FF _text$mn        ends
.text$mn:000025FF
.text$mn:00002600 ; ===========================================================================
.text$mn:00002600
.text$mn:00002600 ; Segment type: Pure code
.text$mn:00002600 ; Segment permissions: Read/Execute
.text$mn:00002600 _text$mn        segment para public 'CODE' use32
.text$mn:00002600                 assume cs:_text$mn
.text$mn:00002600                 ;org 2600h
.text$mn:00002600 ; COMDAT (pick any)
.text$mn:00002600                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002600
.text$mn:00002600 ; =============== S U B R O U T I N E =======================================
.text$mn:00002600
.text$mn:00002600 ; Attributes: bp-based frame
.text$mn:00002600
.text$mn:00002600 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00002600                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002600 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002600                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00002600                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00002600
.text$mn:00002600 var_4           = dword ptr -4
.text$mn:00002600
.text$mn:00002600                 push    ebp
.text$mn:00002601                 mov     ebp, esp
.text$mn:00002603                 push    ecx
.text$mn:00002604                 mov     [ebp+var_4], ecx
.text$mn:00002607                 mov     eax, [ebp+var_4]
.text$mn:0000260A                 mov     eax, [eax+14h]
.text$mn:0000260D                 mov     esp, ebp
.text$mn:0000260F                 pop     ebp
.text$mn:00002610                 retn
.text$mn:00002610 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002610
.text$mn:00002610 ; ---------------------------------------------------------------------------
.text$mn:00002611                 align 4
.text$mn:00002611 _text$mn        ends
.text$mn:00002611
.text$mn:00002614 ; ===========================================================================
.text$mn:00002614
.text$mn:00002614 ; Segment type: Pure code
.text$mn:00002614 ; Segment permissions: Read/Execute
.text$mn:00002614 _text$mn        segment para public 'CODE' use32
.text$mn:00002614                 assume cs:_text$mn
.text$mn:00002614                 ;org 2614h
.text$mn:00002614 ; COMDAT (pick any)
.text$mn:00002614                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002614
.text$mn:00002614 ; =============== S U B R O U T I N E =======================================
.text$mn:00002614
.text$mn:00002614 ; Attributes: bp-based frame
.text$mn:00002614
.text$mn:00002614 ; __int32 __stdcall TaskList::staticProc(HWND hWnd, UINT Msg, WPARAM, __int32)
.text$mn:00002614                 public ?staticProc@TaskList@@KGJPAUHWND__@@IIJ@Z
.text$mn:00002614 ?staticProc@TaskList@@KGJPAUHWND__@@IIJ@Z proc near
.text$mn:00002614                                         ; DATA XREF: TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+BAo
.text$mn:00002614
.text$mn:00002614 hWnd            = dword ptr  8
.text$mn:00002614 Msg             = dword ptr  0Ch
.text$mn:00002614 arg_8           = dword ptr  10h
.text$mn:00002614 arg_C           = dword ptr  14h
.text$mn:00002614
.text$mn:00002614                 push    ebp
.text$mn:00002615                 mov     ebp, esp
.text$mn:00002617                 mov     eax, [ebp+arg_C]
.text$mn:0000261A                 push    eax             ; __int32
.text$mn:0000261B                 mov     ecx, [ebp+arg_8]
.text$mn:0000261E                 push    ecx             ; WPARAM
.text$mn:0000261F                 mov     edx, [ebp+Msg]
.text$mn:00002622                 push    edx             ; Msg
.text$mn:00002623                 mov     eax, [ebp+hWnd]
.text$mn:00002626                 push    eax             ; hWnd
.text$mn:00002627                 push    0FFFFFFEBh      ; nIndex
.text$mn:00002629                 mov     ecx, [ebp+hWnd]
.text$mn:0000262C                 push    ecx             ; hWnd
.text$mn:0000262D                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:00002633                 mov     ecx, eax        ; this
.text$mn:00002635                 call    ?runProc@TaskList@@IAEJPAUHWND__@@IIJ@Z ; TaskList::runProc(HWND__ *,uint,uint,long)
.text$mn:0000263A                 pop     ebp
.text$mn:0000263B                 retn    10h
.text$mn:0000263B ?staticProc@TaskList@@KGJPAUHWND__@@IIJ@Z endp
.text$mn:0000263B
.text$mn:0000263B ; ---------------------------------------------------------------------------
.text$mn:0000263E                 align 10h
.text$mn:0000263E _text$mn        ends
.text$mn:0000263E
.text$mn:00002640 ; ===========================================================================
.text$mn:00002640
.text$mn:00002640 ; Segment type: Pure code
.text$mn:00002640 ; Segment permissions: Read/Execute
.text$mn:00002640 _text$mn        segment para public 'CODE' use32
.text$mn:00002640                 assume cs:_text$mn
.text$mn:00002640                 ;org 2640h
.text$mn:00002640 ; COMDAT (pick any)
.text$mn:00002640                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002640
.text$mn:00002640 ; =============== S U B R O U T I N E =======================================
.text$mn:00002640
.text$mn:00002640 ; Attributes: bp-based frame
.text$mn:00002640
.text$mn:00002640 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00002640                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00002640 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002640                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_210Cp
.text$mn:00002640                 push    ebp
.text$mn:00002641                 mov     ebp, esp
.text$mn:00002643                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00002648                 pop     ebp
.text$mn:00002649                 retn
.text$mn:00002649 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002649
.text$mn:00002649 ; ---------------------------------------------------------------------------
.text$mn:0000264A                 align 4
.text$mn:0000264A _text$mn        ends
.text$mn:0000264A
.text$mn:0000264C ; ===========================================================================
.text$mn:0000264C
.text$mn:0000264C ; Segment type: Pure code
.text$mn:0000264C ; Segment permissions: Read/Execute
.text$mn:0000264C _text$mn        segment para public 'CODE' use32
.text$mn:0000264C                 assume cs:_text$mn
.text$mn:0000264C                 ;org 264Ch
.text$mn:0000264C ; COMDAT (pick any)
.text$mn:0000264C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000264C
.text$mn:0000264C ; =============== S U B R O U T I N E =======================================
.text$mn:0000264C
.text$mn:0000264C ; Attributes: bp-based frame
.text$mn:0000264C
.text$mn:0000264C ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:0000264C                 public ?value@error_code@std@@QBEHXZ
.text$mn:0000264C ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:0000264C
.text$mn:0000264C var_4           = dword ptr -4
.text$mn:0000264C
.text$mn:0000264C                 push    ebp
.text$mn:0000264D                 mov     ebp, esp
.text$mn:0000264F                 push    ecx
.text$mn:00002650                 mov     [ebp+var_4], ecx
.text$mn:00002653                 mov     eax, [ebp+var_4]
.text$mn:00002656                 mov     eax, [eax]
.text$mn:00002658                 mov     esp, ebp
.text$mn:0000265A                 pop     ebp
.text$mn:0000265B                 retn
.text$mn:0000265B ?value@error_code@std@@QBEHXZ endp
.text$mn:0000265B
.text$mn:0000265B _text$mn        ends
.text$mn:0000265B
.text$mn:0000265C ; ===========================================================================
.text$mn:0000265C
.text$mn:0000265C ; Segment type: Pure code
.text$mn:0000265C ; Segment permissions: Read/Execute
.text$mn:0000265C _text$mn        segment para public 'CODE' use32
.text$mn:0000265C                 assume cs:_text$mn
.text$mn:0000265C                 ;org 265Ch
.text$mn:0000265C ; COMDAT (pick any)
.text$mn:0000265C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000265C
.text$mn:0000265C ; =============== S U B R O U T I N E =======================================
.text$mn:0000265C
.text$mn:0000265C ; Attributes: bp-based frame
.text$mn:0000265C
.text$mn:0000265C ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:0000265C                 public ?value@error_condition@std@@QBEHXZ
.text$mn:0000265C ?value@error_condition@std@@QBEHXZ proc near
.text$mn:0000265C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:0000265C                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:0000265C
.text$mn:0000265C var_4           = dword ptr -4
.text$mn:0000265C
.text$mn:0000265C                 push    ebp
.text$mn:0000265D                 mov     ebp, esp
.text$mn:0000265F                 push    ecx
.text$mn:00002660                 mov     [ebp+var_4], ecx
.text$mn:00002663                 mov     eax, [ebp+var_4]
.text$mn:00002666                 mov     eax, [eax]
.text$mn:00002668                 mov     esp, ebp
.text$mn:0000266A                 pop     ebp
.text$mn:0000266B                 retn
.text$mn:0000266B ?value@error_condition@std@@QBEHXZ endp
.text$mn:0000266B
.text$mn:0000266B _text$mn        ends
.text$mn:0000266B
.text$mn:0000266C ; ===========================================================================
.text$mn:0000266C
.text$mn:0000266C ; Segment type: Pure code
.text$mn:0000266C ; Segment permissions: Read/Execute
.text$mn:0000266C _text$mn        segment para public 'CODE' use32
.text$mn:0000266C                 assume cs:_text$mn
.text$mn:0000266C                 ;org 266Ch
.text$mn:0000266C ; COMDAT (pick any)
.text$mn:0000266C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000266C
.text$mn:0000266C ; =============== S U B R O U T I N E =======================================
.text$mn:0000266C
.text$mn:0000266C ; Attributes: bp-based frame
.text$mn:0000266C
.text$mn:0000266C                 public _hypot
.text$mn:0000266C _hypot          proc near
.text$mn:0000266C
.text$mn:0000266C var_10          = qword ptr -10h
.text$mn:0000266C var_8           = qword ptr -8
.text$mn:0000266C arg_0           = qword ptr  8
.text$mn:0000266C arg_8           = qword ptr  10h
.text$mn:0000266C
.text$mn:0000266C                 push    ebp
.text$mn:0000266D                 mov     ebp, esp
.text$mn:0000266F                 sub     esp, 8
.text$mn:00002672                 movsd   xmm0, [ebp+arg_8]
.text$mn:00002677                 movsd   [esp+8+var_8], xmm0
.text$mn:0000267C                 sub     esp, 8
.text$mn:0000267F                 movsd   xmm0, [ebp+arg_0]
.text$mn:00002684                 movsd   [esp+10h+var_10], xmm0
.text$mn:00002689                 call    __hypot
.text$mn:0000268E                 add     esp, 10h
.text$mn:00002691                 pop     ebp
.text$mn:00002692                 retn
.text$mn:00002692 _hypot          endp
.text$mn:00002692
.text$mn:00002692 ; ---------------------------------------------------------------------------
.text$mn:00002693                 align 4
.text$mn:00002693 _text$mn        ends
.text$mn:00002693
.xdata$x:00002694 ; ===========================================================================
.xdata$x:00002694
.xdata$x:00002694 ; Segment type: Pure data
.xdata$x:00002694 ; Segment permissions: Read
.xdata$x:00002694 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002694                 assume cs:_xdata$x
.xdata$x:00002694                 ;org 2694h
.xdata$x:00002694 ; COMDAT (pick associative to section at 1CB0)
.xdata$x:00002694 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00002694                                         ; DATA XREF: .xdata$x:000026A4o
.xdata$x:00002695                 db 0FFh
.xdata$x:00002696                 db 0FFh
.xdata$x:00002697                 db 0FFh
.xdata$x:00002698                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:0000269C __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:0000269C                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:0000269D                 db    5
.xdata$x:0000269E                 db  93h ; ô
.xdata$x:0000269F                 db  19h
.xdata$x:000026A0                 db    1
.xdata$x:000026A1                 db    0
.xdata$x:000026A2                 db    0
.xdata$x:000026A3                 db    0
.xdata$x:000026A4                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:000026A8                 align 20h
.xdata$x:000026A8 _xdata$x        ends
.xdata$x:000026A8
.xdata$x:000026C0 ; ===========================================================================
.xdata$x:000026C0
.xdata$x:000026C0 ; Segment type: Pure data
.xdata$x:000026C0 ; Segment permissions: Read
.xdata$x:000026C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000026C0                 assume cs:_xdata$x
.xdata$x:000026C0                 ;org 26C0h
.xdata$x:000026C0 ; COMDAT (pick associative to section at EAC)
.xdata$x:000026C0 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000026C0                                         ; DATA XREF: .xdata$x:000026D0o
.xdata$x:000026C1                 db 0FFh
.xdata$x:000026C2                 db 0FFh
.xdata$x:000026C3                 db 0FFh
.xdata$x:000026C4                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000026C8 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000026C8                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000026C9                 db    5
.xdata$x:000026CA                 db  93h ; ô
.xdata$x:000026CB                 db  19h
.xdata$x:000026CC                 db    1
.xdata$x:000026CD                 db    0
.xdata$x:000026CE                 db    0
.xdata$x:000026CF                 db    0
.xdata$x:000026D0                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:000026D4                 db    0
.xdata$x:000026D5                 db    0
.xdata$x:000026D6                 db    0
.xdata$x:000026D7                 db    0
.xdata$x:000026D8                 db    0
.xdata$x:000026D9                 db    0
.xdata$x:000026DA                 db    0
.xdata$x:000026DB                 db    0
.xdata$x:000026DC                 db    0
.xdata$x:000026DD                 db    0
.xdata$x:000026DE                 db    0
.xdata$x:000026DF                 db    0
.xdata$x:000026E0                 db    0
.xdata$x:000026E1                 db    0
.xdata$x:000026E2                 db    0
.xdata$x:000026E3                 db    0
.xdata$x:000026E4                 db    0
.xdata$x:000026E5                 db    0
.xdata$x:000026E6                 db    0
.xdata$x:000026E7                 db    0
.xdata$x:000026E8                 db    0
.xdata$x:000026E9                 db    0
.xdata$x:000026EA                 db    0
.xdata$x:000026EB                 db    0
.xdata$x:000026EB _xdata$x        ends
.xdata$x:000026EB
.xdata$x:000026EC ; ===========================================================================
.xdata$x:000026EC
.xdata$x:000026EC ; Segment type: Pure data
.xdata$x:000026EC ; Segment permissions: Read
.xdata$x:000026EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000026EC                 assume cs:_xdata$x
.xdata$x:000026EC                 ;org 26ECh
.xdata$x:000026EC ; COMDAT (pick associative to section at 1388)
.xdata$x:000026EC __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000026EC                                         ; DATA XREF: .xdata$x:000026FCo
.xdata$x:000026ED                 db 0FFh
.xdata$x:000026EE                 db 0FFh
.xdata$x:000026EF                 db 0FFh
.xdata$x:000026F0                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000026F4 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000026F4                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000026F5                 db    5
.xdata$x:000026F6                 db  93h ; ô
.xdata$x:000026F7                 db  19h
.xdata$x:000026F8                 db    1
.xdata$x:000026F9                 db    0
.xdata$x:000026FA                 db    0
.xdata$x:000026FB                 db    0
.xdata$x:000026FC                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002700                 db    0
.xdata$x:00002701                 db    0
.xdata$x:00002702                 db    0
.xdata$x:00002703                 db    0
.xdata$x:00002704                 db    0
.xdata$x:00002705                 db    0
.xdata$x:00002706                 db    0
.xdata$x:00002707                 db    0
.xdata$x:00002708                 db    0
.xdata$x:00002709                 db    0
.xdata$x:0000270A                 db    0
.xdata$x:0000270B                 db    0
.xdata$x:0000270C                 db    0
.xdata$x:0000270D                 db    0
.xdata$x:0000270E                 db    0
.xdata$x:0000270F                 db    0
.xdata$x:00002710                 db    0
.xdata$x:00002711                 db    0
.xdata$x:00002712                 db    0
.xdata$x:00002713                 db    0
.xdata$x:00002714                 db    0
.xdata$x:00002715                 db    0
.xdata$x:00002716                 db    0
.xdata$x:00002717                 db    0
.xdata$x:00002717 _xdata$x        ends
.xdata$x:00002717
.xdata$x:00002718 ; ===========================================================================
.xdata$x:00002718
.xdata$x:00002718 ; Segment type: Pure data
.xdata$x:00002718 ; Segment permissions: Read
.xdata$x:00002718 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002718                 assume cs:_xdata$x
.xdata$x:00002718                 ;org 2718h
.xdata$x:00002718 ; COMDAT (pick associative to section at E30)
.xdata$x:00002718 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00002718                                         ; DATA XREF: .xdata$x:00002728o
.xdata$x:00002719                 db 0FFh
.xdata$x:0000271A                 db 0FFh
.xdata$x:0000271B                 db 0FFh
.xdata$x:0000271C                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00002720 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00002720                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00002721                 db    5
.xdata$x:00002722                 db  93h ; ô
.xdata$x:00002723                 db  19h
.xdata$x:00002724                 db    1
.xdata$x:00002725                 db    0
.xdata$x:00002726                 db    0
.xdata$x:00002727                 db    0
.xdata$x:00002728                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:0000272C                 db    0
.xdata$x:0000272D                 db    0
.xdata$x:0000272E                 db    0
.xdata$x:0000272F                 db    0
.xdata$x:00002730                 db    0
.xdata$x:00002731                 db    0
.xdata$x:00002732                 db    0
.xdata$x:00002733                 db    0
.xdata$x:00002734                 db    0
.xdata$x:00002735                 db    0
.xdata$x:00002736                 db    0
.xdata$x:00002737                 db    0
.xdata$x:00002738                 db    0
.xdata$x:00002739                 db    0
.xdata$x:0000273A                 db    0
.xdata$x:0000273B                 db    0
.xdata$x:0000273C                 db    0
.xdata$x:0000273D                 db    0
.xdata$x:0000273E                 db    0
.xdata$x:0000273F                 db    0
.xdata$x:00002740                 db    0
.xdata$x:00002741                 db    0
.xdata$x:00002742                 db    0
.xdata$x:00002743                 db    0
.xdata$x:00002743 _xdata$x        ends
.xdata$x:00002743
.xdata$x:00002744 ; ===========================================================================
.xdata$x:00002744
.xdata$x:00002744 ; Segment type: Pure data
.xdata$x:00002744 ; Segment permissions: Read
.xdata$x:00002744 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002744                 assume cs:_xdata$x
.xdata$x:00002744                 ;org 2744h
.xdata$x:00002744 ; COMDAT (pick associative to section at 1310)
.xdata$x:00002744 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002744                                         ; DATA XREF: .xdata$x:00002754o
.xdata$x:00002745                 db 0FFh
.xdata$x:00002746                 db 0FFh
.xdata$x:00002747                 db 0FFh
.xdata$x:00002748                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000274C __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000274C                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000274D                 db    5
.xdata$x:0000274E                 db  93h ; ô
.xdata$x:0000274F                 db  19h
.xdata$x:00002750                 db    1
.xdata$x:00002751                 db    0
.xdata$x:00002752                 db    0
.xdata$x:00002753                 db    0
.xdata$x:00002754                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00002758                 db    0
.xdata$x:00002759                 db    0
.xdata$x:0000275A                 db    0
.xdata$x:0000275B                 db    0
.xdata$x:0000275C                 db    0
.xdata$x:0000275D                 db    0
.xdata$x:0000275E                 db    0
.xdata$x:0000275F                 db    0
.xdata$x:00002760                 db    0
.xdata$x:00002761                 db    0
.xdata$x:00002762                 db    0
.xdata$x:00002763                 db    0
.xdata$x:00002764                 db    0
.xdata$x:00002765                 db    0
.xdata$x:00002766                 db    0
.xdata$x:00002767                 db    0
.xdata$x:00002768                 db    0
.xdata$x:00002769                 db    0
.xdata$x:0000276A                 db    0
.xdata$x:0000276B                 db    0
.xdata$x:0000276C                 db    0
.xdata$x:0000276D                 db    0
.xdata$x:0000276E                 db    0
.xdata$x:0000276F                 db    0
.xdata$x:0000276F _xdata$x        ends
.xdata$x:0000276F
.xdata$x:00002770 ; ===========================================================================
.xdata$x:00002770
.xdata$x:00002770 ; Segment type: Pure data
.xdata$x:00002770 ; Segment permissions: Read
.xdata$x:00002770 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002770                 assume cs:_xdata$x
.xdata$x:00002770                 ;org 2770h
.xdata$x:00002770 ; COMDAT (pick associative to section at F6C)
.xdata$x:00002770 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002770                                         ; DATA XREF: .xdata$x:00002780o
.xdata$x:00002771                 db 0FFh
.xdata$x:00002772                 db 0FFh
.xdata$x:00002773                 db 0FFh
.xdata$x:00002774                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00002778 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00002778                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00002779                 db    5
.xdata$x:0000277A                 db  93h ; ô
.xdata$x:0000277B                 db  19h
.xdata$x:0000277C                 db    1
.xdata$x:0000277D                 db    0
.xdata$x:0000277E                 db    0
.xdata$x:0000277F                 db    0
.xdata$x:00002780                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00002784                 db    0
.xdata$x:00002785                 db    0
.xdata$x:00002786                 db    0
.xdata$x:00002787                 db    0
.xdata$x:00002788                 db    0
.xdata$x:00002789                 db    0
.xdata$x:0000278A                 db    0
.xdata$x:0000278B                 db    0
.xdata$x:0000278C                 db    0
.xdata$x:0000278D                 db    0
.xdata$x:0000278E                 db    0
.xdata$x:0000278F                 db    0
.xdata$x:00002790                 db    0
.xdata$x:00002791                 db    0
.xdata$x:00002792                 db    0
.xdata$x:00002793                 db    0
.xdata$x:00002794                 db    0
.xdata$x:00002795                 db    0
.xdata$x:00002796                 db    0
.xdata$x:00002797                 db    0
.xdata$x:00002798                 db    0
.xdata$x:00002799                 db    0
.xdata$x:0000279A                 db    0
.xdata$x:0000279B                 db    0
.xdata$x:0000279B _xdata$x        ends
.xdata$x:0000279B
.xdata$x:0000279C ; ===========================================================================
.xdata$x:0000279C
.xdata$x:0000279C ; Segment type: Pure data
.xdata$x:0000279C ; Segment permissions: Read
.xdata$x:0000279C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000279C                 assume cs:_xdata$x
.xdata$x:0000279C                 ;org 279Ch
.xdata$x:0000279C ; COMDAT (pick associative to section at 13F8)
.xdata$x:0000279C __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000279C                                         ; DATA XREF: .xdata$x:000027ACo
.xdata$x:0000279D                 db 0FFh
.xdata$x:0000279E                 db 0FFh
.xdata$x:0000279F                 db 0FFh
.xdata$x:000027A0                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:000027A4 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000027A4                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:000027A5                 db    5
.xdata$x:000027A6                 db  93h ; ô
.xdata$x:000027A7                 db  19h
.xdata$x:000027A8                 db    1
.xdata$x:000027A9                 db    0
.xdata$x:000027AA                 db    0
.xdata$x:000027AB                 db    0
.xdata$x:000027AC                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:000027B0                 db    0
.xdata$x:000027B1                 db    0
.xdata$x:000027B2                 db    0
.xdata$x:000027B3                 db    0
.xdata$x:000027B4                 db    0
.xdata$x:000027B5                 db    0
.xdata$x:000027B6                 db    0
.xdata$x:000027B7                 db    0
.xdata$x:000027B8                 db    0
.xdata$x:000027B9                 db    0
.xdata$x:000027BA                 db    0
.xdata$x:000027BB                 db    0
.xdata$x:000027BC                 db    0
.xdata$x:000027BD                 db    0
.xdata$x:000027BE                 db    0
.xdata$x:000027BF                 db    0
.xdata$x:000027C0                 db    0
.xdata$x:000027C1                 db    0
.xdata$x:000027C2                 db    0
.xdata$x:000027C3                 db    0
.xdata$x:000027C4                 db    0
.xdata$x:000027C5                 db    0
.xdata$x:000027C6                 db    0
.xdata$x:000027C7                 db    0
.xdata$x:000027C7 _xdata$x        ends
.xdata$x:000027C7
.xdata$x:000027C8 ; ===========================================================================
.xdata$x:000027C8
.xdata$x:000027C8 ; Segment type: Pure data
.xdata$x:000027C8 ; Segment permissions: Read
.xdata$x:000027C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000027C8                 assume cs:_xdata$x
.xdata$x:000027C8                 ;org 27C8h
.xdata$x:000027C8 ; COMDAT (pick associative to section at 190C)
.xdata$x:000027C8 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:000027C8                                         ; DATA XREF: .xdata$x:00002850o
.xdata$x:000027C9                 db    0
.xdata$x:000027CA                 db    0
.xdata$x:000027CB                 db    0
.xdata$x:000027CC                 db    0
.xdata$x:000027CD                 db    0
.xdata$x:000027CE                 db    0
.xdata$x:000027CF                 db    0
.xdata$x:000027D0                 db    0
.xdata$x:000027D1                 db    0
.xdata$x:000027D2                 db    0
.xdata$x:000027D3                 db    0
.xdata$x:000027D4                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:000027D8 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:000027D8                                         ; DATA XREF: .xdata$x:0000283Co
.xdata$x:000027D9                 db    0
.xdata$x:000027DA                 db    0
.xdata$x:000027DB                 db    0
.xdata$x:000027DC                 db    0
.xdata$x:000027DD                 db    0
.xdata$x:000027DE                 db    0
.xdata$x:000027DF                 db    0
.xdata$x:000027E0                 db    0
.xdata$x:000027E1                 db    0
.xdata$x:000027E2                 db    0
.xdata$x:000027E3                 db    0
.xdata$x:000027E4                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:000027E8 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:000027E8                                         ; DATA XREF: .xdata$x:00002810o
.xdata$x:000027E9                 db 0FFh
.xdata$x:000027EA                 db 0FFh
.xdata$x:000027EB                 db 0FFh
.xdata$x:000027EC                 db    0
.xdata$x:000027ED                 db    0
.xdata$x:000027EE                 db    0
.xdata$x:000027EF                 db    0
.xdata$x:000027F0                 db 0FFh
.xdata$x:000027F1                 db 0FFh
.xdata$x:000027F2                 db 0FFh
.xdata$x:000027F3                 db 0FFh
.xdata$x:000027F4                 db    0
.xdata$x:000027F5                 db    0
.xdata$x:000027F6                 db    0
.xdata$x:000027F7                 db    0
.xdata$x:000027F8                 db    1
.xdata$x:000027F9                 db    0
.xdata$x:000027FA                 db    0
.xdata$x:000027FB                 db    0
.xdata$x:000027FC                 db    0
.xdata$x:000027FD                 db    0
.xdata$x:000027FE                 db    0
.xdata$x:000027FF                 db    0
.xdata$x:00002800                 db    1
.xdata$x:00002801                 db    0
.xdata$x:00002802                 db    0
.xdata$x:00002803                 db    0
.xdata$x:00002804                 db    0
.xdata$x:00002805                 db    0
.xdata$x:00002806                 db    0
.xdata$x:00002807                 db    0
.xdata$x:00002808 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00002808                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00002809                 db    5
.xdata$x:0000280A                 db  93h ; ô
.xdata$x:0000280B                 db  19h
.xdata$x:0000280C                 db    4
.xdata$x:0000280D                 db    0
.xdata$x:0000280E                 db    0
.xdata$x:0000280F                 db    0
.xdata$x:00002810                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002814                 db    2
.xdata$x:00002815                 db    0
.xdata$x:00002816                 db    0
.xdata$x:00002817                 db    0
.xdata$x:00002818                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000281C                 db    0
.xdata$x:0000281D                 db    0
.xdata$x:0000281E                 db    0
.xdata$x:0000281F                 db    0
.xdata$x:00002820                 db    0
.xdata$x:00002821                 db    0
.xdata$x:00002822                 db    0
.xdata$x:00002823                 db    0
.xdata$x:00002824                 db    0
.xdata$x:00002825                 db    0
.xdata$x:00002826                 db    0
.xdata$x:00002827                 db    0
.xdata$x:00002828                 db    0
.xdata$x:00002829                 db    0
.xdata$x:0000282A                 db    0
.xdata$x:0000282B                 db    0
.xdata$x:0000282C __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:0000282C                                         ; DATA XREF: .xdata$x:00002818o
.xdata$x:0000282D                 db    0
.xdata$x:0000282E                 db    0
.xdata$x:0000282F                 db    0
.xdata$x:00002830                 db    2
.xdata$x:00002831                 db    0
.xdata$x:00002832                 db    0
.xdata$x:00002833                 db    0
.xdata$x:00002834                 db    3
.xdata$x:00002835                 db    0
.xdata$x:00002836                 db    0
.xdata$x:00002837                 db    0
.xdata$x:00002838                 db    1
.xdata$x:00002839                 db    0
.xdata$x:0000283A                 db    0
.xdata$x:0000283B                 db    0
.xdata$x:0000283C                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00002840                 db    0
.xdata$x:00002841                 db    0
.xdata$x:00002842                 db    0
.xdata$x:00002843                 db    0
.xdata$x:00002844                 db    0
.xdata$x:00002845                 db    0
.xdata$x:00002846                 db    0
.xdata$x:00002847                 db    0
.xdata$x:00002848                 db    3
.xdata$x:00002849                 db    0
.xdata$x:0000284A                 db    0
.xdata$x:0000284B                 db    0
.xdata$x:0000284C                 db    1
.xdata$x:0000284D                 db    0
.xdata$x:0000284E                 db    0
.xdata$x:0000284F                 db    0
.xdata$x:00002850                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00002850 _xdata$x        ends
.xdata$x:00002850
.xdata$x:00002854 ; ===========================================================================
.xdata$x:00002854
.xdata$x:00002854 ; Segment type: Pure data
.xdata$x:00002854 ; Segment permissions: Read
.xdata$x:00002854 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002854                 assume cs:_xdata$x
.xdata$x:00002854                 ;org 2854h
.xdata$x:00002854 ; COMDAT (pick associative to section at 128C)
.xdata$x:00002854 __unwindtable$??0runtime_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002854                                         ; DATA XREF: .xdata$x:00002864o
.xdata$x:00002855                 db 0FFh
.xdata$x:00002856                 db 0FFh
.xdata$x:00002857                 db 0FFh
.xdata$x:00002858                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0
.xdata$x:0000285C __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000285C                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@PBD@Z+11o
.xdata$x:0000285D                 db    5
.xdata$x:0000285E                 db  93h ; ô
.xdata$x:0000285F                 db  19h
.xdata$x:00002860                 db    1
.xdata$x:00002861                 db    0
.xdata$x:00002862                 db    0
.xdata$x:00002863                 db    0
.xdata$x:00002864                 dd offset __unwindtable$??0runtime_error@std@@QAE@PBD@Z
.xdata$x:00002868                 align 20h
.xdata$x:00002868 _xdata$x        ends
.xdata$x:00002868
.xdata$x:00002880 ; ===========================================================================
.xdata$x:00002880
.xdata$x:00002880 ; Segment type: Pure data
.xdata$x:00002880 ; Segment permissions: Read
.xdata$x:00002880 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002880                 assume cs:_xdata$x
.xdata$x:00002880                 ;org 2880h
.xdata$x:00002880 ; COMDAT (pick associative to section at 15EC)
.xdata$x:00002880 __unwindtable$??1runtime_error@std@@UAE@XZ db 0FFh
.xdata$x:00002880                                         ; DATA XREF: .xdata$x:00002890o
.xdata$x:00002881                 db 0FFh
.xdata$x:00002882                 db 0FFh
.xdata$x:00002883                 db 0FFh
.xdata$x:00002884                 dd offset __unwindfunclet$??1runtime_error@std@@UAE@XZ$0
.xdata$x:00002888 __ehfuncinfo$??1runtime_error@std@@UAE@XZ db  22h ; "
.xdata$x:00002888                                         ; DATA XREF: __ehhandler$??1runtime_error@std@@UAE@XZ+11o
.xdata$x:00002889                 db    5
.xdata$x:0000288A                 db  93h ; ô
.xdata$x:0000288B                 db  19h
.xdata$x:0000288C                 db    1
.xdata$x:0000288D                 db    0
.xdata$x:0000288E                 db    0
.xdata$x:0000288F                 db    0
.xdata$x:00002890                 dd offset __unwindtable$??1runtime_error@std@@UAE@XZ
.xdata$x:00002894                 db    0
.xdata$x:00002895                 db    0
.xdata$x:00002896                 db    0
.xdata$x:00002897                 db    0
.xdata$x:00002898                 db    0
.xdata$x:00002899                 db    0
.xdata$x:0000289A                 db    0
.xdata$x:0000289B                 db    0
.xdata$x:0000289C                 db    0
.xdata$x:0000289D                 db    0
.xdata$x:0000289E                 db    0
.xdata$x:0000289F                 db    0
.xdata$x:000028A0                 db    0
.xdata$x:000028A1                 db    0
.xdata$x:000028A2                 db    0
.xdata$x:000028A3                 db    0
.xdata$x:000028A4                 db    0
.xdata$x:000028A5                 db    0
.xdata$x:000028A6                 db    0
.xdata$x:000028A7                 db    0
.xdata$x:000028A8                 db    0
.xdata$x:000028A9                 db    0
.xdata$x:000028AA                 db    0
.xdata$x:000028AB                 db    0
.xdata$x:000028AB _xdata$x        ends
.xdata$x:000028AB
.xdata$x:000028AC ; ===========================================================================
.xdata$x:000028AC
.xdata$x:000028AC ; Segment type: Pure data
.xdata$x:000028AC ; Segment permissions: Read
.xdata$x:000028AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000028AC                 assume cs:_xdata$x
.xdata$x:000028AC                 ;org 28ACh
.xdata$x:000028AC ; COMDAT (pick associative to section at 1208)
.xdata$x:000028AC __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:000028AC                                         ; DATA XREF: .xdata$x:000028BCo
.xdata$x:000028AD                 db 0FFh
.xdata$x:000028AE                 db 0FFh
.xdata$x:000028AF                 db 0FFh
.xdata$x:000028B0                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
.xdata$x:000028B4 __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:000028B4                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z+11o
.xdata$x:000028B5                 db    5
.xdata$x:000028B6                 db  93h ; ô
.xdata$x:000028B7                 db  19h
.xdata$x:000028B8                 db    1
.xdata$x:000028B9                 db    0
.xdata$x:000028BA                 db    0
.xdata$x:000028BB                 db    0
.xdata$x:000028BC                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
.xdata$x:000028C0                 db    0
.xdata$x:000028C1                 db    0
.xdata$x:000028C2                 db    0
.xdata$x:000028C3                 db    0
.xdata$x:000028C4                 db    0
.xdata$x:000028C5                 db    0
.xdata$x:000028C6                 db    0
.xdata$x:000028C7                 db    0
.xdata$x:000028C8                 db    0
.xdata$x:000028C9                 db    0
.xdata$x:000028CA                 db    0
.xdata$x:000028CB                 db    0
.xdata$x:000028CC                 db    0
.xdata$x:000028CD                 db    0
.xdata$x:000028CE                 db    0
.xdata$x:000028CF                 db    0
.xdata$x:000028D0                 db    0
.xdata$x:000028D1                 db    0
.xdata$x:000028D2                 db    0
.xdata$x:000028D3                 db    0
.xdata$x:000028D4                 db    0
.xdata$x:000028D5                 db    0
.xdata$x:000028D6                 db    0
.xdata$x:000028D7                 db    0
.xdata$x:000028D7 _xdata$x        ends
.xdata$x:000028D7
.xdata$x:000028D8 ; ===========================================================================
.xdata$x:000028D8
.xdata$x:000028D8 ; Segment type: Pure data
.xdata$x:000028D8 ; Segment permissions: Read
.xdata$x:000028D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000028D8                 assume cs:_xdata$x
.xdata$x:000028D8                 ;org 28D8h
.xdata$x:000028D8 ; COMDAT (pick associative to section at 1040)
.xdata$x:000028D8 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000028D8                                         ; DATA XREF: .xdata$x:000028E8o
.xdata$x:000028D9                 db 0FFh
.xdata$x:000028DA                 db 0FFh
.xdata$x:000028DB                 db 0FFh
.xdata$x:000028DC                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:000028E0 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000028E0                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:000028E1                 db    5
.xdata$x:000028E2                 db  93h ; ô
.xdata$x:000028E3                 db  19h
.xdata$x:000028E4                 db    1
.xdata$x:000028E5                 db    0
.xdata$x:000028E6                 db    0
.xdata$x:000028E7                 db    0
.xdata$x:000028E8                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:000028EC                 db    0
.xdata$x:000028ED                 db    0
.xdata$x:000028EE                 db    0
.xdata$x:000028EF                 db    0
.xdata$x:000028F0                 db    0
.xdata$x:000028F1                 db    0
.xdata$x:000028F2                 db    0
.xdata$x:000028F3                 db    0
.xdata$x:000028F4                 db    0
.xdata$x:000028F5                 db    0
.xdata$x:000028F6                 db    0
.xdata$x:000028F7                 db    0
.xdata$x:000028F8                 db    0
.xdata$x:000028F9                 db    0
.xdata$x:000028FA                 db    0
.xdata$x:000028FB                 db    0
.xdata$x:000028FC                 db    0
.xdata$x:000028FD                 db    0
.xdata$x:000028FE                 db    0
.xdata$x:000028FF                 db    0
.xdata$x:00002900                 db    0
.xdata$x:00002901                 db    0
.xdata$x:00002902                 db    0
.xdata$x:00002903                 db    0
.xdata$x:00002903 _xdata$x        ends
.xdata$x:00002903
.xdata$x:00002904 ; ===========================================================================
.xdata$x:00002904
.xdata$x:00002904 ; Segment type: Pure data
.xdata$x:00002904 ; Segment permissions: Read
.xdata$x:00002904 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002904                 assume cs:_xdata$x
.xdata$x:00002904                 ;org 2904h
.xdata$x:00002904 ; COMDAT (pick associative to section at 236C)
.xdata$x:00002904 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002904                                         ; DATA XREF: .xdata$x:00002914o
.xdata$x:00002905                 db 0FFh
.xdata$x:00002906                 db 0FFh
.xdata$x:00002907                 db 0FFh
.xdata$x:00002908                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000290C __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000290C                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000290D                 db    5
.xdata$x:0000290E                 db  93h ; ô
.xdata$x:0000290F                 db  19h
.xdata$x:00002910                 db    1
.xdata$x:00002911                 db    0
.xdata$x:00002912                 db    0
.xdata$x:00002913                 db    0
.xdata$x:00002914                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002918                 db    0
.xdata$x:00002919                 db    0
.xdata$x:0000291A                 db    0
.xdata$x:0000291B                 db    0
.xdata$x:0000291C                 db    0
.xdata$x:0000291D                 db    0
.xdata$x:0000291E                 db    0
.xdata$x:0000291F                 db    0
.xdata$x:00002920                 db    0
.xdata$x:00002921                 db    0
.xdata$x:00002922                 db    0
.xdata$x:00002923                 db    0
.xdata$x:00002924                 db    0
.xdata$x:00002925                 db    0
.xdata$x:00002926                 db    0
.xdata$x:00002927                 db    0
.xdata$x:00002928                 db    0
.xdata$x:00002929                 db    0
.xdata$x:0000292A                 db    0
.xdata$x:0000292B                 db    0
.xdata$x:0000292C                 db    0
.xdata$x:0000292D                 db    0
.xdata$x:0000292E                 db    0
.xdata$x:0000292F                 db    0
.xdata$x:0000292F _xdata$x        ends
.xdata$x:0000292F
.xdata$x:00002930 ; ===========================================================================
.xdata$x:00002930
.xdata$x:00002930 ; Segment type: Pure data
.xdata$x:00002930 ; Segment permissions: Read
.xdata$x:00002930 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002930                 assume cs:_xdata$x
.xdata$x:00002930                 ;org 2930h
.xdata$x:00002930 ; COMDAT (pick associative to section at 1488)
.xdata$x:00002930 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002930                                         ; DATA XREF: .xdata$x:00002940o
.xdata$x:00002931                 db 0FFh
.xdata$x:00002932                 db 0FFh
.xdata$x:00002933                 db 0FFh
.xdata$x:00002934                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00002938 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002938                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00002939                 db    5
.xdata$x:0000293A                 db  93h ; ô
.xdata$x:0000293B                 db  19h
.xdata$x:0000293C                 db    1
.xdata$x:0000293D                 db    0
.xdata$x:0000293E                 db    0
.xdata$x:0000293F                 db    0
.xdata$x:00002940                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00002944                 db    0
.xdata$x:00002945                 db    0
.xdata$x:00002946                 db    0
.xdata$x:00002947                 db    0
.xdata$x:00002948                 db    0
.xdata$x:00002949                 db    0
.xdata$x:0000294A                 db    0
.xdata$x:0000294B                 db    0
.xdata$x:0000294C                 db    0
.xdata$x:0000294D                 db    0
.xdata$x:0000294E                 db    0
.xdata$x:0000294F                 db    0
.xdata$x:00002950                 db    0
.xdata$x:00002951                 db    0
.xdata$x:00002952                 db    0
.xdata$x:00002953                 db    0
.xdata$x:00002954                 db    0
.xdata$x:00002955                 db    0
.xdata$x:00002956                 db    0
.xdata$x:00002957                 db    0
.xdata$x:00002958                 db    0
.xdata$x:00002959                 db    0
.xdata$x:0000295A                 db    0
.xdata$x:0000295B                 db    0
.xdata$x:0000295B _xdata$x        ends
.xdata$x:0000295B
.xdata$x:0000295C ; ===========================================================================
.xdata$x:0000295C
.xdata$x:0000295C ; Segment type: Pure data
.xdata$x:0000295C ; Segment permissions: Read
.xdata$x:0000295C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000295C                 assume cs:_xdata$x
.xdata$x:0000295C                 ;org 295Ch
.xdata$x:0000295C ; COMDAT (pick associative to section at 10BC)
.xdata$x:0000295C __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000295C                                         ; DATA XREF: .xdata$x:0000296Co
.xdata$x:0000295D                 db 0FFh
.xdata$x:0000295E                 db 0FFh
.xdata$x:0000295F                 db 0FFh
.xdata$x:00002960                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002964 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002964                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002965                 db    5
.xdata$x:00002966                 db  93h ; ô
.xdata$x:00002967                 db  19h
.xdata$x:00002968                 db    1
.xdata$x:00002969                 db    0
.xdata$x:0000296A                 db    0
.xdata$x:0000296B                 db    0
.xdata$x:0000296C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00002970                 db    0
.xdata$x:00002971                 db    0
.xdata$x:00002972                 db    0
.xdata$x:00002973                 db    0
.xdata$x:00002974                 db    0
.xdata$x:00002975                 db    0
.xdata$x:00002976                 db    0
.xdata$x:00002977                 db    0
.xdata$x:00002978                 db    0
.xdata$x:00002979                 db    0
.xdata$x:0000297A                 db    0
.xdata$x:0000297B                 db    0
.xdata$x:0000297C                 db    0
.xdata$x:0000297D                 db    0
.xdata$x:0000297E                 db    0
.xdata$x:0000297F                 db    0
.xdata$x:00002980                 db    0
.xdata$x:00002981                 db    0
.xdata$x:00002982                 db    0
.xdata$x:00002983                 db    0
.xdata$x:00002984                 db    0
.xdata$x:00002985                 db    0
.xdata$x:00002986                 db    0
.xdata$x:00002987                 db    0
.xdata$x:00002987 _xdata$x        ends
.xdata$x:00002987
.xdata$x:00002988 ; ===========================================================================
.xdata$x:00002988
.xdata$x:00002988 ; Segment type: Pure data
.xdata$x:00002988 ; Segment permissions: Read
.xdata$x:00002988 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002988                 assume cs:_xdata$x
.xdata$x:00002988                 ;org 2988h
.xdata$x:00002988 ; COMDAT (pick associative to section at 2424)
.xdata$x:00002988 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002988                                         ; DATA XREF: .xdata$x:00002998o
.xdata$x:00002989                 db 0FFh
.xdata$x:0000298A                 db 0FFh
.xdata$x:0000298B                 db 0FFh
.xdata$x:0000298C                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002990 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002990                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002991                 db    5
.xdata$x:00002992                 db  93h ; ô
.xdata$x:00002993                 db  19h
.xdata$x:00002994                 db    1
.xdata$x:00002995                 db    0
.xdata$x:00002996                 db    0
.xdata$x:00002997                 db    0
.xdata$x:00002998                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000299C                 db    0
.xdata$x:0000299D                 db    0
.xdata$x:0000299E                 db    0
.xdata$x:0000299F                 db    0
.xdata$x:000029A0                 db    0
.xdata$x:000029A1                 db    0
.xdata$x:000029A2                 db    0
.xdata$x:000029A3                 db    0
.xdata$x:000029A4                 db    0
.xdata$x:000029A5                 db    0
.xdata$x:000029A6                 db    0
.xdata$x:000029A7                 db    0
.xdata$x:000029A8                 db    0
.xdata$x:000029A9                 db    0
.xdata$x:000029AA                 db    0
.xdata$x:000029AB                 db    0
.xdata$x:000029AC                 db    0
.xdata$x:000029AD                 db    0
.xdata$x:000029AE                 db    0
.xdata$x:000029AF                 db    0
.xdata$x:000029B0                 db    0
.xdata$x:000029B1                 db    0
.xdata$x:000029B2                 db    0
.xdata$x:000029B3                 db    0
.xdata$x:000029B3 _xdata$x        ends
.xdata$x:000029B3
.xdata$x:000029B4 ; ===========================================================================
.xdata$x:000029B4
.xdata$x:000029B4 ; Segment type: Pure data
.xdata$x:000029B4 ; Segment permissions: Read
.xdata$x:000029B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000029B4                 assume cs:_xdata$x
.xdata$x:000029B4                 ;org 29B4h
.xdata$x:000029B4 ; COMDAT (pick associative to section at 14F8)
.xdata$x:000029B4 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000029B4                                         ; DATA XREF: .xdata$x:000029C4o
.xdata$x:000029B5                 db 0FFh
.xdata$x:000029B6                 db 0FFh
.xdata$x:000029B7                 db 0FFh
.xdata$x:000029B8                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:000029BC __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000029BC                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:000029BD                 db    5
.xdata$x:000029BE                 db  93h ; ô
.xdata$x:000029BF                 db  19h
.xdata$x:000029C0                 db    1
.xdata$x:000029C1                 db    0
.xdata$x:000029C2                 db    0
.xdata$x:000029C3                 db    0
.xdata$x:000029C4                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:000029C8                 align 20h
.xdata$x:000029C8 _xdata$x        ends
.xdata$x:000029C8
.xdata$x:000029E0 ; ===========================================================================
.xdata$x:000029E0
.xdata$x:000029E0 ; Segment type: Pure data
.xdata$x:000029E0 ; Segment permissions: Read
.xdata$x:000029E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000029E0                 assume cs:_xdata$x
.xdata$x:000029E0                 ;org 29E0h
.xdata$x:000029E0 ; COMDAT (pick associative to section at 1138)
.xdata$x:000029E0 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000029E0                                         ; DATA XREF: .xdata$x:000029F0o
.xdata$x:000029E1                 db 0FFh
.xdata$x:000029E2                 db 0FFh
.xdata$x:000029E3                 db 0FFh
.xdata$x:000029E4                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:000029E8 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000029E8                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:000029E9                 db    5
.xdata$x:000029EA                 db  93h ; ô
.xdata$x:000029EB                 db  19h
.xdata$x:000029EC                 db    1
.xdata$x:000029ED                 db    0
.xdata$x:000029EE                 db    0
.xdata$x:000029EF                 db    0
.xdata$x:000029F0                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:000029F4                 db    0
.xdata$x:000029F5                 db    0
.xdata$x:000029F6                 db    0
.xdata$x:000029F7                 db    0
.xdata$x:000029F8                 db    0
.xdata$x:000029F9                 db    0
.xdata$x:000029FA                 db    0
.xdata$x:000029FB                 db    0
.xdata$x:000029FC                 db    0
.xdata$x:000029FD                 db    0
.xdata$x:000029FE                 db    0
.xdata$x:000029FF                 db    0
.xdata$x:00002A00                 db    0
.xdata$x:00002A01                 db    0
.xdata$x:00002A02                 db    0
.xdata$x:00002A03                 db    0
.xdata$x:00002A04                 db    0
.xdata$x:00002A05                 db    0
.xdata$x:00002A06                 db    0
.xdata$x:00002A07                 db    0
.xdata$x:00002A08                 db    0
.xdata$x:00002A09                 db    0
.xdata$x:00002A0A                 db    0
.xdata$x:00002A0B                 db    0
.xdata$x:00002A0B _xdata$x        ends
.xdata$x:00002A0B
.xdata$x:00002A0C ; ===========================================================================
.xdata$x:00002A0C
.xdata$x:00002A0C ; Segment type: Pure data
.xdata$x:00002A0C ; Segment permissions: Read
.xdata$x:00002A0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002A0C                 assume cs:_xdata$x
.xdata$x:00002A0C                 ;org 2A0Ch
.xdata$x:00002A0C ; COMDAT (pick associative to section at 24E8)
.xdata$x:00002A0C __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002A0C                                         ; DATA XREF: .xdata$x:00002A1Co
.xdata$x:00002A0D                 db 0FFh
.xdata$x:00002A0E                 db 0FFh
.xdata$x:00002A0F                 db 0FFh
.xdata$x:00002A10                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002A14 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002A14                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002A15                 db    5
.xdata$x:00002A16                 db  93h ; ô
.xdata$x:00002A17                 db  19h
.xdata$x:00002A18                 db    1
.xdata$x:00002A19                 db    0
.xdata$x:00002A1A                 db    0
.xdata$x:00002A1B                 db    0
.xdata$x:00002A1C                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002A20                 db    0
.xdata$x:00002A21                 db    0
.xdata$x:00002A22                 db    0
.xdata$x:00002A23                 db    0
.xdata$x:00002A24                 db    0
.xdata$x:00002A25                 db    0
.xdata$x:00002A26                 db    0
.xdata$x:00002A27                 db    0
.xdata$x:00002A28                 db    0
.xdata$x:00002A29                 db    0
.xdata$x:00002A2A                 db    0
.xdata$x:00002A2B                 db    0
.xdata$x:00002A2C                 db    0
.xdata$x:00002A2D                 db    0
.xdata$x:00002A2E                 db    0
.xdata$x:00002A2F                 db    0
.xdata$x:00002A30                 db    0
.xdata$x:00002A31                 db    0
.xdata$x:00002A32                 db    0
.xdata$x:00002A33                 db    0
.xdata$x:00002A34                 db    0
.xdata$x:00002A35                 db    0
.xdata$x:00002A36                 db    0
.xdata$x:00002A37                 db    0
.xdata$x:00002A37 _xdata$x        ends
.xdata$x:00002A37
.xdata$x:00002A38 ; ===========================================================================
.xdata$x:00002A38
.xdata$x:00002A38 ; Segment type: Pure data
.xdata$x:00002A38 ; Segment permissions: Read
.xdata$x:00002A38 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002A38                 assume cs:_xdata$x
.xdata$x:00002A38                 ;org 2A38h
.xdata$x:00002A38 ; COMDAT (pick associative to section at 1568)
.xdata$x:00002A38 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002A38                                         ; DATA XREF: .xdata$x:00002A48o
.xdata$x:00002A39                 db 0FFh
.xdata$x:00002A3A                 db 0FFh
.xdata$x:00002A3B                 db 0FFh
.xdata$x:00002A3C                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00002A40 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002A40                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00002A41                 db    5
.xdata$x:00002A42                 db  93h ; ô
.xdata$x:00002A43                 db  19h
.xdata$x:00002A44                 db    1
.xdata$x:00002A45                 db    0
.xdata$x:00002A46                 db    0
.xdata$x:00002A47                 db    0
.xdata$x:00002A48                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00002A4C                 db    0
.xdata$x:00002A4D                 db    0
.xdata$x:00002A4E                 db    0
.xdata$x:00002A4F                 db    0
.xdata$x:00002A50                 db    0
.xdata$x:00002A51                 db    0
.xdata$x:00002A52                 db    0
.xdata$x:00002A53                 db    0
.xdata$x:00002A54                 db    0
.xdata$x:00002A55                 db    0
.xdata$x:00002A56                 db    0
.xdata$x:00002A57                 db    0
.xdata$x:00002A58                 db    0
.xdata$x:00002A59                 db    0
.xdata$x:00002A5A                 db    0
.xdata$x:00002A5B                 db    0
.xdata$x:00002A5C                 db    0
.xdata$x:00002A5D                 db    0
.xdata$x:00002A5E                 db    0
.xdata$x:00002A5F                 db    0
.xdata$x:00002A60                 db    0
.xdata$x:00002A61                 db    0
.xdata$x:00002A62                 db    0
.xdata$x:00002A63                 db    0
.xdata$x:00002A63 _xdata$x        ends
.xdata$x:00002A63
.xdata$x:00002A64 ; ===========================================================================
.xdata$x:00002A64
.xdata$x:00002A64 ; Segment type: Pure data
.xdata$x:00002A64 ; Segment permissions: Read
.xdata$x:00002A64 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002A64                 assume cs:_xdata$x
.xdata$x:00002A64                 ;org 2A64h
.xdata$x:00002A64 ; COMDAT (pick associative to section at D14)
.xdata$x:00002A64 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002A64                                         ; DATA XREF: .xdata$x:00002A74o
.xdata$x:00002A65                 db 0FFh
.xdata$x:00002A66                 db 0FFh
.xdata$x:00002A67                 db 0FFh
.xdata$x:00002A68                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00002A6C __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00002A6C                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00002A6D                 db    5
.xdata$x:00002A6E                 db  93h ; ô
.xdata$x:00002A6F                 db  19h
.xdata$x:00002A70                 db    1
.xdata$x:00002A71                 db    0
.xdata$x:00002A72                 db    0
.xdata$x:00002A73                 db    0
.xdata$x:00002A74                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00002A78                 db    0
.xdata$x:00002A79                 db    0
.xdata$x:00002A7A                 db    0
.xdata$x:00002A7B                 db    0
.xdata$x:00002A7C                 db    0
.xdata$x:00002A7D                 db    0
.xdata$x:00002A7E                 db    0
.xdata$x:00002A7F                 db    0
.xdata$x:00002A80                 db    0
.xdata$x:00002A81                 db    0
.xdata$x:00002A82                 db    0
.xdata$x:00002A83                 db    0
.xdata$x:00002A84                 db    0
.xdata$x:00002A85                 db    0
.xdata$x:00002A86                 db    0
.xdata$x:00002A87                 db    0
.xdata$x:00002A88                 db    0
.xdata$x:00002A89                 db    0
.xdata$x:00002A8A                 db    0
.xdata$x:00002A8B                 db    0
.xdata$x:00002A8C                 db    0
.xdata$x:00002A8D                 db    0
.xdata$x:00002A8E                 db    0
.xdata$x:00002A8F                 db    0
.xdata$x:00002A8F _xdata$x        ends
.xdata$x:00002A8F
.xdata$x:00002A90 ; ===========================================================================
.xdata$x:00002A90
.xdata$x:00002A90 ; Segment type: Pure data
.xdata$x:00002A90 ; Segment permissions: Read
.xdata$x:00002A90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002A90                 assume cs:_xdata$x
.xdata$x:00002A90                 ;org 2A90h
.xdata$x:00002A90 ; COMDAT (pick associative to section at C40)
.xdata$x:00002A90 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00002A90                                         ; DATA XREF: .xdata$x:00002AA0o
.xdata$x:00002A91                 db 0FFh
.xdata$x:00002A92                 db 0FFh
.xdata$x:00002A93                 db 0FFh
.xdata$x:00002A94                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00002A98 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00002A98                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00002A99                 db    5
.xdata$x:00002A9A                 db  93h ; ô
.xdata$x:00002A9B                 db  19h
.xdata$x:00002A9C                 db    1
.xdata$x:00002A9D                 db    0
.xdata$x:00002A9E                 db    0
.xdata$x:00002A9F                 db    0
.xdata$x:00002AA0                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00002AA4                 db    0
.xdata$x:00002AA5                 db    0
.xdata$x:00002AA6                 db    0
.xdata$x:00002AA7                 db    0
.xdata$x:00002AA8                 db    0
.xdata$x:00002AA9                 db    0
.xdata$x:00002AAA                 db    0
.xdata$x:00002AAB                 db    0
.xdata$x:00002AAC                 db    0
.xdata$x:00002AAD                 db    0
.xdata$x:00002AAE                 db    0
.xdata$x:00002AAF                 db    0
.xdata$x:00002AB0                 db    0
.xdata$x:00002AB1                 db    0
.xdata$x:00002AB2                 db    0
.xdata$x:00002AB3                 db    0
.xdata$x:00002AB4                 db    0
.xdata$x:00002AB5                 db    0
.xdata$x:00002AB6                 db    0
.xdata$x:00002AB7                 db    0
.xdata$x:00002AB8                 db    0
.xdata$x:00002AB9                 db    0
.xdata$x:00002ABA                 db    0
.xdata$x:00002ABB                 db    0
.xdata$x:00002ABB _xdata$x        ends
.xdata$x:00002ABB
.bss:00002ABC ; ===========================================================================
.bss:00002ABC
.bss:00002ABC ; Segment type: Uninitialized
.bss:00002ABC ; Segment permissions: Read/Write
.bss:00002ABC _bss            segment byte public 'BSS' use32
.bss:00002ABC                 assume cs:_bss
.bss:00002ABC                 ;org 2ABCh
.bss:00002ABC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002ABC _allocator_arg  db    ? ;
.bss:00002ABD _piecewise_construct db    ? ;
.bss:00002ABE                 align 10h
.bss:00002ABE _bss            ends
.bss:00002ABE
.rdata:00002AC0 ; ===========================================================================
.rdata:00002AC0
.rdata:00002AC0 ; Segment type: Pure data
.rdata:00002AC0 ; Segment permissions: Read
.rdata:00002AC0 _rdata          segment dword public 'DATA' use32
.rdata:00002AC0                 assume cs:_rdata
.rdata:00002AC0                 ;org 2AC0h
.rdata:00002AC0 ; COMDAT (pick largest)
.rdata:00002AC0                 dd offset ??_R4runtime_error@std@@6B@ ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata:00002AC4                 public ??_7runtime_error@std@@6B@
.rdata:00002AC4 ; const std::runtime_error::`vftable'
.rdata:00002AC4 ??_7runtime_error@std@@6B@ dd offset ??_Eruntime_error@std@@UAEPAXI@Z
.rdata:00002AC4                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+3Co
.rdata:00002AC4                                         ; std::runtime_error::runtime_error(char const *)+3Co
.rdata:00002AC4                                         ; std::runtime_error::`vector deleting destructor'(uint)
.rdata:00002AC8                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:00002AC8 _rdata          ends
.rdata:00002AC8
.xdata$x:00002ACC ; ===========================================================================
.xdata$x:00002ACC
.xdata$x:00002ACC ; Segment type: Pure data
.xdata$x:00002ACC ; Segment permissions: Read
.xdata$x:00002ACC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002ACC                 assume cs:_xdata$x
.xdata$x:00002ACC                 ;org 2ACCh
.xdata$x:00002ACC ; COMDAT (pick any)
.xdata$x:00002ACC                 public __TI2?AVruntime_error@std@@
.xdata$x:00002ACC __TI2?AVruntime_error@std@@ db    0     ; DATA XREF: TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+99o
.xdata$x:00002ACD                 db    0
.xdata$x:00002ACE                 db    0
.xdata$x:00002ACF                 db    0
.xdata$x:00002AD0                 dd offset ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.xdata$x:00002AD4                 align 8
.xdata$x:00002AD8                 dd offset __CTA2?AVruntime_error@std@@
.xdata$x:00002AD8 _xdata$x        ends
.xdata$x:00002AD8
.xdata$x:00002ADC ; ===========================================================================
.xdata$x:00002ADC
.xdata$x:00002ADC ; Segment type: Pure data
.xdata$x:00002ADC ; Segment permissions: Read
.xdata$x:00002ADC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002ADC                 assume cs:_xdata$x
.xdata$x:00002ADC                 ;org 2ADCh
.xdata$x:00002ADC ; COMDAT (pick any)
.xdata$x:00002ADC                 public __CTA2?AVruntime_error@std@@
.xdata$x:00002ADC __CTA2?AVruntime_error@std@@ db    2    ; DATA XREF: .xdata$x:00002AD8o
.xdata$x:00002ADD                 db    0
.xdata$x:00002ADE                 db    0
.xdata$x:00002ADF                 db    0
.xdata$x:00002AE0                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00002AE4                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00002AE4 _xdata$x        ends
.xdata$x:00002AE4
.data$r:00002AE8 ; ===========================================================================
.data$r:00002AE8
.data$r:00002AE8 ; Segment type: Pure data
.data$r:00002AE8 ; Segment permissions: Read/Write
.data$r:00002AE8 _data$r         segment dword public 'DATA' use32
.data$r:00002AE8                 assume cs:_data$r
.data$r:00002AE8                 ;org 2AE8h
.data$r:00002AE8 ; COMDAT (pick any)
.data$r:00002AE8                 public ??_R0?AVruntime_error@std@@@8
.data$r:00002AE8 ; class std::runtime_error `RTTI Type Descriptor'
.data$r:00002AE8 ??_R0?AVruntime_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002AE8                                         ; DATA XREF: .xdata$x:00002B0Co
.data$r:00002AE8                                         ; .rdata$r:00002D50o ...
.data$r:00002AE8                                         ; const type_info::`vftable'
.data$r:00002AEC                 align 10h
.data$r:00002AF0 a_?avruntime_er db '.?AVruntime_error@std@@',0
.data$r:00002AF0 _data$r         ends
.data$r:00002AF0
.xdata$x:00002B08 ; ===========================================================================
.xdata$x:00002B08
.xdata$x:00002B08 ; Segment type: Pure data
.xdata$x:00002B08 ; Segment permissions: Read
.xdata$x:00002B08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B08                 assume cs:_xdata$x
.xdata$x:00002B08                 ;org 2B08h
.xdata$x:00002B08 ; COMDAT (pick any)
.xdata$x:00002B08                 public __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00002B08 __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00002B08                                         ; DATA XREF: .xdata$x:00002AE0o
.xdata$x:00002B09                 db    0
.xdata$x:00002B0A                 db    0
.xdata$x:00002B0B                 db    0
.xdata$x:00002B0C                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.xdata$x:00002B10                 db    0
.xdata$x:00002B11                 db    0
.xdata$x:00002B12                 db    0
.xdata$x:00002B13                 db    0
.xdata$x:00002B14                 db 0FFh
.xdata$x:00002B15                 db 0FFh
.xdata$x:00002B16                 db 0FFh
.xdata$x:00002B17                 db 0FFh
.xdata$x:00002B18                 db    0
.xdata$x:00002B19                 db    0
.xdata$x:00002B1A                 db    0
.xdata$x:00002B1B                 db    0
.xdata$x:00002B1C                 db  0Ch
.xdata$x:00002B1D                 db    0
.xdata$x:00002B1E                 db    0
.xdata$x:00002B1F                 db    0
.xdata$x:00002B20                 dd offset ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.xdata$x:00002B20 _xdata$x        ends
.xdata$x:00002B20
.data$r:00002B24 ; ===========================================================================
.data$r:00002B24
.data$r:00002B24 ; Segment type: Pure data
.data$r:00002B24 ; Segment permissions: Read/Write
.data$r:00002B24 _data$r         segment dword public 'DATA' use32
.data$r:00002B24                 assume cs:_data$r
.data$r:00002B24                 ;org 2B24h
.data$r:00002B24 ; COMDAT (pick any)
.data$r:00002B24                 public ??_R0?AVexception@std@@@8
.data$r:00002B24 ; class std::exception `RTTI Type Descriptor'
.data$r:00002B24 ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002B24                                         ; DATA XREF: .xdata$x:00002B44o
.data$r:00002B24                                         ; .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002B24                                         ; const type_info::`vftable'
.data$r:00002B28                 db    0
.data$r:00002B29                 db    0
.data$r:00002B2A                 db    0
.data$r:00002B2B                 db    0
.data$r:00002B2C                 db  2Eh ; .
.data$r:00002B2D                 db  3Fh ; ?
.data$r:00002B2E                 db  41h ; A
.data$r:00002B2F                 db  56h ; V
.data$r:00002B30                 db  65h ; e
.data$r:00002B31                 db  78h ; x
.data$r:00002B32                 db  63h ; c
.data$r:00002B33                 db  65h ; e
.data$r:00002B34                 db  70h ; p
.data$r:00002B35                 db  74h ; t
.data$r:00002B36                 db  69h ; i
.data$r:00002B37                 db  6Fh ; o
.data$r:00002B38                 db  6Eh ; n
.data$r:00002B39                 db  40h ; @
.data$r:00002B3A                 db  73h ; s
.data$r:00002B3B                 db  74h ; t
.data$r:00002B3C                 db  64h ; d
.data$r:00002B3D                 db  40h ; @
.data$r:00002B3E                 db  40h ; @
.data$r:00002B3F                 db    0
.data$r:00002B3F _data$r         ends
.data$r:00002B3F
.xdata$x:00002B40 ; ===========================================================================
.xdata$x:00002B40
.xdata$x:00002B40 ; Segment type: Pure data
.xdata$x:00002B40 ; Segment permissions: Read
.xdata$x:00002B40 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B40                 assume cs:_xdata$x
.xdata$x:00002B40                 ;org 2B40h
.xdata$x:00002B40 ; COMDAT (pick any)
.xdata$x:00002B40                 public __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00002B40 __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00002B40                                         ; DATA XREF: .xdata$x:00002AE4o
.xdata$x:00002B41                 db    0
.xdata$x:00002B42                 db    0
.xdata$x:00002B43                 db    0
.xdata$x:00002B44                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:00002B48                 db    0
.xdata$x:00002B49                 db    0
.xdata$x:00002B4A                 db    0
.xdata$x:00002B4B                 db    0
.xdata$x:00002B4C                 db 0FFh
.xdata$x:00002B4D                 db 0FFh
.xdata$x:00002B4E                 db 0FFh
.xdata$x:00002B4F                 db 0FFh
.xdata$x:00002B50                 db    0
.xdata$x:00002B51                 db    0
.xdata$x:00002B52                 db    0
.xdata$x:00002B53                 db    0
.xdata$x:00002B54                 db  0Ch
.xdata$x:00002B55                 db    0
.xdata$x:00002B56                 db    0
.xdata$x:00002B57                 db    0
.xdata$x:00002B58                 dd offset ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.xdata$x:00002B58 _xdata$x        ends
.xdata$x:00002B58
.rdata:00002B5C ; ===========================================================================
.rdata:00002B5C
.rdata:00002B5C ; Segment type: Pure data
.rdata:00002B5C ; Segment permissions: Read
.rdata:00002B5C _rdata          segment dword public 'DATA' use32
.rdata:00002B5C                 assume cs:_rdata
.rdata:00002B5C                 ;org 2B5Ch
.rdata:00002B5C ; COMDAT (pick largest)
.rdata:00002B5C                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00002B60                 public ??_7error_category@std@@6B@
.rdata:00002B60 ; const std::error_category::`vftable'
.rdata:00002B60 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00002B60                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00002B60                                         ; std::error_category::~error_category(void)+Ao
.rdata:00002B60                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00002B64                 dd offset __purecall
.rdata:00002B68                 dd offset __purecall
.rdata:00002B6C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002B70                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002B74                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002B74 _rdata          ends
.rdata:00002B74
.rdata:00002B78 ; ===========================================================================
.rdata:00002B78
.rdata:00002B78 ; Segment type: Pure data
.rdata:00002B78 ; Segment permissions: Read
.rdata:00002B78 _rdata          segment dword public 'DATA' use32
.rdata:00002B78                 assume cs:_rdata
.rdata:00002B78                 ;org 2B78h
.rdata:00002B78 ; COMDAT (pick largest)
.rdata:00002B78                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00002B7C                 public ??_7_Generic_error_category@std@@6B@
.rdata:00002B7C ; const std::_Generic_error_category::`vftable'
.rdata:00002B7C ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00002B7C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00002B7C                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00002B80                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00002B84                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00002B88                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002B8C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002B90                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002B90 _rdata          ends
.rdata:00002B90
.rdata:00002B94 ; ===========================================================================
.rdata:00002B94
.rdata:00002B94 ; Segment type: Pure data
.rdata:00002B94 ; Segment permissions: Read
.rdata:00002B94 _rdata          segment dword public 'DATA' use32
.rdata:00002B94                 assume cs:_rdata
.rdata:00002B94                 ;org 2B94h
.rdata:00002B94 ; COMDAT (pick any)
.rdata:00002B94                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00002B94 ; `string'
.rdata:00002B94 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00002B94                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00002B94 _rdata          ends
.rdata:00002B94
.rdata:00002B9C ; ===========================================================================
.rdata:00002B9C
.rdata:00002B9C ; Segment type: Pure data
.rdata:00002B9C ; Segment permissions: Read
.rdata:00002B9C _rdata          segment dword public 'DATA' use32
.rdata:00002B9C                 assume cs:_rdata
.rdata:00002B9C                 ;org 2B9Ch
.rdata:00002B9C ; COMDAT (pick any)
.rdata:00002B9C                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00002B9C ; `string'
.rdata:00002B9C ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00002B9C                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_23B8o
.rdata:00002B9C                                         ; std::_System_error_category::message(int):loc_2534o
.rdata:00002BAA                 align 4
.rdata:00002BAA _rdata          ends
.rdata:00002BAA
.rdata:00002BAC ; ===========================================================================
.rdata:00002BAC
.rdata:00002BAC ; Segment type: Pure data
.rdata:00002BAC ; Segment permissions: Read
.rdata:00002BAC _rdata          segment dword public 'DATA' use32
.rdata:00002BAC                 assume cs:_rdata
.rdata:00002BAC                 ;org 2BACh
.rdata:00002BAC ; COMDAT (pick largest)
.rdata:00002BAC                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00002BB0                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00002BB0 ; const std::_Iostream_error_category::`vftable'
.rdata:00002BB0 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00002BB0                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00002BB0                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00002BB4                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00002BB8                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00002BBC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002BC0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002BC4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002BC4 _rdata          ends
.rdata:00002BC4
.rdata:00002BC8 ; ===========================================================================
.rdata:00002BC8
.rdata:00002BC8 ; Segment type: Pure data
.rdata:00002BC8 ; Segment permissions: Read
.rdata:00002BC8 _rdata          segment dword public 'DATA' use32
.rdata:00002BC8                 assume cs:_rdata
.rdata:00002BC8                 ;org 2BC8h
.rdata:00002BC8 ; COMDAT (pick any)
.rdata:00002BC8                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00002BC8 ; `string'
.rdata:00002BC8 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00002BC8                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00002BD1                 align 4
.rdata:00002BD1 _rdata          ends
.rdata:00002BD1
.rdata:00002BD4 ; ===========================================================================
.rdata:00002BD4
.rdata:00002BD4 ; Segment type: Pure data
.rdata:00002BD4 ; Segment permissions: Read
.rdata:00002BD4 _rdata          segment dword public 'DATA' use32
.rdata:00002BD4                 assume cs:_rdata
.rdata:00002BD4                 ;org 2BD4h
.rdata:00002BD4 ; COMDAT (pick any)
.rdata:00002BD4                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00002BD4 ; char `string'[]
.rdata:00002BD4 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00002BD4                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00002BEA                 align 4
.rdata:00002BEA _rdata          ends
.rdata:00002BEA
.rdata:00002BEC ; ===========================================================================
.rdata:00002BEC
.rdata:00002BEC ; Segment type: Pure data
.rdata:00002BEC ; Segment permissions: Read
.rdata:00002BEC _rdata          segment dword public 'DATA' use32
.rdata:00002BEC                 assume cs:_rdata
.rdata:00002BEC                 ;org 2BECh
.rdata:00002BEC ; COMDAT (pick largest)
.rdata:00002BEC                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00002BF0                 public ??_7_System_error_category@std@@6B@
.rdata:00002BF0 ; const std::_System_error_category::`vftable'
.rdata:00002BF0 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00002BF0                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00002BF0                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00002BF4                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00002BF8                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00002BFC                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00002C00                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002C04                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002C04 _rdata          ends
.rdata:00002C04
.rdata:00002C08 ; ===========================================================================
.rdata:00002C08
.rdata:00002C08 ; Segment type: Pure data
.rdata:00002C08 ; Segment permissions: Read
.rdata:00002C08 _rdata          segment dword public 'DATA' use32
.rdata:00002C08                 assume cs:_rdata
.rdata:00002C08                 ;org 2C08h
.rdata:00002C08 ; COMDAT (pick any)
.rdata:00002C08                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00002C08 ; `string'
.rdata:00002C08 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00002C08                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00002C0F                 align 10h
.rdata:00002C0F _rdata          ends
.rdata:00002C0F
.bss:00002C10 ; ===========================================================================
.bss:00002C10
.bss:00002C10 ; Segment type: Uninitialized
.bss:00002C10 ; Segment permissions: Read/Write
.bss:00002C10 _bss            segment dword public 'BSS' use32
.bss:00002C10                 assume cs:_bss
.bss:00002C10                 ;org 2C10h
.bss:00002C10 ; COMDAT (pick any)
.bss:00002C10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002C10                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00002C10 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00002C10 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00002C10                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00002C10                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00002C11                 db    ? ;
.bss:00002C12                 db    ? ;
.bss:00002C13                 db    ? ;
.bss:00002C13 _bss            ends
.bss:00002C13
.bss:00002C14 ; ===========================================================================
.bss:00002C14
.bss:00002C14 ; Segment type: Uninitialized
.bss:00002C14 ; Segment permissions: Read/Write
.bss:00002C14 _bss            segment dword public 'BSS' use32
.bss:00002C14                 assume cs:_bss
.bss:00002C14                 ;org 2C14h
.bss:00002C14 ; COMDAT (pick any)
.bss:00002C14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002C14                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00002C14 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00002C14 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00002C14                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002C14                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002C15                 db    ? ;
.bss:00002C16                 db    ? ;
.bss:00002C17                 db    ? ;
.bss:00002C17 _bss            ends
.bss:00002C17
.bss:00002C18 ; ===========================================================================
.bss:00002C18
.bss:00002C18 ; Segment type: Uninitialized
.bss:00002C18 ; Segment permissions: Read/Write
.bss:00002C18 _bss            segment dword public 'BSS' use32
.bss:00002C18                 assume cs:_bss
.bss:00002C18                 ;org 2C18h
.bss:00002C18 ; COMDAT (pick any)
.bss:00002C18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002C18                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00002C18 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00002C18 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00002C18                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00002C18                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00002C19                 db    ? ;
.bss:00002C1A                 db    ? ;
.bss:00002C1B                 db    ? ;
.bss:00002C1B _bss            ends
.bss:00002C1B
.bss:00002C1C ; ===========================================================================
.bss:00002C1C
.bss:00002C1C ; Segment type: Uninitialized
.bss:00002C1C ; Segment permissions: Read/Write
.bss:00002C1C _bss            segment dword public 'BSS' use32
.bss:00002C1C                 assume cs:_bss
.bss:00002C1C                 ;org 2C1Ch
.bss:00002C1C ; COMDAT (pick any)
.bss:00002C1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002C1C                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002C1C ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00002C1C ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002C1C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00002C1D                 db    ? ;
.bss:00002C1E                 db    ? ;
.bss:00002C1F                 db    ? ;
.bss:00002C1F _bss            ends
.bss:00002C1F
.bss:00002C20 ; ===========================================================================
.bss:00002C20
.bss:00002C20 ; Segment type: Uninitialized
.bss:00002C20 ; Segment permissions: Read/Write
.bss:00002C20 _bss            segment dword public 'BSS' use32
.bss:00002C20                 assume cs:_bss
.bss:00002C20                 ;org 2C20h
.bss:00002C20 ; COMDAT (pick any)
.bss:00002C20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002C20                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002C20 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00002C20 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002C20                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00002C21                 db    ? ;
.bss:00002C22                 db    ? ;
.bss:00002C23                 db    ? ;
.bss:00002C23 _bss            ends
.bss:00002C23
.rdata:00002C24 ; ===========================================================================
.rdata:00002C24
.rdata:00002C24 ; Segment type: Pure data
.rdata:00002C24 ; Segment permissions: Read
.rdata:00002C24 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002C24 _rdata          segment para public 'DATA' use32
.rdata:00002C24                 assume cs:_rdata
.rdata:00002C24                 ;org 2C24h
.rdata:00002C24 ; COMDAT (pick any)
.rdata:00002C24                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00002C24 ; wchar_t `string'
.rdata:00002C24 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00002C24                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00002C24                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00002C24                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00002C24                 unicode 0, <clude\xstring>,0
.rdata:00002CB2                 align 4
.rdata:00002CB2 _rdata          ends
.rdata:00002CB2
.bss:00002CB4 ; ===========================================================================
.bss:00002CB4
.bss:00002CB4 ; Segment type: Uninitialized
.bss:00002CB4 ; Segment permissions: Read/Write
.bss:00002CB4 _bss            segment dword public 'BSS' use32
.bss:00002CB4                 assume cs:_bss
.bss:00002CB4                 ;org 2CB4h
.bss:00002CB4 ; COMDAT (pick any)
.bss:00002CB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002CB4                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00002CB4 ; std::locale::id std::numpunct<char>::id
.bss:00002CB4 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00002CB4                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00002CB5                 db    ? ;
.bss:00002CB6                 db    ? ;
.bss:00002CB7                 db    ? ;
.bss:00002CB7 _bss            ends
.bss:00002CB7
.bss:00002CB8 ; ===========================================================================
.bss:00002CB8
.bss:00002CB8 ; Segment type: Uninitialized
.bss:00002CB8 ; Segment permissions: Read/Write
.bss:00002CB8 _bss            segment dword public 'BSS' use32
.bss:00002CB8                 assume cs:_bss
.bss:00002CB8                 ;org 2CB8h
.bss:00002CB8 ; COMDAT (pick any)
.bss:00002CB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002CB8                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00002CB8 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00002CB8 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00002CB8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00002CB9                 db    ? ;
.bss:00002CBA                 db    ? ;
.bss:00002CBB                 db    ? ;
.bss:00002CBB _bss            ends
.bss:00002CBB
.rdata:00002CBC ; ===========================================================================
.rdata:00002CBC
.rdata:00002CBC ; Segment type: Pure data
.rdata:00002CBC ; Segment permissions: Read
.rdata:00002CBC _rdata          segment dword public 'DATA' use32
.rdata:00002CBC                 assume cs:_rdata
.rdata:00002CBC                 ;org 2CBCh
.rdata:00002CBC ; COMDAT (pick any)
.rdata:00002CBC                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00002CBC ; char `string'[]
.rdata:00002CBC ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00002CBC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00002CBC _rdata          ends
.rdata:00002CBC
.rdata:00002CCC ; ===========================================================================
.rdata:00002CCC
.rdata:00002CCC ; Segment type: Pure data
.rdata:00002CCC ; Segment permissions: Read
.rdata:00002CCC _rdata          segment dword public 'DATA' use32
.rdata:00002CCC                 assume cs:_rdata
.rdata:00002CCC                 ;org 2CCCh
.rdata:00002CCC ; COMDAT (pick any)
.rdata:00002CCC                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00002CCC ; char `string'[]
.rdata:00002CCC ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00002CCC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00002CCC _rdata          ends
.rdata:00002CCC
.rdata:00002CE4 ; ===========================================================================
.rdata:00002CE4
.rdata:00002CE4 ; Segment type: Pure data
.rdata:00002CE4 ; Segment permissions: Read
.rdata:00002CE4 _rdata          segment dword public 'DATA' use32
.rdata:00002CE4                 assume cs:_rdata
.rdata:00002CE4                 ;org 2CE4h
.rdata:00002CE4 ; COMDAT (pick any)
.rdata:00002CE4                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00002CE4 ; wchar_t `string'
.rdata:00002CE4 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00002CE4                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00002CE4                 unicode 0, <invalid null pointer>,0
.rdata:00002D0E                 align 10h
.rdata:00002D0E _rdata          ends
.rdata:00002D0E
.rdata$r:00002D10 ; ===========================================================================
.rdata$r:00002D10
.rdata$r:00002D10 ; Segment type: Pure data
.rdata$r:00002D10 ; Segment permissions: Read
.rdata$r:00002D10 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002D10                 assume cs:_rdata$r
.rdata$r:00002D10                 ;org 2D10h
.rdata$r:00002D10 ; COMDAT (pick any)
.rdata$r:00002D10                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00002D10 ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002D10 ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:00002D10                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:00002D10                                         ; .rdata$r:00002D6Co
.rdata$r:00002D10                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:00002D14                 db    0
.rdata$r:00002D15                 db    0
.rdata$r:00002D16                 db    0
.rdata$r:00002D17                 db    0
.rdata$r:00002D18                 db    0
.rdata$r:00002D19                 db    0
.rdata$r:00002D1A                 db    0
.rdata$r:00002D1B                 db    0
.rdata$r:00002D1C                 db 0FFh
.rdata$r:00002D1D                 db 0FFh
.rdata$r:00002D1E                 db 0FFh
.rdata$r:00002D1F                 db 0FFh
.rdata$r:00002D20                 db    0
.rdata$r:00002D21                 db    0
.rdata$r:00002D22                 db    0
.rdata$r:00002D23                 db    0
.rdata$r:00002D24                 db  40h ; @
.rdata$r:00002D25                 db    0
.rdata$r:00002D26                 db    0
.rdata$r:00002D27                 db    0
.rdata$r:00002D28                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002D28 _rdata$r        ends
.rdata$r:00002D28
.rdata$r:00002D2C ; ===========================================================================
.rdata$r:00002D2C
.rdata$r:00002D2C ; Segment type: Pure data
.rdata$r:00002D2C ; Segment permissions: Read
.rdata$r:00002D2C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002D2C                 assume cs:_rdata$r
.rdata$r:00002D2C                 ;org 2D2Ch
.rdata$r:00002D2C ; COMDAT (pick any)
.rdata$r:00002D2C                 public ??_R3exception@std@@8
.rdata$r:00002D2C ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002D2C ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:00002D28o
.rdata$r:00002D2D                 db    0
.rdata$r:00002D2E                 db    0
.rdata$r:00002D2F                 db    0
.rdata$r:00002D30                 db    0
.rdata$r:00002D31                 db    0
.rdata$r:00002D32                 db    0
.rdata$r:00002D33                 db    0
.rdata$r:00002D34                 db    1
.rdata$r:00002D35                 db    0
.rdata$r:00002D36                 db    0
.rdata$r:00002D37                 db    0
.rdata$r:00002D38                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:00002D38 _rdata$r        ends
.rdata$r:00002D38
.rdata$r:00002D3C ; ===========================================================================
.rdata$r:00002D3C
.rdata$r:00002D3C ; Segment type: Pure data
.rdata$r:00002D3C ; Segment permissions: Read
.rdata$r:00002D3C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002D3C                 assume cs:_rdata$r
.rdata$r:00002D3C                 ;org 2D3Ch
.rdata$r:00002D3C ; COMDAT (pick any)
.rdata$r:00002D3C                 public ??_R2exception@std@@8
.rdata$r:00002D3C ; std::exception::`RTTI Base Class Array'
.rdata$r:00002D3C ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00002D3C                                         ; DATA XREF: .rdata$r:00002D38o
.rdata$r:00002D3C                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002D40                 db    0
.rdata$r:00002D41                 align 4
.rdata$r:00002D41 _rdata$r        ends
.rdata$r:00002D41
.rdata$r:00002D44 ; ===========================================================================
.rdata$r:00002D44
.rdata$r:00002D44 ; Segment type: Pure data
.rdata$r:00002D44 ; Segment permissions: Read
.rdata$r:00002D44 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002D44                 assume cs:_rdata$r
.rdata$r:00002D44                 ;org 2D44h
.rdata$r:00002D44 ; COMDAT (pick any)
.rdata$r:00002D44                 public ??_R4runtime_error@std@@6B@
.rdata$r:00002D44 ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata$r:00002D44 ??_R4runtime_error@std@@6B@ db    0     ; DATA XREF: .rdata:00002AC0o
.rdata$r:00002D45                 db    0
.rdata$r:00002D46                 db    0
.rdata$r:00002D47                 db    0
.rdata$r:00002D48                 db    0
.rdata$r:00002D49                 db    0
.rdata$r:00002D4A                 db    0
.rdata$r:00002D4B                 db    0
.rdata$r:00002D4C                 db    0
.rdata$r:00002D4D                 db    0
.rdata$r:00002D4E                 db    0
.rdata$r:00002D4F                 db    0
.rdata$r:00002D50                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00002D54                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002D54 _rdata$r        ends
.rdata$r:00002D54
.rdata$r:00002D58 ; ===========================================================================
.rdata$r:00002D58
.rdata$r:00002D58 ; Segment type: Pure data
.rdata$r:00002D58 ; Segment permissions: Read
.rdata$r:00002D58 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002D58                 assume cs:_rdata$r
.rdata$r:00002D58                 ;org 2D58h
.rdata$r:00002D58 ; COMDAT (pick any)
.rdata$r:00002D58                 public ??_R3runtime_error@std@@8
.rdata$r:00002D58 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002D58 ??_R3runtime_error@std@@8 db    0       ; DATA XREF: .rdata$r:00002D54o
.rdata$r:00002D58                                         ; .rdata$r:00002D8Co
.rdata$r:00002D59                 db    0
.rdata$r:00002D5A                 db    0
.rdata$r:00002D5B                 db    0
.rdata$r:00002D5C                 db    0
.rdata$r:00002D5D                 db    0
.rdata$r:00002D5E                 db    0
.rdata$r:00002D5F                 db    0
.rdata$r:00002D60                 db    2
.rdata$r:00002D61                 db    0
.rdata$r:00002D62                 db    0
.rdata$r:00002D63                 db    0
.rdata$r:00002D64                 dd offset ??_R2runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00002D64 _rdata$r        ends
.rdata$r:00002D64
.rdata$r:00002D68 ; ===========================================================================
.rdata$r:00002D68
.rdata$r:00002D68 ; Segment type: Pure data
.rdata$r:00002D68 ; Segment permissions: Read
.rdata$r:00002D68 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002D68                 assume cs:_rdata$r
.rdata$r:00002D68                 ;org 2D68h
.rdata$r:00002D68 ; COMDAT (pick any)
.rdata$r:00002D68                 public ??_R2runtime_error@std@@8
.rdata$r:00002D68 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00002D68 ??_R2runtime_error@std@@8 dd offset ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00002D68                                         ; DATA XREF: .rdata$r:00002D64o
.rdata$r:00002D68                                         ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002D6C                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002D70                 db    0
.rdata$r:00002D71                 align 4
.rdata$r:00002D71 _rdata$r        ends
.rdata$r:00002D71
.rdata$r:00002D74 ; ===========================================================================
.rdata$r:00002D74
.rdata$r:00002D74 ; Segment type: Pure data
.rdata$r:00002D74 ; Segment permissions: Read
.rdata$r:00002D74 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002D74                 assume cs:_rdata$r
.rdata$r:00002D74                 ;org 2D74h
.rdata$r:00002D74 ; COMDAT (pick any)
.rdata$r:00002D74                 public ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00002D74 ; std::runtime_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002D74 ??_R1A@?0A@EA@runtime_error@std@@8 dd offset ??_R0?AVruntime_error@std@@@8
.rdata$r:00002D74                                         ; DATA XREF: .rdata$r:std::runtime_error::`RTTI Base Class Array'o
.rdata$r:00002D74                                         ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00002D78                 db    1
.rdata$r:00002D79                 db    0
.rdata$r:00002D7A                 db    0
.rdata$r:00002D7B                 db    0
.rdata$r:00002D7C                 db    0
.rdata$r:00002D7D                 db    0
.rdata$r:00002D7E                 db    0
.rdata$r:00002D7F                 db    0
.rdata$r:00002D80                 db 0FFh
.rdata$r:00002D81                 db 0FFh
.rdata$r:00002D82                 db 0FFh
.rdata$r:00002D83                 db 0FFh
.rdata$r:00002D84                 db    0
.rdata$r:00002D85                 db    0
.rdata$r:00002D86                 db    0
.rdata$r:00002D87                 db    0
.rdata$r:00002D88                 db  40h ; @
.rdata$r:00002D89                 db    0
.rdata$r:00002D8A                 db    0
.rdata$r:00002D8B                 db    0
.rdata$r:00002D8C                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002D8C _rdata$r        ends
.rdata$r:00002D8C
.rdata$r:00002D90 ; ===========================================================================
.rdata$r:00002D90
.rdata$r:00002D90 ; Segment type: Pure data
.rdata$r:00002D90 ; Segment permissions: Read
.rdata$r:00002D90 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002D90                 assume cs:_rdata$r
.rdata$r:00002D90                 ;org 2D90h
.rdata$r:00002D90 ; COMDAT (pick any)
.rdata$r:00002D90                 public ??_R4error_category@std@@6B@
.rdata$r:00002D90 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00002D90 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00002B5Co
.rdata$r:00002D91                 db    0
.rdata$r:00002D92                 db    0
.rdata$r:00002D93                 db    0
.rdata$r:00002D94                 db    0
.rdata$r:00002D95                 db    0
.rdata$r:00002D96                 db    0
.rdata$r:00002D97                 db    0
.rdata$r:00002D98                 db    0
.rdata$r:00002D99                 db    0
.rdata$r:00002D9A                 db    0
.rdata$r:00002D9B                 db    0
.rdata$r:00002D9C                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002DA0                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002DA0 _rdata$r        ends
.rdata$r:00002DA0
.data$r:00002DA4 ; ===========================================================================
.data$r:00002DA4
.data$r:00002DA4 ; Segment type: Pure data
.data$r:00002DA4 ; Segment permissions: Read/Write
.data$r:00002DA4 _data$r         segment dword public 'DATA' use32
.data$r:00002DA4                 assume cs:_data$r
.data$r:00002DA4                 ;org 2DA4h
.data$r:00002DA4 ; COMDAT (pick any)
.data$r:00002DA4                 public ??_R0?AVerror_category@std@@@8
.data$r:00002DA4 ; class std::error_category `RTTI Type Descriptor'
.data$r:00002DA4 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002DA4                                         ; DATA XREF: .rdata$r:00002D9Co
.data$r:00002DA4                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002DA4                                         ; const type_info::`vftable'
.data$r:00002DA8                 db    0
.data$r:00002DA9                 db    0
.data$r:00002DAA                 db    0
.data$r:00002DAB                 db    0
.data$r:00002DAC                 db  2Eh ; .
.data$r:00002DAD                 db  3Fh ; ?
.data$r:00002DAE                 db  41h ; A
.data$r:00002DAF                 db  56h ; V
.data$r:00002DB0                 db  65h ; e
.data$r:00002DB1                 db  72h ; r
.data$r:00002DB2                 db  72h ; r
.data$r:00002DB3                 db  6Fh ; o
.data$r:00002DB4                 db  72h ; r
.data$r:00002DB5                 db  5Fh ; _
.data$r:00002DB6                 db  63h ; c
.data$r:00002DB7                 db  61h ; a
.data$r:00002DB8                 db  74h ; t
.data$r:00002DB9                 db  65h ; e
.data$r:00002DBA                 db  67h ; g
.data$r:00002DBB                 db  6Fh ; o
.data$r:00002DBC                 db  72h ; r
.data$r:00002DBD                 db  79h ; y
.data$r:00002DBE                 db  40h ; @
.data$r:00002DBF                 db  73h ; s
.data$r:00002DC0                 db  74h ; t
.data$r:00002DC1                 db  64h ; d
.data$r:00002DC2                 db  40h ; @
.data$r:00002DC3                 db  40h ; @
.data$r:00002DC4                 db    0
.data$r:00002DC5                 align 4
.data$r:00002DC5 _data$r         ends
.data$r:00002DC5
.rdata$r:00002DC8 ; ===========================================================================
.rdata$r:00002DC8
.rdata$r:00002DC8 ; Segment type: Pure data
.rdata$r:00002DC8 ; Segment permissions: Read
.rdata$r:00002DC8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002DC8                 assume cs:_rdata$r
.rdata$r:00002DC8                 ;org 2DC8h
.rdata$r:00002DC8 ; COMDAT (pick any)
.rdata$r:00002DC8                 public ??_R3error_category@std@@8
.rdata$r:00002DC8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002DC8 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00002DA0o
.rdata$r:00002DC8                                         ; .rdata$r:00002DF8o
.rdata$r:00002DC9                 db    0
.rdata$r:00002DCA                 db    0
.rdata$r:00002DCB                 db    0
.rdata$r:00002DCC                 db    0
.rdata$r:00002DCD                 db    0
.rdata$r:00002DCE                 db    0
.rdata$r:00002DCF                 db    0
.rdata$r:00002DD0                 db    1
.rdata$r:00002DD1                 db    0
.rdata$r:00002DD2                 db    0
.rdata$r:00002DD3                 db    0
.rdata$r:00002DD4                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002DD4 _rdata$r        ends
.rdata$r:00002DD4
.rdata$r:00002DD8 ; ===========================================================================
.rdata$r:00002DD8
.rdata$r:00002DD8 ; Segment type: Pure data
.rdata$r:00002DD8 ; Segment permissions: Read
.rdata$r:00002DD8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002DD8                 assume cs:_rdata$r
.rdata$r:00002DD8                 ;org 2DD8h
.rdata$r:00002DD8 ; COMDAT (pick any)
.rdata$r:00002DD8                 public ??_R2error_category@std@@8
.rdata$r:00002DD8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002DD8 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002DD8                                         ; DATA XREF: .rdata$r:00002DD4o
.rdata$r:00002DD8                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002DDC                 db    0
.rdata$r:00002DDD                 align 10h
.rdata$r:00002DDD _rdata$r        ends
.rdata$r:00002DDD
.rdata$r:00002DE0 ; ===========================================================================
.rdata$r:00002DE0
.rdata$r:00002DE0 ; Segment type: Pure data
.rdata$r:00002DE0 ; Segment permissions: Read
.rdata$r:00002DE0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002DE0                 assume cs:_rdata$r
.rdata$r:00002DE0                 ;org 2DE0h
.rdata$r:00002DE0 ; COMDAT (pick any)
.rdata$r:00002DE0                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002DE0 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002DE0 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00002DE0                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00002DE0                                         ; .rdata$r:00002E50o ...
.rdata$r:00002DE0                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002DE4                 db    0
.rdata$r:00002DE5                 db    0
.rdata$r:00002DE6                 db    0
.rdata$r:00002DE7                 db    0
.rdata$r:00002DE8                 db    0
.rdata$r:00002DE9                 db    0
.rdata$r:00002DEA                 db    0
.rdata$r:00002DEB                 db    0
.rdata$r:00002DEC                 db 0FFh
.rdata$r:00002DED                 db 0FFh
.rdata$r:00002DEE                 db 0FFh
.rdata$r:00002DEF                 db 0FFh
.rdata$r:00002DF0                 db    0
.rdata$r:00002DF1                 db    0
.rdata$r:00002DF2                 db    0
.rdata$r:00002DF3                 db    0
.rdata$r:00002DF4                 db  40h ; @
.rdata$r:00002DF5                 db    0
.rdata$r:00002DF6                 db    0
.rdata$r:00002DF7                 db    0
.rdata$r:00002DF8                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002DF8 _rdata$r        ends
.rdata$r:00002DF8
.rdata$r:00002DFC ; ===========================================================================
.rdata$r:00002DFC
.rdata$r:00002DFC ; Segment type: Pure data
.rdata$r:00002DFC ; Segment permissions: Read
.rdata$r:00002DFC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002DFC                 assume cs:_rdata$r
.rdata$r:00002DFC                 ;org 2DFCh
.rdata$r:00002DFC ; COMDAT (pick any)
.rdata$r:00002DFC                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00002DFC ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00002DFC ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00002DFC                                         ; DATA XREF: .rdata:00002B78o
.rdata$r:00002DFD                 db    0
.rdata$r:00002DFE                 db    0
.rdata$r:00002DFF                 db    0
.rdata$r:00002E00                 db    0
.rdata$r:00002E01                 db    0
.rdata$r:00002E02                 db    0
.rdata$r:00002E03                 db    0
.rdata$r:00002E04                 db    0
.rdata$r:00002E05                 db    0
.rdata$r:00002E06                 db    0
.rdata$r:00002E07                 db    0
.rdata$r:00002E08                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002E0C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002E0C _rdata$r        ends
.rdata$r:00002E0C
.data$r:00002E10 ; ===========================================================================
.data$r:00002E10
.data$r:00002E10 ; Segment type: Pure data
.data$r:00002E10 ; Segment permissions: Read/Write
.data$r:00002E10 _data$r         segment dword public 'DATA' use32
.data$r:00002E10                 assume cs:_data$r
.data$r:00002E10                 ;org 2E10h
.data$r:00002E10 ; COMDAT (pick any)
.data$r:00002E10                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00002E10 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00002E10 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002E10                                         ; DATA XREF: .rdata$r:00002E08o
.data$r:00002E10                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002E10                                         ; const type_info::`vftable'
.data$r:00002E14                 align 8
.data$r:00002E18 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:00002E3A                 align 4
.data$r:00002E3A _data$r         ends
.data$r:00002E3A
.rdata$r:00002E3C ; ===========================================================================
.rdata$r:00002E3C
.rdata$r:00002E3C ; Segment type: Pure data
.rdata$r:00002E3C ; Segment permissions: Read
.rdata$r:00002E3C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002E3C                 assume cs:_rdata$r
.rdata$r:00002E3C                 ;org 2E3Ch
.rdata$r:00002E3C ; COMDAT (pick any)
.rdata$r:00002E3C                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00002E3C ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002E3C ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00002E3C                                         ; DATA XREF: .rdata$r:00002E0Co
.rdata$r:00002E3C                                         ; .rdata$r:00002E70o
.rdata$r:00002E3D                 db    0
.rdata$r:00002E3E                 db    0
.rdata$r:00002E3F                 db    0
.rdata$r:00002E40                 db    0
.rdata$r:00002E41                 db    0
.rdata$r:00002E42                 db    0
.rdata$r:00002E43                 db    0
.rdata$r:00002E44                 db    2
.rdata$r:00002E45                 db    0
.rdata$r:00002E46                 db    0
.rdata$r:00002E47                 db    0
.rdata$r:00002E48                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00002E48 _rdata$r        ends
.rdata$r:00002E48
.rdata$r:00002E4C ; ===========================================================================
.rdata$r:00002E4C
.rdata$r:00002E4C ; Segment type: Pure data
.rdata$r:00002E4C ; Segment permissions: Read
.rdata$r:00002E4C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002E4C                 assume cs:_rdata$r
.rdata$r:00002E4C                 ;org 2E4Ch
.rdata$r:00002E4C ; COMDAT (pick any)
.rdata$r:00002E4C                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00002E4C ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00002E4C ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002E4C                                         ; DATA XREF: .rdata$r:00002E48o
.rdata$r:00002E4C                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002E50                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002E54                 db    0
.rdata$r:00002E55                 align 4
.rdata$r:00002E55 _rdata$r        ends
.rdata$r:00002E55
.rdata$r:00002E58 ; ===========================================================================
.rdata$r:00002E58
.rdata$r:00002E58 ; Segment type: Pure data
.rdata$r:00002E58 ; Segment permissions: Read
.rdata$r:00002E58 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002E58                 assume cs:_rdata$r
.rdata$r:00002E58                 ;org 2E58h
.rdata$r:00002E58 ; COMDAT (pick any)
.rdata$r:00002E58                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002E58 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002E58 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00002E58                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00002E58                                         ; .rdata$r:00002EC8o ...
.rdata$r:00002E58                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002E5C                 db    1
.rdata$r:00002E5D                 db    0
.rdata$r:00002E5E                 db    0
.rdata$r:00002E5F                 db    0
.rdata$r:00002E60                 db    0
.rdata$r:00002E61                 db    0
.rdata$r:00002E62                 db    0
.rdata$r:00002E63                 db    0
.rdata$r:00002E64                 db 0FFh
.rdata$r:00002E65                 db 0FFh
.rdata$r:00002E66                 db 0FFh
.rdata$r:00002E67                 db 0FFh
.rdata$r:00002E68                 db    0
.rdata$r:00002E69                 db    0
.rdata$r:00002E6A                 db    0
.rdata$r:00002E6B                 db    0
.rdata$r:00002E6C                 db  40h ; @
.rdata$r:00002E6D                 db    0
.rdata$r:00002E6E                 db    0
.rdata$r:00002E6F                 db    0
.rdata$r:00002E70                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002E70 _rdata$r        ends
.rdata$r:00002E70
.rdata$r:00002E74 ; ===========================================================================
.rdata$r:00002E74
.rdata$r:00002E74 ; Segment type: Pure data
.rdata$r:00002E74 ; Segment permissions: Read
.rdata$r:00002E74 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002E74                 assume cs:_rdata$r
.rdata$r:00002E74                 ;org 2E74h
.rdata$r:00002E74 ; COMDAT (pick any)
.rdata$r:00002E74                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00002E74 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00002E74 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00002E74                                         ; DATA XREF: .rdata:00002BACo
.rdata$r:00002E75                 db    0
.rdata$r:00002E76                 db    0
.rdata$r:00002E77                 db    0
.rdata$r:00002E78                 db    0
.rdata$r:00002E79                 db    0
.rdata$r:00002E7A                 db    0
.rdata$r:00002E7B                 db    0
.rdata$r:00002E7C                 db    0
.rdata$r:00002E7D                 db    0
.rdata$r:00002E7E                 db    0
.rdata$r:00002E7F                 db    0
.rdata$r:00002E80                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002E84                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002E84 _rdata$r        ends
.rdata$r:00002E84
.data$r:00002E88 ; ===========================================================================
.data$r:00002E88
.data$r:00002E88 ; Segment type: Pure data
.data$r:00002E88 ; Segment permissions: Read/Write
.data$r:00002E88 _data$r         segment dword public 'DATA' use32
.data$r:00002E88                 assume cs:_data$r
.data$r:00002E88                 ;org 2E88h
.data$r:00002E88 ; COMDAT (pick any)
.data$r:00002E88                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00002E88 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00002E88 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002E88                                         ; DATA XREF: .rdata$r:00002E80o
.data$r:00002E88                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002E88                                         ; const type_info::`vftable'
.data$r:00002E8C                 align 10h
.data$r:00002E90 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:00002EB3                 align 4
.data$r:00002EB3 _data$r         ends
.data$r:00002EB3
.rdata$r:00002EB4 ; ===========================================================================
.rdata$r:00002EB4
.rdata$r:00002EB4 ; Segment type: Pure data
.rdata$r:00002EB4 ; Segment permissions: Read
.rdata$r:00002EB4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002EB4                 assume cs:_rdata$r
.rdata$r:00002EB4                 ;org 2EB4h
.rdata$r:00002EB4 ; COMDAT (pick any)
.rdata$r:00002EB4                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00002EB4 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002EB4 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00002EB4                                         ; DATA XREF: .rdata$r:00002E84o
.rdata$r:00002EB4                                         ; .rdata$r:00002EECo
.rdata$r:00002EB5                 db    0
.rdata$r:00002EB6                 db    0
.rdata$r:00002EB7                 db    0
.rdata$r:00002EB8                 db    0
.rdata$r:00002EB9                 db    0
.rdata$r:00002EBA                 db    0
.rdata$r:00002EBB                 db    0
.rdata$r:00002EBC                 db    3
.rdata$r:00002EBD                 db    0
.rdata$r:00002EBE                 db    0
.rdata$r:00002EBF                 db    0
.rdata$r:00002EC0                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002EC0 _rdata$r        ends
.rdata$r:00002EC0
.rdata$r:00002EC4 ; ===========================================================================
.rdata$r:00002EC4
.rdata$r:00002EC4 ; Segment type: Pure data
.rdata$r:00002EC4 ; Segment permissions: Read
.rdata$r:00002EC4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002EC4                 assume cs:_rdata$r
.rdata$r:00002EC4                 ;org 2EC4h
.rdata$r:00002EC4 ; COMDAT (pick any)
.rdata$r:00002EC4                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00002EC4 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002EC4 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002EC4                                         ; DATA XREF: .rdata$r:00002EC0o
.rdata$r:00002EC4                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002EC8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002ECC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002ED0                 db    0
.rdata$r:00002ED1                 align 4
.rdata$r:00002ED1 _rdata$r        ends
.rdata$r:00002ED1
.rdata$r:00002ED4 ; ===========================================================================
.rdata$r:00002ED4
.rdata$r:00002ED4 ; Segment type: Pure data
.rdata$r:00002ED4 ; Segment permissions: Read
.rdata$r:00002ED4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002ED4                 assume cs:_rdata$r
.rdata$r:00002ED4                 ;org 2ED4h
.rdata$r:00002ED4 ; COMDAT (pick any)
.rdata$r:00002ED4                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002ED4 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002ED4 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00002ED4                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00002ED4                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002ED8                 db    2
.rdata$r:00002ED9                 db    0
.rdata$r:00002EDA                 db    0
.rdata$r:00002EDB                 db    0
.rdata$r:00002EDC                 db    0
.rdata$r:00002EDD                 db    0
.rdata$r:00002EDE                 db    0
.rdata$r:00002EDF                 db    0
.rdata$r:00002EE0                 db 0FFh
.rdata$r:00002EE1                 db 0FFh
.rdata$r:00002EE2                 db 0FFh
.rdata$r:00002EE3                 db 0FFh
.rdata$r:00002EE4                 db    0
.rdata$r:00002EE5                 db    0
.rdata$r:00002EE6                 db    0
.rdata$r:00002EE7                 db    0
.rdata$r:00002EE8                 db  40h ; @
.rdata$r:00002EE9                 db    0
.rdata$r:00002EEA                 db    0
.rdata$r:00002EEB                 db    0
.rdata$r:00002EEC                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002EEC _rdata$r        ends
.rdata$r:00002EEC
.rdata$r:00002EF0 ; ===========================================================================
.rdata$r:00002EF0
.rdata$r:00002EF0 ; Segment type: Pure data
.rdata$r:00002EF0 ; Segment permissions: Read
.rdata$r:00002EF0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002EF0                 assume cs:_rdata$r
.rdata$r:00002EF0                 ;org 2EF0h
.rdata$r:00002EF0 ; COMDAT (pick any)
.rdata$r:00002EF0                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00002EF0 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00002EF0 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00002BECo
.rdata$r:00002EF1                 db    0
.rdata$r:00002EF2                 db    0
.rdata$r:00002EF3                 db    0
.rdata$r:00002EF4                 db    0
.rdata$r:00002EF5                 db    0
.rdata$r:00002EF6                 db    0
.rdata$r:00002EF7                 db    0
.rdata$r:00002EF8                 db    0
.rdata$r:00002EF9                 db    0
.rdata$r:00002EFA                 db    0
.rdata$r:00002EFB                 db    0
.rdata$r:00002EFC                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002F00                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F00 _rdata$r        ends
.rdata$r:00002F00
.data$r:00002F04 ; ===========================================================================
.data$r:00002F04
.data$r:00002F04 ; Segment type: Pure data
.data$r:00002F04 ; Segment permissions: Read/Write
.data$r:00002F04 _data$r         segment dword public 'DATA' use32
.data$r:00002F04                 assume cs:_data$r
.data$r:00002F04                 ;org 2F04h
.data$r:00002F04 ; COMDAT (pick any)
.data$r:00002F04                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00002F04 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00002F04 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002F04                                         ; DATA XREF: .rdata$r:00002EFCo
.data$r:00002F04                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002F04                                         ; const type_info::`vftable'
.data$r:00002F08                 db    0
.data$r:00002F09                 db    0
.data$r:00002F0A                 db    0
.data$r:00002F0B                 db    0
.data$r:00002F0C                 db  2Eh ; .
.data$r:00002F0D                 db  3Fh ; ?
.data$r:00002F0E                 db  41h ; A
.data$r:00002F0F                 db  56h ; V
.data$r:00002F10                 db  5Fh ; _
.data$r:00002F11                 db  53h ; S
.data$r:00002F12                 db  79h ; y
.data$r:00002F13                 db  73h ; s
.data$r:00002F14                 db  74h ; t
.data$r:00002F15                 db  65h ; e
.data$r:00002F16                 db  6Dh ; m
.data$r:00002F17                 db  5Fh ; _
.data$r:00002F18                 db  65h ; e
.data$r:00002F19                 db  72h ; r
.data$r:00002F1A                 db  72h ; r
.data$r:00002F1B                 db  6Fh ; o
.data$r:00002F1C                 db  72h ; r
.data$r:00002F1D                 db  5Fh ; _
.data$r:00002F1E                 db  63h ; c
.data$r:00002F1F                 db  61h ; a
.data$r:00002F20                 db  74h ; t
.data$r:00002F21                 db  65h ; e
.data$r:00002F22                 db  67h ; g
.data$r:00002F23                 db  6Fh ; o
.data$r:00002F24                 db  72h ; r
.data$r:00002F25                 db  79h ; y
.data$r:00002F26                 db  40h ; @
.data$r:00002F27                 db  73h ; s
.data$r:00002F28                 db  74h ; t
.data$r:00002F29                 db  64h ; d
.data$r:00002F2A                 db  40h ; @
.data$r:00002F2B                 db  40h ; @
.data$r:00002F2C                 db    0
.data$r:00002F2D                 align 10h
.data$r:00002F2D _data$r         ends
.data$r:00002F2D
.rdata$r:00002F30 ; ===========================================================================
.rdata$r:00002F30
.rdata$r:00002F30 ; Segment type: Pure data
.rdata$r:00002F30 ; Segment permissions: Read
.rdata$r:00002F30 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F30                 assume cs:_rdata$r
.rdata$r:00002F30                 ;org 2F30h
.rdata$r:00002F30 ; COMDAT (pick any)
.rdata$r:00002F30                 public ??_R3_System_error_category@std@@8
.rdata$r:00002F30 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F30 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00002F00o
.rdata$r:00002F30                                         ; .rdata$r:00002F68o
.rdata$r:00002F31                 db    0
.rdata$r:00002F32                 db    0
.rdata$r:00002F33                 db    0
.rdata$r:00002F34                 db    0
.rdata$r:00002F35                 db    0
.rdata$r:00002F36                 db    0
.rdata$r:00002F37                 db    0
.rdata$r:00002F38                 db    3
.rdata$r:00002F39                 db    0
.rdata$r:00002F3A                 db    0
.rdata$r:00002F3B                 db    0
.rdata$r:00002F3C                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002F3C _rdata$r        ends
.rdata$r:00002F3C
.rdata$r:00002F40 ; ===========================================================================
.rdata$r:00002F40
.rdata$r:00002F40 ; Segment type: Pure data
.rdata$r:00002F40 ; Segment permissions: Read
.rdata$r:00002F40 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F40                 assume cs:_rdata$r
.rdata$r:00002F40                 ;org 2F40h
.rdata$r:00002F40 ; COMDAT (pick any)
.rdata$r:00002F40                 public ??_R2_System_error_category@std@@8
.rdata$r:00002F40 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002F40 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002F40                                         ; DATA XREF: .rdata$r:00002F3Co
.rdata$r:00002F40                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002F44                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002F48                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002F4C                 db    0
.rdata$r:00002F4D                 align 10h
.rdata$r:00002F4D _rdata$r        ends
.rdata$r:00002F4D
.rdata$r:00002F50 ; ===========================================================================
.rdata$r:00002F50
.rdata$r:00002F50 ; Segment type: Pure data
.rdata$r:00002F50 ; Segment permissions: Read
.rdata$r:00002F50 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F50                 assume cs:_rdata$r
.rdata$r:00002F50                 ;org 2F50h
.rdata$r:00002F50 ; COMDAT (pick any)
.rdata$r:00002F50                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002F50 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002F50 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00002F50                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00002F50                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002F54                 db    2
.rdata$r:00002F55                 db    0
.rdata$r:00002F56                 db    0
.rdata$r:00002F57                 db    0
.rdata$r:00002F58                 db    0
.rdata$r:00002F59                 db    0
.rdata$r:00002F5A                 db    0
.rdata$r:00002F5B                 db    0
.rdata$r:00002F5C                 db 0FFh
.rdata$r:00002F5D                 db 0FFh
.rdata$r:00002F5E                 db 0FFh
.rdata$r:00002F5F                 db 0FFh
.rdata$r:00002F60                 db    0
.rdata$r:00002F61                 db    0
.rdata$r:00002F62                 db    0
.rdata$r:00002F63                 db    0
.rdata$r:00002F64                 db  40h ; @
.rdata$r:00002F65                 db    0
.rdata$r:00002F66                 db    0
.rdata$r:00002F67                 db    0
.rdata$r:00002F68                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F68 _rdata$r        ends
.rdata$r:00002F68
.CRT$XCU:00002F6C ; ===========================================================================
.CRT$XCU:00002F6C
.CRT$XCU:00002F6C ; Segment type: Pure data
.CRT$XCU:00002F6C ; Segment permissions: Read
.CRT$XCU:00002F6C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002F6C                 assume cs:_CRT$XCU
.CRT$XCU:00002F6C                 ;org 2F6Ch
.CRT$XCU:00002F6C _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00002F70 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00002F70 _CRT$XCU        ends
.CRT$XCU:00002F70
.CRT$XCU:00002F74 ; ===========================================================================
.CRT$XCU:00002F74
.CRT$XCU:00002F74 ; Segment type: Pure data
.CRT$XCU:00002F74 ; Segment permissions: Read
.CRT$XCU:00002F74 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002F74                 assume cs:_CRT$XCU
.CRT$XCU:00002F74                 ;org 2F74h
.CRT$XCU:00002F74 ; COMDAT (pick associative to section at 2C10)
.CRT$XCU:00002F74 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00002F74 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00002F74 _CRT$XCU        ends
.CRT$XCU:00002F74
.CRT$XCU:00002F78 ; ===========================================================================
.CRT$XCU:00002F78
.CRT$XCU:00002F78 ; Segment type: Pure data
.CRT$XCU:00002F78 ; Segment permissions: Read
.CRT$XCU:00002F78 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002F78                 assume cs:_CRT$XCU
.CRT$XCU:00002F78                 ;org 2F78h
.CRT$XCU:00002F78 ; COMDAT (pick associative to section at 2C14)
.CRT$XCU:00002F78 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00002F78 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00002F78 _CRT$XCU        ends
.CRT$XCU:00002F78
.CRT$XCU:00002F7C ; ===========================================================================
.CRT$XCU:00002F7C
.CRT$XCU:00002F7C ; Segment type: Pure data
.CRT$XCU:00002F7C ; Segment permissions: Read
.CRT$XCU:00002F7C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002F7C                 assume cs:_CRT$XCU
.CRT$XCU:00002F7C                 ;org 2F7Ch
.CRT$XCU:00002F7C ; COMDAT (pick associative to section at 2C18)
.CRT$XCU:00002F7C ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00002F7C ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00002F7C _CRT$XCU        ends
.CRT$XCU:00002F7C
.CRT$XCU:00002F80 ; ===========================================================================
.CRT$XCU:00002F80
.CRT$XCU:00002F80 ; Segment type: Pure data
.CRT$XCU:00002F80 ; Segment permissions: Read
.CRT$XCU:00002F80 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002F80                 assume cs:_CRT$XCU
.CRT$XCU:00002F80                 ;org 2F80h
.CRT$XCU:00002F80 ; COMDAT (pick associative to section at 2C1C)
.CRT$XCU:00002F80 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00002F80 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00002F80 _CRT$XCU        ends
.CRT$XCU:00002F80
.CRT$XCU:00002F84 ; ===========================================================================
.CRT$XCU:00002F84
.CRT$XCU:00002F84 ; Segment type: Pure data
.CRT$XCU:00002F84 ; Segment permissions: Read
.CRT$XCU:00002F84 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002F84                 assume cs:_CRT$XCU
.CRT$XCU:00002F84                 ;org 2F84h
.CRT$XCU:00002F84 ; COMDAT (pick associative to section at 2C20)
.CRT$XCU:00002F84 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00002F84 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00002F84 _CRT$XCU        ends
.CRT$XCU:00002F84
.CRT$XCU:00002F88 ; ===========================================================================
.CRT$XCU:00002F88
.CRT$XCU:00002F88 ; Segment type: Pure data
.CRT$XCU:00002F88 ; Segment permissions: Read
.CRT$XCU:00002F88 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002F88                 assume cs:_CRT$XCU
.CRT$XCU:00002F88                 ;org 2F88h
.CRT$XCU:00002F88 ; COMDAT (pick associative to section at 2CB4)
.CRT$XCU:00002F88 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00002F88 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00002F88 _CRT$XCU        ends
.CRT$XCU:00002F88
.CRT$XCU:00002F8C ; ===========================================================================
.CRT$XCU:00002F8C
.CRT$XCU:00002F8C ; Segment type: Pure data
.CRT$XCU:00002F8C ; Segment permissions: Read
.CRT$XCU:00002F8C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002F8C                 assume cs:_CRT$XCU
.CRT$XCU:00002F8C                 ;org 2F8Ch
.CRT$XCU:00002F8C ; COMDAT (pick associative to section at 2CB8)
.CRT$XCU:00002F8C ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00002F8C ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00002F8C _CRT$XCU        ends
.CRT$XCU:00002F8C
UNDEF:00002F90 ; ===========================================================================
UNDEF:00002F90
UNDEF:00002F90 ; Segment type: Externs
UNDEF:00002F90 ; UNDEF
UNDEF:00002F90                 extrn __purecall:near   ; DATA XREF: .rdata:00002B64o
UNDEF:00002F90                                         ; .rdata:00002B68o
UNDEF:00002F94 ; void *__cdecl operator new(unsigned int)
UNDEF:00002F94                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00002F94                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:00002F98 ; void __cdecl operator delete(void *)
UNDEF:00002F98                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00002F98                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:00002F9C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:00002F9C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:00002F9C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00002FA0 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00002FA0                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00002FA4 ; size_t __cdecl strlen(const char *Str)
UNDEF:00002FA4                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00002FA8 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00002FA8                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00002FAC ; HFONT __stdcall CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
UNDEF:00002FAC                 extrn __imp__CreateFontW@56:near
UNDEF:00002FAC                                         ; CODE XREF: TaskList::setFont(wchar_t *,uint)+56p
UNDEF:00002FAC                                         ; TaskList::setFont(wchar_t *,uint)+85p
UNDEF:00002FAC                                         ; DATA XREF: ...
UNDEF:00002FB0 ; BOOL __stdcall DeleteObject(HGDIOBJ ho)
UNDEF:00002FB0                 extrn __imp__DeleteObject@4:near
UNDEF:00002FB0                                         ; CODE XREF: TaskList::destroy(void)+17p
UNDEF:00002FB0                                         ; TaskList::destroy(void)+2Dp ...
UNDEF:00002FB4 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00002FB4                 extrn __imp__SendMessageW@16:near
UNDEF:00002FB4                                         ; CODE XREF: TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+E4p
UNDEF:00002FB4                                         ; TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+10Bp ...
UNDEF:00002FB8 ; LRESULT __stdcall CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00002FB8                 extrn __imp__CallWindowProcW@20:near
UNDEF:00002FB8                                         ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+50Ap
UNDEF:00002FB8                                         ; DATA XREF: TaskList::runProc(HWND__ *,uint,uint,long)+50Ar
UNDEF:00002FBC ; HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
UNDEF:00002FBC                 extrn __imp__CreateWindowExW@48:near
UNDEF:00002FBC                                         ; CODE XREF: TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+77p
UNDEF:00002FBC                                         ; DATA XREF: TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+77r
UNDEF:00002FC0 ; BOOL __stdcall DestroyWindow(HWND hWnd)
UNDEF:00002FC0                 extrn __imp__DestroyWindow@4:near
UNDEF:00002FC0                                         ; CODE XREF: TaskList::destroy(void)+3Ap
UNDEF:00002FC0                                         ; DATA XREF: TaskList::destroy(void)+3Ar
UNDEF:00002FC4 ; SHORT __stdcall GetKeyState(int nVirtKey)
UNDEF:00002FC4                 extrn __imp__GetKeyState@4:near
UNDEF:00002FC4                                         ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+2ADp
UNDEF:00002FC4                                         ; TaskList::runProc(HWND__ *,uint,uint,long)+2CDp
UNDEF:00002FC4                                         ; DATA XREF: ...
UNDEF:00002FC8 ; BOOL __stdcall UpdateWindow(HWND hWnd)
UNDEF:00002FC8                 extrn __imp__UpdateWindow@4:near
UNDEF:00002FC8                                         ; CODE XREF: TaskList::runProc(HWND__ *,uint,uint,long)+121p
UNDEF:00002FC8                                         ; TaskList::runProc(HWND__ *,uint,uint,long)+179p ...
UNDEF:00002FCC ; LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex)
UNDEF:00002FCC                 extrn __imp__GetWindowLongW@8:near
UNDEF:00002FCC                                         ; CODE XREF: TaskList::staticProc(HWND__ *,uint,uint,long)+19p
UNDEF:00002FCC                                         ; DATA XREF: TaskList::staticProc(HWND__ *,uint,uint,long)+19r
UNDEF:00002FD0 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:00002FD0                 extrn __imp__SetWindowLongW@12:near
UNDEF:00002FD0                                         ; CODE XREF: TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+B4p
UNDEF:00002FD0                                         ; TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+C8p
UNDEF:00002FD0                                         ; DATA XREF: ...
UNDEF:00002FD4 ; BOOL __stdcall InitCommonControlsEx(const INITCOMMONCONTROLSEX *picce)
UNDEF:00002FD4                 extrn __imp__InitCommonControlsEx@4:near
UNDEF:00002FD4                                         ; CODE XREF: TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+34p
UNDEF:00002FD4                                         ; DATA XREF: TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+34r
UNDEF:00002FD8 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00002FD8                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00002FD8                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00002FDC ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00002FDC                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00002FDC                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00002FDC                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00002FE0                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00002FE4 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:00002FE4                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:00002FE4                                         ; CODE XREF: std::runtime_error::runtime_error(char const *)+2Dp
UNDEF:00002FE8 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *)
UNDEF:00002FE8                 extrn ??0exception@std@@QAE@ABV01@@Z:near
UNDEF:00002FE8                                         ; CODE XREF: std::runtime_error::runtime_error(std::runtime_error const &)+2Dp
UNDEF:00002FE8                                         ; DATA XREF: .xdata$x:00002B58o
UNDEF:00002FEC ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:00002FEC                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:00002FEC                                         ; CODE XREF: __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0+3j
UNDEF:00002FEC                                         ; __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0+3j ...
UNDEF:00002FF0 ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:00002FF0                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:00002FF0                                         ; DATA XREF: .rdata:00002AC8o
UNDEF:00002FF4 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00002FF4                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00002FF4                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00002FF8 ; void __cdecl std::_Xbad_alloc()
UNDEF:00002FF8                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00002FF8                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_B9Ep
UNDEF:00002FF8                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_BE0p
UNDEF:00002FFC ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00002FFC                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00002FFC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00003000 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00003000                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00003000                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00003004 ; public: virtual void * __thiscall std::runtime_error::`vector deleting destructor'(unsigned int)
UNDEF:00003004                 extrn ??_Eruntime_error@std@@UAEPAXI@Z:near ; weak
UNDEF:00003004                                         ; DATA XREF: .rdata:const std::runtime_error::`vftable'o
UNDEF:00003008 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003008                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003008                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:0000300C ; const char *__cdecl std::_Syserror_map(int)
UNDEF:0000300C                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:0000300C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:0000300C                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00003010 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00003010                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00003010                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00003014 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003014                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003014                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00003018 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003018                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003018                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:0000301C ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000301C                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000301C                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00003020 ; __fastcall __security_check_cookie(x)
UNDEF:00003020                 extrn @__security_check_cookie@4:near
UNDEF:00003020                                         ; CODE XREF: TaskList::adjustSize(void)+2B0p
UNDEF:00003020                                         ; __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp ...
UNDEF:00003024 ; __stdcall _CxxThrowException(x, x)
UNDEF:00003024                 extrn __CxxThrowException@8:near
UNDEF:00003024                                         ; CODE XREF: TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)+A2p
UNDEF:00003024                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:00003028                 extrn ___CxxFrameHandler3:near
UNDEF:00003028                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:00003028                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:0000302C ; const type_info::`vftable'
UNDEF:0000302C                 extrn ??_7type_info@@6B@:near
UNDEF:0000302C                                         ; DATA XREF: .data$r:std::runtime_error `RTTI Type Descriptor'o
UNDEF:0000302C                                         ; .data$r:std::exception `RTTI Type Descriptor'o ...
UNDEF:00003030 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:00003030                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:00003030                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:00003034                 extrn ___security_cookie:near
UNDEF:00003034                                         ; DATA XREF: TaskList::adjustSize(void)+9r
UNDEF:00003034                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r ...
UNDEF:00003038                 extrn __fltused:near
UNDEF:00003038
UNDEF:00003038                 end
UNDEF:00003038