.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : F51BCE2EFC2949221530A25162C9D17E
.rdata:00000000 ; Input CRC32 : 2797D9A0
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\TreeView.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; const WCHAR _SG99037
.rdata:00000000 $SG99037:                               ; DATA XREF: TreeView::init(HINSTANCE__ *,HWND__ *,int)+4Ao
.rdata:00000000                 unicode 0, <Tree View>,0
.rdata:00000014 ; const WCHAR _SG99038
.rdata:00000014 $SG99038:                               ; DATA XREF: TreeView::init(HINSTANCE__ *,HWND__ *,int)+4Fo
.rdata:00000014                 unicode 0, <SysTreeView32>,0
.rdata:00000014 _rdata          ends
.rdata:00000014
.text$mn:00000030 ; ===========================================================================
.text$mn:00000030
.text$mn:00000030 ; Segment type: Pure code
.text$mn:00000030 ; Segment permissions: Read/Execute
.text$mn:00000030 _text$mn        segment para public 'CODE' use32
.text$mn:00000030                 assume cs:_text$mn
.text$mn:00000030                 ;org 30h
.text$mn:00000030                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000030
.text$mn:00000030 ; =============== S U B R O U T I N E =======================================
.text$mn:00000030
.text$mn:00000030 ; Attributes: bp-based frame
.text$mn:00000030
.text$mn:00000030 ; void __thiscall TreeView::init(TreeView *this, HINSTANCE, HWND hDlg, int)
.text$mn:00000030                 public ?init@TreeView@@UAEXPAUHINSTANCE__@@PAUHWND__@@H@Z
.text$mn:00000030 ?init@TreeView@@UAEXPAUHINSTANCE__@@PAUHWND__@@H@Z proc near
.text$mn:00000030
.text$mn:00000030 dwNewLong       = dword ptr -4
.text$mn:00000030 arg_0           = dword ptr  8
.text$mn:00000030 hDlg            = dword ptr  0Ch
.text$mn:00000030 nIDDlgItem      = dword ptr  10h
.text$mn:00000030
.text$mn:00000030                 push    ebp
.text$mn:00000031                 mov     ebp, esp
.text$mn:00000033                 push    ecx
.text$mn:00000034                 mov     [ebp+dwNewLong], ecx
.text$mn:00000037                 mov     eax, [ebp+hDlg]
.text$mn:0000003A                 push    eax             ; HWND
.text$mn:0000003B                 mov     ecx, [ebp+arg_0]
.text$mn:0000003E                 push    ecx             ; HINSTANCE
.text$mn:0000003F                 mov     ecx, [ebp+dwNewLong] ; this
.text$mn:00000042                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:00000047                 mov     edx, [ebp+nIDDlgItem]
.text$mn:0000004A                 push    edx             ; nIDDlgItem
.text$mn:0000004B                 mov     eax, [ebp+hDlg]
.text$mn:0000004E                 push    eax             ; hDlg
.text$mn:0000004F                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00000055                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000058                 mov     [ecx+0Ch], eax
.text$mn:0000005B                 push    0               ; lpParam
.text$mn:0000005D                 mov     edx, [ebp+dwNewLong]
.text$mn:00000060                 mov     eax, [edx+4]
.text$mn:00000063                 push    eax             ; hInstance
.text$mn:00000064                 push    0               ; hMenu
.text$mn:00000066                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000069                 mov     edx, [ecx+8]
.text$mn:0000006C                 push    edx             ; hWndParent
.text$mn:0000006D                 push    0               ; nHeight
.text$mn:0000006F                 push    0               ; nWidth
.text$mn:00000071                 push    0               ; Y
.text$mn:00000073                 push    0               ; X
.text$mn:00000075                 push    4091082Fh       ; dwStyle
.text$mn:0000007A                 push    offset $SG99037 ; "Tree View"
.text$mn:0000007F                 push    offset $SG99038 ; "SysTreeView32"
.text$mn:00000084                 push    0               ; dwExStyle
.text$mn:00000086                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:0000008C                 mov     ecx, [ebp+dwNewLong]
.text$mn:0000008F                 mov     [ecx+0Ch], eax
.text$mn:00000092                 push    0               ; lParam
.text$mn:00000094                 push    12h             ; wParam
.text$mn:00000096                 push    111Bh           ; Msg
.text$mn:0000009B                 mov     edx, [ebp+dwNewLong]
.text$mn:0000009E                 mov     eax, [edx+0Ch]
.text$mn:000000A1                 push    eax             ; hWnd
.text$mn:000000A2                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000000A8                 mov     ecx, [ebp+dwNewLong]
.text$mn:000000AB                 push    ecx             ; dwNewLong
.text$mn:000000AC                 push    0FFFFFFEBh      ; nIndex
.text$mn:000000AE                 mov     edx, [ebp+dwNewLong]
.text$mn:000000B1                 mov     eax, [edx+0Ch]
.text$mn:000000B4                 push    eax             ; hWnd
.text$mn:000000B5                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:000000BB                 push    offset ?staticProc@TreeView@@KGJPAUHWND__@@IIJ@Z ; dwNewLong
.text$mn:000000C0                 push    0FFFFFFFCh      ; nIndex
.text$mn:000000C2                 mov     ecx, [ebp+dwNewLong]
.text$mn:000000C5                 mov     edx, [ecx+0Ch]
.text$mn:000000C8                 push    edx             ; hWnd
.text$mn:000000C9                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:000000CF                 mov     ecx, [ebp+dwNewLong]
.text$mn:000000D2                 mov     [ecx+10h], eax
.text$mn:000000D5                 mov     esp, ebp
.text$mn:000000D7                 pop     ebp
.text$mn:000000D8                 retn    0Ch
.text$mn:000000D8 ?init@TreeView@@UAEXPAUHINSTANCE__@@PAUHWND__@@H@Z endp
.text$mn:000000D8
.text$mn:000000D8 ; ---------------------------------------------------------------------------
.text$mn:000000DB                 align 10h
.text$mn:000000E0
.text$mn:000000E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000000E0
.text$mn:000000E0 ; Attributes: bp-based frame
.text$mn:000000E0
.text$mn:000000E0 ; void __thiscall TreeView::destroy(TreeView *__hidden this)
.text$mn:000000E0                 public ?destroy@TreeView@@UAEXXZ
.text$mn:000000E0 ?destroy@TreeView@@UAEXXZ proc near
.text$mn:000000E0
.text$mn:000000E0 var_8           = dword ptr -8
.text$mn:000000E0 var_4           = dword ptr -4
.text$mn:000000E0
.text$mn:000000E0                 push    ebp
.text$mn:000000E1                 mov     ebp, esp
.text$mn:000000E3                 sub     esp, 8
.text$mn:000000E6                 mov     [ebp+var_4], ecx
.text$mn:000000E9                 push    0               ; lParam
.text$mn:000000EB                 push    0               ; wParam
.text$mn:000000ED                 push    110Ah           ; Msg
.text$mn:000000F2                 mov     eax, [ebp+var_4]
.text$mn:000000F5                 mov     ecx, [eax+0Ch]
.text$mn:000000F8                 push    ecx             ; hWnd
.text$mn:000000F9                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000000FF                 mov     [ebp+var_8], eax
.text$mn:00000102                 mov     edx, [ebp+var_8]
.text$mn:00000105                 push    edx             ; struct _TREEITEM *
.text$mn:00000106                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000109                 call    ?cleanSubEntries@TreeView@@IAEXPAU_TREEITEM@@@Z ; TreeView::cleanSubEntries(_TREEITEM *)
.text$mn:0000010E                 mov     eax, [ebp+var_4]
.text$mn:00000111                 mov     ecx, [eax+0Ch]
.text$mn:00000114                 push    ecx             ; hWnd
.text$mn:00000115                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:0000011B                 mov     edx, [ebp+var_4]
.text$mn:0000011E                 mov     dword ptr [edx+0Ch], 0
.text$mn:00000125                 mov     esp, ebp
.text$mn:00000127                 pop     ebp
.text$mn:00000128                 retn
.text$mn:00000128 ?destroy@TreeView@@UAEXXZ endp
.text$mn:00000128
.text$mn:00000128 ; ---------------------------------------------------------------------------
.text$mn:00000129                 align 10h
.text$mn:00000130
.text$mn:00000130 ; =============== S U B R O U T I N E =======================================
.text$mn:00000130
.text$mn:00000130 ; Attributes: bp-based frame
.text$mn:00000130
.text$mn:00000130 ; struct _TREEITEM *__thiscall TreeView::addItem(TreeView *this, const wchar_t *, struct _TREEITEM *, int, const wchar_t *)
.text$mn:00000130                 public ?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z
.text$mn:00000130 ?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z proc near
.text$mn:00000130
.text$mn:00000130 lParam          = dword ptr -88h
.text$mn:00000130 var_84          = dword ptr -84h
.text$mn:00000130 var_80          = byte ptr -80h
.text$mn:00000130 var_48          = dword ptr -48h
.text$mn:00000130 var_38          = dword ptr -38h
.text$mn:00000130 var_34          = dword ptr -34h
.text$mn:00000130 var_30          = dword ptr -30h
.text$mn:00000130 var_2C          = dword ptr -2Ch
.text$mn:00000130 var_24          = dword ptr -24h
.text$mn:00000130 var_20          = dword ptr -20h
.text$mn:00000130 var_1C          = dword ptr -1Ch
.text$mn:00000130 var_18          = dword ptr -18h
.text$mn:00000130 var_14          = dword ptr -14h
.text$mn:00000130 var_10          = dword ptr -10h
.text$mn:00000130 var_C           = dword ptr -0Ch
.text$mn:00000130 var_4           = dword ptr -4
.text$mn:00000130 arg_0           = dword ptr  8
.text$mn:00000130 arg_4           = dword ptr  0Ch
.text$mn:00000130 arg_8           = dword ptr  10h
.text$mn:00000130 Str             = dword ptr  14h
.text$mn:00000130
.text$mn:00000130                 push    ebp
.text$mn:00000131                 mov     ebp, esp
.text$mn:00000133                 push    0FFFFFFFFh
.text$mn:00000135                 push    offset __ehhandler$?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z
.text$mn:0000013A                 mov     eax, large fs:0
.text$mn:00000140                 push    eax
.text$mn:00000141                 sub     esp, 7Ch
.text$mn:00000144                 push    esi
.text$mn:00000145                 push    edi
.text$mn:00000146                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000014B                 xor     eax, ebp
.text$mn:0000014D                 push    eax
.text$mn:0000014E                 lea     eax, [ebp+var_C]
.text$mn:00000151                 mov     large fs:0, eax
.text$mn:00000157                 mov     [ebp+var_20], ecx
.text$mn:0000015A                 mov     [ebp+var_48], 27h ; '''
.text$mn:00000161                 mov     eax, [ebp+arg_0]
.text$mn:00000164                 mov     [ebp+var_38], eax
.text$mn:00000167                 mov     [ebp+var_34], 104h
.text$mn:0000016E                 mov     ecx, [ebp+arg_8]
.text$mn:00000171                 mov     [ebp+var_30], ecx
.text$mn:00000174                 mov     edx, [ebp+arg_8]
.text$mn:00000177                 mov     [ebp+var_2C], edx
.text$mn:0000017A                 cmp     [ebp+Str], 0
.text$mn:0000017E                 jnz     short loc_189
.text$mn:00000180                 mov     [ebp+var_18], 0
.text$mn:00000187                 jmp     short loc_1CE
.text$mn:00000189 ; ---------------------------------------------------------------------------
.text$mn:00000189
.text$mn:00000189 loc_189:                                ; CODE XREF: TreeView::addItem(wchar_t const *,_TREEITEM *,int,wchar_t const *)+4Ej
.text$mn:00000189                 push    1Ch             ; unsigned int
.text$mn:0000018B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000190                 add     esp, 4
.text$mn:00000193                 mov     [ebp+var_10], eax
.text$mn:00000196                 mov     [ebp+var_4], 0
.text$mn:0000019D                 cmp     [ebp+var_10], 0
.text$mn:000001A1                 jz      short loc_1B4
.text$mn:000001A3                 mov     eax, [ebp+Str]
.text$mn:000001A6                 push    eax             ; Str
.text$mn:000001A7                 mov     ecx, [ebp+var_10]
.text$mn:000001AA                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000001AF                 mov     [ebp+var_14], eax
.text$mn:000001B2                 jmp     short loc_1BB
.text$mn:000001B4 ; ---------------------------------------------------------------------------
.text$mn:000001B4
.text$mn:000001B4 loc_1B4:                                ; CODE XREF: TreeView::addItem(wchar_t const *,_TREEITEM *,int,wchar_t const *)+71j
.text$mn:000001B4                 mov     [ebp+var_14], 0
.text$mn:000001BB
.text$mn:000001BB loc_1BB:                                ; CODE XREF: TreeView::addItem(wchar_t const *,_TREEITEM *,int,wchar_t const *)+82j
.text$mn:000001BB                 mov     ecx, [ebp+var_14]
.text$mn:000001BE                 mov     [ebp+var_1C], ecx
.text$mn:000001C1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000001C8                 mov     edx, [ebp+var_1C]
.text$mn:000001CB                 mov     [ebp+var_18], edx
.text$mn:000001CE
.text$mn:000001CE loc_1CE:                                ; CODE XREF: TreeView::addItem(wchar_t const *,_TREEITEM *,int,wchar_t const *)+57j
.text$mn:000001CE                 mov     eax, [ebp+var_18]
.text$mn:000001D1                 mov     [ebp+var_24], eax
.text$mn:000001D4                 mov     ecx, 0Ah
.text$mn:000001D9                 lea     esi, [ebp+var_48]
.text$mn:000001DC                 lea     edi, [ebp+var_80]
.text$mn:000001DF                 rep movsd
.text$mn:000001E1                 mov     [ebp+var_84], 0FFFF0002h
.text$mn:000001EB                 mov     ecx, [ebp+arg_4]
.text$mn:000001EE                 mov     [ebp+lParam], ecx
.text$mn:000001F4                 lea     edx, [ebp+lParam]
.text$mn:000001FA                 push    edx             ; lParam
.text$mn:000001FB                 push    0               ; wParam
.text$mn:000001FD                 push    1132h           ; Msg
.text$mn:00000202                 mov     eax, [ebp+var_20]
.text$mn:00000205                 mov     ecx, [eax+0Ch]
.text$mn:00000208                 push    ecx             ; hWnd
.text$mn:00000209                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000020F                 mov     ecx, [ebp+var_C]
.text$mn:00000212                 mov     large fs:0, ecx
.text$mn:00000219                 pop     ecx
.text$mn:0000021A                 pop     edi
.text$mn:0000021B                 pop     esi
.text$mn:0000021C                 mov     esp, ebp
.text$mn:0000021E                 pop     ebp
.text$mn:0000021F                 retn    10h
.text$mn:0000021F ?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z endp
.text$mn:0000021F
.text$mn:0000021F ; ---------------------------------------------------------------------------
.text$mn:00000222                 align 10h
.text$mn:00000230
.text$mn:00000230 ; =============== S U B R O U T I N E =======================================
.text$mn:00000230
.text$mn:00000230 ; Attributes: bp-based frame
.text$mn:00000230
.text$mn:00000230 ; bool __thiscall TreeView::setItemParam(TreeView *this, struct _TREEITEM *, const wchar_t *)
.text$mn:00000230                 public ?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z
.text$mn:00000230 ?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z proc near
.text$mn:00000230
.text$mn:00000230 lParam          = dword ptr -44h
.text$mn:00000230 var_40          = dword ptr -40h
.text$mn:00000230 var_20          = dword ptr -20h
.text$mn:00000230 var_1C          = dword ptr -1Ch
.text$mn:00000230 var_18          = dword ptr -18h
.text$mn:00000230 var_14          = dword ptr -14h
.text$mn:00000230 var_10          = dword ptr -10h
.text$mn:00000230 var_C           = dword ptr -0Ch
.text$mn:00000230 var_4           = dword ptr -4
.text$mn:00000230 arg_0           = dword ptr  8
.text$mn:00000230 Str             = dword ptr  0Ch
.text$mn:00000230
.text$mn:00000230                 push    ebp
.text$mn:00000231                 mov     ebp, esp
.text$mn:00000233                 push    0FFFFFFFFh
.text$mn:00000235                 push    offset __ehhandler$?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z
.text$mn:0000023A                 mov     eax, large fs:0
.text$mn:00000240                 push    eax
.text$mn:00000241                 sub     esp, 38h
.text$mn:00000244                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000249                 xor     eax, ebp
.text$mn:0000024B                 push    eax
.text$mn:0000024C                 lea     eax, [ebp+var_C]
.text$mn:0000024F                 mov     large fs:0, eax
.text$mn:00000255                 mov     [ebp+var_18], ecx
.text$mn:00000258                 cmp     [ebp+arg_0], 0
.text$mn:0000025C                 jnz     short loc_265
.text$mn:0000025E                 xor     al, al
.text$mn:00000260                 jmp     loc_2FD
.text$mn:00000265 ; ---------------------------------------------------------------------------
.text$mn:00000265
.text$mn:00000265 loc_265:                                ; CODE XREF: TreeView::setItemParam(_TREEITEM *,wchar_t const *)+2Cj
.text$mn:00000265                 mov     eax, [ebp+arg_0]
.text$mn:00000268                 mov     [ebp+var_40], eax
.text$mn:0000026B                 mov     [ebp+lParam], 4
.text$mn:00000272                 lea     ecx, [ebp+lParam]
.text$mn:00000275                 push    ecx             ; lParam
.text$mn:00000276                 push    0               ; wParam
.text$mn:00000278                 push    113Eh           ; Msg
.text$mn:0000027D                 mov     edx, [ebp+var_18]
.text$mn:00000280                 mov     eax, [edx+0Ch]
.text$mn:00000283                 push    eax             ; hWnd
.text$mn:00000284                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000028A                 cmp     [ebp+var_20], 0
.text$mn:0000028E                 jnz     short loc_2D7
.text$mn:00000290                 push    1Ch             ; unsigned int
.text$mn:00000292                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000297                 add     esp, 4
.text$mn:0000029A                 mov     [ebp+var_10], eax
.text$mn:0000029D                 mov     [ebp+var_4], 0
.text$mn:000002A4                 cmp     [ebp+var_10], 0
.text$mn:000002A8                 jz      short loc_2BB
.text$mn:000002AA                 mov     ecx, [ebp+Str]
.text$mn:000002AD                 push    ecx             ; Str
.text$mn:000002AE                 mov     ecx, [ebp+var_10]
.text$mn:000002B1                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000002B6                 mov     [ebp+var_14], eax
.text$mn:000002B9                 jmp     short loc_2C2
.text$mn:000002BB ; ---------------------------------------------------------------------------
.text$mn:000002BB
.text$mn:000002BB loc_2BB:                                ; CODE XREF: TreeView::setItemParam(_TREEITEM *,wchar_t const *)+78j
.text$mn:000002BB                 mov     [ebp+var_14], 0
.text$mn:000002C2
.text$mn:000002C2 loc_2C2:                                ; CODE XREF: TreeView::setItemParam(_TREEITEM *,wchar_t const *)+89j
.text$mn:000002C2                 mov     edx, [ebp+var_14]
.text$mn:000002C5                 mov     [ebp+var_1C], edx
.text$mn:000002C8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000002CF                 mov     eax, [ebp+var_1C]
.text$mn:000002D2                 mov     [ebp+var_20], eax
.text$mn:000002D5                 jmp     short loc_2E3
.text$mn:000002D7 ; ---------------------------------------------------------------------------
.text$mn:000002D7
.text$mn:000002D7 loc_2D7:                                ; CODE XREF: TreeView::setItemParam(_TREEITEM *,wchar_t const *)+5Ej
.text$mn:000002D7                 mov     ecx, [ebp+Str]
.text$mn:000002DA                 push    ecx             ; Str
.text$mn:000002DB                 mov     ecx, [ebp+var_20]
.text$mn:000002DE                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:000002E3
.text$mn:000002E3 loc_2E3:                                ; CODE XREF: TreeView::setItemParam(_TREEITEM *,wchar_t const *)+A5j
.text$mn:000002E3                 lea     edx, [ebp+lParam]
.text$mn:000002E6                 push    edx             ; lParam
.text$mn:000002E7                 push    0               ; wParam
.text$mn:000002E9                 push    113Fh           ; Msg
.text$mn:000002EE                 mov     eax, [ebp+var_18]
.text$mn:000002F1                 mov     ecx, [eax+0Ch]
.text$mn:000002F4                 push    ecx             ; hWnd
.text$mn:000002F5                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000002FB                 mov     al, 1
.text$mn:000002FD
.text$mn:000002FD loc_2FD:                                ; CODE XREF: TreeView::setItemParam(_TREEITEM *,wchar_t const *)+30j
.text$mn:000002FD                 mov     ecx, [ebp+var_C]
.text$mn:00000300                 mov     large fs:0, ecx
.text$mn:00000307                 pop     ecx
.text$mn:00000308                 mov     esp, ebp
.text$mn:0000030A                 pop     ebp
.text$mn:0000030B                 retn    8
.text$mn:0000030B ?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z endp
.text$mn:0000030B
.text$mn:0000030B ; ---------------------------------------------------------------------------
.text$mn:0000030E                 align 10h
.text$mn:00000310
.text$mn:00000310 ; =============== S U B R O U T I N E =======================================
.text$mn:00000310
.text$mn:00000310 ; Attributes: bp-based frame
.text$mn:00000310
.text$mn:00000310 ; struct _TREEITEM *__thiscall TreeView::searchSubItemByName(TreeView *this, LPCWSTR lpString1, struct _TREEITEM *)
.text$mn:00000310                 public ?searchSubItemByName@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@@Z
.text$mn:00000310 ?searchSubItemByName@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@@Z proc near
.text$mn:00000310
.text$mn:00000310 lParam          = dword ptr -23Ch
.text$mn:00000310 var_238         = dword ptr -238h
.text$mn:00000310 lpString2       = dword ptr -22Ch
.text$mn:00000310 var_228         = dword ptr -228h
.text$mn:00000310 var_214         = dword ptr -214h
.text$mn:00000310 var_210         = dword ptr -210h
.text$mn:00000310 var_20C         = byte ptr -20Ch
.text$mn:00000310 var_4           = dword ptr -4
.text$mn:00000310 lpString1       = dword ptr  8
.text$mn:00000310 arg_4           = dword ptr  0Ch
.text$mn:00000310
.text$mn:00000310                 push    ebp
.text$mn:00000311                 mov     ebp, esp
.text$mn:00000313                 sub     esp, 23Ch
.text$mn:00000319                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000031E                 xor     eax, ebp
.text$mn:00000320                 mov     [ebp+var_4], eax
.text$mn:00000323                 mov     [ebp+var_214], ecx
.text$mn:00000329                 mov     [ebp+var_210], 0
.text$mn:00000333                 cmp     [ebp+arg_4], 0
.text$mn:00000337                 jz      short loc_350
.text$mn:00000339                 mov     eax, [ebp+arg_4]
.text$mn:0000033C                 push    eax             ; struct _TREEITEM *
.text$mn:0000033D                 mov     ecx, [ebp+var_214] ; this
.text$mn:00000343                 call    ?getChildFrom@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getChildFrom(_TREEITEM *)
.text$mn:00000348                 mov     [ebp+var_210], eax
.text$mn:0000034E                 jmp     short loc_361
.text$mn:00000350 ; ---------------------------------------------------------------------------
.text$mn:00000350
.text$mn:00000350 loc_350:                                ; CODE XREF: TreeView::searchSubItemByName(wchar_t const *,_TREEITEM *)+27j
.text$mn:00000350                 mov     ecx, [ebp+var_214] ; this
.text$mn:00000356                 call    ?getRoot@TreeView@@QBEPAU_TREEITEM@@XZ ; TreeView::getRoot(void)
.text$mn:0000035B                 mov     [ebp+var_210], eax
.text$mn:00000361
.text$mn:00000361 loc_361:                                ; CODE XREF: TreeView::searchSubItemByName(wchar_t const *,_TREEITEM *)+3Ej
.text$mn:00000361                 jmp     short loc_37B
.text$mn:00000363 ; ---------------------------------------------------------------------------
.text$mn:00000363
.text$mn:00000363 loc_363:                                ; CODE XREF: TreeView::searchSubItemByName(wchar_t const *,_TREEITEM *):loc_3EBj
.text$mn:00000363                 mov     ecx, [ebp+var_210]
.text$mn:00000369                 push    ecx             ; struct _TREEITEM *
.text$mn:0000036A                 mov     ecx, [ebp+var_214] ; this
.text$mn:00000370                 call    ?getNextSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getNextSibling(_TREEITEM *)
.text$mn:00000375                 mov     [ebp+var_210], eax
.text$mn:0000037B
.text$mn:0000037B loc_37B:                                ; CODE XREF: TreeView::searchSubItemByName(wchar_t const *,_TREEITEM *):loc_361j
.text$mn:0000037B                 cmp     [ebp+var_210], 0
.text$mn:00000382                 jz      short loc_3F0
.text$mn:00000384                 mov     edx, [ebp+var_210]
.text$mn:0000038A                 mov     [ebp+var_238], edx
.text$mn:00000390                 lea     eax, [ebp+var_20C]
.text$mn:00000396                 mov     [ebp+lpString2], eax
.text$mn:0000039C                 mov     [ebp+var_228], 104h
.text$mn:000003A6                 mov     [ebp+lParam], 1
.text$mn:000003B0                 lea     ecx, [ebp+lParam]
.text$mn:000003B6                 push    ecx             ; lParam
.text$mn:000003B7                 push    0               ; wParam
.text$mn:000003B9                 push    113Eh           ; Msg
.text$mn:000003BE                 mov     edx, [ebp+var_214]
.text$mn:000003C4                 mov     eax, [edx+0Ch]
.text$mn:000003C7                 push    eax             ; hWnd
.text$mn:000003C8                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000003CE                 mov     ecx, [ebp+lpString2]
.text$mn:000003D4                 push    ecx             ; lpString2
.text$mn:000003D5                 mov     edx, [ebp+lpString1]
.text$mn:000003D8                 push    edx             ; lpString1
.text$mn:000003D9                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:000003DF                 test    eax, eax
.text$mn:000003E1                 jnz     short loc_3EB
.text$mn:000003E3                 mov     eax, [ebp+var_210]
.text$mn:000003E9                 jmp     short loc_3F2
.text$mn:000003EB ; ---------------------------------------------------------------------------
.text$mn:000003EB
.text$mn:000003EB loc_3EB:                                ; CODE XREF: TreeView::searchSubItemByName(wchar_t const *,_TREEITEM *)+D1j
.text$mn:000003EB                 jmp     loc_363
.text$mn:000003F0 ; ---------------------------------------------------------------------------
.text$mn:000003F0
.text$mn:000003F0 loc_3F0:                                ; CODE XREF: TreeView::searchSubItemByName(wchar_t const *,_TREEITEM *)+72j
.text$mn:000003F0                 xor     eax, eax
.text$mn:000003F2
.text$mn:000003F2 loc_3F2:                                ; CODE XREF: TreeView::searchSubItemByName(wchar_t const *,_TREEITEM *)+D9j
.text$mn:000003F2                 mov     ecx, [ebp+var_4]
.text$mn:000003F5                 xor     ecx, ebp
.text$mn:000003F7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000003FC                 mov     esp, ebp
.text$mn:000003FE                 pop     ebp
.text$mn:000003FF                 retn    8
.text$mn:000003FF ?searchSubItemByName@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@@Z endp
.text$mn:000003FF
.text$mn:000003FF ; ---------------------------------------------------------------------------
.text$mn:00000402                 align 10h
.text$mn:00000410
.text$mn:00000410 ; =============== S U B R O U T I N E =======================================
.text$mn:00000410
.text$mn:00000410 ; Attributes: bp-based frame
.text$mn:00000410
.text$mn:00000410 ; void __thiscall TreeView::removeItem(TreeView *this, struct _TREEITEM *)
.text$mn:00000410                 public ?removeItem@TreeView@@QAEXPAU_TREEITEM@@@Z
.text$mn:00000410 ?removeItem@TreeView@@QAEXPAU_TREEITEM@@@Z proc near
.text$mn:00000410                                         ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+34Fp
.text$mn:00000410                                         ; TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+35Ep ...
.text$mn:00000410
.text$mn:00000410 lParam          = dword ptr -38h
.text$mn:00000410 var_34          = dword ptr -34h
.text$mn:00000410 var_14          = dword ptr -14h
.text$mn:00000410 var_10          = dword ptr -10h
.text$mn:00000410 var_C           = dword ptr -0Ch
.text$mn:00000410 var_8           = dword ptr -8
.text$mn:00000410 var_4           = dword ptr -4
.text$mn:00000410 arg_0           = dword ptr  8
.text$mn:00000410
.text$mn:00000410                 push    ebp
.text$mn:00000411                 mov     ebp, esp
.text$mn:00000413                 sub     esp, 38h
.text$mn:00000416                 mov     [ebp+var_4], ecx
.text$mn:00000419                 mov     eax, [ebp+arg_0]
.text$mn:0000041C                 push    eax             ; struct _TREEITEM *
.text$mn:0000041D                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000420                 call    ?cleanSubEntries@TreeView@@IAEXPAU_TREEITEM@@@Z ; TreeView::cleanSubEntries(_TREEITEM *)
.text$mn:00000425                 mov     ecx, [ebp+arg_0]
.text$mn:00000428                 mov     [ebp+var_34], ecx
.text$mn:0000042B                 mov     [ebp+lParam], 4
.text$mn:00000432                 lea     edx, [ebp+lParam]
.text$mn:00000435                 push    edx             ; lParam
.text$mn:00000436                 push    0               ; wParam
.text$mn:00000438                 push    113Eh           ; Msg
.text$mn:0000043D                 mov     eax, [ebp+var_4]
.text$mn:00000440                 mov     ecx, [eax+0Ch]
.text$mn:00000443                 push    ecx             ; hWnd
.text$mn:00000444                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000044A                 cmp     [ebp+var_14], 0
.text$mn:0000044E                 jz      short loc_478
.text$mn:00000450                 mov     edx, [ebp+var_14]
.text$mn:00000453                 mov     [ebp+var_C], edx
.text$mn:00000456                 mov     eax, [ebp+var_C]
.text$mn:00000459                 mov     [ebp+var_8], eax
.text$mn:0000045C                 cmp     [ebp+var_8], 0
.text$mn:00000460                 jz      short loc_471
.text$mn:00000462                 push    1
.text$mn:00000464                 mov     ecx, [ebp+var_8]
.text$mn:00000467                 call    ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`scalar deleting destructor'(uint)
.text$mn:0000046C                 mov     [ebp+var_10], eax
.text$mn:0000046F                 jmp     short loc_478
.text$mn:00000471 ; ---------------------------------------------------------------------------
.text$mn:00000471
.text$mn:00000471 loc_471:                                ; CODE XREF: TreeView::removeItem(_TREEITEM *)+50j
.text$mn:00000471                 mov     [ebp+var_10], 0
.text$mn:00000478
.text$mn:00000478 loc_478:                                ; CODE XREF: TreeView::removeItem(_TREEITEM *)+3Ej
.text$mn:00000478                                         ; TreeView::removeItem(_TREEITEM *)+5Fj
.text$mn:00000478                 mov     ecx, [ebp+arg_0]
.text$mn:0000047B                 push    ecx             ; lParam
.text$mn:0000047C                 push    0               ; wParam
.text$mn:0000047E                 push    1101h           ; Msg
.text$mn:00000483                 mov     edx, [ebp+var_4]
.text$mn:00000486                 mov     eax, [edx+0Ch]
.text$mn:00000489                 push    eax             ; hWnd
.text$mn:0000048A                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000490                 mov     esp, ebp
.text$mn:00000492                 pop     ebp
.text$mn:00000493                 retn    4
.text$mn:00000493 ?removeItem@TreeView@@QAEXPAU_TREEITEM@@@Z endp
.text$mn:00000493
.text$mn:00000493 ; ---------------------------------------------------------------------------
.text$mn:00000496                 align 10h
.text$mn:000004A0
.text$mn:000004A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000004A0
.text$mn:000004A0 ; Attributes: bp-based frame
.text$mn:000004A0
.text$mn:000004A0 ; void __thiscall TreeView::removeAllItems(TreeView *__hidden this)
.text$mn:000004A0                 public ?removeAllItems@TreeView@@QAEXXZ
.text$mn:000004A0 ?removeAllItems@TreeView@@QAEXXZ proc near
.text$mn:000004A0
.text$mn:000004A0 var_8           = dword ptr -8
.text$mn:000004A0 var_4           = dword ptr -4
.text$mn:000004A0
.text$mn:000004A0                 push    ebp
.text$mn:000004A1                 mov     ebp, esp
.text$mn:000004A3                 sub     esp, 8
.text$mn:000004A6                 mov     [ebp+var_8], ecx
.text$mn:000004A9                 mov     ecx, [ebp+var_8] ; this
.text$mn:000004AC                 call    ?getRoot@TreeView@@QBEPAU_TREEITEM@@XZ ; TreeView::getRoot(void)
.text$mn:000004B1                 mov     [ebp+var_4], eax
.text$mn:000004B4                 jmp     short loc_4C5
.text$mn:000004B6 ; ---------------------------------------------------------------------------
.text$mn:000004B6
.text$mn:000004B6 loc_4B6:                                ; CODE XREF: TreeView::removeAllItems(void)+37j
.text$mn:000004B6                 mov     eax, [ebp+var_4]
.text$mn:000004B9                 push    eax             ; struct _TREEITEM *
.text$mn:000004BA                 mov     ecx, [ebp+var_8] ; this
.text$mn:000004BD                 call    ?getNextSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getNextSibling(_TREEITEM *)
.text$mn:000004C2                 mov     [ebp+var_4], eax
.text$mn:000004C5
.text$mn:000004C5 loc_4C5:                                ; CODE XREF: TreeView::removeAllItems(void)+14j
.text$mn:000004C5                 cmp     [ebp+var_4], 0
.text$mn:000004C9                 jz      short loc_4D9
.text$mn:000004CB                 mov     ecx, [ebp+var_4]
.text$mn:000004CE                 push    ecx             ; struct _TREEITEM *
.text$mn:000004CF                 mov     ecx, [ebp+var_8] ; this
.text$mn:000004D2                 call    ?cleanSubEntries@TreeView@@IAEXPAU_TREEITEM@@@Z ; TreeView::cleanSubEntries(_TREEITEM *)
.text$mn:000004D7                 jmp     short loc_4B6
.text$mn:000004D9 ; ---------------------------------------------------------------------------
.text$mn:000004D9
.text$mn:000004D9 loc_4D9:                                ; CODE XREF: TreeView::removeAllItems(void)+29j
.text$mn:000004D9                 push    0FFFF0000h      ; lParam
.text$mn:000004DE                 push    0               ; wParam
.text$mn:000004E0                 push    1101h           ; Msg
.text$mn:000004E5                 mov     edx, [ebp+var_8]
.text$mn:000004E8                 mov     eax, [edx+0Ch]
.text$mn:000004EB                 push    eax             ; hWnd
.text$mn:000004EC                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000004F2                 mov     esp, ebp
.text$mn:000004F4                 pop     ebp
.text$mn:000004F5                 retn
.text$mn:000004F5 ?removeAllItems@TreeView@@QAEXXZ endp
.text$mn:000004F5
.text$mn:000004F5 ; ---------------------------------------------------------------------------
.text$mn:000004F6                 align 10h
.text$mn:00000500
.text$mn:00000500 ; =============== S U B R O U T I N E =======================================
.text$mn:00000500
.text$mn:00000500 ; Attributes: bp-based frame
.text$mn:00000500
.text$mn:00000500 ; void __thiscall TreeView::setItemImage(TreeView *this, struct _TREEITEM *, int, int)
.text$mn:00000500                 public ?setItemImage@TreeView@@QAEXPAU_TREEITEM@@HH@Z
.text$mn:00000500 ?setItemImage@TreeView@@QAEXPAU_TREEITEM@@HH@Z proc near
.text$mn:00000500
.text$mn:00000500 lParam          = dword ptr -2Ch
.text$mn:00000500 var_28          = dword ptr -28h
.text$mn:00000500 var_14          = dword ptr -14h
.text$mn:00000500 var_10          = dword ptr -10h
.text$mn:00000500 var_4           = dword ptr -4
.text$mn:00000500 arg_0           = dword ptr  8
.text$mn:00000500 arg_4           = dword ptr  0Ch
.text$mn:00000500 arg_8           = dword ptr  10h
.text$mn:00000500
.text$mn:00000500                 push    ebp
.text$mn:00000501                 mov     ebp, esp
.text$mn:00000503                 sub     esp, 2Ch
.text$mn:00000506                 mov     [ebp+var_4], ecx
.text$mn:00000509                 mov     eax, [ebp+arg_0]
.text$mn:0000050C                 mov     [ebp+var_28], eax
.text$mn:0000050F                 mov     [ebp+lParam], 22h ; '"'
.text$mn:00000516                 mov     ecx, [ebp+arg_4]
.text$mn:00000519                 mov     [ebp+var_14], ecx
.text$mn:0000051C                 mov     edx, [ebp+arg_8]
.text$mn:0000051F                 mov     [ebp+var_10], edx
.text$mn:00000522                 lea     eax, [ebp+lParam]
.text$mn:00000525                 push    eax             ; lParam
.text$mn:00000526                 push    0               ; wParam
.text$mn:00000528                 push    113Fh           ; Msg
.text$mn:0000052D                 mov     ecx, [ebp+var_4]
.text$mn:00000530                 mov     edx, [ecx+0Ch]
.text$mn:00000533                 push    edx             ; hWnd
.text$mn:00000534                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000053A                 mov     esp, ebp
.text$mn:0000053C                 pop     ebp
.text$mn:0000053D                 retn    0Ch
.text$mn:0000053D ?setItemImage@TreeView@@QAEXPAU_TREEITEM@@HH@Z endp
.text$mn:0000053D
.text$mn:00000540
.text$mn:00000540 ; =============== S U B R O U T I N E =======================================
.text$mn:00000540
.text$mn:00000540 ; Attributes: bp-based frame
.text$mn:00000540
.text$mn:00000540 ; void __thiscall TreeView::beginDrag(TreeView *this, struct tagNMTREEVIEWW *)
.text$mn:00000540                 public ?beginDrag@TreeView@@QAEXPAUtagNMTREEVIEWW@@@Z
.text$mn:00000540 ?beginDrag@TreeView@@QAEXPAUtagNMTREEVIEWW@@@Z proc near
.text$mn:00000540
.text$mn:00000540 var_4           = dword ptr -4
.text$mn:00000540 arg_0           = dword ptr  8
.text$mn:00000540
.text$mn:00000540                 push    ebp
.text$mn:00000541                 mov     ebp, esp
.text$mn:00000543                 push    ecx
.text$mn:00000544                 mov     [ebp+var_4], ecx
.text$mn:00000547                 mov     eax, [ebp+arg_0]
.text$mn:0000054A                 mov     ecx, [eax+3Ch]
.text$mn:0000054D                 push    ecx             ; struct _TREEITEM *
.text$mn:0000054E                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000551                 call    ?canDragOut@TreeView@@IAE_NPAU_TREEITEM@@@Z ; TreeView::canDragOut(_TREEITEM *)
.text$mn:00000556                 movzx   edx, al
.text$mn:00000559                 test    edx, edx
.text$mn:0000055B                 jnz     short loc_55F
.text$mn:0000055D                 jmp     short loc_5DD
.text$mn:0000055F ; ---------------------------------------------------------------------------
.text$mn:0000055F
.text$mn:0000055F loc_55F:                                ; CODE XREF: TreeView::beginDrag(tagNMTREEVIEWW *)+1Bj
.text$mn:0000055F                 mov     eax, [ebp+var_4]
.text$mn:00000562                 mov     ecx, [ebp+arg_0]
.text$mn:00000565                 mov     edx, [ecx+3Ch]
.text$mn:00000568                 mov     [eax+14h], edx
.text$mn:0000056B                 mov     eax, [ebp+var_4]
.text$mn:0000056E                 mov     ecx, [eax+14h]
.text$mn:00000571                 push    ecx             ; lParam
.text$mn:00000572                 push    0               ; wParam
.text$mn:00000574                 push    1112h           ; Msg
.text$mn:00000579                 mov     edx, [ebp+var_4]
.text$mn:0000057C                 mov     eax, [edx+0Ch]
.text$mn:0000057F                 push    eax             ; hWnd
.text$mn:00000580                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000586                 mov     ecx, [ebp+var_4]
.text$mn:00000589                 mov     [ecx+18h], eax
.text$mn:0000058C                 push    0               ; dyHotspot
.text$mn:0000058E                 push    0               ; dxHotspot
.text$mn:00000590                 push    0               ; iTrack
.text$mn:00000592                 mov     edx, [ebp+var_4]
.text$mn:00000595                 mov     eax, [edx+18h]
.text$mn:00000598                 push    eax             ; himlTrack
.text$mn:00000599                 call    dword ptr ds:__imp__ImageList_BeginDrag@16 ; ImageList_BeginDrag(x,x,x,x)
.text$mn:0000059F                 mov     ecx, [ebp+arg_0]
.text$mn:000005A2                 mov     edx, [ecx+64h]
.text$mn:000005A5                 push    edx             ; y
.text$mn:000005A6                 mov     eax, [ebp+arg_0]
.text$mn:000005A9                 mov     ecx, [eax+60h]
.text$mn:000005AC                 push    ecx             ; x
.text$mn:000005AD                 mov     edx, [ebp+var_4]
.text$mn:000005B0                 mov     eax, [edx+0Ch]
.text$mn:000005B3                 push    eax             ; hwndLock
.text$mn:000005B4                 call    dword ptr ds:__imp__ImageList_DragEnter@12 ; ImageList_DragEnter(x,x,x)
.text$mn:000005BA                 mov     ecx, [ebp+var_4]
.text$mn:000005BD                 mov     edx, [ecx+0Ch]
.text$mn:000005C0                 push    edx             ; hWnd
.text$mn:000005C1                 call    dword ptr ds:__imp__GetParent@4 ; GetParent(x)
.text$mn:000005C7                 push    eax             ; hWnd
.text$mn:000005C8                 call    dword ptr ds:__imp__SetCapture@4 ; SetCapture(x)
.text$mn:000005CE                 push    0               ; bShow
.text$mn:000005D0                 call    dword ptr ds:__imp__ShowCursor@4 ; ShowCursor(x)
.text$mn:000005D6                 mov     eax, [ebp+var_4]
.text$mn:000005D9                 mov     byte ptr [eax+1Ch], 1
.text$mn:000005DD
.text$mn:000005DD loc_5DD:                                ; CODE XREF: TreeView::beginDrag(tagNMTREEVIEWW *)+1Dj
.text$mn:000005DD                 mov     esp, ebp
.text$mn:000005DF                 pop     ebp
.text$mn:000005E0                 retn    4
.text$mn:000005E0 ?beginDrag@TreeView@@QAEXPAUtagNMTREEVIEWW@@@Z endp
.text$mn:000005E0
.text$mn:000005E0 ; ---------------------------------------------------------------------------
.text$mn:000005E3                 align 10h
.text$mn:000005F0
.text$mn:000005F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000005F0
.text$mn:000005F0 ; Attributes: bp-based frame
.text$mn:000005F0
.text$mn:000005F0 ; void __thiscall TreeView::dragItem(TreeView *this, HWND hWnd, __int16, int)
.text$mn:000005F0                 public ?dragItem@TreeView@@QAEXPAUHWND__@@HH@Z
.text$mn:000005F0 ?dragItem@TreeView@@QAEXPAUHWND__@@HH@Z proc near
.text$mn:000005F0
.text$mn:000005F0 lParam          = dword ptr -20h
.text$mn:000005F0 var_1C          = dword ptr -1Ch
.text$mn:000005F0 Point           = tagPOINT ptr -10h
.text$mn:000005F0 var_8           = dword ptr -8
.text$mn:000005F0 var_4           = dword ptr -4
.text$mn:000005F0 hWnd            = dword ptr  8
.text$mn:000005F0 arg_4           = word ptr  0Ch
.text$mn:000005F0 arg_8           = dword ptr  10h
.text$mn:000005F0
.text$mn:000005F0                 push    ebp
.text$mn:000005F1                 mov     ebp, esp
.text$mn:000005F3                 sub     esp, 20h
.text$mn:000005F6                 mov     [ebp+var_4], ecx
.text$mn:000005F9                 movsx   eax, [ebp+arg_4]
.text$mn:000005FD                 mov     [ebp+Point.x], eax
.text$mn:00000600                 movsx   ecx, word ptr [ebp+arg_8]
.text$mn:00000604                 mov     [ebp+Point.y], ecx
.text$mn:00000607                 lea     edx, [ebp+Point]
.text$mn:0000060A                 push    edx             ; lpPoint
.text$mn:0000060B                 mov     eax, [ebp+hWnd]
.text$mn:0000060E                 push    eax             ; hWnd
.text$mn:0000060F                 call    dword ptr ds:__imp__ClientToScreen@8 ; ClientToScreen(x,x)
.text$mn:00000615                 lea     ecx, [ebp+Point]
.text$mn:00000618                 push    ecx             ; lpPoint
.text$mn:00000619                 mov     edx, [ebp+var_4]
.text$mn:0000061C                 mov     eax, [edx+0Ch]
.text$mn:0000061F                 push    eax             ; hWnd
.text$mn:00000620                 call    dword ptr ds:__imp__ScreenToClient@8 ; ScreenToClient(x,x)
.text$mn:00000626                 mov     ecx, [ebp+Point.y]
.text$mn:00000629                 push    ecx             ; y
.text$mn:0000062A                 mov     edx, [ebp+Point.x]
.text$mn:0000062D                 push    edx             ; x
.text$mn:0000062E                 call    dword ptr ds:__imp__ImageList_DragMove@8 ; ImageList_DragMove(x,x)
.text$mn:00000634                 push    0               ; fShow
.text$mn:00000636                 call    dword ptr ds:__imp__ImageList_DragShowNolock@4 ; ImageList_DragShowNolock(x)
.text$mn:0000063C                 mov     eax, [ebp+Point.x]
.text$mn:0000063F                 mov     [ebp+lParam], eax
.text$mn:00000642                 mov     ecx, [ebp+Point.y]
.text$mn:00000645                 mov     [ebp+var_1C], ecx
.text$mn:00000648                 lea     edx, [ebp+lParam]
.text$mn:0000064B                 push    edx             ; lParam
.text$mn:0000064C                 push    0               ; wParam
.text$mn:0000064E                 push    1111h           ; Msg
.text$mn:00000653                 mov     eax, [ebp+var_4]
.text$mn:00000656                 mov     ecx, [eax+0Ch]
.text$mn:00000659                 push    ecx             ; hWnd
.text$mn:0000065A                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000660                 mov     [ebp+var_8], eax
.text$mn:00000663                 cmp     [ebp+var_8], 0
.text$mn:00000667                 jz      short loc_681
.text$mn:00000669                 mov     edx, [ebp+var_8]
.text$mn:0000066C                 push    edx             ; lParam
.text$mn:0000066D                 push    8               ; wParam
.text$mn:0000066F                 push    110Bh           ; Msg
.text$mn:00000674                 mov     eax, [ebp+var_4]
.text$mn:00000677                 mov     ecx, [eax+0Ch]
.text$mn:0000067A                 push    ecx             ; hWnd
.text$mn:0000067B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000681
.text$mn:00000681 loc_681:                                ; CODE XREF: TreeView::dragItem(HWND__ *,int,int)+77j
.text$mn:00000681                 push    1               ; fShow
.text$mn:00000683                 call    dword ptr ds:__imp__ImageList_DragShowNolock@4 ; ImageList_DragShowNolock(x)
.text$mn:00000689                 mov     esp, ebp
.text$mn:0000068B                 pop     ebp
.text$mn:0000068C                 retn    0Ch
.text$mn:0000068C ?dragItem@TreeView@@QAEXPAUHWND__@@HH@Z endp
.text$mn:0000068C
.text$mn:0000068C ; ---------------------------------------------------------------------------
.text$mn:0000068F                 align 10h
.text$mn:00000690
.text$mn:00000690 ; =============== S U B R O U T I N E =======================================
.text$mn:00000690
.text$mn:00000690 ; Attributes: bp-based frame
.text$mn:00000690
.text$mn:00000690 ; bool __thiscall TreeView::dropItem(TreeView *__hidden this)
.text$mn:00000690                 public ?dropItem@TreeView@@QAE_NXZ
.text$mn:00000690 ?dropItem@TreeView@@QAE_NXZ proc near
.text$mn:00000690
.text$mn:00000690 lParam          = dword ptr -0Ch
.text$mn:00000690 var_8           = dword ptr -8
.text$mn:00000690 var_1           = byte ptr -1
.text$mn:00000690
.text$mn:00000690                 push    ebp
.text$mn:00000691                 mov     ebp, esp
.text$mn:00000693                 sub     esp, 0Ch
.text$mn:00000696                 mov     [ebp+var_8], ecx
.text$mn:00000699                 mov     [ebp+var_1], 0
.text$mn:0000069D                 push    0               ; lParam
.text$mn:0000069F                 push    8               ; wParam
.text$mn:000006A1                 push    110Ah           ; Msg
.text$mn:000006A6                 mov     eax, [ebp+var_8]
.text$mn:000006A9                 mov     ecx, [eax+0Ch]
.text$mn:000006AC                 push    ecx             ; hWnd
.text$mn:000006AD                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000006B3                 mov     [ebp+lParam], eax
.text$mn:000006B6                 mov     edx, [ebp+lParam]
.text$mn:000006B9                 push    edx             ; struct _TREEITEM *
.text$mn:000006BA                 mov     eax, [ebp+var_8]
.text$mn:000006BD                 mov     ecx, [eax+14h]
.text$mn:000006C0                 push    ecx             ; struct _TREEITEM *
.text$mn:000006C1                 mov     ecx, [ebp+var_8] ; this
.text$mn:000006C4                 call    ?canBeDropped@TreeView@@IAE_NPAU_TREEITEM@@0@Z ; TreeView::canBeDropped(_TREEITEM *,_TREEITEM *)
.text$mn:000006C9                 movzx   edx, al
.text$mn:000006CC                 test    edx, edx
.text$mn:000006CE                 jz      short loc_6E7
.text$mn:000006D0                 mov     eax, [ebp+lParam]
.text$mn:000006D3                 push    eax             ; struct _TREEITEM *
.text$mn:000006D4                 mov     ecx, [ebp+var_8]
.text$mn:000006D7                 mov     edx, [ecx+14h]
.text$mn:000006DA                 push    edx             ; struct _TREEITEM *
.text$mn:000006DB                 mov     ecx, [ebp+var_8] ; this
.text$mn:000006DE                 call    ?moveTreeViewItem@TreeView@@IAEXPAU_TREEITEM@@0@Z ; TreeView::moveTreeViewItem(_TREEITEM *,_TREEITEM *)
.text$mn:000006E3                 mov     [ebp+var_1], 1
.text$mn:000006E7
.text$mn:000006E7 loc_6E7:                                ; CODE XREF: TreeView::dropItem(void)+3Ej
.text$mn:000006E7                 call    dword ptr ds:__imp__ImageList_EndDrag@0 ; ImageList_EndDrag()
.text$mn:000006ED                 mov     eax, [ebp+var_8]
.text$mn:000006F0                 mov     ecx, [eax+18h]
.text$mn:000006F3                 push    ecx             ; himl
.text$mn:000006F4                 call    dword ptr ds:__imp__ImageList_Destroy@4 ; ImageList_Destroy(x)
.text$mn:000006FA                 call    dword ptr ds:__imp__ReleaseCapture@0 ; ReleaseCapture()
.text$mn:00000700                 push    1               ; bShow
.text$mn:00000702                 call    dword ptr ds:__imp__ShowCursor@4 ; ShowCursor(x)
.text$mn:00000708                 mov     edx, [ebp+lParam]
.text$mn:0000070B                 push    edx             ; lParam
.text$mn:0000070C                 push    9               ; wParam
.text$mn:0000070E                 push    110Bh           ; Msg
.text$mn:00000713                 mov     eax, [ebp+var_8]
.text$mn:00000716                 mov     ecx, [eax+0Ch]
.text$mn:00000719                 push    ecx             ; hWnd
.text$mn:0000071A                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000720                 push    0               ; lParam
.text$mn:00000722                 push    8               ; wParam
.text$mn:00000724                 push    110Bh           ; Msg
.text$mn:00000729                 mov     edx, [ebp+var_8]
.text$mn:0000072C                 mov     eax, [edx+0Ch]
.text$mn:0000072F                 push    eax             ; hWnd
.text$mn:00000730                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000736                 mov     ecx, [ebp+var_8]
.text$mn:00000739                 mov     dword ptr [ecx+14h], 0
.text$mn:00000740                 mov     edx, [ebp+var_8]
.text$mn:00000743                 mov     dword ptr [edx+18h], 0
.text$mn:0000074A                 mov     eax, [ebp+var_8]
.text$mn:0000074D                 mov     byte ptr [eax+1Ch], 0
.text$mn:00000751                 mov     al, [ebp+var_1]
.text$mn:00000754                 mov     esp, ebp
.text$mn:00000756                 pop     ebp
.text$mn:00000757                 retn
.text$mn:00000757 ?dropItem@TreeView@@QAE_NXZ endp
.text$mn:00000757
.text$mn:00000757 ; ---------------------------------------------------------------------------
.text$mn:00000758                 align 10h
.text$mn:00000760
.text$mn:00000760 ; =============== S U B R O U T I N E =======================================
.text$mn:00000760
.text$mn:00000760 ; Attributes: bp-based frame
.text$mn:00000760
.text$mn:00000760 ; bool __thiscall TreeView::moveDown(TreeView *this, struct _TREEITEM *)
.text$mn:00000760                 public ?moveDown@TreeView@@QAE_NPAU_TREEITEM@@@Z
.text$mn:00000760 ?moveDown@TreeView@@QAE_NPAU_TREEITEM@@@Z proc near
.text$mn:00000760
.text$mn:00000760 var_8           = dword ptr -8
.text$mn:00000760 var_4           = dword ptr -4
.text$mn:00000760 arg_0           = dword ptr  8
.text$mn:00000760
.text$mn:00000760                 push    ebp
.text$mn:00000761                 mov     ebp, esp
.text$mn:00000763                 sub     esp, 8
.text$mn:00000766                 mov     [ebp+var_8], ecx
.text$mn:00000769                 mov     eax, [ebp+arg_0]
.text$mn:0000076C                 push    eax             ; struct _TREEITEM *
.text$mn:0000076D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000770                 call    ?getNextSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getNextSibling(_TREEITEM *)
.text$mn:00000775                 mov     [ebp+var_4], eax
.text$mn:00000778                 cmp     [ebp+var_4], 0
.text$mn:0000077C                 jnz     short loc_782
.text$mn:0000077E                 xor     al, al
.text$mn:00000780                 jmp     short loc_792
.text$mn:00000782 ; ---------------------------------------------------------------------------
.text$mn:00000782
.text$mn:00000782 loc_782:                                ; CODE XREF: TreeView::moveDown(_TREEITEM *)+1Cj
.text$mn:00000782                 mov     ecx, [ebp+var_4]
.text$mn:00000785                 push    ecx             ; struct _TREEITEM *
.text$mn:00000786                 mov     edx, [ebp+arg_0]
.text$mn:00000789                 push    edx             ; struct _TREEITEM *
.text$mn:0000078A                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000078D                 call    ?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z ; TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)
.text$mn:00000792
.text$mn:00000792 loc_792:                                ; CODE XREF: TreeView::moveDown(_TREEITEM *)+20j
.text$mn:00000792                 mov     esp, ebp
.text$mn:00000794                 pop     ebp
.text$mn:00000795                 retn    4
.text$mn:00000795 ?moveDown@TreeView@@QAE_NPAU_TREEITEM@@@Z endp
.text$mn:00000795
.text$mn:00000795 ; ---------------------------------------------------------------------------
.text$mn:00000798                 align 10h
.text$mn:000007A0
.text$mn:000007A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000007A0
.text$mn:000007A0 ; Attributes: bp-based frame
.text$mn:000007A0
.text$mn:000007A0 ; bool __thiscall TreeView::moveUp(TreeView *this, struct _TREEITEM *)
.text$mn:000007A0                 public ?moveUp@TreeView@@QAE_NPAU_TREEITEM@@@Z
.text$mn:000007A0 ?moveUp@TreeView@@QAE_NPAU_TREEITEM@@@Z proc near
.text$mn:000007A0
.text$mn:000007A0 var_8           = dword ptr -8
.text$mn:000007A0 var_4           = dword ptr -4
.text$mn:000007A0 arg_0           = dword ptr  8
.text$mn:000007A0
.text$mn:000007A0                 push    ebp
.text$mn:000007A1                 mov     ebp, esp
.text$mn:000007A3                 sub     esp, 8
.text$mn:000007A6                 mov     [ebp+var_8], ecx
.text$mn:000007A9                 mov     eax, [ebp+arg_0]
.text$mn:000007AC                 push    eax             ; struct _TREEITEM *
.text$mn:000007AD                 mov     ecx, [ebp+var_8] ; this
.text$mn:000007B0                 call    ?getPrevSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getPrevSibling(_TREEITEM *)
.text$mn:000007B5                 mov     [ebp+var_4], eax
.text$mn:000007B8                 cmp     [ebp+var_4], 0
.text$mn:000007BC                 jnz     short loc_7C2
.text$mn:000007BE                 xor     al, al
.text$mn:000007C0                 jmp     short loc_7D2
.text$mn:000007C2 ; ---------------------------------------------------------------------------
.text$mn:000007C2
.text$mn:000007C2 loc_7C2:                                ; CODE XREF: TreeView::moveUp(_TREEITEM *)+1Cj
.text$mn:000007C2                 mov     ecx, [ebp+arg_0]
.text$mn:000007C5                 push    ecx             ; struct _TREEITEM *
.text$mn:000007C6                 mov     edx, [ebp+var_4]
.text$mn:000007C9                 push    edx             ; struct _TREEITEM *
.text$mn:000007CA                 mov     ecx, [ebp+var_8] ; this
.text$mn:000007CD                 call    ?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z ; TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)
.text$mn:000007D2
.text$mn:000007D2 loc_7D2:                                ; CODE XREF: TreeView::moveUp(_TREEITEM *)+20j
.text$mn:000007D2                 mov     esp, ebp
.text$mn:000007D4                 pop     ebp
.text$mn:000007D5                 retn    4
.text$mn:000007D5 ?moveUp@TreeView@@QAE_NPAU_TREEITEM@@@Z endp
.text$mn:000007D5
.text$mn:000007D5 ; ---------------------------------------------------------------------------
.text$mn:000007D8                 align 10h
.text$mn:000007E0
.text$mn:000007E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000007E0
.text$mn:000007E0 ; Attributes: bp-based frame
.text$mn:000007E0
.text$mn:000007E0 ; bool __thiscall TreeView::swapTreeViewItem(TreeView *this, struct _TREEITEM *, struct _TREEITEM *)
.text$mn:000007E0                 public ?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z
.text$mn:000007E0 ?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z proc near
.text$mn:000007E0                                         ; CODE XREF: TreeView::moveDown(_TREEITEM *)+2Dp
.text$mn:000007E0                                         ; TreeView::moveUp(_TREEITEM *)+2Dp
.text$mn:000007E0
.text$mn:000007E0 var_534         = dword ptr -534h
.text$mn:000007E0 var_530         = dword ptr -530h
.text$mn:000007E0 var_52C         = byte ptr -52Ch
.text$mn:000007E0 var_4F4         = dword ptr -4F4h
.text$mn:000007E0 var_4F0         = dword ptr -4F0h
.text$mn:000007E0 var_4EC         = byte ptr -4ECh
.text$mn:000007E0 lParam          = dword ptr -4B4h
.text$mn:000007E0 var_4B0         = dword ptr -4B0h
.text$mn:000007E0 var_4A4         = dword ptr -4A4h
.text$mn:000007E0 var_4A0         = dword ptr -4A0h
.text$mn:000007E0 var_490         = dword ptr -490h
.text$mn:000007E0 var_48C         = dword ptr -48Ch
.text$mn:000007E0 var_488         = dword ptr -488h
.text$mn:000007E0 var_47C         = dword ptr -47Ch
.text$mn:000007E0 var_478         = dword ptr -478h
.text$mn:000007E0 var_468         = dword ptr -468h
.text$mn:000007E0 var_464         = dword ptr -464h
.text$mn:000007E0 var_460         = dword ptr -460h
.text$mn:000007E0 var_45C         = dword ptr -45Ch
.text$mn:000007E0 var_458         = dword ptr -458h
.text$mn:000007E0 var_454         = dword ptr -454h
.text$mn:000007E0 var_450         = dword ptr -450h
.text$mn:000007E0 var_44C         = dword ptr -44Ch
.text$mn:000007E0 var_448         = dword ptr -448h
.text$mn:000007E0 var_444         = dword ptr -444h
.text$mn:000007E0 var_440         = dword ptr -440h
.text$mn:000007E0 var_43C         = dword ptr -43Ch
.text$mn:000007E0 var_438         = dword ptr -438h
.text$mn:000007E0 var_434         = dword ptr -434h
.text$mn:000007E0 var_430         = dword ptr -430h
.text$mn:000007E0 var_42C         = dword ptr -42Ch
.text$mn:000007E0 var_428         = dword ptr -428h
.text$mn:000007E0 var_424         = dword ptr -424h
.text$mn:000007E0 var_420         = byte ptr -420h
.text$mn:000007E0 var_218         = byte ptr -218h
.text$mn:000007E0 var_10          = dword ptr -10h
.text$mn:000007E0 var_C           = dword ptr -0Ch
.text$mn:000007E0 var_4           = dword ptr -4
.text$mn:000007E0 arg_0           = dword ptr  8
.text$mn:000007E0 arg_4           = dword ptr  0Ch
.text$mn:000007E0
.text$mn:000007E0                 push    ebp
.text$mn:000007E1                 mov     ebp, esp
.text$mn:000007E3                 push    0FFFFFFFFh
.text$mn:000007E5                 push    offset __ehhandler$?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z
.text$mn:000007EA                 mov     eax, large fs:0
.text$mn:000007F0                 push    eax
.text$mn:000007F1                 sub     esp, 528h
.text$mn:000007F7                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000007FC                 xor     eax, ebp
.text$mn:000007FE                 mov     [ebp+var_10], eax
.text$mn:00000801                 push    esi
.text$mn:00000802                 push    edi
.text$mn:00000803                 push    eax
.text$mn:00000804                 lea     eax, [ebp+var_C]
.text$mn:00000807                 mov     large fs:0, eax
.text$mn:0000080D                 mov     [ebp+var_424], ecx
.text$mn:00000813                 mov     ecx, [ebp+var_424] ; this
.text$mn:00000819                 call    ?getSelection@TreeView@@QBEPAU_TREEITEM@@XZ ; TreeView::getSelection(void)
.text$mn:0000081E                 mov     [ebp+var_458], eax
.text$mn:00000824                 mov     eax, [ebp+var_458]
.text$mn:0000082A                 cmp     eax, [ebp+arg_0]
.text$mn:0000082D                 jnz     short loc_83B
.text$mn:0000082F                 mov     [ebp+var_440], 1
.text$mn:00000839                 jmp     short loc_868
.text$mn:0000083B ; ---------------------------------------------------------------------------
.text$mn:0000083B
.text$mn:0000083B loc_83B:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+4Dj
.text$mn:0000083B                 mov     ecx, [ebp+var_458]
.text$mn:00000841                 cmp     ecx, [ebp+arg_4]
.text$mn:00000844                 jnz     short loc_852
.text$mn:00000846                 mov     [ebp+var_45C], 2
.text$mn:00000850                 jmp     short loc_85C
.text$mn:00000852 ; ---------------------------------------------------------------------------
.text$mn:00000852
.text$mn:00000852 loc_852:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+64j
.text$mn:00000852                 mov     [ebp+var_45C], 0
.text$mn:0000085C
.text$mn:0000085C loc_85C:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+70j
.text$mn:0000085C                 mov     edx, [ebp+var_45C]
.text$mn:00000862                 mov     [ebp+var_440], edx
.text$mn:00000868
.text$mn:00000868 loc_868:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+59j
.text$mn:00000868                 mov     eax, [ebp+var_440]
.text$mn:0000086E                 mov     [ebp+var_42C], eax
.text$mn:00000874                 mov     ecx, [ebp+arg_0]
.text$mn:00000877                 push    ecx             ; struct _TREEITEM *
.text$mn:00000878                 mov     ecx, [ebp+var_424] ; this
.text$mn:0000087E                 call    ?getPrevSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getPrevSibling(_TREEITEM *)
.text$mn:00000883                 mov     [ebp+var_428], eax
.text$mn:00000889                 cmp     [ebp+var_428], 0
.text$mn:00000890                 jz      short loc_8A0
.text$mn:00000892                 mov     edx, [ebp+var_428]
.text$mn:00000898                 mov     [ebp+var_44C], edx
.text$mn:0000089E                 jmp     short loc_8AA
.text$mn:000008A0 ; ---------------------------------------------------------------------------
.text$mn:000008A0
.text$mn:000008A0 loc_8A0:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+B0j
.text$mn:000008A0                 mov     [ebp+var_44C], 0FFFF0001h
.text$mn:000008AA
.text$mn:000008AA loc_8AA:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+BEj
.text$mn:000008AA                 mov     eax, [ebp+var_44C]
.text$mn:000008B0                 mov     [ebp+var_428], eax
.text$mn:000008B6                 mov     ecx, [ebp+arg_0]
.text$mn:000008B9                 push    ecx             ; struct _TREEITEM *
.text$mn:000008BA                 mov     ecx, [ebp+var_424] ; this
.text$mn:000008C0                 call    ?getParent@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getParent(_TREEITEM *)
.text$mn:000008C5                 mov     [ebp+var_444], eax
.text$mn:000008CB                 mov     edx, [ebp+arg_4]
.text$mn:000008CE                 push    edx             ; struct _TREEITEM *
.text$mn:000008CF                 mov     ecx, [ebp+var_424] ; this
.text$mn:000008D5                 call    ?getParent@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getParent(_TREEITEM *)
.text$mn:000008DA                 mov     [ebp+var_43C], eax
.text$mn:000008E0                 mov     eax, [ebp+var_43C]
.text$mn:000008E6                 cmp     eax, [ebp+var_444]
.text$mn:000008EC                 jz      short loc_8F5
.text$mn:000008EE                 xor     al, al
.text$mn:000008F0                 jmp     loc_B86
.text$mn:000008F5 ; ---------------------------------------------------------------------------
.text$mn:000008F5
.text$mn:000008F5 loc_8F5:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+10Cj
.text$mn:000008F5                 mov     [ebp+lParam], 27h ; '''
.text$mn:000008FF                 mov     [ebp+var_48C], 27h ; '''
.text$mn:00000909                 lea     ecx, [ebp+var_218]
.text$mn:0000090F                 mov     [ebp+var_4A4], ecx
.text$mn:00000915                 lea     edx, [ebp+var_420]
.text$mn:0000091B                 mov     [ebp+var_47C], edx
.text$mn:00000921                 mov     [ebp+var_4A0], 104h
.text$mn:0000092B                 mov     [ebp+var_478], 104h
.text$mn:00000935                 mov     eax, [ebp+arg_4]
.text$mn:00000938                 mov     [ebp+var_4B0], eax
.text$mn:0000093E                 mov     ecx, [ebp+arg_0]
.text$mn:00000941                 mov     [ebp+var_488], ecx
.text$mn:00000947                 lea     edx, [ebp+lParam]
.text$mn:0000094D                 push    edx             ; lParam
.text$mn:0000094E                 push    0               ; wParam
.text$mn:00000950                 push    113Eh           ; Msg
.text$mn:00000955                 mov     eax, [ebp+var_424]
.text$mn:0000095B                 mov     ecx, [eax+0Ch]
.text$mn:0000095E                 push    ecx             ; hWnd
.text$mn:0000095F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000965                 lea     edx, [ebp+var_48C]
.text$mn:0000096B                 push    edx             ; lParam
.text$mn:0000096C                 push    0               ; wParam
.text$mn:0000096E                 push    113Eh           ; Msg
.text$mn:00000973                 mov     eax, [ebp+var_424]
.text$mn:00000979                 mov     ecx, [eax+0Ch]
.text$mn:0000097C                 push    ecx             ; hWnd
.text$mn:0000097D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000983                 cmp     [ebp+var_490], 0
.text$mn:0000098A                 jz      short loc_9EF
.text$mn:0000098C                 push    1Ch             ; unsigned int
.text$mn:0000098E                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000993                 add     esp, 4
.text$mn:00000996                 mov     [ebp+var_454], eax
.text$mn:0000099C                 mov     [ebp+var_4], 0
.text$mn:000009A3                 cmp     [ebp+var_454], 0
.text$mn:000009AA                 jz      short loc_9C6
.text$mn:000009AC                 mov     edx, [ebp+var_490]
.text$mn:000009B2                 push    edx
.text$mn:000009B3                 mov     ecx, [ebp+var_454]
.text$mn:000009B9                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000009BE                 mov     [ebp+var_450], eax
.text$mn:000009C4                 jmp     short loc_9D0
.text$mn:000009C6 ; ---------------------------------------------------------------------------
.text$mn:000009C6
.text$mn:000009C6 loc_9C6:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+1CAj
.text$mn:000009C6                 mov     [ebp+var_450], 0
.text$mn:000009D0
.text$mn:000009D0 loc_9D0:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+1E4j
.text$mn:000009D0                 mov     eax, [ebp+var_450]
.text$mn:000009D6                 mov     [ebp+var_460], eax
.text$mn:000009DC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000009E3                 mov     ecx, [ebp+var_460]
.text$mn:000009E9                 mov     [ebp+var_490], ecx
.text$mn:000009EF
.text$mn:000009EF loc_9EF:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+1AAj
.text$mn:000009EF                 cmp     [ebp+var_468], 0
.text$mn:000009F6                 jz      short loc_A5B
.text$mn:000009F8                 push    1Ch             ; unsigned int
.text$mn:000009FA                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000009FF                 add     esp, 4
.text$mn:00000A02                 mov     [ebp+var_448], eax
.text$mn:00000A08                 mov     [ebp+var_4], 1
.text$mn:00000A0F                 cmp     [ebp+var_448], 0
.text$mn:00000A16                 jz      short loc_A32
.text$mn:00000A18                 mov     edx, [ebp+var_468]
.text$mn:00000A1E                 push    edx
.text$mn:00000A1F                 mov     ecx, [ebp+var_448]
.text$mn:00000A25                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00000A2A                 mov     [ebp+var_434], eax
.text$mn:00000A30                 jmp     short loc_A3C
.text$mn:00000A32 ; ---------------------------------------------------------------------------
.text$mn:00000A32
.text$mn:00000A32 loc_A32:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+236j
.text$mn:00000A32                 mov     [ebp+var_434], 0
.text$mn:00000A3C
.text$mn:00000A3C loc_A3C:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+250j
.text$mn:00000A3C                 mov     eax, [ebp+var_434]
.text$mn:00000A42                 mov     [ebp+var_464], eax
.text$mn:00000A48                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A4F                 mov     ecx, [ebp+var_464]
.text$mn:00000A55                 mov     [ebp+var_468], ecx
.text$mn:00000A5B
.text$mn:00000A5B loc_A5B:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+216j
.text$mn:00000A5B                 mov     ecx, 0Ah
.text$mn:00000A60                 lea     esi, [ebp+lParam]
.text$mn:00000A66                 lea     edi, [ebp+var_52C]
.text$mn:00000A6C                 rep movsd
.text$mn:00000A6E                 mov     edx, [ebp+var_428]
.text$mn:00000A74                 mov     [ebp+var_530], edx
.text$mn:00000A7A                 mov     eax, [ebp+var_43C]
.text$mn:00000A80                 mov     [ebp+var_534], eax
.text$mn:00000A86                 lea     ecx, [ebp+var_534]
.text$mn:00000A8C                 push    ecx             ; lParam
.text$mn:00000A8D                 push    0               ; wParam
.text$mn:00000A8F                 push    1132h           ; Msg
.text$mn:00000A94                 mov     edx, [ebp+var_424]
.text$mn:00000A9A                 mov     eax, [edx+0Ch]
.text$mn:00000A9D                 push    eax             ; hWnd
.text$mn:00000A9E                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000AA4                 mov     [ebp+var_430], eax
.text$mn:00000AAA                 mov     ecx, [ebp+var_430]
.text$mn:00000AB0                 push    ecx             ; struct _TREEITEM *
.text$mn:00000AB1                 mov     edx, [ebp+arg_4]
.text$mn:00000AB4                 push    edx             ; struct _TREEITEM *
.text$mn:00000AB5                 mov     ecx, [ebp+var_424] ; this
.text$mn:00000ABB                 call    ?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z ; TreeView::dupTree(_TREEITEM *,_TREEITEM *)
.text$mn:00000AC0                 mov     ecx, 0Ah
.text$mn:00000AC5                 lea     esi, [ebp+var_48C]
.text$mn:00000ACB                 lea     edi, [ebp+var_4EC]
.text$mn:00000AD1                 rep movsd
.text$mn:00000AD3                 mov     eax, [ebp+var_430]
.text$mn:00000AD9                 mov     [ebp+var_4F0], eax
.text$mn:00000ADF                 mov     ecx, [ebp+var_444]
.text$mn:00000AE5                 mov     [ebp+var_4F4], ecx
.text$mn:00000AEB                 lea     edx, [ebp+var_4F4]
.text$mn:00000AF1                 push    edx             ; lParam
.text$mn:00000AF2                 push    0               ; wParam
.text$mn:00000AF4                 push    1132h           ; Msg
.text$mn:00000AF9                 mov     eax, [ebp+var_424]
.text$mn:00000AFF                 mov     ecx, [eax+0Ch]
.text$mn:00000B02                 push    ecx             ; hWnd
.text$mn:00000B03                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000B09                 mov     [ebp+var_438], eax
.text$mn:00000B0F                 mov     edx, [ebp+var_438]
.text$mn:00000B15                 push    edx             ; struct _TREEITEM *
.text$mn:00000B16                 mov     eax, [ebp+arg_0]
.text$mn:00000B19                 push    eax             ; struct _TREEITEM *
.text$mn:00000B1A                 mov     ecx, [ebp+var_424] ; this
.text$mn:00000B20                 call    ?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z ; TreeView::dupTree(_TREEITEM *,_TREEITEM *)
.text$mn:00000B25                 mov     ecx, [ebp+arg_4]
.text$mn:00000B28                 push    ecx             ; struct _TREEITEM *
.text$mn:00000B29                 mov     ecx, [ebp+var_424] ; this
.text$mn:00000B2F                 call    ?removeItem@TreeView@@QAEXPAU_TREEITEM@@@Z ; TreeView::removeItem(_TREEITEM *)
.text$mn:00000B34                 mov     edx, [ebp+arg_0]
.text$mn:00000B37                 push    edx             ; struct _TREEITEM *
.text$mn:00000B38                 mov     ecx, [ebp+var_424] ; this
.text$mn:00000B3E                 call    ?removeItem@TreeView@@QAEXPAU_TREEITEM@@@Z ; TreeView::removeItem(_TREEITEM *)
.text$mn:00000B43                 cmp     [ebp+var_42C], 0
.text$mn:00000B4A                 jz      short loc_B84
.text$mn:00000B4C                 cmp     [ebp+var_42C], 1
.text$mn:00000B53                 jnz     short loc_B69
.text$mn:00000B55                 mov     eax, [ebp+var_438]
.text$mn:00000B5B                 push    eax             ; struct _TREEITEM *
.text$mn:00000B5C                 mov     ecx, [ebp+var_424] ; this
.text$mn:00000B62                 call    ?selectItem@TreeView@@QBE_NPAU_TREEITEM@@@Z ; TreeView::selectItem(_TREEITEM *)
.text$mn:00000B67                 jmp     short loc_B84
.text$mn:00000B69 ; ---------------------------------------------------------------------------
.text$mn:00000B69
.text$mn:00000B69 loc_B69:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+373j
.text$mn:00000B69                 cmp     [ebp+var_42C], 2
.text$mn:00000B70                 jnz     short loc_B84
.text$mn:00000B72                 mov     ecx, [ebp+var_430]
.text$mn:00000B78                 push    ecx             ; struct _TREEITEM *
.text$mn:00000B79                 mov     ecx, [ebp+var_424] ; this
.text$mn:00000B7F                 call    ?selectItem@TreeView@@QBE_NPAU_TREEITEM@@@Z ; TreeView::selectItem(_TREEITEM *)
.text$mn:00000B84
.text$mn:00000B84 loc_B84:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+36Aj
.text$mn:00000B84                                         ; TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+387j ...
.text$mn:00000B84                 mov     al, 1
.text$mn:00000B86
.text$mn:00000B86 loc_B86:                                ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+110j
.text$mn:00000B86                 mov     ecx, [ebp+var_C]
.text$mn:00000B89                 mov     large fs:0, ecx
.text$mn:00000B90                 pop     ecx
.text$mn:00000B91                 pop     edi
.text$mn:00000B92                 pop     esi
.text$mn:00000B93                 mov     ecx, [ebp+var_10]
.text$mn:00000B96                 xor     ecx, ebp
.text$mn:00000B98                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000B9D                 mov     esp, ebp
.text$mn:00000B9F                 pop     ebp
.text$mn:00000BA0                 retn    8
.text$mn:00000BA0 ?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z endp
.text$mn:00000BA0
.text$mn:00000BA0 ; ---------------------------------------------------------------------------
.text$mn:00000BA3                 align 10h
.text$mn:00000BB0
.text$mn:00000BB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BB0
.text$mn:00000BB0 ; Attributes: bp-based frame
.text$mn:00000BB0
.text$mn:00000BB0 ; bool __thiscall TreeView::restoreFoldingStateFrom(TreeView *this, const struct TreeStateNode *, struct _TREEITEM *)
.text$mn:00000BB0                 public ?restoreFoldingStateFrom@TreeView@@QAE_NABUTreeStateNode@@PAU_TREEITEM@@@Z
.text$mn:00000BB0 ?restoreFoldingStateFrom@TreeView@@QAE_NABUTreeStateNode@@PAU_TREEITEM@@@Z proc near
.text$mn:00000BB0                                         ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+180p
.text$mn:00000BB0
.text$mn:00000BB0 lParam          = dword ptr -244h
.text$mn:00000BB0 var_240         = dword ptr -240h
.text$mn:00000BB0 var_234         = dword ptr -234h
.text$mn:00000BB0 var_230         = dword ptr -230h
.text$mn:00000BB0 var_220         = dword ptr -220h
.text$mn:00000BB0 var_21C         = dword ptr -21Ch
.text$mn:00000BB0 var_218         = dword ptr -218h
.text$mn:00000BB0 var_214         = dword ptr -214h
.text$mn:00000BB0 var_20D         = byte ptr -20Dh
.text$mn:00000BB0 Str             = word ptr -20Ch
.text$mn:00000BB0 var_4           = dword ptr -4
.text$mn:00000BB0 arg_0           = dword ptr  8
.text$mn:00000BB0 arg_4           = dword ptr  0Ch
.text$mn:00000BB0
.text$mn:00000BB0                 push    ebp
.text$mn:00000BB1                 mov     ebp, esp
.text$mn:00000BB3                 sub     esp, 244h
.text$mn:00000BB9                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000BBE                 xor     eax, ebp
.text$mn:00000BC0                 mov     [ebp+var_4], eax
.text$mn:00000BC3                 mov     [ebp+var_214], ecx
.text$mn:00000BC9                 cmp     [ebp+arg_4], 0
.text$mn:00000BCD                 jnz     short loc_BD6
.text$mn:00000BCF                 xor     al, al
.text$mn:00000BD1                 jmp     loc_D62
.text$mn:00000BD6 ; ---------------------------------------------------------------------------
.text$mn:00000BD6
.text$mn:00000BD6 loc_BD6:                                ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+1Dj
.text$mn:00000BD6                 mov     eax, [ebp+arg_4]
.text$mn:00000BD9                 mov     [ebp+var_240], eax
.text$mn:00000BDF                 lea     ecx, [ebp+Str]
.text$mn:00000BE5                 mov     [ebp+var_234], ecx
.text$mn:00000BEB                 mov     [ebp+var_230], 104h
.text$mn:00000BF5                 mov     [ebp+lParam], 0Dh
.text$mn:00000BFF                 lea     edx, [ebp+lParam]
.text$mn:00000C05                 push    edx             ; lParam
.text$mn:00000C06                 push    0               ; wParam
.text$mn:00000C08                 push    113Eh           ; Msg
.text$mn:00000C0D                 mov     eax, [ebp+var_214]
.text$mn:00000C13                 mov     ecx, [eax+0Ch]
.text$mn:00000C16                 push    ecx             ; hWnd
.text$mn:00000C17                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000C1D                 lea     edx, [ebp+Str]
.text$mn:00000C23                 push    edx             ; Str
.text$mn:00000C24                 mov     eax, [ebp+arg_0]
.text$mn:00000C27                 push    eax             ; int
.text$mn:00000C28                 call    ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00000C2D                 add     esp, 8
.text$mn:00000C30                 movzx   ecx, al
.text$mn:00000C33                 test    ecx, ecx
.text$mn:00000C35                 jz      short loc_C3E
.text$mn:00000C37                 xor     al, al
.text$mn:00000C39                 jmp     loc_D62
.text$mn:00000C3E ; ---------------------------------------------------------------------------
.text$mn:00000C3E
.text$mn:00000C3E loc_C3E:                                ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+85j
.text$mn:00000C3E                 cmp     [ebp+var_220], 0
.text$mn:00000C45                 jz      short loc_C6B
.text$mn:00000C47                 mov     edx, [ebp+var_220]
.text$mn:00000C4D                 push    edx
.text$mn:00000C4E                 mov     eax, [ebp+arg_0]
.text$mn:00000C51                 add     eax, 1Ch
.text$mn:00000C54                 push    eax
.text$mn:00000C55                 call    ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00000C5A                 add     esp, 8
.text$mn:00000C5D                 movzx   ecx, al
.text$mn:00000C60                 test    ecx, ecx
.text$mn:00000C62                 jz      short loc_C6B
.text$mn:00000C64                 xor     al, al
.text$mn:00000C66                 jmp     loc_D62
.text$mn:00000C6B ; ---------------------------------------------------------------------------
.text$mn:00000C6B
.text$mn:00000C6B loc_C6B:                                ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+95j
.text$mn:00000C6B                                         ; TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+B2j
.text$mn:00000C6B                 mov     edx, [ebp+arg_0]
.text$mn:00000C6E                 movzx   eax, byte ptr [edx+38h]
.text$mn:00000C72                 test    eax, eax
.text$mn:00000C74                 jz      short loc_C87
.text$mn:00000C76                 mov     ecx, [ebp+arg_4]
.text$mn:00000C79                 push    ecx             ; struct _TREEITEM *
.text$mn:00000C7A                 mov     ecx, [ebp+var_214] ; this
.text$mn:00000C80                 call    ?expand@TreeView@@QBEXPAU_TREEITEM@@@Z ; TreeView::expand(_TREEITEM *)
.text$mn:00000C85                 jmp     short loc_C96
.text$mn:00000C87 ; ---------------------------------------------------------------------------
.text$mn:00000C87
.text$mn:00000C87 loc_C87:                                ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+C4j
.text$mn:00000C87                 mov     edx, [ebp+arg_4]
.text$mn:00000C8A                 push    edx             ; struct _TREEITEM *
.text$mn:00000C8B                 mov     ecx, [ebp+var_214] ; this
.text$mn:00000C91                 call    ?fold@TreeView@@QBEXPAU_TREEITEM@@@Z ; TreeView::fold(_TREEITEM *)
.text$mn:00000C96
.text$mn:00000C96 loc_C96:                                ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+D5j
.text$mn:00000C96                 mov     eax, [ebp+arg_0]
.text$mn:00000C99                 movzx   ecx, byte ptr [eax+39h]
.text$mn:00000C9D                 test    ecx, ecx
.text$mn:00000C9F                 jz      short loc_CB0
.text$mn:00000CA1                 mov     edx, [ebp+arg_4]
.text$mn:00000CA4                 push    edx             ; struct _TREEITEM *
.text$mn:00000CA5                 mov     ecx, [ebp+var_214] ; this
.text$mn:00000CAB                 call    ?selectItem@TreeView@@QBE_NPAU_TREEITEM@@@Z ; TreeView::selectItem(_TREEITEM *)
.text$mn:00000CB0
.text$mn:00000CB0 loc_CB0:                                ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+EFj
.text$mn:00000CB0                 mov     [ebp+var_21C], 0
.text$mn:00000CBA                 mov     [ebp+var_20D], 1
.text$mn:00000CC1                 mov     eax, [ebp+arg_4]
.text$mn:00000CC4                 push    eax             ; struct _TREEITEM *
.text$mn:00000CC5                 mov     ecx, [ebp+var_214] ; this
.text$mn:00000CCB                 call    ?getChildFrom@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getChildFrom(_TREEITEM *)
.text$mn:00000CD0                 mov     [ebp+var_218], eax
.text$mn:00000CD6                 jmp     short loc_CF0
.text$mn:00000CD8 ; ---------------------------------------------------------------------------
.text$mn:00000CD8
.text$mn:00000CD8 loc_CD8:                                ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+1A7j
.text$mn:00000CD8                 mov     ecx, [ebp+var_218]
.text$mn:00000CDE                 push    ecx             ; struct _TREEITEM *
.text$mn:00000CDF                 mov     ecx, [ebp+var_214] ; this
.text$mn:00000CE5                 call    ?getNextSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getNextSibling(_TREEITEM *)
.text$mn:00000CEA                 mov     [ebp+var_218], eax
.text$mn:00000CF0
.text$mn:00000CF0 loc_CF0:                                ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+126j
.text$mn:00000CF0                 cmp     [ebp+var_218], 0
.text$mn:00000CF7                 jz      short loc_D5C
.text$mn:00000CF9                 mov     ecx, [ebp+arg_0]
.text$mn:00000CFC                 add     ecx, 3Ch ; '<'
.text$mn:00000CFF                 call    ?size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::size(void)
.text$mn:00000D04                 cmp     [ebp+var_21C], eax
.text$mn:00000D0A                 jb      short loc_D10
.text$mn:00000D0C                 xor     al, al
.text$mn:00000D0E                 jmp     short loc_D62
.text$mn:00000D10 ; ---------------------------------------------------------------------------
.text$mn:00000D10
.text$mn:00000D10 loc_D10:                                ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+15Aj
.text$mn:00000D10                 mov     edx, [ebp+var_218]
.text$mn:00000D16                 push    edx             ; struct _TREEITEM *
.text$mn:00000D17                 mov     eax, [ebp+var_21C]
.text$mn:00000D1D                 push    eax
.text$mn:00000D1E                 mov     ecx, [ebp+arg_0]
.text$mn:00000D21                 add     ecx, 3Ch ; '<'
.text$mn:00000D24                 call    ?at@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEABUTreeStateNode@@I@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::at(uint)
.text$mn:00000D29                 push    eax             ; struct TreeStateNode *
.text$mn:00000D2A                 mov     ecx, [ebp+var_214] ; this
.text$mn:00000D30                 call    ?restoreFoldingStateFrom@TreeView@@QAE_NABUTreeStateNode@@PAU_TREEITEM@@@Z ; TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)
.text$mn:00000D35                 mov     [ebp+var_20D], al
.text$mn:00000D3B                 movzx   ecx, [ebp+var_20D]
.text$mn:00000D42                 test    ecx, ecx
.text$mn:00000D44                 jnz     short loc_D48
.text$mn:00000D46                 jmp     short loc_D5C
.text$mn:00000D48 ; ---------------------------------------------------------------------------
.text$mn:00000D48
.text$mn:00000D48 loc_D48:                                ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+194j
.text$mn:00000D48                 mov     edx, [ebp+var_21C]
.text$mn:00000D4E                 add     edx, 1
.text$mn:00000D51                 mov     [ebp+var_21C], edx
.text$mn:00000D57                 jmp     loc_CD8
.text$mn:00000D5C ; ---------------------------------------------------------------------------
.text$mn:00000D5C
.text$mn:00000D5C loc_D5C:                                ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+147j
.text$mn:00000D5C                                         ; TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+196j
.text$mn:00000D5C                 mov     al, [ebp+var_20D]
.text$mn:00000D62
.text$mn:00000D62 loc_D62:                                ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+21j
.text$mn:00000D62                                         ; TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+89j ...
.text$mn:00000D62                 mov     ecx, [ebp+var_4]
.text$mn:00000D65                 xor     ecx, ebp
.text$mn:00000D67                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000D6C                 mov     esp, ebp
.text$mn:00000D6E                 pop     ebp
.text$mn:00000D6F                 retn    8
.text$mn:00000D6F ?restoreFoldingStateFrom@TreeView@@QAE_NABUTreeStateNode@@PAU_TREEITEM@@@Z endp
.text$mn:00000D6F
.text$mn:00000D6F ; ---------------------------------------------------------------------------
.text$mn:00000D72                 align 10h
.text$mn:00000D80
.text$mn:00000D80 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D80
.text$mn:00000D80 ; Attributes: bp-based frame
.text$mn:00000D80
.text$mn:00000D80 ; bool __thiscall TreeView::retrieveFoldingStateTo(TreeView *this, struct TreeStateNode *, struct _TREEITEM *)
.text$mn:00000D80                 public ?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z
.text$mn:00000D80 ?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z proc near
.text$mn:00000D80                                         ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+1B7p
.text$mn:00000D80
.text$mn:00000D80 lParam          = dword ptr -2A8h
.text$mn:00000D80 var_2A4         = dword ptr -2A4h
.text$mn:00000D80 var_2A0         = dword ptr -2A0h
.text$mn:00000D80 var_298         = dword ptr -298h
.text$mn:00000D80 var_294         = dword ptr -294h
.text$mn:00000D80 var_284         = dword ptr -284h
.text$mn:00000D80 var_280         = dword ptr -280h
.text$mn:00000D80 var_27C         = dword ptr -27Ch
.text$mn:00000D80 var_278         = dword ptr -278h
.text$mn:00000D80 var_274         = dword ptr -274h
.text$mn:00000D80 var_270         = dword ptr -270h
.text$mn:00000D80 var_26C         = dword ptr -26Ch
.text$mn:00000D80 var_268         = dword ptr -268h
.text$mn:00000D80 var_264         = byte ptr -264h
.text$mn:00000D80 Str             = word ptr -218h
.text$mn:00000D80 var_10          = dword ptr -10h
.text$mn:00000D80 var_C           = dword ptr -0Ch
.text$mn:00000D80 var_4           = dword ptr -4
.text$mn:00000D80 arg_0           = dword ptr  8
.text$mn:00000D80 arg_4           = dword ptr  0Ch
.text$mn:00000D80
.text$mn:00000D80                 push    ebp
.text$mn:00000D81                 mov     ebp, esp
.text$mn:00000D83                 push    0FFFFFFFFh
.text$mn:00000D85                 push    offset __ehhandler$?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z
.text$mn:00000D8A                 mov     eax, large fs:0
.text$mn:00000D90                 push    eax
.text$mn:00000D91                 sub     esp, 29Ch
.text$mn:00000D97                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D9C                 xor     eax, ebp
.text$mn:00000D9E                 mov     [ebp+var_10], eax
.text$mn:00000DA1                 push    eax
.text$mn:00000DA2                 lea     eax, [ebp+var_C]
.text$mn:00000DA5                 mov     large fs:0, eax
.text$mn:00000DAB                 mov     [ebp+var_268], ecx
.text$mn:00000DB1                 cmp     [ebp+arg_4], 0
.text$mn:00000DB5                 jnz     short loc_DBE
.text$mn:00000DB7                 xor     al, al
.text$mn:00000DB9                 jmp     loc_F52
.text$mn:00000DBE ; ---------------------------------------------------------------------------
.text$mn:00000DBE
.text$mn:00000DBE loc_DBE:                                ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+35j
.text$mn:00000DBE                 mov     eax, [ebp+arg_4]
.text$mn:00000DC1                 mov     [ebp+var_2A4], eax
.text$mn:00000DC7                 lea     ecx, [ebp+Str]
.text$mn:00000DCD                 mov     [ebp+var_298], ecx
.text$mn:00000DD3                 mov     [ebp+var_294], 104h
.text$mn:00000DDD                 mov     [ebp+lParam], 0Dh
.text$mn:00000DE7                 lea     edx, [ebp+lParam]
.text$mn:00000DED                 push    edx             ; lParam
.text$mn:00000DEE                 push    0               ; wParam
.text$mn:00000DF0                 push    113Eh           ; Msg
.text$mn:00000DF5                 mov     eax, [ebp+var_268]
.text$mn:00000DFB                 mov     ecx, [eax+0Ch]
.text$mn:00000DFE                 push    ecx             ; hWnd
.text$mn:00000DFF                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000E05                 lea     edx, [ebp+Str]
.text$mn:00000E0B                 push    edx             ; Str
.text$mn:00000E0C                 mov     ecx, [ebp+arg_0]
.text$mn:00000E0F                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:00000E14                 mov     eax, [ebp+var_2A0]
.text$mn:00000E1A                 and     eax, 20h
.text$mn:00000E1D                 jz      short loc_E2B
.text$mn:00000E1F                 mov     [ebp+var_278], 1
.text$mn:00000E29                 jmp     short loc_E35
.text$mn:00000E2B ; ---------------------------------------------------------------------------
.text$mn:00000E2B
.text$mn:00000E2B loc_E2B:                                ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+9Dj
.text$mn:00000E2B                 mov     [ebp+var_278], 0
.text$mn:00000E35
.text$mn:00000E35 loc_E35:                                ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+A9j
.text$mn:00000E35                 mov     ecx, [ebp+arg_0]
.text$mn:00000E38                 mov     dl, byte ptr [ebp+var_278]
.text$mn:00000E3E                 mov     [ecx+38h], dl
.text$mn:00000E41                 mov     eax, [ebp+var_2A0]
.text$mn:00000E47                 and     eax, 2
.text$mn:00000E4A                 jz      short loc_E58
.text$mn:00000E4C                 mov     [ebp+var_274], 1
.text$mn:00000E56                 jmp     short loc_E62
.text$mn:00000E58 ; ---------------------------------------------------------------------------
.text$mn:00000E58
.text$mn:00000E58 loc_E58:                                ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+CAj
.text$mn:00000E58                 mov     [ebp+var_274], 0
.text$mn:00000E62
.text$mn:00000E62 loc_E62:                                ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+D6j
.text$mn:00000E62                 mov     ecx, [ebp+arg_0]
.text$mn:00000E65                 mov     dl, byte ptr [ebp+var_274]
.text$mn:00000E6B                 mov     [ecx+39h], dl
.text$mn:00000E6E                 cmp     [ebp+var_284], 0
.text$mn:00000E75                 jz      short loc_E89
.text$mn:00000E77                 mov     eax, [ebp+var_284]
.text$mn:00000E7D                 push    eax
.text$mn:00000E7E                 mov     ecx, [ebp+arg_0]
.text$mn:00000E81                 add     ecx, 1Ch
.text$mn:00000E84                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00000E89
.text$mn:00000E89 loc_E89:                                ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+F5j
.text$mn:00000E89                 mov     [ebp+var_270], 0
.text$mn:00000E93                 mov     ecx, [ebp+arg_4]
.text$mn:00000E96                 push    ecx             ; struct _TREEITEM *
.text$mn:00000E97                 mov     ecx, [ebp+var_268] ; this
.text$mn:00000E9D                 call    ?getChildFrom@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getChildFrom(_TREEITEM *)
.text$mn:00000EA2                 mov     [ebp+var_26C], eax
.text$mn:00000EA8                 jmp     short loc_EC2
.text$mn:00000EAA ; ---------------------------------------------------------------------------
.text$mn:00000EAA
.text$mn:00000EAA loc_EAA:                                ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+1CBj
.text$mn:00000EAA                 mov     edx, [ebp+var_26C]
.text$mn:00000EB0                 push    edx             ; struct _TREEITEM *
.text$mn:00000EB1                 mov     ecx, [ebp+var_268] ; this
.text$mn:00000EB7                 call    ?getNextSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getNextSibling(_TREEITEM *)
.text$mn:00000EBC                 mov     [ebp+var_26C], eax
.text$mn:00000EC2
.text$mn:00000EC2 loc_EC2:                                ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+128j
.text$mn:00000EC2                 cmp     [ebp+var_26C], 0
.text$mn:00000EC9                 jz      loc_F50
.text$mn:00000ECF                 lea     ecx, [ebp+var_264] ; this
.text$mn:00000ED5                 call    ??0TreeStateNode@@QAE@XZ ; TreeStateNode::TreeStateNode(void)
.text$mn:00000EDA                 mov     [ebp+var_280], eax
.text$mn:00000EE0                 mov     eax, [ebp+var_280]
.text$mn:00000EE6                 mov     [ebp+var_27C], eax
.text$mn:00000EEC                 mov     [ebp+var_4], 0
.text$mn:00000EF3                 mov     ecx, [ebp+var_27C]
.text$mn:00000EF9                 push    ecx
.text$mn:00000EFA                 mov     ecx, [ebp+arg_0]
.text$mn:00000EFD                 add     ecx, 3Ch ; '<'
.text$mn:00000F00                 call    ?push_back@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAEX$$QAUTreeStateNode@@@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::push_back(TreeStateNode &&)
.text$mn:00000F05                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F0C                 lea     ecx, [ebp+var_264] ; this
.text$mn:00000F12                 call    ??1TreeStateNode@@QAE@XZ ; TreeStateNode::~TreeStateNode(void)
.text$mn:00000F17                 mov     edx, [ebp+var_26C]
.text$mn:00000F1D                 push    edx             ; struct _TREEITEM *
.text$mn:00000F1E                 mov     eax, [ebp+var_270]
.text$mn:00000F24                 push    eax
.text$mn:00000F25                 mov     ecx, [ebp+arg_0]
.text$mn:00000F28                 add     ecx, 3Ch ; '<'
.text$mn:00000F2B                 call    ?at@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAEAAUTreeStateNode@@I@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::at(uint)
.text$mn:00000F30                 push    eax             ; struct TreeStateNode *
.text$mn:00000F31                 mov     ecx, [ebp+var_268] ; this
.text$mn:00000F37                 call    ?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z ; TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)
.text$mn:00000F3C                 mov     ecx, [ebp+var_270]
.text$mn:00000F42                 add     ecx, 1
.text$mn:00000F45                 mov     [ebp+var_270], ecx
.text$mn:00000F4B                 jmp     loc_EAA
.text$mn:00000F50 ; ---------------------------------------------------------------------------
.text$mn:00000F50
.text$mn:00000F50 loc_F50:                                ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+149j
.text$mn:00000F50                 mov     al, 1
.text$mn:00000F52
.text$mn:00000F52 loc_F52:                                ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+39j
.text$mn:00000F52                 mov     ecx, [ebp+var_C]
.text$mn:00000F55                 mov     large fs:0, ecx
.text$mn:00000F5C                 pop     ecx
.text$mn:00000F5D                 mov     ecx, [ebp+var_10]
.text$mn:00000F60                 xor     ecx, ebp
.text$mn:00000F62                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000F67                 mov     esp, ebp
.text$mn:00000F69                 pop     ebp
.text$mn:00000F6A                 retn    8
.text$mn:00000F6A ?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z endp
.text$mn:00000F6A
.text$mn:00000F6A ; ---------------------------------------------------------------------------
.text$mn:00000F6D                 align 10h
.text$mn:00000F70
.text$mn:00000F70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F70
.text$mn:00000F70 ; Attributes: bp-based frame
.text$mn:00000F70
.text$mn:00000F70 ; int __stdcall TreeView::searchLeafAndBuildTree(TreeView *, int, int)
.text$mn:00000F70                 public ?searchLeafAndBuildTree@TreeView@@QAE_NAAV1@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z
.text$mn:00000F70 ?searchLeafAndBuildTree@TreeView@@QAE_NAAV1@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z proc near
.text$mn:00000F70
.text$mn:00000F70 var_4           = dword ptr -4
.text$mn:00000F70 arg_0           = dword ptr  8
.text$mn:00000F70 arg_4           = dword ptr  0Ch
.text$mn:00000F70 arg_8           = dword ptr  10h
.text$mn:00000F70
.text$mn:00000F70                 push    ebp
.text$mn:00000F71                 mov     ebp, esp
.text$mn:00000F73                 push    ecx
.text$mn:00000F74                 mov     [ebp+var_4], ecx
.text$mn:00000F77                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000F7A                 call    ?getRoot@TreeView@@QBEPAU_TREEITEM@@XZ ; TreeView::getRoot(void)
.text$mn:00000F7F                 push    eax             ; struct _TREEITEM *
.text$mn:00000F80                 mov     eax, [ebp+arg_8]
.text$mn:00000F83                 push    eax             ; int
.text$mn:00000F84                 mov     ecx, [ebp+arg_4]
.text$mn:00000F87                 push    ecx             ; int
.text$mn:00000F88                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000F8B                 call    ?getRoot@TreeView@@QBEPAU_TREEITEM@@XZ ; TreeView::getRoot(void)
.text$mn:00000F90                 push    eax             ; int
.text$mn:00000F91                 mov     ecx, [ebp+var_4]
.text$mn:00000F94                 call    ?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z ; TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)
.text$mn:00000F99                 mov     esp, ebp
.text$mn:00000F9B                 pop     ebp
.text$mn:00000F9C                 retn    0Ch
.text$mn:00000F9C ?searchLeafAndBuildTree@TreeView@@QAE_NAAV1@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z endp
.text$mn:00000F9C
.text$mn:00000F9C ; ---------------------------------------------------------------------------
.text$mn:00000F9F                 align 10h
.text$mn:00000FA0
.text$mn:00000FA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FA0
.text$mn:00000FA0 ; Attributes: bp-based frame
.text$mn:00000FA0
.text$mn:00000FA0 ; void __thiscall TreeView::sort(TreeView *this, struct _TREEITEM *)
.text$mn:00000FA0                 public ?sort@TreeView@@QAEXPAU_TREEITEM@@@Z
.text$mn:00000FA0 ?sort@TreeView@@QAEXPAU_TREEITEM@@@Z proc near
.text$mn:00000FA0                                         ; CODE XREF: TreeView::sort(_TREEITEM *)+4Ep
.text$mn:00000FA0
.text$mn:00000FA0 var_8           = dword ptr -8
.text$mn:00000FA0 var_4           = dword ptr -4
.text$mn:00000FA0 lParam          = dword ptr  8
.text$mn:00000FA0
.text$mn:00000FA0                 push    ebp
.text$mn:00000FA1                 mov     ebp, esp
.text$mn:00000FA3                 sub     esp, 8
.text$mn:00000FA6                 mov     [ebp+var_8], ecx
.text$mn:00000FA9                 mov     eax, [ebp+lParam]
.text$mn:00000FAC                 push    eax             ; lParam
.text$mn:00000FAD                 push    1               ; wParam
.text$mn:00000FAF                 push    1113h           ; Msg
.text$mn:00000FB4                 mov     ecx, [ebp+var_8]
.text$mn:00000FB7                 mov     edx, [ecx+0Ch]
.text$mn:00000FBA                 push    edx             ; hWnd
.text$mn:00000FBB                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000FC1                 mov     eax, [ebp+lParam]
.text$mn:00000FC4                 push    eax             ; struct _TREEITEM *
.text$mn:00000FC5                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000FC8                 call    ?getChildFrom@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getChildFrom(_TREEITEM *)
.text$mn:00000FCD                 mov     [ebp+var_4], eax
.text$mn:00000FD0                 jmp     short loc_FE1
.text$mn:00000FD2 ; ---------------------------------------------------------------------------
.text$mn:00000FD2
.text$mn:00000FD2 loc_FD2:                                ; CODE XREF: TreeView::sort(_TREEITEM *)+53j
.text$mn:00000FD2                 mov     ecx, [ebp+var_4]
.text$mn:00000FD5                 push    ecx             ; struct _TREEITEM *
.text$mn:00000FD6                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000FD9                 call    ?getNextSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getNextSibling(_TREEITEM *)
.text$mn:00000FDE                 mov     [ebp+var_4], eax
.text$mn:00000FE1
.text$mn:00000FE1 loc_FE1:                                ; CODE XREF: TreeView::sort(_TREEITEM *)+30j
.text$mn:00000FE1                 cmp     [ebp+var_4], 0
.text$mn:00000FE5                 jz      short loc_FF5
.text$mn:00000FE7                 mov     edx, [ebp+var_4]
.text$mn:00000FEA                 push    edx             ; struct _TREEITEM *
.text$mn:00000FEB                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000FEE                 call    ?sort@TreeView@@QAEXPAU_TREEITEM@@@Z ; TreeView::sort(_TREEITEM *)
.text$mn:00000FF3                 jmp     short loc_FD2
.text$mn:00000FF5 ; ---------------------------------------------------------------------------
.text$mn:00000FF5
.text$mn:00000FF5 loc_FF5:                                ; CODE XREF: TreeView::sort(_TREEITEM *)+45j
.text$mn:00000FF5                 mov     esp, ebp
.text$mn:00000FF7                 pop     ebp
.text$mn:00000FF8                 retn    4
.text$mn:00000FF8 ?sort@TreeView@@QAEXPAU_TREEITEM@@@Z endp
.text$mn:00000FF8
.text$mn:00000FF8 ; ---------------------------------------------------------------------------
.text$mn:00000FFB                 align 10h
.text$mn:00001000
.text$mn:00001000 ; =============== S U B R O U T I N E =======================================
.text$mn:00001000
.text$mn:00001000 ; Attributes: bp-based frame
.text$mn:00001000
.text$mn:00001000 ; __int32 __thiscall TreeView::runProc(TreeView *this, HWND hWnd, UINT Msg, WPARAM wParam, __int32)
.text$mn:00001000                 public ?runProc@TreeView@@IAEJPAUHWND__@@IIJ@Z
.text$mn:00001000 ?runProc@TreeView@@IAEJPAUHWND__@@IIJ@Z proc near
.text$mn:00001000                                         ; CODE XREF: TreeView::staticProc(HWND__ *,uint,uint,long)+21p
.text$mn:00001000
.text$mn:00001000 var_4           = dword ptr -4
.text$mn:00001000 hWnd            = dword ptr  8
.text$mn:00001000 Msg             = dword ptr  0Ch
.text$mn:00001000 wParam          = dword ptr  10h
.text$mn:00001000 lParam          = dword ptr  14h
.text$mn:00001000
.text$mn:00001000                 push    ebp
.text$mn:00001001                 mov     ebp, esp
.text$mn:00001003                 push    ecx
.text$mn:00001004                 mov     [ebp+var_4], ecx
.text$mn:00001007                 mov     eax, [ebp+lParam]
.text$mn:0000100A                 push    eax             ; lParam
.text$mn:0000100B                 mov     ecx, [ebp+wParam]
.text$mn:0000100E                 push    ecx             ; wParam
.text$mn:0000100F                 mov     edx, [ebp+Msg]
.text$mn:00001012                 push    edx             ; Msg
.text$mn:00001013                 mov     eax, [ebp+hWnd]
.text$mn:00001016                 push    eax             ; hWnd
.text$mn:00001017                 mov     ecx, [ebp+var_4]
.text$mn:0000101A                 mov     edx, [ecx+10h]
.text$mn:0000101D                 push    edx             ; lpPrevWndFunc
.text$mn:0000101E                 call    dword ptr ds:__imp__CallWindowProcW@20 ; CallWindowProcW(x,x,x,x,x)
.text$mn:00001024                 mov     esp, ebp
.text$mn:00001026                 pop     ebp
.text$mn:00001027                 retn    10h
.text$mn:00001027 ?runProc@TreeView@@IAEJPAUHWND__@@IIJ@Z endp
.text$mn:00001027
.text$mn:00001027 ; ---------------------------------------------------------------------------
.text$mn:0000102A                 align 10h
.text$mn:00001030
.text$mn:00001030 ; =============== S U B R O U T I N E =======================================
.text$mn:00001030
.text$mn:00001030 ; Attributes: bp-based frame
.text$mn:00001030
.text$mn:00001030 ; void __thiscall TreeView::cleanSubEntries(TreeView *this, struct _TREEITEM *)
.text$mn:00001030                 public ?cleanSubEntries@TreeView@@IAEXPAU_TREEITEM@@@Z
.text$mn:00001030 ?cleanSubEntries@TreeView@@IAEXPAU_TREEITEM@@@Z proc near
.text$mn:00001030                                         ; CODE XREF: TreeView::destroy(void)+29p
.text$mn:00001030                                         ; TreeView::removeItem(_TREEITEM *)+10p ...
.text$mn:00001030
.text$mn:00001030 lParam          = dword ptr -3Ch
.text$mn:00001030 var_38          = dword ptr -38h
.text$mn:00001030 var_18          = dword ptr -18h
.text$mn:00001030 var_14          = dword ptr -14h
.text$mn:00001030 var_10          = dword ptr -10h
.text$mn:00001030 var_C           = dword ptr -0Ch
.text$mn:00001030 var_8           = dword ptr -8
.text$mn:00001030 var_4           = dword ptr -4
.text$mn:00001030 arg_0           = dword ptr  8
.text$mn:00001030
.text$mn:00001030                 push    ebp
.text$mn:00001031                 mov     ebp, esp
.text$mn:00001033                 sub     esp, 3Ch
.text$mn:00001036                 mov     [ebp+var_8], ecx
.text$mn:00001039                 mov     eax, [ebp+arg_0]
.text$mn:0000103C                 push    eax             ; struct _TREEITEM *
.text$mn:0000103D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00001040                 call    ?getChildFrom@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getChildFrom(_TREEITEM *)
.text$mn:00001045                 mov     [ebp+var_4], eax
.text$mn:00001048                 jmp     short loc_1059
.text$mn:0000104A ; ---------------------------------------------------------------------------
.text$mn:0000104A
.text$mn:0000104A loc_104A:                               ; CODE XREF: TreeView::cleanSubEntries(_TREEITEM *)+8Ej
.text$mn:0000104A                 mov     ecx, [ebp+var_4]
.text$mn:0000104D                 push    ecx             ; struct _TREEITEM *
.text$mn:0000104E                 mov     ecx, [ebp+var_8] ; this
.text$mn:00001051                 call    ?getNextSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getNextSibling(_TREEITEM *)
.text$mn:00001056                 mov     [ebp+var_4], eax
.text$mn:00001059
.text$mn:00001059 loc_1059:                               ; CODE XREF: TreeView::cleanSubEntries(_TREEITEM *)+18j
.text$mn:00001059                 cmp     [ebp+var_4], 0
.text$mn:0000105D                 jz      short loc_10C0
.text$mn:0000105F                 mov     edx, [ebp+var_4]
.text$mn:00001062                 mov     [ebp+var_38], edx
.text$mn:00001065                 mov     [ebp+lParam], 4
.text$mn:0000106C                 lea     eax, [ebp+lParam]
.text$mn:0000106F                 push    eax             ; lParam
.text$mn:00001070                 push    0               ; wParam
.text$mn:00001072                 push    113Eh           ; Msg
.text$mn:00001077                 mov     ecx, [ebp+var_8]
.text$mn:0000107A                 mov     edx, [ecx+0Ch]
.text$mn:0000107D                 push    edx             ; hWnd
.text$mn:0000107E                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001084                 cmp     [ebp+var_18], 0
.text$mn:00001088                 jz      short loc_10B2
.text$mn:0000108A                 mov     eax, [ebp+var_18]
.text$mn:0000108D                 mov     [ebp+var_10], eax
.text$mn:00001090                 mov     ecx, [ebp+var_10]
.text$mn:00001093                 mov     [ebp+var_C], ecx
.text$mn:00001096                 cmp     [ebp+var_C], 0
.text$mn:0000109A                 jz      short loc_10AB
.text$mn:0000109C                 push    1
.text$mn:0000109E                 mov     ecx, [ebp+var_C]
.text$mn:000010A1                 call    ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`scalar deleting destructor'(uint)
.text$mn:000010A6                 mov     [ebp+var_14], eax
.text$mn:000010A9                 jmp     short loc_10B2
.text$mn:000010AB ; ---------------------------------------------------------------------------
.text$mn:000010AB
.text$mn:000010AB loc_10AB:                               ; CODE XREF: TreeView::cleanSubEntries(_TREEITEM *)+6Aj
.text$mn:000010AB                 mov     [ebp+var_14], 0
.text$mn:000010B2
.text$mn:000010B2 loc_10B2:                               ; CODE XREF: TreeView::cleanSubEntries(_TREEITEM *)+58j
.text$mn:000010B2                                         ; TreeView::cleanSubEntries(_TREEITEM *)+79j
.text$mn:000010B2                 mov     edx, [ebp+var_4]
.text$mn:000010B5                 push    edx             ; struct _TREEITEM *
.text$mn:000010B6                 mov     ecx, [ebp+var_8] ; this
.text$mn:000010B9                 call    ?cleanSubEntries@TreeView@@IAEXPAU_TREEITEM@@@Z ; TreeView::cleanSubEntries(_TREEITEM *)
.text$mn:000010BE                 jmp     short loc_104A
.text$mn:000010C0 ; ---------------------------------------------------------------------------
.text$mn:000010C0
.text$mn:000010C0 loc_10C0:                               ; CODE XREF: TreeView::cleanSubEntries(_TREEITEM *)+2Dj
.text$mn:000010C0                 mov     esp, ebp
.text$mn:000010C2                 pop     ebp
.text$mn:000010C3                 retn    4
.text$mn:000010C3 ?cleanSubEntries@TreeView@@IAEXPAU_TREEITEM@@@Z endp
.text$mn:000010C3
.text$mn:000010C3 ; ---------------------------------------------------------------------------
.text$mn:000010C6                 align 10h
.text$mn:000010D0
.text$mn:000010D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000010D0
.text$mn:000010D0 ; Attributes: bp-based frame
.text$mn:000010D0
.text$mn:000010D0 ; void __thiscall TreeView::dupTree(TreeView *this, struct _TREEITEM *, struct _TREEITEM *)
.text$mn:000010D0                 public ?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z
.text$mn:000010D0 ?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z proc near
.text$mn:000010D0                                         ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+2DBp
.text$mn:000010D0                                         ; TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+340p ...
.text$mn:000010D0
.text$mn:000010D0 var_298         = dword ptr -298h
.text$mn:000010D0 var_294         = dword ptr -294h
.text$mn:000010D0 var_290         = byte ptr -290h
.text$mn:000010D0 lParam          = dword ptr -258h
.text$mn:000010D0 var_254         = dword ptr -254h
.text$mn:000010D0 var_248         = dword ptr -248h
.text$mn:000010D0 var_244         = dword ptr -244h
.text$mn:000010D0 var_234         = dword ptr -234h
.text$mn:000010D0 var_230         = dword ptr -230h
.text$mn:000010D0 var_22C         = dword ptr -22Ch
.text$mn:000010D0 var_228         = dword ptr -228h
.text$mn:000010D0 var_224         = dword ptr -224h
.text$mn:000010D0 var_220         = dword ptr -220h
.text$mn:000010D0 var_21C         = dword ptr -21Ch
.text$mn:000010D0 var_218         = byte ptr -218h
.text$mn:000010D0 var_10          = dword ptr -10h
.text$mn:000010D0 var_C           = dword ptr -0Ch
.text$mn:000010D0 var_4           = dword ptr -4
.text$mn:000010D0 arg_0           = dword ptr  8
.text$mn:000010D0 arg_4           = dword ptr  0Ch
.text$mn:000010D0
.text$mn:000010D0                 push    ebp
.text$mn:000010D1                 mov     ebp, esp
.text$mn:000010D3                 push    0FFFFFFFFh
.text$mn:000010D5                 push    offset __ehhandler$?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z
.text$mn:000010DA                 mov     eax, large fs:0
.text$mn:000010E0                 push    eax
.text$mn:000010E1                 sub     esp, 28Ch
.text$mn:000010E7                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000010EC                 xor     eax, ebp
.text$mn:000010EE                 mov     [ebp+var_10], eax
.text$mn:000010F1                 push    esi
.text$mn:000010F2                 push    edi
.text$mn:000010F3                 push    eax
.text$mn:000010F4                 lea     eax, [ebp+var_C]
.text$mn:000010F7                 mov     large fs:0, eax
.text$mn:000010FD                 mov     [ebp+var_21C], ecx
.text$mn:00001103                 mov     eax, [ebp+arg_0]
.text$mn:00001106                 push    eax             ; struct _TREEITEM *
.text$mn:00001107                 mov     ecx, [ebp+var_21C] ; this
.text$mn:0000110D                 call    ?getChildFrom@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getChildFrom(_TREEITEM *)
.text$mn:00001112                 mov     [ebp+var_220], eax
.text$mn:00001118                 jmp     short loc_1132
.text$mn:0000111A ; ---------------------------------------------------------------------------
.text$mn:0000111A
.text$mn:0000111A loc_111A:                               ; CODE XREF: TreeView::dupTree(_TREEITEM *,_TREEITEM *)+188j
.text$mn:0000111A                 mov     ecx, [ebp+var_220]
.text$mn:00001120                 push    ecx             ; struct _TREEITEM *
.text$mn:00001121                 mov     ecx, [ebp+var_21C] ; this
.text$mn:00001127                 call    ?getNextSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getNextSibling(_TREEITEM *)
.text$mn:0000112C                 mov     [ebp+var_220], eax
.text$mn:00001132
.text$mn:00001132 loc_1132:                               ; CODE XREF: TreeView::dupTree(_TREEITEM *,_TREEITEM *)+48j
.text$mn:00001132                 cmp     [ebp+var_220], 0
.text$mn:00001139                 jz      loc_125D
.text$mn:0000113F                 mov     edx, [ebp+var_220]
.text$mn:00001145                 mov     [ebp+var_254], edx
.text$mn:0000114B                 lea     eax, [ebp+var_218]
.text$mn:00001151                 mov     [ebp+var_248], eax
.text$mn:00001157                 mov     [ebp+var_244], 104h
.text$mn:00001161                 mov     [ebp+lParam], 27h ; '''
.text$mn:0000116B                 lea     ecx, [ebp+lParam]
.text$mn:00001171                 push    ecx             ; lParam
.text$mn:00001172                 push    0               ; wParam
.text$mn:00001174                 push    113Eh           ; Msg
.text$mn:00001179                 mov     edx, [ebp+var_21C]
.text$mn:0000117F                 mov     eax, [edx+0Ch]
.text$mn:00001182                 push    eax             ; hWnd
.text$mn:00001183                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001189                 cmp     [ebp+var_234], 0
.text$mn:00001190                 jz      short loc_11F5
.text$mn:00001192                 push    1Ch             ; unsigned int
.text$mn:00001194                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001199                 add     esp, 4
.text$mn:0000119C                 mov     [ebp+var_224], eax
.text$mn:000011A2                 mov     [ebp+var_4], 0
.text$mn:000011A9                 cmp     [ebp+var_224], 0
.text$mn:000011B0                 jz      short loc_11CC
.text$mn:000011B2                 mov     ecx, [ebp+var_234]
.text$mn:000011B8                 push    ecx
.text$mn:000011B9                 mov     ecx, [ebp+var_224]
.text$mn:000011BF                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000011C4                 mov     [ebp+var_228], eax
.text$mn:000011CA                 jmp     short loc_11D6
.text$mn:000011CC ; ---------------------------------------------------------------------------
.text$mn:000011CC
.text$mn:000011CC loc_11CC:                               ; CODE XREF: TreeView::dupTree(_TREEITEM *,_TREEITEM *)+E0j
.text$mn:000011CC                 mov     [ebp+var_228], 0
.text$mn:000011D6
.text$mn:000011D6 loc_11D6:                               ; CODE XREF: TreeView::dupTree(_TREEITEM *,_TREEITEM *)+FAj
.text$mn:000011D6                 mov     edx, [ebp+var_228]
.text$mn:000011DC                 mov     [ebp+var_22C], edx
.text$mn:000011E2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000011E9                 mov     eax, [ebp+var_22C]
.text$mn:000011EF                 mov     [ebp+var_234], eax
.text$mn:000011F5
.text$mn:000011F5 loc_11F5:                               ; CODE XREF: TreeView::dupTree(_TREEITEM *,_TREEITEM *)+C0j
.text$mn:000011F5                 mov     ecx, 0Ah
.text$mn:000011FA                 lea     esi, [ebp+lParam]
.text$mn:00001200                 lea     edi, [ebp+var_290]
.text$mn:00001206                 rep movsd
.text$mn:00001208                 mov     [ebp+var_294], 0FFFF0002h
.text$mn:00001212                 mov     ecx, [ebp+arg_4]
.text$mn:00001215                 mov     [ebp+var_298], ecx
.text$mn:0000121B                 lea     edx, [ebp+var_298]
.text$mn:00001221                 push    edx             ; lParam
.text$mn:00001222                 push    0               ; wParam
.text$mn:00001224                 push    1132h           ; Msg
.text$mn:00001229                 mov     eax, [ebp+var_21C]
.text$mn:0000122F                 mov     ecx, [eax+0Ch]
.text$mn:00001232                 push    ecx             ; hWnd
.text$mn:00001233                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001239                 mov     [ebp+var_230], eax
.text$mn:0000123F                 mov     edx, [ebp+var_230]
.text$mn:00001245                 push    edx             ; struct _TREEITEM *
.text$mn:00001246                 mov     eax, [ebp+var_220]
.text$mn:0000124C                 push    eax             ; struct _TREEITEM *
.text$mn:0000124D                 mov     ecx, [ebp+var_21C] ; this
.text$mn:00001253                 call    ?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z ; TreeView::dupTree(_TREEITEM *,_TREEITEM *)
.text$mn:00001258                 jmp     loc_111A
.text$mn:0000125D ; ---------------------------------------------------------------------------
.text$mn:0000125D
.text$mn:0000125D loc_125D:                               ; CODE XREF: TreeView::dupTree(_TREEITEM *,_TREEITEM *)+69j
.text$mn:0000125D                 mov     ecx, [ebp+var_C]
.text$mn:00001260                 mov     large fs:0, ecx
.text$mn:00001267                 pop     ecx
.text$mn:00001268                 pop     edi
.text$mn:00001269                 pop     esi
.text$mn:0000126A                 mov     ecx, [ebp+var_10]
.text$mn:0000126D                 xor     ecx, ebp
.text$mn:0000126F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001274                 mov     esp, ebp
.text$mn:00001276                 pop     ebp
.text$mn:00001277                 retn    8
.text$mn:00001277 ?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z endp
.text$mn:00001277
.text$mn:00001277 ; ---------------------------------------------------------------------------
.text$mn:0000127A                 align 10h
.text$mn:00001280
.text$mn:00001280 ; =============== S U B R O U T I N E =======================================
.text$mn:00001280
.text$mn:00001280 ; Attributes: bp-based frame
.text$mn:00001280
.text$mn:00001280 ; int __stdcall TreeView::searchLeafRecusivelyAndBuildTree(int, int, int, struct _TREEITEM *)
.text$mn:00001280                 public ?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z
.text$mn:00001280 ?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z proc near
.text$mn:00001280                                         ; CODE XREF: TreeView::searchLeafAndBuildTree(TreeView &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int)+24p
.text$mn:00001280                                         ; TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+289p
.text$mn:00001280
.text$mn:00001280 var_2F8         = dword ptr -2F8h
.text$mn:00001280 var_2F4         = dword ptr -2F4h
.text$mn:00001280 var_2F0         = byte ptr -2F0h
.text$mn:00001280 var_2B8         = dword ptr -2B8h
.text$mn:00001280 var_2B4         = dword ptr -2B4h
.text$mn:00001280 var_2B0         = dword ptr -2B0h
.text$mn:00001280 var_2AC         = dword ptr -2ACh
.text$mn:00001280 var_2A8         = dword ptr -2A8h
.text$mn:00001280 var_2A4         = dword ptr -2A4h
.text$mn:00001280 lParam          = dword ptr -2A0h
.text$mn:00001280 var_29C         = dword ptr -29Ch
.text$mn:00001280 Str             = dword ptr -290h
.text$mn:00001280 var_28C         = dword ptr -28Ch
.text$mn:00001280 var_288         = dword ptr -288h
.text$mn:00001280 var_27C         = dword ptr -27Ch
.text$mn:00001280 var_278         = dword ptr -278h
.text$mn:00001280 var_274         = dword ptr -274h
.text$mn:00001280 var_270         = dword ptr -270h
.text$mn:00001280 var_26C         = dword ptr -26Ch
.text$mn:00001280 var_268         = dword ptr -268h
.text$mn:00001280 var_264         = dword ptr -264h
.text$mn:00001280 var_260         = dword ptr -260h
.text$mn:00001280 var_25C         = dword ptr -25Ch
.text$mn:00001280 var_258         = dword ptr -258h
.text$mn:00001280 var_251         = byte ptr -251h
.text$mn:00001280 var_250         = byte ptr -250h
.text$mn:00001280 var_234         = byte ptr -234h
.text$mn:00001280 var_218         = byte ptr -218h
.text$mn:00001280 var_10          = dword ptr -10h
.text$mn:00001280 var_C           = dword ptr -0Ch
.text$mn:00001280 var_4           = dword ptr -4
.text$mn:00001280 arg_0           = dword ptr  8
.text$mn:00001280 arg_4           = dword ptr  0Ch
.text$mn:00001280 arg_8           = dword ptr  10h
.text$mn:00001280 arg_C           = dword ptr  14h
.text$mn:00001280
.text$mn:00001280                 push    ebp
.text$mn:00001281                 mov     ebp, esp
.text$mn:00001283                 push    0FFFFFFFFh
.text$mn:00001285                 push    offset __ehhandler$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z
.text$mn:0000128A                 mov     eax, large fs:0
.text$mn:00001290                 push    eax
.text$mn:00001291                 sub     esp, 2ECh
.text$mn:00001297                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000129C                 xor     eax, ebp
.text$mn:0000129E                 mov     [ebp+var_10], eax
.text$mn:000012A1                 push    esi
.text$mn:000012A2                 push    edi
.text$mn:000012A3                 push    eax
.text$mn:000012A4                 lea     eax, [ebp+var_C]
.text$mn:000012A7                 mov     large fs:0, eax
.text$mn:000012AD                 mov     [ebp+var_258], ecx
.text$mn:000012B3                 cmp     [ebp+arg_C], 0
.text$mn:000012B7                 jnz     short loc_12C0
.text$mn:000012B9                 xor     al, al
.text$mn:000012BB                 jmp     loc_1538
.text$mn:000012C0 ; ---------------------------------------------------------------------------
.text$mn:000012C0
.text$mn:000012C0 loc_12C0:                               ; CODE XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+37j
.text$mn:000012C0                 mov     eax, [ebp+arg_C]
.text$mn:000012C3                 mov     [ebp+var_29C], eax
.text$mn:000012C9                 lea     ecx, [ebp+var_218]
.text$mn:000012CF                 mov     [ebp+Str], ecx
.text$mn:000012D5                 mov     [ebp+var_28C], 104h
.text$mn:000012DF                 mov     [ebp+lParam], 27h ; '''
.text$mn:000012E9                 lea     edx, [ebp+lParam]
.text$mn:000012EF                 push    edx             ; lParam
.text$mn:000012F0                 push    0               ; wParam
.text$mn:000012F2                 push    113Eh           ; Msg
.text$mn:000012F7                 mov     eax, [ebp+var_258]
.text$mn:000012FD                 mov     ecx, [eax+0Ch]
.text$mn:00001300                 push    ecx             ; hWnd
.text$mn:00001301                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001307                 mov     edx, [ebp+var_288]
.text$mn:0000130D                 cmp     edx, [ebp+arg_8]
.text$mn:00001310                 jnz     loc_14A7
.text$mn:00001316                 sub     esp, 1Ch
.text$mn:00001319                 mov     ecx, esp
.text$mn:0000131B                 mov     [ebp+var_2A4], esp
.text$mn:00001321                 mov     eax, [ebp+Str]
.text$mn:00001327                 push    eax             ; Str
.text$mn:00001328                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000132D                 mov     [ebp+var_26C], eax
.text$mn:00001333                 mov     ecx, [ebp+var_26C]
.text$mn:00001339                 mov     [ebp+var_2B0], ecx
.text$mn:0000133F                 mov     [ebp+var_4], 0
.text$mn:00001346                 lea     edx, [ebp+var_250]
.text$mn:0000134C                 push    edx
.text$mn:0000134D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001354                 call    ?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z ; stringToUpper(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)
.text$mn:00001359                 add     esp, 20h
.text$mn:0000135C                 mov     [ebp+var_2A8], eax
.text$mn:00001362                 mov     [ebp+var_4], 1
.text$mn:00001369                 sub     esp, 1Ch
.text$mn:0000136C                 mov     ecx, esp
.text$mn:0000136E                 mov     [ebp+var_2AC], esp
.text$mn:00001374                 mov     eax, [ebp+arg_4]
.text$mn:00001377                 push    eax
.text$mn:00001378                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000137D                 mov     [ebp+var_278], eax
.text$mn:00001383                 mov     ecx, [ebp+var_278]
.text$mn:00001389                 mov     [ebp+var_2B4], ecx
.text$mn:0000138F                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001393                 lea     edx, [ebp+var_234]
.text$mn:00001399                 push    edx
.text$mn:0000139A                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000139E                 call    ?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z ; stringToUpper(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)
.text$mn:000013A3                 add     esp, 20h
.text$mn:000013A6                 mov     [ebp+var_2B8], eax
.text$mn:000013AC                 mov     byte ptr [ebp+var_4], 3
.text$mn:000013B0                 push    0
.text$mn:000013B2                 lea     eax, [ebp+var_234]
.text$mn:000013B8                 push    eax
.text$mn:000013B9                 lea     ecx, [ebp+var_250]
.text$mn:000013BF                 call    ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIABV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)
.text$mn:000013C4                 mov     [ebp+var_270], eax
.text$mn:000013CA                 mov     ecx, [ebp+var_270]
.text$mn:000013D0                 cmp     ecx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:000013D6                 jz      loc_1486
.text$mn:000013DC                 cmp     [ebp+var_27C], 0
.text$mn:000013E3                 jz      short loc_1442
.text$mn:000013E5                 push    1Ch             ; unsigned int
.text$mn:000013E7                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000013EC                 add     esp, 4
.text$mn:000013EF                 mov     [ebp+var_268], eax
.text$mn:000013F5                 mov     byte ptr [ebp+var_4], 4
.text$mn:000013F9                 cmp     [ebp+var_268], 0
.text$mn:00001400                 jz      short loc_141C
.text$mn:00001402                 mov     edx, [ebp+var_27C]
.text$mn:00001408                 push    edx
.text$mn:00001409                 mov     ecx, [ebp+var_268]
.text$mn:0000140F                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001414                 mov     [ebp+var_260], eax
.text$mn:0000141A                 jmp     short loc_1426
.text$mn:0000141C ; ---------------------------------------------------------------------------
.text$mn:0000141C
.text$mn:0000141C loc_141C:                               ; CODE XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+180j
.text$mn:0000141C                 mov     [ebp+var_260], 0
.text$mn:00001426
.text$mn:00001426 loc_1426:                               ; CODE XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+19Aj
.text$mn:00001426                 mov     eax, [ebp+var_260]
.text$mn:0000142C                 mov     [ebp+var_274], eax
.text$mn:00001432                 mov     byte ptr [ebp+var_4], 3
.text$mn:00001436                 mov     ecx, [ebp+var_274]
.text$mn:0000143C                 mov     [ebp+var_27C], ecx
.text$mn:00001442
.text$mn:00001442 loc_1442:                               ; CODE XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+163j
.text$mn:00001442                 mov     ecx, 0Ah
.text$mn:00001447                 lea     esi, [ebp+lParam]
.text$mn:0000144D                 lea     edi, [ebp+var_2F0]
.text$mn:00001453                 rep movsd
.text$mn:00001455                 mov     [ebp+var_2F4], 0FFFF0002h
.text$mn:0000145F                 mov     edx, [ebp+arg_0]
.text$mn:00001462                 mov     [ebp+var_2F8], edx
.text$mn:00001468                 lea     eax, [ebp+var_2F8]
.text$mn:0000146E                 push    eax             ; lParam
.text$mn:0000146F                 push    0               ; wParam
.text$mn:00001471                 push    1132h           ; Msg
.text$mn:00001476                 mov     ecx, [ebp+var_258]
.text$mn:0000147C                 mov     edx, [ecx+0Ch]
.text$mn:0000147F                 push    edx             ; hWnd
.text$mn:00001480                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001486
.text$mn:00001486 loc_1486:                               ; CODE XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+156j
.text$mn:00001486                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000148A                 lea     ecx, [ebp+var_234]
.text$mn:00001490                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001495                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000149C                 lea     ecx, [ebp+var_250]
.text$mn:000014A2                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000014A7
.text$mn:000014A7 loc_14A7:                               ; CODE XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+90j
.text$mn:000014A7                 mov     [ebp+var_264], 0
.text$mn:000014B1                 mov     [ebp+var_251], 1
.text$mn:000014B8                 mov     eax, [ebp+arg_C]
.text$mn:000014BB                 push    eax             ; struct _TREEITEM *
.text$mn:000014BC                 mov     ecx, [ebp+var_258] ; this
.text$mn:000014C2                 call    ?getChildFrom@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getChildFrom(_TREEITEM *)
.text$mn:000014C7                 mov     [ebp+var_25C], eax
.text$mn:000014CD                 jmp     short loc_14E7
.text$mn:000014CF ; ---------------------------------------------------------------------------
.text$mn:000014CF
.text$mn:000014CF loc_14CF:                               ; CODE XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+2B0j
.text$mn:000014CF                 mov     ecx, [ebp+var_25C]
.text$mn:000014D5                 push    ecx             ; struct _TREEITEM *
.text$mn:000014D6                 mov     ecx, [ebp+var_258] ; this
.text$mn:000014DC                 call    ?getNextSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getNextSibling(_TREEITEM *)
.text$mn:000014E1                 mov     [ebp+var_25C], eax
.text$mn:000014E7
.text$mn:000014E7 loc_14E7:                               ; CODE XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+24Dj
.text$mn:000014E7                 cmp     [ebp+var_25C], 0
.text$mn:000014EE                 jz      short loc_1532
.text$mn:000014F0                 mov     edx, [ebp+var_25C]
.text$mn:000014F6                 push    edx             ; struct _TREEITEM *
.text$mn:000014F7                 mov     eax, [ebp+arg_8]
.text$mn:000014FA                 push    eax             ; int
.text$mn:000014FB                 mov     ecx, [ebp+arg_4]
.text$mn:000014FE                 push    ecx             ; int
.text$mn:000014FF                 mov     edx, [ebp+arg_0]
.text$mn:00001502                 push    edx             ; int
.text$mn:00001503                 mov     ecx, [ebp+var_258]
.text$mn:00001509                 call    ?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z ; TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)
.text$mn:0000150E                 mov     [ebp+var_251], al
.text$mn:00001514                 movzx   eax, [ebp+var_251]
.text$mn:0000151B                 test    eax, eax
.text$mn:0000151D                 jnz     short loc_1521
.text$mn:0000151F                 jmp     short loc_1532
.text$mn:00001521 ; ---------------------------------------------------------------------------
.text$mn:00001521
.text$mn:00001521 loc_1521:                               ; CODE XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+29Dj
.text$mn:00001521                 mov     ecx, [ebp+var_264]
.text$mn:00001527                 add     ecx, 1
.text$mn:0000152A                 mov     [ebp+var_264], ecx
.text$mn:00001530                 jmp     short loc_14CF
.text$mn:00001532 ; ---------------------------------------------------------------------------
.text$mn:00001532
.text$mn:00001532 loc_1532:                               ; CODE XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+26Ej
.text$mn:00001532                                         ; TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+29Fj
.text$mn:00001532                 mov     al, [ebp+var_251]
.text$mn:00001538
.text$mn:00001538 loc_1538:                               ; CODE XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+3Bj
.text$mn:00001538                 mov     ecx, [ebp+var_C]
.text$mn:0000153B                 mov     large fs:0, ecx
.text$mn:00001542                 pop     ecx
.text$mn:00001543                 pop     edi
.text$mn:00001544                 pop     esi
.text$mn:00001545                 mov     ecx, [ebp+var_10]
.text$mn:00001548                 xor     ecx, ebp
.text$mn:0000154A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000154F                 mov     esp, ebp
.text$mn:00001551                 pop     ebp
.text$mn:00001552                 retn    10h
.text$mn:00001552 ?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z endp
.text$mn:00001552
.text$mn:00001552 ; ---------------------------------------------------------------------------
.text$mn:00001555                 align 10h
.text$mn:00001560
.text$mn:00001560 ; =============== S U B R O U T I N E =======================================
.text$mn:00001560
.text$mn:00001560 ; Attributes: bp-based frame
.text$mn:00001560
.text$mn:00001560 ; bool __thiscall TreeView::canBeDropped(TreeView *this, struct _TREEITEM *, struct _TREEITEM *)
.text$mn:00001560                 public ?canBeDropped@TreeView@@IAE_NPAU_TREEITEM@@0@Z
.text$mn:00001560 ?canBeDropped@TreeView@@IAE_NPAU_TREEITEM@@0@Z proc near
.text$mn:00001560                                         ; CODE XREF: TreeView::dropItem(void)+34p
.text$mn:00001560
.text$mn:00001560 var_4           = dword ptr -4
.text$mn:00001560 arg_0           = dword ptr  8
.text$mn:00001560 arg_4           = dword ptr  0Ch
.text$mn:00001560
.text$mn:00001560                 push    ebp
.text$mn:00001561                 mov     ebp, esp
.text$mn:00001563                 push    ecx
.text$mn:00001564                 mov     [ebp+var_4], ecx
.text$mn:00001567                 cmp     [ebp+arg_4], 0
.text$mn:0000156B                 jnz     short loc_1571
.text$mn:0000156D                 xor     al, al
.text$mn:0000156F                 jmp     short loc_15EB
.text$mn:00001571 ; ---------------------------------------------------------------------------
.text$mn:00001571
.text$mn:00001571 loc_1571:                               ; CODE XREF: TreeView::canBeDropped(_TREEITEM *,_TREEITEM *)+Bj
.text$mn:00001571                 mov     eax, [ebp+arg_0]
.text$mn:00001574                 cmp     eax, [ebp+arg_4]
.text$mn:00001577                 jnz     short loc_157D
.text$mn:00001579                 xor     al, al
.text$mn:0000157B                 jmp     short loc_15EB
.text$mn:0000157D ; ---------------------------------------------------------------------------
.text$mn:0000157D
.text$mn:0000157D loc_157D:                               ; CODE XREF: TreeView::canBeDropped(_TREEITEM *,_TREEITEM *)+17j
.text$mn:0000157D                 push    0               ; lParam
.text$mn:0000157F                 push    0               ; wParam
.text$mn:00001581                 push    110Ah           ; Msg
.text$mn:00001586                 mov     ecx, [ebp+var_4]
.text$mn:00001589                 mov     edx, [ecx+0Ch]
.text$mn:0000158C                 push    edx             ; hWnd
.text$mn:0000158D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001593                 cmp     [ebp+arg_4], eax
.text$mn:00001596                 jnz     short loc_159C
.text$mn:00001598                 xor     al, al
.text$mn:0000159A                 jmp     short loc_15EB
.text$mn:0000159C ; ---------------------------------------------------------------------------
.text$mn:0000159C
.text$mn:0000159C loc_159C:                               ; CODE XREF: TreeView::canBeDropped(_TREEITEM *,_TREEITEM *)+36j
.text$mn:0000159C                 mov     eax, [ebp+arg_0]
.text$mn:0000159F                 push    eax             ; struct _TREEITEM *
.text$mn:000015A0                 mov     ecx, [ebp+arg_4]
.text$mn:000015A3                 push    ecx             ; struct _TREEITEM *
.text$mn:000015A4                 mov     ecx, [ebp+var_4] ; this
.text$mn:000015A7                 call    ?isDescendant@TreeView@@IAE_NPAU_TREEITEM@@0@Z ; TreeView::isDescendant(_TREEITEM *,_TREEITEM *)
.text$mn:000015AC                 movzx   edx, al
.text$mn:000015AF                 test    edx, edx
.text$mn:000015B1                 jz      short loc_15B7
.text$mn:000015B3                 xor     al, al
.text$mn:000015B5                 jmp     short loc_15EB
.text$mn:000015B7 ; ---------------------------------------------------------------------------
.text$mn:000015B7
.text$mn:000015B7 loc_15B7:                               ; CODE XREF: TreeView::canBeDropped(_TREEITEM *,_TREEITEM *)+51j
.text$mn:000015B7                 mov     eax, [ebp+arg_0]
.text$mn:000015BA                 push    eax             ; struct _TREEITEM *
.text$mn:000015BB                 mov     ecx, [ebp+arg_4]
.text$mn:000015BE                 push    ecx             ; struct _TREEITEM *
.text$mn:000015BF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000015C2                 call    ?isParent@TreeView@@IAE_NPAU_TREEITEM@@0@Z ; TreeView::isParent(_TREEITEM *,_TREEITEM *)
.text$mn:000015C7                 movzx   edx, al
.text$mn:000015CA                 test    edx, edx
.text$mn:000015CC                 jz      short loc_15D2
.text$mn:000015CE                 xor     al, al
.text$mn:000015D0                 jmp     short loc_15EB
.text$mn:000015D2 ; ---------------------------------------------------------------------------
.text$mn:000015D2
.text$mn:000015D2 loc_15D2:                               ; CODE XREF: TreeView::canBeDropped(_TREEITEM *,_TREEITEM *)+6Cj
.text$mn:000015D2                 mov     eax, [ebp+arg_4]
.text$mn:000015D5                 push    eax             ; struct _TREEITEM *
.text$mn:000015D6                 mov     ecx, [ebp+var_4] ; this
.text$mn:000015D9                 call    ?canDropIn@TreeView@@IAE_NPAU_TREEITEM@@@Z ; TreeView::canDropIn(_TREEITEM *)
.text$mn:000015DE                 movzx   ecx, al
.text$mn:000015E1                 test    ecx, ecx
.text$mn:000015E3                 jnz     short loc_15E9
.text$mn:000015E5                 xor     al, al
.text$mn:000015E7                 jmp     short loc_15EB
.text$mn:000015E9 ; ---------------------------------------------------------------------------
.text$mn:000015E9
.text$mn:000015E9 loc_15E9:                               ; CODE XREF: TreeView::canBeDropped(_TREEITEM *,_TREEITEM *)+83j
.text$mn:000015E9                 mov     al, 1
.text$mn:000015EB
.text$mn:000015EB loc_15EB:                               ; CODE XREF: TreeView::canBeDropped(_TREEITEM *,_TREEITEM *)+Fj
.text$mn:000015EB                                         ; TreeView::canBeDropped(_TREEITEM *,_TREEITEM *)+1Bj ...
.text$mn:000015EB                 mov     esp, ebp
.text$mn:000015ED                 pop     ebp
.text$mn:000015EE                 retn    8
.text$mn:000015EE ?canBeDropped@TreeView@@IAE_NPAU_TREEITEM@@0@Z endp
.text$mn:000015EE
.text$mn:000015EE ; ---------------------------------------------------------------------------
.text$mn:000015F1                 align 10h
.text$mn:00001600
.text$mn:00001600 ; =============== S U B R O U T I N E =======================================
.text$mn:00001600
.text$mn:00001600 ; Attributes: bp-based frame
.text$mn:00001600
.text$mn:00001600 ; void __thiscall TreeView::moveTreeViewItem(TreeView *this, struct _TREEITEM *, struct _TREEITEM *)
.text$mn:00001600                 public ?moveTreeViewItem@TreeView@@IAEXPAU_TREEITEM@@0@Z
.text$mn:00001600 ?moveTreeViewItem@TreeView@@IAEXPAU_TREEITEM@@0@Z proc near
.text$mn:00001600                                         ; CODE XREF: TreeView::dropItem(void)+4Ep
.text$mn:00001600
.text$mn:00001600 var_294         = dword ptr -294h
.text$mn:00001600 var_290         = dword ptr -290h
.text$mn:00001600 var_28C         = byte ptr -28Ch
.text$mn:00001600 lParam          = dword ptr -254h
.text$mn:00001600 var_250         = dword ptr -250h
.text$mn:00001600 var_244         = dword ptr -244h
.text$mn:00001600 var_240         = dword ptr -240h
.text$mn:00001600 var_230         = dword ptr -230h
.text$mn:00001600 var_22C         = dword ptr -22Ch
.text$mn:00001600 var_228         = dword ptr -228h
.text$mn:00001600 var_224         = dword ptr -224h
.text$mn:00001600 var_220         = dword ptr -220h
.text$mn:00001600 var_21C         = dword ptr -21Ch
.text$mn:00001600 var_218         = byte ptr -218h
.text$mn:00001600 var_10          = dword ptr -10h
.text$mn:00001600 var_C           = dword ptr -0Ch
.text$mn:00001600 var_4           = dword ptr -4
.text$mn:00001600 arg_0           = dword ptr  8
.text$mn:00001600 arg_4           = dword ptr  0Ch
.text$mn:00001600
.text$mn:00001600                 push    ebp
.text$mn:00001601                 mov     ebp, esp
.text$mn:00001603                 push    0FFFFFFFFh
.text$mn:00001605                 push    offset __ehhandler$?moveTreeViewItem@TreeView@@IAEXPAU_TREEITEM@@0@Z
.text$mn:0000160A                 mov     eax, large fs:0
.text$mn:00001610                 push    eax
.text$mn:00001611                 sub     esp, 288h
.text$mn:00001617                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000161C                 xor     eax, ebp
.text$mn:0000161E                 mov     [ebp+var_10], eax
.text$mn:00001621                 push    esi
.text$mn:00001622                 push    edi
.text$mn:00001623                 push    eax
.text$mn:00001624                 lea     eax, [ebp+var_C]
.text$mn:00001627                 mov     large fs:0, eax
.text$mn:0000162D                 mov     [ebp+var_21C], ecx
.text$mn:00001633                 mov     [ebp+lParam], 27h ; '''
.text$mn:0000163D                 lea     eax, [ebp+var_218]
.text$mn:00001643                 mov     [ebp+var_244], eax
.text$mn:00001649                 mov     [ebp+var_240], 104h
.text$mn:00001653                 mov     ecx, [ebp+arg_0]
.text$mn:00001656                 mov     [ebp+var_250], ecx
.text$mn:0000165C                 lea     edx, [ebp+lParam]
.text$mn:00001662                 push    edx             ; lParam
.text$mn:00001663                 push    0               ; wParam
.text$mn:00001665                 push    113Eh           ; Msg
.text$mn:0000166A                 mov     eax, [ebp+var_21C]
.text$mn:00001670                 mov     ecx, [eax+0Ch]
.text$mn:00001673                 push    ecx             ; hWnd
.text$mn:00001674                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000167A                 cmp     [ebp+var_230], 0
.text$mn:00001681                 jz      short loc_16E6
.text$mn:00001683                 push    1Ch             ; unsigned int
.text$mn:00001685                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000168A                 add     esp, 4
.text$mn:0000168D                 mov     [ebp+var_220], eax
.text$mn:00001693                 mov     [ebp+var_4], 0
.text$mn:0000169A                 cmp     [ebp+var_220], 0
.text$mn:000016A1                 jz      short loc_16BD
.text$mn:000016A3                 mov     edx, [ebp+var_230]
.text$mn:000016A9                 push    edx
.text$mn:000016AA                 mov     ecx, [ebp+var_220]
.text$mn:000016B0                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000016B5                 mov     [ebp+var_224], eax
.text$mn:000016BB                 jmp     short loc_16C7
.text$mn:000016BD ; ---------------------------------------------------------------------------
.text$mn:000016BD
.text$mn:000016BD loc_16BD:                               ; CODE XREF: TreeView::moveTreeViewItem(_TREEITEM *,_TREEITEM *)+A1j
.text$mn:000016BD                 mov     [ebp+var_224], 0
.text$mn:000016C7
.text$mn:000016C7 loc_16C7:                               ; CODE XREF: TreeView::moveTreeViewItem(_TREEITEM *,_TREEITEM *)+BBj
.text$mn:000016C7                 mov     eax, [ebp+var_224]
.text$mn:000016CD                 mov     [ebp+var_228], eax
.text$mn:000016D3                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000016DA                 mov     ecx, [ebp+var_228]
.text$mn:000016E0                 mov     [ebp+var_230], ecx
.text$mn:000016E6
.text$mn:000016E6 loc_16E6:                               ; CODE XREF: TreeView::moveTreeViewItem(_TREEITEM *,_TREEITEM *)+81j
.text$mn:000016E6                 mov     ecx, 0Ah
.text$mn:000016EB                 lea     esi, [ebp+lParam]
.text$mn:000016F1                 lea     edi, [ebp+var_28C]
.text$mn:000016F7                 rep movsd
.text$mn:000016F9                 mov     [ebp+var_290], 0FFFF0002h
.text$mn:00001703                 mov     edx, [ebp+arg_4]
.text$mn:00001706                 mov     [ebp+var_294], edx
.text$mn:0000170C                 lea     eax, [ebp+var_294]
.text$mn:00001712                 push    eax             ; lParam
.text$mn:00001713                 push    0               ; wParam
.text$mn:00001715                 push    1132h           ; Msg
.text$mn:0000171A                 mov     ecx, [ebp+var_21C]
.text$mn:00001720                 mov     edx, [ecx+0Ch]
.text$mn:00001723                 push    edx             ; hWnd
.text$mn:00001724                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000172A                 mov     [ebp+var_22C], eax
.text$mn:00001730                 mov     eax, [ebp+var_22C]
.text$mn:00001736                 push    eax             ; struct _TREEITEM *
.text$mn:00001737                 mov     ecx, [ebp+arg_0]
.text$mn:0000173A                 push    ecx             ; struct _TREEITEM *
.text$mn:0000173B                 mov     ecx, [ebp+var_21C] ; this
.text$mn:00001741                 call    ?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z ; TreeView::dupTree(_TREEITEM *,_TREEITEM *)
.text$mn:00001746                 mov     edx, [ebp+arg_0]
.text$mn:00001749                 push    edx             ; struct _TREEITEM *
.text$mn:0000174A                 mov     ecx, [ebp+var_21C] ; this
.text$mn:00001750                 call    ?removeItem@TreeView@@QAEXPAU_TREEITEM@@@Z ; TreeView::removeItem(_TREEITEM *)
.text$mn:00001755                 mov     ecx, [ebp+var_C]
.text$mn:00001758                 mov     large fs:0, ecx
.text$mn:0000175F                 pop     ecx
.text$mn:00001760                 pop     edi
.text$mn:00001761                 pop     esi
.text$mn:00001762                 mov     ecx, [ebp+var_10]
.text$mn:00001765                 xor     ecx, ebp
.text$mn:00001767                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000176C                 mov     esp, ebp
.text$mn:0000176E                 pop     ebp
.text$mn:0000176F                 retn    8
.text$mn:0000176F ?moveTreeViewItem@TreeView@@IAEXPAU_TREEITEM@@0@Z endp
.text$mn:0000176F
.text$mn:0000176F ; ---------------------------------------------------------------------------
.text$mn:00001772                 align 10h
.text$mn:00001780
.text$mn:00001780 ; =============== S U B R O U T I N E =======================================
.text$mn:00001780
.text$mn:00001780 ; Attributes: bp-based frame
.text$mn:00001780
.text$mn:00001780 ; bool __thiscall TreeView::isParent(TreeView *this, struct _TREEITEM *, struct _TREEITEM *)
.text$mn:00001780                 public ?isParent@TreeView@@IAE_NPAU_TREEITEM@@0@Z
.text$mn:00001780 ?isParent@TreeView@@IAE_NPAU_TREEITEM@@0@Z proc near
.text$mn:00001780                                         ; CODE XREF: TreeView::canBeDropped(_TREEITEM *,_TREEITEM *)+62p
.text$mn:00001780
.text$mn:00001780 var_8           = dword ptr -8
.text$mn:00001780 var_4           = dword ptr -4
.text$mn:00001780 arg_0           = dword ptr  8
.text$mn:00001780 arg_4           = dword ptr  0Ch
.text$mn:00001780
.text$mn:00001780                 push    ebp
.text$mn:00001781                 mov     ebp, esp
.text$mn:00001783                 sub     esp, 8
.text$mn:00001786                 mov     [ebp+var_4], ecx
.text$mn:00001789                 mov     eax, [ebp+arg_4]
.text$mn:0000178C                 push    eax             ; struct _TREEITEM *
.text$mn:0000178D                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001790                 call    ?getParent@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getParent(_TREEITEM *)
.text$mn:00001795                 mov     [ebp+var_8], eax
.text$mn:00001798                 mov     ecx, [ebp+var_8]
.text$mn:0000179B                 cmp     ecx, [ebp+arg_0]
.text$mn:0000179E                 jnz     short loc_17A4
.text$mn:000017A0                 mov     al, 1
.text$mn:000017A2                 jmp     short loc_17A6
.text$mn:000017A4 ; ---------------------------------------------------------------------------
.text$mn:000017A4
.text$mn:000017A4 loc_17A4:                               ; CODE XREF: TreeView::isParent(_TREEITEM *,_TREEITEM *)+1Ej
.text$mn:000017A4                 xor     al, al
.text$mn:000017A6
.text$mn:000017A6 loc_17A6:                               ; CODE XREF: TreeView::isParent(_TREEITEM *,_TREEITEM *)+22j
.text$mn:000017A6                 mov     esp, ebp
.text$mn:000017A8                 pop     ebp
.text$mn:000017A9                 retn    8
.text$mn:000017A9 ?isParent@TreeView@@IAE_NPAU_TREEITEM@@0@Z endp
.text$mn:000017A9
.text$mn:000017A9 ; ---------------------------------------------------------------------------
.text$mn:000017AC                 align 10h
.text$mn:000017B0
.text$mn:000017B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000017B0
.text$mn:000017B0 ; Attributes: bp-based frame
.text$mn:000017B0
.text$mn:000017B0 ; bool __thiscall TreeView::isDescendant(TreeView *this, struct _TREEITEM *, struct _TREEITEM *)
.text$mn:000017B0                 public ?isDescendant@TreeView@@IAE_NPAU_TREEITEM@@0@Z
.text$mn:000017B0 ?isDescendant@TreeView@@IAE_NPAU_TREEITEM@@0@Z proc near
.text$mn:000017B0                                         ; CODE XREF: TreeView::canBeDropped(_TREEITEM *,_TREEITEM *)+47p
.text$mn:000017B0                                         ; TreeView::isDescendant(_TREEITEM *,_TREEITEM *)+58p
.text$mn:000017B0
.text$mn:000017B0 var_8           = dword ptr -8
.text$mn:000017B0 var_4           = dword ptr -4
.text$mn:000017B0 arg_0           = dword ptr  8
.text$mn:000017B0 arg_4           = dword ptr  0Ch
.text$mn:000017B0
.text$mn:000017B0                 push    ebp
.text$mn:000017B1                 mov     ebp, esp
.text$mn:000017B3                 sub     esp, 8
.text$mn:000017B6                 mov     [ebp+var_4], ecx
.text$mn:000017B9                 cmp     [ebp+arg_0], 0
.text$mn:000017BD                 jnz     short loc_17C3
.text$mn:000017BF                 xor     al, al
.text$mn:000017C1                 jmp     short loc_180D
.text$mn:000017C3 ; ---------------------------------------------------------------------------
.text$mn:000017C3
.text$mn:000017C3 loc_17C3:                               ; CODE XREF: TreeView::isDescendant(_TREEITEM *,_TREEITEM *)+Dj
.text$mn:000017C3                 push    0               ; lParam
.text$mn:000017C5                 push    0               ; wParam
.text$mn:000017C7                 push    110Ah           ; Msg
.text$mn:000017CC                 mov     eax, [ebp+var_4]
.text$mn:000017CF                 mov     ecx, [eax+0Ch]
.text$mn:000017D2                 push    ecx             ; hWnd
.text$mn:000017D3                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000017D9                 cmp     eax, [ebp+arg_0]
.text$mn:000017DC                 jnz     short loc_17E2
.text$mn:000017DE                 xor     al, al
.text$mn:000017E0                 jmp     short loc_180D
.text$mn:000017E2 ; ---------------------------------------------------------------------------
.text$mn:000017E2
.text$mn:000017E2 loc_17E2:                               ; CODE XREF: TreeView::isDescendant(_TREEITEM *,_TREEITEM *)+2Cj
.text$mn:000017E2                 mov     edx, [ebp+arg_0]
.text$mn:000017E5                 push    edx             ; struct _TREEITEM *
.text$mn:000017E6                 mov     ecx, [ebp+var_4] ; this
.text$mn:000017E9                 call    ?getParent@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z ; TreeView::getParent(_TREEITEM *)
.text$mn:000017EE                 mov     [ebp+var_8], eax
.text$mn:000017F1                 mov     eax, [ebp+var_8]
.text$mn:000017F4                 cmp     eax, [ebp+arg_4]
.text$mn:000017F7                 jnz     short loc_17FD
.text$mn:000017F9                 mov     al, 1
.text$mn:000017FB                 jmp     short loc_180D
.text$mn:000017FD ; ---------------------------------------------------------------------------
.text$mn:000017FD
.text$mn:000017FD loc_17FD:                               ; CODE XREF: TreeView::isDescendant(_TREEITEM *,_TREEITEM *)+47j
.text$mn:000017FD                 mov     ecx, [ebp+arg_4]
.text$mn:00001800                 push    ecx             ; struct _TREEITEM *
.text$mn:00001801                 mov     edx, [ebp+var_8]
.text$mn:00001804                 push    edx             ; struct _TREEITEM *
.text$mn:00001805                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001808                 call    ?isDescendant@TreeView@@IAE_NPAU_TREEITEM@@0@Z ; TreeView::isDescendant(_TREEITEM *,_TREEITEM *)
.text$mn:0000180D
.text$mn:0000180D loc_180D:                               ; CODE XREF: TreeView::isDescendant(_TREEITEM *,_TREEITEM *)+11j
.text$mn:0000180D                                         ; TreeView::isDescendant(_TREEITEM *,_TREEITEM *)+30j ...
.text$mn:0000180D                 mov     esp, ebp
.text$mn:0000180F                 pop     ebp
.text$mn:00001810                 retn    8
.text$mn:00001810 ?isDescendant@TreeView@@IAE_NPAU_TREEITEM@@0@Z endp
.text$mn:00001810
.text$mn:00001810 ; ---------------------------------------------------------------------------
.text$mn:00001813                 align 10h
.text$mn:00001820
.text$mn:00001820 ; =============== S U B R O U T I N E =======================================
.text$mn:00001820
.text$mn:00001820 ; Attributes: bp-based frame
.text$mn:00001820
.text$mn:00001820 ; bool __thiscall TreeView::canDragOut(TreeView *this, struct _TREEITEM *)
.text$mn:00001820                 public ?canDragOut@TreeView@@IAE_NPAU_TREEITEM@@@Z
.text$mn:00001820 ?canDragOut@TreeView@@IAE_NPAU_TREEITEM@@@Z proc near
.text$mn:00001820                                         ; CODE XREF: TreeView::beginDrag(tagNMTREEVIEWW *)+11p
.text$mn:00001820
.text$mn:00001820 lParam          = dword ptr -34h
.text$mn:00001820 var_30          = dword ptr -30h
.text$mn:00001820 var_1C          = dword ptr -1Ch
.text$mn:00001820 var_C           = dword ptr -0Ch
.text$mn:00001820 var_8           = dword ptr -8
.text$mn:00001820 var_4           = dword ptr -4
.text$mn:00001820 arg_0           = dword ptr  8
.text$mn:00001820
.text$mn:00001820                 push    ebp
.text$mn:00001821                 mov     ebp, esp
.text$mn:00001823                 sub     esp, 34h
.text$mn:00001826                 mov     [ebp+var_8], ecx
.text$mn:00001829                 mov     [ebp+lParam], 2
.text$mn:00001830                 mov     eax, [ebp+arg_0]
.text$mn:00001833                 mov     [ebp+var_30], eax
.text$mn:00001836                 lea     ecx, [ebp+lParam]
.text$mn:00001839                 push    ecx             ; lParam
.text$mn:0000183A                 push    0               ; wParam
.text$mn:0000183C                 push    113Eh           ; Msg
.text$mn:00001841                 mov     edx, [ebp+var_8]
.text$mn:00001844                 mov     eax, [edx+0Ch]
.text$mn:00001847                 push    eax             ; hWnd
.text$mn:00001848                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000184E                 mov     [ebp+var_4], 0
.text$mn:00001855                 mov     ecx, [ebp+var_8]
.text$mn:00001858                 add     ecx, 20h ; ' '
.text$mn:0000185B                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00001860                 mov     [ebp+var_C], eax
.text$mn:00001863                 jmp     short loc_186E
.text$mn:00001865 ; ---------------------------------------------------------------------------
.text$mn:00001865
.text$mn:00001865 loc_1865:                               ; CODE XREF: TreeView::canDragOut(_TREEITEM *):loc_1890j
.text$mn:00001865                 mov     ecx, [ebp+var_4]
.text$mn:00001868                 add     ecx, 1
.text$mn:0000186B                 mov     [ebp+var_4], ecx
.text$mn:0000186E
.text$mn:0000186E loc_186E:                               ; CODE XREF: TreeView::canDragOut(_TREEITEM *)+43j
.text$mn:0000186E                 mov     edx, [ebp+var_4]
.text$mn:00001871                 cmp     edx, [ebp+var_C]
.text$mn:00001874                 jnb     short loc_1892
.text$mn:00001876                 mov     eax, [ebp+var_4]
.text$mn:00001879                 push    eax
.text$mn:0000187A                 mov     ecx, [ebp+var_8]
.text$mn:0000187D                 add     ecx, 20h ; ' '
.text$mn:00001880                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:00001885                 mov     ecx, [ebp+var_1C]
.text$mn:00001888                 cmp     ecx, [eax]
.text$mn:0000188A                 jnz     short loc_1890
.text$mn:0000188C                 xor     al, al
.text$mn:0000188E                 jmp     short loc_1894
.text$mn:00001890 ; ---------------------------------------------------------------------------
.text$mn:00001890
.text$mn:00001890 loc_1890:                               ; CODE XREF: TreeView::canDragOut(_TREEITEM *)+6Aj
.text$mn:00001890                 jmp     short loc_1865
.text$mn:00001892 ; ---------------------------------------------------------------------------
.text$mn:00001892
.text$mn:00001892 loc_1892:                               ; CODE XREF: TreeView::canDragOut(_TREEITEM *)+54j
.text$mn:00001892                 mov     al, 1
.text$mn:00001894
.text$mn:00001894 loc_1894:                               ; CODE XREF: TreeView::canDragOut(_TREEITEM *)+6Ej
.text$mn:00001894                 mov     esp, ebp
.text$mn:00001896                 pop     ebp
.text$mn:00001897                 retn    4
.text$mn:00001897 ?canDragOut@TreeView@@IAE_NPAU_TREEITEM@@@Z endp
.text$mn:00001897
.text$mn:00001897 ; ---------------------------------------------------------------------------
.text$mn:0000189A                 align 10h
.text$mn:000018A0
.text$mn:000018A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000018A0
.text$mn:000018A0 ; Attributes: bp-based frame
.text$mn:000018A0
.text$mn:000018A0 ; bool __thiscall TreeView::canDropIn(TreeView *this, struct _TREEITEM *)
.text$mn:000018A0                 public ?canDropIn@TreeView@@IAE_NPAU_TREEITEM@@@Z
.text$mn:000018A0 ?canDropIn@TreeView@@IAE_NPAU_TREEITEM@@@Z proc near
.text$mn:000018A0                                         ; CODE XREF: TreeView::canBeDropped(_TREEITEM *,_TREEITEM *)+79p
.text$mn:000018A0
.text$mn:000018A0 lParam          = dword ptr -34h
.text$mn:000018A0 var_30          = dword ptr -30h
.text$mn:000018A0 var_1C          = dword ptr -1Ch
.text$mn:000018A0 var_C           = dword ptr -0Ch
.text$mn:000018A0 var_8           = dword ptr -8
.text$mn:000018A0 var_4           = dword ptr -4
.text$mn:000018A0 arg_0           = dword ptr  8
.text$mn:000018A0
.text$mn:000018A0                 push    ebp
.text$mn:000018A1                 mov     ebp, esp
.text$mn:000018A3                 sub     esp, 34h
.text$mn:000018A6                 mov     [ebp+var_8], ecx
.text$mn:000018A9                 mov     [ebp+lParam], 2
.text$mn:000018B0                 mov     eax, [ebp+arg_0]
.text$mn:000018B3                 mov     [ebp+var_30], eax
.text$mn:000018B6                 lea     ecx, [ebp+lParam]
.text$mn:000018B9                 push    ecx             ; lParam
.text$mn:000018BA                 push    0               ; wParam
.text$mn:000018BC                 push    113Eh           ; Msg
.text$mn:000018C1                 mov     edx, [ebp+var_8]
.text$mn:000018C4                 mov     eax, [edx+0Ch]
.text$mn:000018C7                 push    eax             ; hWnd
.text$mn:000018C8                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000018CE                 mov     [ebp+var_4], 0
.text$mn:000018D5                 mov     ecx, [ebp+var_8]
.text$mn:000018D8                 add     ecx, 30h ; '0'
.text$mn:000018DB                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:000018E0                 mov     [ebp+var_C], eax
.text$mn:000018E3                 jmp     short loc_18EE
.text$mn:000018E5 ; ---------------------------------------------------------------------------
.text$mn:000018E5
.text$mn:000018E5 loc_18E5:                               ; CODE XREF: TreeView::canDropIn(_TREEITEM *):loc_1910j
.text$mn:000018E5                 mov     ecx, [ebp+var_4]
.text$mn:000018E8                 add     ecx, 1
.text$mn:000018EB                 mov     [ebp+var_4], ecx
.text$mn:000018EE
.text$mn:000018EE loc_18EE:                               ; CODE XREF: TreeView::canDropIn(_TREEITEM *)+43j
.text$mn:000018EE                 mov     edx, [ebp+var_4]
.text$mn:000018F1                 cmp     edx, [ebp+var_C]
.text$mn:000018F4                 jnb     short loc_1912
.text$mn:000018F6                 mov     eax, [ebp+var_4]
.text$mn:000018F9                 push    eax
.text$mn:000018FA                 mov     ecx, [ebp+var_8]
.text$mn:000018FD                 add     ecx, 30h ; '0'
.text$mn:00001900                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:00001905                 mov     ecx, [ebp+var_1C]
.text$mn:00001908                 cmp     ecx, [eax]
.text$mn:0000190A                 jnz     short loc_1910
.text$mn:0000190C                 xor     al, al
.text$mn:0000190E                 jmp     short loc_1914
.text$mn:00001910 ; ---------------------------------------------------------------------------
.text$mn:00001910
.text$mn:00001910 loc_1910:                               ; CODE XREF: TreeView::canDropIn(_TREEITEM *)+6Aj
.text$mn:00001910                 jmp     short loc_18E5
.text$mn:00001912 ; ---------------------------------------------------------------------------
.text$mn:00001912
.text$mn:00001912 loc_1912:                               ; CODE XREF: TreeView::canDropIn(_TREEITEM *)+54j
.text$mn:00001912                 mov     al, 1
.text$mn:00001914
.text$mn:00001914 loc_1914:                               ; CODE XREF: TreeView::canDropIn(_TREEITEM *)+6Ej
.text$mn:00001914                 mov     esp, ebp
.text$mn:00001916                 pop     ebp
.text$mn:00001917                 retn    4
.text$mn:00001917 ?canDropIn@TreeView@@IAE_NPAU_TREEITEM@@@Z endp
.text$mn:00001917
.text$mn:00001917 ; ---------------------------------------------------------------------------
.text$mn:0000191A                 align 4
.text$mn:0000191A _text$mn        ends
.text$mn:0000191A
.text$x:0000191C ; ===========================================================================
.text$x:0000191C
.text$x:0000191C ; Segment type: Pure code
.text$x:0000191C ; Segment permissions: Read/Execute
.text$x:0000191C _text$x         segment para public 'CODE' use32
.text$x:0000191C                 assume cs:_text$x
.text$x:0000191C                 ;org 191Ch
.text$x:0000191C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000191C
.text$x:0000191C ; =============== S U B R O U T I N E =======================================
.text$x:0000191C
.text$x:0000191C
.text$x:0000191C __unwindfunclet$?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z$0 proc near
.text$x:0000191C                                         ; DATA XREF: .xdata$x:0000761Co
.text$x:0000191C                 mov     eax, [ebp-10h]
.text$x:0000191F                 push    eax             ; void *
.text$x:00001920                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001925                 pop     ecx
.text$x:00001926                 retn
.text$x:00001926 __unwindfunclet$?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z$0 endp
.text$x:00001926
.text$x:00001927
.text$x:00001927 ; =============== S U B R O U T I N E =======================================
.text$x:00001927
.text$x:00001927
.text$x:00001927 __ehhandler$?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z proc near
.text$x:00001927                                         ; DATA XREF: TreeView::addItem(wchar_t const *,_TREEITEM *,int,wchar_t const *)+5o
.text$x:00001927
.text$x:00001927 arg_4           = dword ptr  8
.text$x:00001927
.text$x:00001927                 mov     edx, [esp+arg_4]
.text$x:0000192B                 lea     eax, [edx+0Ch]
.text$x:0000192E                 mov     ecx, [edx-88h]
.text$x:00001934                 xor     ecx, eax
.text$x:00001936                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000193B                 mov     eax, offset __ehfuncinfo$?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z
.text$x:00001940                 jmp     ___CxxFrameHandler3
.text$x:00001940 __ehhandler$?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z endp
.text$x:00001940
.text$x:00001945
.text$x:00001945 ; =============== S U B R O U T I N E =======================================
.text$x:00001945
.text$x:00001945
.text$x:00001945 __unwindfunclet$?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z$0 proc near
.text$x:00001945                                         ; DATA XREF: .xdata$x:00007614o
.text$x:00001945                 mov     eax, [ebp-10h]
.text$x:00001948                 push    eax             ; void *
.text$x:00001949                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000194E                 pop     ecx
.text$x:0000194F                 retn
.text$x:0000194F __unwindfunclet$?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z$0 endp
.text$x:0000194F
.text$x:00001950
.text$x:00001950 ; =============== S U B R O U T I N E =======================================
.text$x:00001950
.text$x:00001950
.text$x:00001950 __ehhandler$?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z proc near
.text$x:00001950                                         ; DATA XREF: TreeView::setItemParam(_TREEITEM *,wchar_t const *)+5o
.text$x:00001950
.text$x:00001950 arg_4           = dword ptr  8
.text$x:00001950
.text$x:00001950                 mov     edx, [esp+arg_4]
.text$x:00001954                 lea     eax, [edx+0Ch]
.text$x:00001957                 mov     ecx, [edx-3Ch]
.text$x:0000195A                 xor     ecx, eax
.text$x:0000195C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001961                 mov     eax, offset __ehfuncinfo$?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z
.text$x:00001966                 jmp     ___CxxFrameHandler3
.text$x:00001966 __ehhandler$?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z endp
.text$x:00001966
.text$x:0000196B
.text$x:0000196B ; =============== S U B R O U T I N E =======================================
.text$x:0000196B
.text$x:0000196B
.text$x:0000196B __unwindfunclet$?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z$0 proc near
.text$x:0000196B                                         ; DATA XREF: .xdata$x:00007624o
.text$x:0000196B                 mov     eax, [ebp-454h]
.text$x:00001971                 push    eax             ; void *
.text$x:00001972                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001977                 pop     ecx
.text$x:00001978                 retn
.text$x:00001978 __unwindfunclet$?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z$0 endp
.text$x:00001978
.text$x:00001979
.text$x:00001979 ; =============== S U B R O U T I N E =======================================
.text$x:00001979
.text$x:00001979
.text$x:00001979 __unwindfunclet$?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z$1 proc near
.text$x:00001979                                         ; DATA XREF: .xdata$x:0000762Co
.text$x:00001979                 mov     eax, [ebp-448h]
.text$x:0000197F                 push    eax             ; void *
.text$x:00001980                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001985                 pop     ecx
.text$x:00001986                 retn
.text$x:00001986 __unwindfunclet$?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z$1 endp
.text$x:00001986
.text$x:00001987
.text$x:00001987 ; =============== S U B R O U T I N E =======================================
.text$x:00001987
.text$x:00001987
.text$x:00001987 __ehhandler$?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z proc near
.text$x:00001987                                         ; DATA XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+5o
.text$x:00001987
.text$x:00001987 arg_4           = dword ptr  8
.text$x:00001987
.text$x:00001987                 mov     edx, [esp+arg_4]
.text$x:0000198B                 lea     eax, [edx+0Ch]
.text$x:0000198E                 mov     ecx, [edx-534h]
.text$x:00001994                 xor     ecx, eax
.text$x:00001996                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000199B                 mov     ecx, [edx-4]
.text$x:0000199E                 xor     ecx, eax
.text$x:000019A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019A5                 mov     eax, offset __ehfuncinfo$?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z
.text$x:000019AA                 jmp     ___CxxFrameHandler3
.text$x:000019AA __ehhandler$?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z endp
.text$x:000019AA
.text$x:000019AF
.text$x:000019AF ; =============== S U B R O U T I N E =======================================
.text$x:000019AF
.text$x:000019AF
.text$x:000019AF __unwindfunclet$?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z$0 proc near
.text$x:000019AF                                         ; DATA XREF: .xdata$x:0000760Co
.text$x:000019AF                 lea     ecx, [ebp-264h] ; this
.text$x:000019B5                 jmp     ??1TreeStateNode@@QAE@XZ ; TreeStateNode::~TreeStateNode(void)
.text$x:000019B5 __unwindfunclet$?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z$0 endp
.text$x:000019B5
.text$x:000019BA
.text$x:000019BA ; =============== S U B R O U T I N E =======================================
.text$x:000019BA
.text$x:000019BA
.text$x:000019BA __ehhandler$?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z proc near
.text$x:000019BA                                         ; DATA XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+5o
.text$x:000019BA
.text$x:000019BA arg_4           = dword ptr  8
.text$x:000019BA
.text$x:000019BA                 mov     edx, [esp+arg_4]
.text$x:000019BE                 lea     eax, [edx+0Ch]
.text$x:000019C1                 mov     ecx, [edx-2A0h]
.text$x:000019C7                 xor     ecx, eax
.text$x:000019C9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019CE                 mov     ecx, [edx-4]
.text$x:000019D1                 xor     ecx, eax
.text$x:000019D3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019D8                 mov     eax, offset __ehfuncinfo$?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z
.text$x:000019DD                 jmp     ___CxxFrameHandler3
.text$x:000019DD __ehhandler$?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z endp
.text$x:000019DD
.text$x:000019E2
.text$x:000019E2 ; =============== S U B R O U T I N E =======================================
.text$x:000019E2
.text$x:000019E2
.text$x:000019E2 __unwindfunclet$?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z$0 proc near
.text$x:000019E2                                         ; DATA XREF: .xdata$x:00007604o
.text$x:000019E2                 mov     eax, [ebp-224h]
.text$x:000019E8                 push    eax             ; void *
.text$x:000019E9                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000019EE                 pop     ecx
.text$x:000019EF                 retn
.text$x:000019EF __unwindfunclet$?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z$0 endp
.text$x:000019EF
.text$x:000019F0
.text$x:000019F0 ; =============== S U B R O U T I N E =======================================
.text$x:000019F0
.text$x:000019F0
.text$x:000019F0 __ehhandler$?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z proc near
.text$x:000019F0                                         ; DATA XREF: TreeView::dupTree(_TREEITEM *,_TREEITEM *)+5o
.text$x:000019F0
.text$x:000019F0 arg_4           = dword ptr  8
.text$x:000019F0
.text$x:000019F0                 mov     edx, [esp+arg_4]
.text$x:000019F4                 lea     eax, [edx+0Ch]
.text$x:000019F7                 mov     ecx, [edx-298h]
.text$x:000019FD                 xor     ecx, eax
.text$x:000019FF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A04                 mov     ecx, [edx-4]
.text$x:00001A07                 xor     ecx, eax
.text$x:00001A09                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A0E                 mov     eax, offset __ehfuncinfo$?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z
.text$x:00001A13                 jmp     ___CxxFrameHandler3
.text$x:00001A13 __ehhandler$?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z endp
.text$x:00001A13
.text$x:00001A18
.text$x:00001A18 ; =============== S U B R O U T I N E =======================================
.text$x:00001A18
.text$x:00001A18
.text$x:00001A18 __unwindfunclet$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z$0 proc near
.text$x:00001A18                                         ; DATA XREF: .xdata$x:00007730o
.text$x:00001A18                 mov     ecx, [ebp-2A4h]
.text$x:00001A1E                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001A1E __unwindfunclet$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z$0 endp
.text$x:00001A1E
.text$x:00001A23
.text$x:00001A23 ; =============== S U B R O U T I N E =======================================
.text$x:00001A23
.text$x:00001A23
.text$x:00001A23 __unwindfunclet$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z$1 proc near
.text$x:00001A23                                         ; DATA XREF: .xdata$x:00007738o
.text$x:00001A23                 lea     ecx, [ebp-250h]
.text$x:00001A29                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001A29 __unwindfunclet$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z$1 endp
.text$x:00001A29
.text$x:00001A2E
.text$x:00001A2E ; =============== S U B R O U T I N E =======================================
.text$x:00001A2E
.text$x:00001A2E
.text$x:00001A2E __unwindfunclet$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z$2 proc near
.text$x:00001A2E                                         ; DATA XREF: .xdata$x:00007740o
.text$x:00001A2E                 mov     ecx, [ebp-2ACh]
.text$x:00001A34                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001A34 __unwindfunclet$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z$2 endp
.text$x:00001A34
.text$x:00001A39
.text$x:00001A39 ; =============== S U B R O U T I N E =======================================
.text$x:00001A39
.text$x:00001A39
.text$x:00001A39 __unwindfunclet$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z$3 proc near
.text$x:00001A39                                         ; DATA XREF: .xdata$x:00007748o
.text$x:00001A39                 lea     ecx, [ebp-234h]
.text$x:00001A3F                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001A3F __unwindfunclet$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z$3 endp
.text$x:00001A3F
.text$x:00001A44
.text$x:00001A44 ; =============== S U B R O U T I N E =======================================
.text$x:00001A44
.text$x:00001A44
.text$x:00001A44 __unwindfunclet$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z$4 proc near
.text$x:00001A44                                         ; DATA XREF: .xdata$x:00007750o
.text$x:00001A44                 mov     eax, [ebp-268h]
.text$x:00001A4A                 push    eax             ; void *
.text$x:00001A4B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001A50                 pop     ecx
.text$x:00001A51                 retn
.text$x:00001A51 __unwindfunclet$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z$4 endp
.text$x:00001A51
.text$x:00001A52
.text$x:00001A52 ; =============== S U B R O U T I N E =======================================
.text$x:00001A52
.text$x:00001A52
.text$x:00001A52 __ehhandler$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z proc near
.text$x:00001A52                                         ; DATA XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+5o
.text$x:00001A52
.text$x:00001A52 arg_4           = dword ptr  8
.text$x:00001A52
.text$x:00001A52                 mov     edx, [esp+arg_4]
.text$x:00001A56                 lea     eax, [edx+0Ch]
.text$x:00001A59                 mov     ecx, [edx-2F8h]
.text$x:00001A5F                 xor     ecx, eax
.text$x:00001A61                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A66                 mov     ecx, [edx-4]
.text$x:00001A69                 xor     ecx, eax
.text$x:00001A6B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A70                 mov     eax, offset __ehfuncinfo$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z
.text$x:00001A75                 jmp     ___CxxFrameHandler3
.text$x:00001A75 __ehhandler$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z endp
.text$x:00001A75
.text$x:00001A7A
.text$x:00001A7A ; =============== S U B R O U T I N E =======================================
.text$x:00001A7A
.text$x:00001A7A
.text$x:00001A7A __unwindfunclet$?moveTreeViewItem@TreeView@@IAEXPAU_TREEITEM@@0@Z$0 proc near
.text$x:00001A7A                                         ; DATA XREF: .xdata$x:000075FCo
.text$x:00001A7A                 mov     eax, [ebp-220h]
.text$x:00001A80                 push    eax             ; void *
.text$x:00001A81                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001A86                 pop     ecx
.text$x:00001A87                 retn
.text$x:00001A87 __unwindfunclet$?moveTreeViewItem@TreeView@@IAEXPAU_TREEITEM@@0@Z$0 endp
.text$x:00001A87
.text$x:00001A88
.text$x:00001A88 ; =============== S U B R O U T I N E =======================================
.text$x:00001A88
.text$x:00001A88
.text$x:00001A88 __ehhandler$?moveTreeViewItem@TreeView@@IAEXPAU_TREEITEM@@0@Z proc near
.text$x:00001A88                                         ; DATA XREF: TreeView::moveTreeViewItem(_TREEITEM *,_TREEITEM *)+5o
.text$x:00001A88
.text$x:00001A88 arg_4           = dword ptr  8
.text$x:00001A88
.text$x:00001A88                 mov     edx, [esp+arg_4]
.text$x:00001A8C                 lea     eax, [edx+0Ch]
.text$x:00001A8F                 mov     ecx, [edx-294h]
.text$x:00001A95                 xor     ecx, eax
.text$x:00001A97                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A9C                 mov     ecx, [edx-4]
.text$x:00001A9F                 xor     ecx, eax
.text$x:00001AA1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001AA6                 mov     eax, offset __ehfuncinfo$?moveTreeViewItem@TreeView@@IAEXPAU_TREEITEM@@0@Z
.text$x:00001AAB                 jmp     ___CxxFrameHandler3
.text$x:00001AAB __ehhandler$?moveTreeViewItem@TreeView@@IAEXPAU_TREEITEM@@0@Z endp
.text$x:00001AAB
.text$x:00001AAB _text$x         ends
.text$x:00001AAB
.text$mn:00001AB0 ; ===========================================================================
.text$mn:00001AB0
.text$mn:00001AB0 ; Segment type: Pure code
.text$mn:00001AB0 ; Segment permissions: Read/Execute
.text$mn:00001AB0 _text$mn        segment para public 'CODE' use32
.text$mn:00001AB0                 assume cs:_text$mn
.text$mn:00001AB0                 ;org 1AB0h
.text$mn:00001AB0 ; COMDAT (pick any)
.text$mn:00001AB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AB0
.text$mn:00001AB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AB0
.text$mn:00001AB0 ; Attributes: bp-based frame
.text$mn:00001AB0
.text$mn:00001AB0 ; bool __cdecl std::operator==<class std::allocator<wchar_t>, class std::allocator<wchar_t>>(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &, struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:00001AB0                 public ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
.text$mn:00001AB0 ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z proc near
.text$mn:00001AB0                                         ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+Cp
.text$mn:00001AB0
.text$mn:00001AB0 var_2           = byte ptr -2
.text$mn:00001AB0 var_1           = byte ptr -1
.text$mn:00001AB0 arg_0           = dword ptr  8
.text$mn:00001AB0 arg_4           = dword ptr  0Ch
.text$mn:00001AB0
.text$mn:00001AB0                 push    ebp
.text$mn:00001AB1                 mov     ebp, esp
.text$mn:00001AB3                 push    ecx
.text$mn:00001AB4                 mov     eax, [ebp+arg_4]
.text$mn:00001AB7                 push    eax
.text$mn:00001AB8                 lea     ecx, [ebp+var_1]
.text$mn:00001ABB                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00001AC0                 push    eax
.text$mn:00001AC1                 mov     ecx, [ebp+arg_0]
.text$mn:00001AC4                 push    ecx
.text$mn:00001AC5                 lea     ecx, [ebp+var_2]
.text$mn:00001AC8                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00001ACD                 push    eax
.text$mn:00001ACE                 call    ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z ; std::operator==<wchar_t,wchar_t>(std::allocator<wchar_t> const &,std::allocator<wchar_t> const &)
.text$mn:00001AD3                 add     esp, 8
.text$mn:00001AD6                 mov     esp, ebp
.text$mn:00001AD8                 pop     ebp
.text$mn:00001AD9                 retn
.text$mn:00001AD9 ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z endp
.text$mn:00001AD9
.text$mn:00001AD9 ; ---------------------------------------------------------------------------
.text$mn:00001ADA                 align 4
.text$mn:00001ADA _text$mn        ends
.text$mn:00001ADA
.text$mn:00001ADC ; ===========================================================================
.text$mn:00001ADC
.text$mn:00001ADC ; Segment type: Pure code
.text$mn:00001ADC ; Segment permissions: Read/Execute
.text$mn:00001ADC _text$mn        segment para public 'CODE' use32
.text$mn:00001ADC                 assume cs:_text$mn
.text$mn:00001ADC                 ;org 1ADCh
.text$mn:00001ADC ; COMDAT (pick any)
.text$mn:00001ADC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001ADC
.text$mn:00001ADC ; =============== S U B R O U T I N E =======================================
.text$mn:00001ADC
.text$mn:00001ADC ; Attributes: bp-based frame
.text$mn:00001ADC
.text$mn:00001ADC ; bool __cdecl std::operator==<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00001ADC                 public ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
.text$mn:00001ADC ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z proc near
.text$mn:00001ADC                                         ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+Cp
.text$mn:00001ADC
.text$mn:00001ADC var_4           = dword ptr -4
.text$mn:00001ADC arg_0           = dword ptr  8
.text$mn:00001ADC arg_4           = dword ptr  0Ch
.text$mn:00001ADC
.text$mn:00001ADC                 push    ebp
.text$mn:00001ADD                 mov     ebp, esp
.text$mn:00001ADF                 push    ecx
.text$mn:00001AE0                 mov     eax, [ebp+arg_4]
.text$mn:00001AE3                 push    eax
.text$mn:00001AE4                 mov     ecx, [ebp+arg_0]
.text$mn:00001AE7                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001AEC                 test    eax, eax
.text$mn:00001AEE                 jnz     short loc_1AF9
.text$mn:00001AF0                 mov     [ebp+var_4], 1
.text$mn:00001AF7                 jmp     short loc_1B00
.text$mn:00001AF9 ; ---------------------------------------------------------------------------
.text$mn:00001AF9
.text$mn:00001AF9 loc_1AF9:                               ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+12j
.text$mn:00001AF9                 mov     [ebp+var_4], 0
.text$mn:00001B00
.text$mn:00001B00 loc_1B00:                               ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+1Bj
.text$mn:00001B00                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001B03                 mov     esp, ebp
.text$mn:00001B05                 pop     ebp
.text$mn:00001B06                 retn
.text$mn:00001B06 ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z endp
.text$mn:00001B06
.text$mn:00001B06 ; ---------------------------------------------------------------------------
.text$mn:00001B07                 align 4
.text$mn:00001B07 _text$mn        ends
.text$mn:00001B07
.text$mn:00001B08 ; ===========================================================================
.text$mn:00001B08
.text$mn:00001B08 ; Segment type: Pure code
.text$mn:00001B08 ; Segment permissions: Read/Execute
.text$mn:00001B08 _text$mn        segment para public 'CODE' use32
.text$mn:00001B08                 assume cs:_text$mn
.text$mn:00001B08                 ;org 1B08h
.text$mn:00001B08 ; COMDAT (pick any)
.text$mn:00001B08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B08
.text$mn:00001B08 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B08
.text$mn:00001B08 ; Attributes: bp-based frame
.text$mn:00001B08
.text$mn:00001B08 ; int __cdecl std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, wchar_t *Str)
.text$mn:00001B08                 public ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z
.text$mn:00001B08 ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z proc near
.text$mn:00001B08                                         ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+Cp
.text$mn:00001B08
.text$mn:00001B08 var_4           = dword ptr -4
.text$mn:00001B08 arg_0           = dword ptr  8
.text$mn:00001B08 Str             = dword ptr  0Ch
.text$mn:00001B08
.text$mn:00001B08                 push    ebp
.text$mn:00001B09                 mov     ebp, esp
.text$mn:00001B0B                 push    ecx
.text$mn:00001B0C                 mov     eax, [ebp+Str]
.text$mn:00001B0F                 push    eax             ; Str
.text$mn:00001B10                 mov     ecx, [ebp+arg_0]
.text$mn:00001B13                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)
.text$mn:00001B18                 test    eax, eax
.text$mn:00001B1A                 jnz     short loc_1B25
.text$mn:00001B1C                 mov     [ebp+var_4], 1
.text$mn:00001B23                 jmp     short loc_1B2C
.text$mn:00001B25 ; ---------------------------------------------------------------------------
.text$mn:00001B25
.text$mn:00001B25 loc_1B25:                               ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+12j
.text$mn:00001B25                 mov     [ebp+var_4], 0
.text$mn:00001B2C
.text$mn:00001B2C loc_1B2C:                               ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+1Bj
.text$mn:00001B2C                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001B2F                 mov     esp, ebp
.text$mn:00001B31                 pop     ebp
.text$mn:00001B32                 retn
.text$mn:00001B32 ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z endp
.text$mn:00001B32
.text$mn:00001B32 ; ---------------------------------------------------------------------------
.text$mn:00001B33                 align 4
.text$mn:00001B33 _text$mn        ends
.text$mn:00001B33
.text$mn:00001B34 ; ===========================================================================
.text$mn:00001B34
.text$mn:00001B34 ; Segment type: Pure code
.text$mn:00001B34 ; Segment permissions: Read/Execute
.text$mn:00001B34 _text$mn        segment para public 'CODE' use32
.text$mn:00001B34                 assume cs:_text$mn
.text$mn:00001B34                 ;org 1B34h
.text$mn:00001B34 ; COMDAT (pick any)
.text$mn:00001B34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B34
.text$mn:00001B34 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B34
.text$mn:00001B34 ; Attributes: bp-based frame
.text$mn:00001B34
.text$mn:00001B34 ; bool __cdecl std::operator==<wchar_t, wchar_t>(class std::allocator<wchar_t> const &, class std::allocator<wchar_t> const &)
.text$mn:00001B34                 public ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z
.text$mn:00001B34 ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z proc near
.text$mn:00001B34                                         ; CODE XREF: std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+1Ep
.text$mn:00001B34                 push    ebp
.text$mn:00001B35                 mov     ebp, esp
.text$mn:00001B37                 mov     al, 1
.text$mn:00001B39                 pop     ebp
.text$mn:00001B3A                 retn
.text$mn:00001B3A ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z endp
.text$mn:00001B3A
.text$mn:00001B3A ; ---------------------------------------------------------------------------
.text$mn:00001B3B                 align 4
.text$mn:00001B3B _text$mn        ends
.text$mn:00001B3B
.text$mn:00001B3C ; ===========================================================================
.text$mn:00001B3C
.text$mn:00001B3C ; Segment type: Pure code
.text$mn:00001B3C ; Segment permissions: Read/Execute
.text$mn:00001B3C _text$mn        segment para public 'CODE' use32
.text$mn:00001B3C                 assume cs:_text$mn
.text$mn:00001B3C                 ;org 1B3Ch
.text$mn:00001B3C ; COMDAT (pick any)
.text$mn:00001B3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B3C
.text$mn:00001B3C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B3C
.text$mn:00001B3C ; Attributes: bp-based frame
.text$mn:00001B3C
.text$mn:00001B3C ; bool __cdecl std::operator!=<class std::allocator<wchar_t>, class std::allocator<wchar_t>>(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &, struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:00001B3C                 public ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
.text$mn:00001B3C ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z proc near
.text$mn:00001B3C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+2Bp
.text$mn:00001B3C
.text$mn:00001B3C var_4           = dword ptr -4
.text$mn:00001B3C arg_0           = dword ptr  8
.text$mn:00001B3C arg_4           = dword ptr  0Ch
.text$mn:00001B3C
.text$mn:00001B3C                 push    ebp
.text$mn:00001B3D                 mov     ebp, esp
.text$mn:00001B3F                 push    ecx
.text$mn:00001B40                 mov     eax, [ebp+arg_4]
.text$mn:00001B43                 push    eax
.text$mn:00001B44                 mov     ecx, [ebp+arg_0]
.text$mn:00001B47                 push    ecx
.text$mn:00001B48                 call    ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00001B4D                 add     esp, 8
.text$mn:00001B50                 movzx   edx, al
.text$mn:00001B53                 test    edx, edx
.text$mn:00001B55                 jnz     short loc_1B60
.text$mn:00001B57                 mov     [ebp+var_4], 1
.text$mn:00001B5E                 jmp     short loc_1B67
.text$mn:00001B60 ; ---------------------------------------------------------------------------
.text$mn:00001B60
.text$mn:00001B60 loc_1B60:                               ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+19j
.text$mn:00001B60                 mov     [ebp+var_4], 0
.text$mn:00001B67
.text$mn:00001B67 loc_1B67:                               ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+22j
.text$mn:00001B67                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001B6A                 mov     esp, ebp
.text$mn:00001B6C                 pop     ebp
.text$mn:00001B6D                 retn
.text$mn:00001B6D ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z endp
.text$mn:00001B6D
.text$mn:00001B6D ; ---------------------------------------------------------------------------
.text$mn:00001B6E                 align 10h
.text$mn:00001B6E _text$mn        ends
.text$mn:00001B6E
.text$mn:00001B70 ; ===========================================================================
.text$mn:00001B70
.text$mn:00001B70 ; Segment type: Pure code
.text$mn:00001B70 ; Segment permissions: Read/Execute
.text$mn:00001B70 _text$mn        segment para public 'CODE' use32
.text$mn:00001B70                 assume cs:_text$mn
.text$mn:00001B70                 ;org 1B70h
.text$mn:00001B70 ; COMDAT (pick any)
.text$mn:00001B70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B70
.text$mn:00001B70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B70
.text$mn:00001B70 ; Attributes: bp-based frame
.text$mn:00001B70
.text$mn:00001B70 ; bool __cdecl std::operator!=<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00001B70                 public ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
.text$mn:00001B70 ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z proc near
.text$mn:00001B70                                         ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+A5p
.text$mn:00001B70
.text$mn:00001B70 var_4           = dword ptr -4
.text$mn:00001B70 arg_0           = dword ptr  8
.text$mn:00001B70 arg_4           = dword ptr  0Ch
.text$mn:00001B70
.text$mn:00001B70                 push    ebp
.text$mn:00001B71                 mov     ebp, esp
.text$mn:00001B73                 push    ecx
.text$mn:00001B74                 mov     eax, [ebp+arg_4]
.text$mn:00001B77                 push    eax
.text$mn:00001B78                 mov     ecx, [ebp+arg_0]
.text$mn:00001B7B                 push    ecx
.text$mn:00001B7C                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001B81                 add     esp, 8
.text$mn:00001B84                 movzx   edx, al
.text$mn:00001B87                 test    edx, edx
.text$mn:00001B89                 jnz     short loc_1B94
.text$mn:00001B8B                 mov     [ebp+var_4], 1
.text$mn:00001B92                 jmp     short loc_1B9B
.text$mn:00001B94 ; ---------------------------------------------------------------------------
.text$mn:00001B94
.text$mn:00001B94 loc_1B94:                               ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+19j
.text$mn:00001B94                 mov     [ebp+var_4], 0
.text$mn:00001B9B
.text$mn:00001B9B loc_1B9B:                               ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+22j
.text$mn:00001B9B                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001B9E                 mov     esp, ebp
.text$mn:00001BA0                 pop     ebp
.text$mn:00001BA1                 retn
.text$mn:00001BA1 ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z endp
.text$mn:00001BA1
.text$mn:00001BA1 ; ---------------------------------------------------------------------------
.text$mn:00001BA2                 align 4
.text$mn:00001BA2 _text$mn        ends
.text$mn:00001BA2
.text$mn:00001BA4 ; ===========================================================================
.text$mn:00001BA4
.text$mn:00001BA4 ; Segment type: Pure code
.text$mn:00001BA4 ; Segment permissions: Read/Execute
.text$mn:00001BA4 _text$mn        segment para public 'CODE' use32
.text$mn:00001BA4                 assume cs:_text$mn
.text$mn:00001BA4                 ;org 1BA4h
.text$mn:00001BA4 ; COMDAT (pick any)
.text$mn:00001BA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BA4
.text$mn:00001BA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BA4
.text$mn:00001BA4 ; Attributes: bp-based frame
.text$mn:00001BA4
.text$mn:00001BA4 ; int __cdecl std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, wchar_t *Str)
.text$mn:00001BA4                 public ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z
.text$mn:00001BA4 ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z proc near
.text$mn:00001BA4                                         ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+78p
.text$mn:00001BA4
.text$mn:00001BA4 var_4           = dword ptr -4
.text$mn:00001BA4 arg_0           = dword ptr  8
.text$mn:00001BA4 Str             = dword ptr  0Ch
.text$mn:00001BA4
.text$mn:00001BA4                 push    ebp
.text$mn:00001BA5                 mov     ebp, esp
.text$mn:00001BA7                 push    ecx
.text$mn:00001BA8                 mov     eax, [ebp+Str]
.text$mn:00001BAB                 push    eax             ; Str
.text$mn:00001BAC                 mov     ecx, [ebp+arg_0]
.text$mn:00001BAF                 push    ecx             ; int
.text$mn:00001BB0                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00001BB5                 add     esp, 8
.text$mn:00001BB8                 movzx   edx, al
.text$mn:00001BBB                 test    edx, edx
.text$mn:00001BBD                 jnz     short loc_1BC8
.text$mn:00001BBF                 mov     [ebp+var_4], 1
.text$mn:00001BC6                 jmp     short loc_1BCF
.text$mn:00001BC8 ; ---------------------------------------------------------------------------
.text$mn:00001BC8
.text$mn:00001BC8 loc_1BC8:                               ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+19j
.text$mn:00001BC8                 mov     [ebp+var_4], 0
.text$mn:00001BCF
.text$mn:00001BCF loc_1BCF:                               ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+22j
.text$mn:00001BCF                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001BD2                 mov     esp, ebp
.text$mn:00001BD4                 pop     ebp
.text$mn:00001BD5                 retn
.text$mn:00001BD5 ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z endp
.text$mn:00001BD5
.text$mn:00001BD5 ; ---------------------------------------------------------------------------
.text$mn:00001BD6                 align 4
.text$mn:00001BD6 _text$mn        ends
.text$mn:00001BD6
.text$mn:00001BD8 ; ===========================================================================
.text$mn:00001BD8
.text$mn:00001BD8 ; Segment type: Pure code
.text$mn:00001BD8 ; Segment permissions: Read/Execute
.text$mn:00001BD8 _text$mn        segment para public 'CODE' use32
.text$mn:00001BD8                 assume cs:_text$mn
.text$mn:00001BD8                 ;org 1BD8h
.text$mn:00001BD8 ; COMDAT (pick any)
.text$mn:00001BD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BD8
.text$mn:00001BD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BD8
.text$mn:00001BD8 ; Attributes: bp-based frame
.text$mn:00001BD8
.text$mn:00001BD8 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00001BD8                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00001BD8 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00001BD8                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00001BD8
.text$mn:00001BD8 var_4           = dword ptr -4
.text$mn:00001BD8 arg_0           = dword ptr  8
.text$mn:00001BD8
.text$mn:00001BD8                 push    ebp
.text$mn:00001BD9                 mov     ebp, esp
.text$mn:00001BDB                 push    ecx
.text$mn:00001BDC                 mov     [ebp+var_4], 0
.text$mn:00001BE3                 cmp     [ebp+arg_0], 0
.text$mn:00001BE7                 jnz     short loc_1BEB
.text$mn:00001BE9                 jmp     short loc_1C0B
.text$mn:00001BEB ; ---------------------------------------------------------------------------
.text$mn:00001BEB
.text$mn:00001BEB loc_1BEB:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00001BEB                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00001BEF                 ja      short loc_1C06
.text$mn:00001BF1                 mov     eax, [ebp+arg_0]
.text$mn:00001BF4                 push    eax             ; unsigned int
.text$mn:00001BF5                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001BFA                 add     esp, 4
.text$mn:00001BFD                 mov     [ebp+var_4], eax
.text$mn:00001C00                 cmp     [ebp+var_4], 0
.text$mn:00001C04                 jnz     short loc_1C0B
.text$mn:00001C06
.text$mn:00001C06 loc_1C06:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00001C06                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001C0B
.text$mn:00001C0B loc_1C0B:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00001C0B                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00001C0B                 mov     eax, [ebp+var_4]
.text$mn:00001C0E                 mov     esp, ebp
.text$mn:00001C10                 pop     ebp
.text$mn:00001C11                 retn
.text$mn:00001C11 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00001C11
.text$mn:00001C11 ; ---------------------------------------------------------------------------
.text$mn:00001C12                 align 4
.text$mn:00001C12 _text$mn        ends
.text$mn:00001C12
.text$mn:00001C14 ; ===========================================================================
.text$mn:00001C14
.text$mn:00001C14 ; Segment type: Pure code
.text$mn:00001C14 ; Segment permissions: Read/Execute
.text$mn:00001C14 _text$mn        segment para public 'CODE' use32
.text$mn:00001C14                 assume cs:_text$mn
.text$mn:00001C14                 ;org 1C14h
.text$mn:00001C14 ; COMDAT (pick any)
.text$mn:00001C14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C14
.text$mn:00001C14 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C14
.text$mn:00001C14 ; Attributes: bp-based frame
.text$mn:00001C14
.text$mn:00001C14 ; struct TreeStateNode * __cdecl std::_Allocate<struct TreeStateNode>(unsigned int, struct TreeStateNode *)
.text$mn:00001C14                 public ??$_Allocate@UTreeStateNode@@@std@@YAPAUTreeStateNode@@IPAU1@@Z
.text$mn:00001C14 ??$_Allocate@UTreeStateNode@@@std@@YAPAUTreeStateNode@@IPAU1@@Z proc near
.text$mn:00001C14                                         ; CODE XREF: std::allocator<TreeStateNode>::allocate(uint)+Dp
.text$mn:00001C14
.text$mn:00001C14 var_4           = dword ptr -4
.text$mn:00001C14 arg_0           = dword ptr  8
.text$mn:00001C14
.text$mn:00001C14                 push    ebp
.text$mn:00001C15                 mov     ebp, esp
.text$mn:00001C17                 push    ecx
.text$mn:00001C18                 mov     [ebp+var_4], 0
.text$mn:00001C1F                 cmp     [ebp+arg_0], 0
.text$mn:00001C23                 jnz     short loc_1C27
.text$mn:00001C25                 jmp     short loc_1C4B
.text$mn:00001C27 ; ---------------------------------------------------------------------------
.text$mn:00001C27
.text$mn:00001C27 loc_1C27:                               ; CODE XREF: std::_Allocate<TreeStateNode>(uint,TreeStateNode *)+Fj
.text$mn:00001C27                 cmp     [ebp+arg_0], 35E50D7h
.text$mn:00001C2E                 ja      short loc_1C46
.text$mn:00001C30                 imul    eax, [ebp+arg_0], 4Ch
.text$mn:00001C34                 push    eax             ; unsigned int
.text$mn:00001C35                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001C3A                 add     esp, 4
.text$mn:00001C3D                 mov     [ebp+var_4], eax
.text$mn:00001C40                 cmp     [ebp+var_4], 0
.text$mn:00001C44                 jnz     short loc_1C4B
.text$mn:00001C46
.text$mn:00001C46 loc_1C46:                               ; CODE XREF: std::_Allocate<TreeStateNode>(uint,TreeStateNode *)+1Aj
.text$mn:00001C46                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001C4B
.text$mn:00001C4B loc_1C4B:                               ; CODE XREF: std::_Allocate<TreeStateNode>(uint,TreeStateNode *)+11j
.text$mn:00001C4B                                         ; std::_Allocate<TreeStateNode>(uint,TreeStateNode *)+30j
.text$mn:00001C4B                 mov     eax, [ebp+var_4]
.text$mn:00001C4E                 mov     esp, ebp
.text$mn:00001C50                 pop     ebp
.text$mn:00001C51                 retn
.text$mn:00001C51 ??$_Allocate@UTreeStateNode@@@std@@YAPAUTreeStateNode@@IPAU1@@Z endp
.text$mn:00001C51
.text$mn:00001C51 ; ---------------------------------------------------------------------------
.text$mn:00001C52                 align 4
.text$mn:00001C52 _text$mn        ends
.text$mn:00001C52
.text$mn:00001C54 ; ===========================================================================
.text$mn:00001C54
.text$mn:00001C54 ; Segment type: Pure code
.text$mn:00001C54 ; Segment permissions: Read/Execute
.text$mn:00001C54 _text$mn        segment para public 'CODE' use32
.text$mn:00001C54                 assume cs:_text$mn
.text$mn:00001C54                 ;org 1C54h
.text$mn:00001C54 ; COMDAT (pick any)
.text$mn:00001C54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C54
.text$mn:00001C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C54
.text$mn:00001C54 ; Attributes: bp-based frame
.text$mn:00001C54
.text$mn:00001C54 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00001C54                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00001C54 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00001C54                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00001C54
.text$mn:00001C54 var_4           = dword ptr -4
.text$mn:00001C54 arg_0           = dword ptr  8
.text$mn:00001C54
.text$mn:00001C54                 push    ebp
.text$mn:00001C55                 mov     ebp, esp
.text$mn:00001C57                 push    ecx
.text$mn:00001C58                 mov     [ebp+var_4], 0
.text$mn:00001C5F                 cmp     [ebp+arg_0], 0
.text$mn:00001C63                 jnz     short loc_1C67
.text$mn:00001C65                 jmp     short loc_1C8D
.text$mn:00001C67 ; ---------------------------------------------------------------------------
.text$mn:00001C67
.text$mn:00001C67 loc_1C67:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00001C67                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00001C6E                 ja      short loc_1C88
.text$mn:00001C70                 mov     eax, [ebp+arg_0]
.text$mn:00001C73                 shl     eax, 3
.text$mn:00001C76                 push    eax             ; unsigned int
.text$mn:00001C77                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001C7C                 add     esp, 4
.text$mn:00001C7F                 mov     [ebp+var_4], eax
.text$mn:00001C82                 cmp     [ebp+var_4], 0
.text$mn:00001C86                 jnz     short loc_1C8D
.text$mn:00001C88
.text$mn:00001C88 loc_1C88:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00001C88                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001C8D
.text$mn:00001C8D loc_1C8D:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00001C8D                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00001C8D                 mov     eax, [ebp+var_4]
.text$mn:00001C90                 mov     esp, ebp
.text$mn:00001C92                 pop     ebp
.text$mn:00001C93                 retn
.text$mn:00001C93 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00001C93
.text$mn:00001C93 _text$mn        ends
.text$mn:00001C93
.text$mn:00001C94 ; ===========================================================================
.text$mn:00001C94
.text$mn:00001C94 ; Segment type: Pure code
.text$mn:00001C94 ; Segment permissions: Read/Execute
.text$mn:00001C94 _text$mn        segment para public 'CODE' use32
.text$mn:00001C94                 assume cs:_text$mn
.text$mn:00001C94                 ;org 1C94h
.text$mn:00001C94 ; COMDAT (pick any)
.text$mn:00001C94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C94
.text$mn:00001C94 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C94
.text$mn:00001C94 ; Attributes: bp-based frame
.text$mn:00001C94
.text$mn:00001C94 ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:00001C94                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:00001C94 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:00001C94                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:00001C94
.text$mn:00001C94 var_4           = dword ptr -4
.text$mn:00001C94 arg_0           = dword ptr  8
.text$mn:00001C94
.text$mn:00001C94                 push    ebp
.text$mn:00001C95                 mov     ebp, esp
.text$mn:00001C97                 push    ecx
.text$mn:00001C98                 mov     [ebp+var_4], 0
.text$mn:00001C9F                 cmp     [ebp+arg_0], 0
.text$mn:00001CA3                 jnz     short loc_1CA7
.text$mn:00001CA5                 jmp     short loc_1CCC
.text$mn:00001CA7 ; ---------------------------------------------------------------------------
.text$mn:00001CA7
.text$mn:00001CA7 loc_1CA7:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:00001CA7                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:00001CAE                 ja      short loc_1CC7
.text$mn:00001CB0                 mov     eax, [ebp+arg_0]
.text$mn:00001CB3                 shl     eax, 1
.text$mn:00001CB5                 push    eax             ; unsigned int
.text$mn:00001CB6                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001CBB                 add     esp, 4
.text$mn:00001CBE                 mov     [ebp+var_4], eax
.text$mn:00001CC1                 cmp     [ebp+var_4], 0
.text$mn:00001CC5                 jnz     short loc_1CCC
.text$mn:00001CC7
.text$mn:00001CC7 loc_1CC7:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:00001CC7                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001CCC
.text$mn:00001CCC loc_1CCC:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:00001CCC                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:00001CCC                 mov     eax, [ebp+var_4]
.text$mn:00001CCF                 mov     esp, ebp
.text$mn:00001CD1                 pop     ebp
.text$mn:00001CD2                 retn
.text$mn:00001CD2 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:00001CD2
.text$mn:00001CD2 ; ---------------------------------------------------------------------------
.text$mn:00001CD3                 align 4
.text$mn:00001CD3 _text$mn        ends
.text$mn:00001CD3
.text$mn:00001CD4 ; ===========================================================================
.text$mn:00001CD4
.text$mn:00001CD4 ; Segment type: Pure code
.text$mn:00001CD4 ; Segment permissions: Read/Execute
.text$mn:00001CD4 _text$mn        segment para public 'CODE' use32
.text$mn:00001CD4                 assume cs:_text$mn
.text$mn:00001CD4                 ;org 1CD4h
.text$mn:00001CD4 ; COMDAT (pick any)
.text$mn:00001CD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CD4
.text$mn:00001CD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CD4
.text$mn:00001CD4 ; Attributes: bp-based frame
.text$mn:00001CD4
.text$mn:00001CD4 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00001CD4                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00001CD4 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00001CD4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00001CD4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00001CD4
.text$mn:00001CD4 arg_0           = dword ptr  8
.text$mn:00001CD4 arg_4           = dword ptr  0Ch
.text$mn:00001CD4 arg_8           = dword ptr  10h
.text$mn:00001CD4
.text$mn:00001CD4                 push    ebp
.text$mn:00001CD5                 mov     ebp, esp
.text$mn:00001CD7                 cmp     [ebp+arg_0], 0
.text$mn:00001CDB                 jnz     short loc_1CF2
.text$mn:00001CDD                 mov     eax, [ebp+arg_8]
.text$mn:00001CE0                 push    eax             ; unsigned int
.text$mn:00001CE1                 mov     ecx, [ebp+arg_4]
.text$mn:00001CE4                 push    ecx             ; wchar_t *
.text$mn:00001CE5                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001CEA                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001CEF                 add     esp, 0Ch
.text$mn:00001CF2
.text$mn:00001CF2 loc_1CF2:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00001CF2                 pop     ebp
.text$mn:00001CF3                 retn
.text$mn:00001CF3 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00001CF3
.text$mn:00001CF3 _text$mn        ends
.text$mn:00001CF3
.text$mn:00001CF4 ; ===========================================================================
.text$mn:00001CF4
.text$mn:00001CF4 ; Segment type: Pure code
.text$mn:00001CF4 ; Segment permissions: Read/Execute
.text$mn:00001CF4 _text$mn        segment para public 'CODE' use32
.text$mn:00001CF4                 assume cs:_text$mn
.text$mn:00001CF4                 ;org 1CF4h
.text$mn:00001CF4 ; COMDAT (pick any)
.text$mn:00001CF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CF4
.text$mn:00001CF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CF4
.text$mn:00001CF4 ; Attributes: bp-based frame
.text$mn:00001CF4
.text$mn:00001CF4 ; int __cdecl std::_Debug_pointer<TreeStateNode>(int, wchar_t *, unsigned int)
.text$mn:00001CF4                 public ??$_Debug_pointer@UTreeStateNode@@@std@@YAXPAUTreeStateNode@@PB_WI@Z
.text$mn:00001CF4 ??$_Debug_pointer@UTreeStateNode@@@std@@YAXPAUTreeStateNode@@PB_WI@Z proc near
.text$mn:00001CF4                                         ; CODE XREF: std::_Debug_range2<TreeStateNode *>(TreeStateNode *,TreeStateNode *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00001CF4                                         ; std::_Debug_range2<TreeStateNode *>(TreeStateNode *,TreeStateNode *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00001CF4
.text$mn:00001CF4 arg_0           = dword ptr  8
.text$mn:00001CF4 arg_4           = dword ptr  0Ch
.text$mn:00001CF4 arg_8           = dword ptr  10h
.text$mn:00001CF4
.text$mn:00001CF4                 push    ebp
.text$mn:00001CF5                 mov     ebp, esp
.text$mn:00001CF7                 cmp     [ebp+arg_0], 0
.text$mn:00001CFB                 jnz     short loc_1D12
.text$mn:00001CFD                 mov     eax, [ebp+arg_8]
.text$mn:00001D00                 push    eax             ; unsigned int
.text$mn:00001D01                 mov     ecx, [ebp+arg_4]
.text$mn:00001D04                 push    ecx             ; wchar_t *
.text$mn:00001D05                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001D0A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001D0F                 add     esp, 0Ch
.text$mn:00001D12
.text$mn:00001D12 loc_1D12:                               ; CODE XREF: std::_Debug_pointer<TreeStateNode>(TreeStateNode *,wchar_t const *,uint)+7j
.text$mn:00001D12                 pop     ebp
.text$mn:00001D13                 retn
.text$mn:00001D13 ??$_Debug_pointer@UTreeStateNode@@@std@@YAXPAUTreeStateNode@@PB_WI@Z endp
.text$mn:00001D13
.text$mn:00001D13 _text$mn        ends
.text$mn:00001D13
.text$mn:00001D14 ; ===========================================================================
.text$mn:00001D14
.text$mn:00001D14 ; Segment type: Pure code
.text$mn:00001D14 ; Segment permissions: Read/Execute
.text$mn:00001D14 _text$mn        segment para public 'CODE' use32
.text$mn:00001D14                 assume cs:_text$mn
.text$mn:00001D14                 ;org 1D14h
.text$mn:00001D14 ; COMDAT (pick any)
.text$mn:00001D14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D14
.text$mn:00001D14 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D14
.text$mn:00001D14 ; Attributes: bp-based frame
.text$mn:00001D14
.text$mn:00001D14 ; int __cdecl std::_Debug_pointer<TreeStateNode>(int, wchar_t *, unsigned int)
.text$mn:00001D14                 public ??$_Debug_pointer@UTreeStateNode@@@std@@YAXPBUTreeStateNode@@PB_WI@Z
.text$mn:00001D14 ??$_Debug_pointer@UTreeStateNode@@@std@@YAXPBUTreeStateNode@@PB_WI@Z proc near
.text$mn:00001D14                                         ; CODE XREF: std::_Debug_range2<TreeStateNode const *>(TreeStateNode const *,TreeStateNode const *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00001D14                                         ; std::_Debug_range2<TreeStateNode const *>(TreeStateNode const *,TreeStateNode const *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp
.text$mn:00001D14
.text$mn:00001D14 arg_0           = dword ptr  8
.text$mn:00001D14 arg_4           = dword ptr  0Ch
.text$mn:00001D14 arg_8           = dword ptr  10h
.text$mn:00001D14
.text$mn:00001D14                 push    ebp
.text$mn:00001D15                 mov     ebp, esp
.text$mn:00001D17                 cmp     [ebp+arg_0], 0
.text$mn:00001D1B                 jnz     short loc_1D32
.text$mn:00001D1D                 mov     eax, [ebp+arg_8]
.text$mn:00001D20                 push    eax             ; unsigned int
.text$mn:00001D21                 mov     ecx, [ebp+arg_4]
.text$mn:00001D24                 push    ecx             ; wchar_t *
.text$mn:00001D25                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001D2A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001D2F                 add     esp, 0Ch
.text$mn:00001D32
.text$mn:00001D32 loc_1D32:                               ; CODE XREF: std::_Debug_pointer<TreeStateNode>(TreeStateNode const *,wchar_t const *,uint)+7j
.text$mn:00001D32                 pop     ebp
.text$mn:00001D33                 retn
.text$mn:00001D33 ??$_Debug_pointer@UTreeStateNode@@@std@@YAXPBUTreeStateNode@@PB_WI@Z endp
.text$mn:00001D33
.text$mn:00001D33 _text$mn        ends
.text$mn:00001D33
.text$mn:00001D34 ; ===========================================================================
.text$mn:00001D34
.text$mn:00001D34 ; Segment type: Pure code
.text$mn:00001D34 ; Segment permissions: Read/Execute
.text$mn:00001D34 _text$mn        segment para public 'CODE' use32
.text$mn:00001D34                 assume cs:_text$mn
.text$mn:00001D34                 ;org 1D34h
.text$mn:00001D34 ; COMDAT (pick any)
.text$mn:00001D34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D34
.text$mn:00001D34 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D34
.text$mn:00001D34 ; Attributes: bp-based frame
.text$mn:00001D34
.text$mn:00001D34 ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:00001D34                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:00001D34 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:00001D34                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+15p
.text$mn:00001D34                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+1Bp ...
.text$mn:00001D34
.text$mn:00001D34 arg_0           = dword ptr  8
.text$mn:00001D34 arg_4           = dword ptr  0Ch
.text$mn:00001D34 arg_8           = dword ptr  10h
.text$mn:00001D34
.text$mn:00001D34                 push    ebp
.text$mn:00001D35                 mov     ebp, esp
.text$mn:00001D37                 cmp     [ebp+arg_0], 0
.text$mn:00001D3B                 jnz     short loc_1D52
.text$mn:00001D3D                 mov     eax, [ebp+arg_8]
.text$mn:00001D40                 push    eax             ; unsigned int
.text$mn:00001D41                 mov     ecx, [ebp+arg_4]
.text$mn:00001D44                 push    ecx             ; wchar_t *
.text$mn:00001D45                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001D4A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001D4F                 add     esp, 0Ch
.text$mn:00001D52
.text$mn:00001D52 loc_1D52:                               ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:00001D52                 pop     ebp
.text$mn:00001D53                 retn
.text$mn:00001D53 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:00001D53
.text$mn:00001D53 _text$mn        ends
.text$mn:00001D53
.text$mn:00001D54 ; ===========================================================================
.text$mn:00001D54
.text$mn:00001D54 ; Segment type: Pure code
.text$mn:00001D54 ; Segment permissions: Read/Execute
.text$mn:00001D54 _text$mn        segment para public 'CODE' use32
.text$mn:00001D54                 assume cs:_text$mn
.text$mn:00001D54                 ;org 1D54h
.text$mn:00001D54 ; COMDAT (pick any)
.text$mn:00001D54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D54
.text$mn:00001D54 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D54
.text$mn:00001D54 ; Attributes: bp-based frame
.text$mn:00001D54
.text$mn:00001D54 ; int __cdecl std::_Debug_range2<TreeStateNode *>(int, int, wchar_t *, unsigned int)
.text$mn:00001D54                 public ??$_Debug_range2@PAUTreeStateNode@@@std@@YAXPAUTreeStateNode@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00001D54 ??$_Debug_range2@PAUTreeStateNode@@@std@@YAXPAUTreeStateNode@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00001D54                                         ; CODE XREF: std::_Debug_range<TreeStateNode *>(TreeStateNode *,TreeStateNode *,wchar_t const *,uint)+2Ap
.text$mn:00001D54
.text$mn:00001D54 arg_0           = dword ptr  8
.text$mn:00001D54 arg_4           = dword ptr  0Ch
.text$mn:00001D54 arg_8           = dword ptr  10h
.text$mn:00001D54 arg_C           = dword ptr  14h
.text$mn:00001D54
.text$mn:00001D54                 push    ebp
.text$mn:00001D55                 mov     ebp, esp
.text$mn:00001D57                 mov     eax, [ebp+arg_0]
.text$mn:00001D5A                 cmp     eax, [ebp+arg_4]
.text$mn:00001D5D                 jz      short loc_1DA4
.text$mn:00001D5F                 mov     ecx, [ebp+arg_C]
.text$mn:00001D62                 push    ecx             ; unsigned int
.text$mn:00001D63                 mov     edx, [ebp+arg_8]
.text$mn:00001D66                 push    edx             ; wchar_t *
.text$mn:00001D67                 mov     eax, [ebp+arg_0]
.text$mn:00001D6A                 push    eax             ; int
.text$mn:00001D6B                 call    ??$_Debug_pointer@UTreeStateNode@@@std@@YAXPAUTreeStateNode@@PB_WI@Z ; std::_Debug_pointer<TreeStateNode>(TreeStateNode *,wchar_t const *,uint)
.text$mn:00001D70                 add     esp, 0Ch
.text$mn:00001D73                 mov     ecx, [ebp+arg_C]
.text$mn:00001D76                 push    ecx             ; unsigned int
.text$mn:00001D77                 mov     edx, [ebp+arg_8]
.text$mn:00001D7A                 push    edx             ; wchar_t *
.text$mn:00001D7B                 mov     eax, [ebp+arg_4]
.text$mn:00001D7E                 push    eax             ; int
.text$mn:00001D7F                 call    ??$_Debug_pointer@UTreeStateNode@@@std@@YAXPAUTreeStateNode@@PB_WI@Z ; std::_Debug_pointer<TreeStateNode>(TreeStateNode *,wchar_t const *,uint)
.text$mn:00001D84                 add     esp, 0Ch
.text$mn:00001D87                 mov     ecx, [ebp+arg_4]
.text$mn:00001D8A                 cmp     ecx, [ebp+arg_0]
.text$mn:00001D8D                 jnb     short loc_1DA4
.text$mn:00001D8F                 mov     edx, [ebp+arg_C]
.text$mn:00001D92                 push    edx             ; unsigned int
.text$mn:00001D93                 mov     eax, [ebp+arg_8]
.text$mn:00001D96                 push    eax             ; wchar_t *
.text$mn:00001D97                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00001D9C                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001DA1                 add     esp, 0Ch
.text$mn:00001DA4
.text$mn:00001DA4 loc_1DA4:                               ; CODE XREF: std::_Debug_range2<TreeStateNode *>(TreeStateNode *,TreeStateNode *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00001DA4                                         ; std::_Debug_range2<TreeStateNode *>(TreeStateNode *,TreeStateNode *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00001DA4                 pop     ebp
.text$mn:00001DA5                 retn
.text$mn:00001DA5 ??$_Debug_range2@PAUTreeStateNode@@@std@@YAXPAUTreeStateNode@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00001DA5
.text$mn:00001DA5 ; ---------------------------------------------------------------------------
.text$mn:00001DA6                 align 4
.text$mn:00001DA6 _text$mn        ends
.text$mn:00001DA6
.text$mn:00001DA8 ; ===========================================================================
.text$mn:00001DA8
.text$mn:00001DA8 ; Segment type: Pure code
.text$mn:00001DA8 ; Segment permissions: Read/Execute
.text$mn:00001DA8 _text$mn        segment para public 'CODE' use32
.text$mn:00001DA8                 assume cs:_text$mn
.text$mn:00001DA8                 ;org 1DA8h
.text$mn:00001DA8 ; COMDAT (pick any)
.text$mn:00001DA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DA8
.text$mn:00001DA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DA8
.text$mn:00001DA8 ; Attributes: bp-based frame
.text$mn:00001DA8
.text$mn:00001DA8 ; int __cdecl std::_Debug_range2<TreeStateNode const *>(int, int, wchar_t *, unsigned int)
.text$mn:00001DA8                 public ??$_Debug_range2@PBUTreeStateNode@@@std@@YAXPBUTreeStateNode@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00001DA8 ??$_Debug_range2@PBUTreeStateNode@@@std@@YAXPBUTreeStateNode@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00001DA8                                         ; CODE XREF: std::_Debug_range<TreeStateNode const *>(TreeStateNode const *,TreeStateNode const *,wchar_t const *,uint)+2Ap
.text$mn:00001DA8
.text$mn:00001DA8 arg_0           = dword ptr  8
.text$mn:00001DA8 arg_4           = dword ptr  0Ch
.text$mn:00001DA8 arg_8           = dword ptr  10h
.text$mn:00001DA8 arg_C           = dword ptr  14h
.text$mn:00001DA8
.text$mn:00001DA8                 push    ebp
.text$mn:00001DA9                 mov     ebp, esp
.text$mn:00001DAB                 mov     eax, [ebp+arg_0]
.text$mn:00001DAE                 cmp     eax, [ebp+arg_4]
.text$mn:00001DB1                 jz      short loc_1DF8
.text$mn:00001DB3                 mov     ecx, [ebp+arg_C]
.text$mn:00001DB6                 push    ecx             ; unsigned int
.text$mn:00001DB7                 mov     edx, [ebp+arg_8]
.text$mn:00001DBA                 push    edx             ; wchar_t *
.text$mn:00001DBB                 mov     eax, [ebp+arg_0]
.text$mn:00001DBE                 push    eax             ; int
.text$mn:00001DBF                 call    ??$_Debug_pointer@UTreeStateNode@@@std@@YAXPBUTreeStateNode@@PB_WI@Z ; std::_Debug_pointer<TreeStateNode>(TreeStateNode const *,wchar_t const *,uint)
.text$mn:00001DC4                 add     esp, 0Ch
.text$mn:00001DC7                 mov     ecx, [ebp+arg_C]
.text$mn:00001DCA                 push    ecx             ; unsigned int
.text$mn:00001DCB                 mov     edx, [ebp+arg_8]
.text$mn:00001DCE                 push    edx             ; wchar_t *
.text$mn:00001DCF                 mov     eax, [ebp+arg_4]
.text$mn:00001DD2                 push    eax             ; int
.text$mn:00001DD3                 call    ??$_Debug_pointer@UTreeStateNode@@@std@@YAXPBUTreeStateNode@@PB_WI@Z ; std::_Debug_pointer<TreeStateNode>(TreeStateNode const *,wchar_t const *,uint)
.text$mn:00001DD8                 add     esp, 0Ch
.text$mn:00001DDB                 mov     ecx, [ebp+arg_4]
.text$mn:00001DDE                 cmp     ecx, [ebp+arg_0]
.text$mn:00001DE1                 jnb     short loc_1DF8
.text$mn:00001DE3                 mov     edx, [ebp+arg_C]
.text$mn:00001DE6                 push    edx             ; unsigned int
.text$mn:00001DE7                 mov     eax, [ebp+arg_8]
.text$mn:00001DEA                 push    eax             ; wchar_t *
.text$mn:00001DEB                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00001DF0                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001DF5                 add     esp, 0Ch
.text$mn:00001DF8
.text$mn:00001DF8 loc_1DF8:                               ; CODE XREF: std::_Debug_range2<TreeStateNode const *>(TreeStateNode const *,TreeStateNode const *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00001DF8                                         ; std::_Debug_range2<TreeStateNode const *>(TreeStateNode const *,TreeStateNode const *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00001DF8                 pop     ebp
.text$mn:00001DF9                 retn
.text$mn:00001DF9 ??$_Debug_range2@PBUTreeStateNode@@@std@@YAXPBUTreeStateNode@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00001DF9
.text$mn:00001DF9 ; ---------------------------------------------------------------------------
.text$mn:00001DFA                 align 4
.text$mn:00001DFA _text$mn        ends
.text$mn:00001DFA
.text$mn:00001DFC ; ===========================================================================
.text$mn:00001DFC
.text$mn:00001DFC ; Segment type: Pure code
.text$mn:00001DFC ; Segment permissions: Read/Execute
.text$mn:00001DFC _text$mn        segment para public 'CODE' use32
.text$mn:00001DFC                 assume cs:_text$mn
.text$mn:00001DFC                 ;org 1DFCh
.text$mn:00001DFC ; COMDAT (pick any)
.text$mn:00001DFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DFC
.text$mn:00001DFC ; =============== S U B R O U T I N E =======================================
.text$mn:00001DFC
.text$mn:00001DFC ; Attributes: bp-based frame
.text$mn:00001DFC
.text$mn:00001DFC ; int __cdecl std::_Debug_range<TreeStateNode *>(int, int, wchar_t *, unsigned int)
.text$mn:00001DFC                 public ??$_Debug_range@PAUTreeStateNode@@@std@@YAXPAUTreeStateNode@@0PB_WI@Z
.text$mn:00001DFC ??$_Debug_range@PAUTreeStateNode@@@std@@YAXPAUTreeStateNode@@0PB_WI@Z proc near
.text$mn:00001DFC                                         ; CODE XREF: std::_Uninit_move<TreeStateNode *,TreeStateNode *,std::allocator<TreeStateNode>,TreeStateNode>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,TreeStateNode *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:00001DFC
.text$mn:00001DFC var_1           = byte ptr -1
.text$mn:00001DFC arg_0           = dword ptr  8
.text$mn:00001DFC arg_4           = dword ptr  0Ch
.text$mn:00001DFC arg_8           = dword ptr  10h
.text$mn:00001DFC arg_C           = dword ptr  14h
.text$mn:00001DFC
.text$mn:00001DFC                 push    ebp
.text$mn:00001DFD                 mov     ebp, esp
.text$mn:00001DFF                 push    ecx
.text$mn:00001E00                 lea     eax, [ebp+arg_0]
.text$mn:00001E03                 push    eax
.text$mn:00001E04                 lea     ecx, [ebp+var_1]
.text$mn:00001E07                 push    ecx
.text$mn:00001E08                 call    ??$_Iter_cat@PAUTreeStateNode@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTreeStateNode@@@Z ; std::_Iter_cat<TreeStateNode *>(TreeStateNode * const &)
.text$mn:00001E0D                 add     esp, 8
.text$mn:00001E10                 mov     dl, [eax]
.text$mn:00001E12                 movzx   eax, dl
.text$mn:00001E15                 push    eax
.text$mn:00001E16                 mov     ecx, [ebp+arg_C]
.text$mn:00001E19                 push    ecx             ; unsigned int
.text$mn:00001E1A                 mov     edx, [ebp+arg_8]
.text$mn:00001E1D                 push    edx             ; wchar_t *
.text$mn:00001E1E                 mov     eax, [ebp+arg_4]
.text$mn:00001E21                 push    eax             ; int
.text$mn:00001E22                 mov     ecx, [ebp+arg_0]
.text$mn:00001E25                 push    ecx             ; int
.text$mn:00001E26                 call    ??$_Debug_range2@PAUTreeStateNode@@@std@@YAXPAUTreeStateNode@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<TreeStateNode *>(TreeStateNode *,TreeStateNode *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00001E2B                 add     esp, 14h
.text$mn:00001E2E                 mov     esp, ebp
.text$mn:00001E30                 pop     ebp
.text$mn:00001E31                 retn
.text$mn:00001E31 ??$_Debug_range@PAUTreeStateNode@@@std@@YAXPAUTreeStateNode@@0PB_WI@Z endp
.text$mn:00001E31
.text$mn:00001E31 ; ---------------------------------------------------------------------------
.text$mn:00001E32                 align 4
.text$mn:00001E32 _text$mn        ends
.text$mn:00001E32
.text$mn:00001E34 ; ===========================================================================
.text$mn:00001E34
.text$mn:00001E34 ; Segment type: Pure code
.text$mn:00001E34 ; Segment permissions: Read/Execute
.text$mn:00001E34 _text$mn        segment para public 'CODE' use32
.text$mn:00001E34                 assume cs:_text$mn
.text$mn:00001E34                 ;org 1E34h
.text$mn:00001E34 ; COMDAT (pick any)
.text$mn:00001E34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E34
.text$mn:00001E34 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E34
.text$mn:00001E34 ; Attributes: bp-based frame
.text$mn:00001E34
.text$mn:00001E34 ; int __cdecl std::_Debug_range<TreeStateNode const *>(int, int, wchar_t *, unsigned int)
.text$mn:00001E34                 public ??$_Debug_range@PBUTreeStateNode@@@std@@YAXPBUTreeStateNode@@0PB_WI@Z
.text$mn:00001E34 ??$_Debug_range@PBUTreeStateNode@@@std@@YAXPBUTreeStateNode@@0PB_WI@Z proc near
.text$mn:00001E34                                         ; CODE XREF: std::_Uninit_copy<TreeStateNode const *,TreeStateNode *,std::allocator<TreeStateNode>>(TreeStateNode const *,TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:00001E34
.text$mn:00001E34 var_1           = byte ptr -1
.text$mn:00001E34 arg_0           = dword ptr  8
.text$mn:00001E34 arg_4           = dword ptr  0Ch
.text$mn:00001E34 arg_8           = dword ptr  10h
.text$mn:00001E34 arg_C           = dword ptr  14h
.text$mn:00001E34
.text$mn:00001E34                 push    ebp
.text$mn:00001E35                 mov     ebp, esp
.text$mn:00001E37                 push    ecx
.text$mn:00001E38                 lea     eax, [ebp+arg_0]
.text$mn:00001E3B                 push    eax
.text$mn:00001E3C                 lea     ecx, [ebp+var_1]
.text$mn:00001E3F                 push    ecx
.text$mn:00001E40                 call    ??$_Iter_cat@PBUTreeStateNode@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUTreeStateNode@@@Z ; std::_Iter_cat<TreeStateNode const *>(TreeStateNode const * const &)
.text$mn:00001E45                 add     esp, 8
.text$mn:00001E48                 mov     dl, [eax]
.text$mn:00001E4A                 movzx   eax, dl
.text$mn:00001E4D                 push    eax
.text$mn:00001E4E                 mov     ecx, [ebp+arg_C]
.text$mn:00001E51                 push    ecx             ; unsigned int
.text$mn:00001E52                 mov     edx, [ebp+arg_8]
.text$mn:00001E55                 push    edx             ; wchar_t *
.text$mn:00001E56                 mov     eax, [ebp+arg_4]
.text$mn:00001E59                 push    eax             ; int
.text$mn:00001E5A                 mov     ecx, [ebp+arg_0]
.text$mn:00001E5D                 push    ecx             ; int
.text$mn:00001E5E                 call    ??$_Debug_range2@PBUTreeStateNode@@@std@@YAXPBUTreeStateNode@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<TreeStateNode const *>(TreeStateNode const *,TreeStateNode const *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00001E63                 add     esp, 14h
.text$mn:00001E66                 mov     esp, ebp
.text$mn:00001E68                 pop     ebp
.text$mn:00001E69                 retn
.text$mn:00001E69 ??$_Debug_range@PBUTreeStateNode@@@std@@YAXPBUTreeStateNode@@0PB_WI@Z endp
.text$mn:00001E69
.text$mn:00001E69 ; ---------------------------------------------------------------------------
.text$mn:00001E6A                 align 4
.text$mn:00001E6A _text$mn        ends
.text$mn:00001E6A
.text$mn:00001E6C ; ===========================================================================
.text$mn:00001E6C
.text$mn:00001E6C ; Segment type: Pure code
.text$mn:00001E6C ; Segment permissions: Read/Execute
.text$mn:00001E6C _text$mn        segment para public 'CODE' use32
.text$mn:00001E6C                 assume cs:_text$mn
.text$mn:00001E6C                 ;org 1E6Ch
.text$mn:00001E6C ; COMDAT (pick any)
.text$mn:00001E6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E6C
.text$mn:00001E6C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E6C
.text$mn:00001E6C ; Attributes: bp-based frame
.text$mn:00001E6C
.text$mn:00001E6C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>>>(struct TreeStateNode *, struct TreeStateNode *, struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>> &)
.text$mn:00001E6C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAXPAUTreeStateNode@@0AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z
.text$mn:00001E6C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAXPAUTreeStateNode@@0AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z proc near
.text$mn:00001E6C                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Destroy(TreeStateNode *,TreeStateNode *)+21p
.text$mn:00001E6C
.text$mn:00001E6C var_1           = byte ptr -1
.text$mn:00001E6C arg_0           = dword ptr  8
.text$mn:00001E6C arg_4           = dword ptr  0Ch
.text$mn:00001E6C arg_8           = dword ptr  10h
.text$mn:00001E6C
.text$mn:00001E6C                 push    ebp
.text$mn:00001E6D                 mov     ebp, esp
.text$mn:00001E6F                 push    ecx
.text$mn:00001E70                 mov     eax, [ebp+arg_4]
.text$mn:00001E73                 push    eax
.text$mn:00001E74                 mov     ecx, [ebp+arg_0]
.text$mn:00001E77                 push    ecx
.text$mn:00001E78                 call    ??$_Ptr_cat@UTreeStateNode@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUTreeStateNode@@0@Z ; std::_Ptr_cat<TreeStateNode,TreeStateNode>(TreeStateNode *,TreeStateNode *)
.text$mn:00001E7D                 add     esp, 8
.text$mn:00001E80                 mov     [ebp+var_1], al
.text$mn:00001E83                 movzx   edx, [ebp+var_1]
.text$mn:00001E87                 push    edx
.text$mn:00001E88                 mov     eax, [ebp+arg_8]
.text$mn:00001E8B                 push    eax
.text$mn:00001E8C                 mov     ecx, [ebp+arg_4]
.text$mn:00001E8F                 push    ecx
.text$mn:00001E90                 mov     edx, [ebp+arg_0]
.text$mn:00001E93                 push    edx
.text$mn:00001E94                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAXPAUTreeStateNode@@0AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00001E99                 add     esp, 10h
.text$mn:00001E9C                 mov     esp, ebp
.text$mn:00001E9E                 pop     ebp
.text$mn:00001E9F                 retn
.text$mn:00001E9F ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAXPAUTreeStateNode@@0AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z endp
.text$mn:00001E9F
.text$mn:00001E9F _text$mn        ends
.text$mn:00001E9F
.text$mn:00001EA0 ; ===========================================================================
.text$mn:00001EA0
.text$mn:00001EA0 ; Segment type: Pure code
.text$mn:00001EA0 ; Segment permissions: Read/Execute
.text$mn:00001EA0 _text$mn        segment para public 'CODE' use32
.text$mn:00001EA0                 assume cs:_text$mn
.text$mn:00001EA0                 ;org 1EA0h
.text$mn:00001EA0 ; COMDAT (pick any)
.text$mn:00001EA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EA0
.text$mn:00001EA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EA0
.text$mn:00001EA0 ; Attributes: bp-based frame
.text$mn:00001EA0
.text$mn:00001EA0 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>>>(struct TreeStateNode *, struct TreeStateNode *, struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00001EA0                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAXPAUTreeStateNode@@0AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00001EA0 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAXPAUTreeStateNode@@0AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00001EA0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+28p
.text$mn:00001EA0
.text$mn:00001EA0 arg_0           = dword ptr  8
.text$mn:00001EA0 arg_4           = dword ptr  0Ch
.text$mn:00001EA0 arg_8           = dword ptr  10h
.text$mn:00001EA0
.text$mn:00001EA0                 push    ebp
.text$mn:00001EA1                 mov     ebp, esp
.text$mn:00001EA3                 jmp     short loc_1EAE
.text$mn:00001EA5 ; ---------------------------------------------------------------------------
.text$mn:00001EA5
.text$mn:00001EA5 loc_1EA5:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00001EA5                 mov     eax, [ebp+arg_0]
.text$mn:00001EA8                 add     eax, 4Ch ; 'L'
.text$mn:00001EAB                 mov     [ebp+arg_0], eax
.text$mn:00001EAE
.text$mn:00001EAE loc_1EAE:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00001EAE                 mov     ecx, [ebp+arg_0]
.text$mn:00001EB1                 cmp     ecx, [ebp+arg_4]
.text$mn:00001EB4                 jz      short loc_1EC4
.text$mn:00001EB6                 mov     edx, [ebp+arg_0]
.text$mn:00001EB9                 push    edx
.text$mn:00001EBA                 mov     ecx, [ebp+arg_8]
.text$mn:00001EBD                 call    ??$destroy@UTreeStateNode@@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@@Z ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::destroy<TreeStateNode>(TreeStateNode *)
.text$mn:00001EC2                 jmp     short loc_1EA5
.text$mn:00001EC4 ; ---------------------------------------------------------------------------
.text$mn:00001EC4
.text$mn:00001EC4 loc_1EC4:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:00001EC4                 pop     ebp
.text$mn:00001EC5                 retn
.text$mn:00001EC5 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAXPAUTreeStateNode@@0AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00001EC5
.text$mn:00001EC5 ; ---------------------------------------------------------------------------
.text$mn:00001EC6                 align 4
.text$mn:00001EC6 _text$mn        ends
.text$mn:00001EC6
.text$mn:00001EC8 ; ===========================================================================
.text$mn:00001EC8
.text$mn:00001EC8 ; Segment type: Pure code
.text$mn:00001EC8 ; Segment permissions: Read/Execute
.text$mn:00001EC8 _text$mn        segment para public 'CODE' use32
.text$mn:00001EC8                 assume cs:_text$mn
.text$mn:00001EC8                 ;org 1EC8h
.text$mn:00001EC8 ; COMDAT (pick any)
.text$mn:00001EC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EC8
.text$mn:00001EC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EC8
.text$mn:00001EC8 ; Attributes: bp-based frame
.text$mn:00001EC8
.text$mn:00001EC8 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct TreeStateNode *>(struct TreeStateNode * const &)
.text$mn:00001EC8                 public ??$_Iter_cat@PAUTreeStateNode@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTreeStateNode@@@Z
.text$mn:00001EC8 ??$_Iter_cat@PAUTreeStateNode@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTreeStateNode@@@Z proc near
.text$mn:00001EC8                                         ; CODE XREF: std::_Debug_range<TreeStateNode *>(TreeStateNode *,TreeStateNode *,wchar_t const *,uint)+Cp
.text$mn:00001EC8
.text$mn:00001EC8 var_1           = byte ptr -1
.text$mn:00001EC8 arg_0           = dword ptr  8
.text$mn:00001EC8
.text$mn:00001EC8                 push    ebp
.text$mn:00001EC9                 mov     ebp, esp
.text$mn:00001ECB                 push    ecx
.text$mn:00001ECC                 mov     eax, [ebp+arg_0]
.text$mn:00001ECF                 mov     cl, [ebp+var_1]
.text$mn:00001ED2                 mov     [eax], cl
.text$mn:00001ED4                 mov     eax, [ebp+arg_0]
.text$mn:00001ED7                 mov     esp, ebp
.text$mn:00001ED9                 pop     ebp
.text$mn:00001EDA                 retn
.text$mn:00001EDA ??$_Iter_cat@PAUTreeStateNode@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTreeStateNode@@@Z endp
.text$mn:00001EDA
.text$mn:00001EDA ; ---------------------------------------------------------------------------
.text$mn:00001EDB                 align 4
.text$mn:00001EDB _text$mn        ends
.text$mn:00001EDB
.text$mn:00001EDC ; ===========================================================================
.text$mn:00001EDC
.text$mn:00001EDC ; Segment type: Pure code
.text$mn:00001EDC ; Segment permissions: Read/Execute
.text$mn:00001EDC _text$mn        segment para public 'CODE' use32
.text$mn:00001EDC                 assume cs:_text$mn
.text$mn:00001EDC                 ;org 1EDCh
.text$mn:00001EDC ; COMDAT (pick any)
.text$mn:00001EDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EDC
.text$mn:00001EDC ; =============== S U B R O U T I N E =======================================
.text$mn:00001EDC
.text$mn:00001EDC ; Attributes: bp-based frame
.text$mn:00001EDC
.text$mn:00001EDC ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct TreeStateNode const *>(struct TreeStateNode const * const &)
.text$mn:00001EDC                 public ??$_Iter_cat@PBUTreeStateNode@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUTreeStateNode@@@Z
.text$mn:00001EDC ??$_Iter_cat@PBUTreeStateNode@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUTreeStateNode@@@Z proc near
.text$mn:00001EDC                                         ; CODE XREF: std::_Debug_range<TreeStateNode const *>(TreeStateNode const *,TreeStateNode const *,wchar_t const *,uint)+Cp
.text$mn:00001EDC
.text$mn:00001EDC var_1           = byte ptr -1
.text$mn:00001EDC arg_0           = dword ptr  8
.text$mn:00001EDC
.text$mn:00001EDC                 push    ebp
.text$mn:00001EDD                 mov     ebp, esp
.text$mn:00001EDF                 push    ecx
.text$mn:00001EE0                 mov     eax, [ebp+arg_0]
.text$mn:00001EE3                 mov     cl, [ebp+var_1]
.text$mn:00001EE6                 mov     [eax], cl
.text$mn:00001EE8                 mov     eax, [ebp+arg_0]
.text$mn:00001EEB                 mov     esp, ebp
.text$mn:00001EED                 pop     ebp
.text$mn:00001EEE                 retn
.text$mn:00001EEE ??$_Iter_cat@PBUTreeStateNode@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUTreeStateNode@@@Z endp
.text$mn:00001EEE
.text$mn:00001EEE ; ---------------------------------------------------------------------------
.text$mn:00001EEF                 align 10h
.text$mn:00001EEF _text$mn        ends
.text$mn:00001EEF
.text$mn:00001EF0 ; ===========================================================================
.text$mn:00001EF0
.text$mn:00001EF0 ; Segment type: Pure code
.text$mn:00001EF0 ; Segment permissions: Read/Execute
.text$mn:00001EF0 _text$mn        segment para public 'CODE' use32
.text$mn:00001EF0                 assume cs:_text$mn
.text$mn:00001EF0                 ;org 1EF0h
.text$mn:00001EF0 ; COMDAT (pick any)
.text$mn:00001EF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EF0
.text$mn:00001EF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EF0
.text$mn:00001EF0 ; Attributes: bp-based frame
.text$mn:00001EF0
.text$mn:00001EF0 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct TreeStateNode, struct TreeStateNode>(struct TreeStateNode *, struct TreeStateNode *)
.text$mn:00001EF0                 public ??$_Ptr_cat@UTreeStateNode@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUTreeStateNode@@0@Z
.text$mn:00001EF0 ??$_Ptr_cat@UTreeStateNode@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUTreeStateNode@@0@Z proc near
.text$mn:00001EF0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+Cp
.text$mn:00001EF0                                         ; std::_Uninit_move<TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+Cp
.text$mn:00001EF0
.text$mn:00001EF0 var_1           = byte ptr -1
.text$mn:00001EF0
.text$mn:00001EF0                 push    ebp
.text$mn:00001EF1                 mov     ebp, esp
.text$mn:00001EF3                 push    ecx
.text$mn:00001EF4                 mov     al, [ebp+var_1]
.text$mn:00001EF7                 mov     esp, ebp
.text$mn:00001EF9                 pop     ebp
.text$mn:00001EFA                 retn
.text$mn:00001EFA ??$_Ptr_cat@UTreeStateNode@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUTreeStateNode@@0@Z endp
.text$mn:00001EFA
.text$mn:00001EFA ; ---------------------------------------------------------------------------
.text$mn:00001EFB                 align 4
.text$mn:00001EFB _text$mn        ends
.text$mn:00001EFB
.text$mn:00001EFC ; ===========================================================================
.text$mn:00001EFC
.text$mn:00001EFC ; Segment type: Pure code
.text$mn:00001EFC ; Segment permissions: Read/Execute
.text$mn:00001EFC _text$mn        segment para public 'CODE' use32
.text$mn:00001EFC                 assume cs:_text$mn
.text$mn:00001EFC                 ;org 1EFCh
.text$mn:00001EFC ; COMDAT (pick any)
.text$mn:00001EFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EFC
.text$mn:00001EFC ; =============== S U B R O U T I N E =======================================
.text$mn:00001EFC
.text$mn:00001EFC ; Attributes: bp-based frame
.text$mn:00001EFC
.text$mn:00001EFC ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct TreeStateNode, struct TreeStateNode>(struct TreeStateNode const *, struct TreeStateNode *)
.text$mn:00001EFC                 public ??$_Ptr_cat@UTreeStateNode@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUTreeStateNode@@PAU2@@Z
.text$mn:00001EFC ??$_Ptr_cat@UTreeStateNode@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUTreeStateNode@@PAU2@@Z proc near
.text$mn:00001EFC                                         ; CODE XREF: std::_Uninit_copy<TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode const *,TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+Cp
.text$mn:00001EFC
.text$mn:00001EFC var_1           = byte ptr -1
.text$mn:00001EFC
.text$mn:00001EFC                 push    ebp
.text$mn:00001EFD                 mov     ebp, esp
.text$mn:00001EFF                 push    ecx
.text$mn:00001F00                 mov     al, [ebp+var_1]
.text$mn:00001F03                 mov     esp, ebp
.text$mn:00001F05                 pop     ebp
.text$mn:00001F06                 retn
.text$mn:00001F06 ??$_Ptr_cat@UTreeStateNode@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUTreeStateNode@@PAU2@@Z endp
.text$mn:00001F06
.text$mn:00001F06 ; ---------------------------------------------------------------------------
.text$mn:00001F07                 align 4
.text$mn:00001F07 _text$mn        ends
.text$mn:00001F07
.text$mn:00001F08 ; ===========================================================================
.text$mn:00001F08
.text$mn:00001F08 ; Segment type: Pure code
.text$mn:00001F08 ; Segment permissions: Read/Execute
.text$mn:00001F08 _text$mn        segment para public 'CODE' use32
.text$mn:00001F08                 assume cs:_text$mn
.text$mn:00001F08                 ;org 1F08h
.text$mn:00001F08 ; COMDAT (pick any)
.text$mn:00001F08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F08
.text$mn:00001F08 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F08
.text$mn:00001F08 ; Attributes: bp-based frame
.text$mn:00001F08
.text$mn:00001F08 ; struct TreeStateNode * & __cdecl std::_Rechecked<struct TreeStateNode *, struct TreeStateNode *>(struct TreeStateNode * &, struct TreeStateNode *)
.text$mn:00001F08                 public ??$_Rechecked@PAUTreeStateNode@@PAU1@@std@@YAAAPAUTreeStateNode@@AAPAU1@PAU1@@Z
.text$mn:00001F08 ??$_Rechecked@PAUTreeStateNode@@PAU1@@std@@YAAAPAUTreeStateNode@@AAPAU1@PAU1@@Z proc near
.text$mn:00001F08                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+B2p
.text$mn:00001F08                                         ; std::_Uninitialized_move<TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+3Bp
.text$mn:00001F08
.text$mn:00001F08 arg_0           = dword ptr  8
.text$mn:00001F08 arg_4           = dword ptr  0Ch
.text$mn:00001F08
.text$mn:00001F08                 push    ebp
.text$mn:00001F09                 mov     ebp, esp
.text$mn:00001F0B                 mov     eax, [ebp+arg_0]
.text$mn:00001F0E                 mov     ecx, [ebp+arg_4]
.text$mn:00001F11                 mov     [eax], ecx
.text$mn:00001F13                 mov     eax, [ebp+arg_0]
.text$mn:00001F16                 pop     ebp
.text$mn:00001F17                 retn
.text$mn:00001F17 ??$_Rechecked@PAUTreeStateNode@@PAU1@@std@@YAAAPAUTreeStateNode@@AAPAU1@PAU1@@Z endp
.text$mn:00001F17
.text$mn:00001F17 _text$mn        ends
.text$mn:00001F17
.text$mn:00001F18 ; ===========================================================================
.text$mn:00001F18
.text$mn:00001F18 ; Segment type: Pure code
.text$mn:00001F18 ; Segment permissions: Read/Execute
.text$mn:00001F18 _text$mn        segment para public 'CODE' use32
.text$mn:00001F18                 assume cs:_text$mn
.text$mn:00001F18                 ;org 1F18h
.text$mn:00001F18 ; COMDAT (pick any)
.text$mn:00001F18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F18
.text$mn:00001F18 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F18
.text$mn:00001F18 ; Attributes: bp-based frame
.text$mn:00001F18
.text$mn:00001F18 ; protected: struct TreeStateNode * __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::_Ucopy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>>, struct TreeStateNode *)
.text$mn:00001F18                 public ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z
.text$mn:00001F18 ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z proc near
.text$mn:00001F18                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(std::vector<TreeStateNode,std::allocator<TreeStateNode>> const &)+C0p
.text$mn:00001F18
.text$mn:00001F18 var_34          = dword ptr -34h
.text$mn:00001F18 var_30          = dword ptr -30h
.text$mn:00001F18 var_2C          = dword ptr -2Ch
.text$mn:00001F18 var_28          = dword ptr -28h
.text$mn:00001F18 var_24          = dword ptr -24h
.text$mn:00001F18 var_20          = dword ptr -20h
.text$mn:00001F18 var_1C          = dword ptr -1Ch
.text$mn:00001F18 var_18          = dword ptr -18h
.text$mn:00001F18 var_14          = dword ptr -14h
.text$mn:00001F18 var_D           = byte ptr -0Dh
.text$mn:00001F18 var_C           = dword ptr -0Ch
.text$mn:00001F18 var_4           = dword ptr -4
.text$mn:00001F18 arg_0           = byte ptr  8
.text$mn:00001F18 arg_C           = byte ptr  14h
.text$mn:00001F18 arg_18          = dword ptr  20h
.text$mn:00001F18
.text$mn:00001F18                 push    ebp
.text$mn:00001F19                 mov     ebp, esp
.text$mn:00001F1B                 push    0FFFFFFFFh
.text$mn:00001F1D                 push    offset __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z
.text$mn:00001F22                 mov     eax, large fs:0
.text$mn:00001F28                 push    eax
.text$mn:00001F29                 sub     esp, 28h
.text$mn:00001F2C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001F31                 xor     eax, ebp
.text$mn:00001F33                 push    eax
.text$mn:00001F34                 lea     eax, [ebp+var_C]
.text$mn:00001F37                 mov     large fs:0, eax
.text$mn:00001F3D                 mov     [ebp+var_14], ecx
.text$mn:00001F40                 mov     [ebp+var_4], 1
.text$mn:00001F47                 lea     eax, [ebp+var_D]
.text$mn:00001F4A                 push    eax
.text$mn:00001F4B                 mov     ecx, [ebp+var_14]
.text$mn:00001F4E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Getal(void)
.text$mn:00001F53                 lea     ecx, [ebp+var_D]
.text$mn:00001F56                 push    ecx
.text$mn:00001F57                 mov     edx, [ebp+arg_18]
.text$mn:00001F5A                 push    edx
.text$mn:00001F5B                 sub     esp, 0Ch
.text$mn:00001F5E                 mov     ecx, esp
.text$mn:00001F60                 mov     [ebp+var_28], esp
.text$mn:00001F63                 lea     eax, [ebp+arg_C]
.text$mn:00001F66                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00001F67                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>> const &)
.text$mn:00001F6C                 mov     [ebp+var_18], eax
.text$mn:00001F6F                 mov     ecx, [ebp+var_18]
.text$mn:00001F72                 mov     [ebp+var_2C], ecx
.text$mn:00001F75                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001F79                 sub     esp, 0Ch
.text$mn:00001F7C                 mov     ecx, esp
.text$mn:00001F7E                 mov     [ebp+var_30], esp
.text$mn:00001F81                 lea     edx, [ebp+arg_0]
.text$mn:00001F84                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00001F85                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>> const &)
.text$mn:00001F8A                 mov     [ebp+var_1C], eax
.text$mn:00001F8D                 mov     eax, [ebp+var_1C]
.text$mn:00001F90                 mov     [ebp+var_34], eax
.text$mn:00001F93                 mov     byte ptr [ebp+var_4], 3
.text$mn:00001F97                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001F9B                 call    ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)
.text$mn:00001FA0                 add     esp, 20h
.text$mn:00001FA3                 mov     [ebp+var_20], eax
.text$mn:00001FA6                 mov     ecx, [ebp+var_20]
.text$mn:00001FA9                 mov     [ebp+var_24], ecx
.text$mn:00001FAC                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001FB0                 lea     ecx, [ebp+arg_0]
.text$mn:00001FB3                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$mn:00001FB8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001FBF                 lea     ecx, [ebp+arg_C]
.text$mn:00001FC2                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$mn:00001FC7                 mov     eax, [ebp+var_24]
.text$mn:00001FCA                 mov     ecx, [ebp+var_C]
.text$mn:00001FCD                 mov     large fs:0, ecx
.text$mn:00001FD4                 pop     ecx
.text$mn:00001FD5                 mov     esp, ebp
.text$mn:00001FD7                 pop     ebp
.text$mn:00001FD8                 retn    1Ch
.text$mn:00001FD8 ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z endp
.text$mn:00001FD8
.text$mn:00001FD8 ; ---------------------------------------------------------------------------
.text$mn:00001FDB                 align 4
.text$mn:00001FDB _text$mn        ends
.text$mn:00001FDB
.text$x:00001FDC ; ===========================================================================
.text$x:00001FDC
.text$x:00001FDC ; Segment type: Pure code
.text$x:00001FDC ; Segment permissions: Read/Execute
.text$x:00001FDC _text$x         segment para public 'CODE' use32
.text$x:00001FDC                 assume cs:_text$x
.text$x:00001FDC                 ;org 1FDCh
.text$x:00001FDC ; COMDAT (pick associative to section at 1F18)
.text$x:00001FDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001FDC
.text$x:00001FDC ; =============== S U B R O U T I N E =======================================
.text$x:00001FDC
.text$x:00001FDC
.text$x:00001FDC __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z$0 proc near
.text$x:00001FDC                                         ; DATA XREF: .xdata$x:00007968o
.text$x:00001FDC                 lea     ecx, [ebp+14h]
.text$x:00001FDF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$x:00001FDF __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z$0 endp
.text$x:00001FDF
.text$x:00001FE4
.text$x:00001FE4 ; =============== S U B R O U T I N E =======================================
.text$x:00001FE4
.text$x:00001FE4
.text$x:00001FE4 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z$1 proc near
.text$x:00001FE4                                         ; DATA XREF: .xdata$x:00007970o
.text$x:00001FE4                 lea     ecx, [ebp+8]
.text$x:00001FE7                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$x:00001FE7 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z$1 endp
.text$x:00001FE7
.text$x:00001FEC
.text$x:00001FEC ; =============== S U B R O U T I N E =======================================
.text$x:00001FEC
.text$x:00001FEC
.text$x:00001FEC __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z$2 proc near
.text$x:00001FEC                                         ; DATA XREF: .xdata$x:00007978o
.text$x:00001FEC                 mov     ecx, [ebp-28h]
.text$x:00001FEF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$x:00001FEF __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z$2 endp
.text$x:00001FEF
.text$x:00001FF4
.text$x:00001FF4 ; =============== S U B R O U T I N E =======================================
.text$x:00001FF4
.text$x:00001FF4
.text$x:00001FF4 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z$3 proc near
.text$x:00001FF4                                         ; DATA XREF: .xdata$x:00007980o
.text$x:00001FF4                 mov     ecx, [ebp-30h]
.text$x:00001FF7                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$x:00001FF7 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z$3 endp
.text$x:00001FF7
.text$x:00001FFC
.text$x:00001FFC ; =============== S U B R O U T I N E =======================================
.text$x:00001FFC
.text$x:00001FFC
.text$x:00001FFC __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z proc near
.text$x:00001FFC                                         ; DATA XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *)+5o
.text$x:00001FFC
.text$x:00001FFC arg_4           = dword ptr  8
.text$x:00001FFC
.text$x:00001FFC                 mov     edx, [esp+arg_4]
.text$x:00002000                 lea     eax, [edx+0Ch]
.text$x:00002003                 mov     ecx, [edx-2Ch]
.text$x:00002006                 xor     ecx, eax
.text$x:00002008                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000200D                 mov     eax, offset __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z
.text$x:00002012                 jmp     ___CxxFrameHandler3
.text$x:00002012 __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z endp
.text$x:00002012
.text$x:00002012 ; ---------------------------------------------------------------------------
.text$x:00002017                 align 4
.text$x:00002017 _text$x         ends
.text$x:00002017
.text$mn:00002018 ; ===========================================================================
.text$mn:00002018
.text$mn:00002018 ; Segment type: Pure code
.text$mn:00002018 ; Segment permissions: Read/Execute
.text$mn:00002018 _text$mn        segment para public 'CODE' use32
.text$mn:00002018                 assume cs:_text$mn
.text$mn:00002018                 ;org 2018h
.text$mn:00002018 ; COMDAT (pick any)
.text$mn:00002018                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002018
.text$mn:00002018 ; =============== S U B R O U T I N E =======================================
.text$mn:00002018
.text$mn:00002018 ; Attributes: bp-based frame
.text$mn:00002018
.text$mn:00002018 ; protected: struct TreeStateNode * __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::_Umove<struct TreeStateNode *>(struct TreeStateNode *, struct TreeStateNode *, struct TreeStateNode *)
.text$mn:00002018                 public ??$_Umove@PAUTreeStateNode@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@PAU2@00@Z
.text$mn:00002018 ??$_Umove@PAUTreeStateNode@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@PAU2@00@Z proc near
.text$mn:00002018                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reallocate(uint)+65p
.text$mn:00002018
.text$mn:00002018 var_8           = dword ptr -8
.text$mn:00002018 var_1           = byte ptr -1
.text$mn:00002018 arg_0           = dword ptr  8
.text$mn:00002018 arg_4           = dword ptr  0Ch
.text$mn:00002018 arg_8           = dword ptr  10h
.text$mn:00002018
.text$mn:00002018                 push    ebp
.text$mn:00002019                 mov     ebp, esp
.text$mn:0000201B                 sub     esp, 8
.text$mn:0000201E                 mov     [ebp+var_8], ecx
.text$mn:00002021                 lea     eax, [ebp+var_1]
.text$mn:00002024                 push    eax
.text$mn:00002025                 mov     ecx, [ebp+var_8]
.text$mn:00002028                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Getal(void)
.text$mn:0000202D                 lea     ecx, [ebp+var_1]
.text$mn:00002030                 push    ecx
.text$mn:00002031                 mov     edx, [ebp+arg_8]
.text$mn:00002034                 push    edx
.text$mn:00002035                 mov     eax, [ebp+arg_4]
.text$mn:00002038                 push    eax
.text$mn:00002039                 mov     ecx, [ebp+arg_0]
.text$mn:0000203C                 push    ecx
.text$mn:0000203D                 call    ??$_Uninitialized_move@PAUTreeStateNode@@PAU1@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z ; std::_Uninitialized_move<TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)
.text$mn:00002042                 add     esp, 10h
.text$mn:00002045                 mov     esp, ebp
.text$mn:00002047                 pop     ebp
.text$mn:00002048                 retn    0Ch
.text$mn:00002048 ??$_Umove@PAUTreeStateNode@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@PAU2@00@Z endp
.text$mn:00002048
.text$mn:00002048 ; ---------------------------------------------------------------------------
.text$mn:0000204B                 align 4
.text$mn:0000204B _text$mn        ends
.text$mn:0000204B
.text$mn:0000204C ; ===========================================================================
.text$mn:0000204C
.text$mn:0000204C ; Segment type: Pure code
.text$mn:0000204C ; Segment permissions: Read/Execute
.text$mn:0000204C _text$mn        segment para public 'CODE' use32
.text$mn:0000204C                 assume cs:_text$mn
.text$mn:0000204C                 ;org 204Ch
.text$mn:0000204C ; COMDAT (pick any)
.text$mn:0000204C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000204C
.text$mn:0000204C ; =============== S U B R O U T I N E =======================================
.text$mn:0000204C
.text$mn:0000204C ; Attributes: bp-based frame
.text$mn:0000204C
.text$mn:0000204C ; struct TreeStateNode * __cdecl std::_Unchecked<struct TreeStateNode *>(struct TreeStateNode *)
.text$mn:0000204C                 public ??$_Unchecked@PAUTreeStateNode@@@std@@YAPAUTreeStateNode@@PAU1@@Z
.text$mn:0000204C ??$_Unchecked@PAUTreeStateNode@@@std@@YAPAUTreeStateNode@@PAU1@@Z proc near
.text$mn:0000204C                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+34p
.text$mn:0000204C                                         ; std::_Uninitialized_move<TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+Bp ...
.text$mn:0000204C
.text$mn:0000204C arg_0           = dword ptr  8
.text$mn:0000204C
.text$mn:0000204C                 push    ebp
.text$mn:0000204D                 mov     ebp, esp
.text$mn:0000204F                 mov     eax, [ebp+arg_0]
.text$mn:00002052                 pop     ebp
.text$mn:00002053                 retn
.text$mn:00002053 ??$_Unchecked@PAUTreeStateNode@@@std@@YAPAUTreeStateNode@@PAU1@@Z endp
.text$mn:00002053
.text$mn:00002053 _text$mn        ends
.text$mn:00002053
.text$mn:00002054 ; ===========================================================================
.text$mn:00002054
.text$mn:00002054 ; Segment type: Pure code
.text$mn:00002054 ; Segment permissions: Read/Execute
.text$mn:00002054 _text$mn        segment para public 'CODE' use32
.text$mn:00002054                 assume cs:_text$mn
.text$mn:00002054                 ;org 2054h
.text$mn:00002054 ; COMDAT (pick any)
.text$mn:00002054                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002054
.text$mn:00002054 ; =============== S U B R O U T I N E =======================================
.text$mn:00002054
.text$mn:00002054 ; Attributes: bp-based frame
.text$mn:00002054
.text$mn:00002054 ; struct TreeStateNode const * __cdecl std::_Unchecked<class std::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>>)
.text$mn:00002054                 public ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z
.text$mn:00002054 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z proc near
.text$mn:00002054                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+5Fp
.text$mn:00002054                                         ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+90p
.text$mn:00002054
.text$mn:00002054 var_10          = dword ptr -10h
.text$mn:00002054 var_C           = dword ptr -0Ch
.text$mn:00002054 var_4           = dword ptr -4
.text$mn:00002054 arg_0           = byte ptr  8
.text$mn:00002054
.text$mn:00002054                 push    ebp
.text$mn:00002055                 mov     ebp, esp
.text$mn:00002057                 push    0FFFFFFFFh
.text$mn:00002059                 push    offset __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z
.text$mn:0000205E                 mov     eax, large fs:0
.text$mn:00002064                 push    eax
.text$mn:00002065                 push    ecx
.text$mn:00002066                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000206B                 xor     eax, ebp
.text$mn:0000206D                 push    eax
.text$mn:0000206E                 lea     eax, [ebp+var_C]
.text$mn:00002071                 mov     large fs:0, eax
.text$mn:00002077                 mov     [ebp+var_4], 0
.text$mn:0000207E                 lea     ecx, [ebp+arg_0]
.text$mn:00002081                 call    ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QBEPBUTreeStateNode@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::_Unchecked(void)
.text$mn:00002086                 mov     [ebp+var_10], eax
.text$mn:00002089                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002090                 lea     ecx, [ebp+arg_0]
.text$mn:00002093                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$mn:00002098                 mov     eax, [ebp+var_10]
.text$mn:0000209B                 mov     ecx, [ebp+var_C]
.text$mn:0000209E                 mov     large fs:0, ecx
.text$mn:000020A5                 pop     ecx
.text$mn:000020A6                 mov     esp, ebp
.text$mn:000020A8                 pop     ebp
.text$mn:000020A9                 retn
.text$mn:000020A9 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z endp
.text$mn:000020A9
.text$mn:000020A9 ; ---------------------------------------------------------------------------
.text$mn:000020AA                 align 4
.text$mn:000020AA _text$mn        ends
.text$mn:000020AA
.text$x:000020AC ; ===========================================================================
.text$x:000020AC
.text$x:000020AC ; Segment type: Pure code
.text$x:000020AC ; Segment permissions: Read/Execute
.text$x:000020AC _text$x         segment para public 'CODE' use32
.text$x:000020AC                 assume cs:_text$x
.text$x:000020AC                 ;org 20ACh
.text$x:000020AC ; COMDAT (pick associative to section at 2054)
.text$x:000020AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000020AC
.text$x:000020AC ; =============== S U B R O U T I N E =======================================
.text$x:000020AC
.text$x:000020AC
.text$x:000020AC __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z$0 proc near
.text$x:000020AC                                         ; DATA XREF: .xdata$x:000079F0o
.text$x:000020AC                 lea     ecx, [ebp+8]
.text$x:000020AF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$x:000020AF __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z$0 endp
.text$x:000020AF
.text$x:000020B4
.text$x:000020B4 ; =============== S U B R O U T I N E =======================================
.text$x:000020B4
.text$x:000020B4
.text$x:000020B4 __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z proc near
.text$x:000020B4                                         ; DATA XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>)+5o
.text$x:000020B4
.text$x:000020B4 arg_4           = dword ptr  8
.text$x:000020B4
.text$x:000020B4                 mov     edx, [esp+arg_4]
.text$x:000020B8                 lea     eax, [edx+0Ch]
.text$x:000020BB                 mov     ecx, [edx-8]
.text$x:000020BE                 xor     ecx, eax
.text$x:000020C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000020C5                 mov     eax, offset __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z
.text$x:000020CA                 jmp     ___CxxFrameHandler3
.text$x:000020CA __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z endp
.text$x:000020CA
.text$x:000020CA ; ---------------------------------------------------------------------------
.text$x:000020CF                 align 10h
.text$x:000020CF _text$x         ends
.text$x:000020CF
.text$mn:000020D0 ; ===========================================================================
.text$mn:000020D0
.text$mn:000020D0 ; Segment type: Pure code
.text$mn:000020D0 ; Segment permissions: Read/Execute
.text$mn:000020D0 _text$mn        segment para public 'CODE' use32
.text$mn:000020D0                 assume cs:_text$mn
.text$mn:000020D0                 ;org 20D0h
.text$mn:000020D0 ; COMDAT (pick any)
.text$mn:000020D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020D0
.text$mn:000020D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000020D0
.text$mn:000020D0 ; Attributes: bp-based frame
.text$mn:000020D0
.text$mn:000020D0 ; struct TreeStateNode * __cdecl std::_Uninit_copy<struct TreeStateNode const *, struct TreeStateNode *, struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>>>(struct TreeStateNode const *, struct TreeStateNode const *, struct TreeStateNode *, struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>> &)
.text$mn:000020D0                 public ??$_Uninit_copy@PBUTreeStateNode@@PAU1@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z
.text$mn:000020D0 ??$_Uninit_copy@PBUTreeStateNode@@PAU1@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z proc near
.text$mn:000020D0                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+9Fp
.text$mn:000020D0
.text$mn:000020D0 var_1           = byte ptr -1
.text$mn:000020D0 arg_0           = dword ptr  8
.text$mn:000020D0 arg_4           = dword ptr  0Ch
.text$mn:000020D0 arg_8           = dword ptr  10h
.text$mn:000020D0 arg_C           = dword ptr  14h
.text$mn:000020D0
.text$mn:000020D0                 push    ebp
.text$mn:000020D1                 mov     ebp, esp
.text$mn:000020D3                 push    ecx
.text$mn:000020D4                 mov     eax, [ebp+arg_8]
.text$mn:000020D7                 push    eax
.text$mn:000020D8                 mov     ecx, [ebp+arg_0]
.text$mn:000020DB                 push    ecx
.text$mn:000020DC                 call    ??$_Ptr_cat@UTreeStateNode@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUTreeStateNode@@PAU2@@Z ; std::_Ptr_cat<TreeStateNode,TreeStateNode>(TreeStateNode const *,TreeStateNode *)
.text$mn:000020E1                 add     esp, 8
.text$mn:000020E4                 mov     [ebp+var_1], al
.text$mn:000020E7                 movzx   edx, [ebp+var_1]
.text$mn:000020EB                 push    edx
.text$mn:000020EC                 mov     eax, [ebp+arg_C]
.text$mn:000020EF                 push    eax
.text$mn:000020F0                 mov     ecx, [ebp+arg_8]
.text$mn:000020F3                 push    ecx
.text$mn:000020F4                 mov     edx, [ebp+arg_4]
.text$mn:000020F7                 push    edx
.text$mn:000020F8                 mov     eax, [ebp+arg_0]
.text$mn:000020FB                 push    eax
.text$mn:000020FC                 call    ??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<TreeStateNode const *,TreeStateNode *,std::allocator<TreeStateNode>>(TreeStateNode const *,TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002101                 add     esp, 14h
.text$mn:00002104                 mov     esp, ebp
.text$mn:00002106                 pop     ebp
.text$mn:00002107                 retn
.text$mn:00002107 ??$_Uninit_copy@PBUTreeStateNode@@PAU1@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z endp
.text$mn:00002107
.text$mn:00002107 _text$mn        ends
.text$mn:00002107
.text$mn:00002108 ; ===========================================================================
.text$mn:00002108
.text$mn:00002108 ; Segment type: Pure code
.text$mn:00002108 ; Segment permissions: Read/Execute
.text$mn:00002108 _text$mn        segment para public 'CODE' use32
.text$mn:00002108                 assume cs:_text$mn
.text$mn:00002108                 ;org 2108h
.text$mn:00002108 ; COMDAT (pick any)
.text$mn:00002108                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002108
.text$mn:00002108 ; =============== S U B R O U T I N E =======================================
.text$mn:00002108
.text$mn:00002108 ; Attributes: bp-based frame
.text$mn:00002108
.text$mn:00002108 ; struct TreeStateNode * __cdecl std::_Uninit_copy<struct TreeStateNode const *, struct TreeStateNode *, class std::allocator<struct TreeStateNode>>(struct TreeStateNode const *, struct TreeStateNode const *, struct TreeStateNode *, struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002108                 public ??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002108 ??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002108                                         ; CODE XREF: std::_Uninit_copy<TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode const *,TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+2Cp
.text$mn:00002108
.text$mn:00002108 var_14          = dword ptr -14h
.text$mn:00002108 var_10          = dword ptr -10h
.text$mn:00002108 var_C           = dword ptr -0Ch
.text$mn:00002108 var_4           = dword ptr -4
.text$mn:00002108 arg_0           = dword ptr  8
.text$mn:00002108 arg_4           = dword ptr  0Ch
.text$mn:00002108 arg_8           = dword ptr  10h
.text$mn:00002108 arg_C           = dword ptr  14h
.text$mn:00002108
.text$mn:00002108 ; FUNCTION CHUNK AT .text$mn:000021CF SIZE 00000009 BYTES
.text$mn:00002108 ; FUNCTION CHUNK AT .text$mn:000021DF SIZE 00000015 BYTES
.text$mn:00002108
.text$mn:00002108                 push    ebp
.text$mn:00002109                 mov     ebp, esp
.text$mn:0000210B                 push    0FFFFFFFFh
.text$mn:0000210D                 push    offset __ehhandler$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002112                 mov     eax, large fs:0
.text$mn:00002118                 push    eax
.text$mn:00002119                 push    ecx
.text$mn:0000211A                 push    ecx
.text$mn:0000211B                 push    ebx
.text$mn:0000211C                 push    esi
.text$mn:0000211D                 push    edi
.text$mn:0000211E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002123                 xor     eax, ebp
.text$mn:00002125                 push    eax
.text$mn:00002126                 lea     eax, [ebp+var_C]
.text$mn:00002129                 mov     large fs:0, eax
.text$mn:0000212F                 mov     [ebp+var_10], esp
.text$mn:00002132                 push    174h            ; unsigned int
.text$mn:00002137                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000213C                 mov     eax, [ebp+arg_4]
.text$mn:0000213F                 push    eax             ; int
.text$mn:00002140                 mov     ecx, [ebp+arg_0]
.text$mn:00002143                 push    ecx             ; int
.text$mn:00002144                 call    ??$_Debug_range@PBUTreeStateNode@@@std@@YAXPBUTreeStateNode@@0PB_WI@Z ; std::_Debug_range<TreeStateNode const *>(TreeStateNode const *,TreeStateNode const *,wchar_t const *,uint)
.text$mn:00002149                 add     esp, 10h
.text$mn:0000214C                 push    175h            ; unsigned int
.text$mn:00002151                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002156                 mov     edx, [ebp+arg_8]
.text$mn:00002159                 push    edx             ; int
.text$mn:0000215A                 call    ??$_Debug_pointer@UTreeStateNode@@@std@@YAXPAUTreeStateNode@@PB_WI@Z ; std::_Debug_pointer<TreeStateNode>(TreeStateNode *,wchar_t const *,uint)
.text$mn:0000215F                 add     esp, 0Ch
.text$mn:00002162                 mov     eax, [ebp+arg_8]
.text$mn:00002165                 mov     [ebp+var_14], eax
.text$mn:00002168                 mov     [ebp+var_4], 0
.text$mn:0000216F                 jmp     short loc_2183
.text$mn:00002171 ; ---------------------------------------------------------------------------
.text$mn:00002171
.text$mn:00002171 loc_2171:                               ; CODE XREF: std::_Uninit_copy<TreeStateNode const *,TreeStateNode *,std::allocator<TreeStateNode>>(TreeStateNode const *,TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:00002171                 mov     ecx, [ebp+arg_8]
.text$mn:00002174                 add     ecx, 4Ch ; 'L'
.text$mn:00002177                 mov     [ebp+arg_8], ecx
.text$mn:0000217A                 mov     edx, [ebp+arg_0]
.text$mn:0000217D                 add     edx, 4Ch ; 'L'
.text$mn:00002180                 mov     [ebp+arg_0], edx
.text$mn:00002183
.text$mn:00002183 loc_2183:                               ; CODE XREF: std::_Uninit_copy<TreeStateNode const *,TreeStateNode *,std::allocator<TreeStateNode>>(TreeStateNode const *,TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:00002183                 mov     eax, [ebp+arg_0]
.text$mn:00002186                 cmp     eax, [ebp+arg_4]
.text$mn:00002189                 jz      short loc_219D
.text$mn:0000218B                 mov     ecx, [ebp+arg_0]
.text$mn:0000218E                 push    ecx
.text$mn:0000218F                 mov     edx, [ebp+arg_8]
.text$mn:00002192                 push    edx
.text$mn:00002193                 mov     ecx, [ebp+arg_C]
.text$mn:00002196                 call    ??$construct@UTreeStateNode@@ABU1@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::construct<TreeStateNode,TreeStateNode const &>(TreeStateNode *,TreeStateNode const &)
.text$mn:0000219B                 jmp     short loc_2171
.text$mn:0000219D ; ---------------------------------------------------------------------------
.text$mn:0000219D
.text$mn:0000219D loc_219D:                               ; CODE XREF: std::_Uninit_copy<TreeStateNode const *,TreeStateNode *,std::allocator<TreeStateNode>>(TreeStateNode const *,TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:0000219D                 jmp     short loc_21CF
.text$mn:0000219D ??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000219D
.text$mn:0000219F
.text$mn:0000219F ; =============== S U B R O U T I N E =======================================
.text$mn:0000219F
.text$mn:0000219F ; Attributes: noreturn
.text$mn:0000219F
.text$mn:0000219F __catch$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:0000219F                                         ; DATA XREF: .xdata$x:00007A24o
.text$mn:0000219F                 jmp     short loc_21AA
.text$mn:000021A1 ; ---------------------------------------------------------------------------
.text$mn:000021A1
.text$mn:000021A1 loc_21A1:                               ; CODE XREF: __catch$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:000021A1                 mov     eax, [ebp-14h]
.text$mn:000021A4                 add     eax, 4Ch ; 'L'
.text$mn:000021A7                 mov     [ebp-14h], eax
.text$mn:000021AA
.text$mn:000021AA loc_21AA:                               ; CODE XREF: __catch$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:000021AA                 mov     ecx, [ebp-14h]
.text$mn:000021AD                 cmp     ecx, [ebp+10h]
.text$mn:000021B0                 jz      short loc_21C0
.text$mn:000021B2                 mov     edx, [ebp-14h]
.text$mn:000021B5                 push    edx
.text$mn:000021B6                 mov     ecx, [ebp+14h]
.text$mn:000021B9                 call    ??$destroy@UTreeStateNode@@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@@Z ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::destroy<TreeStateNode>(TreeStateNode *)
.text$mn:000021BE                 jmp     short loc_21A1
.text$mn:000021C0 ; ---------------------------------------------------------------------------
.text$mn:000021C0
.text$mn:000021C0 loc_21C0:                               ; CODE XREF: __catch$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:000021C0                 push    0
.text$mn:000021C2                 push    0
.text$mn:000021C4                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000021C4 __catch$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:000021C4
.text$mn:000021C9 ; ---------------------------------------------------------------------------
.text$mn:000021C9                 mov     eax, offset $LN13_0
.text$mn:000021CE                 retn
.text$mn:000021CF ; ---------------------------------------------------------------------------
.text$mn:000021CF ; START OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000021CF
.text$mn:000021CF loc_21CF:                               ; CODE XREF: std::_Uninit_copy<TreeStateNode const *,TreeStateNode *,std::allocator<TreeStateNode>>(TreeStateNode const *,TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag):loc_219Dj
.text$mn:000021CF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000021D6                 jmp     short loc_21DF
.text$mn:000021D6 ; END OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000021D8
.text$mn:000021D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000021D8
.text$mn:000021D8
.text$mn:000021D8 $LN13_0         proc near               ; DATA XREF: .text$mn:000021C9o
.text$mn:000021D8                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000021D8 $LN13_0         endp ; sp-analysis failed
.text$mn:000021D8
.text$mn:000021DF ; START OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000021DF
.text$mn:000021DF loc_21DF:                               ; CODE XREF: std::_Uninit_copy<TreeStateNode const *,TreeStateNode *,std::allocator<TreeStateNode>>(TreeStateNode const *,TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:000021DF                 mov     eax, [ebp+arg_8]
.text$mn:000021E2                 mov     ecx, [ebp+var_C]
.text$mn:000021E5                 mov     large fs:0, ecx
.text$mn:000021EC                 pop     ecx
.text$mn:000021ED                 pop     edi
.text$mn:000021EE                 pop     esi
.text$mn:000021EF                 pop     ebx
.text$mn:000021F0                 mov     esp, ebp
.text$mn:000021F2                 pop     ebp
.text$mn:000021F3                 retn
.text$mn:000021F3 ; END OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000021F3 _text$mn        ends
.text$mn:000021F3
.text$x:000021F4 ; ===========================================================================
.text$x:000021F4
.text$x:000021F4 ; Segment type: Pure code
.text$x:000021F4 ; Segment permissions: Read/Execute
.text$x:000021F4 _text$x         segment para public 'CODE' use32
.text$x:000021F4                 assume cs:_text$x
.text$x:000021F4                 ;org 21F4h
.text$x:000021F4 ; COMDAT (pick associative to section at 2108)
.text$x:000021F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000021F4
.text$x:000021F4 ; =============== S U B R O U T I N E =======================================
.text$x:000021F4
.text$x:000021F4
.text$x:000021F4 __ehhandler$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:000021F4                                         ; DATA XREF: std::_Uninit_copy<TreeStateNode const *,TreeStateNode *,std::allocator<TreeStateNode>>(TreeStateNode const *,TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:000021F4
.text$x:000021F4 arg_4           = dword ptr  8
.text$x:000021F4
.text$x:000021F4                 mov     edx, [esp+arg_4]
.text$x:000021F8                 lea     eax, [edx+0Ch]
.text$x:000021FB                 mov     ecx, [edx-18h]
.text$x:000021FE                 xor     ecx, eax
.text$x:00002200                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002205                 mov     eax, offset __ehfuncinfo$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:0000220A                 jmp     ___CxxFrameHandler3
.text$x:0000220A __ehhandler$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:0000220A
.text$x:0000220A ; ---------------------------------------------------------------------------
.text$x:0000220F                 align 10h
.text$x:0000220F _text$x         ends
.text$x:0000220F
.text$mn:00002210 ; ===========================================================================
.text$mn:00002210
.text$mn:00002210 ; Segment type: Pure code
.text$mn:00002210 ; Segment permissions: Read/Execute
.text$mn:00002210 _text$mn        segment para public 'CODE' use32
.text$mn:00002210                 assume cs:_text$mn
.text$mn:00002210                 ;org 2210h
.text$mn:00002210 ; COMDAT (pick any)
.text$mn:00002210                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002210
.text$mn:00002210 ; =============== S U B R O U T I N E =======================================
.text$mn:00002210
.text$mn:00002210 ; Attributes: bp-based frame
.text$mn:00002210
.text$mn:00002210 ; struct TreeStateNode * __cdecl std::_Uninit_move<struct TreeStateNode *, struct TreeStateNode *, struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>>>(struct TreeStateNode *, struct TreeStateNode *, struct TreeStateNode *, struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>> &)
.text$mn:00002210                 public ??$_Uninit_move@PAUTreeStateNode@@PAU1@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z
.text$mn:00002210 ??$_Uninit_move@PAUTreeStateNode@@PAU1@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z proc near
.text$mn:00002210                                         ; CODE XREF: std::_Uninitialized_move<TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+2Ep
.text$mn:00002210
.text$mn:00002210 var_1           = byte ptr -1
.text$mn:00002210 arg_0           = dword ptr  8
.text$mn:00002210 arg_4           = dword ptr  0Ch
.text$mn:00002210 arg_8           = dword ptr  10h
.text$mn:00002210 arg_C           = dword ptr  14h
.text$mn:00002210
.text$mn:00002210                 push    ebp
.text$mn:00002211                 mov     ebp, esp
.text$mn:00002213                 push    ecx
.text$mn:00002214                 mov     eax, [ebp+arg_8]
.text$mn:00002217                 push    eax
.text$mn:00002218                 mov     ecx, [ebp+arg_0]
.text$mn:0000221B                 push    ecx
.text$mn:0000221C                 call    ??$_Ptr_cat@UTreeStateNode@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUTreeStateNode@@0@Z ; std::_Ptr_cat<TreeStateNode,TreeStateNode>(TreeStateNode *,TreeStateNode *)
.text$mn:00002221                 add     esp, 8
.text$mn:00002224                 mov     [ebp+var_1], al
.text$mn:00002227                 movzx   edx, [ebp+var_1]
.text$mn:0000222B                 push    edx
.text$mn:0000222C                 mov     eax, [ebp+arg_0]
.text$mn:0000222F                 push    eax
.text$mn:00002230                 call    ??$_Val_type@PAUTreeStateNode@@@std@@YAPAUTreeStateNode@@PAU1@@Z ; std::_Val_type<TreeStateNode *>(TreeStateNode *)
.text$mn:00002235                 add     esp, 4
.text$mn:00002238                 push    eax
.text$mn:00002239                 mov     ecx, [ebp+arg_C]
.text$mn:0000223C                 push    ecx
.text$mn:0000223D                 mov     edx, [ebp+arg_8]
.text$mn:00002240                 push    edx
.text$mn:00002241                 mov     eax, [ebp+arg_4]
.text$mn:00002244                 push    eax
.text$mn:00002245                 mov     ecx, [ebp+arg_0]
.text$mn:00002248                 push    ecx
.text$mn:00002249                 call    ??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<TreeStateNode *,TreeStateNode *,std::allocator<TreeStateNode>,TreeStateNode>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,TreeStateNode *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000224E                 add     esp, 18h
.text$mn:00002251                 mov     esp, ebp
.text$mn:00002253                 pop     ebp
.text$mn:00002254                 retn
.text$mn:00002254 ??$_Uninit_move@PAUTreeStateNode@@PAU1@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z endp
.text$mn:00002254
.text$mn:00002254 ; ---------------------------------------------------------------------------
.text$mn:00002255                 align 4
.text$mn:00002255 _text$mn        ends
.text$mn:00002255
.text$mn:00002258 ; ===========================================================================
.text$mn:00002258
.text$mn:00002258 ; Segment type: Pure code
.text$mn:00002258 ; Segment permissions: Read/Execute
.text$mn:00002258 _text$mn        segment para public 'CODE' use32
.text$mn:00002258                 assume cs:_text$mn
.text$mn:00002258                 ;org 2258h
.text$mn:00002258 ; COMDAT (pick any)
.text$mn:00002258                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002258
.text$mn:00002258 ; =============== S U B R O U T I N E =======================================
.text$mn:00002258
.text$mn:00002258 ; Attributes: bp-based frame
.text$mn:00002258
.text$mn:00002258 ; struct TreeStateNode * __cdecl std::_Uninit_move<struct TreeStateNode *, struct TreeStateNode *, class std::allocator<struct TreeStateNode>, struct TreeStateNode>(struct TreeStateNode *, struct TreeStateNode *, struct TreeStateNode *, struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>> &, struct TreeStateNode *, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002258                 public ??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002258 ??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002258                                         ; CODE XREF: std::_Uninit_move<TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+39p
.text$mn:00002258
.text$mn:00002258 var_14          = dword ptr -14h
.text$mn:00002258 var_10          = dword ptr -10h
.text$mn:00002258 var_C           = dword ptr -0Ch
.text$mn:00002258 var_4           = dword ptr -4
.text$mn:00002258 arg_0           = dword ptr  8
.text$mn:00002258 arg_4           = dword ptr  0Ch
.text$mn:00002258 arg_8           = dword ptr  10h
.text$mn:00002258 arg_C           = dword ptr  14h
.text$mn:00002258
.text$mn:00002258 ; FUNCTION CHUNK AT .text$mn:0000231F SIZE 00000009 BYTES
.text$mn:00002258 ; FUNCTION CHUNK AT .text$mn:0000232F SIZE 00000015 BYTES
.text$mn:00002258
.text$mn:00002258                 push    ebp
.text$mn:00002259                 mov     ebp, esp
.text$mn:0000225B                 push    0FFFFFFFFh
.text$mn:0000225D                 push    offset __ehhandler$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002262                 mov     eax, large fs:0
.text$mn:00002268                 push    eax
.text$mn:00002269                 push    ecx
.text$mn:0000226A                 push    ecx
.text$mn:0000226B                 push    ebx
.text$mn:0000226C                 push    esi
.text$mn:0000226D                 push    edi
.text$mn:0000226E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002273                 xor     eax, ebp
.text$mn:00002275                 push    eax
.text$mn:00002276                 lea     eax, [ebp+var_C]
.text$mn:00002279                 mov     large fs:0, eax
.text$mn:0000227F                 mov     [ebp+var_10], esp
.text$mn:00002282                 push    1B6h            ; unsigned int
.text$mn:00002287                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000228C                 mov     eax, [ebp+arg_4]
.text$mn:0000228F                 push    eax             ; int
.text$mn:00002290                 mov     ecx, [ebp+arg_0]
.text$mn:00002293                 push    ecx             ; int
.text$mn:00002294                 call    ??$_Debug_range@PAUTreeStateNode@@@std@@YAXPAUTreeStateNode@@0PB_WI@Z ; std::_Debug_range<TreeStateNode *>(TreeStateNode *,TreeStateNode *,wchar_t const *,uint)
.text$mn:00002299                 add     esp, 10h
.text$mn:0000229C                 push    1B7h            ; unsigned int
.text$mn:000022A1                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000022A6                 mov     edx, [ebp+arg_8]
.text$mn:000022A9                 push    edx             ; int
.text$mn:000022AA                 call    ??$_Debug_pointer@UTreeStateNode@@@std@@YAXPAUTreeStateNode@@PB_WI@Z ; std::_Debug_pointer<TreeStateNode>(TreeStateNode *,wchar_t const *,uint)
.text$mn:000022AF                 add     esp, 0Ch
.text$mn:000022B2                 mov     eax, [ebp+arg_8]
.text$mn:000022B5                 mov     [ebp+var_14], eax
.text$mn:000022B8                 mov     [ebp+var_4], 0
.text$mn:000022BF                 jmp     short loc_22D3
.text$mn:000022C1 ; ---------------------------------------------------------------------------
.text$mn:000022C1
.text$mn:000022C1 loc_22C1:                               ; CODE XREF: std::_Uninit_move<TreeStateNode *,TreeStateNode *,std::allocator<TreeStateNode>,TreeStateNode>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,TreeStateNode *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:000022C1                 mov     ecx, [ebp+arg_8]
.text$mn:000022C4                 add     ecx, 4Ch ; 'L'
.text$mn:000022C7                 mov     [ebp+arg_8], ecx
.text$mn:000022CA                 mov     edx, [ebp+arg_0]
.text$mn:000022CD                 add     edx, 4Ch ; 'L'
.text$mn:000022D0                 mov     [ebp+arg_0], edx
.text$mn:000022D3
.text$mn:000022D3 loc_22D3:                               ; CODE XREF: std::_Uninit_move<TreeStateNode *,TreeStateNode *,std::allocator<TreeStateNode>,TreeStateNode>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,TreeStateNode *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:000022D3                 mov     eax, [ebp+arg_0]
.text$mn:000022D6                 cmp     eax, [ebp+arg_4]
.text$mn:000022D9                 jz      short loc_22ED
.text$mn:000022DB                 mov     ecx, [ebp+arg_0]
.text$mn:000022DE                 push    ecx
.text$mn:000022DF                 mov     edx, [ebp+arg_8]
.text$mn:000022E2                 push    edx
.text$mn:000022E3                 mov     ecx, [ebp+arg_C]
.text$mn:000022E6                 call    ??$construct@UTreeStateNode@@U1@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::construct<TreeStateNode,TreeStateNode>(TreeStateNode *,TreeStateNode &&)
.text$mn:000022EB                 jmp     short loc_22C1
.text$mn:000022ED ; ---------------------------------------------------------------------------
.text$mn:000022ED
.text$mn:000022ED loc_22ED:                               ; CODE XREF: std::_Uninit_move<TreeStateNode *,TreeStateNode *,std::allocator<TreeStateNode>,TreeStateNode>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,TreeStateNode *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:000022ED                 jmp     short loc_231F
.text$mn:000022ED ??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000022ED
.text$mn:000022EF
.text$mn:000022EF ; =============== S U B R O U T I N E =======================================
.text$mn:000022EF
.text$mn:000022EF ; Attributes: noreturn
.text$mn:000022EF
.text$mn:000022EF __catch$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:000022EF                                         ; DATA XREF: .xdata$x:00007918o
.text$mn:000022EF                 jmp     short loc_22FA
.text$mn:000022F1 ; ---------------------------------------------------------------------------
.text$mn:000022F1
.text$mn:000022F1 loc_22F1:                               ; CODE XREF: __catch$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:000022F1                 mov     eax, [ebp-14h]
.text$mn:000022F4                 add     eax, 4Ch ; 'L'
.text$mn:000022F7                 mov     [ebp-14h], eax
.text$mn:000022FA
.text$mn:000022FA loc_22FA:                               ; CODE XREF: __catch$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:000022FA                 mov     ecx, [ebp-14h]
.text$mn:000022FD                 cmp     ecx, [ebp+10h]
.text$mn:00002300                 jz      short loc_2310
.text$mn:00002302                 mov     edx, [ebp-14h]
.text$mn:00002305                 push    edx
.text$mn:00002306                 mov     ecx, [ebp+14h]
.text$mn:00002309                 call    ??$destroy@UTreeStateNode@@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@@Z ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::destroy<TreeStateNode>(TreeStateNode *)
.text$mn:0000230E                 jmp     short loc_22F1
.text$mn:00002310 ; ---------------------------------------------------------------------------
.text$mn:00002310
.text$mn:00002310 loc_2310:                               ; CODE XREF: __catch$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00002310                 push    0
.text$mn:00002312                 push    0
.text$mn:00002314                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00002314 __catch$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00002314
.text$mn:00002319 ; ---------------------------------------------------------------------------
.text$mn:00002319                 mov     eax, offset $LN13
.text$mn:0000231E                 retn
.text$mn:0000231F ; ---------------------------------------------------------------------------
.text$mn:0000231F ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000231F
.text$mn:0000231F loc_231F:                               ; CODE XREF: std::_Uninit_move<TreeStateNode *,TreeStateNode *,std::allocator<TreeStateNode>,TreeStateNode>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,TreeStateNode *,std::_Nonscalar_ptr_iterator_tag):loc_22EDj
.text$mn:0000231F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002326                 jmp     short loc_232F
.text$mn:00002326 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002328
.text$mn:00002328 ; =============== S U B R O U T I N E =======================================
.text$mn:00002328
.text$mn:00002328
.text$mn:00002328 $LN13           proc near               ; DATA XREF: .text$mn:00002319o
.text$mn:00002328                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002328 $LN13           endp ; sp-analysis failed
.text$mn:00002328
.text$mn:0000232F ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000232F
.text$mn:0000232F loc_232F:                               ; CODE XREF: std::_Uninit_move<TreeStateNode *,TreeStateNode *,std::allocator<TreeStateNode>,TreeStateNode>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,TreeStateNode *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:0000232F                 mov     eax, [ebp+arg_8]
.text$mn:00002332                 mov     ecx, [ebp+var_C]
.text$mn:00002335                 mov     large fs:0, ecx
.text$mn:0000233C                 pop     ecx
.text$mn:0000233D                 pop     edi
.text$mn:0000233E                 pop     esi
.text$mn:0000233F                 pop     ebx
.text$mn:00002340                 mov     esp, ebp
.text$mn:00002342                 pop     ebp
.text$mn:00002343                 retn
.text$mn:00002343 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002343 _text$mn        ends
.text$mn:00002343
.text$x:00002344 ; ===========================================================================
.text$x:00002344
.text$x:00002344 ; Segment type: Pure code
.text$x:00002344 ; Segment permissions: Read/Execute
.text$x:00002344 _text$x         segment para public 'CODE' use32
.text$x:00002344                 assume cs:_text$x
.text$x:00002344                 ;org 2344h
.text$x:00002344 ; COMDAT (pick associative to section at 2258)
.text$x:00002344                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002344
.text$x:00002344 ; =============== S U B R O U T I N E =======================================
.text$x:00002344
.text$x:00002344
.text$x:00002344 __ehhandler$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00002344                                         ; DATA XREF: std::_Uninit_move<TreeStateNode *,TreeStateNode *,std::allocator<TreeStateNode>,TreeStateNode>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,TreeStateNode *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00002344
.text$x:00002344 arg_4           = dword ptr  8
.text$x:00002344
.text$x:00002344                 mov     edx, [esp+arg_4]
.text$x:00002348                 lea     eax, [edx+0Ch]
.text$x:0000234B                 mov     ecx, [edx-18h]
.text$x:0000234E                 xor     ecx, eax
.text$x:00002350                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002355                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:0000235A                 jmp     ___CxxFrameHandler3
.text$x:0000235A __ehhandler$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:0000235A
.text$x:0000235A ; ---------------------------------------------------------------------------
.text$x:0000235F                 align 10h
.text$x:0000235F _text$x         ends
.text$x:0000235F
.text$mn:00002360 ; ===========================================================================
.text$mn:00002360
.text$mn:00002360 ; Segment type: Pure code
.text$mn:00002360 ; Segment permissions: Read/Execute
.text$mn:00002360 _text$mn        segment para public 'CODE' use32
.text$mn:00002360                 assume cs:_text$mn
.text$mn:00002360                 ;org 2360h
.text$mn:00002360 ; COMDAT (pick any)
.text$mn:00002360                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002360
.text$mn:00002360 ; =============== S U B R O U T I N E =======================================
.text$mn:00002360
.text$mn:00002360 ; Attributes: bp-based frame
.text$mn:00002360
.text$mn:00002360 ; struct TreeStateNode * __cdecl std::_Uninitialized_copy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>>, struct TreeStateNode *, struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>>, struct TreeStateNode *, struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>> &)
.text$mn:00002360                 public ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z
.text$mn:00002360 ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z proc near
.text$mn:00002360                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *)+83p
.text$mn:00002360
.text$mn:00002360 var_34          = dword ptr -34h
.text$mn:00002360 var_30          = dword ptr -30h
.text$mn:00002360 var_2C          = dword ptr -2Ch
.text$mn:00002360 var_28          = dword ptr -28h
.text$mn:00002360 var_24          = dword ptr -24h
.text$mn:00002360 var_20          = dword ptr -20h
.text$mn:00002360 var_1C          = dword ptr -1Ch
.text$mn:00002360 var_18          = dword ptr -18h
.text$mn:00002360 var_14          = dword ptr -14h
.text$mn:00002360 var_10          = dword ptr -10h
.text$mn:00002360 var_C           = dword ptr -0Ch
.text$mn:00002360 var_4           = dword ptr -4
.text$mn:00002360 arg_0           = byte ptr  8
.text$mn:00002360 arg_C           = byte ptr  14h
.text$mn:00002360 arg_18          = dword ptr  20h
.text$mn:00002360 arg_1C          = dword ptr  24h
.text$mn:00002360
.text$mn:00002360                 push    ebp
.text$mn:00002361                 mov     ebp, esp
.text$mn:00002363                 push    0FFFFFFFFh
.text$mn:00002365                 push    offset __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z
.text$mn:0000236A                 mov     eax, large fs:0
.text$mn:00002370                 push    eax
.text$mn:00002371                 sub     esp, 28h
.text$mn:00002374                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002379                 xor     eax, ebp
.text$mn:0000237B                 push    eax
.text$mn:0000237C                 lea     eax, [ebp+var_C]
.text$mn:0000237F                 mov     large fs:0, eax
.text$mn:00002385                 mov     [ebp+var_4], 1
.text$mn:0000238C                 mov     eax, [ebp+arg_1C]
.text$mn:0000238F                 push    eax
.text$mn:00002390                 mov     ecx, [ebp+arg_18]
.text$mn:00002393                 push    ecx
.text$mn:00002394                 call    ??$_Unchecked@PAUTreeStateNode@@@std@@YAPAUTreeStateNode@@PAU1@@Z ; std::_Unchecked<TreeStateNode *>(TreeStateNode *)
.text$mn:00002399                 add     esp, 4
.text$mn:0000239C                 push    eax
.text$mn:0000239D                 sub     esp, 0Ch
.text$mn:000023A0                 mov     ecx, esp
.text$mn:000023A2                 mov     [ebp+var_28], esp
.text$mn:000023A5                 lea     edx, [ebp+arg_C]
.text$mn:000023A8                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000023A9                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>> const &)
.text$mn:000023AE                 mov     [ebp+var_10], eax
.text$mn:000023B1                 mov     eax, [ebp+var_10]
.text$mn:000023B4                 mov     [ebp+var_2C], eax
.text$mn:000023B7                 mov     byte ptr [ebp+var_4], 2
.text$mn:000023BB                 mov     byte ptr [ebp+var_4], 1
.text$mn:000023BF                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>)
.text$mn:000023C4                 add     esp, 0Ch
.text$mn:000023C7                 mov     [ebp+var_14], eax
.text$mn:000023CA                 mov     ecx, [ebp+var_14]
.text$mn:000023CD                 push    ecx
.text$mn:000023CE                 sub     esp, 0Ch
.text$mn:000023D1                 mov     ecx, esp
.text$mn:000023D3                 mov     [ebp+var_30], esp
.text$mn:000023D6                 lea     edx, [ebp+arg_0]
.text$mn:000023D9                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000023DA                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>> const &)
.text$mn:000023DF                 mov     [ebp+var_18], eax
.text$mn:000023E2                 mov     eax, [ebp+var_18]
.text$mn:000023E5                 mov     [ebp+var_34], eax
.text$mn:000023E8                 mov     byte ptr [ebp+var_4], 3
.text$mn:000023EC                 mov     byte ptr [ebp+var_4], 1
.text$mn:000023F0                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>)
.text$mn:000023F5                 add     esp, 0Ch
.text$mn:000023F8                 mov     [ebp+var_1C], eax
.text$mn:000023FB                 mov     ecx, [ebp+var_1C]
.text$mn:000023FE                 push    ecx
.text$mn:000023FF                 call    ??$_Uninit_copy@PBUTreeStateNode@@PAU1@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z ; std::_Uninit_copy<TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode const *,TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)
.text$mn:00002404                 add     esp, 10h
.text$mn:00002407                 mov     [ebp+var_20], eax
.text$mn:0000240A                 mov     edx, [ebp+var_20]
.text$mn:0000240D                 push    edx
.text$mn:0000240E                 lea     eax, [ebp+arg_18]
.text$mn:00002411                 push    eax
.text$mn:00002412                 call    ??$_Rechecked@PAUTreeStateNode@@PAU1@@std@@YAAAPAUTreeStateNode@@AAPAU1@PAU1@@Z ; std::_Rechecked<TreeStateNode *,TreeStateNode *>(TreeStateNode * &,TreeStateNode *)
.text$mn:00002417                 add     esp, 8
.text$mn:0000241A                 mov     ecx, [eax]
.text$mn:0000241C                 mov     [ebp+var_24], ecx
.text$mn:0000241F                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002423                 lea     ecx, [ebp+arg_0]
.text$mn:00002426                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$mn:0000242B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002432                 lea     ecx, [ebp+arg_C]
.text$mn:00002435                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$mn:0000243A                 mov     eax, [ebp+var_24]
.text$mn:0000243D                 mov     ecx, [ebp+var_C]
.text$mn:00002440                 mov     large fs:0, ecx
.text$mn:00002447                 pop     ecx
.text$mn:00002448                 mov     esp, ebp
.text$mn:0000244A                 pop     ebp
.text$mn:0000244B                 retn
.text$mn:0000244B ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z endp
.text$mn:0000244B
.text$mn:0000244B _text$mn        ends
.text$mn:0000244B
.text$x:0000244C ; ===========================================================================
.text$x:0000244C
.text$x:0000244C ; Segment type: Pure code
.text$x:0000244C ; Segment permissions: Read/Execute
.text$x:0000244C _text$x         segment para public 'CODE' use32
.text$x:0000244C                 assume cs:_text$x
.text$x:0000244C                 ;org 244Ch
.text$x:0000244C ; COMDAT (pick associative to section at 2360)
.text$x:0000244C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000244C
.text$x:0000244C ; =============== S U B R O U T I N E =======================================
.text$x:0000244C
.text$x:0000244C
.text$x:0000244C __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z$0 proc near
.text$x:0000244C                                         ; DATA XREF: .xdata$x:000079ACo
.text$x:0000244C                 lea     ecx, [ebp+14h]
.text$x:0000244F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$x:0000244F __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z$0 endp
.text$x:0000244F
.text$x:00002454
.text$x:00002454 ; =============== S U B R O U T I N E =======================================
.text$x:00002454
.text$x:00002454
.text$x:00002454 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z$1 proc near
.text$x:00002454                                         ; DATA XREF: .xdata$x:000079B4o
.text$x:00002454                 lea     ecx, [ebp+8]
.text$x:00002457                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$x:00002457 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z$1 endp
.text$x:00002457
.text$x:0000245C
.text$x:0000245C ; =============== S U B R O U T I N E =======================================
.text$x:0000245C
.text$x:0000245C
.text$x:0000245C __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z$2 proc near
.text$x:0000245C                                         ; DATA XREF: .xdata$x:000079BCo
.text$x:0000245C                 mov     ecx, [ebp-28h]
.text$x:0000245F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$x:0000245F __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z$2 endp
.text$x:0000245F
.text$x:00002464
.text$x:00002464 ; =============== S U B R O U T I N E =======================================
.text$x:00002464
.text$x:00002464
.text$x:00002464 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z$3 proc near
.text$x:00002464                                         ; DATA XREF: .xdata$x:000079C4o
.text$x:00002464                 mov     ecx, [ebp-30h]
.text$x:00002467                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$x:00002467 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z$3 endp
.text$x:00002467
.text$x:0000246C
.text$x:0000246C ; =============== S U B R O U T I N E =======================================
.text$x:0000246C
.text$x:0000246C
.text$x:0000246C __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z proc near
.text$x:0000246C                                         ; DATA XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+5o
.text$x:0000246C
.text$x:0000246C arg_4           = dword ptr  8
.text$x:0000246C
.text$x:0000246C                 mov     edx, [esp+arg_4]
.text$x:00002470                 lea     eax, [edx+0Ch]
.text$x:00002473                 mov     ecx, [edx-2Ch]
.text$x:00002476                 xor     ecx, eax
.text$x:00002478                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000247D                 mov     eax, offset __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z
.text$x:00002482                 jmp     ___CxxFrameHandler3
.text$x:00002482 __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z endp
.text$x:00002482
.text$x:00002482 ; ---------------------------------------------------------------------------
.text$x:00002487                 align 4
.text$x:00002487 _text$x         ends
.text$x:00002487
.text$mn:00002488 ; ===========================================================================
.text$mn:00002488
.text$mn:00002488 ; Segment type: Pure code
.text$mn:00002488 ; Segment permissions: Read/Execute
.text$mn:00002488 _text$mn        segment para public 'CODE' use32
.text$mn:00002488                 assume cs:_text$mn
.text$mn:00002488                 ;org 2488h
.text$mn:00002488 ; COMDAT (pick any)
.text$mn:00002488                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002488
.text$mn:00002488 ; =============== S U B R O U T I N E =======================================
.text$mn:00002488
.text$mn:00002488 ; Attributes: bp-based frame
.text$mn:00002488
.text$mn:00002488 ; struct TreeStateNode * __cdecl std::_Uninitialized_move<struct TreeStateNode *, struct TreeStateNode *, struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>>>(struct TreeStateNode *, struct TreeStateNode *, struct TreeStateNode *, struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>> &)
.text$mn:00002488                 public ??$_Uninitialized_move@PAUTreeStateNode@@PAU1@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z
.text$mn:00002488 ??$_Uninitialized_move@PAUTreeStateNode@@PAU1@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z proc near
.text$mn:00002488                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Umove<TreeStateNode *>(TreeStateNode *,TreeStateNode *,TreeStateNode *)+25p
.text$mn:00002488
.text$mn:00002488 arg_0           = dword ptr  8
.text$mn:00002488 arg_4           = dword ptr  0Ch
.text$mn:00002488 arg_8           = dword ptr  10h
.text$mn:00002488 arg_C           = dword ptr  14h
.text$mn:00002488
.text$mn:00002488                 push    ebp
.text$mn:00002489                 mov     ebp, esp
.text$mn:0000248B                 mov     eax, [ebp+arg_C]
.text$mn:0000248E                 push    eax
.text$mn:0000248F                 mov     ecx, [ebp+arg_8]
.text$mn:00002492                 push    ecx
.text$mn:00002493                 call    ??$_Unchecked@PAUTreeStateNode@@@std@@YAPAUTreeStateNode@@PAU1@@Z ; std::_Unchecked<TreeStateNode *>(TreeStateNode *)
.text$mn:00002498                 add     esp, 4
.text$mn:0000249B                 push    eax
.text$mn:0000249C                 mov     edx, [ebp+arg_4]
.text$mn:0000249F                 push    edx
.text$mn:000024A0                 call    ??$_Unchecked@PAUTreeStateNode@@@std@@YAPAUTreeStateNode@@PAU1@@Z ; std::_Unchecked<TreeStateNode *>(TreeStateNode *)
.text$mn:000024A5                 add     esp, 4
.text$mn:000024A8                 push    eax
.text$mn:000024A9                 mov     eax, [ebp+arg_0]
.text$mn:000024AC                 push    eax
.text$mn:000024AD                 call    ??$_Unchecked@PAUTreeStateNode@@@std@@YAPAUTreeStateNode@@PAU1@@Z ; std::_Unchecked<TreeStateNode *>(TreeStateNode *)
.text$mn:000024B2                 add     esp, 4
.text$mn:000024B5                 push    eax
.text$mn:000024B6                 call    ??$_Uninit_move@PAUTreeStateNode@@PAU1@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z ; std::_Uninit_move<TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)
.text$mn:000024BB                 add     esp, 10h
.text$mn:000024BE                 push    eax
.text$mn:000024BF                 lea     ecx, [ebp+arg_8]
.text$mn:000024C2                 push    ecx
.text$mn:000024C3                 call    ??$_Rechecked@PAUTreeStateNode@@PAU1@@std@@YAAAPAUTreeStateNode@@AAPAU1@PAU1@@Z ; std::_Rechecked<TreeStateNode *,TreeStateNode *>(TreeStateNode * &,TreeStateNode *)
.text$mn:000024C8                 add     esp, 8
.text$mn:000024CB                 mov     eax, [eax]
.text$mn:000024CD                 pop     ebp
.text$mn:000024CE                 retn
.text$mn:000024CE ??$_Uninitialized_move@PAUTreeStateNode@@PAU1@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z endp
.text$mn:000024CE
.text$mn:000024CE ; ---------------------------------------------------------------------------
.text$mn:000024CF                 align 10h
.text$mn:000024CF _text$mn        ends
.text$mn:000024CF
.text$mn:000024D0 ; ===========================================================================
.text$mn:000024D0
.text$mn:000024D0 ; Segment type: Pure code
.text$mn:000024D0 ; Segment permissions: Read/Execute
.text$mn:000024D0 _text$mn        segment para public 'CODE' use32
.text$mn:000024D0                 assume cs:_text$mn
.text$mn:000024D0                 ;org 24D0h
.text$mn:000024D0 ; COMDAT (pick any)
.text$mn:000024D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024D0
.text$mn:000024D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000024D0
.text$mn:000024D0 ; Attributes: bp-based frame
.text$mn:000024D0
.text$mn:000024D0 ; struct TreeStateNode * __cdecl std::_Val_type<struct TreeStateNode *>(struct TreeStateNode *)
.text$mn:000024D0                 public ??$_Val_type@PAUTreeStateNode@@@std@@YAPAUTreeStateNode@@PAU1@@Z
.text$mn:000024D0 ??$_Val_type@PAUTreeStateNode@@@std@@YAPAUTreeStateNode@@PAU1@@Z proc near
.text$mn:000024D0                                         ; CODE XREF: std::_Uninit_move<TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)+20p
.text$mn:000024D0                 push    ebp
.text$mn:000024D1                 mov     ebp, esp
.text$mn:000024D3                 xor     eax, eax
.text$mn:000024D5                 pop     ebp
.text$mn:000024D6                 retn
.text$mn:000024D6 ??$_Val_type@PAUTreeStateNode@@@std@@YAPAUTreeStateNode@@PAU1@@Z endp
.text$mn:000024D6
.text$mn:000024D6 ; ---------------------------------------------------------------------------
.text$mn:000024D7                 align 4
.text$mn:000024D7 _text$mn        ends
.text$mn:000024D7
.text$mn:000024D8 ; ===========================================================================
.text$mn:000024D8
.text$mn:000024D8 ; Segment type: Pure code
.text$mn:000024D8 ; Segment permissions: Read/Execute
.text$mn:000024D8 _text$mn        segment para public 'CODE' use32
.text$mn:000024D8                 assume cs:_text$mn
.text$mn:000024D8                 ;org 24D8h
.text$mn:000024D8 ; COMDAT (pick any)
.text$mn:000024D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024D8
.text$mn:000024D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000024D8
.text$mn:000024D8 ; Attributes: bp-based frame
.text$mn:000024D8
.text$mn:000024D8 ; char * __cdecl std::addressof<char>(char &)
.text$mn:000024D8                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000024D8 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000024D8                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000024D8                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000024D8
.text$mn:000024D8 arg_0           = dword ptr  8
.text$mn:000024D8
.text$mn:000024D8                 push    ebp
.text$mn:000024D9                 mov     ebp, esp
.text$mn:000024DB                 mov     eax, [ebp+arg_0]
.text$mn:000024DE                 pop     ebp
.text$mn:000024DF                 retn
.text$mn:000024DF ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000024DF
.text$mn:000024DF _text$mn        ends
.text$mn:000024DF
.text$mn:000024E0 ; ===========================================================================
.text$mn:000024E0
.text$mn:000024E0 ; Segment type: Pure code
.text$mn:000024E0 ; Segment permissions: Read/Execute
.text$mn:000024E0 _text$mn        segment para public 'CODE' use32
.text$mn:000024E0                 assume cs:_text$mn
.text$mn:000024E0                 ;org 24E0h
.text$mn:000024E0 ; COMDAT (pick any)
.text$mn:000024E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024E0
.text$mn:000024E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000024E0
.text$mn:000024E0 ; Attributes: bp-based frame
.text$mn:000024E0
.text$mn:000024E0 ; struct TreeStateNode * __cdecl std::addressof<struct TreeStateNode>(struct TreeStateNode &)
.text$mn:000024E0                 public ??$addressof@UTreeStateNode@@@std@@YAPAUTreeStateNode@@AAU1@@Z
.text$mn:000024E0 ??$addressof@UTreeStateNode@@@std@@YAPAUTreeStateNode@@AAU1@@Z proc near
.text$mn:000024E0                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::push_back(TreeStateNode &&)+Dp
.text$mn:000024E0                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::push_back(TreeStateNode &&)+2Dp
.text$mn:000024E0
.text$mn:000024E0 arg_0           = dword ptr  8
.text$mn:000024E0
.text$mn:000024E0                 push    ebp
.text$mn:000024E1                 mov     ebp, esp
.text$mn:000024E3                 mov     eax, [ebp+arg_0]
.text$mn:000024E6                 pop     ebp
.text$mn:000024E7                 retn
.text$mn:000024E7 ??$addressof@UTreeStateNode@@@std@@YAPAUTreeStateNode@@AAU1@@Z endp
.text$mn:000024E7
.text$mn:000024E7 _text$mn        ends
.text$mn:000024E7
.text$mn:000024E8 ; ===========================================================================
.text$mn:000024E8
.text$mn:000024E8 ; Segment type: Pure code
.text$mn:000024E8 ; Segment permissions: Read/Execute
.text$mn:000024E8 _text$mn        segment para public 'CODE' use32
.text$mn:000024E8                 assume cs:_text$mn
.text$mn:000024E8                 ;org 24E8h
.text$mn:000024E8 ; COMDAT (pick any)
.text$mn:000024E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024E8
.text$mn:000024E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000024E8
.text$mn:000024E8 ; Attributes: bp-based frame
.text$mn:000024E8
.text$mn:000024E8 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:000024E8                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:000024E8 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:000024E8                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:000024E8                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:000024E8
.text$mn:000024E8 arg_0           = dword ptr  8
.text$mn:000024E8
.text$mn:000024E8                 push    ebp
.text$mn:000024E9                 mov     ebp, esp
.text$mn:000024EB                 mov     eax, [ebp+arg_0]
.text$mn:000024EE                 pop     ebp
.text$mn:000024EF                 retn
.text$mn:000024EF ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:000024EF
.text$mn:000024EF _text$mn        ends
.text$mn:000024EF
.text$mn:000024F0 ; ===========================================================================
.text$mn:000024F0
.text$mn:000024F0 ; Segment type: Pure code
.text$mn:000024F0 ; Segment permissions: Read/Execute
.text$mn:000024F0 _text$mn        segment para public 'CODE' use32
.text$mn:000024F0                 assume cs:_text$mn
.text$mn:000024F0                 ;org 24F0h
.text$mn:000024F0 ; COMDAT (pick any)
.text$mn:000024F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024F0
.text$mn:000024F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000024F0
.text$mn:000024F0 ; Attributes: bp-based frame
.text$mn:000024F0
.text$mn:000024F0 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000024F0                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000024F0 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000024F0                                         ; CODE XREF: $LN19+4Bp
.text$mn:000024F0
.text$mn:000024F0 var_4           = dword ptr -4
.text$mn:000024F0 arg_0           = dword ptr  8
.text$mn:000024F0 arg_4           = dword ptr  0Ch
.text$mn:000024F0
.text$mn:000024F0                 push    ebp
.text$mn:000024F1                 mov     ebp, esp
.text$mn:000024F3                 push    ecx
.text$mn:000024F4                 mov     [ebp+var_4], ecx
.text$mn:000024F7                 mov     eax, [ebp+arg_4]
.text$mn:000024FA                 push    eax
.text$mn:000024FB                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00002500                 add     esp, 4
.text$mn:00002503                 push    eax             ; int
.text$mn:00002504                 mov     ecx, [ebp+arg_0]
.text$mn:00002507                 push    ecx             ; void *
.text$mn:00002508                 mov     edx, [ebp+var_4]
.text$mn:0000250B                 push    edx             ; int
.text$mn:0000250C                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00002511                 add     esp, 0Ch
.text$mn:00002514                 mov     esp, ebp
.text$mn:00002516                 pop     ebp
.text$mn:00002517                 retn    8
.text$mn:00002517 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00002517
.text$mn:00002517 ; ---------------------------------------------------------------------------
.text$mn:0000251A                 align 4
.text$mn:0000251A _text$mn        ends
.text$mn:0000251A
.text$mn:0000251C ; ===========================================================================
.text$mn:0000251C
.text$mn:0000251C ; Segment type: Pure code
.text$mn:0000251C ; Segment permissions: Read/Execute
.text$mn:0000251C _text$mn        segment para public 'CODE' use32
.text$mn:0000251C                 assume cs:_text$mn
.text$mn:0000251C                 ;org 251Ch
.text$mn:0000251C ; COMDAT (pick any)
.text$mn:0000251C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000251C
.text$mn:0000251C ; =============== S U B R O U T I N E =======================================
.text$mn:0000251C
.text$mn:0000251C ; Attributes: bp-based frame
.text$mn:0000251C
.text$mn:0000251C ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:0000251C                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000251C ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:0000251C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:0000251C
.text$mn:0000251C var_1C          = dword ptr -1Ch
.text$mn:0000251C var_18          = dword ptr -18h
.text$mn:0000251C var_14          = dword ptr -14h
.text$mn:0000251C var_10          = dword ptr -10h
.text$mn:0000251C var_C           = dword ptr -0Ch
.text$mn:0000251C var_4           = dword ptr -4
.text$mn:0000251C arg_0           = dword ptr  8
.text$mn:0000251C arg_4           = dword ptr  0Ch
.text$mn:0000251C
.text$mn:0000251C                 push    ebp
.text$mn:0000251D                 mov     ebp, esp
.text$mn:0000251F                 push    0FFFFFFFFh
.text$mn:00002521                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00002526                 mov     eax, large fs:0
.text$mn:0000252C                 push    eax
.text$mn:0000252D                 sub     esp, 10h
.text$mn:00002530                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002535                 xor     eax, ebp
.text$mn:00002537                 push    eax
.text$mn:00002538                 lea     eax, [ebp+var_C]
.text$mn:0000253B                 mov     large fs:0, eax
.text$mn:00002541                 mov     [ebp+var_18], ecx
.text$mn:00002544                 mov     eax, [ebp+arg_0]
.text$mn:00002547                 push    eax             ; void *
.text$mn:00002548                 push    4               ; unsigned int
.text$mn:0000254A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000254F                 add     esp, 8
.text$mn:00002552                 mov     [ebp+var_10], eax
.text$mn:00002555                 mov     [ebp+var_4], 0
.text$mn:0000255C                 cmp     [ebp+var_10], 0
.text$mn:00002560                 jz      short loc_257D
.text$mn:00002562                 mov     ecx, [ebp+arg_4]
.text$mn:00002565                 push    ecx
.text$mn:00002566                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000256B                 add     esp, 4
.text$mn:0000256E                 mov     edx, [ebp+var_10]
.text$mn:00002571                 mov     eax, [eax]
.text$mn:00002573                 mov     [edx], eax
.text$mn:00002575                 mov     ecx, [ebp+var_10]
.text$mn:00002578                 mov     [ebp+var_14], ecx
.text$mn:0000257B                 jmp     short loc_2584
.text$mn:0000257D ; ---------------------------------------------------------------------------
.text$mn:0000257D
.text$mn:0000257D loc_257D:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:0000257D                 mov     [ebp+var_14], 0
.text$mn:00002584
.text$mn:00002584 loc_2584:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00002584                 mov     edx, [ebp+var_14]
.text$mn:00002587                 mov     [ebp+var_1C], edx
.text$mn:0000258A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002591                 mov     ecx, [ebp+var_C]
.text$mn:00002594                 mov     large fs:0, ecx
.text$mn:0000259B                 pop     ecx
.text$mn:0000259C                 mov     esp, ebp
.text$mn:0000259E                 pop     ebp
.text$mn:0000259F                 retn    8
.text$mn:0000259F ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000259F
.text$mn:0000259F ; ---------------------------------------------------------------------------
.text$mn:000025A2                 align 4
.text$mn:000025A2 _text$mn        ends
.text$mn:000025A2
.text$x:000025A4 ; ===========================================================================
.text$x:000025A4
.text$x:000025A4 ; Segment type: Pure code
.text$x:000025A4 ; Segment permissions: Read/Execute
.text$x:000025A4 _text$x         segment para public 'CODE' use32
.text$x:000025A4                 assume cs:_text$x
.text$x:000025A4                 ;org 25A4h
.text$x:000025A4 ; COMDAT (pick associative to section at 251C)
.text$x:000025A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000025A4
.text$x:000025A4 ; =============== S U B R O U T I N E =======================================
.text$x:000025A4
.text$x:000025A4
.text$x:000025A4 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000025A4                                         ; DATA XREF: .xdata$x:000078B8o
.text$x:000025A4                 mov     eax, [ebp+8]
.text$x:000025A7                 push    eax
.text$x:000025A8                 mov     eax, [ebp-10h]
.text$x:000025AB                 push    eax             ; void *
.text$x:000025AC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000025B1                 add     esp, 8
.text$x:000025B4                 retn
.text$x:000025B4 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000025B4
.text$x:000025B5
.text$x:000025B5 ; =============== S U B R O U T I N E =======================================
.text$x:000025B5
.text$x:000025B5
.text$x:000025B5 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000025B5                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000025B5
.text$x:000025B5 arg_4           = dword ptr  8
.text$x:000025B5
.text$x:000025B5                 mov     edx, [esp+arg_4]
.text$x:000025B9                 lea     eax, [edx+0Ch]
.text$x:000025BC                 mov     ecx, [edx-14h]
.text$x:000025BF                 xor     ecx, eax
.text$x:000025C1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000025C6                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000025CB                 jmp     ___CxxFrameHandler3
.text$x:000025CB __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000025CB
.text$x:000025CB _text$x         ends
.text$x:000025CB
.text$mn:000025D0 ; ===========================================================================
.text$mn:000025D0
.text$mn:000025D0 ; Segment type: Pure code
.text$mn:000025D0 ; Segment permissions: Read/Execute
.text$mn:000025D0 _text$mn        segment para public 'CODE' use32
.text$mn:000025D0                 assume cs:_text$mn
.text$mn:000025D0                 ;org 25D0h
.text$mn:000025D0 ; COMDAT (pick any)
.text$mn:000025D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025D0
.text$mn:000025D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025D0
.text$mn:000025D0 ; Attributes: bp-based frame
.text$mn:000025D0
.text$mn:000025D0 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000025D0                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000025D0 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000025D0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000025D0
.text$mn:000025D0 arg_0           = dword ptr  8
.text$mn:000025D0 arg_4           = dword ptr  0Ch
.text$mn:000025D0 arg_8           = dword ptr  10h
.text$mn:000025D0
.text$mn:000025D0                 push    ebp
.text$mn:000025D1                 mov     ebp, esp
.text$mn:000025D3                 mov     eax, [ebp+arg_8]
.text$mn:000025D6                 push    eax
.text$mn:000025D7                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000025DC                 add     esp, 4
.text$mn:000025DF                 push    eax             ; int
.text$mn:000025E0                 mov     ecx, [ebp+arg_4]
.text$mn:000025E3                 push    ecx             ; void *
.text$mn:000025E4                 mov     ecx, [ebp+arg_0]
.text$mn:000025E7                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:000025EC                 pop     ebp
.text$mn:000025ED                 retn
.text$mn:000025ED ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:000025ED
.text$mn:000025ED ; ---------------------------------------------------------------------------
.text$mn:000025EE                 align 10h
.text$mn:000025EE _text$mn        ends
.text$mn:000025EE
.text$mn:000025F0 ; ===========================================================================
.text$mn:000025F0
.text$mn:000025F0 ; Segment type: Pure code
.text$mn:000025F0 ; Segment permissions: Read/Execute
.text$mn:000025F0 _text$mn        segment para public 'CODE' use32
.text$mn:000025F0                 assume cs:_text$mn
.text$mn:000025F0                 ;org 25F0h
.text$mn:000025F0 ; COMDAT (pick any)
.text$mn:000025F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025F0
.text$mn:000025F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025F0
.text$mn:000025F0 ; Attributes: bp-based frame
.text$mn:000025F0
.text$mn:000025F0 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:000025F0                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:000025F0 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:000025F0                                         ; CODE XREF: $LN19_0+4Bp
.text$mn:000025F0
.text$mn:000025F0 var_4           = dword ptr -4
.text$mn:000025F0 arg_0           = dword ptr  8
.text$mn:000025F0 arg_4           = dword ptr  0Ch
.text$mn:000025F0
.text$mn:000025F0                 push    ebp
.text$mn:000025F1                 mov     ebp, esp
.text$mn:000025F3                 push    ecx
.text$mn:000025F4                 mov     [ebp+var_4], ecx
.text$mn:000025F7                 mov     eax, [ebp+arg_4]
.text$mn:000025FA                 push    eax
.text$mn:000025FB                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00002600                 add     esp, 4
.text$mn:00002603                 push    eax             ; int
.text$mn:00002604                 mov     ecx, [ebp+arg_0]
.text$mn:00002607                 push    ecx             ; void *
.text$mn:00002608                 mov     edx, [ebp+var_4]
.text$mn:0000260B                 push    edx             ; int
.text$mn:0000260C                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:00002611                 add     esp, 0Ch
.text$mn:00002614                 mov     esp, ebp
.text$mn:00002616                 pop     ebp
.text$mn:00002617                 retn    8
.text$mn:00002617 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00002617
.text$mn:00002617 ; ---------------------------------------------------------------------------
.text$mn:0000261A                 align 4
.text$mn:0000261A _text$mn        ends
.text$mn:0000261A
.text$mn:0000261C ; ===========================================================================
.text$mn:0000261C
.text$mn:0000261C ; Segment type: Pure code
.text$mn:0000261C ; Segment permissions: Read/Execute
.text$mn:0000261C _text$mn        segment para public 'CODE' use32
.text$mn:0000261C                 assume cs:_text$mn
.text$mn:0000261C                 ;org 261Ch
.text$mn:0000261C ; COMDAT (pick any)
.text$mn:0000261C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000261C
.text$mn:0000261C ; =============== S U B R O U T I N E =======================================
.text$mn:0000261C
.text$mn:0000261C ; Attributes: bp-based frame
.text$mn:0000261C
.text$mn:0000261C ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:0000261C                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:0000261C ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:0000261C                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:0000261C
.text$mn:0000261C var_1C          = dword ptr -1Ch
.text$mn:0000261C var_18          = dword ptr -18h
.text$mn:0000261C var_14          = dword ptr -14h
.text$mn:0000261C var_10          = dword ptr -10h
.text$mn:0000261C var_C           = dword ptr -0Ch
.text$mn:0000261C var_4           = dword ptr -4
.text$mn:0000261C arg_0           = dword ptr  8
.text$mn:0000261C arg_4           = dword ptr  0Ch
.text$mn:0000261C
.text$mn:0000261C                 push    ebp
.text$mn:0000261D                 mov     ebp, esp
.text$mn:0000261F                 push    0FFFFFFFFh
.text$mn:00002621                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00002626                 mov     eax, large fs:0
.text$mn:0000262C                 push    eax
.text$mn:0000262D                 sub     esp, 10h
.text$mn:00002630                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002635                 xor     eax, ebp
.text$mn:00002637                 push    eax
.text$mn:00002638                 lea     eax, [ebp+var_C]
.text$mn:0000263B                 mov     large fs:0, eax
.text$mn:00002641                 mov     [ebp+var_18], ecx
.text$mn:00002644                 mov     eax, [ebp+arg_0]
.text$mn:00002647                 push    eax             ; void *
.text$mn:00002648                 push    4               ; unsigned int
.text$mn:0000264A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000264F                 add     esp, 8
.text$mn:00002652                 mov     [ebp+var_10], eax
.text$mn:00002655                 mov     [ebp+var_4], 0
.text$mn:0000265C                 cmp     [ebp+var_10], 0
.text$mn:00002660                 jz      short loc_267D
.text$mn:00002662                 mov     ecx, [ebp+arg_4]
.text$mn:00002665                 push    ecx
.text$mn:00002666                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:0000266B                 add     esp, 4
.text$mn:0000266E                 mov     edx, [ebp+var_10]
.text$mn:00002671                 mov     eax, [eax]
.text$mn:00002673                 mov     [edx], eax
.text$mn:00002675                 mov     ecx, [ebp+var_10]
.text$mn:00002678                 mov     [ebp+var_14], ecx
.text$mn:0000267B                 jmp     short loc_2684
.text$mn:0000267D ; ---------------------------------------------------------------------------
.text$mn:0000267D
.text$mn:0000267D loc_267D:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:0000267D                 mov     [ebp+var_14], 0
.text$mn:00002684
.text$mn:00002684 loc_2684:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:00002684                 mov     edx, [ebp+var_14]
.text$mn:00002687                 mov     [ebp+var_1C], edx
.text$mn:0000268A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002691                 mov     ecx, [ebp+var_C]
.text$mn:00002694                 mov     large fs:0, ecx
.text$mn:0000269B                 pop     ecx
.text$mn:0000269C                 mov     esp, ebp
.text$mn:0000269E                 pop     ebp
.text$mn:0000269F                 retn    8
.text$mn:0000269F ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:0000269F
.text$mn:0000269F ; ---------------------------------------------------------------------------
.text$mn:000026A2                 align 4
.text$mn:000026A2 _text$mn        ends
.text$mn:000026A2
.text$x:000026A4 ; ===========================================================================
.text$x:000026A4
.text$x:000026A4 ; Segment type: Pure code
.text$x:000026A4 ; Segment permissions: Read/Execute
.text$x:000026A4 _text$x         segment para public 'CODE' use32
.text$x:000026A4                 assume cs:_text$x
.text$x:000026A4                 ;org 26A4h
.text$x:000026A4 ; COMDAT (pick associative to section at 261C)
.text$x:000026A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000026A4
.text$x:000026A4 ; =============== S U B R O U T I N E =======================================
.text$x:000026A4
.text$x:000026A4
.text$x:000026A4 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:000026A4                                         ; DATA XREF: .xdata$x:000078E4o
.text$x:000026A4                 mov     eax, [ebp+8]
.text$x:000026A7                 push    eax
.text$x:000026A8                 mov     eax, [ebp-10h]
.text$x:000026AB                 push    eax             ; void *
.text$x:000026AC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000026B1                 add     esp, 8
.text$x:000026B4                 retn
.text$x:000026B4 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:000026B4
.text$x:000026B5
.text$x:000026B5 ; =============== S U B R O U T I N E =======================================
.text$x:000026B5
.text$x:000026B5
.text$x:000026B5 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:000026B5                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:000026B5
.text$x:000026B5 arg_4           = dword ptr  8
.text$x:000026B5
.text$x:000026B5                 mov     edx, [esp+arg_4]
.text$x:000026B9                 lea     eax, [edx+0Ch]
.text$x:000026BC                 mov     ecx, [edx-14h]
.text$x:000026BF                 xor     ecx, eax
.text$x:000026C1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000026C6                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:000026CB                 jmp     ___CxxFrameHandler3
.text$x:000026CB __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:000026CB
.text$x:000026CB _text$x         ends
.text$x:000026CB
.text$mn:000026D0 ; ===========================================================================
.text$mn:000026D0
.text$mn:000026D0 ; Segment type: Pure code
.text$mn:000026D0 ; Segment permissions: Read/Execute
.text$mn:000026D0 _text$mn        segment para public 'CODE' use32
.text$mn:000026D0                 assume cs:_text$mn
.text$mn:000026D0                 ;org 26D0h
.text$mn:000026D0 ; COMDAT (pick any)
.text$mn:000026D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026D0
.text$mn:000026D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000026D0
.text$mn:000026D0 ; Attributes: bp-based frame
.text$mn:000026D0
.text$mn:000026D0 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:000026D0                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:000026D0 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:000026D0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:000026D0
.text$mn:000026D0 arg_0           = dword ptr  8
.text$mn:000026D0 arg_4           = dword ptr  0Ch
.text$mn:000026D0 arg_8           = dword ptr  10h
.text$mn:000026D0
.text$mn:000026D0                 push    ebp
.text$mn:000026D1                 mov     ebp, esp
.text$mn:000026D3                 mov     eax, [ebp+arg_8]
.text$mn:000026D6                 push    eax
.text$mn:000026D7                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000026DC                 add     esp, 4
.text$mn:000026DF                 push    eax             ; int
.text$mn:000026E0                 mov     ecx, [ebp+arg_4]
.text$mn:000026E3                 push    ecx             ; void *
.text$mn:000026E4                 mov     ecx, [ebp+arg_0]
.text$mn:000026E7                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:000026EC                 pop     ebp
.text$mn:000026ED                 retn
.text$mn:000026ED ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:000026ED
.text$mn:000026ED ; ---------------------------------------------------------------------------
.text$mn:000026EE                 align 10h
.text$mn:000026EE _text$mn        ends
.text$mn:000026EE
.text$mn:000026F0 ; ===========================================================================
.text$mn:000026F0
.text$mn:000026F0 ; Segment type: Pure code
.text$mn:000026F0 ; Segment permissions: Read/Execute
.text$mn:000026F0 _text$mn        segment para public 'CODE' use32
.text$mn:000026F0                 assume cs:_text$mn
.text$mn:000026F0                 ;org 26F0h
.text$mn:000026F0 ; COMDAT (pick any)
.text$mn:000026F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026F0
.text$mn:000026F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000026F0
.text$mn:000026F0 ; Attributes: bp-based frame
.text$mn:000026F0
.text$mn:000026F0 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct TreeStateNode>>::construct<struct TreeStateNode, struct TreeStateNode const &>(struct TreeStateNode *, struct TreeStateNode const &)
.text$mn:000026F0                 public ??$construct@UTreeStateNode@@ABU1@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@ABU2@@Z
.text$mn:000026F0 ??$construct@UTreeStateNode@@ABU1@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@ABU2@@Z proc near
.text$mn:000026F0                                         ; CODE XREF: std::_Uninit_copy<TreeStateNode const *,TreeStateNode *,std::allocator<TreeStateNode>>(TreeStateNode const *,TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:000026F0
.text$mn:000026F0 var_4           = dword ptr -4
.text$mn:000026F0 arg_0           = dword ptr  8
.text$mn:000026F0 arg_4           = dword ptr  0Ch
.text$mn:000026F0
.text$mn:000026F0                 push    ebp
.text$mn:000026F1                 mov     ebp, esp
.text$mn:000026F3                 push    ecx
.text$mn:000026F4                 mov     [ebp+var_4], ecx
.text$mn:000026F7                 mov     eax, [ebp+arg_4]
.text$mn:000026FA                 push    eax
.text$mn:000026FB                 call    ??$forward@ABUTreeStateNode@@@std@@YAABUTreeStateNode@@ABU1@@Z ; std::forward<TreeStateNode const &>(TreeStateNode const &)
.text$mn:00002700                 add     esp, 4
.text$mn:00002703                 push    eax
.text$mn:00002704                 mov     ecx, [ebp+arg_0]
.text$mn:00002707                 push    ecx
.text$mn:00002708                 mov     edx, [ebp+var_4]
.text$mn:0000270B                 push    edx
.text$mn:0000270C                 call    ??$construct@UTreeStateNode@@ABU1@@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAXAAV?$allocator@UTreeStateNode@@@1@PAUTreeStateNode@@ABU3@@Z ; std::allocator_traits<std::allocator<TreeStateNode>>::construct<TreeStateNode,TreeStateNode const &>(std::allocator<TreeStateNode> &,TreeStateNode *,TreeStateNode const &)
.text$mn:00002711                 add     esp, 0Ch
.text$mn:00002714                 mov     esp, ebp
.text$mn:00002716                 pop     ebp
.text$mn:00002717                 retn    8
.text$mn:00002717 ??$construct@UTreeStateNode@@ABU1@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@ABU2@@Z endp
.text$mn:00002717
.text$mn:00002717 ; ---------------------------------------------------------------------------
.text$mn:0000271A                 align 4
.text$mn:0000271A _text$mn        ends
.text$mn:0000271A
.text$mn:0000271C ; ===========================================================================
.text$mn:0000271C
.text$mn:0000271C ; Segment type: Pure code
.text$mn:0000271C ; Segment permissions: Read/Execute
.text$mn:0000271C _text$mn        segment para public 'CODE' use32
.text$mn:0000271C                 assume cs:_text$mn
.text$mn:0000271C                 ;org 271Ch
.text$mn:0000271C ; COMDAT (pick any)
.text$mn:0000271C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000271C
.text$mn:0000271C ; =============== S U B R O U T I N E =======================================
.text$mn:0000271C
.text$mn:0000271C ; Attributes: bp-based frame
.text$mn:0000271C
.text$mn:0000271C ; public: static void __cdecl std::allocator_traits<class std::allocator<struct TreeStateNode>>::construct<struct TreeStateNode, struct TreeStateNode const &>(class std::allocator<struct TreeStateNode> &, struct TreeStateNode *, struct TreeStateNode const &)
.text$mn:0000271C                 public ??$construct@UTreeStateNode@@ABU1@@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAXAAV?$allocator@UTreeStateNode@@@1@PAUTreeStateNode@@ABU3@@Z
.text$mn:0000271C ??$construct@UTreeStateNode@@ABU1@@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAXAAV?$allocator@UTreeStateNode@@@1@PAUTreeStateNode@@ABU3@@Z proc near
.text$mn:0000271C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TreeStateNode>>::construct<TreeStateNode,TreeStateNode const &>(TreeStateNode *,TreeStateNode const &)+1Cp
.text$mn:0000271C
.text$mn:0000271C arg_0           = dword ptr  8
.text$mn:0000271C arg_4           = dword ptr  0Ch
.text$mn:0000271C arg_8           = dword ptr  10h
.text$mn:0000271C
.text$mn:0000271C                 push    ebp
.text$mn:0000271D                 mov     ebp, esp
.text$mn:0000271F                 mov     eax, [ebp+arg_8]
.text$mn:00002722                 push    eax
.text$mn:00002723                 call    ??$forward@ABUTreeStateNode@@@std@@YAABUTreeStateNode@@ABU1@@Z ; std::forward<TreeStateNode const &>(TreeStateNode const &)
.text$mn:00002728                 add     esp, 4
.text$mn:0000272B                 push    eax             ; int
.text$mn:0000272C                 mov     ecx, [ebp+arg_4]
.text$mn:0000272F                 push    ecx             ; void *
.text$mn:00002730                 mov     ecx, [ebp+arg_0]
.text$mn:00002733                 call    ?construct@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@ABU3@@Z ; std::allocator<TreeStateNode>::construct(TreeStateNode *,TreeStateNode const &)
.text$mn:00002738                 pop     ebp
.text$mn:00002739                 retn
.text$mn:00002739 ??$construct@UTreeStateNode@@ABU1@@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAXAAV?$allocator@UTreeStateNode@@@1@PAUTreeStateNode@@ABU3@@Z endp
.text$mn:00002739
.text$mn:00002739 ; ---------------------------------------------------------------------------
.text$mn:0000273A                 align 4
.text$mn:0000273A _text$mn        ends
.text$mn:0000273A
.text$mn:0000273C ; ===========================================================================
.text$mn:0000273C
.text$mn:0000273C ; Segment type: Pure code
.text$mn:0000273C ; Segment permissions: Read/Execute
.text$mn:0000273C _text$mn        segment para public 'CODE' use32
.text$mn:0000273C                 assume cs:_text$mn
.text$mn:0000273C                 ;org 273Ch
.text$mn:0000273C ; COMDAT (pick any)
.text$mn:0000273C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000273C
.text$mn:0000273C ; =============== S U B R O U T I N E =======================================
.text$mn:0000273C
.text$mn:0000273C ; Attributes: bp-based frame
.text$mn:0000273C
.text$mn:0000273C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct TreeStateNode>>::construct<struct TreeStateNode, struct TreeStateNode>(struct TreeStateNode *, struct TreeStateNode &&)
.text$mn:0000273C                 public ??$construct@UTreeStateNode@@U1@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z
.text$mn:0000273C ??$construct@UTreeStateNode@@U1@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z proc near
.text$mn:0000273C                                         ; CODE XREF: std::_Uninit_move<TreeStateNode *,TreeStateNode *,std::allocator<TreeStateNode>,TreeStateNode>(TreeStateNode *,TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,TreeStateNode *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:0000273C                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::push_back(TreeStateNode &&)+9Dp ...
.text$mn:0000273C
.text$mn:0000273C var_4           = dword ptr -4
.text$mn:0000273C arg_0           = dword ptr  8
.text$mn:0000273C arg_4           = dword ptr  0Ch
.text$mn:0000273C
.text$mn:0000273C                 push    ebp
.text$mn:0000273D                 mov     ebp, esp
.text$mn:0000273F                 push    ecx
.text$mn:00002740                 mov     [ebp+var_4], ecx
.text$mn:00002743                 mov     eax, [ebp+arg_4]
.text$mn:00002746                 push    eax
.text$mn:00002747                 call    ??$forward@UTreeStateNode@@@std@@YA$$QAUTreeStateNode@@AAU1@@Z ; std::forward<TreeStateNode>(TreeStateNode &)
.text$mn:0000274C                 add     esp, 4
.text$mn:0000274F                 push    eax             ; int
.text$mn:00002750                 mov     ecx, [ebp+arg_0]
.text$mn:00002753                 push    ecx             ; void *
.text$mn:00002754                 mov     edx, [ebp+var_4]
.text$mn:00002757                 push    edx             ; int
.text$mn:00002758                 call    ??$construct@UTreeStateNode@@U1@@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAXAAV?$allocator@UTreeStateNode@@@1@PAUTreeStateNode@@$$QAU3@@Z ; std::allocator_traits<std::allocator<TreeStateNode>>::construct<TreeStateNode,TreeStateNode>(std::allocator<TreeStateNode> &,TreeStateNode *,TreeStateNode &&)
.text$mn:0000275D                 add     esp, 0Ch
.text$mn:00002760                 mov     esp, ebp
.text$mn:00002762                 pop     ebp
.text$mn:00002763                 retn    8
.text$mn:00002763 ??$construct@UTreeStateNode@@U1@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z endp
.text$mn:00002763
.text$mn:00002763 ; ---------------------------------------------------------------------------
.text$mn:00002766                 align 4
.text$mn:00002766 _text$mn        ends
.text$mn:00002766
.text$mn:00002768 ; ===========================================================================
.text$mn:00002768
.text$mn:00002768 ; Segment type: Pure code
.text$mn:00002768 ; Segment permissions: Read/Execute
.text$mn:00002768 _text$mn        segment para public 'CODE' use32
.text$mn:00002768                 assume cs:_text$mn
.text$mn:00002768                 ;org 2768h
.text$mn:00002768 ; COMDAT (pick any)
.text$mn:00002768                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002768
.text$mn:00002768 ; =============== S U B R O U T I N E =======================================
.text$mn:00002768
.text$mn:00002768 ; Attributes: bp-based frame
.text$mn:00002768
.text$mn:00002768 ; int __stdcall std::allocator<TreeStateNode>::construct<TreeStateNode,TreeStateNode>(void *, int)
.text$mn:00002768                 public ??$construct@UTreeStateNode@@U1@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z
.text$mn:00002768 ??$construct@UTreeStateNode@@U1@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z proc near
.text$mn:00002768                                         ; CODE XREF: std::allocator_traits<std::allocator<TreeStateNode>>::construct<TreeStateNode,TreeStateNode>(std::allocator<TreeStateNode> &,TreeStateNode *,TreeStateNode &&)+17p
.text$mn:00002768
.text$mn:00002768 var_1C          = dword ptr -1Ch
.text$mn:00002768 var_18          = dword ptr -18h
.text$mn:00002768 var_14          = dword ptr -14h
.text$mn:00002768 var_10          = dword ptr -10h
.text$mn:00002768 var_C           = dword ptr -0Ch
.text$mn:00002768 var_4           = dword ptr -4
.text$mn:00002768 arg_0           = dword ptr  8
.text$mn:00002768 arg_4           = dword ptr  0Ch
.text$mn:00002768
.text$mn:00002768                 push    ebp
.text$mn:00002769                 mov     ebp, esp
.text$mn:0000276B                 push    0FFFFFFFFh
.text$mn:0000276D                 push    offset __ehhandler$??$construct@UTreeStateNode@@U1@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z
.text$mn:00002772                 mov     eax, large fs:0
.text$mn:00002778                 push    eax
.text$mn:00002779                 sub     esp, 10h
.text$mn:0000277C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002781                 xor     eax, ebp
.text$mn:00002783                 push    eax
.text$mn:00002784                 lea     eax, [ebp+var_C]
.text$mn:00002787                 mov     large fs:0, eax
.text$mn:0000278D                 mov     [ebp+var_18], ecx
.text$mn:00002790                 mov     eax, [ebp+arg_0]
.text$mn:00002793                 push    eax             ; void *
.text$mn:00002794                 push    4Ch ; 'L'       ; unsigned int
.text$mn:00002796                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000279B                 add     esp, 8
.text$mn:0000279E                 mov     [ebp+var_10], eax
.text$mn:000027A1                 mov     [ebp+var_4], 0
.text$mn:000027A8                 cmp     [ebp+var_10], 0
.text$mn:000027AC                 jz      short loc_27C8
.text$mn:000027AE                 mov     ecx, [ebp+arg_4]
.text$mn:000027B1                 push    ecx
.text$mn:000027B2                 call    ??$forward@UTreeStateNode@@@std@@YA$$QAUTreeStateNode@@AAU1@@Z ; std::forward<TreeStateNode>(TreeStateNode &)
.text$mn:000027B7                 add     esp, 4
.text$mn:000027BA                 push    eax
.text$mn:000027BB                 mov     ecx, [ebp+var_10]
.text$mn:000027BE                 call    ??0TreeStateNode@@QAE@ABU0@@Z ; TreeStateNode::TreeStateNode(TreeStateNode const &)
.text$mn:000027C3                 mov     [ebp+var_14], eax
.text$mn:000027C6                 jmp     short loc_27CF
.text$mn:000027C8 ; ---------------------------------------------------------------------------
.text$mn:000027C8
.text$mn:000027C8 loc_27C8:                               ; CODE XREF: std::allocator<TreeStateNode>::construct<TreeStateNode,TreeStateNode>(TreeStateNode *,TreeStateNode &&)+44j
.text$mn:000027C8                 mov     [ebp+var_14], 0
.text$mn:000027CF
.text$mn:000027CF loc_27CF:                               ; CODE XREF: std::allocator<TreeStateNode>::construct<TreeStateNode,TreeStateNode>(TreeStateNode *,TreeStateNode &&)+5Ej
.text$mn:000027CF                 mov     edx, [ebp+var_14]
.text$mn:000027D2                 mov     [ebp+var_1C], edx
.text$mn:000027D5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000027DC                 mov     ecx, [ebp+var_C]
.text$mn:000027DF                 mov     large fs:0, ecx
.text$mn:000027E6                 pop     ecx
.text$mn:000027E7                 mov     esp, ebp
.text$mn:000027E9                 pop     ebp
.text$mn:000027EA                 retn    8
.text$mn:000027EA ??$construct@UTreeStateNode@@U1@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z endp
.text$mn:000027EA
.text$mn:000027EA ; ---------------------------------------------------------------------------
.text$mn:000027ED                 align 10h
.text$mn:000027ED _text$mn        ends
.text$mn:000027ED
.text$x:000027F0 ; ===========================================================================
.text$x:000027F0
.text$x:000027F0 ; Segment type: Pure code
.text$x:000027F0 ; Segment permissions: Read/Execute
.text$x:000027F0 _text$x         segment para public 'CODE' use32
.text$x:000027F0                 assume cs:_text$x
.text$x:000027F0                 ;org 27F0h
.text$x:000027F0 ; COMDAT (pick associative to section at 2768)
.text$x:000027F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000027F0
.text$x:000027F0 ; =============== S U B R O U T I N E =======================================
.text$x:000027F0
.text$x:000027F0
.text$x:000027F0 __unwindfunclet$??$construct@UTreeStateNode@@U1@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z$0 proc near
.text$x:000027F0                                         ; DATA XREF: .xdata$x:0000788Co
.text$x:000027F0                 mov     eax, [ebp+8]
.text$x:000027F3                 push    eax
.text$x:000027F4                 mov     eax, [ebp-10h]
.text$x:000027F7                 push    eax             ; void *
.text$x:000027F8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000027FD                 add     esp, 8
.text$x:00002800                 retn
.text$x:00002800 __unwindfunclet$??$construct@UTreeStateNode@@U1@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z$0 endp
.text$x:00002800
.text$x:00002801
.text$x:00002801 ; =============== S U B R O U T I N E =======================================
.text$x:00002801
.text$x:00002801
.text$x:00002801 __ehhandler$??$construct@UTreeStateNode@@U1@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z proc near
.text$x:00002801                                         ; DATA XREF: std::allocator<TreeStateNode>::construct<TreeStateNode,TreeStateNode>(TreeStateNode *,TreeStateNode &&)+5o
.text$x:00002801
.text$x:00002801 arg_4           = dword ptr  8
.text$x:00002801
.text$x:00002801                 mov     edx, [esp+arg_4]
.text$x:00002805                 lea     eax, [edx+0Ch]
.text$x:00002808                 mov     ecx, [edx-14h]
.text$x:0000280B                 xor     ecx, eax
.text$x:0000280D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002812                 mov     eax, offset __ehfuncinfo$??$construct@UTreeStateNode@@U1@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z
.text$x:00002817                 jmp     ___CxxFrameHandler3
.text$x:00002817 __ehhandler$??$construct@UTreeStateNode@@U1@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z endp
.text$x:00002817
.text$x:00002817 _text$x         ends
.text$x:00002817
.text$mn:0000281C ; ===========================================================================
.text$mn:0000281C
.text$mn:0000281C ; Segment type: Pure code
.text$mn:0000281C ; Segment permissions: Read/Execute
.text$mn:0000281C _text$mn        segment para public 'CODE' use32
.text$mn:0000281C                 assume cs:_text$mn
.text$mn:0000281C                 ;org 281Ch
.text$mn:0000281C ; COMDAT (pick any)
.text$mn:0000281C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000281C
.text$mn:0000281C ; =============== S U B R O U T I N E =======================================
.text$mn:0000281C
.text$mn:0000281C ; Attributes: bp-based frame
.text$mn:0000281C
.text$mn:0000281C ; int __cdecl std::allocator_traits<std::allocator<TreeStateNode>>::construct<TreeStateNode,TreeStateNode>(int, void *, int)
.text$mn:0000281C                 public ??$construct@UTreeStateNode@@U1@@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAXAAV?$allocator@UTreeStateNode@@@1@PAUTreeStateNode@@$$QAU3@@Z
.text$mn:0000281C ??$construct@UTreeStateNode@@U1@@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAXAAV?$allocator@UTreeStateNode@@@1@PAUTreeStateNode@@$$QAU3@@Z proc near
.text$mn:0000281C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TreeStateNode>>::construct<TreeStateNode,TreeStateNode>(TreeStateNode *,TreeStateNode &&)+1Cp
.text$mn:0000281C
.text$mn:0000281C arg_0           = dword ptr  8
.text$mn:0000281C arg_4           = dword ptr  0Ch
.text$mn:0000281C arg_8           = dword ptr  10h
.text$mn:0000281C
.text$mn:0000281C                 push    ebp
.text$mn:0000281D                 mov     ebp, esp
.text$mn:0000281F                 mov     eax, [ebp+arg_8]
.text$mn:00002822                 push    eax
.text$mn:00002823                 call    ??$forward@UTreeStateNode@@@std@@YA$$QAUTreeStateNode@@AAU1@@Z ; std::forward<TreeStateNode>(TreeStateNode &)
.text$mn:00002828                 add     esp, 4
.text$mn:0000282B                 push    eax             ; int
.text$mn:0000282C                 mov     ecx, [ebp+arg_4]
.text$mn:0000282F                 push    ecx             ; void *
.text$mn:00002830                 mov     ecx, [ebp+arg_0]
.text$mn:00002833                 call    ??$construct@UTreeStateNode@@U1@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z ; std::allocator<TreeStateNode>::construct<TreeStateNode,TreeStateNode>(TreeStateNode *,TreeStateNode &&)
.text$mn:00002838                 pop     ebp
.text$mn:00002839                 retn
.text$mn:00002839 ??$construct@UTreeStateNode@@U1@@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAXAAV?$allocator@UTreeStateNode@@@1@PAUTreeStateNode@@$$QAU3@@Z endp
.text$mn:00002839
.text$mn:00002839 ; ---------------------------------------------------------------------------
.text$mn:0000283A                 align 4
.text$mn:0000283A _text$mn        ends
.text$mn:0000283A
.text$mn:0000283C ; ===========================================================================
.text$mn:0000283C
.text$mn:0000283C ; Segment type: Pure code
.text$mn:0000283C ; Segment permissions: Read/Execute
.text$mn:0000283C _text$mn        segment para public 'CODE' use32
.text$mn:0000283C                 assume cs:_text$mn
.text$mn:0000283C                 ;org 283Ch
.text$mn:0000283C ; COMDAT (pick any)
.text$mn:0000283C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000283C
.text$mn:0000283C ; =============== S U B R O U T I N E =======================================
.text$mn:0000283C
.text$mn:0000283C ; Attributes: bp-based frame
.text$mn:0000283C
.text$mn:0000283C ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:0000283C                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000283C ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:0000283C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Alloc_proxy(void)+32p
.text$mn:0000283C
.text$mn:0000283C var_4           = dword ptr -4
.text$mn:0000283C arg_0           = dword ptr  8
.text$mn:0000283C arg_4           = dword ptr  0Ch
.text$mn:0000283C
.text$mn:0000283C                 push    ebp
.text$mn:0000283D                 mov     ebp, esp
.text$mn:0000283F                 push    ecx
.text$mn:00002840                 mov     [ebp+var_4], ecx
.text$mn:00002843                 mov     eax, [ebp+arg_4]
.text$mn:00002846                 push    eax
.text$mn:00002847                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000284C                 add     esp, 4
.text$mn:0000284F                 push    eax             ; int
.text$mn:00002850                 mov     ecx, [ebp+arg_0]
.text$mn:00002853                 push    ecx             ; void *
.text$mn:00002854                 mov     edx, [ebp+var_4]
.text$mn:00002857                 push    edx             ; int
.text$mn:00002858                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000285D                 add     esp, 0Ch
.text$mn:00002860                 mov     esp, ebp
.text$mn:00002862                 pop     ebp
.text$mn:00002863                 retn    8
.text$mn:00002863 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00002863
.text$mn:00002863 ; ---------------------------------------------------------------------------
.text$mn:00002866                 align 4
.text$mn:00002866 _text$mn        ends
.text$mn:00002866
.text$mn:00002868 ; ===========================================================================
.text$mn:00002868
.text$mn:00002868 ; Segment type: Pure code
.text$mn:00002868 ; Segment permissions: Read/Execute
.text$mn:00002868 _text$mn        segment para public 'CODE' use32
.text$mn:00002868                 assume cs:_text$mn
.text$mn:00002868                 ;org 2868h
.text$mn:00002868 ; COMDAT (pick any)
.text$mn:00002868                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002868
.text$mn:00002868 ; =============== S U B R O U T I N E =======================================
.text$mn:00002868
.text$mn:00002868 ; Attributes: bp-based frame
.text$mn:00002868
.text$mn:00002868 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00002868                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00002868 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00002868                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:00002868                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p ...
.text$mn:00002868
.text$mn:00002868 var_1C          = dword ptr -1Ch
.text$mn:00002868 var_18          = dword ptr -18h
.text$mn:00002868 var_14          = dword ptr -14h
.text$mn:00002868 var_10          = dword ptr -10h
.text$mn:00002868 var_C           = dword ptr -0Ch
.text$mn:00002868 var_4           = dword ptr -4
.text$mn:00002868 arg_0           = dword ptr  8
.text$mn:00002868 arg_4           = dword ptr  0Ch
.text$mn:00002868
.text$mn:00002868                 push    ebp
.text$mn:00002869                 mov     ebp, esp
.text$mn:0000286B                 push    0FFFFFFFFh
.text$mn:0000286D                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00002872                 mov     eax, large fs:0
.text$mn:00002878                 push    eax
.text$mn:00002879                 sub     esp, 10h
.text$mn:0000287C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002881                 xor     eax, ebp
.text$mn:00002883                 push    eax
.text$mn:00002884                 lea     eax, [ebp+var_C]
.text$mn:00002887                 mov     large fs:0, eax
.text$mn:0000288D                 mov     [ebp+var_18], ecx
.text$mn:00002890                 mov     eax, [ebp+arg_0]
.text$mn:00002893                 push    eax             ; void *
.text$mn:00002894                 push    8               ; unsigned int
.text$mn:00002896                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000289B                 add     esp, 8
.text$mn:0000289E                 mov     [ebp+var_10], eax
.text$mn:000028A1                 mov     [ebp+var_4], 0
.text$mn:000028A8                 cmp     [ebp+var_10], 0
.text$mn:000028AC                 jz      short loc_28CF
.text$mn:000028AE                 mov     ecx, [ebp+arg_4]
.text$mn:000028B1                 push    ecx
.text$mn:000028B2                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000028B7                 add     esp, 4
.text$mn:000028BA                 mov     edx, [eax]
.text$mn:000028BC                 mov     eax, [eax+4]
.text$mn:000028BF                 mov     ecx, [ebp+var_10]
.text$mn:000028C2                 mov     [ecx], edx
.text$mn:000028C4                 mov     [ecx+4], eax
.text$mn:000028C7                 mov     edx, [ebp+var_10]
.text$mn:000028CA                 mov     [ebp+var_14], edx
.text$mn:000028CD                 jmp     short loc_28D6
.text$mn:000028CF ; ---------------------------------------------------------------------------
.text$mn:000028CF
.text$mn:000028CF loc_28CF:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:000028CF                 mov     [ebp+var_14], 0
.text$mn:000028D6
.text$mn:000028D6 loc_28D6:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:000028D6                 mov     eax, [ebp+var_14]
.text$mn:000028D9                 mov     [ebp+var_1C], eax
.text$mn:000028DC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000028E3                 mov     ecx, [ebp+var_C]
.text$mn:000028E6                 mov     large fs:0, ecx
.text$mn:000028ED                 pop     ecx
.text$mn:000028EE                 mov     esp, ebp
.text$mn:000028F0                 pop     ebp
.text$mn:000028F1                 retn    8
.text$mn:000028F1 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000028F1
.text$mn:000028F1 _text$mn        ends
.text$mn:000028F1
.text$x:000028F4 ; ===========================================================================
.text$x:000028F4
.text$x:000028F4 ; Segment type: Pure code
.text$x:000028F4 ; Segment permissions: Read/Execute
.text$x:000028F4 _text$x         segment para public 'CODE' use32
.text$x:000028F4                 assume cs:_text$x
.text$x:000028F4                 ;org 28F4h
.text$x:000028F4 ; COMDAT (pick associative to section at 2868)
.text$x:000028F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000028F4
.text$x:000028F4 ; =============== S U B R O U T I N E =======================================
.text$x:000028F4
.text$x:000028F4
.text$x:000028F4 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000028F4                                         ; DATA XREF: .xdata$x:00007860o
.text$x:000028F4                 mov     eax, [ebp+8]
.text$x:000028F7                 push    eax
.text$x:000028F8                 mov     eax, [ebp-10h]
.text$x:000028FB                 push    eax             ; void *
.text$x:000028FC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002901                 add     esp, 8
.text$x:00002904                 retn
.text$x:00002904 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00002904
.text$x:00002905
.text$x:00002905 ; =============== S U B R O U T I N E =======================================
.text$x:00002905
.text$x:00002905
.text$x:00002905 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00002905                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00002905
.text$x:00002905 arg_4           = dword ptr  8
.text$x:00002905
.text$x:00002905                 mov     edx, [esp+arg_4]
.text$x:00002909                 lea     eax, [edx+0Ch]
.text$x:0000290C                 mov     ecx, [edx-14h]
.text$x:0000290F                 xor     ecx, eax
.text$x:00002911                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002916                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:0000291B                 jmp     ___CxxFrameHandler3
.text$x:0000291B __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:0000291B
.text$x:0000291B _text$x         ends
.text$x:0000291B
.text$mn:00002920 ; ===========================================================================
.text$mn:00002920
.text$mn:00002920 ; Segment type: Pure code
.text$mn:00002920 ; Segment permissions: Read/Execute
.text$mn:00002920 _text$mn        segment para public 'CODE' use32
.text$mn:00002920                 assume cs:_text$mn
.text$mn:00002920                 ;org 2920h
.text$mn:00002920 ; COMDAT (pick any)
.text$mn:00002920                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002920
.text$mn:00002920 ; =============== S U B R O U T I N E =======================================
.text$mn:00002920
.text$mn:00002920 ; Attributes: bp-based frame
.text$mn:00002920
.text$mn:00002920 ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:00002920                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00002920 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00002920                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:00002920
.text$mn:00002920 arg_0           = dword ptr  8
.text$mn:00002920 arg_4           = dword ptr  0Ch
.text$mn:00002920 arg_8           = dword ptr  10h
.text$mn:00002920
.text$mn:00002920                 push    ebp
.text$mn:00002921                 mov     ebp, esp
.text$mn:00002923                 mov     eax, [ebp+arg_8]
.text$mn:00002926                 push    eax
.text$mn:00002927                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000292C                 add     esp, 4
.text$mn:0000292F                 push    eax             ; int
.text$mn:00002930                 mov     ecx, [ebp+arg_4]
.text$mn:00002933                 push    ecx             ; void *
.text$mn:00002934                 mov     ecx, [ebp+arg_0]
.text$mn:00002937                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000293C                 pop     ebp
.text$mn:0000293D                 retn
.text$mn:0000293D ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:0000293D
.text$mn:0000293D ; ---------------------------------------------------------------------------
.text$mn:0000293E                 align 10h
.text$mn:0000293E _text$mn        ends
.text$mn:0000293E
.text$mn:00002940 ; ===========================================================================
.text$mn:00002940
.text$mn:00002940 ; Segment type: Pure code
.text$mn:00002940 ; Segment permissions: Read/Execute
.text$mn:00002940 _text$mn        segment para public 'CODE' use32
.text$mn:00002940                 assume cs:_text$mn
.text$mn:00002940                 ;org 2940h
.text$mn:00002940 ; COMDAT (pick any)
.text$mn:00002940                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002940
.text$mn:00002940 ; =============== S U B R O U T I N E =======================================
.text$mn:00002940
.text$mn:00002940 ; Attributes: bp-based frame
.text$mn:00002940
.text$mn:00002940 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00002940                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00002940 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00002940                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00002940
.text$mn:00002940 var_4           = dword ptr -4
.text$mn:00002940 arg_0           = dword ptr  8
.text$mn:00002940
.text$mn:00002940                 push    ebp
.text$mn:00002941                 mov     ebp, esp
.text$mn:00002943                 push    ecx
.text$mn:00002944                 mov     [ebp+var_4], ecx
.text$mn:00002947                 mov     eax, [ebp+arg_0]
.text$mn:0000294A                 push    eax
.text$mn:0000294B                 mov     ecx, [ebp+var_4]
.text$mn:0000294E                 push    ecx
.text$mn:0000294F                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00002954                 add     esp, 8
.text$mn:00002957                 mov     esp, ebp
.text$mn:00002959                 pop     ebp
.text$mn:0000295A                 retn    4
.text$mn:0000295A ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:0000295A
.text$mn:0000295A ; ---------------------------------------------------------------------------
.text$mn:0000295D                 align 10h
.text$mn:0000295D _text$mn        ends
.text$mn:0000295D
.text$mn:00002960 ; ===========================================================================
.text$mn:00002960
.text$mn:00002960 ; Segment type: Pure code
.text$mn:00002960 ; Segment permissions: Read/Execute
.text$mn:00002960 _text$mn        segment para public 'CODE' use32
.text$mn:00002960                 assume cs:_text$mn
.text$mn:00002960                 ;org 2960h
.text$mn:00002960 ; COMDAT (pick any)
.text$mn:00002960                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002960
.text$mn:00002960 ; =============== S U B R O U T I N E =======================================
.text$mn:00002960
.text$mn:00002960 ; Attributes: bp-based frame
.text$mn:00002960
.text$mn:00002960 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00002960                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00002960 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00002960                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00002960
.text$mn:00002960 var_4           = dword ptr -4
.text$mn:00002960
.text$mn:00002960                 push    ebp
.text$mn:00002961                 mov     ebp, esp
.text$mn:00002963                 push    ecx
.text$mn:00002964                 mov     [ebp+var_4], ecx
.text$mn:00002967                 mov     esp, ebp
.text$mn:00002969                 pop     ebp
.text$mn:0000296A                 retn    4
.text$mn:0000296A ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:0000296A
.text$mn:0000296A ; ---------------------------------------------------------------------------
.text$mn:0000296D                 align 10h
.text$mn:0000296D _text$mn        ends
.text$mn:0000296D
.text$mn:00002970 ; ===========================================================================
.text$mn:00002970
.text$mn:00002970 ; Segment type: Pure code
.text$mn:00002970 ; Segment permissions: Read/Execute
.text$mn:00002970 _text$mn        segment para public 'CODE' use32
.text$mn:00002970                 assume cs:_text$mn
.text$mn:00002970                 ;org 2970h
.text$mn:00002970 ; COMDAT (pick any)
.text$mn:00002970                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002970
.text$mn:00002970 ; =============== S U B R O U T I N E =======================================
.text$mn:00002970
.text$mn:00002970 ; Attributes: bp-based frame
.text$mn:00002970
.text$mn:00002970 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00002970                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00002970 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00002970                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00002970
.text$mn:00002970 arg_0           = dword ptr  8
.text$mn:00002970 arg_4           = dword ptr  0Ch
.text$mn:00002970
.text$mn:00002970                 push    ebp
.text$mn:00002971                 mov     ebp, esp
.text$mn:00002973                 mov     eax, [ebp+arg_4]
.text$mn:00002976                 push    eax
.text$mn:00002977                 mov     ecx, [ebp+arg_0]
.text$mn:0000297A                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:0000297F                 pop     ebp
.text$mn:00002980                 retn
.text$mn:00002980 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00002980
.text$mn:00002980 ; ---------------------------------------------------------------------------
.text$mn:00002981                 align 4
.text$mn:00002981 _text$mn        ends
.text$mn:00002981
.text$mn:00002984 ; ===========================================================================
.text$mn:00002984
.text$mn:00002984 ; Segment type: Pure code
.text$mn:00002984 ; Segment permissions: Read/Execute
.text$mn:00002984 _text$mn        segment para public 'CODE' use32
.text$mn:00002984                 assume cs:_text$mn
.text$mn:00002984                 ;org 2984h
.text$mn:00002984 ; COMDAT (pick any)
.text$mn:00002984                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002984
.text$mn:00002984 ; =============== S U B R O U T I N E =======================================
.text$mn:00002984
.text$mn:00002984 ; Attributes: bp-based frame
.text$mn:00002984
.text$mn:00002984 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00002984                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:00002984 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:00002984                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:00002984
.text$mn:00002984 var_4           = dword ptr -4
.text$mn:00002984 arg_0           = dword ptr  8
.text$mn:00002984
.text$mn:00002984                 push    ebp
.text$mn:00002985                 mov     ebp, esp
.text$mn:00002987                 push    ecx
.text$mn:00002988                 mov     [ebp+var_4], ecx
.text$mn:0000298B                 mov     eax, [ebp+arg_0]
.text$mn:0000298E                 push    eax
.text$mn:0000298F                 mov     ecx, [ebp+var_4]
.text$mn:00002992                 push    ecx
.text$mn:00002993                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00002998                 add     esp, 8
.text$mn:0000299B                 mov     esp, ebp
.text$mn:0000299D                 pop     ebp
.text$mn:0000299E                 retn    4
.text$mn:0000299E ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:0000299E
.text$mn:0000299E ; ---------------------------------------------------------------------------
.text$mn:000029A1                 align 4
.text$mn:000029A1 _text$mn        ends
.text$mn:000029A1
.text$mn:000029A4 ; ===========================================================================
.text$mn:000029A4
.text$mn:000029A4 ; Segment type: Pure code
.text$mn:000029A4 ; Segment permissions: Read/Execute
.text$mn:000029A4 _text$mn        segment para public 'CODE' use32
.text$mn:000029A4                 assume cs:_text$mn
.text$mn:000029A4                 ;org 29A4h
.text$mn:000029A4 ; COMDAT (pick any)
.text$mn:000029A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029A4
.text$mn:000029A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029A4
.text$mn:000029A4 ; Attributes: bp-based frame
.text$mn:000029A4
.text$mn:000029A4 ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:000029A4                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:000029A4 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:000029A4                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:000029A4
.text$mn:000029A4 var_4           = dword ptr -4
.text$mn:000029A4
.text$mn:000029A4                 push    ebp
.text$mn:000029A5                 mov     ebp, esp
.text$mn:000029A7                 push    ecx
.text$mn:000029A8                 mov     [ebp+var_4], ecx
.text$mn:000029AB                 mov     esp, ebp
.text$mn:000029AD                 pop     ebp
.text$mn:000029AE                 retn    4
.text$mn:000029AE ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:000029AE
.text$mn:000029AE ; ---------------------------------------------------------------------------
.text$mn:000029B1                 align 4
.text$mn:000029B1 _text$mn        ends
.text$mn:000029B1
.text$mn:000029B4 ; ===========================================================================
.text$mn:000029B4
.text$mn:000029B4 ; Segment type: Pure code
.text$mn:000029B4 ; Segment permissions: Read/Execute
.text$mn:000029B4 _text$mn        segment para public 'CODE' use32
.text$mn:000029B4                 assume cs:_text$mn
.text$mn:000029B4                 ;org 29B4h
.text$mn:000029B4 ; COMDAT (pick any)
.text$mn:000029B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029B4
.text$mn:000029B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029B4
.text$mn:000029B4 ; Attributes: bp-based frame
.text$mn:000029B4
.text$mn:000029B4 ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:000029B4                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:000029B4 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:000029B4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:000029B4
.text$mn:000029B4 arg_0           = dword ptr  8
.text$mn:000029B4 arg_4           = dword ptr  0Ch
.text$mn:000029B4
.text$mn:000029B4                 push    ebp
.text$mn:000029B5                 mov     ebp, esp
.text$mn:000029B7                 mov     eax, [ebp+arg_4]
.text$mn:000029BA                 push    eax
.text$mn:000029BB                 mov     ecx, [ebp+arg_0]
.text$mn:000029BE                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:000029C3                 pop     ebp
.text$mn:000029C4                 retn
.text$mn:000029C4 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:000029C4
.text$mn:000029C4 ; ---------------------------------------------------------------------------
.text$mn:000029C5                 align 4
.text$mn:000029C5 _text$mn        ends
.text$mn:000029C5
.text$mn:000029C8 ; ===========================================================================
.text$mn:000029C8
.text$mn:000029C8 ; Segment type: Pure code
.text$mn:000029C8 ; Segment permissions: Read/Execute
.text$mn:000029C8 _text$mn        segment para public 'CODE' use32
.text$mn:000029C8                 assume cs:_text$mn
.text$mn:000029C8                 ;org 29C8h
.text$mn:000029C8 ; COMDAT (pick any)
.text$mn:000029C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029C8
.text$mn:000029C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000029C8
.text$mn:000029C8 ; Attributes: bp-based frame
.text$mn:000029C8
.text$mn:000029C8 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct TreeStateNode>>::destroy<struct TreeStateNode>(struct TreeStateNode *)
.text$mn:000029C8                 public ??$destroy@UTreeStateNode@@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@@Z
.text$mn:000029C8 ??$destroy@UTreeStateNode@@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@@Z proc near
.text$mn:000029C8                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:000029C8                                         ; __catch$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap ...
.text$mn:000029C8
.text$mn:000029C8 var_4           = dword ptr -4
.text$mn:000029C8 arg_0           = dword ptr  8
.text$mn:000029C8
.text$mn:000029C8                 push    ebp
.text$mn:000029C9                 mov     ebp, esp
.text$mn:000029CB                 push    ecx
.text$mn:000029CC                 mov     [ebp+var_4], ecx
.text$mn:000029CF                 mov     eax, [ebp+arg_0]
.text$mn:000029D2                 push    eax
.text$mn:000029D3                 mov     ecx, [ebp+var_4]
.text$mn:000029D6                 push    ecx
.text$mn:000029D7                 call    ??$destroy@UTreeStateNode@@@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAXAAV?$allocator@UTreeStateNode@@@1@PAUTreeStateNode@@@Z ; std::allocator_traits<std::allocator<TreeStateNode>>::destroy<TreeStateNode>(std::allocator<TreeStateNode> &,TreeStateNode *)
.text$mn:000029DC                 add     esp, 8
.text$mn:000029DF                 mov     esp, ebp
.text$mn:000029E1                 pop     ebp
.text$mn:000029E2                 retn    4
.text$mn:000029E2 ??$destroy@UTreeStateNode@@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@@Z endp
.text$mn:000029E2
.text$mn:000029E2 ; ---------------------------------------------------------------------------
.text$mn:000029E5                 align 4
.text$mn:000029E5 _text$mn        ends
.text$mn:000029E5
.text$mn:000029E8 ; ===========================================================================
.text$mn:000029E8
.text$mn:000029E8 ; Segment type: Pure code
.text$mn:000029E8 ; Segment permissions: Read/Execute
.text$mn:000029E8 _text$mn        segment para public 'CODE' use32
.text$mn:000029E8                 assume cs:_text$mn
.text$mn:000029E8                 ;org 29E8h
.text$mn:000029E8 ; COMDAT (pick any)
.text$mn:000029E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029E8
.text$mn:000029E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000029E8
.text$mn:000029E8 ; Attributes: bp-based frame
.text$mn:000029E8
.text$mn:000029E8 ; public: void __thiscall std::allocator<struct TreeStateNode>::destroy<struct TreeStateNode>(struct TreeStateNode *)
.text$mn:000029E8                 public ??$destroy@UTreeStateNode@@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@@Z
.text$mn:000029E8 ??$destroy@UTreeStateNode@@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@@Z proc near
.text$mn:000029E8                                         ; CODE XREF: std::allocator_traits<std::allocator<TreeStateNode>>::destroy<TreeStateNode>(std::allocator<TreeStateNode> &,TreeStateNode *)+Ap
.text$mn:000029E8
.text$mn:000029E8 var_4           = dword ptr -4
.text$mn:000029E8 arg_0           = dword ptr  8
.text$mn:000029E8
.text$mn:000029E8                 push    ebp
.text$mn:000029E9                 mov     ebp, esp
.text$mn:000029EB                 push    ecx
.text$mn:000029EC                 mov     [ebp+var_4], ecx
.text$mn:000029EF                 push    0
.text$mn:000029F1                 mov     ecx, [ebp+arg_0]
.text$mn:000029F4                 call    ??_GTreeStateNode@@QAEPAXI@Z ; TreeStateNode::`scalar deleting destructor'(uint)
.text$mn:000029F9                 mov     esp, ebp
.text$mn:000029FB                 pop     ebp
.text$mn:000029FC                 retn    4
.text$mn:000029FC ??$destroy@UTreeStateNode@@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@@Z endp
.text$mn:000029FC
.text$mn:000029FC ; ---------------------------------------------------------------------------
.text$mn:000029FF                 align 10h
.text$mn:000029FF _text$mn        ends
.text$mn:000029FF
.text$mn:00002A00 ; ===========================================================================
.text$mn:00002A00
.text$mn:00002A00 ; Segment type: Pure code
.text$mn:00002A00 ; Segment permissions: Read/Execute
.text$mn:00002A00 _text$mn        segment para public 'CODE' use32
.text$mn:00002A00                 assume cs:_text$mn
.text$mn:00002A00                 ;org 2A00h
.text$mn:00002A00 ; COMDAT (pick any)
.text$mn:00002A00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A00
.text$mn:00002A00 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A00
.text$mn:00002A00 ; Attributes: bp-based frame
.text$mn:00002A00
.text$mn:00002A00 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct TreeStateNode>>::destroy<struct TreeStateNode>(class std::allocator<struct TreeStateNode> &, struct TreeStateNode *)
.text$mn:00002A00                 public ??$destroy@UTreeStateNode@@@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAXAAV?$allocator@UTreeStateNode@@@1@PAUTreeStateNode@@@Z
.text$mn:00002A00 ??$destroy@UTreeStateNode@@@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAXAAV?$allocator@UTreeStateNode@@@1@PAUTreeStateNode@@@Z proc near
.text$mn:00002A00                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TreeStateNode>>::destroy<TreeStateNode>(TreeStateNode *)+Fp
.text$mn:00002A00
.text$mn:00002A00 arg_0           = dword ptr  8
.text$mn:00002A00 arg_4           = dword ptr  0Ch
.text$mn:00002A00
.text$mn:00002A00                 push    ebp
.text$mn:00002A01                 mov     ebp, esp
.text$mn:00002A03                 mov     eax, [ebp+arg_4]
.text$mn:00002A06                 push    eax
.text$mn:00002A07                 mov     ecx, [ebp+arg_0]
.text$mn:00002A0A                 call    ??$destroy@UTreeStateNode@@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@@Z ; std::allocator<TreeStateNode>::destroy<TreeStateNode>(TreeStateNode *)
.text$mn:00002A0F                 pop     ebp
.text$mn:00002A10                 retn
.text$mn:00002A10 ??$destroy@UTreeStateNode@@@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAXAAV?$allocator@UTreeStateNode@@@1@PAUTreeStateNode@@@Z endp
.text$mn:00002A10
.text$mn:00002A10 ; ---------------------------------------------------------------------------
.text$mn:00002A11                 align 4
.text$mn:00002A11 _text$mn        ends
.text$mn:00002A11
.text$mn:00002A14 ; ===========================================================================
.text$mn:00002A14
.text$mn:00002A14 ; Segment type: Pure code
.text$mn:00002A14 ; Segment permissions: Read/Execute
.text$mn:00002A14 _text$mn        segment para public 'CODE' use32
.text$mn:00002A14                 assume cs:_text$mn
.text$mn:00002A14                 ;org 2A14h
.text$mn:00002A14 ; COMDAT (pick any)
.text$mn:00002A14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A14
.text$mn:00002A14 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A14
.text$mn:00002A14 ; Attributes: bp-based frame
.text$mn:00002A14
.text$mn:00002A14 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00002A14                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00002A14 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00002A14                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Free_proxy(void)+22p
.text$mn:00002A14
.text$mn:00002A14 var_4           = dword ptr -4
.text$mn:00002A14 arg_0           = dword ptr  8
.text$mn:00002A14
.text$mn:00002A14                 push    ebp
.text$mn:00002A15                 mov     ebp, esp
.text$mn:00002A17                 push    ecx
.text$mn:00002A18                 mov     [ebp+var_4], ecx
.text$mn:00002A1B                 mov     eax, [ebp+arg_0]
.text$mn:00002A1E                 push    eax
.text$mn:00002A1F                 mov     ecx, [ebp+var_4]
.text$mn:00002A22                 push    ecx
.text$mn:00002A23                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:00002A28                 add     esp, 8
.text$mn:00002A2B                 mov     esp, ebp
.text$mn:00002A2D                 pop     ebp
.text$mn:00002A2E                 retn    4
.text$mn:00002A2E ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00002A2E
.text$mn:00002A2E ; ---------------------------------------------------------------------------
.text$mn:00002A31                 align 4
.text$mn:00002A31 _text$mn        ends
.text$mn:00002A31
.text$mn:00002A34 ; ===========================================================================
.text$mn:00002A34
.text$mn:00002A34 ; Segment type: Pure code
.text$mn:00002A34 ; Segment permissions: Read/Execute
.text$mn:00002A34 _text$mn        segment para public 'CODE' use32
.text$mn:00002A34                 assume cs:_text$mn
.text$mn:00002A34                 ;org 2A34h
.text$mn:00002A34 ; COMDAT (pick any)
.text$mn:00002A34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A34
.text$mn:00002A34 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A34
.text$mn:00002A34 ; Attributes: bp-based frame
.text$mn:00002A34
.text$mn:00002A34 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00002A34                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00002A34 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00002A34                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:00002A34                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p ...
.text$mn:00002A34
.text$mn:00002A34 var_4           = dword ptr -4
.text$mn:00002A34
.text$mn:00002A34                 push    ebp
.text$mn:00002A35                 mov     ebp, esp
.text$mn:00002A37                 push    ecx
.text$mn:00002A38                 mov     [ebp+var_4], ecx
.text$mn:00002A3B                 mov     esp, ebp
.text$mn:00002A3D                 pop     ebp
.text$mn:00002A3E                 retn    4
.text$mn:00002A3E ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00002A3E
.text$mn:00002A3E ; ---------------------------------------------------------------------------
.text$mn:00002A41                 align 4
.text$mn:00002A41 _text$mn        ends
.text$mn:00002A41
.text$mn:00002A44 ; ===========================================================================
.text$mn:00002A44
.text$mn:00002A44 ; Segment type: Pure code
.text$mn:00002A44 ; Segment permissions: Read/Execute
.text$mn:00002A44 _text$mn        segment para public 'CODE' use32
.text$mn:00002A44                 assume cs:_text$mn
.text$mn:00002A44                 ;org 2A44h
.text$mn:00002A44 ; COMDAT (pick any)
.text$mn:00002A44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A44
.text$mn:00002A44 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A44
.text$mn:00002A44 ; Attributes: bp-based frame
.text$mn:00002A44
.text$mn:00002A44 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:00002A44                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:00002A44 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:00002A44                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:00002A44
.text$mn:00002A44 arg_0           = dword ptr  8
.text$mn:00002A44 arg_4           = dword ptr  0Ch
.text$mn:00002A44
.text$mn:00002A44                 push    ebp
.text$mn:00002A45                 mov     ebp, esp
.text$mn:00002A47                 mov     eax, [ebp+arg_4]
.text$mn:00002A4A                 push    eax
.text$mn:00002A4B                 mov     ecx, [ebp+arg_0]
.text$mn:00002A4E                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00002A53                 pop     ebp
.text$mn:00002A54                 retn
.text$mn:00002A54 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:00002A54
.text$mn:00002A54 ; ---------------------------------------------------------------------------
.text$mn:00002A55                 align 4
.text$mn:00002A55 _text$mn        ends
.text$mn:00002A55
.text$mn:00002A58 ; ===========================================================================
.text$mn:00002A58
.text$mn:00002A58 ; Segment type: Pure code
.text$mn:00002A58 ; Segment permissions: Read/Execute
.text$mn:00002A58 _text$mn        segment para public 'CODE' use32
.text$mn:00002A58                 assume cs:_text$mn
.text$mn:00002A58                 ;org 2A58h
.text$mn:00002A58 ; COMDAT (pick any)
.text$mn:00002A58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A58
.text$mn:00002A58 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A58
.text$mn:00002A58 ; Attributes: bp-based frame
.text$mn:00002A58
.text$mn:00002A58 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00002A58                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00002A58 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00002A58                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00002A58                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00002A58
.text$mn:00002A58 arg_0           = dword ptr  8
.text$mn:00002A58
.text$mn:00002A58                 push    ebp
.text$mn:00002A59                 mov     ebp, esp
.text$mn:00002A5B                 mov     eax, [ebp+arg_0]
.text$mn:00002A5E                 pop     ebp
.text$mn:00002A5F                 retn
.text$mn:00002A5F ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00002A5F
.text$mn:00002A5F _text$mn        ends
.text$mn:00002A5F
.text$mn:00002A60 ; ===========================================================================
.text$mn:00002A60
.text$mn:00002A60 ; Segment type: Pure code
.text$mn:00002A60 ; Segment permissions: Read/Execute
.text$mn:00002A60 _text$mn        segment para public 'CODE' use32
.text$mn:00002A60                 assume cs:_text$mn
.text$mn:00002A60                 ;org 2A60h
.text$mn:00002A60 ; COMDAT (pick any)
.text$mn:00002A60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A60
.text$mn:00002A60 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A60
.text$mn:00002A60 ; Attributes: bp-based frame
.text$mn:00002A60
.text$mn:00002A60 ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00002A60                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:00002A60 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:00002A60                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:00002A60                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:00002A60
.text$mn:00002A60 arg_0           = dword ptr  8
.text$mn:00002A60
.text$mn:00002A60                 push    ebp
.text$mn:00002A61                 mov     ebp, esp
.text$mn:00002A63                 mov     eax, [ebp+arg_0]
.text$mn:00002A66                 pop     ebp
.text$mn:00002A67                 retn
.text$mn:00002A67 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:00002A67
.text$mn:00002A67 _text$mn        ends
.text$mn:00002A67
.text$mn:00002A68 ; ===========================================================================
.text$mn:00002A68
.text$mn:00002A68 ; Segment type: Pure code
.text$mn:00002A68 ; Segment permissions: Read/Execute
.text$mn:00002A68 _text$mn        segment para public 'CODE' use32
.text$mn:00002A68                 assume cs:_text$mn
.text$mn:00002A68                 ;org 2A68h
.text$mn:00002A68 ; COMDAT (pick any)
.text$mn:00002A68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A68
.text$mn:00002A68 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A68
.text$mn:00002A68 ; Attributes: bp-based frame
.text$mn:00002A68
.text$mn:00002A68 ; struct TreeStateNode const & __cdecl std::forward<struct TreeStateNode const &>(struct TreeStateNode const &)
.text$mn:00002A68                 public ??$forward@ABUTreeStateNode@@@std@@YAABUTreeStateNode@@ABU1@@Z
.text$mn:00002A68 ??$forward@ABUTreeStateNode@@@std@@YAABUTreeStateNode@@ABU1@@Z proc near
.text$mn:00002A68                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TreeStateNode>>::construct<TreeStateNode,TreeStateNode const &>(TreeStateNode *,TreeStateNode const &)+Bp
.text$mn:00002A68                                         ; std::allocator_traits<std::allocator<TreeStateNode>>::construct<TreeStateNode,TreeStateNode const &>(std::allocator<TreeStateNode> &,TreeStateNode *,TreeStateNode const &)+7p
.text$mn:00002A68
.text$mn:00002A68 arg_0           = dword ptr  8
.text$mn:00002A68
.text$mn:00002A68                 push    ebp
.text$mn:00002A69                 mov     ebp, esp
.text$mn:00002A6B                 mov     eax, [ebp+arg_0]
.text$mn:00002A6E                 pop     ebp
.text$mn:00002A6F                 retn
.text$mn:00002A6F ??$forward@ABUTreeStateNode@@@std@@YAABUTreeStateNode@@ABU1@@Z endp
.text$mn:00002A6F
.text$mn:00002A6F _text$mn        ends
.text$mn:00002A6F
.text$mn:00002A70 ; ===========================================================================
.text$mn:00002A70
.text$mn:00002A70 ; Segment type: Pure code
.text$mn:00002A70 ; Segment permissions: Read/Execute
.text$mn:00002A70 _text$mn        segment para public 'CODE' use32
.text$mn:00002A70                 assume cs:_text$mn
.text$mn:00002A70                 ;org 2A70h
.text$mn:00002A70 ; COMDAT (pick any)
.text$mn:00002A70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A70
.text$mn:00002A70 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A70
.text$mn:00002A70 ; Attributes: bp-based frame
.text$mn:00002A70
.text$mn:00002A70 ; struct TreeStateNode && __cdecl std::forward<struct TreeStateNode>(struct TreeStateNode &)
.text$mn:00002A70                 public ??$forward@UTreeStateNode@@@std@@YA$$QAUTreeStateNode@@AAU1@@Z
.text$mn:00002A70 ??$forward@UTreeStateNode@@@std@@YA$$QAUTreeStateNode@@AAU1@@Z proc near
.text$mn:00002A70                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TreeStateNode>>::construct<TreeStateNode,TreeStateNode>(TreeStateNode *,TreeStateNode &&)+Bp
.text$mn:00002A70                                         ; std::allocator<TreeStateNode>::construct<TreeStateNode,TreeStateNode>(TreeStateNode *,TreeStateNode &&)+4Ap ...
.text$mn:00002A70
.text$mn:00002A70 arg_0           = dword ptr  8
.text$mn:00002A70
.text$mn:00002A70                 push    ebp
.text$mn:00002A71                 mov     ebp, esp
.text$mn:00002A73                 mov     eax, [ebp+arg_0]
.text$mn:00002A76                 pop     ebp
.text$mn:00002A77                 retn
.text$mn:00002A77 ??$forward@UTreeStateNode@@@std@@YA$$QAUTreeStateNode@@AAU1@@Z endp
.text$mn:00002A77
.text$mn:00002A77 _text$mn        ends
.text$mn:00002A77
.text$mn:00002A78 ; ===========================================================================
.text$mn:00002A78
.text$mn:00002A78 ; Segment type: Pure code
.text$mn:00002A78 ; Segment permissions: Read/Execute
.text$mn:00002A78 _text$mn        segment para public 'CODE' use32
.text$mn:00002A78                 assume cs:_text$mn
.text$mn:00002A78                 ;org 2A78h
.text$mn:00002A78 ; COMDAT (pick any)
.text$mn:00002A78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A78
.text$mn:00002A78 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A78
.text$mn:00002A78 ; Attributes: bp-based frame
.text$mn:00002A78
.text$mn:00002A78 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00002A78                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00002A78 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00002A78                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp
.text$mn:00002A78                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap ...
.text$mn:00002A78
.text$mn:00002A78 arg_0           = dword ptr  8
.text$mn:00002A78
.text$mn:00002A78                 push    ebp
.text$mn:00002A79                 mov     ebp, esp
.text$mn:00002A7B                 mov     eax, [ebp+arg_0]
.text$mn:00002A7E                 pop     ebp
.text$mn:00002A7F                 retn
.text$mn:00002A7F ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00002A7F
.text$mn:00002A7F _text$mn        ends
.text$mn:00002A7F
.text$mn:00002A80 ; ===========================================================================
.text$mn:00002A80
.text$mn:00002A80 ; Segment type: Pure code
.text$mn:00002A80 ; Segment permissions: Read/Execute
.text$mn:00002A80 _text$mn        segment para public 'CODE' use32
.text$mn:00002A80                 assume cs:_text$mn
.text$mn:00002A80                 ;org 2A80h
.text$mn:00002A80 ; COMDAT (pick any)
.text$mn:00002A80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A80
.text$mn:00002A80 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A80
.text$mn:00002A80 ; Attributes: bp-based frame
.text$mn:00002A80
.text$mn:00002A80 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00002A80                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00002A80 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00002A80                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>> const &)+2Dp
.text$mn:00002A80
.text$mn:00002A80 var_10          = dword ptr -10h
.text$mn:00002A80 var_C           = dword ptr -0Ch
.text$mn:00002A80 var_4           = dword ptr -4
.text$mn:00002A80 arg_0           = dword ptr  8
.text$mn:00002A80
.text$mn:00002A80                 push    ebp
.text$mn:00002A81                 mov     ebp, esp
.text$mn:00002A83                 push    0FFFFFFFFh
.text$mn:00002A85                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00002A8A                 mov     eax, large fs:0
.text$mn:00002A90                 push    eax
.text$mn:00002A91                 push    ecx
.text$mn:00002A92                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002A97                 xor     eax, ebp
.text$mn:00002A99                 push    eax
.text$mn:00002A9A                 lea     eax, [ebp+var_C]
.text$mn:00002A9D                 mov     large fs:0, eax
.text$mn:00002AA3                 mov     [ebp+var_10], ecx
.text$mn:00002AA6                 mov     eax, [ebp+arg_0]
.text$mn:00002AA9                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002AAA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002AAD                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:00002AB2                 mov     [ebp+var_4], 0
.text$mn:00002AB9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002AC0                 mov     eax, [ebp+var_10]
.text$mn:00002AC3                 mov     ecx, [ebp+var_C]
.text$mn:00002AC6                 mov     large fs:0, ecx
.text$mn:00002ACD                 pop     ecx
.text$mn:00002ACE                 mov     esp, ebp
.text$mn:00002AD0                 pop     ebp
.text$mn:00002AD1                 retn    4
.text$mn:00002AD1 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:00002AD1
.text$mn:00002AD1 _text$mn        ends
.text$mn:00002AD1
.text$x:00002AD4 ; ===========================================================================
.text$x:00002AD4
.text$x:00002AD4 ; Segment type: Pure code
.text$x:00002AD4 ; Segment permissions: Read/Execute
.text$x:00002AD4 _text$x         segment para public 'CODE' use32
.text$x:00002AD4                 assume cs:_text$x
.text$x:00002AD4                 ;org 2AD4h
.text$x:00002AD4 ; COMDAT (pick associative to section at 2A80)
.text$x:00002AD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002AD4
.text$x:00002AD4 ; =============== S U B R O U T I N E =======================================
.text$x:00002AD4
.text$x:00002AD4
.text$x:00002AD4 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:00002AD4                                         ; DATA XREF: .xdata$x:000077B0o
.text$x:00002AD4                 mov     ecx, [ebp-10h]  ; this
.text$x:00002AD7                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00002AD7 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:00002AD7
.text$x:00002ADC
.text$x:00002ADC ; =============== S U B R O U T I N E =======================================
.text$x:00002ADC
.text$x:00002ADC
.text$x:00002ADC __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:00002ADC                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12> const &)+5o
.text$x:00002ADC
.text$x:00002ADC arg_4           = dword ptr  8
.text$x:00002ADC
.text$x:00002ADC                 mov     edx, [esp+arg_4]
.text$x:00002AE0                 lea     eax, [edx+0Ch]
.text$x:00002AE3                 mov     ecx, [edx-8]
.text$x:00002AE6                 xor     ecx, eax
.text$x:00002AE8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002AED                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:00002AF2                 jmp     ___CxxFrameHandler3
.text$x:00002AF2 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:00002AF2
.text$x:00002AF2 ; ---------------------------------------------------------------------------
.text$x:00002AF7                 align 4
.text$x:00002AF7 _text$x         ends
.text$x:00002AF7
.text$mn:00002AF8 ; ===========================================================================
.text$mn:00002AF8
.text$mn:00002AF8 ; Segment type: Pure code
.text$mn:00002AF8 ; Segment permissions: Read/Execute
.text$mn:00002AF8 _text$mn        segment para public 'CODE' use32
.text$mn:00002AF8                 assume cs:_text$mn
.text$mn:00002AF8                 ;org 2AF8h
.text$mn:00002AF8 ; COMDAT (pick any)
.text$mn:00002AF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AF8
.text$mn:00002AF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AF8
.text$mn:00002AF8 ; Attributes: bp-based frame
.text$mn:00002AF8
.text$mn:00002AF8 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct TreeStateNode, int, struct TreeStateNode const *, struct TreeStateNode const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, struct TreeStateNode, int, struct TreeStateNode const *, struct TreeStateNode const &, struct std::_Iterator_base12>(void)
.text$mn:00002AF8                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00002AF8 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00002AF8                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(TreeStateNode *,std::_Container_base12 const *)+29p
.text$mn:00002AF8
.text$mn:00002AF8 var_10          = dword ptr -10h
.text$mn:00002AF8 var_C           = dword ptr -0Ch
.text$mn:00002AF8 var_4           = dword ptr -4
.text$mn:00002AF8
.text$mn:00002AF8                 push    ebp
.text$mn:00002AF9                 mov     ebp, esp
.text$mn:00002AFB                 push    0FFFFFFFFh
.text$mn:00002AFD                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00002B02                 mov     eax, large fs:0
.text$mn:00002B08                 push    eax
.text$mn:00002B09                 push    ecx
.text$mn:00002B0A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B0F                 xor     eax, ebp
.text$mn:00002B11                 push    eax
.text$mn:00002B12                 lea     eax, [ebp+var_C]
.text$mn:00002B15                 mov     large fs:0, eax
.text$mn:00002B1B                 mov     [ebp+var_10], ecx
.text$mn:00002B1E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002B21                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00002B26                 mov     [ebp+var_4], 0
.text$mn:00002B2D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002B34                 mov     eax, [ebp+var_10]
.text$mn:00002B37                 mov     ecx, [ebp+var_C]
.text$mn:00002B3A                 mov     large fs:0, ecx
.text$mn:00002B41                 pop     ecx
.text$mn:00002B42                 mov     esp, ebp
.text$mn:00002B44                 pop     ebp
.text$mn:00002B45                 retn
.text$mn:00002B45 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00002B45
.text$mn:00002B45 ; ---------------------------------------------------------------------------
.text$mn:00002B46                 align 4
.text$mn:00002B46 _text$mn        ends
.text$mn:00002B46
.text$x:00002B48 ; ===========================================================================
.text$x:00002B48
.text$x:00002B48 ; Segment type: Pure code
.text$x:00002B48 ; Segment permissions: Read/Execute
.text$x:00002B48 _text$x         segment para public 'CODE' use32
.text$x:00002B48                 assume cs:_text$x
.text$x:00002B48                 ;org 2B48h
.text$x:00002B48 ; COMDAT (pick associative to section at 2AF8)
.text$x:00002B48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002B48
.text$x:00002B48 ; =============== S U B R O U T I N E =======================================
.text$x:00002B48
.text$x:00002B48
.text$x:00002B48 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00002B48                                         ; DATA XREF: .xdata$x:00007758o
.text$x:00002B48                 mov     ecx, [ebp-10h]  ; this
.text$x:00002B4B                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00002B4B __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00002B4B
.text$x:00002B50
.text$x:00002B50 ; =============== S U B R O U T I N E =======================================
.text$x:00002B50
.text$x:00002B50
.text$x:00002B50 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00002B50                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>(void)+5o
.text$x:00002B50
.text$x:00002B50 arg_4           = dword ptr  8
.text$x:00002B50
.text$x:00002B50                 mov     edx, [esp+arg_4]
.text$x:00002B54                 lea     eax, [edx+0Ch]
.text$x:00002B57                 mov     ecx, [edx-8]
.text$x:00002B5A                 xor     ecx, eax
.text$x:00002B5C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B61                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00002B66                 jmp     ___CxxFrameHandler3
.text$x:00002B66 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00002B66
.text$x:00002B66 ; ---------------------------------------------------------------------------
.text$x:00002B6B                 align 4
.text$x:00002B6B _text$x         ends
.text$x:00002B6B
.text$mn:00002B6C ; ===========================================================================
.text$mn:00002B6C
.text$mn:00002B6C ; Segment type: Pure code
.text$mn:00002B6C ; Segment permissions: Read/Execute
.text$mn:00002B6C _text$mn        segment para public 'CODE' use32
.text$mn:00002B6C                 assume cs:_text$mn
.text$mn:00002B6C                 ;org 2B6Ch
.text$mn:00002B6C ; COMDAT (pick any)
.text$mn:00002B6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B6C
.text$mn:00002B6C ; =============== S U B R O U T I N E =======================================
.text$mn:00002B6C
.text$mn:00002B6C ; Attributes: bp-based frame
.text$mn:00002B6C
.text$mn:00002B6C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00002B6C                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002B6C ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00002B6C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00002B6C
.text$mn:00002B6C var_10          = dword ptr -10h
.text$mn:00002B6C var_C           = dword ptr -0Ch
.text$mn:00002B6C var_4           = dword ptr -4
.text$mn:00002B6C
.text$mn:00002B6C                 push    ebp
.text$mn:00002B6D                 mov     ebp, esp
.text$mn:00002B6F                 push    0FFFFFFFFh
.text$mn:00002B71                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002B76                 mov     eax, large fs:0
.text$mn:00002B7C                 push    eax
.text$mn:00002B7D                 push    ecx
.text$mn:00002B7E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B83                 xor     eax, ebp
.text$mn:00002B85                 push    eax
.text$mn:00002B86                 lea     eax, [ebp+var_C]
.text$mn:00002B89                 mov     large fs:0, eax
.text$mn:00002B8F                 mov     [ebp+var_10], ecx
.text$mn:00002B92                 mov     ecx, [ebp+var_10]
.text$mn:00002B95                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00002B9A                 mov     [ebp+var_4], 0
.text$mn:00002BA1                 mov     ecx, [ebp+var_10]
.text$mn:00002BA4                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00002BA9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002BB0                 mov     eax, [ebp+var_10]
.text$mn:00002BB3                 mov     ecx, [ebp+var_C]
.text$mn:00002BB6                 mov     large fs:0, ecx
.text$mn:00002BBD                 pop     ecx
.text$mn:00002BBE                 mov     esp, ebp
.text$mn:00002BC0                 pop     ebp
.text$mn:00002BC1                 retn    4
.text$mn:00002BC1 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00002BC1
.text$mn:00002BC1 _text$mn        ends
.text$mn:00002BC1
.text$x:00002BC4 ; ===========================================================================
.text$x:00002BC4
.text$x:00002BC4 ; Segment type: Pure code
.text$x:00002BC4 ; Segment permissions: Read/Execute
.text$x:00002BC4 _text$x         segment para public 'CODE' use32
.text$x:00002BC4                 assume cs:_text$x
.text$x:00002BC4                 ;org 2BC4h
.text$x:00002BC4 ; COMDAT (pick associative to section at 2B6C)
.text$x:00002BC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002BC4
.text$x:00002BC4 ; =============== S U B R O U T I N E =======================================
.text$x:00002BC4
.text$x:00002BC4
.text$x:00002BC4 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00002BC4                                         ; DATA XREF: .xdata$x:00006E14o
.text$x:00002BC4                 mov     ecx, [ebp-10h]
.text$x:00002BC7                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00002BC7 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00002BC7
.text$x:00002BCC
.text$x:00002BCC ; =============== S U B R O U T I N E =======================================
.text$x:00002BCC
.text$x:00002BCC
.text$x:00002BCC __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00002BCC                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00002BCC
.text$x:00002BCC arg_4           = dword ptr  8
.text$x:00002BCC
.text$x:00002BCC                 mov     edx, [esp+arg_4]
.text$x:00002BD0                 lea     eax, [edx+0Ch]
.text$x:00002BD3                 mov     ecx, [edx-8]
.text$x:00002BD6                 xor     ecx, eax
.text$x:00002BD8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002BDD                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00002BE2                 jmp     ___CxxFrameHandler3
.text$x:00002BE2 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00002BE2
.text$x:00002BE2 ; ---------------------------------------------------------------------------
.text$x:00002BE7                 align 4
.text$x:00002BE7 _text$x         ends
.text$x:00002BE7
.text$mn:00002BE8 ; ===========================================================================
.text$mn:00002BE8
.text$mn:00002BE8 ; Segment type: Pure code
.text$mn:00002BE8 ; Segment permissions: Read/Execute
.text$mn:00002BE8 _text$mn        segment para public 'CODE' use32
.text$mn:00002BE8                 assume cs:_text$mn
.text$mn:00002BE8                 ;org 2BE8h
.text$mn:00002BE8 ; COMDAT (pick any)
.text$mn:00002BE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BE8
.text$mn:00002BE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BE8
.text$mn:00002BE8 ; Attributes: bp-based frame
.text$mn:00002BE8
.text$mn:00002BE8 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:00002BE8                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00002BE8 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00002BE8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+43p
.text$mn:00002BE8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+34p ...
.text$mn:00002BE8
.text$mn:00002BE8 var_10          = dword ptr -10h
.text$mn:00002BE8 var_C           = dword ptr -0Ch
.text$mn:00002BE8 var_4           = dword ptr -4
.text$mn:00002BE8
.text$mn:00002BE8                 push    ebp
.text$mn:00002BE9                 mov     ebp, esp
.text$mn:00002BEB                 push    0FFFFFFFFh
.text$mn:00002BED                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00002BF2                 mov     eax, large fs:0
.text$mn:00002BF8                 push    eax
.text$mn:00002BF9                 push    ecx
.text$mn:00002BFA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002BFF                 xor     eax, ebp
.text$mn:00002C01                 push    eax
.text$mn:00002C02                 lea     eax, [ebp+var_C]
.text$mn:00002C05                 mov     large fs:0, eax
.text$mn:00002C0B                 mov     [ebp+var_10], ecx
.text$mn:00002C0E                 mov     ecx, [ebp+var_10]
.text$mn:00002C11                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00002C16                 mov     [ebp+var_4], 0
.text$mn:00002C1D                 mov     ecx, [ebp+var_10]
.text$mn:00002C20                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00002C25                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002C2C                 mov     eax, [ebp+var_10]
.text$mn:00002C2F                 mov     ecx, [ebp+var_C]
.text$mn:00002C32                 mov     large fs:0, ecx
.text$mn:00002C39                 pop     ecx
.text$mn:00002C3A                 mov     esp, ebp
.text$mn:00002C3C                 pop     ebp
.text$mn:00002C3D                 retn    4
.text$mn:00002C3D ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00002C3D
.text$mn:00002C3D _text$mn        ends
.text$mn:00002C3D
.text$x:00002C40 ; ===========================================================================
.text$x:00002C40
.text$x:00002C40 ; Segment type: Pure code
.text$x:00002C40 ; Segment permissions: Read/Execute
.text$x:00002C40 _text$x         segment para public 'CODE' use32
.text$x:00002C40                 assume cs:_text$x
.text$x:00002C40                 ;org 2C40h
.text$x:00002C40 ; COMDAT (pick associative to section at 2BE8)
.text$x:00002C40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002C40
.text$x:00002C40 ; =============== S U B R O U T I N E =======================================
.text$x:00002C40
.text$x:00002C40
.text$x:00002C40 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:00002C40                                         ; DATA XREF: .xdata$x:00007134o
.text$x:00002C40                 mov     ecx, [ebp-10h]
.text$x:00002C43                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00002C43 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:00002C43
.text$x:00002C48
.text$x:00002C48 ; =============== S U B R O U T I N E =======================================
.text$x:00002C48
.text$x:00002C48
.text$x:00002C48 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:00002C48                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:00002C48
.text$x:00002C48 arg_4           = dword ptr  8
.text$x:00002C48
.text$x:00002C48                 mov     edx, [esp+arg_4]
.text$x:00002C4C                 lea     eax, [edx+0Ch]
.text$x:00002C4F                 mov     ecx, [edx-8]
.text$x:00002C52                 xor     ecx, eax
.text$x:00002C54                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002C59                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:00002C5E                 jmp     ___CxxFrameHandler3
.text$x:00002C5E __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:00002C5E
.text$x:00002C5E ; ---------------------------------------------------------------------------
.text$x:00002C63                 align 4
.text$x:00002C63 _text$x         ends
.text$x:00002C63
.text$mn:00002C64 ; ===========================================================================
.text$mn:00002C64
.text$mn:00002C64 ; Segment type: Pure code
.text$mn:00002C64 ; Segment permissions: Read/Execute
.text$mn:00002C64 _text$mn        segment para public 'CODE' use32
.text$mn:00002C64                 assume cs:_text$mn
.text$mn:00002C64                 ;org 2C64h
.text$mn:00002C64 ; COMDAT (pick any)
.text$mn:00002C64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C64
.text$mn:00002C64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C64
.text$mn:00002C64 ; Attributes: bp-based frame
.text$mn:00002C64
.text$mn:00002C64 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00002C64                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002C64 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00002C64                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00002C64
.text$mn:00002C64 var_10          = dword ptr -10h
.text$mn:00002C64 var_C           = dword ptr -0Ch
.text$mn:00002C64 var_4           = dword ptr -4
.text$mn:00002C64
.text$mn:00002C64                 push    ebp
.text$mn:00002C65                 mov     ebp, esp
.text$mn:00002C67                 push    0FFFFFFFFh
.text$mn:00002C69                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002C6E                 mov     eax, large fs:0
.text$mn:00002C74                 push    eax
.text$mn:00002C75                 push    ecx
.text$mn:00002C76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002C7B                 xor     eax, ebp
.text$mn:00002C7D                 push    eax
.text$mn:00002C7E                 lea     eax, [ebp+var_C]
.text$mn:00002C81                 mov     large fs:0, eax
.text$mn:00002C87                 mov     [ebp+var_10], ecx
.text$mn:00002C8A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002C8D                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00002C92                 mov     [ebp+var_4], 0
.text$mn:00002C99                 mov     eax, [ebp+var_10]
.text$mn:00002C9C                 mov     dword ptr [eax+14h], 0
.text$mn:00002CA3                 mov     ecx, [ebp+var_10]
.text$mn:00002CA6                 mov     dword ptr [ecx+18h], 0
.text$mn:00002CAD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002CB4                 mov     eax, [ebp+var_10]
.text$mn:00002CB7                 mov     ecx, [ebp+var_C]
.text$mn:00002CBA                 mov     large fs:0, ecx
.text$mn:00002CC1                 pop     ecx
.text$mn:00002CC2                 mov     esp, ebp
.text$mn:00002CC4                 pop     ebp
.text$mn:00002CC5                 retn
.text$mn:00002CC5 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00002CC5
.text$mn:00002CC5 ; ---------------------------------------------------------------------------
.text$mn:00002CC6                 align 4
.text$mn:00002CC6 _text$mn        ends
.text$mn:00002CC6
.text$x:00002CC8 ; ===========================================================================
.text$x:00002CC8
.text$x:00002CC8 ; Segment type: Pure code
.text$x:00002CC8 ; Segment permissions: Read/Execute
.text$x:00002CC8 _text$x         segment para public 'CODE' use32
.text$x:00002CC8                 assume cs:_text$x
.text$x:00002CC8                 ;org 2CC8h
.text$x:00002CC8 ; COMDAT (pick associative to section at 2C64)
.text$x:00002CC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002CC8
.text$x:00002CC8 ; =============== S U B R O U T I N E =======================================
.text$x:00002CC8
.text$x:00002CC8
.text$x:00002CC8 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00002CC8                                         ; DATA XREF: .xdata$x:00006DBCo
.text$x:00002CC8                 mov     ecx, [ebp-10h]  ; this
.text$x:00002CCB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002CCB __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00002CCB
.text$x:00002CD0
.text$x:00002CD0 ; =============== S U B R O U T I N E =======================================
.text$x:00002CD0
.text$x:00002CD0
.text$x:00002CD0 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00002CD0                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00002CD0
.text$x:00002CD0 arg_4           = dword ptr  8
.text$x:00002CD0
.text$x:00002CD0                 mov     edx, [esp+arg_4]
.text$x:00002CD4                 lea     eax, [edx+0Ch]
.text$x:00002CD7                 mov     ecx, [edx-8]
.text$x:00002CDA                 xor     ecx, eax
.text$x:00002CDC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002CE1                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00002CE6                 jmp     ___CxxFrameHandler3
.text$x:00002CE6 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00002CE6
.text$x:00002CE6 ; ---------------------------------------------------------------------------
.text$x:00002CEB                 align 4
.text$x:00002CEB _text$x         ends
.text$x:00002CEB
.text$mn:00002CEC ; ===========================================================================
.text$mn:00002CEC
.text$mn:00002CEC ; Segment type: Pure code
.text$mn:00002CEC ; Segment permissions: Read/Execute
.text$mn:00002CEC _text$mn        segment para public 'CODE' use32
.text$mn:00002CEC                 assume cs:_text$mn
.text$mn:00002CEC                 ;org 2CECh
.text$mn:00002CEC ; COMDAT (pick any)
.text$mn:00002CEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CEC
.text$mn:00002CEC ; =============== S U B R O U T I N E =======================================
.text$mn:00002CEC
.text$mn:00002CEC ; Attributes: bp-based frame
.text$mn:00002CEC
.text$mn:00002CEC ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00002CEC                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00002CEC ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00002CEC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:00002CEC
.text$mn:00002CEC var_10          = dword ptr -10h
.text$mn:00002CEC var_C           = dword ptr -0Ch
.text$mn:00002CEC var_4           = dword ptr -4
.text$mn:00002CEC
.text$mn:00002CEC                 push    ebp
.text$mn:00002CED                 mov     ebp, esp
.text$mn:00002CEF                 push    0FFFFFFFFh
.text$mn:00002CF1                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00002CF6                 mov     eax, large fs:0
.text$mn:00002CFC                 push    eax
.text$mn:00002CFD                 push    ecx
.text$mn:00002CFE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002D03                 xor     eax, ebp
.text$mn:00002D05                 push    eax
.text$mn:00002D06                 lea     eax, [ebp+var_C]
.text$mn:00002D09                 mov     large fs:0, eax
.text$mn:00002D0F                 mov     [ebp+var_10], ecx
.text$mn:00002D12                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002D15                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00002D1A                 mov     [ebp+var_4], 0
.text$mn:00002D21                 mov     eax, [ebp+var_10]
.text$mn:00002D24                 mov     dword ptr [eax+14h], 0
.text$mn:00002D2B                 mov     ecx, [ebp+var_10]
.text$mn:00002D2E                 mov     dword ptr [ecx+18h], 0
.text$mn:00002D35                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002D3C                 mov     eax, [ebp+var_10]
.text$mn:00002D3F                 mov     ecx, [ebp+var_C]
.text$mn:00002D42                 mov     large fs:0, ecx
.text$mn:00002D49                 pop     ecx
.text$mn:00002D4A                 mov     esp, ebp
.text$mn:00002D4C                 pop     ebp
.text$mn:00002D4D                 retn
.text$mn:00002D4D ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00002D4D
.text$mn:00002D4D ; ---------------------------------------------------------------------------
.text$mn:00002D4E                 align 10h
.text$mn:00002D4E _text$mn        ends
.text$mn:00002D4E
.text$x:00002D50 ; ===========================================================================
.text$x:00002D50
.text$x:00002D50 ; Segment type: Pure code
.text$x:00002D50 ; Segment permissions: Read/Execute
.text$x:00002D50 _text$x         segment para public 'CODE' use32
.text$x:00002D50                 assume cs:_text$x
.text$x:00002D50                 ;org 2D50h
.text$x:00002D50 ; COMDAT (pick associative to section at 2CEC)
.text$x:00002D50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002D50
.text$x:00002D50 ; =============== S U B R O U T I N E =======================================
.text$x:00002D50
.text$x:00002D50
.text$x:00002D50 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00002D50                                         ; DATA XREF: .xdata$x:000070DCo
.text$x:00002D50                 mov     ecx, [ebp-10h]  ; this
.text$x:00002D53                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002D53 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00002D53
.text$x:00002D58
.text$x:00002D58 ; =============== S U B R O U T I N E =======================================
.text$x:00002D58
.text$x:00002D58
.text$x:00002D58 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00002D58                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00002D58
.text$x:00002D58 arg_4           = dword ptr  8
.text$x:00002D58
.text$x:00002D58                 mov     edx, [esp+arg_4]
.text$x:00002D5C                 lea     eax, [edx+0Ch]
.text$x:00002D5F                 mov     ecx, [edx-8]
.text$x:00002D62                 xor     ecx, eax
.text$x:00002D64                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D69                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00002D6E                 jmp     ___CxxFrameHandler3
.text$x:00002D6E __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00002D6E
.text$x:00002D6E ; ---------------------------------------------------------------------------
.text$x:00002D73                 align 4
.text$x:00002D73 _text$x         ends
.text$x:00002D73
.text$mn:00002D74 ; ===========================================================================
.text$mn:00002D74
.text$mn:00002D74 ; Segment type: Pure code
.text$mn:00002D74 ; Segment permissions: Read/Execute
.text$mn:00002D74 _text$mn        segment para public 'CODE' use32
.text$mn:00002D74                 assume cs:_text$mn
.text$mn:00002D74                 ;org 2D74h
.text$mn:00002D74 ; COMDAT (pick any)
.text$mn:00002D74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D74
.text$mn:00002D74 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D74
.text$mn:00002D74 ; Attributes: bp-based frame
.text$mn:00002D74
.text$mn:00002D74 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct TreeStateNode, class std::allocator<struct TreeStateNode>>>::_Vector_alloc<0, struct std::_Vec_base_types<struct TreeStateNode, class std::allocator<struct TreeStateNode>>>(class std::allocator<struct TreeStateNode> const &)
.text$mn:00002D74                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z
.text$mn:00002D74 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z proc near
.text$mn:00002D74                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(std::vector<TreeStateNode,std::allocator<TreeStateNode>> const &)+4Ap
.text$mn:00002D74                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(void)+34p
.text$mn:00002D74
.text$mn:00002D74 var_10          = dword ptr -10h
.text$mn:00002D74 var_C           = dword ptr -0Ch
.text$mn:00002D74 var_4           = dword ptr -4
.text$mn:00002D74
.text$mn:00002D74                 push    ebp
.text$mn:00002D75                 mov     ebp, esp
.text$mn:00002D77                 push    0FFFFFFFFh
.text$mn:00002D79                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z
.text$mn:00002D7E                 mov     eax, large fs:0
.text$mn:00002D84                 push    eax
.text$mn:00002D85                 push    ecx
.text$mn:00002D86                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002D8B                 xor     eax, ebp
.text$mn:00002D8D                 push    eax
.text$mn:00002D8E                 lea     eax, [ebp+var_C]
.text$mn:00002D91                 mov     large fs:0, eax
.text$mn:00002D97                 mov     [ebp+var_10], ecx
.text$mn:00002D9A                 mov     ecx, [ebp+var_10]
.text$mn:00002D9D                 call    ??0?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<TreeStateNode>>::_Vector_val<std::_Simple_types<TreeStateNode>>(void)
.text$mn:00002DA2                 mov     [ebp+var_4], 0
.text$mn:00002DA9                 mov     ecx, [ebp+var_10]
.text$mn:00002DAC                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Alloc_proxy(void)
.text$mn:00002DB1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002DB8                 mov     eax, [ebp+var_10]
.text$mn:00002DBB                 mov     ecx, [ebp+var_C]
.text$mn:00002DBE                 mov     large fs:0, ecx
.text$mn:00002DC5                 pop     ecx
.text$mn:00002DC6                 mov     esp, ebp
.text$mn:00002DC8                 pop     ebp
.text$mn:00002DC9                 retn    4
.text$mn:00002DC9 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z endp
.text$mn:00002DC9
.text$mn:00002DC9 _text$mn        ends
.text$mn:00002DC9
.text$x:00002DCC ; ===========================================================================
.text$x:00002DCC
.text$x:00002DCC ; Segment type: Pure code
.text$x:00002DCC ; Segment permissions: Read/Execute
.text$x:00002DCC _text$x         segment para public 'CODE' use32
.text$x:00002DCC                 assume cs:_text$x
.text$x:00002DCC                 ;org 2DCCh
.text$x:00002DCC ; COMDAT (pick associative to section at 2D74)
.text$x:00002DCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002DCC
.text$x:00002DCC ; =============== S U B R O U T I N E =======================================
.text$x:00002DCC
.text$x:00002DCC
.text$x:00002DCC __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z$0 proc near
.text$x:00002DCC                                         ; DATA XREF: .xdata$x:0000734Co
.text$x:00002DCC                 mov     ecx, [ebp-10h]
.text$x:00002DCF                 jmp     ??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<TreeStateNode>>::~_Vector_val<std::_Simple_types<TreeStateNode>>(void)
.text$x:00002DCF __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z$0 endp
.text$x:00002DCF
.text$x:00002DD4
.text$x:00002DD4 ; =============== S U B R O U T I N E =======================================
.text$x:00002DD4
.text$x:00002DD4
.text$x:00002DD4 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z proc near
.text$x:00002DD4                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>(std::allocator<TreeStateNode> const &)+5o
.text$x:00002DD4
.text$x:00002DD4 arg_4           = dword ptr  8
.text$x:00002DD4
.text$x:00002DD4                 mov     edx, [esp+arg_4]
.text$x:00002DD8                 lea     eax, [edx+0Ch]
.text$x:00002DDB                 mov     ecx, [edx-8]
.text$x:00002DDE                 xor     ecx, eax
.text$x:00002DE0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002DE5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z
.text$x:00002DEA                 jmp     ___CxxFrameHandler3
.text$x:00002DEA __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z endp
.text$x:00002DEA
.text$x:00002DEA ; ---------------------------------------------------------------------------
.text$x:00002DEF                 align 10h
.text$x:00002DEF _text$x         ends
.text$x:00002DEF
.text$mn:00002DF0 ; ===========================================================================
.text$mn:00002DF0
.text$mn:00002DF0 ; Segment type: Pure code
.text$mn:00002DF0 ; Segment permissions: Read/Execute
.text$mn:00002DF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002DF0                 assume cs:_text$mn
.text$mn:00002DF0                 ;org 2DF0h
.text$mn:00002DF0 ; COMDAT (pick any)
.text$mn:00002DF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DF0
.text$mn:00002DF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DF0
.text$mn:00002DF0 ; Attributes: bp-based frame
.text$mn:00002DF0
.text$mn:00002DF0 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(struct std::_Iterator_base12 *)
.text$mn:00002DF0                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002DF0 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00002DF0                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *)+4Fp
.text$mn:00002DF0                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *)+6Dp ...
.text$mn:00002DF0
.text$mn:00002DF0 var_10          = dword ptr -10h
.text$mn:00002DF0 var_C           = dword ptr -0Ch
.text$mn:00002DF0 var_4           = dword ptr -4
.text$mn:00002DF0 arg_0           = dword ptr  8
.text$mn:00002DF0
.text$mn:00002DF0                 push    ebp
.text$mn:00002DF1                 mov     ebp, esp
.text$mn:00002DF3                 push    0FFFFFFFFh
.text$mn:00002DF5                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002DFA                 mov     eax, large fs:0
.text$mn:00002E00                 push    eax
.text$mn:00002E01                 push    ecx
.text$mn:00002E02                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002E07                 xor     eax, ebp
.text$mn:00002E09                 push    eax
.text$mn:00002E0A                 lea     eax, [ebp+var_C]
.text$mn:00002E0D                 mov     large fs:0, eax
.text$mn:00002E13                 mov     [ebp+var_10], ecx
.text$mn:00002E16                 mov     eax, [ebp+arg_0]
.text$mn:00002E19                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002E1A                 mov     ecx, [ebp+var_10]
.text$mn:00002E1D                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12> const &)
.text$mn:00002E22                 mov     [ebp+var_4], 0
.text$mn:00002E29                 mov     ecx, [ebp+var_10]
.text$mn:00002E2C                 mov     edx, [ebp+arg_0]
.text$mn:00002E2F                 mov     eax, [edx+8]
.text$mn:00002E32                 mov     [ecx+8], eax
.text$mn:00002E35                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002E3C                 mov     eax, [ebp+var_10]
.text$mn:00002E3F                 mov     ecx, [ebp+var_C]
.text$mn:00002E42                 mov     large fs:0, ecx
.text$mn:00002E49                 pop     ecx
.text$mn:00002E4A                 mov     esp, ebp
.text$mn:00002E4C                 pop     ebp
.text$mn:00002E4D                 retn    4
.text$mn:00002E4D ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00002E4D
.text$mn:00002E4D _text$mn        ends
.text$mn:00002E4D
.text$x:00002E50 ; ===========================================================================
.text$x:00002E50
.text$x:00002E50 ; Segment type: Pure code
.text$x:00002E50 ; Segment permissions: Read/Execute
.text$x:00002E50 _text$x         segment para public 'CODE' use32
.text$x:00002E50                 assume cs:_text$x
.text$x:00002E50                 ;org 2E50h
.text$x:00002E50 ; COMDAT (pick associative to section at 2DF0)
.text$x:00002E50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002E50
.text$x:00002E50 ; =============== S U B R O U T I N E =======================================
.text$x:00002E50
.text$x:00002E50
.text$x:00002E50 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00002E50                                         ; DATA XREF: .xdata$x:00007834o
.text$x:00002E50                 mov     ecx, [ebp-10h]
.text$x:00002E53                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>(void)
.text$x:00002E53 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00002E53
.text$x:00002E58
.text$x:00002E58 ; =============== S U B R O U T I N E =======================================
.text$x:00002E58
.text$x:00002E58
.text$x:00002E58 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00002E58                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>> const &)+5o
.text$x:00002E58
.text$x:00002E58 arg_4           = dword ptr  8
.text$x:00002E58
.text$x:00002E58                 mov     edx, [esp+arg_4]
.text$x:00002E5C                 lea     eax, [edx+0Ch]
.text$x:00002E5F                 mov     ecx, [edx-8]
.text$x:00002E62                 xor     ecx, eax
.text$x:00002E64                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002E69                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00002E6E                 jmp     ___CxxFrameHandler3
.text$x:00002E6E __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00002E6E
.text$x:00002E6E ; ---------------------------------------------------------------------------
.text$x:00002E73                 align 4
.text$x:00002E73 _text$x         ends
.text$x:00002E73
.text$mn:00002E74 ; ===========================================================================
.text$mn:00002E74
.text$mn:00002E74 ; Segment type: Pure code
.text$mn:00002E74 ; Segment permissions: Read/Execute
.text$mn:00002E74 _text$mn        segment para public 'CODE' use32
.text$mn:00002E74                 assume cs:_text$mn
.text$mn:00002E74                 ;org 2E74h
.text$mn:00002E74 ; COMDAT (pick any)
.text$mn:00002E74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E74
.text$mn:00002E74 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E74
.text$mn:00002E74 ; Attributes: bp-based frame
.text$mn:00002E74
.text$mn:00002E74 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(int, struct std::_Container_base12 *)
.text$mn:00002E74                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z
.text$mn:00002E74 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z proc near
.text$mn:00002E74                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::begin(void)+3Dp
.text$mn:00002E74                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::end(void)+3Dp
.text$mn:00002E74
.text$mn:00002E74 var_10          = dword ptr -10h
.text$mn:00002E74 var_C           = dword ptr -0Ch
.text$mn:00002E74 var_4           = dword ptr -4
.text$mn:00002E74 arg_0           = dword ptr  8
.text$mn:00002E74 arg_4           = dword ptr  0Ch
.text$mn:00002E74
.text$mn:00002E74                 push    ebp
.text$mn:00002E75                 mov     ebp, esp
.text$mn:00002E77                 push    0FFFFFFFFh
.text$mn:00002E79                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z
.text$mn:00002E7E                 mov     eax, large fs:0
.text$mn:00002E84                 push    eax
.text$mn:00002E85                 push    ecx
.text$mn:00002E86                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002E8B                 xor     eax, ebp
.text$mn:00002E8D                 push    eax
.text$mn:00002E8E                 lea     eax, [ebp+var_C]
.text$mn:00002E91                 mov     large fs:0, eax
.text$mn:00002E97                 mov     [ebp+var_10], ecx
.text$mn:00002E9A                 mov     ecx, [ebp+var_10]
.text$mn:00002E9D                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>(void)
.text$mn:00002EA2                 mov     [ebp+var_4], 0
.text$mn:00002EA9                 mov     eax, [ebp+var_10]
.text$mn:00002EAC                 mov     ecx, [ebp+arg_0]
.text$mn:00002EAF                 mov     [eax+8], ecx
.text$mn:00002EB2                 mov     edx, [ebp+arg_4]
.text$mn:00002EB5                 push    edx             ; struct std::_Container_base12 *
.text$mn:00002EB6                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002EB9                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00002EBE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002EC5                 mov     eax, [ebp+var_10]
.text$mn:00002EC8                 mov     ecx, [ebp+var_C]
.text$mn:00002ECB                 mov     large fs:0, ecx
.text$mn:00002ED2                 pop     ecx
.text$mn:00002ED3                 mov     esp, ebp
.text$mn:00002ED5                 pop     ebp
.text$mn:00002ED6                 retn    8
.text$mn:00002ED6 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z endp
.text$mn:00002ED6
.text$mn:00002ED6 ; ---------------------------------------------------------------------------
.text$mn:00002ED9                 align 4
.text$mn:00002ED9 _text$mn        ends
.text$mn:00002ED9
.text$x:00002EDC ; ===========================================================================
.text$x:00002EDC
.text$x:00002EDC ; Segment type: Pure code
.text$x:00002EDC ; Segment permissions: Read/Execute
.text$x:00002EDC _text$x         segment para public 'CODE' use32
.text$x:00002EDC                 assume cs:_text$x
.text$x:00002EDC                 ;org 2EDCh
.text$x:00002EDC ; COMDAT (pick associative to section at 2E74)
.text$x:00002EDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002EDC
.text$x:00002EDC ; =============== S U B R O U T I N E =======================================
.text$x:00002EDC
.text$x:00002EDC
.text$x:00002EDC __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z$0 proc near
.text$x:00002EDC                                         ; DATA XREF: .xdata$x:000077DCo
.text$x:00002EDC                 mov     ecx, [ebp-10h]
.text$x:00002EDF                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>(void)
.text$x:00002EDF __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z$0 endp
.text$x:00002EDF
.text$x:00002EE4
.text$x:00002EE4 ; =============== S U B R O U T I N E =======================================
.text$x:00002EE4
.text$x:00002EE4
.text$x:00002EE4 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z proc near
.text$x:00002EE4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(TreeStateNode *,std::_Container_base12 const *)+5o
.text$x:00002EE4
.text$x:00002EE4 arg_4           = dword ptr  8
.text$x:00002EE4
.text$x:00002EE4                 mov     edx, [esp+arg_4]
.text$x:00002EE8                 lea     eax, [edx+0Ch]
.text$x:00002EEB                 mov     ecx, [edx-8]
.text$x:00002EEE                 xor     ecx, eax
.text$x:00002EF0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002EF5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z
.text$x:00002EFA                 jmp     ___CxxFrameHandler3
.text$x:00002EFA __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z endp
.text$x:00002EFA
.text$x:00002EFA ; ---------------------------------------------------------------------------
.text$x:00002EFF                 align 10h
.text$x:00002EFF _text$x         ends
.text$x:00002EFF
.text$mn:00002F00 ; ===========================================================================
.text$mn:00002F00
.text$mn:00002F00 ; Segment type: Pure code
.text$mn:00002F00 ; Segment permissions: Read/Execute
.text$mn:00002F00 _text$mn        segment para public 'CODE' use32
.text$mn:00002F00                 assume cs:_text$mn
.text$mn:00002F00                 ;org 2F00h
.text$mn:00002F00 ; COMDAT (pick any)
.text$mn:00002F00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F00
.text$mn:00002F00 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F00
.text$mn:00002F00 ; Attributes: bp-based frame
.text$mn:00002F00
.text$mn:00002F00 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>(void)
.text$mn:00002F00                 public ??0?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ
.text$mn:00002F00 ??0?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ proc near
.text$mn:00002F00                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>(std::allocator<TreeStateNode> const &)+29p
.text$mn:00002F00
.text$mn:00002F00 var_10          = dword ptr -10h
.text$mn:00002F00 var_C           = dword ptr -0Ch
.text$mn:00002F00 var_4           = dword ptr -4
.text$mn:00002F00
.text$mn:00002F00                 push    ebp
.text$mn:00002F01                 mov     ebp, esp
.text$mn:00002F03                 push    0FFFFFFFFh
.text$mn:00002F05                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ
.text$mn:00002F0A                 mov     eax, large fs:0
.text$mn:00002F10                 push    eax
.text$mn:00002F11                 push    ecx
.text$mn:00002F12                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002F17                 xor     eax, ebp
.text$mn:00002F19                 push    eax
.text$mn:00002F1A                 lea     eax, [ebp+var_C]
.text$mn:00002F1D                 mov     large fs:0, eax
.text$mn:00002F23                 mov     [ebp+var_10], ecx
.text$mn:00002F26                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002F29                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00002F2E                 mov     [ebp+var_4], 0
.text$mn:00002F35                 mov     eax, [ebp+var_10]
.text$mn:00002F38                 mov     dword ptr [eax+4], 0
.text$mn:00002F3F                 mov     ecx, [ebp+var_10]
.text$mn:00002F42                 mov     dword ptr [ecx+8], 0
.text$mn:00002F49                 mov     edx, [ebp+var_10]
.text$mn:00002F4C                 mov     dword ptr [edx+0Ch], 0
.text$mn:00002F53                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002F5A                 mov     eax, [ebp+var_10]
.text$mn:00002F5D                 mov     ecx, [ebp+var_C]
.text$mn:00002F60                 mov     large fs:0, ecx
.text$mn:00002F67                 pop     ecx
.text$mn:00002F68                 mov     esp, ebp
.text$mn:00002F6A                 pop     ebp
.text$mn:00002F6B                 retn
.text$mn:00002F6B ??0?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ endp
.text$mn:00002F6B
.text$mn:00002F6B _text$mn        ends
.text$mn:00002F6B
.text$x:00002F6C ; ===========================================================================
.text$x:00002F6C
.text$x:00002F6C ; Segment type: Pure code
.text$x:00002F6C ; Segment permissions: Read/Execute
.text$x:00002F6C _text$x         segment para public 'CODE' use32
.text$x:00002F6C                 assume cs:_text$x
.text$x:00002F6C                 ;org 2F6Ch
.text$x:00002F6C ; COMDAT (pick associative to section at 2F00)
.text$x:00002F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002F6C
.text$x:00002F6C ; =============== S U B R O U T I N E =======================================
.text$x:00002F6C
.text$x:00002F6C
.text$x:00002F6C __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002F6C                                         ; DATA XREF: .xdata$x:000072F4o
.text$x:00002F6C                 mov     ecx, [ebp-10h]  ; this
.text$x:00002F6F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002F6F __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002F6F
.text$x:00002F74
.text$x:00002F74 ; =============== S U B R O U T I N E =======================================
.text$x:00002F74
.text$x:00002F74
.text$x:00002F74 __ehhandler$??0?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ proc near
.text$x:00002F74                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<TreeStateNode>>::_Vector_val<std::_Simple_types<TreeStateNode>>(void)+5o
.text$x:00002F74
.text$x:00002F74 arg_4           = dword ptr  8
.text$x:00002F74
.text$x:00002F74                 mov     edx, [esp+arg_4]
.text$x:00002F78                 lea     eax, [edx+0Ch]
.text$x:00002F7B                 mov     ecx, [edx-8]
.text$x:00002F7E                 xor     ecx, eax
.text$x:00002F80                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F85                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ
.text$x:00002F8A                 jmp     ___CxxFrameHandler3
.text$x:00002F8A __ehhandler$??0?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ endp
.text$x:00002F8A
.text$x:00002F8A ; ---------------------------------------------------------------------------
.text$x:00002F8F                 align 10h
.text$x:00002F8F _text$x         ends
.text$x:00002F8F
.text$mn:00002F90 ; ===========================================================================
.text$mn:00002F90
.text$mn:00002F90 ; Segment type: Pure code
.text$mn:00002F90 ; Segment permissions: Read/Execute
.text$mn:00002F90 _text$mn        segment para public 'CODE' use32
.text$mn:00002F90                 assume cs:_text$mn
.text$mn:00002F90                 ;org 2F90h
.text$mn:00002F90 ; COMDAT (pick any)
.text$mn:00002F90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F90
.text$mn:00002F90 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F90
.text$mn:00002F90 ; Attributes: bp-based frame
.text$mn:00002F90
.text$mn:00002F90 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00002F90                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00002F90 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00002F90                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00002F90
.text$mn:00002F90 var_4           = dword ptr -4
.text$mn:00002F90
.text$mn:00002F90                 push    ebp
.text$mn:00002F91                 mov     ebp, esp
.text$mn:00002F93                 push    ecx
.text$mn:00002F94                 mov     [ebp+var_4], ecx
.text$mn:00002F97                 mov     ecx, [ebp+var_4]
.text$mn:00002F9A                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00002F9F                 mov     eax, [ebp+var_4]
.text$mn:00002FA2                 mov     esp, ebp
.text$mn:00002FA4                 pop     ebp
.text$mn:00002FA5                 retn
.text$mn:00002FA5 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00002FA5
.text$mn:00002FA5 ; ---------------------------------------------------------------------------
.text$mn:00002FA6                 align 4
.text$mn:00002FA6 _text$mn        ends
.text$mn:00002FA6
.text$mn:00002FA8 ; ===========================================================================
.text$mn:00002FA8
.text$mn:00002FA8 ; Segment type: Pure code
.text$mn:00002FA8 ; Segment permissions: Read/Execute
.text$mn:00002FA8 _text$mn        segment para public 'CODE' use32
.text$mn:00002FA8                 assume cs:_text$mn
.text$mn:00002FA8                 ;org 2FA8h
.text$mn:00002FA8 ; COMDAT (pick any)
.text$mn:00002FA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FA8
.text$mn:00002FA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FA8
.text$mn:00002FA8 ; Attributes: bp-based frame
.text$mn:00002FA8
.text$mn:00002FA8 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct TreeStateNode>>::_Wrap_alloc<class std::allocator<struct TreeStateNode>>(class std::allocator<struct TreeStateNode> const &)
.text$mn:00002FA8                 public ??0?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z
.text$mn:00002FA8 ??0?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z proc near
.text$mn:00002FA8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TreeStateNode>>::select_on_container_copy_construction(void)+1Dp
.text$mn:00002FA8
.text$mn:00002FA8 var_4           = dword ptr -4
.text$mn:00002FA8 arg_0           = dword ptr  8
.text$mn:00002FA8
.text$mn:00002FA8                 push    ebp
.text$mn:00002FA9                 mov     ebp, esp
.text$mn:00002FAB                 push    ecx
.text$mn:00002FAC                 mov     [ebp+var_4], ecx
.text$mn:00002FAF                 mov     eax, [ebp+arg_0]
.text$mn:00002FB2                 push    eax
.text$mn:00002FB3                 mov     ecx, [ebp+var_4]
.text$mn:00002FB6                 call    ??0?$allocator@UTreeStateNode@@@std@@QAE@ABV01@@Z ; std::allocator<TreeStateNode>::allocator<TreeStateNode>(std::allocator<TreeStateNode> const &)
.text$mn:00002FBB                 mov     eax, [ebp+var_4]
.text$mn:00002FBE                 mov     esp, ebp
.text$mn:00002FC0                 pop     ebp
.text$mn:00002FC1                 retn    4
.text$mn:00002FC1 ??0?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z endp
.text$mn:00002FC1
.text$mn:00002FC1 _text$mn        ends
.text$mn:00002FC1
.text$mn:00002FC4 ; ===========================================================================
.text$mn:00002FC4
.text$mn:00002FC4 ; Segment type: Pure code
.text$mn:00002FC4 ; Segment permissions: Read/Execute
.text$mn:00002FC4 _text$mn        segment para public 'CODE' use32
.text$mn:00002FC4                 assume cs:_text$mn
.text$mn:00002FC4                 ;org 2FC4h
.text$mn:00002FC4 ; COMDAT (pick any)
.text$mn:00002FC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FC4
.text$mn:00002FC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FC4
.text$mn:00002FC4 ; Attributes: bp-based frame
.text$mn:00002FC4
.text$mn:00002FC4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct TreeStateNode>>::_Wrap_alloc<class std::allocator<struct TreeStateNode>>(void)
.text$mn:00002FC4                 public ??0?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ
.text$mn:00002FC4 ??0?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ proc near
.text$mn:00002FC4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Getal(void)+Ap
.text$mn:00002FC4
.text$mn:00002FC4 var_4           = dword ptr -4
.text$mn:00002FC4
.text$mn:00002FC4                 push    ebp
.text$mn:00002FC5                 mov     ebp, esp
.text$mn:00002FC7                 push    ecx
.text$mn:00002FC8                 mov     [ebp+var_4], ecx
.text$mn:00002FCB                 mov     ecx, [ebp+var_4]
.text$mn:00002FCE                 call    ??0?$allocator@UTreeStateNode@@@std@@QAE@XZ ; std::allocator<TreeStateNode>::allocator<TreeStateNode>(void)
.text$mn:00002FD3                 mov     eax, [ebp+var_4]
.text$mn:00002FD6                 mov     esp, ebp
.text$mn:00002FD8                 pop     ebp
.text$mn:00002FD9                 retn
.text$mn:00002FD9 ??0?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ endp
.text$mn:00002FD9
.text$mn:00002FD9 ; ---------------------------------------------------------------------------
.text$mn:00002FDA                 align 4
.text$mn:00002FDA _text$mn        ends
.text$mn:00002FDA
.text$mn:00002FDC ; ===========================================================================
.text$mn:00002FDC
.text$mn:00002FDC ; Segment type: Pure code
.text$mn:00002FDC ; Segment permissions: Read/Execute
.text$mn:00002FDC _text$mn        segment para public 'CODE' use32
.text$mn:00002FDC                 assume cs:_text$mn
.text$mn:00002FDC                 ;org 2FDCh
.text$mn:00002FDC ; COMDAT (pick any)
.text$mn:00002FDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FDC
.text$mn:00002FDC ; =============== S U B R O U T I N E =======================================
.text$mn:00002FDC
.text$mn:00002FDC ; Attributes: bp-based frame
.text$mn:00002FDC
.text$mn:00002FDC ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:00002FDC                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:00002FDC ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00002FDC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Alloc_proxy(void)+Cp
.text$mn:00002FDC                                         ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Free_proxy(void)+Cp
.text$mn:00002FDC
.text$mn:00002FDC var_4           = dword ptr -4
.text$mn:00002FDC
.text$mn:00002FDC                 push    ebp
.text$mn:00002FDD                 mov     ebp, esp
.text$mn:00002FDF                 push    ecx
.text$mn:00002FE0                 mov     [ebp+var_4], ecx
.text$mn:00002FE3                 mov     ecx, [ebp+var_4]
.text$mn:00002FE6                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00002FEB                 mov     eax, [ebp+var_4]
.text$mn:00002FEE                 mov     esp, ebp
.text$mn:00002FF0                 pop     ebp
.text$mn:00002FF1                 retn
.text$mn:00002FF1 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:00002FF1
.text$mn:00002FF1 ; ---------------------------------------------------------------------------
.text$mn:00002FF2                 align 4
.text$mn:00002FF2 _text$mn        ends
.text$mn:00002FF2
.text$mn:00002FF4 ; ===========================================================================
.text$mn:00002FF4
.text$mn:00002FF4 ; Segment type: Pure code
.text$mn:00002FF4 ; Segment permissions: Read/Execute
.text$mn:00002FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00002FF4                 assume cs:_text$mn
.text$mn:00002FF4                 ;org 2FF4h
.text$mn:00002FF4 ; COMDAT (pick any)
.text$mn:00002FF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FF4
.text$mn:00002FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FF4
.text$mn:00002FF4 ; Attributes: bp-based frame
.text$mn:00002FF4
.text$mn:00002FF4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(class std::allocator<wchar_t> const &)
.text$mn:00002FF4                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00002FF4 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00002FF4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+1Dp
.text$mn:00002FF4
.text$mn:00002FF4 var_4           = dword ptr -4
.text$mn:00002FF4 arg_0           = dword ptr  8
.text$mn:00002FF4
.text$mn:00002FF4                 push    ebp
.text$mn:00002FF5                 mov     ebp, esp
.text$mn:00002FF7                 push    ecx
.text$mn:00002FF8                 mov     [ebp+var_4], ecx
.text$mn:00002FFB                 mov     eax, [ebp+arg_0]
.text$mn:00002FFE                 push    eax
.text$mn:00002FFF                 mov     ecx, [ebp+var_4]
.text$mn:00003002                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00003007                 mov     eax, [ebp+var_4]
.text$mn:0000300A                 mov     esp, ebp
.text$mn:0000300C                 pop     ebp
.text$mn:0000300D                 retn    4
.text$mn:0000300D ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:0000300D
.text$mn:0000300D _text$mn        ends
.text$mn:0000300D
.text$mn:00003010 ; ===========================================================================
.text$mn:00003010
.text$mn:00003010 ; Segment type: Pure code
.text$mn:00003010 ; Segment permissions: Read/Execute
.text$mn:00003010 _text$mn        segment para public 'CODE' use32
.text$mn:00003010                 assume cs:_text$mn
.text$mn:00003010                 ;org 3010h
.text$mn:00003010 ; COMDAT (pick any)
.text$mn:00003010                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003010
.text$mn:00003010 ; =============== S U B R O U T I N E =======================================
.text$mn:00003010
.text$mn:00003010 ; Attributes: bp-based frame
.text$mn:00003010
.text$mn:00003010 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:00003010                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:00003010 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:00003010                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:00003010
.text$mn:00003010 var_4           = dword ptr -4
.text$mn:00003010
.text$mn:00003010                 push    ebp
.text$mn:00003011                 mov     ebp, esp
.text$mn:00003013                 push    ecx
.text$mn:00003014                 mov     [ebp+var_4], ecx
.text$mn:00003017                 mov     ecx, [ebp+var_4]
.text$mn:0000301A                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:0000301F                 mov     eax, [ebp+var_4]
.text$mn:00003022                 mov     esp, ebp
.text$mn:00003024                 pop     ebp
.text$mn:00003025                 retn
.text$mn:00003025 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00003025
.text$mn:00003025 ; ---------------------------------------------------------------------------
.text$mn:00003026                 align 4
.text$mn:00003026 _text$mn        ends
.text$mn:00003026
.text$mn:00003028 ; ===========================================================================
.text$mn:00003028
.text$mn:00003028 ; Segment type: Pure code
.text$mn:00003028 ; Segment permissions: Read/Execute
.text$mn:00003028 _text$mn        segment para public 'CODE' use32
.text$mn:00003028                 assume cs:_text$mn
.text$mn:00003028                 ;org 3028h
.text$mn:00003028 ; COMDAT (pick any)
.text$mn:00003028                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003028
.text$mn:00003028 ; =============== S U B R O U T I N E =======================================
.text$mn:00003028
.text$mn:00003028 ; Attributes: bp-based frame
.text$mn:00003028
.text$mn:00003028 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00003028                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00003028 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00003028                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00003028
.text$mn:00003028 var_4           = dword ptr -4
.text$mn:00003028
.text$mn:00003028                 push    ebp
.text$mn:00003029                 mov     ebp, esp
.text$mn:0000302B                 push    ecx
.text$mn:0000302C                 mov     [ebp+var_4], ecx
.text$mn:0000302F                 mov     eax, [ebp+var_4]
.text$mn:00003032                 mov     esp, ebp
.text$mn:00003034                 pop     ebp
.text$mn:00003035                 retn
.text$mn:00003035 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00003035
.text$mn:00003035 ; ---------------------------------------------------------------------------
.text$mn:00003036                 align 4
.text$mn:00003036 _text$mn        ends
.text$mn:00003036
.text$mn:00003038 ; ===========================================================================
.text$mn:00003038
.text$mn:00003038 ; Segment type: Pure code
.text$mn:00003038 ; Segment permissions: Read/Execute
.text$mn:00003038 _text$mn        segment para public 'CODE' use32
.text$mn:00003038                 assume cs:_text$mn
.text$mn:00003038                 ;org 3038h
.text$mn:00003038 ; COMDAT (pick any)
.text$mn:00003038                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003038
.text$mn:00003038 ; =============== S U B R O U T I N E =======================================
.text$mn:00003038
.text$mn:00003038 ; Attributes: bp-based frame
.text$mn:00003038
.text$mn:00003038 ; public: __thiscall std::allocator<struct TreeStateNode>::allocator<struct TreeStateNode>(class std::allocator<struct TreeStateNode> const &)
.text$mn:00003038                 public ??0?$allocator@UTreeStateNode@@@std@@QAE@ABV01@@Z
.text$mn:00003038 ??0?$allocator@UTreeStateNode@@@std@@QAE@ABV01@@Z proc near
.text$mn:00003038                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TreeStateNode>>::_Wrap_alloc<std::allocator<TreeStateNode>>(std::allocator<TreeStateNode> const &)+Ep
.text$mn:00003038                                         ; std::allocator<TreeStateNode>::select_on_container_copy_construction(void)+Ep
.text$mn:00003038
.text$mn:00003038 var_4           = dword ptr -4
.text$mn:00003038
.text$mn:00003038                 push    ebp
.text$mn:00003039                 mov     ebp, esp
.text$mn:0000303B                 push    ecx
.text$mn:0000303C                 mov     [ebp+var_4], ecx
.text$mn:0000303F                 mov     eax, [ebp+var_4]
.text$mn:00003042                 mov     esp, ebp
.text$mn:00003044                 pop     ebp
.text$mn:00003045                 retn    4
.text$mn:00003045 ??0?$allocator@UTreeStateNode@@@std@@QAE@ABV01@@Z endp
.text$mn:00003045
.text$mn:00003045 _text$mn        ends
.text$mn:00003045
.text$mn:00003048 ; ===========================================================================
.text$mn:00003048
.text$mn:00003048 ; Segment type: Pure code
.text$mn:00003048 ; Segment permissions: Read/Execute
.text$mn:00003048 _text$mn        segment para public 'CODE' use32
.text$mn:00003048                 assume cs:_text$mn
.text$mn:00003048                 ;org 3048h
.text$mn:00003048 ; COMDAT (pick any)
.text$mn:00003048                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003048
.text$mn:00003048 ; =============== S U B R O U T I N E =======================================
.text$mn:00003048
.text$mn:00003048 ; Attributes: bp-based frame
.text$mn:00003048
.text$mn:00003048 ; public: __thiscall std::allocator<struct TreeStateNode>::allocator<struct TreeStateNode>(void)
.text$mn:00003048                 public ??0?$allocator@UTreeStateNode@@@std@@QAE@XZ
.text$mn:00003048 ??0?$allocator@UTreeStateNode@@@std@@QAE@XZ proc near
.text$mn:00003048                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TreeStateNode>>::_Wrap_alloc<std::allocator<TreeStateNode>>(void)+Ap
.text$mn:00003048                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(void)+2Bp
.text$mn:00003048
.text$mn:00003048 var_4           = dword ptr -4
.text$mn:00003048
.text$mn:00003048                 push    ebp
.text$mn:00003049                 mov     ebp, esp
.text$mn:0000304B                 push    ecx
.text$mn:0000304C                 mov     [ebp+var_4], ecx
.text$mn:0000304F                 mov     eax, [ebp+var_4]
.text$mn:00003052                 mov     esp, ebp
.text$mn:00003054                 pop     ebp
.text$mn:00003055                 retn
.text$mn:00003055 ??0?$allocator@UTreeStateNode@@@std@@QAE@XZ endp
.text$mn:00003055
.text$mn:00003055 ; ---------------------------------------------------------------------------
.text$mn:00003056                 align 4
.text$mn:00003056 _text$mn        ends
.text$mn:00003056
.text$mn:00003058 ; ===========================================================================
.text$mn:00003058
.text$mn:00003058 ; Segment type: Pure code
.text$mn:00003058 ; Segment permissions: Read/Execute
.text$mn:00003058 _text$mn        segment para public 'CODE' use32
.text$mn:00003058                 assume cs:_text$mn
.text$mn:00003058                 ;org 3058h
.text$mn:00003058 ; COMDAT (pick any)
.text$mn:00003058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003058
.text$mn:00003058 ; =============== S U B R O U T I N E =======================================
.text$mn:00003058
.text$mn:00003058 ; Attributes: bp-based frame
.text$mn:00003058
.text$mn:00003058 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00003058                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00003058 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00003058                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:00003058                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00003058
.text$mn:00003058 var_4           = dword ptr -4
.text$mn:00003058
.text$mn:00003058                 push    ebp
.text$mn:00003059                 mov     ebp, esp
.text$mn:0000305B                 push    ecx
.text$mn:0000305C                 mov     [ebp+var_4], ecx
.text$mn:0000305F                 mov     eax, [ebp+var_4]
.text$mn:00003062                 mov     esp, ebp
.text$mn:00003064                 pop     ebp
.text$mn:00003065                 retn
.text$mn:00003065 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00003065
.text$mn:00003065 ; ---------------------------------------------------------------------------
.text$mn:00003066                 align 4
.text$mn:00003066 _text$mn        ends
.text$mn:00003066
.text$mn:00003068 ; ===========================================================================
.text$mn:00003068
.text$mn:00003068 ; Segment type: Pure code
.text$mn:00003068 ; Segment permissions: Read/Execute
.text$mn:00003068 _text$mn        segment para public 'CODE' use32
.text$mn:00003068                 assume cs:_text$mn
.text$mn:00003068                 ;org 3068h
.text$mn:00003068 ; COMDAT (pick any)
.text$mn:00003068                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003068
.text$mn:00003068 ; =============== S U B R O U T I N E =======================================
.text$mn:00003068
.text$mn:00003068 ; Attributes: bp-based frame
.text$mn:00003068
.text$mn:00003068 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(class std::allocator<wchar_t> const &)
.text$mn:00003068                 public ??0?$allocator@_W@std@@QAE@ABV01@@Z
.text$mn:00003068 ??0?$allocator@_W@std@@QAE@ABV01@@Z proc near
.text$mn:00003068                                         ; CODE XREF: std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+Bp
.text$mn:00003068                                         ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+18p ...
.text$mn:00003068
.text$mn:00003068 var_4           = dword ptr -4
.text$mn:00003068
.text$mn:00003068                 push    ebp
.text$mn:00003069                 mov     ebp, esp
.text$mn:0000306B                 push    ecx
.text$mn:0000306C                 mov     [ebp+var_4], ecx
.text$mn:0000306F                 mov     eax, [ebp+var_4]
.text$mn:00003072                 mov     esp, ebp
.text$mn:00003074                 pop     ebp
.text$mn:00003075                 retn    4
.text$mn:00003075 ??0?$allocator@_W@std@@QAE@ABV01@@Z endp
.text$mn:00003075
.text$mn:00003075 _text$mn        ends
.text$mn:00003075
.text$mn:00003078 ; ===========================================================================
.text$mn:00003078
.text$mn:00003078 ; Segment type: Pure code
.text$mn:00003078 ; Segment permissions: Read/Execute
.text$mn:00003078 _text$mn        segment para public 'CODE' use32
.text$mn:00003078                 assume cs:_text$mn
.text$mn:00003078                 ;org 3078h
.text$mn:00003078 ; COMDAT (pick any)
.text$mn:00003078                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003078
.text$mn:00003078 ; =============== S U B R O U T I N E =======================================
.text$mn:00003078
.text$mn:00003078 ; Attributes: bp-based frame
.text$mn:00003078
.text$mn:00003078 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00003078                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:00003078 ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:00003078                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+2Bp ...
.text$mn:00003078
.text$mn:00003078 var_4           = dword ptr -4
.text$mn:00003078
.text$mn:00003078                 push    ebp
.text$mn:00003079                 mov     ebp, esp
.text$mn:0000307B                 push    ecx
.text$mn:0000307C                 mov     [ebp+var_4], ecx
.text$mn:0000307F                 mov     eax, [ebp+var_4]
.text$mn:00003082                 mov     esp, ebp
.text$mn:00003084                 pop     ebp
.text$mn:00003085                 retn
.text$mn:00003085 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00003085
.text$mn:00003085 ; ---------------------------------------------------------------------------
.text$mn:00003086                 align 4
.text$mn:00003086 _text$mn        ends
.text$mn:00003086
.text$mn:00003088 ; ===========================================================================
.text$mn:00003088
.text$mn:00003088 ; Segment type: Pure code
.text$mn:00003088 ; Segment permissions: Read/Execute
.text$mn:00003088 _text$mn        segment para public 'CODE' use32
.text$mn:00003088                 assume cs:_text$mn
.text$mn:00003088                 ;org 3088h
.text$mn:00003088 ; COMDAT (pick any)
.text$mn:00003088                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003088
.text$mn:00003088 ; =============== S U B R O U T I N E =======================================
.text$mn:00003088
.text$mn:00003088 ; Attributes: bp-based frame
.text$mn:00003088
.text$mn:00003088 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00003088                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00003088 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00003088                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00003088                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00003088
.text$mn:00003088 var_14          = dword ptr -14h
.text$mn:00003088 var_D           = byte ptr -0Dh
.text$mn:00003088 var_C           = dword ptr -0Ch
.text$mn:00003088 var_4           = dword ptr -4
.text$mn:00003088 Str             = dword ptr  8
.text$mn:00003088
.text$mn:00003088                 push    ebp
.text$mn:00003089                 mov     ebp, esp
.text$mn:0000308B                 push    0FFFFFFFFh
.text$mn:0000308D                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00003092                 mov     eax, large fs:0
.text$mn:00003098                 push    eax
.text$mn:00003099                 sub     esp, 8
.text$mn:0000309C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000030A1                 xor     eax, ebp
.text$mn:000030A3                 push    eax
.text$mn:000030A4                 lea     eax, [ebp+var_C]
.text$mn:000030A7                 mov     large fs:0, eax
.text$mn:000030AD                 mov     [ebp+var_14], ecx
.text$mn:000030B0                 lea     ecx, [ebp+var_D]
.text$mn:000030B3                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000030B8                 push    eax
.text$mn:000030B9                 mov     ecx, [ebp+var_14]
.text$mn:000030BC                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000030C1                 mov     [ebp+var_4], 0
.text$mn:000030C8                 push    0               ; Size
.text$mn:000030CA                 push    0               ; char
.text$mn:000030CC                 mov     ecx, [ebp+var_14]
.text$mn:000030CF                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000030D4                 mov     eax, [ebp+Str]
.text$mn:000030D7                 push    eax             ; Str
.text$mn:000030D8                 mov     ecx, [ebp+var_14]
.text$mn:000030DB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000030E0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000030E7                 mov     eax, [ebp+var_14]
.text$mn:000030EA                 mov     ecx, [ebp+var_C]
.text$mn:000030ED                 mov     large fs:0, ecx
.text$mn:000030F4                 pop     ecx
.text$mn:000030F5                 mov     esp, ebp
.text$mn:000030F7                 pop     ebp
.text$mn:000030F8                 retn    4
.text$mn:000030F8 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:000030F8
.text$mn:000030F8 ; ---------------------------------------------------------------------------
.text$mn:000030FB                 align 4
.text$mn:000030FB _text$mn        ends
.text$mn:000030FB
.text$x:000030FC ; ===========================================================================
.text$x:000030FC
.text$x:000030FC ; Segment type: Pure code
.text$x:000030FC ; Segment permissions: Read/Execute
.text$x:000030FC _text$x         segment para public 'CODE' use32
.text$x:000030FC                 assume cs:_text$x
.text$x:000030FC                 ;org 30FCh
.text$x:000030FC ; COMDAT (pick associative to section at 3088)
.text$x:000030FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000030FC
.text$x:000030FC ; =============== S U B R O U T I N E =======================================
.text$x:000030FC
.text$x:000030FC
.text$x:000030FC __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:000030FC                                         ; DATA XREF: .xdata$x:00006E6Co
.text$x:000030FC                 mov     ecx, [ebp-14h]
.text$x:000030FF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000030FF __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:000030FF
.text$x:00003104
.text$x:00003104 ; =============== S U B R O U T I N E =======================================
.text$x:00003104
.text$x:00003104
.text$x:00003104 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00003104                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00003104
.text$x:00003104 arg_4           = dword ptr  8
.text$x:00003104
.text$x:00003104                 mov     edx, [esp+arg_4]
.text$x:00003108                 lea     eax, [edx+0Ch]
.text$x:0000310B                 mov     ecx, [edx-0Ch]
.text$x:0000310E                 xor     ecx, eax
.text$x:00003110                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003115                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:0000311A                 jmp     ___CxxFrameHandler3
.text$x:0000311A __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:0000311A
.text$x:0000311A ; ---------------------------------------------------------------------------
.text$x:0000311F                 align 10h
.text$x:0000311F _text$x         ends
.text$x:0000311F
.text$mn:00003120 ; ===========================================================================
.text$mn:00003120
.text$mn:00003120 ; Segment type: Pure code
.text$mn:00003120 ; Segment permissions: Read/Execute
.text$mn:00003120 _text$mn        segment para public 'CODE' use32
.text$mn:00003120                 assume cs:_text$mn
.text$mn:00003120                 ;org 3120h
.text$mn:00003120 ; COMDAT (pick any)
.text$mn:00003120                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003120
.text$mn:00003120 ; =============== S U B R O U T I N E =======================================
.text$mn:00003120
.text$mn:00003120 ; Attributes: bp-based frame
.text$mn:00003120
.text$mn:00003120 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00003120                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:00003120 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$mn:00003120                                         ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+1D9p
.text$mn:00003120                                         ; TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+245p ...
.text$mn:00003120
.text$mn:00003120 var_14          = dword ptr -14h
.text$mn:00003120 var_E           = byte ptr -0Eh
.text$mn:00003120 var_D           = byte ptr -0Dh
.text$mn:00003120 var_C           = dword ptr -0Ch
.text$mn:00003120 var_4           = dword ptr -4
.text$mn:00003120 arg_0           = dword ptr  8
.text$mn:00003120
.text$mn:00003120                 push    ebp
.text$mn:00003121                 mov     ebp, esp
.text$mn:00003123                 push    0FFFFFFFFh
.text$mn:00003125                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:0000312A                 mov     eax, large fs:0
.text$mn:00003130                 push    eax
.text$mn:00003131                 sub     esp, 8
.text$mn:00003134                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003139                 xor     eax, ebp
.text$mn:0000313B                 push    eax
.text$mn:0000313C                 lea     eax, [ebp+var_C]
.text$mn:0000313F                 mov     large fs:0, eax
.text$mn:00003145                 mov     [ebp+var_14], ecx
.text$mn:00003148                 lea     eax, [ebp+var_D]
.text$mn:0000314B                 push    eax
.text$mn:0000314C                 lea     ecx, [ebp+var_E]
.text$mn:0000314F                 push    ecx
.text$mn:00003150                 mov     ecx, [ebp+arg_0]
.text$mn:00003153                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00003158                 mov     ecx, eax
.text$mn:0000315A                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)
.text$mn:0000315F                 push    eax
.text$mn:00003160                 mov     ecx, [ebp+var_14]
.text$mn:00003163                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00003168                 mov     [ebp+var_4], 0
.text$mn:0000316F                 push    0
.text$mn:00003171                 push    0
.text$mn:00003173                 mov     ecx, [ebp+var_14]
.text$mn:00003176                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000317B                 mov     edx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00003181                 push    edx
.text$mn:00003182                 push    0
.text$mn:00003184                 mov     eax, [ebp+arg_0]
.text$mn:00003187                 push    eax
.text$mn:00003188                 mov     ecx, [ebp+var_14]
.text$mn:0000318B                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00003190                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003197                 mov     eax, [ebp+var_14]
.text$mn:0000319A                 mov     ecx, [ebp+var_C]
.text$mn:0000319D                 mov     large fs:0, ecx
.text$mn:000031A4                 pop     ecx
.text$mn:000031A5                 mov     esp, ebp
.text$mn:000031A7                 pop     ebp
.text$mn:000031A8                 retn    4
.text$mn:000031A8 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$mn:000031A8
.text$mn:000031A8 ; ---------------------------------------------------------------------------
.text$mn:000031AB                 align 4
.text$mn:000031AB _text$mn        ends
.text$mn:000031AB
.text$x:000031AC ; ===========================================================================
.text$x:000031AC
.text$x:000031AC ; Segment type: Pure code
.text$x:000031AC ; Segment permissions: Read/Execute
.text$x:000031AC _text$x         segment para public 'CODE' use32
.text$x:000031AC                 assume cs:_text$x
.text$x:000031AC                 ;org 31ACh
.text$x:000031AC ; COMDAT (pick associative to section at 3120)
.text$x:000031AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000031AC
.text$x:000031AC ; =============== S U B R O U T I N E =======================================
.text$x:000031AC
.text$x:000031AC
.text$x:000031AC __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 proc near
.text$x:000031AC                                         ; DATA XREF: .xdata$x:0000718Co
.text$x:000031AC                 mov     ecx, [ebp-14h]
.text$x:000031AF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000031AF __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 endp
.text$x:000031AF
.text$x:000031B4
.text$x:000031B4 ; =============== S U B R O U T I N E =======================================
.text$x:000031B4
.text$x:000031B4
.text$x:000031B4 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$x:000031B4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:000031B4
.text$x:000031B4 arg_4           = dword ptr  8
.text$x:000031B4
.text$x:000031B4                 mov     edx, [esp+arg_4]
.text$x:000031B8                 lea     eax, [edx+0Ch]
.text$x:000031BB                 mov     ecx, [edx-0Ch]
.text$x:000031BE                 xor     ecx, eax
.text$x:000031C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000031C5                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$x:000031CA                 jmp     ___CxxFrameHandler3
.text$x:000031CA __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$x:000031CA
.text$x:000031CA ; ---------------------------------------------------------------------------
.text$x:000031CF                 align 10h
.text$x:000031CF _text$x         ends
.text$x:000031CF
.text$mn:000031D0 ; ===========================================================================
.text$mn:000031D0
.text$mn:000031D0 ; Segment type: Pure code
.text$mn:000031D0 ; Segment permissions: Read/Execute
.text$mn:000031D0 _text$mn        segment para public 'CODE' use32
.text$mn:000031D0                 assume cs:_text$mn
.text$mn:000031D0                 ;org 31D0h
.text$mn:000031D0 ; COMDAT (pick any)
.text$mn:000031D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031D0
.text$mn:000031D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000031D0
.text$mn:000031D0 ; Attributes: bp-based frame
.text$mn:000031D0
.text$mn:000031D0 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t *Str)
.text$mn:000031D0                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:000031D0 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$mn:000031D0                                         ; CODE XREF: TreeView::addItem(wchar_t const *,_TREEITEM *,int,wchar_t const *)+7Ap
.text$mn:000031D0                                         ; TreeView::setItemParam(_TREEITEM *,wchar_t const *)+81p ...
.text$mn:000031D0
.text$mn:000031D0 var_14          = dword ptr -14h
.text$mn:000031D0 var_D           = byte ptr -0Dh
.text$mn:000031D0 var_C           = dword ptr -0Ch
.text$mn:000031D0 var_4           = dword ptr -4
.text$mn:000031D0 Str             = dword ptr  8
.text$mn:000031D0
.text$mn:000031D0                 push    ebp
.text$mn:000031D1                 mov     ebp, esp
.text$mn:000031D3                 push    0FFFFFFFFh
.text$mn:000031D5                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:000031DA                 mov     eax, large fs:0
.text$mn:000031E0                 push    eax
.text$mn:000031E1                 sub     esp, 8
.text$mn:000031E4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000031E9                 xor     eax, ebp
.text$mn:000031EB                 push    eax
.text$mn:000031EC                 lea     eax, [ebp+var_C]
.text$mn:000031EF                 mov     large fs:0, eax
.text$mn:000031F5                 mov     [ebp+var_14], ecx
.text$mn:000031F8                 lea     ecx, [ebp+var_D]
.text$mn:000031FB                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00003200                 push    eax
.text$mn:00003201                 mov     ecx, [ebp+var_14]
.text$mn:00003204                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00003209                 mov     [ebp+var_4], 0
.text$mn:00003210                 push    0
.text$mn:00003212                 push    0
.text$mn:00003214                 mov     ecx, [ebp+var_14]
.text$mn:00003217                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000321C                 mov     eax, [ebp+Str]
.text$mn:0000321F                 push    eax             ; Str
.text$mn:00003220                 mov     ecx, [ebp+var_14]
.text$mn:00003223                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00003228                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000322F                 mov     eax, [ebp+var_14]
.text$mn:00003232                 mov     ecx, [ebp+var_C]
.text$mn:00003235                 mov     large fs:0, ecx
.text$mn:0000323C                 pop     ecx
.text$mn:0000323D                 mov     esp, ebp
.text$mn:0000323F                 pop     ebp
.text$mn:00003240                 retn    4
.text$mn:00003240 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$mn:00003240
.text$mn:00003240 ; ---------------------------------------------------------------------------
.text$mn:00003243                 align 4
.text$mn:00003243 _text$mn        ends
.text$mn:00003243
.text$x:00003244 ; ===========================================================================
.text$x:00003244
.text$x:00003244 ; Segment type: Pure code
.text$x:00003244 ; Segment permissions: Read/Execute
.text$x:00003244 _text$x         segment para public 'CODE' use32
.text$x:00003244                 assume cs:_text$x
.text$x:00003244                 ;org 3244h
.text$x:00003244 ; COMDAT (pick associative to section at 31D0)
.text$x:00003244                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003244
.text$x:00003244 ; =============== S U B R O U T I N E =======================================
.text$x:00003244
.text$x:00003244
.text$x:00003244 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 proc near
.text$x:00003244                                         ; DATA XREF: .xdata$x:000071E4o
.text$x:00003244                 mov     ecx, [ebp-14h]
.text$x:00003247                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00003247 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 endp
.text$x:00003247
.text$x:0000324C
.text$x:0000324C ; =============== S U B R O U T I N E =======================================
.text$x:0000324C
.text$x:0000324C
.text$x:0000324C __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$x:0000324C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+5o
.text$x:0000324C
.text$x:0000324C arg_4           = dword ptr  8
.text$x:0000324C
.text$x:0000324C                 mov     edx, [esp+arg_4]
.text$x:00003250                 lea     eax, [edx+0Ch]
.text$x:00003253                 mov     ecx, [edx-0Ch]
.text$x:00003256                 xor     ecx, eax
.text$x:00003258                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000325D                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$x:00003262                 jmp     ___CxxFrameHandler3
.text$x:00003262 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$x:00003262
.text$x:00003262 ; ---------------------------------------------------------------------------
.text$x:00003267                 align 4
.text$x:00003267 _text$x         ends
.text$x:00003267
.text$mn:00003268 ; ===========================================================================
.text$mn:00003268
.text$mn:00003268 ; Segment type: Pure code
.text$mn:00003268 ; Segment permissions: Read/Execute
.text$mn:00003268 _text$mn        segment para public 'CODE' use32
.text$mn:00003268                 assume cs:_text$mn
.text$mn:00003268                 ;org 3268h
.text$mn:00003268 ; COMDAT (pick any)
.text$mn:00003268                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003268
.text$mn:00003268 ; =============== S U B R O U T I N E =======================================
.text$mn:00003268
.text$mn:00003268 ; Attributes: bp-based frame
.text$mn:00003268
.text$mn:00003268 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00003268                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00003268 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00003268                                         ; CODE XREF: TreeStateNode::TreeStateNode(void)+29p
.text$mn:00003268                                         ; TreeStateNode::TreeStateNode(void)+3Bp
.text$mn:00003268
.text$mn:00003268 var_14          = dword ptr -14h
.text$mn:00003268 var_D           = byte ptr -0Dh
.text$mn:00003268 var_C           = dword ptr -0Ch
.text$mn:00003268 var_4           = dword ptr -4
.text$mn:00003268
.text$mn:00003268                 push    ebp
.text$mn:00003269                 mov     ebp, esp
.text$mn:0000326B                 push    0FFFFFFFFh
.text$mn:0000326D                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00003272                 mov     eax, large fs:0
.text$mn:00003278                 push    eax
.text$mn:00003279                 sub     esp, 8
.text$mn:0000327C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003281                 xor     eax, ebp
.text$mn:00003283                 push    eax
.text$mn:00003284                 lea     eax, [ebp+var_C]
.text$mn:00003287                 mov     large fs:0, eax
.text$mn:0000328D                 mov     [ebp+var_14], ecx
.text$mn:00003290                 lea     ecx, [ebp+var_D]
.text$mn:00003293                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00003298                 push    eax
.text$mn:00003299                 mov     ecx, [ebp+var_14]
.text$mn:0000329C                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:000032A1                 mov     [ebp+var_4], 0
.text$mn:000032A8                 push    0
.text$mn:000032AA                 push    0
.text$mn:000032AC                 mov     ecx, [ebp+var_14]
.text$mn:000032AF                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000032B4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000032BB                 mov     eax, [ebp+var_14]
.text$mn:000032BE                 mov     ecx, [ebp+var_C]
.text$mn:000032C1                 mov     large fs:0, ecx
.text$mn:000032C8                 pop     ecx
.text$mn:000032C9                 mov     esp, ebp
.text$mn:000032CB                 pop     ebp
.text$mn:000032CC                 retn
.text$mn:000032CC ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:000032CC
.text$mn:000032CC ; ---------------------------------------------------------------------------
.text$mn:000032CD                 align 10h
.text$mn:000032CD _text$mn        ends
.text$mn:000032CD
.text$x:000032D0 ; ===========================================================================
.text$x:000032D0
.text$x:000032D0 ; Segment type: Pure code
.text$x:000032D0 ; Segment permissions: Read/Execute
.text$x:000032D0 _text$x         segment para public 'CODE' use32
.text$x:000032D0                 assume cs:_text$x
.text$x:000032D0                 ;org 32D0h
.text$x:000032D0 ; COMDAT (pick associative to section at 3268)
.text$x:000032D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000032D0
.text$x:000032D0 ; =============== S U B R O U T I N E =======================================
.text$x:000032D0
.text$x:000032D0
.text$x:000032D0 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:000032D0                                         ; DATA XREF: .xdata$x:000071B8o
.text$x:000032D0                 mov     ecx, [ebp-14h]
.text$x:000032D3                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000032D3 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:000032D3
.text$x:000032D8
.text$x:000032D8 ; =============== S U B R O U T I N E =======================================
.text$x:000032D8
.text$x:000032D8
.text$x:000032D8 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:000032D8                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:000032D8
.text$x:000032D8 arg_4           = dword ptr  8
.text$x:000032D8
.text$x:000032D8                 mov     edx, [esp+arg_4]
.text$x:000032DC                 lea     eax, [edx+0Ch]
.text$x:000032DF                 mov     ecx, [edx-0Ch]
.text$x:000032E2                 xor     ecx, eax
.text$x:000032E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000032E9                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:000032EE                 jmp     ___CxxFrameHandler3
.text$x:000032EE __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:000032EE
.text$x:000032EE ; ---------------------------------------------------------------------------
.text$x:000032F3                 align 4
.text$x:000032F3 _text$x         ends
.text$x:000032F3
.text$mn:000032F4 ; ===========================================================================
.text$mn:000032F4
.text$mn:000032F4 ; Segment type: Pure code
.text$mn:000032F4 ; Segment permissions: Read/Execute
.text$mn:000032F4 _text$mn        segment para public 'CODE' use32
.text$mn:000032F4                 assume cs:_text$mn
.text$mn:000032F4                 ;org 32F4h
.text$mn:000032F4 ; COMDAT (pick any)
.text$mn:000032F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032F4
.text$mn:000032F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000032F4
.text$mn:000032F4 ; Attributes: bp-based frame
.text$mn:000032F4
.text$mn:000032F4 ; public: __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>(class std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>> const &)
.text$mn:000032F4                 public ??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000032F4 ??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:000032F4                                         ; CODE XREF: TreeStateNode::TreeStateNode(TreeStateNode const &)+74p
.text$mn:000032F4
.text$mn:000032F4 var_34          = dword ptr -34h
.text$mn:000032F4 var_30          = dword ptr -30h
.text$mn:000032F4 var_2C          = dword ptr -2Ch
.text$mn:000032F4 var_28          = dword ptr -28h
.text$mn:000032F4 var_24          = dword ptr -24h
.text$mn:000032F4 var_20          = dword ptr -20h
.text$mn:000032F4 var_1C          = dword ptr -1Ch
.text$mn:000032F4 var_18          = dword ptr -18h
.text$mn:000032F4 var_12          = byte ptr -12h
.text$mn:000032F4 var_11          = byte ptr -11h
.text$mn:000032F4 var_10          = dword ptr -10h
.text$mn:000032F4 var_C           = dword ptr -0Ch
.text$mn:000032F4 var_4           = dword ptr -4
.text$mn:000032F4 arg_0           = dword ptr  8
.text$mn:000032F4
.text$mn:000032F4 ; FUNCTION CHUNK AT .text$mn:000033DE SIZE 00000009 BYTES
.text$mn:000032F4 ; FUNCTION CHUNK AT .text$mn:000033EE SIZE 0000001E BYTES
.text$mn:000032F4
.text$mn:000032F4                 push    ebp
.text$mn:000032F5                 mov     ebp, esp
.text$mn:000032F7                 push    0FFFFFFFFh
.text$mn:000032F9                 push    offset __ehhandler$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000032FE                 mov     eax, large fs:0
.text$mn:00003304                 push    eax
.text$mn:00003305                 push    ecx
.text$mn:00003306                 sub     esp, 24h
.text$mn:00003309                 push    ebx
.text$mn:0000330A                 push    esi
.text$mn:0000330B                 push    edi
.text$mn:0000330C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003311                 xor     eax, ebp
.text$mn:00003313                 push    eax
.text$mn:00003314                 lea     eax, [ebp+var_C]
.text$mn:00003317                 mov     large fs:0, eax
.text$mn:0000331D                 mov     [ebp+var_10], esp
.text$mn:00003320                 mov     [ebp+var_18], ecx
.text$mn:00003323                 lea     eax, [ebp+var_11]
.text$mn:00003326                 push    eax
.text$mn:00003327                 lea     ecx, [ebp+var_12]
.text$mn:0000332A                 push    ecx
.text$mn:0000332B                 mov     ecx, [ebp+arg_0]
.text$mn:0000332E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Getal(void)
.text$mn:00003333                 mov     ecx, eax
.text$mn:00003335                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::select_on_container_copy_construction(void)
.text$mn:0000333A                 push    eax
.text$mn:0000333B                 mov     ecx, [ebp+var_18]
.text$mn:0000333E                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>(std::allocator<TreeStateNode> const &)
.text$mn:00003343                 mov     [ebp+var_4], 0
.text$mn:0000334A                 mov     ecx, [ebp+arg_0]
.text$mn:0000334D                 call    ?size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::size(void)
.text$mn:00003352                 push    eax
.text$mn:00003353                 mov     ecx, [ebp+var_18]
.text$mn:00003356                 call    ?_Buy@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAE_NI@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Buy(uint)
.text$mn:0000335B                 movzx   edx, al
.text$mn:0000335E                 test    edx, edx
.text$mn:00003360                 jz      loc_33EE
.text$mn:00003366                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000336A                 mov     eax, [ebp+var_18]
.text$mn:0000336D                 mov     ecx, [eax+4]
.text$mn:00003370                 push    ecx
.text$mn:00003371                 sub     esp, 0Ch
.text$mn:00003374                 mov     edx, esp
.text$mn:00003376                 mov     [ebp+var_28], esp
.text$mn:00003379                 push    edx
.text$mn:0000337A                 mov     ecx, [ebp+arg_0]
.text$mn:0000337D                 call    ?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::end(void)
.text$mn:00003382                 mov     [ebp+var_1C], eax
.text$mn:00003385                 mov     eax, [ebp+var_1C]
.text$mn:00003388                 mov     [ebp+var_2C], eax
.text$mn:0000338B                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000338F                 sub     esp, 0Ch
.text$mn:00003392                 mov     ecx, esp
.text$mn:00003394                 mov     [ebp+var_30], esp
.text$mn:00003397                 push    ecx
.text$mn:00003398                 mov     ecx, [ebp+arg_0]
.text$mn:0000339B                 call    ?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::begin(void)
.text$mn:000033A0                 mov     [ebp+var_20], eax
.text$mn:000033A3                 mov     edx, [ebp+var_20]
.text$mn:000033A6                 mov     [ebp+var_34], edx
.text$mn:000033A9                 mov     byte ptr [ebp+var_4], 3
.text$mn:000033AD                 mov     byte ptr [ebp+var_4], 1
.text$mn:000033B1                 mov     ecx, [ebp+var_18]
.text$mn:000033B4                 call    ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *)
.text$mn:000033B9                 mov     [ebp+var_24], eax
.text$mn:000033BC                 mov     eax, [ebp+var_18]
.text$mn:000033BF                 mov     ecx, [ebp+var_24]
.text$mn:000033C2                 mov     [eax+8], ecx
.text$mn:000033C5                 jmp     short loc_33DE
.text$mn:000033C5 ??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:000033C5
.text$mn:000033C7
.text$mn:000033C7 ; =============== S U B R O U T I N E =======================================
.text$mn:000033C7
.text$mn:000033C7 ; Attributes: noreturn
.text$mn:000033C7
.text$mn:000033C7 __catch$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$mn:000033C7                                         ; DATA XREF: .xdata$x:000073D8o
.text$mn:000033C7                 mov     ecx, [ebp-18h]
.text$mn:000033CA                 call    ?_Tidy@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Tidy(void)
.text$mn:000033CF                 push    0
.text$mn:000033D1                 push    0
.text$mn:000033D3                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000033D3 __catch$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$mn:000033D3
.text$mn:000033D8 ; ---------------------------------------------------------------------------
.text$mn:000033D8                 mov     eax, offset $LN11
.text$mn:000033DD                 retn
.text$mn:000033DE ; ---------------------------------------------------------------------------
.text$mn:000033DE ; START OF FUNCTION CHUNK FOR ??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000033DE
.text$mn:000033DE loc_33DE:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(std::vector<TreeStateNode,std::allocator<TreeStateNode>> const &)+D1j
.text$mn:000033DE                 mov     [ebp+var_4], 0
.text$mn:000033E5                 jmp     short loc_33EE
.text$mn:000033E5 ; END OF FUNCTION CHUNK FOR ??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000033E7
.text$mn:000033E7 ; =============== S U B R O U T I N E =======================================
.text$mn:000033E7
.text$mn:000033E7
.text$mn:000033E7 $LN11           proc near               ; DATA XREF: .text$mn:000033D8o
.text$mn:000033E7                 mov     dword ptr [ebp-4], 0
.text$mn:000033E7 $LN11           endp ; sp-analysis failed
.text$mn:000033E7
.text$mn:000033EE ; START OF FUNCTION CHUNK FOR ??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000033EE
.text$mn:000033EE loc_33EE:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(std::vector<TreeStateNode,std::allocator<TreeStateNode>> const &)+6Cj
.text$mn:000033EE                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(std::vector<TreeStateNode,std::allocator<TreeStateNode>> const &)+F1j
.text$mn:000033EE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000033F5                 mov     eax, [ebp+var_18]
.text$mn:000033F8                 mov     ecx, [ebp+var_C]
.text$mn:000033FB                 mov     large fs:0, ecx
.text$mn:00003402                 pop     ecx
.text$mn:00003403                 pop     edi
.text$mn:00003404                 pop     esi
.text$mn:00003405                 pop     ebx
.text$mn:00003406                 mov     esp, ebp
.text$mn:00003408                 pop     ebp
.text$mn:00003409                 retn    4
.text$mn:00003409 ; END OF FUNCTION CHUNK FOR ??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00003409 _text$mn        ends
.text$mn:00003409
.text$x:0000340C ; ===========================================================================
.text$x:0000340C
.text$x:0000340C ; Segment type: Pure code
.text$x:0000340C ; Segment permissions: Read/Execute
.text$x:0000340C _text$x         segment para public 'CODE' use32
.text$x:0000340C                 assume cs:_text$x
.text$x:0000340C                 ;org 340Ch
.text$x:0000340C ; COMDAT (pick associative to section at 32F4)
.text$x:0000340C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000340C
.text$x:0000340C ; =============== S U B R O U T I N E =======================================
.text$x:0000340C
.text$x:0000340C
.text$x:0000340C __unwindfunclet$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$2 proc near
.text$x:0000340C                                         ; DATA XREF: .xdata$x:00007418o
.text$x:0000340C                 mov     ecx, [ebp-18h]
.text$x:0000340F                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::~_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>(void)
.text$x:0000340F __unwindfunclet$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$2 endp
.text$x:0000340F
.text$x:00003414
.text$x:00003414 ; =============== S U B R O U T I N E =======================================
.text$x:00003414
.text$x:00003414
.text$x:00003414 __unwindfunclet$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$3 proc near
.text$x:00003414                                         ; DATA XREF: .xdata$x:00007428o
.text$x:00003414                 mov     ecx, [ebp-28h]
.text$x:00003417                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$x:00003417 __unwindfunclet$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$3 endp
.text$x:00003417
.text$x:0000341C
.text$x:0000341C ; =============== S U B R O U T I N E =======================================
.text$x:0000341C
.text$x:0000341C
.text$x:0000341C __unwindfunclet$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$4 proc near
.text$x:0000341C                                         ; DATA XREF: .xdata$x:00007430o
.text$x:0000341C                 mov     ecx, [ebp-30h]
.text$x:0000341F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$x:0000341F __unwindfunclet$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$4 endp
.text$x:0000341F
.text$x:00003424
.text$x:00003424 ; =============== S U B R O U T I N E =======================================
.text$x:00003424
.text$x:00003424
.text$x:00003424 __ehhandler$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00003424                                         ; DATA XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(std::vector<TreeStateNode,std::allocator<TreeStateNode>> const &)+5o
.text$x:00003424
.text$x:00003424 arg_4           = dword ptr  8
.text$x:00003424
.text$x:00003424                 mov     edx, [esp+arg_4]
.text$x:00003428                 lea     eax, [edx+0Ch]
.text$x:0000342B                 mov     ecx, [edx-38h]
.text$x:0000342E                 xor     ecx, eax
.text$x:00003430                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003435                 mov     eax, offset __ehfuncinfo$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000343A                 jmp     ___CxxFrameHandler3
.text$x:0000343A __ehhandler$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000343A
.text$x:0000343A ; ---------------------------------------------------------------------------
.text$x:0000343F                 align 10h
.text$x:0000343F _text$x         ends
.text$x:0000343F
.text$mn:00003440 ; ===========================================================================
.text$mn:00003440
.text$mn:00003440 ; Segment type: Pure code
.text$mn:00003440 ; Segment permissions: Read/Execute
.text$mn:00003440 _text$mn        segment para public 'CODE' use32
.text$mn:00003440                 assume cs:_text$mn
.text$mn:00003440                 ;org 3440h
.text$mn:00003440 ; COMDAT (pick any)
.text$mn:00003440                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003440
.text$mn:00003440 ; =============== S U B R O U T I N E =======================================
.text$mn:00003440
.text$mn:00003440 ; Attributes: bp-based frame
.text$mn:00003440
.text$mn:00003440 ; public: __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>(void)
.text$mn:00003440                 public ??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ
.text$mn:00003440 ??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ proc near
.text$mn:00003440                                         ; CODE XREF: TreeStateNode::TreeStateNode(void)+4Ap
.text$mn:00003440
.text$mn:00003440 var_14          = dword ptr -14h
.text$mn:00003440 var_D           = byte ptr -0Dh
.text$mn:00003440 var_C           = dword ptr -0Ch
.text$mn:00003440 var_4           = dword ptr -4
.text$mn:00003440
.text$mn:00003440                 push    ebp
.text$mn:00003441                 mov     ebp, esp
.text$mn:00003443                 push    0FFFFFFFFh
.text$mn:00003445                 push    offset __ehhandler$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ
.text$mn:0000344A                 mov     eax, large fs:0
.text$mn:00003450                 push    eax
.text$mn:00003451                 sub     esp, 8
.text$mn:00003454                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003459                 xor     eax, ebp
.text$mn:0000345B                 push    eax
.text$mn:0000345C                 lea     eax, [ebp+var_C]
.text$mn:0000345F                 mov     large fs:0, eax
.text$mn:00003465                 mov     [ebp+var_14], ecx
.text$mn:00003468                 lea     ecx, [ebp+var_D]
.text$mn:0000346B                 call    ??0?$allocator@UTreeStateNode@@@std@@QAE@XZ ; std::allocator<TreeStateNode>::allocator<TreeStateNode>(void)
.text$mn:00003470                 push    eax
.text$mn:00003471                 mov     ecx, [ebp+var_14]
.text$mn:00003474                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>(std::allocator<TreeStateNode> const &)
.text$mn:00003479                 mov     [ebp+var_4], 0
.text$mn:00003480                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003487                 mov     eax, [ebp+var_14]
.text$mn:0000348A                 mov     ecx, [ebp+var_C]
.text$mn:0000348D                 mov     large fs:0, ecx
.text$mn:00003494                 pop     ecx
.text$mn:00003495                 mov     esp, ebp
.text$mn:00003497                 pop     ebp
.text$mn:00003498                 retn
.text$mn:00003498 ??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ endp
.text$mn:00003498
.text$mn:00003498 ; ---------------------------------------------------------------------------
.text$mn:00003499                 align 4
.text$mn:00003499 _text$mn        ends
.text$mn:00003499
.text$x:0000349C ; ===========================================================================
.text$x:0000349C
.text$x:0000349C ; Segment type: Pure code
.text$x:0000349C ; Segment permissions: Read/Execute
.text$x:0000349C _text$x         segment para public 'CODE' use32
.text$x:0000349C                 assume cs:_text$x
.text$x:0000349C                 ;org 349Ch
.text$x:0000349C ; COMDAT (pick associative to section at 3440)
.text$x:0000349C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000349C
.text$x:0000349C ; =============== S U B R O U T I N E =======================================
.text$x:0000349C
.text$x:0000349C
.text$x:0000349C __unwindfunclet$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000349C                                         ; DATA XREF: .xdata$x:000073A4o
.text$x:0000349C                 mov     ecx, [ebp-14h]
.text$x:0000349F                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::~_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>(void)
.text$x:0000349F __unwindfunclet$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000349F
.text$x:000034A4
.text$x:000034A4 ; =============== S U B R O U T I N E =======================================
.text$x:000034A4
.text$x:000034A4
.text$x:000034A4 __ehhandler$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ proc near
.text$x:000034A4                                         ; DATA XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(void)+5o
.text$x:000034A4
.text$x:000034A4 arg_4           = dword ptr  8
.text$x:000034A4
.text$x:000034A4                 mov     edx, [esp+arg_4]
.text$x:000034A8                 lea     eax, [edx+0Ch]
.text$x:000034AB                 mov     ecx, [edx-0Ch]
.text$x:000034AE                 xor     ecx, eax
.text$x:000034B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000034B5                 mov     eax, offset __ehfuncinfo$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ
.text$x:000034BA                 jmp     ___CxxFrameHandler3
.text$x:000034BA __ehhandler$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ endp
.text$x:000034BA
.text$x:000034BA ; ---------------------------------------------------------------------------
.text$x:000034BF                 align 10h
.text$x:000034BF _text$x         ends
.text$x:000034BF
.text$mn:000034C0 ; ===========================================================================
.text$mn:000034C0
.text$mn:000034C0 ; Segment type: Pure code
.text$mn:000034C0 ; Segment permissions: Read/Execute
.text$mn:000034C0 _text$mn        segment para public 'CODE' use32
.text$mn:000034C0                 assume cs:_text$mn
.text$mn:000034C0                 ;org 34C0h
.text$mn:000034C0 ; COMDAT (pick any)
.text$mn:000034C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034C0
.text$mn:000034C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000034C0
.text$mn:000034C0 ; Attributes: bp-based frame
.text$mn:000034C0
.text$mn:000034C0 ; public: __thiscall TreeStateNode::TreeStateNode(struct TreeStateNode const &)
.text$mn:000034C0                 public ??0TreeStateNode@@QAE@ABU0@@Z
.text$mn:000034C0 ??0TreeStateNode@@QAE@ABU0@@Z proc near ; CODE XREF: std::allocator<TreeStateNode>::construct<TreeStateNode,TreeStateNode>(TreeStateNode *,TreeStateNode &&)+56p
.text$mn:000034C0                                         ; std::allocator<TreeStateNode>::construct(TreeStateNode *,TreeStateNode const &)+4Dp
.text$mn:000034C0
.text$mn:000034C0 var_10          = dword ptr -10h
.text$mn:000034C0 var_C           = dword ptr -0Ch
.text$mn:000034C0 var_4           = dword ptr -4
.text$mn:000034C0 arg_0           = dword ptr  8
.text$mn:000034C0
.text$mn:000034C0                 push    ebp
.text$mn:000034C1                 mov     ebp, esp
.text$mn:000034C3                 push    0FFFFFFFFh
.text$mn:000034C5                 push    offset __ehhandler$??0TreeStateNode@@QAE@ABU0@@Z
.text$mn:000034CA                 mov     eax, large fs:0
.text$mn:000034D0                 push    eax
.text$mn:000034D1                 push    ecx
.text$mn:000034D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000034D7                 xor     eax, ebp
.text$mn:000034D9                 push    eax
.text$mn:000034DA                 lea     eax, [ebp+var_C]
.text$mn:000034DD                 mov     large fs:0, eax
.text$mn:000034E3                 mov     [ebp+var_10], ecx
.text$mn:000034E6                 mov     eax, [ebp+arg_0]
.text$mn:000034E9                 push    eax
.text$mn:000034EA                 mov     ecx, [ebp+var_10]
.text$mn:000034ED                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000034F2                 mov     [ebp+var_4], 0
.text$mn:000034F9                 mov     ecx, [ebp+arg_0]
.text$mn:000034FC                 add     ecx, 1Ch
.text$mn:000034FF                 push    ecx
.text$mn:00003500                 mov     ecx, [ebp+var_10]
.text$mn:00003503                 add     ecx, 1Ch
.text$mn:00003506                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000350B                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000350F                 mov     edx, [ebp+var_10]
.text$mn:00003512                 mov     eax, [ebp+arg_0]
.text$mn:00003515                 mov     cl, [eax+38h]
.text$mn:00003518                 mov     [edx+38h], cl
.text$mn:0000351B                 mov     edx, [ebp+var_10]
.text$mn:0000351E                 mov     eax, [ebp+arg_0]
.text$mn:00003521                 mov     cl, [eax+39h]
.text$mn:00003524                 mov     [edx+39h], cl
.text$mn:00003527                 mov     edx, [ebp+arg_0]
.text$mn:0000352A                 add     edx, 3Ch ; '<'
.text$mn:0000352D                 push    edx
.text$mn:0000352E                 mov     ecx, [ebp+var_10]
.text$mn:00003531                 add     ecx, 3Ch ; '<'
.text$mn:00003534                 call    ??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(std::vector<TreeStateNode,std::allocator<TreeStateNode>> const &)
.text$mn:00003539                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000353D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003544                 mov     eax, [ebp+var_10]
.text$mn:00003547                 mov     ecx, [ebp+var_C]
.text$mn:0000354A                 mov     large fs:0, ecx
.text$mn:00003551                 pop     ecx
.text$mn:00003552                 mov     esp, ebp
.text$mn:00003554                 pop     ebp
.text$mn:00003555                 retn    4
.text$mn:00003555 ??0TreeStateNode@@QAE@ABU0@@Z endp
.text$mn:00003555
.text$mn:00003555 _text$mn        ends
.text$mn:00003555
.text$x:00003558 ; ===========================================================================
.text$x:00003558
.text$x:00003558 ; Segment type: Pure code
.text$x:00003558 ; Segment permissions: Read/Execute
.text$x:00003558 _text$x         segment para public 'CODE' use32
.text$x:00003558                 assume cs:_text$x
.text$x:00003558                 ;org 3558h
.text$x:00003558 ; COMDAT (pick associative to section at 34C0)
.text$x:00003558                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003558
.text$x:00003558 ; =============== S U B R O U T I N E =======================================
.text$x:00003558
.text$x:00003558
.text$x:00003558 __unwindfunclet$??0TreeStateNode@@QAE@ABU0@@Z$0 proc near
.text$x:00003558                                         ; DATA XREF: .xdata$x:000075C0o
.text$x:00003558                 mov     ecx, [ebp-10h]
.text$x:0000355B                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000355B __unwindfunclet$??0TreeStateNode@@QAE@ABU0@@Z$0 endp
.text$x:0000355B
.text$x:00003560
.text$x:00003560 ; =============== S U B R O U T I N E =======================================
.text$x:00003560
.text$x:00003560
.text$x:00003560 __unwindfunclet$??0TreeStateNode@@QAE@ABU0@@Z$1 proc near
.text$x:00003560                                         ; DATA XREF: .xdata$x:000075C8o
.text$x:00003560                 mov     ecx, [ebp-10h]
.text$x:00003563                 add     ecx, 1Ch
.text$x:00003566                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00003566 __unwindfunclet$??0TreeStateNode@@QAE@ABU0@@Z$1 endp
.text$x:00003566
.text$x:0000356B
.text$x:0000356B ; =============== S U B R O U T I N E =======================================
.text$x:0000356B
.text$x:0000356B
.text$x:0000356B __unwindfunclet$??0TreeStateNode@@QAE@ABU0@@Z$2 proc near
.text$x:0000356B                                         ; DATA XREF: .xdata$x:000075D0o
.text$x:0000356B                 mov     ecx, [ebp-10h]
.text$x:0000356E                 add     ecx, 3Ch ; '<'
.text$x:00003571                 jmp     ??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::~vector<TreeStateNode,std::allocator<TreeStateNode>>(void)
.text$x:00003571 __unwindfunclet$??0TreeStateNode@@QAE@ABU0@@Z$2 endp
.text$x:00003571
.text$x:00003576
.text$x:00003576 ; =============== S U B R O U T I N E =======================================
.text$x:00003576
.text$x:00003576
.text$x:00003576 __ehhandler$??0TreeStateNode@@QAE@ABU0@@Z proc near
.text$x:00003576                                         ; DATA XREF: TreeStateNode::TreeStateNode(TreeStateNode const &)+5o
.text$x:00003576
.text$x:00003576 arg_4           = dword ptr  8
.text$x:00003576
.text$x:00003576                 mov     edx, [esp+arg_4]
.text$x:0000357A                 lea     eax, [edx+0Ch]
.text$x:0000357D                 mov     ecx, [edx-8]
.text$x:00003580                 xor     ecx, eax
.text$x:00003582                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003587                 mov     eax, offset __ehfuncinfo$??0TreeStateNode@@QAE@ABU0@@Z
.text$x:0000358C                 jmp     ___CxxFrameHandler3
.text$x:0000358C __ehhandler$??0TreeStateNode@@QAE@ABU0@@Z endp
.text$x:0000358C
.text$x:0000358C ; ---------------------------------------------------------------------------
.text$x:00003591                 align 4
.text$x:00003591 _text$x         ends
.text$x:00003591
.text$mn:00003594 ; ===========================================================================
.text$mn:00003594
.text$mn:00003594 ; Segment type: Pure code
.text$mn:00003594 ; Segment permissions: Read/Execute
.text$mn:00003594 _text$mn        segment para public 'CODE' use32
.text$mn:00003594                 assume cs:_text$mn
.text$mn:00003594                 ;org 3594h
.text$mn:00003594 ; COMDAT (pick any)
.text$mn:00003594                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003594
.text$mn:00003594 ; =============== S U B R O U T I N E =======================================
.text$mn:00003594
.text$mn:00003594 ; Attributes: bp-based frame
.text$mn:00003594
.text$mn:00003594 ; _DWORD __thiscall TreeStateNode::TreeStateNode(TreeStateNode *__hidden this)
.text$mn:00003594                 public ??0TreeStateNode@@QAE@XZ
.text$mn:00003594 ??0TreeStateNode@@QAE@XZ proc near      ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+155p
.text$mn:00003594
.text$mn:00003594 var_10          = dword ptr -10h
.text$mn:00003594 var_C           = dword ptr -0Ch
.text$mn:00003594 var_4           = dword ptr -4
.text$mn:00003594
.text$mn:00003594                 push    ebp
.text$mn:00003595                 mov     ebp, esp
.text$mn:00003597                 push    0FFFFFFFFh
.text$mn:00003599                 push    offset __ehhandler$??0TreeStateNode@@QAE@XZ
.text$mn:0000359E                 mov     eax, large fs:0
.text$mn:000035A4                 push    eax
.text$mn:000035A5                 push    ecx
.text$mn:000035A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000035AB                 xor     eax, ebp
.text$mn:000035AD                 push    eax
.text$mn:000035AE                 lea     eax, [ebp+var_C]
.text$mn:000035B1                 mov     large fs:0, eax
.text$mn:000035B7                 mov     [ebp+var_10], ecx
.text$mn:000035BA                 mov     ecx, [ebp+var_10]
.text$mn:000035BD                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000035C2                 mov     [ebp+var_4], 0
.text$mn:000035C9                 mov     ecx, [ebp+var_10]
.text$mn:000035CC                 add     ecx, 1Ch
.text$mn:000035CF                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000035D4                 mov     byte ptr [ebp+var_4], 1
.text$mn:000035D8                 mov     ecx, [ebp+var_10]
.text$mn:000035DB                 add     ecx, 3Ch ; '<'
.text$mn:000035DE                 call    ??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(void)
.text$mn:000035E3                 mov     byte ptr [ebp+var_4], 2
.text$mn:000035E7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000035EE                 mov     eax, [ebp+var_10]
.text$mn:000035F1                 mov     ecx, [ebp+var_C]
.text$mn:000035F4                 mov     large fs:0, ecx
.text$mn:000035FB                 pop     ecx
.text$mn:000035FC                 mov     esp, ebp
.text$mn:000035FE                 pop     ebp
.text$mn:000035FF                 retn
.text$mn:000035FF ??0TreeStateNode@@QAE@XZ endp
.text$mn:000035FF
.text$mn:000035FF _text$mn        ends
.text$mn:000035FF
.text$x:00003600 ; ===========================================================================
.text$x:00003600
.text$x:00003600 ; Segment type: Pure code
.text$x:00003600 ; Segment permissions: Read/Execute
.text$x:00003600 _text$x         segment para public 'CODE' use32
.text$x:00003600                 assume cs:_text$x
.text$x:00003600                 ;org 3600h
.text$x:00003600 ; COMDAT (pick associative to section at 3594)
.text$x:00003600                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003600
.text$x:00003600 ; =============== S U B R O U T I N E =======================================
.text$x:00003600
.text$x:00003600
.text$x:00003600 __unwindfunclet$??0TreeStateNode@@QAE@XZ$0 proc near
.text$x:00003600                                         ; DATA XREF: .xdata$x:00007548o
.text$x:00003600                 mov     ecx, [ebp-10h]
.text$x:00003603                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00003603 __unwindfunclet$??0TreeStateNode@@QAE@XZ$0 endp
.text$x:00003603
.text$x:00003608
.text$x:00003608 ; =============== S U B R O U T I N E =======================================
.text$x:00003608
.text$x:00003608
.text$x:00003608 __unwindfunclet$??0TreeStateNode@@QAE@XZ$1 proc near
.text$x:00003608                                         ; DATA XREF: .xdata$x:00007550o
.text$x:00003608                 mov     ecx, [ebp-10h]
.text$x:0000360B                 add     ecx, 1Ch
.text$x:0000360E                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000360E __unwindfunclet$??0TreeStateNode@@QAE@XZ$1 endp
.text$x:0000360E
.text$x:00003613
.text$x:00003613 ; =============== S U B R O U T I N E =======================================
.text$x:00003613
.text$x:00003613
.text$x:00003613 __unwindfunclet$??0TreeStateNode@@QAE@XZ$2 proc near
.text$x:00003613                                         ; DATA XREF: .xdata$x:00007558o
.text$x:00003613                 mov     ecx, [ebp-10h]
.text$x:00003616                 add     ecx, 3Ch ; '<'
.text$x:00003619                 jmp     ??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::~vector<TreeStateNode,std::allocator<TreeStateNode>>(void)
.text$x:00003619 __unwindfunclet$??0TreeStateNode@@QAE@XZ$2 endp
.text$x:00003619
.text$x:0000361E
.text$x:0000361E ; =============== S U B R O U T I N E =======================================
.text$x:0000361E
.text$x:0000361E
.text$x:0000361E __ehhandler$??0TreeStateNode@@QAE@XZ proc near
.text$x:0000361E                                         ; DATA XREF: TreeStateNode::TreeStateNode(void)+5o
.text$x:0000361E
.text$x:0000361E arg_4           = dword ptr  8
.text$x:0000361E
.text$x:0000361E                 mov     edx, [esp+arg_4]
.text$x:00003622                 lea     eax, [edx+0Ch]
.text$x:00003625                 mov     ecx, [edx-8]
.text$x:00003628                 xor     ecx, eax
.text$x:0000362A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000362F                 mov     eax, offset __ehfuncinfo$??0TreeStateNode@@QAE@XZ
.text$x:00003634                 jmp     ___CxxFrameHandler3
.text$x:00003634 __ehhandler$??0TreeStateNode@@QAE@XZ endp
.text$x:00003634
.text$x:00003634 ; ---------------------------------------------------------------------------
.text$x:00003639                 align 4
.text$x:00003639 _text$x         ends
.text$x:00003639
.text$mn:0000363C ; ===========================================================================
.text$mn:0000363C
.text$mn:0000363C ; Segment type: Pure code
.text$mn:0000363C ; Segment permissions: Read/Execute
.text$mn:0000363C _text$mn        segment para public 'CODE' use32
.text$mn:0000363C                 assume cs:_text$mn
.text$mn:0000363C                 ;org 363Ch
.text$mn:0000363C ; COMDAT (pick any)
.text$mn:0000363C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000363C
.text$mn:0000363C ; =============== S U B R O U T I N E =======================================
.text$mn:0000363C
.text$mn:0000363C ; Attributes: bp-based frame
.text$mn:0000363C
.text$mn:0000363C ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:0000363C                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:0000363C ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:0000363C                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:0000363C                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+29p ...
.text$mn:0000363C
.text$mn:0000363C var_4           = dword ptr -4
.text$mn:0000363C
.text$mn:0000363C                 push    ebp
.text$mn:0000363D                 mov     ebp, esp
.text$mn:0000363F                 push    ecx
.text$mn:00003640                 mov     [ebp+var_4], ecx
.text$mn:00003643                 mov     eax, [ebp+var_4]
.text$mn:00003646                 mov     dword ptr [eax], 0
.text$mn:0000364C                 mov     eax, [ebp+var_4]
.text$mn:0000364F                 mov     esp, ebp
.text$mn:00003651                 pop     ebp
.text$mn:00003652                 retn
.text$mn:00003652 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00003652
.text$mn:00003652 ; ---------------------------------------------------------------------------
.text$mn:00003653                 align 4
.text$mn:00003653 _text$mn        ends
.text$mn:00003653
.text$mn:00003654 ; ===========================================================================
.text$mn:00003654
.text$mn:00003654 ; Segment type: Pure code
.text$mn:00003654 ; Segment permissions: Read/Execute
.text$mn:00003654 _text$mn        segment para public 'CODE' use32
.text$mn:00003654                 assume cs:_text$mn
.text$mn:00003654                 ;org 3654h
.text$mn:00003654 ; COMDAT (pick any)
.text$mn:00003654                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003654
.text$mn:00003654 ; =============== S U B R O U T I N E =======================================
.text$mn:00003654
.text$mn:00003654 ; Attributes: bp-based frame
.text$mn:00003654
.text$mn:00003654 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00003654                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00003654 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00003654                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00003654                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+23p ...
.text$mn:00003654
.text$mn:00003654 var_4           = dword ptr -4
.text$mn:00003654
.text$mn:00003654                 push    ebp
.text$mn:00003655                 mov     ebp, esp
.text$mn:00003657                 push    ecx
.text$mn:00003658                 mov     [ebp+var_4], ecx
.text$mn:0000365B                 mov     eax, [ebp+var_4]
.text$mn:0000365E                 mov     dword ptr [eax], 0
.text$mn:00003664                 mov     ecx, [ebp+var_4]
.text$mn:00003667                 mov     dword ptr [ecx+4], 0
.text$mn:0000366E                 mov     eax, [ebp+var_4]
.text$mn:00003671                 mov     esp, ebp
.text$mn:00003673                 pop     ebp
.text$mn:00003674                 retn
.text$mn:00003674 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00003674
.text$mn:00003674 ; ---------------------------------------------------------------------------
.text$mn:00003675                 align 4
.text$mn:00003675 _text$mn        ends
.text$mn:00003675
.text$mn:00003678 ; ===========================================================================
.text$mn:00003678
.text$mn:00003678 ; Segment type: Pure code
.text$mn:00003678 ; Segment permissions: Read/Execute
.text$mn:00003678 _text$mn        segment para public 'CODE' use32
.text$mn:00003678                 assume cs:_text$mn
.text$mn:00003678                 ;org 3678h
.text$mn:00003678 ; COMDAT (pick any)
.text$mn:00003678                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003678
.text$mn:00003678 ; =============== S U B R O U T I N E =======================================
.text$mn:00003678
.text$mn:00003678 ; Attributes: bp-based frame
.text$mn:00003678
.text$mn:00003678 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00003678                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00003678 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00003678                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00003678                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00003678
.text$mn:00003678 var_10          = dword ptr -10h
.text$mn:00003678 var_C           = dword ptr -0Ch
.text$mn:00003678 var_4           = dword ptr -4
.text$mn:00003678
.text$mn:00003678                 push    ebp
.text$mn:00003679                 mov     ebp, esp
.text$mn:0000367B                 push    0FFFFFFFFh
.text$mn:0000367D                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00003682                 mov     eax, large fs:0
.text$mn:00003688                 push    eax
.text$mn:00003689                 push    ecx
.text$mn:0000368A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000368F                 xor     eax, ebp
.text$mn:00003691                 push    eax
.text$mn:00003692                 lea     eax, [ebp+var_C]
.text$mn:00003695                 mov     large fs:0, eax
.text$mn:0000369B                 mov     [ebp+var_10], ecx
.text$mn:0000369E                 mov     ecx, [ebp+var_10] ; this
.text$mn:000036A1                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:000036A6                 mov     [ebp+var_4], 0
.text$mn:000036AD                 mov     eax, [ebp+var_10]
.text$mn:000036B0                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:000036B6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000036BD                 mov     eax, [ebp+var_10]
.text$mn:000036C0                 mov     ecx, [ebp+var_C]
.text$mn:000036C3                 mov     large fs:0, ecx
.text$mn:000036CA                 pop     ecx
.text$mn:000036CB                 mov     esp, ebp
.text$mn:000036CD                 pop     ebp
.text$mn:000036CE                 retn
.text$mn:000036CE ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000036CE
.text$mn:000036CE ; ---------------------------------------------------------------------------
.text$mn:000036CF                 align 10h
.text$mn:000036CF _text$mn        ends
.text$mn:000036CF
.text$x:000036D0 ; ===========================================================================
.text$x:000036D0
.text$x:000036D0 ; Segment type: Pure code
.text$x:000036D0 ; Segment permissions: Read/Execute
.text$x:000036D0 _text$x         segment para public 'CODE' use32
.text$x:000036D0                 assume cs:_text$x
.text$x:000036D0                 ;org 36D0h
.text$x:000036D0 ; COMDAT (pick associative to section at 3678)
.text$x:000036D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000036D0
.text$x:000036D0 ; =============== S U B R O U T I N E =======================================
.text$x:000036D0
.text$x:000036D0
.text$x:000036D0 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000036D0                                         ; DATA XREF: .xdata$x:00006F50o
.text$x:000036D0                 mov     ecx, [ebp-10h]  ; this
.text$x:000036D3                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000036D3 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000036D3
.text$x:000036D8
.text$x:000036D8 ; =============== S U B R O U T I N E =======================================
.text$x:000036D8
.text$x:000036D8
.text$x:000036D8 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000036D8                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000036D8
.text$x:000036D8 arg_4           = dword ptr  8
.text$x:000036D8
.text$x:000036D8                 mov     edx, [esp+arg_4]
.text$x:000036DC                 lea     eax, [edx+0Ch]
.text$x:000036DF                 mov     ecx, [edx-8]
.text$x:000036E2                 xor     ecx, eax
.text$x:000036E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000036E9                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000036EE                 jmp     ___CxxFrameHandler3
.text$x:000036EE __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000036EE
.text$x:000036EE ; ---------------------------------------------------------------------------
.text$x:000036F3                 align 4
.text$x:000036F3 _text$x         ends
.text$x:000036F3
.text$mn:000036F4 ; ===========================================================================
.text$mn:000036F4
.text$mn:000036F4 ; Segment type: Pure code
.text$mn:000036F4 ; Segment permissions: Read/Execute
.text$mn:000036F4 _text$mn        segment para public 'CODE' use32
.text$mn:000036F4                 assume cs:_text$mn
.text$mn:000036F4                 ;org 36F4h
.text$mn:000036F4 ; COMDAT (pick any)
.text$mn:000036F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036F4
.text$mn:000036F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000036F4
.text$mn:000036F4 ; Attributes: bp-based frame
.text$mn:000036F4
.text$mn:000036F4 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000036F4                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000036F4 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:000036F4                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000036F4
.text$mn:000036F4 var_10          = dword ptr -10h
.text$mn:000036F4 var_C           = dword ptr -0Ch
.text$mn:000036F4 var_4           = dword ptr -4
.text$mn:000036F4
.text$mn:000036F4                 push    ebp
.text$mn:000036F5                 mov     ebp, esp
.text$mn:000036F7                 push    0FFFFFFFFh
.text$mn:000036F9                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000036FE                 mov     eax, large fs:0
.text$mn:00003704                 push    eax
.text$mn:00003705                 push    ecx
.text$mn:00003706                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000370B                 xor     eax, ebp
.text$mn:0000370D                 push    eax
.text$mn:0000370E                 lea     eax, [ebp+var_C]
.text$mn:00003711                 mov     large fs:0, eax
.text$mn:00003717                 mov     [ebp+var_10], ecx
.text$mn:0000371A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000371D                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00003722                 mov     [ebp+var_4], 0
.text$mn:00003729                 mov     eax, [ebp+var_10]
.text$mn:0000372C                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00003732                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003739                 mov     eax, [ebp+var_10]
.text$mn:0000373C                 mov     ecx, [ebp+var_C]
.text$mn:0000373F                 mov     large fs:0, ecx
.text$mn:00003746                 pop     ecx
.text$mn:00003747                 mov     esp, ebp
.text$mn:00003749                 pop     ebp
.text$mn:0000374A                 retn
.text$mn:0000374A ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:0000374A
.text$mn:0000374A ; ---------------------------------------------------------------------------
.text$mn:0000374B                 align 4
.text$mn:0000374B _text$mn        ends
.text$mn:0000374B
.text$x:0000374C ; ===========================================================================
.text$x:0000374C
.text$x:0000374C ; Segment type: Pure code
.text$x:0000374C ; Segment permissions: Read/Execute
.text$x:0000374C _text$x         segment para public 'CODE' use32
.text$x:0000374C                 assume cs:_text$x
.text$x:0000374C                 ;org 374Ch
.text$x:0000374C ; COMDAT (pick associative to section at 36F4)
.text$x:0000374C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000374C
.text$x:0000374C ; =============== S U B R O U T I N E =======================================
.text$x:0000374C
.text$x:0000374C
.text$x:0000374C __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:0000374C                                         ; DATA XREF: .xdata$x:00006FD4o
.text$x:0000374C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000374F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000374F __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:0000374F
.text$x:00003754
.text$x:00003754 ; =============== S U B R O U T I N E =======================================
.text$x:00003754
.text$x:00003754
.text$x:00003754 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00003754                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00003754
.text$x:00003754 arg_4           = dword ptr  8
.text$x:00003754
.text$x:00003754                 mov     edx, [esp+arg_4]
.text$x:00003758                 lea     eax, [edx+0Ch]
.text$x:0000375B                 mov     ecx, [edx-8]
.text$x:0000375E                 xor     ecx, eax
.text$x:00003760                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003765                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:0000376A                 jmp     ___CxxFrameHandler3
.text$x:0000376A __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:0000376A
.text$x:0000376A ; ---------------------------------------------------------------------------
.text$x:0000376F                 align 10h
.text$x:0000376F _text$x         ends
.text$x:0000376F
.text$mn:00003770 ; ===========================================================================
.text$mn:00003770
.text$mn:00003770 ; Segment type: Pure code
.text$mn:00003770 ; Segment permissions: Read/Execute
.text$mn:00003770 _text$mn        segment para public 'CODE' use32
.text$mn:00003770                 assume cs:_text$mn
.text$mn:00003770                 ;org 3770h
.text$mn:00003770 ; COMDAT (pick any)
.text$mn:00003770                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003770
.text$mn:00003770 ; =============== S U B R O U T I N E =======================================
.text$mn:00003770
.text$mn:00003770 ; Attributes: bp-based frame
.text$mn:00003770
.text$mn:00003770 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:00003770                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:00003770 ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:00003770                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00003770
.text$mn:00003770 var_4           = dword ptr -4
.text$mn:00003770 arg_0           = dword ptr  8
.text$mn:00003770
.text$mn:00003770                 push    ebp
.text$mn:00003771                 mov     ebp, esp
.text$mn:00003773                 push    ecx
.text$mn:00003774                 mov     [ebp+var_4], ecx
.text$mn:00003777                 mov     eax, [ebp+var_4]
.text$mn:0000377A                 mov     dword ptr [eax], 0
.text$mn:00003780                 mov     ecx, [ebp+var_4]
.text$mn:00003783                 mov     dword ptr [ecx+4], 0
.text$mn:0000378A                 mov     edx, [ebp+arg_0]
.text$mn:0000378D                 push    edx
.text$mn:0000378E                 mov     ecx, [ebp+var_4]
.text$mn:00003791                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:00003796                 mov     eax, [ebp+var_4]
.text$mn:00003799                 mov     esp, ebp
.text$mn:0000379B                 pop     ebp
.text$mn:0000379C                 retn    4
.text$mn:0000379C ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:0000379C
.text$mn:0000379C ; ---------------------------------------------------------------------------
.text$mn:0000379F                 align 10h
.text$mn:0000379F _text$mn        ends
.text$mn:0000379F
.text$mn:000037A0 ; ===========================================================================
.text$mn:000037A0
.text$mn:000037A0 ; Segment type: Pure code
.text$mn:000037A0 ; Segment permissions: Read/Execute
.text$mn:000037A0 _text$mn        segment para public 'CODE' use32
.text$mn:000037A0                 assume cs:_text$mn
.text$mn:000037A0                 ;org 37A0h
.text$mn:000037A0 ; COMDAT (pick any)
.text$mn:000037A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037A0
.text$mn:000037A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000037A0
.text$mn:000037A0 ; Attributes: bp-based frame
.text$mn:000037A0
.text$mn:000037A0 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:000037A0                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:000037A0 ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:000037A0                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>(void)+29p
.text$mn:000037A0
.text$mn:000037A0 var_4           = dword ptr -4
.text$mn:000037A0
.text$mn:000037A0                 push    ebp
.text$mn:000037A1                 mov     ebp, esp
.text$mn:000037A3                 push    ecx
.text$mn:000037A4                 mov     [ebp+var_4], ecx
.text$mn:000037A7                 mov     eax, [ebp+var_4]
.text$mn:000037AA                 mov     dword ptr [eax], 0
.text$mn:000037B0                 mov     ecx, [ebp+var_4]
.text$mn:000037B3                 mov     dword ptr [ecx+4], 0
.text$mn:000037BA                 mov     eax, [ebp+var_4]
.text$mn:000037BD                 mov     esp, ebp
.text$mn:000037BF                 pop     ebp
.text$mn:000037C0                 retn
.text$mn:000037C0 ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:000037C0
.text$mn:000037C0 ; ---------------------------------------------------------------------------
.text$mn:000037C1                 align 4
.text$mn:000037C1 _text$mn        ends
.text$mn:000037C1
.text$mn:000037C4 ; ===========================================================================
.text$mn:000037C4
.text$mn:000037C4 ; Segment type: Pure code
.text$mn:000037C4 ; Segment permissions: Read/Execute
.text$mn:000037C4 _text$mn        segment para public 'CODE' use32
.text$mn:000037C4                 assume cs:_text$mn
.text$mn:000037C4                 ;org 37C4h
.text$mn:000037C4 ; COMDAT (pick any)
.text$mn:000037C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037C4
.text$mn:000037C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000037C4
.text$mn:000037C4 ; Attributes: bp-based frame
.text$mn:000037C4
.text$mn:000037C4 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000037C4                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:000037C4 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:000037C4                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000037C4
.text$mn:000037C4 var_10          = dword ptr -10h
.text$mn:000037C4 var_C           = dword ptr -0Ch
.text$mn:000037C4 var_4           = dword ptr -4
.text$mn:000037C4
.text$mn:000037C4                 push    ebp
.text$mn:000037C5                 mov     ebp, esp
.text$mn:000037C7                 push    0FFFFFFFFh
.text$mn:000037C9                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:000037CE                 mov     eax, large fs:0
.text$mn:000037D4                 push    eax
.text$mn:000037D5                 push    ecx
.text$mn:000037D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000037DB                 xor     eax, ebp
.text$mn:000037DD                 push    eax
.text$mn:000037DE                 lea     eax, [ebp+var_C]
.text$mn:000037E1                 mov     large fs:0, eax
.text$mn:000037E7                 mov     [ebp+var_10], ecx
.text$mn:000037EA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000037ED                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000037F2                 mov     [ebp+var_4], 0
.text$mn:000037F9                 mov     eax, [ebp+var_10]
.text$mn:000037FC                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00003802                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003809                 mov     eax, [ebp+var_10]
.text$mn:0000380C                 mov     ecx, [ebp+var_C]
.text$mn:0000380F                 mov     large fs:0, ecx
.text$mn:00003816                 pop     ecx
.text$mn:00003817                 mov     esp, ebp
.text$mn:00003819                 pop     ebp
.text$mn:0000381A                 retn
.text$mn:0000381A ??0_System_error_category@std@@QAE@XZ endp
.text$mn:0000381A
.text$mn:0000381A ; ---------------------------------------------------------------------------
.text$mn:0000381B                 align 4
.text$mn:0000381B _text$mn        ends
.text$mn:0000381B
.text$x:0000381C ; ===========================================================================
.text$x:0000381C
.text$x:0000381C ; Segment type: Pure code
.text$x:0000381C ; Segment permissions: Read/Execute
.text$x:0000381C _text$x         segment para public 'CODE' use32
.text$x:0000381C                 assume cs:_text$x
.text$x:0000381C                 ;org 381Ch
.text$x:0000381C ; COMDAT (pick associative to section at 37C4)
.text$x:0000381C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000381C
.text$x:0000381C ; =============== S U B R O U T I N E =======================================
.text$x:0000381C
.text$x:0000381C
.text$x:0000381C __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:0000381C                                         ; DATA XREF: .xdata$x:00007058o
.text$x:0000381C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000381F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000381F __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:0000381F
.text$x:00003824
.text$x:00003824 ; =============== S U B R O U T I N E =======================================
.text$x:00003824
.text$x:00003824
.text$x:00003824 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00003824                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00003824
.text$x:00003824 arg_4           = dword ptr  8
.text$x:00003824
.text$x:00003824                 mov     edx, [esp+arg_4]
.text$x:00003828                 lea     eax, [edx+0Ch]
.text$x:0000382B                 mov     ecx, [edx-8]
.text$x:0000382E                 xor     ecx, eax
.text$x:00003830                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003835                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:0000383A                 jmp     ___CxxFrameHandler3
.text$x:0000383A __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:0000383A
.text$x:0000383A ; ---------------------------------------------------------------------------
.text$x:0000383F                 align 10h
.text$x:0000383F _text$x         ends
.text$x:0000383F
.text$mn:00003840 ; ===========================================================================
.text$mn:00003840
.text$mn:00003840 ; Segment type: Pure code
.text$mn:00003840 ; Segment permissions: Read/Execute
.text$mn:00003840 _text$mn        segment para public 'CODE' use32
.text$mn:00003840                 assume cs:_text$mn
.text$mn:00003840                 ;org 3840h
.text$mn:00003840 ; COMDAT (pick any)
.text$mn:00003840                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003840
.text$mn:00003840 ; =============== S U B R O U T I N E =======================================
.text$mn:00003840
.text$mn:00003840 ; Attributes: bp-based frame
.text$mn:00003840
.text$mn:00003840 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00003840                 public ??0error_category@std@@QAE@XZ
.text$mn:00003840 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00003840
.text$mn:00003840 var_4           = dword ptr -4
.text$mn:00003840
.text$mn:00003840                 push    ebp
.text$mn:00003841                 mov     ebp, esp
.text$mn:00003843                 push    ecx
.text$mn:00003844                 mov     [ebp+var_4], ecx
.text$mn:00003847                 mov     eax, [ebp+var_4]
.text$mn:0000384A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00003850                 mov     eax, [ebp+var_4]
.text$mn:00003853                 mov     esp, ebp
.text$mn:00003855                 pop     ebp
.text$mn:00003856                 retn
.text$mn:00003856 ??0error_category@std@@QAE@XZ endp
.text$mn:00003856
.text$mn:00003856 ; ---------------------------------------------------------------------------
.text$mn:00003857                 align 4
.text$mn:00003857 _text$mn        ends
.text$mn:00003857
.text$mn:00003858 ; ===========================================================================
.text$mn:00003858
.text$mn:00003858 ; Segment type: Pure code
.text$mn:00003858 ; Segment permissions: Read/Execute
.text$mn:00003858 _text$mn        segment para public 'CODE' use32
.text$mn:00003858                 assume cs:_text$mn
.text$mn:00003858                 ;org 3858h
.text$mn:00003858 ; COMDAT (pick any)
.text$mn:00003858                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003858
.text$mn:00003858 ; =============== S U B R O U T I N E =======================================
.text$mn:00003858
.text$mn:00003858 ; Attributes: bp-based frame
.text$mn:00003858
.text$mn:00003858 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00003858                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00003858 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00003858                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00003858                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00003858
.text$mn:00003858 var_4           = dword ptr -4
.text$mn:00003858 arg_0           = dword ptr  8
.text$mn:00003858 arg_4           = dword ptr  0Ch
.text$mn:00003858
.text$mn:00003858                 push    ebp
.text$mn:00003859                 mov     ebp, esp
.text$mn:0000385B                 push    ecx
.text$mn:0000385C                 mov     [ebp+var_4], ecx
.text$mn:0000385F                 mov     eax, [ebp+var_4]
.text$mn:00003862                 mov     ecx, [ebp+arg_0]
.text$mn:00003865                 mov     [eax], ecx
.text$mn:00003867                 mov     edx, [ebp+var_4]
.text$mn:0000386A                 mov     eax, [ebp+arg_4]
.text$mn:0000386D                 mov     [edx+4], eax
.text$mn:00003870                 mov     eax, [ebp+var_4]
.text$mn:00003873                 mov     esp, ebp
.text$mn:00003875                 pop     ebp
.text$mn:00003876                 retn    8
.text$mn:00003876 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00003876
.text$mn:00003876 ; ---------------------------------------------------------------------------
.text$mn:00003879                 align 4
.text$mn:00003879 _text$mn        ends
.text$mn:00003879
.text$mn:0000387C ; ===========================================================================
.text$mn:0000387C
.text$mn:0000387C ; Segment type: Pure code
.text$mn:0000387C ; Segment permissions: Read/Execute
.text$mn:0000387C _text$mn        segment para public 'CODE' use32
.text$mn:0000387C                 assume cs:_text$mn
.text$mn:0000387C                 ;org 387Ch
.text$mn:0000387C ; COMDAT (pick any)
.text$mn:0000387C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000387C
.text$mn:0000387C ; =============== S U B R O U T I N E =======================================
.text$mn:0000387C
.text$mn:0000387C ; Attributes: bp-based frame
.text$mn:0000387C
.text$mn:0000387C ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:0000387C                 public ??0id@locale@std@@QAE@I@Z
.text$mn:0000387C ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:0000387C                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:0000387C
.text$mn:0000387C var_4           = dword ptr -4
.text$mn:0000387C arg_0           = dword ptr  8
.text$mn:0000387C
.text$mn:0000387C                 push    ebp
.text$mn:0000387D                 mov     ebp, esp
.text$mn:0000387F                 push    ecx
.text$mn:00003880                 mov     [ebp+var_4], ecx
.text$mn:00003883                 mov     eax, [ebp+var_4]
.text$mn:00003886                 mov     ecx, [ebp+arg_0]
.text$mn:00003889                 mov     [eax], ecx
.text$mn:0000388B                 mov     eax, [ebp+var_4]
.text$mn:0000388E                 mov     esp, ebp
.text$mn:00003890                 pop     ebp
.text$mn:00003891                 retn    4
.text$mn:00003891 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00003891
.text$mn:00003891 _text$mn        ends
.text$mn:00003891
.text$mn:00003894 ; ===========================================================================
.text$mn:00003894
.text$mn:00003894 ; Segment type: Pure code
.text$mn:00003894 ; Segment permissions: Read/Execute
.text$mn:00003894 _text$mn        segment para public 'CODE' use32
.text$mn:00003894                 assume cs:_text$mn
.text$mn:00003894                 ;org 3894h
.text$mn:00003894 ; COMDAT (pick any)
.text$mn:00003894                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003894
.text$mn:00003894 ; =============== S U B R O U T I N E =======================================
.text$mn:00003894
.text$mn:00003894 ; Attributes: bp-based frame
.text$mn:00003894
.text$mn:00003894 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct TreeStateNode, int, struct TreeStateNode const *, struct TreeStateNode const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, struct TreeStateNode, int, struct TreeStateNode const *, struct TreeStateNode const &, struct std::_Iterator_base12>(void)
.text$mn:00003894                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003894 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00003894                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00003894                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:00003894
.text$mn:00003894 var_10          = dword ptr -10h
.text$mn:00003894 var_C           = dword ptr -0Ch
.text$mn:00003894 var_4           = dword ptr -4
.text$mn:00003894
.text$mn:00003894                 push    ebp
.text$mn:00003895                 mov     ebp, esp
.text$mn:00003897                 push    0FFFFFFFFh
.text$mn:00003899                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000389E                 mov     eax, large fs:0
.text$mn:000038A4                 push    eax
.text$mn:000038A5                 push    ecx
.text$mn:000038A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000038AB                 xor     eax, ebp
.text$mn:000038AD                 push    eax
.text$mn:000038AE                 lea     eax, [ebp+var_C]
.text$mn:000038B1                 mov     large fs:0, eax
.text$mn:000038B7                 mov     [ebp+var_10], ecx
.text$mn:000038BA                 mov     [ebp+var_4], 0
.text$mn:000038C1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000038C8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000038CB                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:000038D0                 mov     ecx, [ebp+var_C]
.text$mn:000038D3                 mov     large fs:0, ecx
.text$mn:000038DA                 pop     ecx
.text$mn:000038DB                 mov     esp, ebp
.text$mn:000038DD                 pop     ebp
.text$mn:000038DE                 retn
.text$mn:000038DE ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:000038DE
.text$mn:000038DE ; ---------------------------------------------------------------------------
.text$mn:000038DF                 align 10h
.text$mn:000038DF _text$mn        ends
.text$mn:000038DF
.text$x:000038E0 ; ===========================================================================
.text$x:000038E0
.text$x:000038E0 ; Segment type: Pure code
.text$x:000038E0 ; Segment permissions: Read/Execute
.text$x:000038E0 _text$x         segment para public 'CODE' use32
.text$x:000038E0                 assume cs:_text$x
.text$x:000038E0                 ;org 38E0h
.text$x:000038E0 ; COMDAT (pick associative to section at 3894)
.text$x:000038E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000038E0
.text$x:000038E0 ; =============== S U B R O U T I N E =======================================
.text$x:000038E0
.text$x:000038E0
.text$x:000038E0 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:000038E0                                         ; DATA XREF: .xdata$x:00007784o
.text$x:000038E0                 mov     ecx, [ebp-10h]  ; this
.text$x:000038E3                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000038E3 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:000038E3
.text$x:000038E8
.text$x:000038E8 ; =============== S U B R O U T I N E =======================================
.text$x:000038E8
.text$x:000038E8
.text$x:000038E8 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:000038E8                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>(void)+5o
.text$x:000038E8
.text$x:000038E8 arg_4           = dword ptr  8
.text$x:000038E8
.text$x:000038E8                 mov     edx, [esp+arg_4]
.text$x:000038EC                 lea     eax, [edx+0Ch]
.text$x:000038EF                 mov     ecx, [edx-8]
.text$x:000038F2                 xor     ecx, eax
.text$x:000038F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000038F9                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:000038FE                 jmp     ___CxxFrameHandler3
.text$x:000038FE __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:000038FE
.text$x:000038FE ; ---------------------------------------------------------------------------
.text$x:00003903                 align 4
.text$x:00003903 _text$x         ends
.text$x:00003903
.text$mn:00003904 ; ===========================================================================
.text$mn:00003904
.text$mn:00003904 ; Segment type: Pure code
.text$mn:00003904 ; Segment permissions: Read/Execute
.text$mn:00003904 _text$mn        segment para public 'CODE' use32
.text$mn:00003904                 assume cs:_text$mn
.text$mn:00003904                 ;org 3904h
.text$mn:00003904 ; COMDAT (pick any)
.text$mn:00003904                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003904
.text$mn:00003904 ; =============== S U B R O U T I N E =======================================
.text$mn:00003904
.text$mn:00003904 ; Attributes: bp-based frame
.text$mn:00003904
.text$mn:00003904 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00003904                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00003904 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003904                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00003904                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00003904
.text$mn:00003904 var_10          = dword ptr -10h
.text$mn:00003904 var_C           = dword ptr -0Ch
.text$mn:00003904 var_4           = dword ptr -4
.text$mn:00003904
.text$mn:00003904                 push    ebp
.text$mn:00003905                 mov     ebp, esp
.text$mn:00003907                 push    0FFFFFFFFh
.text$mn:00003909                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000390E                 mov     eax, large fs:0
.text$mn:00003914                 push    eax
.text$mn:00003915                 push    ecx
.text$mn:00003916                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000391B                 xor     eax, ebp
.text$mn:0000391D                 push    eax
.text$mn:0000391E                 lea     eax, [ebp+var_C]
.text$mn:00003921                 mov     large fs:0, eax
.text$mn:00003927                 mov     [ebp+var_10], ecx
.text$mn:0000392A                 mov     [ebp+var_4], 0
.text$mn:00003931                 mov     ecx, [ebp+var_10]
.text$mn:00003934                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00003939                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003940                 mov     ecx, [ebp+var_10]
.text$mn:00003943                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00003948                 mov     ecx, [ebp+var_C]
.text$mn:0000394B                 mov     large fs:0, ecx
.text$mn:00003952                 pop     ecx
.text$mn:00003953                 mov     esp, ebp
.text$mn:00003955                 pop     ebp
.text$mn:00003956                 retn
.text$mn:00003956 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003956
.text$mn:00003956 ; ---------------------------------------------------------------------------
.text$mn:00003957                 align 4
.text$mn:00003957 _text$mn        ends
.text$mn:00003957
.text$x:00003958 ; ===========================================================================
.text$x:00003958
.text$x:00003958 ; Segment type: Pure code
.text$x:00003958 ; Segment permissions: Read/Execute
.text$x:00003958 _text$x         segment para public 'CODE' use32
.text$x:00003958                 assume cs:_text$x
.text$x:00003958                 ;org 3958h
.text$x:00003958 ; COMDAT (pick associative to section at 3904)
.text$x:00003958                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003958
.text$x:00003958 ; =============== S U B R O U T I N E =======================================
.text$x:00003958
.text$x:00003958
.text$x:00003958 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003958                                         ; DATA XREF: .xdata$x:00006E40o
.text$x:00003958                 mov     ecx, [ebp-10h]
.text$x:0000395B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000395B __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000395B
.text$x:00003960
.text$x:00003960 ; =============== S U B R O U T I N E =======================================
.text$x:00003960
.text$x:00003960
.text$x:00003960 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00003960                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00003960
.text$x:00003960 arg_4           = dword ptr  8
.text$x:00003960
.text$x:00003960                 mov     edx, [esp+arg_4]
.text$x:00003964                 lea     eax, [edx+0Ch]
.text$x:00003967                 mov     ecx, [edx-8]
.text$x:0000396A                 xor     ecx, eax
.text$x:0000396C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003971                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00003976                 jmp     ___CxxFrameHandler3
.text$x:00003976 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00003976
.text$x:00003976 ; ---------------------------------------------------------------------------
.text$x:0000397B                 align 4
.text$x:0000397B _text$x         ends
.text$x:0000397B
.text$mn:0000397C ; ===========================================================================
.text$mn:0000397C
.text$mn:0000397C ; Segment type: Pure code
.text$mn:0000397C ; Segment permissions: Read/Execute
.text$mn:0000397C _text$mn        segment para public 'CODE' use32
.text$mn:0000397C                 assume cs:_text$mn
.text$mn:0000397C                 ;org 397Ch
.text$mn:0000397C ; COMDAT (pick any)
.text$mn:0000397C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000397C
.text$mn:0000397C ; =============== S U B R O U T I N E =======================================
.text$mn:0000397C
.text$mn:0000397C ; Attributes: bp-based frame
.text$mn:0000397C
.text$mn:0000397C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:0000397C                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:0000397C ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000397C                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0+3j
.text$mn:0000397C                                         ; __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0+3j ...
.text$mn:0000397C
.text$mn:0000397C var_10          = dword ptr -10h
.text$mn:0000397C var_C           = dword ptr -0Ch
.text$mn:0000397C var_4           = dword ptr -4
.text$mn:0000397C
.text$mn:0000397C                 push    ebp
.text$mn:0000397D                 mov     ebp, esp
.text$mn:0000397F                 push    0FFFFFFFFh
.text$mn:00003981                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00003986                 mov     eax, large fs:0
.text$mn:0000398C                 push    eax
.text$mn:0000398D                 push    ecx
.text$mn:0000398E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003993                 xor     eax, ebp
.text$mn:00003995                 push    eax
.text$mn:00003996                 lea     eax, [ebp+var_C]
.text$mn:00003999                 mov     large fs:0, eax
.text$mn:0000399F                 mov     [ebp+var_10], ecx
.text$mn:000039A2                 mov     [ebp+var_4], 0
.text$mn:000039A9                 mov     ecx, [ebp+var_10]
.text$mn:000039AC                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:000039B1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000039B8                 mov     ecx, [ebp+var_10]
.text$mn:000039BB                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:000039C0                 mov     ecx, [ebp+var_C]
.text$mn:000039C3                 mov     large fs:0, ecx
.text$mn:000039CA                 pop     ecx
.text$mn:000039CB                 mov     esp, ebp
.text$mn:000039CD                 pop     ebp
.text$mn:000039CE                 retn
.text$mn:000039CE ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:000039CE
.text$mn:000039CE ; ---------------------------------------------------------------------------
.text$mn:000039CF                 align 10h
.text$mn:000039CF _text$mn        ends
.text$mn:000039CF
.text$x:000039D0 ; ===========================================================================
.text$x:000039D0
.text$x:000039D0 ; Segment type: Pure code
.text$x:000039D0 ; Segment permissions: Read/Execute
.text$x:000039D0 _text$x         segment para public 'CODE' use32
.text$x:000039D0                 assume cs:_text$x
.text$x:000039D0                 ;org 39D0h
.text$x:000039D0 ; COMDAT (pick associative to section at 397C)
.text$x:000039D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000039D0
.text$x:000039D0 ; =============== S U B R O U T I N E =======================================
.text$x:000039D0
.text$x:000039D0
.text$x:000039D0 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000039D0                                         ; DATA XREF: .xdata$x:00007160o
.text$x:000039D0                 mov     ecx, [ebp-10h]
.text$x:000039D3                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:000039D3 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000039D3
.text$x:000039D8
.text$x:000039D8 ; =============== S U B R O U T I N E =======================================
.text$x:000039D8
.text$x:000039D8
.text$x:000039D8 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:000039D8                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:000039D8
.text$x:000039D8 arg_4           = dword ptr  8
.text$x:000039D8
.text$x:000039D8                 mov     edx, [esp+arg_4]
.text$x:000039DC                 lea     eax, [edx+0Ch]
.text$x:000039DF                 mov     ecx, [edx-8]
.text$x:000039E2                 xor     ecx, eax
.text$x:000039E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000039E9                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:000039EE                 jmp     ___CxxFrameHandler3
.text$x:000039EE __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:000039EE
.text$x:000039EE ; ---------------------------------------------------------------------------
.text$x:000039F3                 align 4
.text$x:000039F3 _text$x         ends
.text$x:000039F3
.text$mn:000039F4 ; ===========================================================================
.text$mn:000039F4
.text$mn:000039F4 ; Segment type: Pure code
.text$mn:000039F4 ; Segment permissions: Read/Execute
.text$mn:000039F4 _text$mn        segment para public 'CODE' use32
.text$mn:000039F4                 assume cs:_text$mn
.text$mn:000039F4                 ;org 39F4h
.text$mn:000039F4 ; COMDAT (pick any)
.text$mn:000039F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000039F4
.text$mn:000039F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000039F4
.text$mn:000039F4 ; Attributes: bp-based frame
.text$mn:000039F4
.text$mn:000039F4 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000039F4                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000039F4 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000039F4                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:000039F4                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:000039F4
.text$mn:000039F4 var_10          = dword ptr -10h
.text$mn:000039F4 var_C           = dword ptr -0Ch
.text$mn:000039F4 var_4           = dword ptr -4
.text$mn:000039F4
.text$mn:000039F4                 push    ebp
.text$mn:000039F5                 mov     ebp, esp
.text$mn:000039F7                 push    0FFFFFFFFh
.text$mn:000039F9                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000039FE                 mov     eax, large fs:0
.text$mn:00003A04                 push    eax
.text$mn:00003A05                 push    ecx
.text$mn:00003A06                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003A0B                 xor     eax, ebp
.text$mn:00003A0D                 push    eax
.text$mn:00003A0E                 lea     eax, [ebp+var_C]
.text$mn:00003A11                 mov     large fs:0, eax
.text$mn:00003A17                 mov     [ebp+var_10], ecx
.text$mn:00003A1A                 mov     [ebp+var_4], 0
.text$mn:00003A21                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003A28                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003A2B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00003A30                 mov     ecx, [ebp+var_C]
.text$mn:00003A33                 mov     large fs:0, ecx
.text$mn:00003A3A                 pop     ecx
.text$mn:00003A3B                 mov     esp, ebp
.text$mn:00003A3D                 pop     ebp
.text$mn:00003A3E                 retn
.text$mn:00003A3E ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00003A3E
.text$mn:00003A3E ; ---------------------------------------------------------------------------
.text$mn:00003A3F                 align 10h
.text$mn:00003A3F _text$mn        ends
.text$mn:00003A3F
.text$x:00003A40 ; ===========================================================================
.text$x:00003A40
.text$x:00003A40 ; Segment type: Pure code
.text$x:00003A40 ; Segment permissions: Read/Execute
.text$x:00003A40 _text$x         segment para public 'CODE' use32
.text$x:00003A40                 assume cs:_text$x
.text$x:00003A40                 ;org 3A40h
.text$x:00003A40 ; COMDAT (pick associative to section at 39F4)
.text$x:00003A40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003A40
.text$x:00003A40 ; =============== S U B R O U T I N E =======================================
.text$x:00003A40
.text$x:00003A40
.text$x:00003A40 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00003A40                                         ; DATA XREF: .xdata$x:00006DE8o
.text$x:00003A40                 mov     ecx, [ebp-10h]  ; this
.text$x:00003A43                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00003A43 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00003A43
.text$x:00003A48
.text$x:00003A48 ; =============== S U B R O U T I N E =======================================
.text$x:00003A48
.text$x:00003A48
.text$x:00003A48 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00003A48                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00003A48
.text$x:00003A48 arg_4           = dword ptr  8
.text$x:00003A48
.text$x:00003A48                 mov     edx, [esp+arg_4]
.text$x:00003A4C                 lea     eax, [edx+0Ch]
.text$x:00003A4F                 mov     ecx, [edx-8]
.text$x:00003A52                 xor     ecx, eax
.text$x:00003A54                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003A59                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00003A5E                 jmp     ___CxxFrameHandler3
.text$x:00003A5E __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00003A5E
.text$x:00003A5E ; ---------------------------------------------------------------------------
.text$x:00003A63                 align 4
.text$x:00003A63 _text$x         ends
.text$x:00003A63
.text$mn:00003A64 ; ===========================================================================
.text$mn:00003A64
.text$mn:00003A64 ; Segment type: Pure code
.text$mn:00003A64 ; Segment permissions: Read/Execute
.text$mn:00003A64 _text$mn        segment para public 'CODE' use32
.text$mn:00003A64                 assume cs:_text$mn
.text$mn:00003A64                 ;org 3A64h
.text$mn:00003A64 ; COMDAT (pick any)
.text$mn:00003A64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A64
.text$mn:00003A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A64
.text$mn:00003A64 ; Attributes: bp-based frame
.text$mn:00003A64
.text$mn:00003A64 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00003A64                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00003A64 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00003A64                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:00003A64                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:00003A64
.text$mn:00003A64 var_10          = dword ptr -10h
.text$mn:00003A64 var_C           = dword ptr -0Ch
.text$mn:00003A64 var_4           = dword ptr -4
.text$mn:00003A64
.text$mn:00003A64                 push    ebp
.text$mn:00003A65                 mov     ebp, esp
.text$mn:00003A67                 push    0FFFFFFFFh
.text$mn:00003A69                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00003A6E                 mov     eax, large fs:0
.text$mn:00003A74                 push    eax
.text$mn:00003A75                 push    ecx
.text$mn:00003A76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003A7B                 xor     eax, ebp
.text$mn:00003A7D                 push    eax
.text$mn:00003A7E                 lea     eax, [ebp+var_C]
.text$mn:00003A81                 mov     large fs:0, eax
.text$mn:00003A87                 mov     [ebp+var_10], ecx
.text$mn:00003A8A                 mov     [ebp+var_4], 0
.text$mn:00003A91                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003A98                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003A9B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00003AA0                 mov     ecx, [ebp+var_C]
.text$mn:00003AA3                 mov     large fs:0, ecx
.text$mn:00003AAA                 pop     ecx
.text$mn:00003AAB                 mov     esp, ebp
.text$mn:00003AAD                 pop     ebp
.text$mn:00003AAE                 retn
.text$mn:00003AAE ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00003AAE
.text$mn:00003AAE ; ---------------------------------------------------------------------------
.text$mn:00003AAF                 align 10h
.text$mn:00003AAF _text$mn        ends
.text$mn:00003AAF
.text$x:00003AB0 ; ===========================================================================
.text$x:00003AB0
.text$x:00003AB0 ; Segment type: Pure code
.text$x:00003AB0 ; Segment permissions: Read/Execute
.text$x:00003AB0 _text$x         segment para public 'CODE' use32
.text$x:00003AB0                 assume cs:_text$x
.text$x:00003AB0                 ;org 3AB0h
.text$x:00003AB0 ; COMDAT (pick associative to section at 3A64)
.text$x:00003AB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003AB0
.text$x:00003AB0 ; =============== S U B R O U T I N E =======================================
.text$x:00003AB0
.text$x:00003AB0
.text$x:00003AB0 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00003AB0                                         ; DATA XREF: .xdata$x:00007108o
.text$x:00003AB0                 mov     ecx, [ebp-10h]  ; this
.text$x:00003AB3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00003AB3 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00003AB3
.text$x:00003AB8
.text$x:00003AB8 ; =============== S U B R O U T I N E =======================================
.text$x:00003AB8
.text$x:00003AB8
.text$x:00003AB8 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00003AB8                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00003AB8
.text$x:00003AB8 arg_4           = dword ptr  8
.text$x:00003AB8
.text$x:00003AB8                 mov     edx, [esp+arg_4]
.text$x:00003ABC                 lea     eax, [edx+0Ch]
.text$x:00003ABF                 mov     ecx, [edx-8]
.text$x:00003AC2                 xor     ecx, eax
.text$x:00003AC4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003AC9                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00003ACE                 jmp     ___CxxFrameHandler3
.text$x:00003ACE __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00003ACE
.text$x:00003ACE ; ---------------------------------------------------------------------------
.text$x:00003AD3                 align 4
.text$x:00003AD3 _text$x         ends
.text$x:00003AD3
.text$mn:00003AD4 ; ===========================================================================
.text$mn:00003AD4
.text$mn:00003AD4 ; Segment type: Pure code
.text$mn:00003AD4 ; Segment permissions: Read/Execute
.text$mn:00003AD4 _text$mn        segment para public 'CODE' use32
.text$mn:00003AD4                 assume cs:_text$mn
.text$mn:00003AD4                 ;org 3AD4h
.text$mn:00003AD4 ; COMDAT (pick any)
.text$mn:00003AD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003AD4
.text$mn:00003AD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AD4
.text$mn:00003AD4 ; Attributes: bp-based frame
.text$mn:00003AD4
.text$mn:00003AD4 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct TreeStateNode, class std::allocator<struct TreeStateNode>>>::~_Vector_alloc<0, struct std::_Vec_base_types<struct TreeStateNode, class std::allocator<struct TreeStateNode>>>(void)
.text$mn:00003AD4                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ
.text$mn:00003AD4 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003AD4                                         ; CODE XREF: __unwindfunclet$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$2+3j
.text$mn:00003AD4                                         ; __unwindfunclet$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00003AD4
.text$mn:00003AD4 var_10          = dword ptr -10h
.text$mn:00003AD4 var_C           = dword ptr -0Ch
.text$mn:00003AD4 var_4           = dword ptr -4
.text$mn:00003AD4
.text$mn:00003AD4                 push    ebp
.text$mn:00003AD5                 mov     ebp, esp
.text$mn:00003AD7                 push    0FFFFFFFFh
.text$mn:00003AD9                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ
.text$mn:00003ADE                 mov     eax, large fs:0
.text$mn:00003AE4                 push    eax
.text$mn:00003AE5                 push    ecx
.text$mn:00003AE6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003AEB                 xor     eax, ebp
.text$mn:00003AED                 push    eax
.text$mn:00003AEE                 lea     eax, [ebp+var_C]
.text$mn:00003AF1                 mov     large fs:0, eax
.text$mn:00003AF7                 mov     [ebp+var_10], ecx
.text$mn:00003AFA                 mov     [ebp+var_4], 0
.text$mn:00003B01                 mov     ecx, [ebp+var_10]
.text$mn:00003B04                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Free_proxy(void)
.text$mn:00003B09                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003B10                 mov     ecx, [ebp+var_10]
.text$mn:00003B13                 call    ??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<TreeStateNode>>::~_Vector_val<std::_Simple_types<TreeStateNode>>(void)
.text$mn:00003B18                 mov     ecx, [ebp+var_C]
.text$mn:00003B1B                 mov     large fs:0, ecx
.text$mn:00003B22                 pop     ecx
.text$mn:00003B23                 mov     esp, ebp
.text$mn:00003B25                 pop     ebp
.text$mn:00003B26                 retn
.text$mn:00003B26 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003B26
.text$mn:00003B26 ; ---------------------------------------------------------------------------
.text$mn:00003B27                 align 4
.text$mn:00003B27 _text$mn        ends
.text$mn:00003B27
.text$x:00003B28 ; ===========================================================================
.text$x:00003B28
.text$x:00003B28 ; Segment type: Pure code
.text$x:00003B28 ; Segment permissions: Read/Execute
.text$x:00003B28 _text$x         segment para public 'CODE' use32
.text$x:00003B28                 assume cs:_text$x
.text$x:00003B28                 ;org 3B28h
.text$x:00003B28 ; COMDAT (pick associative to section at 3AD4)
.text$x:00003B28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003B28
.text$x:00003B28 ; =============== S U B R O U T I N E =======================================
.text$x:00003B28
.text$x:00003B28
.text$x:00003B28 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003B28                                         ; DATA XREF: .xdata$x:00007378o
.text$x:00003B28                 mov     ecx, [ebp-10h]
.text$x:00003B2B                 jmp     ??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<TreeStateNode>>::~_Vector_val<std::_Simple_types<TreeStateNode>>(void)
.text$x:00003B2B __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003B2B
.text$x:00003B30
.text$x:00003B30 ; =============== S U B R O U T I N E =======================================
.text$x:00003B30
.text$x:00003B30
.text$x:00003B30 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00003B30                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::~_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>(void)+5o
.text$x:00003B30
.text$x:00003B30 arg_4           = dword ptr  8
.text$x:00003B30
.text$x:00003B30                 mov     edx, [esp+arg_4]
.text$x:00003B34                 lea     eax, [edx+0Ch]
.text$x:00003B37                 mov     ecx, [edx-8]
.text$x:00003B3A                 xor     ecx, eax
.text$x:00003B3C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003B41                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ
.text$x:00003B46                 jmp     ___CxxFrameHandler3
.text$x:00003B46 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00003B46
.text$x:00003B46 ; ---------------------------------------------------------------------------
.text$x:00003B4B                 align 4
.text$x:00003B4B _text$x         ends
.text$x:00003B4B
.text$mn:00003B4C ; ===========================================================================
.text$mn:00003B4C
.text$mn:00003B4C ; Segment type: Pure code
.text$mn:00003B4C ; Segment permissions: Read/Execute
.text$mn:00003B4C _text$mn        segment para public 'CODE' use32
.text$mn:00003B4C                 assume cs:_text$mn
.text$mn:00003B4C                 ;org 3B4Ch
.text$mn:00003B4C ; COMDAT (pick any)
.text$mn:00003B4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B4C
.text$mn:00003B4C ; =============== S U B R O U T I N E =======================================
.text$mn:00003B4C
.text$mn:00003B4C ; Attributes: bp-based frame
.text$mn:00003B4C
.text$mn:00003B4C ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>>(void)
.text$mn:00003B4C                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ
.text$mn:00003B4C ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003B4C                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *)+9Bp
.text$mn:00003B4C                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *)+AAp ...
.text$mn:00003B4C
.text$mn:00003B4C var_10          = dword ptr -10h
.text$mn:00003B4C var_C           = dword ptr -0Ch
.text$mn:00003B4C var_4           = dword ptr -4
.text$mn:00003B4C
.text$mn:00003B4C                 push    ebp
.text$mn:00003B4D                 mov     ebp, esp
.text$mn:00003B4F                 push    0FFFFFFFFh
.text$mn:00003B51                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ
.text$mn:00003B56                 mov     eax, large fs:0
.text$mn:00003B5C                 push    eax
.text$mn:00003B5D                 push    ecx
.text$mn:00003B5E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003B63                 xor     eax, ebp
.text$mn:00003B65                 push    eax
.text$mn:00003B66                 lea     eax, [ebp+var_C]
.text$mn:00003B69                 mov     large fs:0, eax
.text$mn:00003B6F                 mov     [ebp+var_10], ecx
.text$mn:00003B72                 mov     [ebp+var_4], 0
.text$mn:00003B79                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003B80                 mov     ecx, [ebp+var_10]
.text$mn:00003B83                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>(void)
.text$mn:00003B88                 mov     ecx, [ebp+var_C]
.text$mn:00003B8B                 mov     large fs:0, ecx
.text$mn:00003B92                 pop     ecx
.text$mn:00003B93                 mov     esp, ebp
.text$mn:00003B95                 pop     ebp
.text$mn:00003B96                 retn
.text$mn:00003B96 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003B96
.text$mn:00003B96 ; ---------------------------------------------------------------------------
.text$mn:00003B97                 align 4
.text$mn:00003B97 _text$mn        ends
.text$mn:00003B97
.text$x:00003B98 ; ===========================================================================
.text$x:00003B98
.text$x:00003B98 ; Segment type: Pure code
.text$x:00003B98 ; Segment permissions: Read/Execute
.text$x:00003B98 _text$x         segment para public 'CODE' use32
.text$x:00003B98                 assume cs:_text$x
.text$x:00003B98                 ;org 3B98h
.text$x:00003B98 ; COMDAT (pick associative to section at 3B4C)
.text$x:00003B98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003B98
.text$x:00003B98 ; =============== S U B R O U T I N E =======================================
.text$x:00003B98
.text$x:00003B98
.text$x:00003B98 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003B98                                         ; DATA XREF: .xdata$x:00007808o
.text$x:00003B98                 mov     ecx, [ebp-10h]
.text$x:00003B9B                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,TreeStateNode,int,TreeStateNode const *,TreeStateNode const &,std::_Iterator_base12>(void)
.text$x:00003B9B __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003B9B
.text$x:00003BA0
.text$x:00003BA0 ; =============== S U B R O U T I N E =======================================
.text$x:00003BA0
.text$x:00003BA0
.text$x:00003BA0 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00003BA0                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)+5o
.text$x:00003BA0
.text$x:00003BA0 arg_4           = dword ptr  8
.text$x:00003BA0
.text$x:00003BA0                 mov     edx, [esp+arg_4]
.text$x:00003BA4                 lea     eax, [edx+0Ch]
.text$x:00003BA7                 mov     ecx, [edx-8]
.text$x:00003BAA                 xor     ecx, eax
.text$x:00003BAC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BB1                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ
.text$x:00003BB6                 jmp     ___CxxFrameHandler3
.text$x:00003BB6 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00003BB6
.text$x:00003BB6 ; ---------------------------------------------------------------------------
.text$x:00003BBB                 align 4
.text$x:00003BBB _text$x         ends
.text$x:00003BBB
.text$mn:00003BBC ; ===========================================================================
.text$mn:00003BBC
.text$mn:00003BBC ; Segment type: Pure code
.text$mn:00003BBC ; Segment permissions: Read/Execute
.text$mn:00003BBC _text$mn        segment para public 'CODE' use32
.text$mn:00003BBC                 assume cs:_text$mn
.text$mn:00003BBC                 ;org 3BBCh
.text$mn:00003BBC ; COMDAT (pick any)
.text$mn:00003BBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003BBC
.text$mn:00003BBC ; =============== S U B R O U T I N E =======================================
.text$mn:00003BBC
.text$mn:00003BBC ; Attributes: bp-based frame
.text$mn:00003BBC
.text$mn:00003BBC ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>::~_Vector_val<struct std::_Simple_types<struct TreeStateNode>>(void)
.text$mn:00003BBC                 public ??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ
.text$mn:00003BBC ??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ proc near
.text$mn:00003BBC                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z$0+3j
.text$mn:00003BBC                                         ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::~_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>(void)+3Fp ...
.text$mn:00003BBC
.text$mn:00003BBC var_10          = dword ptr -10h
.text$mn:00003BBC var_C           = dword ptr -0Ch
.text$mn:00003BBC var_4           = dword ptr -4
.text$mn:00003BBC
.text$mn:00003BBC                 push    ebp
.text$mn:00003BBD                 mov     ebp, esp
.text$mn:00003BBF                 push    0FFFFFFFFh
.text$mn:00003BC1                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ
.text$mn:00003BC6                 mov     eax, large fs:0
.text$mn:00003BCC                 push    eax
.text$mn:00003BCD                 push    ecx
.text$mn:00003BCE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003BD3                 xor     eax, ebp
.text$mn:00003BD5                 push    eax
.text$mn:00003BD6                 lea     eax, [ebp+var_C]
.text$mn:00003BD9                 mov     large fs:0, eax
.text$mn:00003BDF                 mov     [ebp+var_10], ecx
.text$mn:00003BE2                 mov     [ebp+var_4], 0
.text$mn:00003BE9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003BF0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003BF3                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00003BF8                 mov     ecx, [ebp+var_C]
.text$mn:00003BFB                 mov     large fs:0, ecx
.text$mn:00003C02                 pop     ecx
.text$mn:00003C03                 mov     esp, ebp
.text$mn:00003C05                 pop     ebp
.text$mn:00003C06                 retn
.text$mn:00003C06 ??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ endp
.text$mn:00003C06
.text$mn:00003C06 ; ---------------------------------------------------------------------------
.text$mn:00003C07                 align 4
.text$mn:00003C07 _text$mn        ends
.text$mn:00003C07
.text$x:00003C08 ; ===========================================================================
.text$x:00003C08
.text$x:00003C08 ; Segment type: Pure code
.text$x:00003C08 ; Segment permissions: Read/Execute
.text$x:00003C08 _text$x         segment para public 'CODE' use32
.text$x:00003C08                 assume cs:_text$x
.text$x:00003C08                 ;org 3C08h
.text$x:00003C08 ; COMDAT (pick associative to section at 3BBC)
.text$x:00003C08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003C08
.text$x:00003C08 ; =============== S U B R O U T I N E =======================================
.text$x:00003C08
.text$x:00003C08
.text$x:00003C08 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003C08                                         ; DATA XREF: .xdata$x:00007320o
.text$x:00003C08                 mov     ecx, [ebp-10h]  ; this
.text$x:00003C0B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00003C0B __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003C0B
.text$x:00003C10
.text$x:00003C10 ; =============== S U B R O U T I N E =======================================
.text$x:00003C10
.text$x:00003C10
.text$x:00003C10 __ehhandler$??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ proc near
.text$x:00003C10                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<TreeStateNode>>::~_Vector_val<std::_Simple_types<TreeStateNode>>(void)+5o
.text$x:00003C10
.text$x:00003C10 arg_4           = dword ptr  8
.text$x:00003C10
.text$x:00003C10                 mov     edx, [esp+arg_4]
.text$x:00003C14                 lea     eax, [edx+0Ch]
.text$x:00003C17                 mov     ecx, [edx-8]
.text$x:00003C1A                 xor     ecx, eax
.text$x:00003C1C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003C21                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ
.text$x:00003C26                 jmp     ___CxxFrameHandler3
.text$x:00003C26 __ehhandler$??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ endp
.text$x:00003C26
.text$x:00003C26 ; ---------------------------------------------------------------------------
.text$x:00003C2B                 align 4
.text$x:00003C2B _text$x         ends
.text$x:00003C2B
.text$mn:00003C2C ; ===========================================================================
.text$mn:00003C2C
.text$mn:00003C2C ; Segment type: Pure code
.text$mn:00003C2C ; Segment permissions: Read/Execute
.text$mn:00003C2C _text$mn        segment para public 'CODE' use32
.text$mn:00003C2C                 assume cs:_text$mn
.text$mn:00003C2C                 ;org 3C2Ch
.text$mn:00003C2C ; COMDAT (pick any)
.text$mn:00003C2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C2C
.text$mn:00003C2C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C2C
.text$mn:00003C2C ; Attributes: bp-based frame
.text$mn:00003C2C
.text$mn:00003C2C ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00003C2C                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00003C2C ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00003C2C                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00003C2C                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00003C2C
.text$mn:00003C2C var_10          = dword ptr -10h
.text$mn:00003C2C var_C           = dword ptr -0Ch
.text$mn:00003C2C var_4           = dword ptr -4
.text$mn:00003C2C
.text$mn:00003C2C                 push    ebp
.text$mn:00003C2D                 mov     ebp, esp
.text$mn:00003C2F                 push    0FFFFFFFFh
.text$mn:00003C31                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00003C36                 mov     eax, large fs:0
.text$mn:00003C3C                 push    eax
.text$mn:00003C3D                 push    ecx
.text$mn:00003C3E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003C43                 xor     eax, ebp
.text$mn:00003C45                 push    eax
.text$mn:00003C46                 lea     eax, [ebp+var_C]
.text$mn:00003C49                 mov     large fs:0, eax
.text$mn:00003C4F                 mov     [ebp+var_10], ecx
.text$mn:00003C52                 mov     [ebp+var_4], 0
.text$mn:00003C59                 push    0               ; Size
.text$mn:00003C5B                 push    1               ; char
.text$mn:00003C5D                 mov     ecx, [ebp+var_10]
.text$mn:00003C60                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003C65                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003C6C                 mov     ecx, [ebp+var_10]
.text$mn:00003C6F                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00003C74                 mov     ecx, [ebp+var_C]
.text$mn:00003C77                 mov     large fs:0, ecx
.text$mn:00003C7E                 pop     ecx
.text$mn:00003C7F                 mov     esp, ebp
.text$mn:00003C81                 pop     ebp
.text$mn:00003C82                 retn
.text$mn:00003C82 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00003C82
.text$mn:00003C82 ; ---------------------------------------------------------------------------
.text$mn:00003C83                 align 4
.text$mn:00003C83 _text$mn        ends
.text$mn:00003C83
.text$x:00003C84 ; ===========================================================================
.text$x:00003C84
.text$x:00003C84 ; Segment type: Pure code
.text$x:00003C84 ; Segment permissions: Read/Execute
.text$x:00003C84 _text$x         segment para public 'CODE' use32
.text$x:00003C84                 assume cs:_text$x
.text$x:00003C84                 ;org 3C84h
.text$x:00003C84 ; COMDAT (pick associative to section at 3C2C)
.text$x:00003C84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003C84
.text$x:00003C84 ; =============== S U B R O U T I N E =======================================
.text$x:00003C84
.text$x:00003C84
.text$x:00003C84 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00003C84                                         ; DATA XREF: .xdata$x:00006E98o
.text$x:00003C84                 mov     ecx, [ebp-10h]
.text$x:00003C87                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00003C87 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00003C87
.text$x:00003C8C
.text$x:00003C8C ; =============== S U B R O U T I N E =======================================
.text$x:00003C8C
.text$x:00003C8C
.text$x:00003C8C __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00003C8C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00003C8C
.text$x:00003C8C arg_4           = dword ptr  8
.text$x:00003C8C
.text$x:00003C8C                 mov     edx, [esp+arg_4]
.text$x:00003C90                 lea     eax, [edx+0Ch]
.text$x:00003C93                 mov     ecx, [edx-8]
.text$x:00003C96                 xor     ecx, eax
.text$x:00003C98                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003C9D                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00003CA2                 jmp     ___CxxFrameHandler3
.text$x:00003CA2 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00003CA2
.text$x:00003CA2 ; ---------------------------------------------------------------------------
.text$x:00003CA7                 align 4
.text$x:00003CA7 _text$x         ends
.text$x:00003CA7
.text$mn:00003CA8 ; ===========================================================================
.text$mn:00003CA8
.text$mn:00003CA8 ; Segment type: Pure code
.text$mn:00003CA8 ; Segment permissions: Read/Execute
.text$mn:00003CA8 _text$mn        segment para public 'CODE' use32
.text$mn:00003CA8                 assume cs:_text$mn
.text$mn:00003CA8                 ;org 3CA8h
.text$mn:00003CA8 ; COMDAT (pick any)
.text$mn:00003CA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CA8
.text$mn:00003CA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CA8
.text$mn:00003CA8 ; Attributes: bp-based frame
.text$mn:00003CA8
.text$mn:00003CA8 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00003CA8                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00003CA8 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00003CA8                                         ; CODE XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+210p
.text$mn:00003CA8                                         ; TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+222p ...
.text$mn:00003CA8
.text$mn:00003CA8 var_10          = dword ptr -10h
.text$mn:00003CA8 var_C           = dword ptr -0Ch
.text$mn:00003CA8 var_4           = dword ptr -4
.text$mn:00003CA8
.text$mn:00003CA8                 push    ebp
.text$mn:00003CA9                 mov     ebp, esp
.text$mn:00003CAB                 push    0FFFFFFFFh
.text$mn:00003CAD                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00003CB2                 mov     eax, large fs:0
.text$mn:00003CB8                 push    eax
.text$mn:00003CB9                 push    ecx
.text$mn:00003CBA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003CBF                 xor     eax, ebp
.text$mn:00003CC1                 push    eax
.text$mn:00003CC2                 lea     eax, [ebp+var_C]
.text$mn:00003CC5                 mov     large fs:0, eax
.text$mn:00003CCB                 mov     [ebp+var_10], ecx
.text$mn:00003CCE                 mov     [ebp+var_4], 0
.text$mn:00003CD5                 push    0
.text$mn:00003CD7                 push    1
.text$mn:00003CD9                 mov     ecx, [ebp+var_10]
.text$mn:00003CDC                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00003CE1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003CE8                 mov     ecx, [ebp+var_10]
.text$mn:00003CEB                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:00003CF0                 mov     ecx, [ebp+var_C]
.text$mn:00003CF3                 mov     large fs:0, ecx
.text$mn:00003CFA                 pop     ecx
.text$mn:00003CFB                 mov     esp, ebp
.text$mn:00003CFD                 pop     ebp
.text$mn:00003CFE                 retn
.text$mn:00003CFE ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:00003CFE
.text$mn:00003CFE ; ---------------------------------------------------------------------------
.text$mn:00003CFF                 align 10h
.text$mn:00003CFF _text$mn        ends
.text$mn:00003CFF
.text$x:00003D00 ; ===========================================================================
.text$x:00003D00
.text$x:00003D00 ; Segment type: Pure code
.text$x:00003D00 ; Segment permissions: Read/Execute
.text$x:00003D00 _text$x         segment para public 'CODE' use32
.text$x:00003D00                 assume cs:_text$x
.text$x:00003D00                 ;org 3D00h
.text$x:00003D00 ; COMDAT (pick associative to section at 3CA8)
.text$x:00003D00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003D00
.text$x:00003D00 ; =============== S U B R O U T I N E =======================================
.text$x:00003D00
.text$x:00003D00
.text$x:00003D00 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:00003D00                                         ; DATA XREF: .xdata$x:00007210o
.text$x:00003D00                 mov     ecx, [ebp-10h]
.text$x:00003D03                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00003D03 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:00003D03
.text$x:00003D08
.text$x:00003D08 ; =============== S U B R O U T I N E =======================================
.text$x:00003D08
.text$x:00003D08
.text$x:00003D08 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:00003D08                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:00003D08
.text$x:00003D08 arg_4           = dword ptr  8
.text$x:00003D08
.text$x:00003D08                 mov     edx, [esp+arg_4]
.text$x:00003D0C                 lea     eax, [edx+0Ch]
.text$x:00003D0F                 mov     ecx, [edx-8]
.text$x:00003D12                 xor     ecx, eax
.text$x:00003D14                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003D19                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:00003D1E                 jmp     ___CxxFrameHandler3
.text$x:00003D1E __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:00003D1E
.text$x:00003D1E ; ---------------------------------------------------------------------------
.text$x:00003D23                 align 4
.text$x:00003D23 _text$x         ends
.text$x:00003D23
.text$mn:00003D24 ; ===========================================================================
.text$mn:00003D24
.text$mn:00003D24 ; Segment type: Pure code
.text$mn:00003D24 ; Segment permissions: Read/Execute
.text$mn:00003D24 _text$mn        segment para public 'CODE' use32
.text$mn:00003D24                 assume cs:_text$mn
.text$mn:00003D24                 ;org 3D24h
.text$mn:00003D24 ; COMDAT (pick any)
.text$mn:00003D24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D24
.text$mn:00003D24 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D24
.text$mn:00003D24 ; Attributes: bp-based frame
.text$mn:00003D24
.text$mn:00003D24 ; public: __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::~vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>(void)
.text$mn:00003D24                 public ??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ
.text$mn:00003D24 ??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ proc near
.text$mn:00003D24                                         ; CODE XREF: __unwindfunclet$??0TreeStateNode@@QAE@ABU0@@Z$2+6j
.text$mn:00003D24                                         ; __unwindfunclet$??0TreeStateNode@@QAE@XZ$2+6j ...
.text$mn:00003D24
.text$mn:00003D24 var_10          = dword ptr -10h
.text$mn:00003D24 var_C           = dword ptr -0Ch
.text$mn:00003D24 var_4           = dword ptr -4
.text$mn:00003D24
.text$mn:00003D24                 push    ebp
.text$mn:00003D25                 mov     ebp, esp
.text$mn:00003D27                 push    0FFFFFFFFh
.text$mn:00003D29                 push    offset __ehhandler$??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ
.text$mn:00003D2E                 mov     eax, large fs:0
.text$mn:00003D34                 push    eax
.text$mn:00003D35                 push    ecx
.text$mn:00003D36                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003D3B                 xor     eax, ebp
.text$mn:00003D3D                 push    eax
.text$mn:00003D3E                 lea     eax, [ebp+var_C]
.text$mn:00003D41                 mov     large fs:0, eax
.text$mn:00003D47                 mov     [ebp+var_10], ecx
.text$mn:00003D4A                 mov     [ebp+var_4], 0
.text$mn:00003D51                 mov     ecx, [ebp+var_10]
.text$mn:00003D54                 call    ?_Tidy@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Tidy(void)
.text$mn:00003D59                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003D60                 mov     ecx, [ebp+var_10]
.text$mn:00003D63                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::~_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>(void)
.text$mn:00003D68                 mov     ecx, [ebp+var_C]
.text$mn:00003D6B                 mov     large fs:0, ecx
.text$mn:00003D72                 pop     ecx
.text$mn:00003D73                 mov     esp, ebp
.text$mn:00003D75                 pop     ebp
.text$mn:00003D76                 retn
.text$mn:00003D76 ??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ endp
.text$mn:00003D76
.text$mn:00003D76 ; ---------------------------------------------------------------------------
.text$mn:00003D77                 align 4
.text$mn:00003D77 _text$mn        ends
.text$mn:00003D77
.text$x:00003D78 ; ===========================================================================
.text$x:00003D78
.text$x:00003D78 ; Segment type: Pure code
.text$x:00003D78 ; Segment permissions: Read/Execute
.text$x:00003D78 _text$x         segment para public 'CODE' use32
.text$x:00003D78                 assume cs:_text$x
.text$x:00003D78                 ;org 3D78h
.text$x:00003D78 ; COMDAT (pick associative to section at 3D24)
.text$x:00003D78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003D78
.text$x:00003D78 ; =============== S U B R O U T I N E =======================================
.text$x:00003D78
.text$x:00003D78
.text$x:00003D78 __unwindfunclet$??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003D78                                         ; DATA XREF: .xdata$x:00007440o
.text$x:00003D78                 mov     ecx, [ebp-10h]
.text$x:00003D7B                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::~_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>(void)
.text$x:00003D7B __unwindfunclet$??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003D7B
.text$x:00003D80
.text$x:00003D80 ; =============== S U B R O U T I N E =======================================
.text$x:00003D80
.text$x:00003D80
.text$x:00003D80 __ehhandler$??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ proc near
.text$x:00003D80                                         ; DATA XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::~vector<TreeStateNode,std::allocator<TreeStateNode>>(void)+5o
.text$x:00003D80
.text$x:00003D80 arg_4           = dword ptr  8
.text$x:00003D80
.text$x:00003D80                 mov     edx, [esp+arg_4]
.text$x:00003D84                 lea     eax, [edx+0Ch]
.text$x:00003D87                 mov     ecx, [edx-8]
.text$x:00003D8A                 xor     ecx, eax
.text$x:00003D8C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003D91                 mov     eax, offset __ehfuncinfo$??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ
.text$x:00003D96                 jmp     ___CxxFrameHandler3
.text$x:00003D96 __ehhandler$??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ endp
.text$x:00003D96
.text$x:00003D96 ; ---------------------------------------------------------------------------
.text$x:00003D9B                 align 4
.text$x:00003D9B _text$x         ends
.text$x:00003D9B
.text$mn:00003D9C ; ===========================================================================
.text$mn:00003D9C
.text$mn:00003D9C ; Segment type: Pure code
.text$mn:00003D9C ; Segment permissions: Read/Execute
.text$mn:00003D9C _text$mn        segment para public 'CODE' use32
.text$mn:00003D9C                 assume cs:_text$mn
.text$mn:00003D9C                 ;org 3D9Ch
.text$mn:00003D9C ; COMDAT (pick any)
.text$mn:00003D9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D9C
.text$mn:00003D9C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D9C
.text$mn:00003D9C ; Attributes: bp-based frame
.text$mn:00003D9C
.text$mn:00003D9C ; _DWORD __thiscall TreeStateNode::~TreeStateNode(TreeStateNode *__hidden this)
.text$mn:00003D9C                 public ??1TreeStateNode@@QAE@XZ
.text$mn:00003D9C ??1TreeStateNode@@QAE@XZ proc near      ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+192p
.text$mn:00003D9C                                         ; __unwindfunclet$?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z$0+6j ...
.text$mn:00003D9C
.text$mn:00003D9C var_10          = dword ptr -10h
.text$mn:00003D9C var_C           = dword ptr -0Ch
.text$mn:00003D9C var_4           = dword ptr -4
.text$mn:00003D9C
.text$mn:00003D9C                 push    ebp
.text$mn:00003D9D                 mov     ebp, esp
.text$mn:00003D9F                 push    0FFFFFFFFh
.text$mn:00003DA1                 push    offset __ehhandler$??1TreeStateNode@@QAE@XZ
.text$mn:00003DA6                 mov     eax, large fs:0
.text$mn:00003DAC                 push    eax
.text$mn:00003DAD                 push    ecx
.text$mn:00003DAE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003DB3                 xor     eax, ebp
.text$mn:00003DB5                 push    eax
.text$mn:00003DB6                 lea     eax, [ebp+var_C]
.text$mn:00003DB9                 mov     large fs:0, eax
.text$mn:00003DBF                 mov     [ebp+var_10], ecx
.text$mn:00003DC2                 mov     [ebp+var_4], 2
.text$mn:00003DC9                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003DCD                 mov     ecx, [ebp+var_10]
.text$mn:00003DD0                 add     ecx, 3Ch ; '<'
.text$mn:00003DD3                 call    ??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::~vector<TreeStateNode,std::allocator<TreeStateNode>>(void)
.text$mn:00003DD8                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003DDC                 mov     ecx, [ebp+var_10]
.text$mn:00003DDF                 add     ecx, 1Ch
.text$mn:00003DE2                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00003DE7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003DEE                 mov     ecx, [ebp+var_10]
.text$mn:00003DF1                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00003DF6                 mov     ecx, [ebp+var_C]
.text$mn:00003DF9                 mov     large fs:0, ecx
.text$mn:00003E00                 pop     ecx
.text$mn:00003E01                 mov     esp, ebp
.text$mn:00003E03                 pop     ebp
.text$mn:00003E04                 retn
.text$mn:00003E04 ??1TreeStateNode@@QAE@XZ endp
.text$mn:00003E04
.text$mn:00003E04 ; ---------------------------------------------------------------------------
.text$mn:00003E05                 align 4
.text$mn:00003E05 _text$mn        ends
.text$mn:00003E05
.text$x:00003E08 ; ===========================================================================
.text$x:00003E08
.text$x:00003E08 ; Segment type: Pure code
.text$x:00003E08 ; Segment permissions: Read/Execute
.text$x:00003E08 _text$x         segment para public 'CODE' use32
.text$x:00003E08                 assume cs:_text$x
.text$x:00003E08                 ;org 3E08h
.text$x:00003E08 ; COMDAT (pick associative to section at 3D9C)
.text$x:00003E08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003E08
.text$x:00003E08 ; =============== S U B R O U T I N E =======================================
.text$x:00003E08
.text$x:00003E08
.text$x:00003E08 __unwindfunclet$??1TreeStateNode@@QAE@XZ$0 proc near
.text$x:00003E08                                         ; DATA XREF: .xdata$x:00007584o
.text$x:00003E08                 mov     ecx, [ebp-10h]
.text$x:00003E0B                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00003E0B __unwindfunclet$??1TreeStateNode@@QAE@XZ$0 endp
.text$x:00003E0B
.text$x:00003E10
.text$x:00003E10 ; =============== S U B R O U T I N E =======================================
.text$x:00003E10
.text$x:00003E10
.text$x:00003E10 __unwindfunclet$??1TreeStateNode@@QAE@XZ$1 proc near
.text$x:00003E10                                         ; DATA XREF: .xdata$x:0000758Co
.text$x:00003E10                 mov     ecx, [ebp-10h]
.text$x:00003E13                 add     ecx, 1Ch
.text$x:00003E16                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00003E16 __unwindfunclet$??1TreeStateNode@@QAE@XZ$1 endp
.text$x:00003E16
.text$x:00003E1B
.text$x:00003E1B ; =============== S U B R O U T I N E =======================================
.text$x:00003E1B
.text$x:00003E1B
.text$x:00003E1B __unwindfunclet$??1TreeStateNode@@QAE@XZ$2 proc near
.text$x:00003E1B                                         ; DATA XREF: .xdata$x:00007594o
.text$x:00003E1B                 mov     ecx, [ebp-10h]
.text$x:00003E1E                 add     ecx, 3Ch ; '<'
.text$x:00003E21                 jmp     ??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::~vector<TreeStateNode,std::allocator<TreeStateNode>>(void)
.text$x:00003E21 __unwindfunclet$??1TreeStateNode@@QAE@XZ$2 endp
.text$x:00003E21
.text$x:00003E26
.text$x:00003E26 ; =============== S U B R O U T I N E =======================================
.text$x:00003E26
.text$x:00003E26
.text$x:00003E26 __ehhandler$??1TreeStateNode@@QAE@XZ proc near
.text$x:00003E26                                         ; DATA XREF: TreeStateNode::~TreeStateNode(void)+5o
.text$x:00003E26
.text$x:00003E26 arg_4           = dword ptr  8
.text$x:00003E26
.text$x:00003E26                 mov     edx, [esp+arg_4]
.text$x:00003E2A                 lea     eax, [edx+0Ch]
.text$x:00003E2D                 mov     ecx, [edx-8]
.text$x:00003E30                 xor     ecx, eax
.text$x:00003E32                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003E37                 mov     eax, offset __ehfuncinfo$??1TreeStateNode@@QAE@XZ
.text$x:00003E3C                 jmp     ___CxxFrameHandler3
.text$x:00003E3C __ehhandler$??1TreeStateNode@@QAE@XZ endp
.text$x:00003E3C
.text$x:00003E3C ; ---------------------------------------------------------------------------
.text$x:00003E41                 align 4
.text$x:00003E41 _text$x         ends
.text$x:00003E41
.text$mn:00003E44 ; ===========================================================================
.text$mn:00003E44
.text$mn:00003E44 ; Segment type: Pure code
.text$mn:00003E44 ; Segment permissions: Read/Execute
.text$mn:00003E44 _text$mn        segment para public 'CODE' use32
.text$mn:00003E44                 assume cs:_text$mn
.text$mn:00003E44                 ;org 3E44h
.text$mn:00003E44 ; COMDAT (pick any)
.text$mn:00003E44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E44
.text$mn:00003E44 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E44
.text$mn:00003E44 ; Attributes: bp-based frame
.text$mn:00003E44
.text$mn:00003E44 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00003E44                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00003E44 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00003E44                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00003E44                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00003E44
.text$mn:00003E44 var_4           = dword ptr -4
.text$mn:00003E44
.text$mn:00003E44                 push    ebp
.text$mn:00003E45                 mov     ebp, esp
.text$mn:00003E47                 push    ecx
.text$mn:00003E48                 mov     [ebp+var_4], ecx
.text$mn:00003E4B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003E4E                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00003E53                 mov     esp, ebp
.text$mn:00003E55                 pop     ebp
.text$mn:00003E56                 retn
.text$mn:00003E56 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00003E56
.text$mn:00003E56 ; ---------------------------------------------------------------------------
.text$mn:00003E57                 align 4
.text$mn:00003E57 _text$mn        ends
.text$mn:00003E57
.text$mn:00003E58 ; ===========================================================================
.text$mn:00003E58
.text$mn:00003E58 ; Segment type: Pure code
.text$mn:00003E58 ; Segment permissions: Read/Execute
.text$mn:00003E58 _text$mn        segment para public 'CODE' use32
.text$mn:00003E58                 assume cs:_text$mn
.text$mn:00003E58                 ;org 3E58h
.text$mn:00003E58 ; COMDAT (pick any)
.text$mn:00003E58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E58
.text$mn:00003E58 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E58
.text$mn:00003E58 ; Attributes: bp-based frame
.text$mn:00003E58
.text$mn:00003E58 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00003E58                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00003E58 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00003E58                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00003E58                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00003E58
.text$mn:00003E58 var_10          = dword ptr -10h
.text$mn:00003E58 var_C           = dword ptr -0Ch
.text$mn:00003E58 var_4           = dword ptr -4
.text$mn:00003E58
.text$mn:00003E58                 push    ebp
.text$mn:00003E59                 mov     ebp, esp
.text$mn:00003E5B                 push    0FFFFFFFFh
.text$mn:00003E5D                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00003E62                 mov     eax, large fs:0
.text$mn:00003E68                 push    eax
.text$mn:00003E69                 push    ecx
.text$mn:00003E6A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003E6F                 xor     eax, ebp
.text$mn:00003E71                 push    eax
.text$mn:00003E72                 lea     eax, [ebp+var_C]
.text$mn:00003E75                 mov     large fs:0, eax
.text$mn:00003E7B                 mov     [ebp+var_10], ecx
.text$mn:00003E7E                 mov     [ebp+var_4], 0
.text$mn:00003E85                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003E8C                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003E8F                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00003E94                 mov     ecx, [ebp+var_C]
.text$mn:00003E97                 mov     large fs:0, ecx
.text$mn:00003E9E                 pop     ecx
.text$mn:00003E9F                 mov     esp, ebp
.text$mn:00003EA1                 pop     ebp
.text$mn:00003EA2                 retn
.text$mn:00003EA2 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00003EA2
.text$mn:00003EA2 ; ---------------------------------------------------------------------------
.text$mn:00003EA3                 align 4
.text$mn:00003EA3 _text$mn        ends
.text$mn:00003EA3
.text$x:00003EA4 ; ===========================================================================
.text$x:00003EA4
.text$x:00003EA4 ; Segment type: Pure code
.text$x:00003EA4 ; Segment permissions: Read/Execute
.text$x:00003EA4 _text$x         segment para public 'CODE' use32
.text$x:00003EA4                 assume cs:_text$x
.text$x:00003EA4                 ;org 3EA4h
.text$x:00003EA4 ; COMDAT (pick associative to section at 3E58)
.text$x:00003EA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003EA4
.text$x:00003EA4 ; =============== S U B R O U T I N E =======================================
.text$x:00003EA4
.text$x:00003EA4
.text$x:00003EA4 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00003EA4                                         ; DATA XREF: .xdata$x:00006FA8o
.text$x:00003EA4                 mov     ecx, [ebp-10h]  ; this
.text$x:00003EA7                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00003EA7 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00003EA7
.text$x:00003EAC
.text$x:00003EAC ; =============== S U B R O U T I N E =======================================
.text$x:00003EAC
.text$x:00003EAC
.text$x:00003EAC __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00003EAC                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00003EAC
.text$x:00003EAC arg_4           = dword ptr  8
.text$x:00003EAC
.text$x:00003EAC                 mov     edx, [esp+arg_4]
.text$x:00003EB0                 lea     eax, [edx+0Ch]
.text$x:00003EB3                 mov     ecx, [edx-8]
.text$x:00003EB6                 xor     ecx, eax
.text$x:00003EB8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003EBD                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00003EC2                 jmp     ___CxxFrameHandler3
.text$x:00003EC2 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00003EC2
.text$x:00003EC2 ; ---------------------------------------------------------------------------
.text$x:00003EC7                 align 4
.text$x:00003EC7 _text$x         ends
.text$x:00003EC7
.text$mn:00003EC8 ; ===========================================================================
.text$mn:00003EC8
.text$mn:00003EC8 ; Segment type: Pure code
.text$mn:00003EC8 ; Segment permissions: Read/Execute
.text$mn:00003EC8 _text$mn        segment para public 'CODE' use32
.text$mn:00003EC8                 assume cs:_text$mn
.text$mn:00003EC8                 ;org 3EC8h
.text$mn:00003EC8 ; COMDAT (pick any)
.text$mn:00003EC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003EC8
.text$mn:00003EC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003EC8
.text$mn:00003EC8 ; Attributes: bp-based frame
.text$mn:00003EC8
.text$mn:00003EC8 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00003EC8                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00003EC8 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00003EC8                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00003EC8                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00003EC8
.text$mn:00003EC8 var_10          = dword ptr -10h
.text$mn:00003EC8 var_C           = dword ptr -0Ch
.text$mn:00003EC8 var_4           = dword ptr -4
.text$mn:00003EC8
.text$mn:00003EC8                 push    ebp
.text$mn:00003EC9                 mov     ebp, esp
.text$mn:00003ECB                 push    0FFFFFFFFh
.text$mn:00003ECD                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00003ED2                 mov     eax, large fs:0
.text$mn:00003ED8                 push    eax
.text$mn:00003ED9                 push    ecx
.text$mn:00003EDA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003EDF                 xor     eax, ebp
.text$mn:00003EE1                 push    eax
.text$mn:00003EE2                 lea     eax, [ebp+var_C]
.text$mn:00003EE5                 mov     large fs:0, eax
.text$mn:00003EEB                 mov     [ebp+var_10], ecx
.text$mn:00003EEE                 mov     [ebp+var_4], 0
.text$mn:00003EF5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003EFC                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003EFF                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00003F04                 mov     ecx, [ebp+var_C]
.text$mn:00003F07                 mov     large fs:0, ecx
.text$mn:00003F0E                 pop     ecx
.text$mn:00003F0F                 mov     esp, ebp
.text$mn:00003F11                 pop     ebp
.text$mn:00003F12                 retn
.text$mn:00003F12 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00003F12
.text$mn:00003F12 ; ---------------------------------------------------------------------------
.text$mn:00003F13                 align 4
.text$mn:00003F13 _text$mn        ends
.text$mn:00003F13
.text$x:00003F14 ; ===========================================================================
.text$x:00003F14
.text$x:00003F14 ; Segment type: Pure code
.text$x:00003F14 ; Segment permissions: Read/Execute
.text$x:00003F14 _text$x         segment para public 'CODE' use32
.text$x:00003F14                 assume cs:_text$x
.text$x:00003F14                 ;org 3F14h
.text$x:00003F14 ; COMDAT (pick associative to section at 3EC8)
.text$x:00003F14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003F14
.text$x:00003F14 ; =============== S U B R O U T I N E =======================================
.text$x:00003F14
.text$x:00003F14
.text$x:00003F14 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00003F14                                         ; DATA XREF: .xdata$x:0000702Co
.text$x:00003F14                 mov     ecx, [ebp-10h]  ; this
.text$x:00003F17                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00003F17 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00003F17
.text$x:00003F1C
.text$x:00003F1C ; =============== S U B R O U T I N E =======================================
.text$x:00003F1C
.text$x:00003F1C
.text$x:00003F1C __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00003F1C                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00003F1C
.text$x:00003F1C arg_4           = dword ptr  8
.text$x:00003F1C
.text$x:00003F1C                 mov     edx, [esp+arg_4]
.text$x:00003F20                 lea     eax, [edx+0Ch]
.text$x:00003F23                 mov     ecx, [edx-8]
.text$x:00003F26                 xor     ecx, eax
.text$x:00003F28                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F2D                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00003F32                 jmp     ___CxxFrameHandler3
.text$x:00003F32 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00003F32
.text$x:00003F32 ; ---------------------------------------------------------------------------
.text$x:00003F37                 align 4
.text$x:00003F37 _text$x         ends
.text$x:00003F37
.text$mn:00003F38 ; ===========================================================================
.text$mn:00003F38
.text$mn:00003F38 ; Segment type: Pure code
.text$mn:00003F38 ; Segment permissions: Read/Execute
.text$mn:00003F38 _text$mn        segment para public 'CODE' use32
.text$mn:00003F38                 assume cs:_text$mn
.text$mn:00003F38                 ;org 3F38h
.text$mn:00003F38 ; COMDAT (pick any)
.text$mn:00003F38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F38
.text$mn:00003F38 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F38
.text$mn:00003F38 ; Attributes: bp-based frame
.text$mn:00003F38
.text$mn:00003F38 ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00003F38                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:00003F38 ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00003F38                                         ; CODE XREF: __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0+3j
.text$mn:00003F38                                         ; __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0+3j ...
.text$mn:00003F38
.text$mn:00003F38 var_14          = byte ptr -14h
.text$mn:00003F38 var_10          = dword ptr -10h
.text$mn:00003F38 var_C           = dword ptr -0Ch
.text$mn:00003F38 var_4           = dword ptr -4
.text$mn:00003F38
.text$mn:00003F38                 push    ebp
.text$mn:00003F39                 mov     ebp, esp
.text$mn:00003F3B                 push    0FFFFFFFFh
.text$mn:00003F3D                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:00003F42                 mov     eax, large fs:0
.text$mn:00003F48                 push    eax
.text$mn:00003F49                 sub     esp, 8
.text$mn:00003F4C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003F51                 xor     eax, ebp
.text$mn:00003F53                 push    eax
.text$mn:00003F54                 lea     eax, [ebp+var_C]
.text$mn:00003F57                 mov     large fs:0, eax
.text$mn:00003F5D                 mov     [ebp+var_10], ecx
.text$mn:00003F60                 push    3               ; int
.text$mn:00003F62                 lea     ecx, [ebp+var_14] ; this
.text$mn:00003F65                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00003F6A                 mov     [ebp+var_4], 0
.text$mn:00003F71                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003F74                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00003F79                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003F80                 lea     ecx, [ebp+var_14] ; this
.text$mn:00003F83                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00003F88                 mov     ecx, [ebp+var_C]
.text$mn:00003F8B                 mov     large fs:0, ecx
.text$mn:00003F92                 pop     ecx
.text$mn:00003F93                 mov     esp, ebp
.text$mn:00003F95                 pop     ebp
.text$mn:00003F96                 retn
.text$mn:00003F96 ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:00003F96
.text$mn:00003F96 ; ---------------------------------------------------------------------------
.text$mn:00003F97                 align 4
.text$mn:00003F97 _text$mn        ends
.text$mn:00003F97
.text$x:00003F98 ; ===========================================================================
.text$x:00003F98
.text$x:00003F98 ; Segment type: Pure code
.text$x:00003F98 ; Segment permissions: Read/Execute
.text$x:00003F98 _text$x         segment para public 'CODE' use32
.text$x:00003F98                 assume cs:_text$x
.text$x:00003F98                 ;org 3F98h
.text$x:00003F98 ; COMDAT (pick associative to section at 3F38)
.text$x:00003F98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003F98
.text$x:00003F98 ; =============== S U B R O U T I N E =======================================
.text$x:00003F98
.text$x:00003F98
.text$x:00003F98 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:00003F98                                         ; DATA XREF: .xdata$x:00006D5Co
.text$x:00003F98                 lea     ecx, [ebp-14h]  ; this
.text$x:00003F9B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00003F9B __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:00003F9B
.text$x:00003FA0
.text$x:00003FA0 ; =============== S U B R O U T I N E =======================================
.text$x:00003FA0
.text$x:00003FA0
.text$x:00003FA0 __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:00003FA0                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:00003FA0
.text$x:00003FA0 arg_4           = dword ptr  8
.text$x:00003FA0
.text$x:00003FA0                 mov     edx, [esp+arg_4]
.text$x:00003FA4                 lea     eax, [edx+0Ch]
.text$x:00003FA7                 mov     ecx, [edx-0Ch]
.text$x:00003FAA                 xor     ecx, eax
.text$x:00003FAC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003FB1                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:00003FB6                 jmp     ___CxxFrameHandler3
.text$x:00003FB6 __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:00003FB6
.text$x:00003FB6 ; ---------------------------------------------------------------------------
.text$x:00003FBB                 align 4
.text$x:00003FBB _text$x         ends
.text$x:00003FBB
.text$mn:00003FBC ; ===========================================================================
.text$mn:00003FBC
.text$mn:00003FBC ; Segment type: Pure code
.text$mn:00003FBC ; Segment permissions: Read/Execute
.text$mn:00003FBC _text$mn        segment para public 'CODE' use32
.text$mn:00003FBC                 assume cs:_text$mn
.text$mn:00003FBC                 ;org 3FBCh
.text$mn:00003FBC ; COMDAT (pick any)
.text$mn:00003FBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FBC
.text$mn:00003FBC ; =============== S U B R O U T I N E =======================================
.text$mn:00003FBC
.text$mn:00003FBC ; Attributes: bp-based frame
.text$mn:00003FBC
.text$mn:00003FBC ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00003FBC                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00003FBC ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00003FBC                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00003FBC                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00003FBC
.text$mn:00003FBC var_10          = dword ptr -10h
.text$mn:00003FBC var_C           = dword ptr -0Ch
.text$mn:00003FBC var_4           = dword ptr -4
.text$mn:00003FBC
.text$mn:00003FBC                 push    ebp
.text$mn:00003FBD                 mov     ebp, esp
.text$mn:00003FBF                 push    0FFFFFFFFh
.text$mn:00003FC1                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00003FC6                 mov     eax, large fs:0
.text$mn:00003FCC                 push    eax
.text$mn:00003FCD                 push    ecx
.text$mn:00003FCE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003FD3                 xor     eax, ebp
.text$mn:00003FD5                 push    eax
.text$mn:00003FD6                 lea     eax, [ebp+var_C]
.text$mn:00003FD9                 mov     large fs:0, eax
.text$mn:00003FDF                 mov     [ebp+var_10], ecx
.text$mn:00003FE2                 mov     [ebp+var_4], 0
.text$mn:00003FE9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003FF0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003FF3                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00003FF8                 mov     ecx, [ebp+var_C]
.text$mn:00003FFB                 mov     large fs:0, ecx
.text$mn:00004002                 pop     ecx
.text$mn:00004003                 mov     esp, ebp
.text$mn:00004005                 pop     ebp
.text$mn:00004006                 retn
.text$mn:00004006 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00004006
.text$mn:00004006 ; ---------------------------------------------------------------------------
.text$mn:00004007                 align 4
.text$mn:00004007 _text$mn        ends
.text$mn:00004007
.text$x:00004008 ; ===========================================================================
.text$x:00004008
.text$x:00004008 ; Segment type: Pure code
.text$x:00004008 ; Segment permissions: Read/Execute
.text$x:00004008 _text$x         segment para public 'CODE' use32
.text$x:00004008                 assume cs:_text$x
.text$x:00004008                 ;org 4008h
.text$x:00004008 ; COMDAT (pick associative to section at 3FBC)
.text$x:00004008                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004008
.text$x:00004008 ; =============== S U B R O U T I N E =======================================
.text$x:00004008
.text$x:00004008
.text$x:00004008 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00004008                                         ; DATA XREF: .xdata$x:000070B0o
.text$x:00004008                 mov     ecx, [ebp-10h]  ; this
.text$x:0000400B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000400B __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:0000400B
.text$x:00004010
.text$x:00004010 ; =============== S U B R O U T I N E =======================================
.text$x:00004010
.text$x:00004010
.text$x:00004010 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00004010                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00004010
.text$x:00004010 arg_4           = dword ptr  8
.text$x:00004010
.text$x:00004010                 mov     edx, [esp+arg_4]
.text$x:00004014                 lea     eax, [edx+0Ch]
.text$x:00004017                 mov     ecx, [edx-8]
.text$x:0000401A                 xor     ecx, eax
.text$x:0000401C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004021                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00004026                 jmp     ___CxxFrameHandler3
.text$x:00004026 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00004026
.text$x:00004026 ; ---------------------------------------------------------------------------
.text$x:0000402B                 align 4
.text$x:0000402B _text$x         ends
.text$x:0000402B
.text$mn:0000402C ; ===========================================================================
.text$mn:0000402C
.text$mn:0000402C ; Segment type: Pure code
.text$mn:0000402C ; Segment permissions: Read/Execute
.text$mn:0000402C _text$mn        segment para public 'CODE' use32
.text$mn:0000402C                 assume cs:_text$mn
.text$mn:0000402C                 ;org 402Ch
.text$mn:0000402C ; COMDAT (pick any)
.text$mn:0000402C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000402C
.text$mn:0000402C ; =============== S U B R O U T I N E =======================================
.text$mn:0000402C
.text$mn:0000402C ; Attributes: bp-based frame
.text$mn:0000402C
.text$mn:0000402C ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:0000402C                 public ??1error_category@std@@UAE@XZ
.text$mn:0000402C ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:0000402C                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:0000402C
.text$mn:0000402C var_4           = dword ptr -4
.text$mn:0000402C
.text$mn:0000402C                 push    ebp
.text$mn:0000402D                 mov     ebp, esp
.text$mn:0000402F                 push    ecx
.text$mn:00004030                 mov     [ebp+var_4], ecx
.text$mn:00004033                 mov     eax, [ebp+var_4]
.text$mn:00004036                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:0000403C                 mov     esp, ebp
.text$mn:0000403E                 pop     ebp
.text$mn:0000403F                 retn
.text$mn:0000403F ??1error_category@std@@UAE@XZ endp
.text$mn:0000403F
.text$mn:0000403F _text$mn        ends
.text$mn:0000403F
.text$mn:00004040 ; ===========================================================================
.text$mn:00004040
.text$mn:00004040 ; Segment type: Pure code
.text$mn:00004040 ; Segment permissions: Read/Execute
.text$mn:00004040 _text$mn        segment para public 'CODE' use32
.text$mn:00004040                 assume cs:_text$mn
.text$mn:00004040                 ;org 4040h
.text$mn:00004040 ; COMDAT (pick any)
.text$mn:00004040                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004040
.text$mn:00004040 ; =============== S U B R O U T I N E =======================================
.text$mn:00004040
.text$mn:00004040 ; Attributes: bp-based frame
.text$mn:00004040
.text$mn:00004040 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00004040                 public ??2@YAPAXIPAX@Z
.text$mn:00004040 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00004040                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+2Ep ...
.text$mn:00004040
.text$mn:00004040 arg_4           = dword ptr  0Ch
.text$mn:00004040
.text$mn:00004040                 push    ebp
.text$mn:00004041                 mov     ebp, esp
.text$mn:00004043                 mov     eax, [ebp+arg_4]
.text$mn:00004046                 pop     ebp
.text$mn:00004047                 retn
.text$mn:00004047 ??2@YAPAXIPAX@Z endp
.text$mn:00004047
.text$mn:00004047 _text$mn        ends
.text$mn:00004047
.text$mn:00004048 ; ===========================================================================
.text$mn:00004048
.text$mn:00004048 ; Segment type: Pure code
.text$mn:00004048 ; Segment permissions: Read/Execute
.text$mn:00004048 _text$mn        segment para public 'CODE' use32
.text$mn:00004048                 assume cs:_text$mn
.text$mn:00004048                 ;org 4048h
.text$mn:00004048 ; COMDAT (pick any)
.text$mn:00004048                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004048
.text$mn:00004048 ; =============== S U B R O U T I N E =======================================
.text$mn:00004048
.text$mn:00004048 ; Attributes: bp-based frame
.text$mn:00004048
.text$mn:00004048 ; void __cdecl operator delete(void *)
.text$mn:00004048                 public ??3@YAXPAX0@Z
.text$mn:00004048 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00004048                                         ; __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0+8p ...
.text$mn:00004048                 push    ebp
.text$mn:00004049                 mov     ebp, esp
.text$mn:0000404B                 pop     ebp
.text$mn:0000404C                 retn
.text$mn:0000404C ??3@YAXPAX0@Z   endp
.text$mn:0000404C
.text$mn:0000404C ; ---------------------------------------------------------------------------
.text$mn:0000404D                 align 10h
.text$mn:0000404D _text$mn        ends
.text$mn:0000404D
.text$mn:00004050 ; ===========================================================================
.text$mn:00004050
.text$mn:00004050 ; Segment type: Pure code
.text$mn:00004050 ; Segment permissions: Read/Execute
.text$mn:00004050 _text$mn        segment para public 'CODE' use32
.text$mn:00004050                 assume cs:_text$mn
.text$mn:00004050                 ;org 4050h
.text$mn:00004050 ; COMDAT (pick any)
.text$mn:00004050                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004050
.text$mn:00004050 ; =============== S U B R O U T I N E =======================================
.text$mn:00004050
.text$mn:00004050 ; Attributes: bp-based frame
.text$mn:00004050
.text$mn:00004050 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator=(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00004050                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
.text$mn:00004050 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:00004050                                         ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+104p
.text$mn:00004050
.text$mn:00004050 var_8           = dword ptr -8
.text$mn:00004050 var_3           = byte ptr -3
.text$mn:00004050 var_2           = byte ptr -2
.text$mn:00004050 var_1           = byte ptr -1
.text$mn:00004050 arg_0           = dword ptr  8
.text$mn:00004050
.text$mn:00004050                 push    ebp
.text$mn:00004051                 mov     ebp, esp
.text$mn:00004053                 sub     esp, 8
.text$mn:00004056                 mov     [ebp+var_8], ecx
.text$mn:00004059                 mov     eax, [ebp+var_8]
.text$mn:0000405C                 cmp     eax, [ebp+arg_0]
.text$mn:0000405F                 jz      short loc_40BB
.text$mn:00004061                 lea     ecx, [ebp+var_1]
.text$mn:00004064                 push    ecx
.text$mn:00004065                 mov     ecx, [ebp+arg_0]
.text$mn:00004068                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000406D                 push    eax
.text$mn:0000406E                 lea     edx, [ebp+var_2]
.text$mn:00004071                 push    edx
.text$mn:00004072                 mov     ecx, [ebp+var_8]
.text$mn:00004075                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000407A                 push    eax
.text$mn:0000407B                 call    ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00004080                 add     esp, 8
.text$mn:00004083                 movzx   eax, al
.text$mn:00004086                 test    eax, eax
.text$mn:00004088                 jz      short loc_40AF
.text$mn:0000408A                 xor     ecx, ecx
.text$mn:0000408C                 jz      short loc_40AF
.text$mn:0000408E                 push    0
.text$mn:00004090                 push    1
.text$mn:00004092                 mov     ecx, [ebp+var_8]
.text$mn:00004095                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000409A                 lea     edx, [ebp+var_3]
.text$mn:0000409D                 push    edx
.text$mn:0000409E                 mov     ecx, [ebp+arg_0]
.text$mn:000040A1                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000040A6                 push    eax
.text$mn:000040A7                 mov     ecx, [ebp+var_8]
.text$mn:000040AA                 call    ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Change_alloc(std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:000040AF
.text$mn:000040AF loc_40AF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+38j
.text$mn:000040AF                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Cj
.text$mn:000040AF                 mov     eax, [ebp+arg_0]
.text$mn:000040B2                 push    eax
.text$mn:000040B3                 mov     ecx, [ebp+var_8]
.text$mn:000040B6                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000040BB
.text$mn:000040BB loc_40BB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+Fj
.text$mn:000040BB                 mov     eax, [ebp+var_8]
.text$mn:000040BE                 mov     esp, ebp
.text$mn:000040C0                 pop     ebp
.text$mn:000040C1                 retn    4
.text$mn:000040C1 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:000040C1
.text$mn:000040C1 _text$mn        ends
.text$mn:000040C1
.text$mn:000040C4 ; ===========================================================================
.text$mn:000040C4
.text$mn:000040C4 ; Segment type: Pure code
.text$mn:000040C4 ; Segment permissions: Read/Execute
.text$mn:000040C4 _text$mn        segment para public 'CODE' use32
.text$mn:000040C4                 assume cs:_text$mn
.text$mn:000040C4                 ;org 40C4h
.text$mn:000040C4 ; COMDAT (pick any)
.text$mn:000040C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040C4
.text$mn:000040C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000040C4
.text$mn:000040C4 ; Attributes: bp-based frame
.text$mn:000040C4
.text$mn:000040C4 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t *Str)
.text$mn:000040C4                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:000040C4 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:000040C4                                         ; CODE XREF: TreeView::setItemParam(_TREEITEM *,wchar_t const *)+AEp
.text$mn:000040C4                                         ; TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+8Fp
.text$mn:000040C4
.text$mn:000040C4 var_4           = dword ptr -4
.text$mn:000040C4 Str             = dword ptr  8
.text$mn:000040C4
.text$mn:000040C4                 push    ebp
.text$mn:000040C5                 mov     ebp, esp
.text$mn:000040C7                 push    ecx
.text$mn:000040C8                 mov     [ebp+var_4], ecx
.text$mn:000040CB                 mov     eax, [ebp+Str]
.text$mn:000040CE                 push    eax             ; Str
.text$mn:000040CF                 mov     ecx, [ebp+var_4]
.text$mn:000040D2                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:000040D7                 mov     esp, ebp
.text$mn:000040D9                 pop     ebp
.text$mn:000040DA                 retn    4
.text$mn:000040DA ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:000040DA
.text$mn:000040DA ; ---------------------------------------------------------------------------
.text$mn:000040DD                 align 10h
.text$mn:000040DD _text$mn        ends
.text$mn:000040DD
.text$mn:000040E0 ; ===========================================================================
.text$mn:000040E0
.text$mn:000040E0 ; Segment type: Pure code
.text$mn:000040E0 ; Segment permissions: Read/Execute
.text$mn:000040E0 _text$mn        segment para public 'CODE' use32
.text$mn:000040E0                 assume cs:_text$mn
.text$mn:000040E0                 ;org 40E0h
.text$mn:000040E0 ; COMDAT (pick any)
.text$mn:000040E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040E0
.text$mn:000040E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000040E0
.text$mn:000040E0 ; Attributes: bp-based frame
.text$mn:000040E0
.text$mn:000040E0 ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:000040E0                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:000040E0 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:000040E0                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:000040E0
.text$mn:000040E0 var_14          = byte ptr -14h
.text$mn:000040E0 var_10          = dword ptr -10h
.text$mn:000040E0 var_C           = dword ptr -0Ch
.text$mn:000040E0 var_4           = dword ptr -4
.text$mn:000040E0 arg_0           = dword ptr  8
.text$mn:000040E0
.text$mn:000040E0                 push    ebp
.text$mn:000040E1                 mov     ebp, esp
.text$mn:000040E3                 push    0FFFFFFFFh
.text$mn:000040E5                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:000040EA                 mov     eax, large fs:0
.text$mn:000040F0                 push    eax
.text$mn:000040F1                 sub     esp, 8
.text$mn:000040F4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000040F9                 xor     eax, ebp
.text$mn:000040FB                 push    eax
.text$mn:000040FC                 lea     eax, [ebp+var_C]
.text$mn:000040FF                 mov     large fs:0, eax
.text$mn:00004105                 mov     [ebp+var_10], ecx
.text$mn:00004108                 mov     eax, [ebp+var_10]
.text$mn:0000410B                 mov     ecx, [ebp+arg_0]
.text$mn:0000410E                 mov     edx, [eax]
.text$mn:00004110                 cmp     edx, [ecx]
.text$mn:00004112                 jnz     short loc_4116
.text$mn:00004114                 jmp     short loc_4158
.text$mn:00004116 ; ---------------------------------------------------------------------------
.text$mn:00004116
.text$mn:00004116 loc_4116:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:00004116                 mov     eax, [ebp+arg_0]
.text$mn:00004119                 cmp     dword ptr [eax], 0
.text$mn:0000411C                 jz      short loc_4130
.text$mn:0000411E                 mov     ecx, [ebp+arg_0]
.text$mn:00004121                 mov     edx, [ecx]
.text$mn:00004123                 mov     eax, [edx]
.text$mn:00004125                 push    eax             ; struct std::_Container_base12 *
.text$mn:00004126                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004129                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:0000412E                 jmp     short loc_4158
.text$mn:00004130 ; ---------------------------------------------------------------------------
.text$mn:00004130
.text$mn:00004130 loc_4130:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:00004130                 push    3               ; int
.text$mn:00004132                 lea     ecx, [ebp+var_14] ; this
.text$mn:00004135                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000413A                 mov     [ebp+var_4], 0
.text$mn:00004141                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004144                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00004149                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004150                 lea     ecx, [ebp+var_14] ; this
.text$mn:00004153                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00004158
.text$mn:00004158 loc_4158:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:00004158                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:00004158                 mov     eax, [ebp+var_10]
.text$mn:0000415B                 mov     ecx, [ebp+var_C]
.text$mn:0000415E                 mov     large fs:0, ecx
.text$mn:00004165                 pop     ecx
.text$mn:00004166                 mov     esp, ebp
.text$mn:00004168                 pop     ebp
.text$mn:00004169                 retn    4
.text$mn:00004169 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:00004169
.text$mn:00004169 _text$mn        ends
.text$mn:00004169
.text$x:0000416C ; ===========================================================================
.text$x:0000416C
.text$x:0000416C ; Segment type: Pure code
.text$x:0000416C ; Segment permissions: Read/Execute
.text$x:0000416C _text$x         segment para public 'CODE' use32
.text$x:0000416C                 assume cs:_text$x
.text$x:0000416C                 ;org 416Ch
.text$x:0000416C ; COMDAT (pick associative to section at 40E0)
.text$x:0000416C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000416C
.text$x:0000416C ; =============== S U B R O U T I N E =======================================
.text$x:0000416C
.text$x:0000416C
.text$x:0000416C __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:0000416C                                         ; DATA XREF: .xdata$x:00006D30o
.text$x:0000416C                 lea     ecx, [ebp-14h]  ; this
.text$x:0000416F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000416F __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:0000416F
.text$x:00004174
.text$x:00004174 ; =============== S U B R O U T I N E =======================================
.text$x:00004174
.text$x:00004174
.text$x:00004174 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:00004174                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:00004174
.text$x:00004174 arg_4           = dword ptr  8
.text$x:00004174
.text$x:00004174                 mov     edx, [esp+arg_4]
.text$x:00004178                 lea     eax, [edx+0Ch]
.text$x:0000417B                 mov     ecx, [edx-0Ch]
.text$x:0000417E                 xor     ecx, eax
.text$x:00004180                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004185                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:0000418A                 jmp     ___CxxFrameHandler3
.text$x:0000418A __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:0000418A
.text$x:0000418A ; ---------------------------------------------------------------------------
.text$x:0000418F                 align 10h
.text$x:0000418F _text$x         ends
.text$x:0000418F
.text$mn:00004190 ; ===========================================================================
.text$mn:00004190
.text$mn:00004190 ; Segment type: Pure code
.text$mn:00004190 ; Segment permissions: Read/Execute
.text$mn:00004190 _text$mn        segment para public 'CODE' use32
.text$mn:00004190                 assume cs:_text$mn
.text$mn:00004190                 ;org 4190h
.text$mn:00004190 ; COMDAT (pick any)
.text$mn:00004190                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004190
.text$mn:00004190 ; =============== S U B R O U T I N E =======================================
.text$mn:00004190
.text$mn:00004190 ; Attributes: bp-based frame
.text$mn:00004190
.text$mn:00004190 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00004190                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00004190 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00004190                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00004190                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00004190
.text$mn:00004190 var_8           = dword ptr -8
.text$mn:00004190 var_4           = dword ptr -4
.text$mn:00004190 arg_0           = dword ptr  8
.text$mn:00004190
.text$mn:00004190                 push    ebp
.text$mn:00004191                 mov     ebp, esp
.text$mn:00004193                 sub     esp, 8
.text$mn:00004196                 mov     [ebp+var_8], ecx
.text$mn:00004199                 mov     eax, [ebp+var_8]
.text$mn:0000419C                 cmp     eax, [ebp+arg_0]
.text$mn:0000419F                 jnz     short loc_41AA
.text$mn:000041A1                 mov     [ebp+var_4], 1
.text$mn:000041A8                 jmp     short loc_41B1
.text$mn:000041AA ; ---------------------------------------------------------------------------
.text$mn:000041AA
.text$mn:000041AA loc_41AA:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:000041AA                 mov     [ebp+var_4], 0
.text$mn:000041B1
.text$mn:000041B1 loc_41B1:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:000041B1                 mov     al, byte ptr [ebp+var_4]
.text$mn:000041B4                 mov     esp, ebp
.text$mn:000041B6                 pop     ebp
.text$mn:000041B7                 retn    4
.text$mn:000041B7 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:000041B7
.text$mn:000041B7 ; ---------------------------------------------------------------------------
.text$mn:000041BA                 align 4
.text$mn:000041BA _text$mn        ends
.text$mn:000041BA
.text$mn:000041BC ; ===========================================================================
.text$mn:000041BC
.text$mn:000041BC ; Segment type: Pure code
.text$mn:000041BC ; Segment permissions: Read/Execute
.text$mn:000041BC _text$mn        segment para public 'CODE' use32
.text$mn:000041BC                 assume cs:_text$mn
.text$mn:000041BC                 ;org 41BCh
.text$mn:000041BC ; COMDAT (pick any)
.text$mn:000041BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000041BC
.text$mn:000041BC ; =============== S U B R O U T I N E =======================================
.text$mn:000041BC
.text$mn:000041BC ; Attributes: bp-based frame
.text$mn:000041BC
.text$mn:000041BC ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:000041BC                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:000041BC ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:000041BC                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:000041BC
.text$mn:000041BC var_8           = dword ptr -8
.text$mn:000041BC var_4           = dword ptr -4
.text$mn:000041BC arg_0           = dword ptr  8
.text$mn:000041BC
.text$mn:000041BC                 push    ebp
.text$mn:000041BD                 mov     ebp, esp
.text$mn:000041BF                 sub     esp, 8
.text$mn:000041C2                 push    esi
.text$mn:000041C3                 mov     [ebp+var_4], ecx
.text$mn:000041C6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000041C9                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000041CE                 push    eax
.text$mn:000041CF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000041D2                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000041D7                 mov     ecx, eax
.text$mn:000041D9                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000041DE                 movzx   eax, al
.text$mn:000041E1                 test    eax, eax
.text$mn:000041E3                 jz      short loc_4204
.text$mn:000041E5                 mov     ecx, [ebp+var_4] ; this
.text$mn:000041E8                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000041ED                 mov     esi, eax
.text$mn:000041EF                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000041F2                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000041F7                 cmp     esi, eax
.text$mn:000041F9                 jnz     short loc_4204
.text$mn:000041FB                 mov     [ebp+var_8], 1
.text$mn:00004202                 jmp     short loc_420B
.text$mn:00004204 ; ---------------------------------------------------------------------------
.text$mn:00004204
.text$mn:00004204 loc_4204:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00004204                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00004204                 mov     [ebp+var_8], 0
.text$mn:0000420B
.text$mn:0000420B loc_420B:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:0000420B                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000420E                 pop     esi
.text$mn:0000420F                 mov     esp, ebp
.text$mn:00004211                 pop     ebp
.text$mn:00004212                 retn    4
.text$mn:00004212 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00004212
.text$mn:00004212 ; ---------------------------------------------------------------------------
.text$mn:00004215                 align 4
.text$mn:00004215 _text$mn        ends
.text$mn:00004215
.text$mn:00004218 ; ===========================================================================
.text$mn:00004218
.text$mn:00004218 ; Segment type: Pure code
.text$mn:00004218 ; Segment permissions: Read/Execute
.text$mn:00004218 _text$mn        segment para public 'CODE' use32
.text$mn:00004218                 assume cs:_text$mn
.text$mn:00004218                 ;org 4218h
.text$mn:00004218 ; COMDAT (pick any)
.text$mn:00004218                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004218
.text$mn:00004218 ; =============== S U B R O U T I N E =======================================
.text$mn:00004218
.text$mn:00004218 ; Attributes: bp-based frame
.text$mn:00004218
.text$mn:00004218 ; public: int & __thiscall std::vector<int, class std::allocator<int>>::operator[](unsigned int)
.text$mn:00004218                 public ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
.text$mn:00004218 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z proc near
.text$mn:00004218                                         ; CODE XREF: TreeView::canDragOut(_TREEITEM *)+60p
.text$mn:00004218                                         ; TreeView::canDropIn(_TREEITEM *)+60p
.text$mn:00004218
.text$mn:00004218 var_4           = dword ptr -4
.text$mn:00004218 arg_0           = dword ptr  8
.text$mn:00004218
.text$mn:00004218                 push    ebp
.text$mn:00004219                 mov     ebp, esp
.text$mn:0000421B                 push    ecx
.text$mn:0000421C                 mov     [ebp+var_4], ecx
.text$mn:0000421F                 mov     ecx, [ebp+var_4]
.text$mn:00004222                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00004227                 cmp     eax, [ebp+arg_0]
.text$mn:0000422A                 ja      short loc_4294
.text$mn:0000422C                 push    4B1h            ; unsigned int
.text$mn:00004231                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004236                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:0000423B                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00004240                 add     esp, 0Ch
.text$mn:00004243                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00004248                 test    eax, eax
.text$mn:0000424A                 jz      short loc_4250
.text$mn:0000424C                 xor     ecx, ecx
.text$mn:0000424E                 jnz     short loc_4276
.text$mn:00004250
.text$mn:00004250 loc_4250:                               ; CODE XREF: std::vector<int,std::allocator<int>>::operator[](uint)+32j
.text$mn:00004250                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00004255                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000425A                 push    0
.text$mn:0000425C                 push    4B2h
.text$mn:00004261                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004266                 push    2
.text$mn:00004268                 call    __CrtDbgReportW
.text$mn:0000426D                 add     esp, 18h
.text$mn:00004270                 cmp     eax, 1
.text$mn:00004273                 jnz     short loc_4276
.text$mn:00004275                 int     3               ; Trap to Debugger
.text$mn:00004276
.text$mn:00004276 loc_4276:                               ; CODE XREF: std::vector<int,std::allocator<int>>::operator[](uint)+36j
.text$mn:00004276                                         ; std::vector<int,std::allocator<int>>::operator[](uint)+5Bj
.text$mn:00004276                 push    0
.text$mn:00004278                 push    4B2h
.text$mn:0000427D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004282                 push    offset ??_C@_1HC@HBCEAHKD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAi?$AAn?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAa?$AAl?$AAl?$AAo?$AAc@ ; "std::vector<int,class std::allocator<in"...
.text$mn:00004287                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000428C                 call    __invalid_parameter
.text$mn:00004291                 add     esp, 14h
.text$mn:00004294
.text$mn:00004294 loc_4294:                               ; CODE XREF: std::vector<int,std::allocator<int>>::operator[](uint)+12j
.text$mn:00004294                 mov     eax, [ebp+var_4]
.text$mn:00004297                 mov     ecx, [eax+4]
.text$mn:0000429A                 mov     edx, [ebp+arg_0]
.text$mn:0000429D                 lea     eax, [ecx+edx*4]
.text$mn:000042A0                 mov     esp, ebp
.text$mn:000042A2                 pop     ebp
.text$mn:000042A3                 retn    4
.text$mn:000042A3 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z endp
.text$mn:000042A3
.text$mn:000042A3 ; ---------------------------------------------------------------------------
.text$mn:000042A6                 align 4
.text$mn:000042A6 _text$mn        ends
.text$mn:000042A6
.text$mn:000042A8 ; ===========================================================================
.text$mn:000042A8
.text$mn:000042A8 ; Segment type: Pure code
.text$mn:000042A8 ; Segment permissions: Read/Execute
.text$mn:000042A8 _text$mn        segment para public 'CODE' use32
.text$mn:000042A8                 assume cs:_text$mn
.text$mn:000042A8                 ;org 42A8h
.text$mn:000042A8 ; COMDAT (pick any)
.text$mn:000042A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000042A8
.text$mn:000042A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000042A8
.text$mn:000042A8 ; Attributes: bp-based frame
.text$mn:000042A8
.text$mn:000042A8 ; public: void * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::`scalar deleting destructor'(unsigned int)
.text$mn:000042A8                 public ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z
.text$mn:000042A8 ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z proc near
.text$mn:000042A8                                         ; CODE XREF: TreeView::removeItem(_TREEITEM *)+57p
.text$mn:000042A8                                         ; TreeView::cleanSubEntries(_TREEITEM *)+71p
.text$mn:000042A8
.text$mn:000042A8 var_4           = dword ptr -4
.text$mn:000042A8 arg_0           = dword ptr  8
.text$mn:000042A8
.text$mn:000042A8                 push    ebp
.text$mn:000042A9                 mov     ebp, esp
.text$mn:000042AB                 push    ecx
.text$mn:000042AC                 mov     [ebp+var_4], ecx
.text$mn:000042AF                 mov     ecx, [ebp+var_4]
.text$mn:000042B2                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000042B7                 mov     eax, [ebp+arg_0]
.text$mn:000042BA                 and     eax, 1
.text$mn:000042BD                 jz      short loc_42CB
.text$mn:000042BF                 mov     ecx, [ebp+var_4]
.text$mn:000042C2                 push    ecx             ; void *
.text$mn:000042C3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000042C8                 add     esp, 4
.text$mn:000042CB
.text$mn:000042CB loc_42CB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`scalar deleting destructor'(uint)+15j
.text$mn:000042CB                 mov     eax, [ebp+var_4]
.text$mn:000042CE                 mov     esp, ebp
.text$mn:000042D0                 pop     ebp
.text$mn:000042D1                 retn    4
.text$mn:000042D1 ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z endp
.text$mn:000042D1
.text$mn:000042D1 _text$mn        ends
.text$mn:000042D1
.text$mn:000042D4 ; ===========================================================================
.text$mn:000042D4
.text$mn:000042D4 ; Segment type: Pure code
.text$mn:000042D4 ; Segment permissions: Read/Execute
.text$mn:000042D4 _text$mn        segment para public 'CODE' use32
.text$mn:000042D4                 assume cs:_text$mn
.text$mn:000042D4                 ;org 42D4h
.text$mn:000042D4 ; COMDAT (pick any)
.text$mn:000042D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000042D4
.text$mn:000042D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000042D4
.text$mn:000042D4 ; Attributes: bp-based frame
.text$mn:000042D4
.text$mn:000042D4 ; public: void * __thiscall TreeStateNode::`scalar deleting destructor'(unsigned int)
.text$mn:000042D4                 public ??_GTreeStateNode@@QAEPAXI@Z
.text$mn:000042D4 ??_GTreeStateNode@@QAEPAXI@Z proc near  ; CODE XREF: std::allocator<TreeStateNode>::destroy<TreeStateNode>(TreeStateNode *)+Cp
.text$mn:000042D4
.text$mn:000042D4 var_4           = dword ptr -4
.text$mn:000042D4 arg_0           = dword ptr  8
.text$mn:000042D4
.text$mn:000042D4                 push    ebp
.text$mn:000042D5                 mov     ebp, esp
.text$mn:000042D7                 push    ecx
.text$mn:000042D8                 mov     [ebp+var_4], ecx
.text$mn:000042DB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000042DE                 call    ??1TreeStateNode@@QAE@XZ ; TreeStateNode::~TreeStateNode(void)
.text$mn:000042E3                 mov     eax, [ebp+arg_0]
.text$mn:000042E6                 and     eax, 1
.text$mn:000042E9                 jz      short loc_42F7
.text$mn:000042EB                 mov     ecx, [ebp+var_4]
.text$mn:000042EE                 push    ecx             ; void *
.text$mn:000042EF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000042F4                 add     esp, 4
.text$mn:000042F7
.text$mn:000042F7 loc_42F7:                               ; CODE XREF: TreeStateNode::`scalar deleting destructor'(uint)+15j
.text$mn:000042F7                 mov     eax, [ebp+var_4]
.text$mn:000042FA                 mov     esp, ebp
.text$mn:000042FC                 pop     ebp
.text$mn:000042FD                 retn    4
.text$mn:000042FD ??_GTreeStateNode@@QAEPAXI@Z endp
.text$mn:000042FD
.text$mn:000042FD _text$mn        ends
.text$mn:000042FD
.text$mn:00004300 ; ===========================================================================
.text$mn:00004300
.text$mn:00004300 ; Segment type: Pure code
.text$mn:00004300 ; Segment permissions: Read/Execute
.text$mn:00004300 _text$mn        segment para public 'CODE' use32
.text$mn:00004300                 assume cs:_text$mn
.text$mn:00004300                 ;org 4300h
.text$mn:00004300 ; COMDAT (pick any)
.text$mn:00004300                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004300
.text$mn:00004300 ; =============== S U B R O U T I N E =======================================
.text$mn:00004300
.text$mn:00004300 ; Attributes: bp-based frame
.text$mn:00004300
.text$mn:00004300 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00004300                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00004300 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00004300
.text$mn:00004300 var_4           = dword ptr -4
.text$mn:00004300 arg_0           = dword ptr  8
.text$mn:00004300
.text$mn:00004300                 push    ebp
.text$mn:00004301                 mov     ebp, esp
.text$mn:00004303                 push    ecx
.text$mn:00004304                 mov     [ebp+var_4], ecx
.text$mn:00004307                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000430A                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000430F                 mov     eax, [ebp+arg_0]
.text$mn:00004312                 and     eax, 1
.text$mn:00004315                 jz      short loc_4323
.text$mn:00004317                 mov     ecx, [ebp+var_4]
.text$mn:0000431A                 push    ecx             ; void *
.text$mn:0000431B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004320                 add     esp, 4
.text$mn:00004323
.text$mn:00004323 loc_4323:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00004323                 mov     eax, [ebp+var_4]
.text$mn:00004326                 mov     esp, ebp
.text$mn:00004328                 pop     ebp
.text$mn:00004329                 retn    4
.text$mn:00004329 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00004329
.text$mn:00004329 _text$mn        ends
.text$mn:00004329
.text$mn:0000432C ; ===========================================================================
.text$mn:0000432C
.text$mn:0000432C ; Segment type: Pure code
.text$mn:0000432C ; Segment permissions: Read/Execute
.text$mn:0000432C _text$mn        segment para public 'CODE' use32
.text$mn:0000432C                 assume cs:_text$mn
.text$mn:0000432C                 ;org 432Ch
.text$mn:0000432C ; COMDAT (pick any)
.text$mn:0000432C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000432C
.text$mn:0000432C ; =============== S U B R O U T I N E =======================================
.text$mn:0000432C
.text$mn:0000432C ; Attributes: bp-based frame
.text$mn:0000432C
.text$mn:0000432C ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000432C                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:0000432C ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000432C
.text$mn:0000432C var_4           = dword ptr -4
.text$mn:0000432C arg_0           = dword ptr  8
.text$mn:0000432C
.text$mn:0000432C                 push    ebp
.text$mn:0000432D                 mov     ebp, esp
.text$mn:0000432F                 push    ecx
.text$mn:00004330                 mov     [ebp+var_4], ecx
.text$mn:00004333                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004336                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:0000433B                 mov     eax, [ebp+arg_0]
.text$mn:0000433E                 and     eax, 1
.text$mn:00004341                 jz      short loc_434F
.text$mn:00004343                 mov     ecx, [ebp+var_4]
.text$mn:00004346                 push    ecx             ; void *
.text$mn:00004347                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000434C                 add     esp, 4
.text$mn:0000434F
.text$mn:0000434F loc_434F:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000434F                 mov     eax, [ebp+var_4]
.text$mn:00004352                 mov     esp, ebp
.text$mn:00004354                 pop     ebp
.text$mn:00004355                 retn    4
.text$mn:00004355 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00004355
.text$mn:00004355 _text$mn        ends
.text$mn:00004355
.text$mn:00004358 ; ===========================================================================
.text$mn:00004358
.text$mn:00004358 ; Segment type: Pure code
.text$mn:00004358 ; Segment permissions: Read/Execute
.text$mn:00004358 _text$mn        segment para public 'CODE' use32
.text$mn:00004358                 assume cs:_text$mn
.text$mn:00004358                 ;org 4358h
.text$mn:00004358 ; COMDAT (pick any)
.text$mn:00004358                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004358
.text$mn:00004358 ; =============== S U B R O U T I N E =======================================
.text$mn:00004358
.text$mn:00004358 ; Attributes: bp-based frame
.text$mn:00004358
.text$mn:00004358 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00004358                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00004358 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00004358
.text$mn:00004358 var_4           = dword ptr -4
.text$mn:00004358 arg_0           = dword ptr  8
.text$mn:00004358
.text$mn:00004358                 push    ebp
.text$mn:00004359                 mov     ebp, esp
.text$mn:0000435B                 push    ecx
.text$mn:0000435C                 mov     [ebp+var_4], ecx
.text$mn:0000435F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004362                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00004367                 mov     eax, [ebp+arg_0]
.text$mn:0000436A                 and     eax, 1
.text$mn:0000436D                 jz      short loc_437B
.text$mn:0000436F                 mov     ecx, [ebp+var_4]
.text$mn:00004372                 push    ecx             ; void *
.text$mn:00004373                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004378                 add     esp, 4
.text$mn:0000437B
.text$mn:0000437B loc_437B:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000437B                 mov     eax, [ebp+var_4]
.text$mn:0000437E                 mov     esp, ebp
.text$mn:00004380                 pop     ebp
.text$mn:00004381                 retn    4
.text$mn:00004381 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00004381
.text$mn:00004381 _text$mn        ends
.text$mn:00004381
.text$mn:00004384 ; ===========================================================================
.text$mn:00004384
.text$mn:00004384 ; Segment type: Pure code
.text$mn:00004384 ; Segment permissions: Read/Execute
.text$mn:00004384 _text$mn        segment para public 'CODE' use32
.text$mn:00004384                 assume cs:_text$mn
.text$mn:00004384                 ;org 4384h
.text$mn:00004384 ; COMDAT (pick any)
.text$mn:00004384                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004384
.text$mn:00004384 ; =============== S U B R O U T I N E =======================================
.text$mn:00004384
.text$mn:00004384 ; Attributes: bp-based frame
.text$mn:00004384
.text$mn:00004384 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00004384                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00004384 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00004384
.text$mn:00004384 var_4           = dword ptr -4
.text$mn:00004384 arg_0           = dword ptr  8
.text$mn:00004384
.text$mn:00004384                 push    ebp
.text$mn:00004385                 mov     ebp, esp
.text$mn:00004387                 push    ecx
.text$mn:00004388                 mov     [ebp+var_4], ecx
.text$mn:0000438B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000438E                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00004393                 mov     eax, [ebp+arg_0]
.text$mn:00004396                 and     eax, 1
.text$mn:00004399                 jz      short loc_43A7
.text$mn:0000439B                 mov     ecx, [ebp+var_4]
.text$mn:0000439E                 push    ecx             ; void *
.text$mn:0000439F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000043A4                 add     esp, 4
.text$mn:000043A7
.text$mn:000043A7 loc_43A7:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000043A7                 mov     eax, [ebp+var_4]
.text$mn:000043AA                 mov     esp, ebp
.text$mn:000043AC                 pop     ebp
.text$mn:000043AD                 retn    4
.text$mn:000043AD ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:000043AD
.text$mn:000043AD _text$mn        ends
.text$mn:000043AD
.text$di:000043B0 ; ===========================================================================
.text$di:000043B0
.text$di:000043B0 ; Segment type: Pure code
.text$di:000043B0 ; Segment permissions: Read/Execute
.text$di:000043B0 _text$di        segment para public 'CODE' use32
.text$di:000043B0                 assume cs:_text$di
.text$di:000043B0                 ;org 43B0h
.text$di:000043B0 ; COMDAT (pick any)
.text$di:000043B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000043B0
.text$di:000043B0 ; =============== S U B R O U T I N E =======================================
.text$di:000043B0
.text$di:000043B0 ; Attributes: bp-based frame
.text$di:000043B0
.text$di:000043B0 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:000043B0 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:000043B0                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:000043B0                 push    ebp
.text$di:000043B1                 mov     ebp, esp
.text$di:000043B3                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:000043B8                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:000043BD                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000043C2                 call    _atexit
.text$di:000043C7                 add     esp, 4
.text$di:000043CA                 pop     ebp
.text$di:000043CB                 retn
.text$di:000043CB ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:000043CB
.text$di:000043CB _text$di        ends
.text$di:000043CB
.text$di:000043CC ; ===========================================================================
.text$di:000043CC
.text$di:000043CC ; Segment type: Pure code
.text$di:000043CC ; Segment permissions: Read/Execute
.text$di:000043CC _text$di        segment para public 'CODE' use32
.text$di:000043CC                 assume cs:_text$di
.text$di:000043CC                 ;org 43CCh
.text$di:000043CC ; COMDAT (pick any)
.text$di:000043CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000043CC
.text$di:000043CC ; =============== S U B R O U T I N E =======================================
.text$di:000043CC
.text$di:000043CC ; Attributes: bp-based frame
.text$di:000043CC
.text$di:000043CC ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:000043CC ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:000043CC                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:000043CC                 push    ebp
.text$di:000043CD                 mov     ebp, esp
.text$di:000043CF                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:000043D4                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:000043D9                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000043DE                 call    _atexit
.text$di:000043E3                 add     esp, 4
.text$di:000043E6                 pop     ebp
.text$di:000043E7                 retn
.text$di:000043E7 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:000043E7
.text$di:000043E7 _text$di        ends
.text$di:000043E7
.text$di:000043E8 ; ===========================================================================
.text$di:000043E8
.text$di:000043E8 ; Segment type: Pure code
.text$di:000043E8 ; Segment permissions: Read/Execute
.text$di:000043E8 _text$di        segment para public 'CODE' use32
.text$di:000043E8                 assume cs:_text$di
.text$di:000043E8                 ;org 43E8h
.text$di:000043E8 ; COMDAT (pick any)
.text$di:000043E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000043E8
.text$di:000043E8 ; =============== S U B R O U T I N E =======================================
.text$di:000043E8
.text$di:000043E8 ; Attributes: bp-based frame
.text$di:000043E8
.text$di:000043E8 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:000043E8 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:000043E8                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:000043E8                 push    ebp
.text$di:000043E9                 mov     ebp, esp
.text$di:000043EB                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:000043F0                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:000043F5                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000043FA                 call    _atexit
.text$di:000043FF                 add     esp, 4
.text$di:00004402                 pop     ebp
.text$di:00004403                 retn
.text$di:00004403 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00004403
.text$di:00004403 _text$di        ends
.text$di:00004403
.text$di:00004404 ; ===========================================================================
.text$di:00004404
.text$di:00004404 ; Segment type: Pure code
.text$di:00004404 ; Segment permissions: Read/Execute
.text$di:00004404 _text$di        segment para public 'CODE' use32
.text$di:00004404                 assume cs:_text$di
.text$di:00004404                 ;org 4404h
.text$di:00004404 ; COMDAT (pick any)
.text$di:00004404                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004404
.text$di:00004404 ; =============== S U B R O U T I N E =======================================
.text$di:00004404
.text$di:00004404 ; Attributes: bp-based frame
.text$di:00004404
.text$di:00004404 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00004404 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00004404                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00004404                 push    ebp
.text$di:00004405                 mov     ebp, esp
.text$di:00004407                 push    0               ; unsigned int
.text$di:00004409                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000440E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00004413                 pop     ebp
.text$di:00004414                 retn
.text$di:00004414 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00004414
.text$di:00004414 ; ---------------------------------------------------------------------------
.text$di:00004415                 align 4
.text$di:00004415 _text$di        ends
.text$di:00004415
.text$di:00004418 ; ===========================================================================
.text$di:00004418
.text$di:00004418 ; Segment type: Pure code
.text$di:00004418 ; Segment permissions: Read/Execute
.text$di:00004418 _text$di        segment para public 'CODE' use32
.text$di:00004418                 assume cs:_text$di
.text$di:00004418                 ;org 4418h
.text$di:00004418 ; COMDAT (pick any)
.text$di:00004418                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004418
.text$di:00004418 ; =============== S U B R O U T I N E =======================================
.text$di:00004418
.text$di:00004418 ; Attributes: bp-based frame
.text$di:00004418
.text$di:00004418 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00004418 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00004418                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00004418                 push    ebp
.text$di:00004419                 mov     ebp, esp
.text$di:0000441B                 push    0               ; unsigned int
.text$di:0000441D                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00004422                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00004427                 pop     ebp
.text$di:00004428                 retn
.text$di:00004428 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00004428
.text$di:00004428 ; ---------------------------------------------------------------------------
.text$di:00004429                 align 4
.text$di:00004429 _text$di        ends
.text$di:00004429
.text$di:0000442C ; ===========================================================================
.text$di:0000442C
.text$di:0000442C ; Segment type: Pure code
.text$di:0000442C ; Segment permissions: Read/Execute
.text$di:0000442C _text$di        segment para public 'CODE' use32
.text$di:0000442C                 assume cs:_text$di
.text$di:0000442C                 ;org 442Ch
.text$di:0000442C ; COMDAT (pick any)
.text$di:0000442C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000442C
.text$di:0000442C ; =============== S U B R O U T I N E =======================================
.text$di:0000442C
.text$di:0000442C ; Attributes: bp-based frame
.text$di:0000442C
.text$di:0000442C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:0000442C ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000442C                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:0000442C                 push    ebp
.text$di:0000442D                 mov     ebp, esp
.text$di:0000442F                 push    0               ; unsigned int
.text$di:00004431                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00004436                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000443B                 pop     ebp
.text$di:0000443C                 retn
.text$di:0000443C ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000443C
.text$di:0000443C ; ---------------------------------------------------------------------------
.text$di:0000443D                 align 10h
.text$di:0000443D _text$di        ends
.text$di:0000443D
.text$di:00004440 ; ===========================================================================
.text$di:00004440
.text$di:00004440 ; Segment type: Pure code
.text$di:00004440 ; Segment permissions: Read/Execute
.text$di:00004440 _text$di        segment para public 'CODE' use32
.text$di:00004440                 assume cs:_text$di
.text$di:00004440                 ;org 4440h
.text$di:00004440 ; COMDAT (pick any)
.text$di:00004440                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004440
.text$di:00004440 ; =============== S U B R O U T I N E =======================================
.text$di:00004440
.text$di:00004440 ; Attributes: bp-based frame
.text$di:00004440
.text$di:00004440 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00004440 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00004440                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00004440                 push    ebp
.text$di:00004441                 mov     ebp, esp
.text$di:00004443                 push    0               ; unsigned int
.text$di:00004445                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:0000444A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000444F                 pop     ebp
.text$di:00004450                 retn
.text$di:00004450 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00004450
.text$di:00004450 ; ---------------------------------------------------------------------------
.text$di:00004451                 align 4
.text$di:00004451 _text$di        ends
.text$di:00004451
.text$di:00004454 ; ===========================================================================
.text$di:00004454
.text$di:00004454 ; Segment type: Pure code
.text$di:00004454 ; Segment permissions: Read/Execute
.text$di:00004454 _text$di        segment para public 'CODE' use32
.text$di:00004454                 assume cs:_text$di
.text$di:00004454                 ;org 4454h
.text$di:00004454 ; COMDAT (pick any)
.text$di:00004454                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004454
.text$di:00004454 ; =============== S U B R O U T I N E =======================================
.text$di:00004454
.text$di:00004454 ; Attributes: bp-based frame
.text$di:00004454
.text$di:00004454 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00004454 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00004454
.text$di:00004454 var_1           = byte ptr -1
.text$di:00004454
.text$di:00004454                 push    ebp
.text$di:00004455                 mov     ebp, esp
.text$di:00004457                 push    ecx
.text$di:00004458                 xor     eax, eax
.text$di:0000445A                 mov     [ebp+var_1], al
.text$di:0000445D                 mov     esp, ebp
.text$di:0000445F                 pop     ebp
.text$di:00004460                 retn
.text$di:00004460 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00004460
.text$di:00004460 ; ---------------------------------------------------------------------------
.text$di:00004461                 align 4
.text$di:00004461 _text$di        ends
.text$di:00004461
.text$di:00004464 ; ===========================================================================
.text$di:00004464
.text$di:00004464 ; Segment type: Pure code
.text$di:00004464 ; Segment permissions: Read/Execute
.text$di:00004464 _text$di        segment para public 'CODE' use32
.text$di:00004464                 assume cs:_text$di
.text$di:00004464                 ;org 4464h
.text$di:00004464 ; COMDAT (pick any)
.text$di:00004464                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004464
.text$di:00004464 ; =============== S U B R O U T I N E =======================================
.text$di:00004464
.text$di:00004464 ; Attributes: bp-based frame
.text$di:00004464
.text$di:00004464 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00004464 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00004464                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00004464
.text$di:00004464 var_1           = byte ptr -1
.text$di:00004464
.text$di:00004464                 push    ebp
.text$di:00004465                 mov     ebp, esp
.text$di:00004467                 push    ecx
.text$di:00004468                 xor     eax, eax
.text$di:0000446A                 mov     [ebp+var_1], al
.text$di:0000446D                 mov     esp, ebp
.text$di:0000446F                 pop     ebp
.text$di:00004470                 retn
.text$di:00004470 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00004470
.text$di:00004470 ; ---------------------------------------------------------------------------
.text$di:00004471                 align 4
.text$di:00004471 _text$di        ends
.text$di:00004471
.text$yd:00004474 ; ===========================================================================
.text$yd:00004474
.text$yd:00004474 ; Segment type: Pure code
.text$yd:00004474 ; Segment permissions: Read/Execute
.text$yd:00004474 _text$yd        segment para public 'CODE' use32
.text$yd:00004474                 assume cs:_text$yd
.text$yd:00004474                 ;org 4474h
.text$yd:00004474 ; COMDAT (pick any)
.text$yd:00004474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00004474
.text$yd:00004474 ; =============== S U B R O U T I N E =======================================
.text$yd:00004474
.text$yd:00004474 ; Attributes: bp-based frame
.text$yd:00004474
.text$yd:00004474 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00004474 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00004474                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00004474                 push    ebp
.text$yd:00004475                 mov     ebp, esp
.text$yd:00004477                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:0000447C                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00004481                 pop     ebp
.text$yd:00004482                 retn
.text$yd:00004482 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00004482
.text$yd:00004482 ; ---------------------------------------------------------------------------
.text$yd:00004483                 align 4
.text$yd:00004483 _text$yd        ends
.text$yd:00004483
.text$yd:00004484 ; ===========================================================================
.text$yd:00004484
.text$yd:00004484 ; Segment type: Pure code
.text$yd:00004484 ; Segment permissions: Read/Execute
.text$yd:00004484 _text$yd        segment para public 'CODE' use32
.text$yd:00004484                 assume cs:_text$yd
.text$yd:00004484                 ;org 4484h
.text$yd:00004484 ; COMDAT (pick any)
.text$yd:00004484                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00004484
.text$yd:00004484 ; =============== S U B R O U T I N E =======================================
.text$yd:00004484
.text$yd:00004484 ; Attributes: bp-based frame
.text$yd:00004484
.text$yd:00004484 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00004484 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00004484                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00004484                 push    ebp
.text$yd:00004485                 mov     ebp, esp
.text$yd:00004487                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:0000448C                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00004491                 pop     ebp
.text$yd:00004492                 retn
.text$yd:00004492 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00004492
.text$yd:00004492 ; ---------------------------------------------------------------------------
.text$yd:00004493                 align 4
.text$yd:00004493 _text$yd        ends
.text$yd:00004493
.text$yd:00004494 ; ===========================================================================
.text$yd:00004494
.text$yd:00004494 ; Segment type: Pure code
.text$yd:00004494 ; Segment permissions: Read/Execute
.text$yd:00004494 _text$yd        segment para public 'CODE' use32
.text$yd:00004494                 assume cs:_text$yd
.text$yd:00004494                 ;org 4494h
.text$yd:00004494 ; COMDAT (pick any)
.text$yd:00004494                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00004494
.text$yd:00004494 ; =============== S U B R O U T I N E =======================================
.text$yd:00004494
.text$yd:00004494 ; Attributes: bp-based frame
.text$yd:00004494
.text$yd:00004494 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00004494 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00004494                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00004494                 push    ebp
.text$yd:00004495                 mov     ebp, esp
.text$yd:00004497                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:0000449C                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:000044A1                 pop     ebp
.text$yd:000044A2                 retn
.text$yd:000044A2 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:000044A2
.text$yd:000044A2 ; ---------------------------------------------------------------------------
.text$yd:000044A3                 align 4
.text$yd:000044A3 _text$yd        ends
.text$yd:000044A3
.text$mn:000044A4 ; ===========================================================================
.text$mn:000044A4
.text$mn:000044A4 ; Segment type: Pure code
.text$mn:000044A4 ; Segment permissions: Read/Execute
.text$mn:000044A4 _text$mn        segment para public 'CODE' use32
.text$mn:000044A4                 assume cs:_text$mn
.text$mn:000044A4                 ;org 44A4h
.text$mn:000044A4 ; COMDAT (pick any)
.text$mn:000044A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000044A4
.text$mn:000044A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000044A4
.text$mn:000044A4 ; Attributes: bp-based frame
.text$mn:000044A4
.text$mn:000044A4 ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:000044A4                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:000044A4 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:000044A4                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(TreeStateNode *,std::_Container_base12 const *)+45p
.text$mn:000044A4                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+49p
.text$mn:000044A4
.text$mn:000044A4 var_1C          = byte ptr -1Ch
.text$mn:000044A4 var_18          = byte ptr -18h
.text$mn:000044A4 var_14          = dword ptr -14h
.text$mn:000044A4 var_10          = dword ptr -10h
.text$mn:000044A4 var_C           = dword ptr -0Ch
.text$mn:000044A4 var_4           = dword ptr -4
.text$mn:000044A4 arg_0           = dword ptr  8
.text$mn:000044A4
.text$mn:000044A4                 push    ebp
.text$mn:000044A5                 mov     ebp, esp
.text$mn:000044A7                 push    0FFFFFFFFh
.text$mn:000044A9                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:000044AE                 mov     eax, large fs:0
.text$mn:000044B4                 push    eax
.text$mn:000044B5                 sub     esp, 10h
.text$mn:000044B8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000044BD                 xor     eax, ebp
.text$mn:000044BF                 push    eax
.text$mn:000044C0                 lea     eax, [ebp+var_C]
.text$mn:000044C3                 mov     large fs:0, eax
.text$mn:000044C9                 mov     [ebp+var_10], ecx
.text$mn:000044CC                 cmp     [ebp+arg_0], 0
.text$mn:000044D0                 jnz     short loc_44FC
.text$mn:000044D2                 push    3               ; int
.text$mn:000044D4                 lea     ecx, [ebp+var_18] ; this
.text$mn:000044D7                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000044DC                 mov     [ebp+var_4], 0
.text$mn:000044E3                 mov     ecx, [ebp+var_10] ; this
.text$mn:000044E6                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:000044EB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000044F2                 lea     ecx, [ebp+var_18] ; this
.text$mn:000044F5                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000044FA                 jmp     short loc_4553
.text$mn:000044FC ; ---------------------------------------------------------------------------
.text$mn:000044FC
.text$mn:000044FC loc_44FC:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:000044FC                 mov     eax, [ebp+arg_0]
.text$mn:000044FF                 mov     ecx, [eax]
.text$mn:00004501                 mov     [ebp+var_14], ecx
.text$mn:00004504                 mov     edx, [ebp+var_10]
.text$mn:00004507                 mov     eax, [edx]
.text$mn:00004509                 cmp     eax, [ebp+var_14]
.text$mn:0000450C                 jz      short loc_4553
.text$mn:0000450E                 push    3               ; int
.text$mn:00004510                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00004513                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00004518                 mov     [ebp+var_4], 1
.text$mn:0000451F                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004522                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00004527                 mov     ecx, [ebp+var_10]
.text$mn:0000452A                 mov     edx, [ebp+var_14]
.text$mn:0000452D                 mov     eax, [edx+4]
.text$mn:00004530                 mov     [ecx+4], eax
.text$mn:00004533                 mov     ecx, [ebp+var_14]
.text$mn:00004536                 mov     edx, [ebp+var_10]
.text$mn:00004539                 mov     [ecx+4], edx
.text$mn:0000453C                 mov     eax, [ebp+var_10]
.text$mn:0000453F                 mov     ecx, [ebp+var_14]
.text$mn:00004542                 mov     [eax], ecx
.text$mn:00004544                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000454B                 lea     ecx, [ebp+var_1C] ; this
.text$mn:0000454E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00004553
.text$mn:00004553 loc_4553:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:00004553                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:00004553                 mov     ecx, [ebp+var_C]
.text$mn:00004556                 mov     large fs:0, ecx
.text$mn:0000455D                 pop     ecx
.text$mn:0000455E                 mov     esp, ebp
.text$mn:00004560                 pop     ebp
.text$mn:00004561                 retn    4
.text$mn:00004561 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:00004561
.text$mn:00004561 _text$mn        ends
.text$mn:00004561
.text$x:00004564 ; ===========================================================================
.text$x:00004564
.text$x:00004564 ; Segment type: Pure code
.text$x:00004564 ; Segment permissions: Read/Execute
.text$x:00004564 _text$x         segment para public 'CODE' use32
.text$x:00004564                 assume cs:_text$x
.text$x:00004564                 ;org 4564h
.text$x:00004564 ; COMDAT (pick associative to section at 44A4)
.text$x:00004564                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004564
.text$x:00004564 ; =============== S U B R O U T I N E =======================================
.text$x:00004564
.text$x:00004564
.text$x:00004564 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:00004564                                         ; DATA XREF: .xdata$x:00006D88o
.text$x:00004564                 lea     ecx, [ebp-18h]  ; this
.text$x:00004567                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00004567 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:00004567
.text$x:0000456C
.text$x:0000456C ; =============== S U B R O U T I N E =======================================
.text$x:0000456C
.text$x:0000456C
.text$x:0000456C __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:0000456C                                         ; DATA XREF: .xdata$x:00006D90o
.text$x:0000456C                 lea     ecx, [ebp-1Ch]  ; this
.text$x:0000456F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000456F __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:0000456F
.text$x:00004574
.text$x:00004574 ; =============== S U B R O U T I N E =======================================
.text$x:00004574
.text$x:00004574
.text$x:00004574 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:00004574                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:00004574
.text$x:00004574 arg_4           = dword ptr  8
.text$x:00004574
.text$x:00004574                 mov     edx, [esp+arg_4]
.text$x:00004578                 lea     eax, [edx+0Ch]
.text$x:0000457B                 mov     ecx, [edx-14h]
.text$x:0000457E                 xor     ecx, eax
.text$x:00004580                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004585                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:0000458A                 jmp     ___CxxFrameHandler3
.text$x:0000458A __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:0000458A
.text$x:0000458A ; ---------------------------------------------------------------------------
.text$x:0000458F                 align 10h
.text$x:0000458F _text$x         ends
.text$x:0000458F
.text$mn:00004590 ; ===========================================================================
.text$mn:00004590
.text$mn:00004590 ; Segment type: Pure code
.text$mn:00004590 ; Segment permissions: Read/Execute
.text$mn:00004590 _text$mn        segment para public 'CODE' use32
.text$mn:00004590                 assume cs:_text$mn
.text$mn:00004590                 ;org 4590h
.text$mn:00004590 ; COMDAT (pick any)
.text$mn:00004590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004590
.text$mn:00004590 ; =============== S U B R O U T I N E =======================================
.text$mn:00004590
.text$mn:00004590 ; Attributes: bp-based frame
.text$mn:00004590
.text$mn:00004590 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00004590                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00004590 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00004590                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00004590
.text$mn:00004590 var_10          = byte ptr -10h
.text$mn:00004590 var_8           = dword ptr -8
.text$mn:00004590 var_1           = byte ptr -1
.text$mn:00004590
.text$mn:00004590                 push    ebp
.text$mn:00004591                 mov     ebp, esp
.text$mn:00004593                 sub     esp, 10h
.text$mn:00004596                 mov     [ebp+var_8], ecx
.text$mn:00004599                 lea     ecx, [ebp+var_1]
.text$mn:0000459C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000045A1                 push    1
.text$mn:000045A3                 lea     ecx, [ebp+var_1]
.text$mn:000045A6                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000045AB                 mov     ecx, [ebp+var_8]
.text$mn:000045AE                 mov     [ecx], eax
.text$mn:000045B0                 lea     ecx, [ebp+var_10] ; this
.text$mn:000045B3                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000045B8                 push    eax             ; int
.text$mn:000045B9                 mov     edx, [ebp+var_8]
.text$mn:000045BC                 mov     eax, [edx]
.text$mn:000045BE                 push    eax             ; void *
.text$mn:000045BF                 lea     ecx, [ebp+var_1]
.text$mn:000045C2                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000045C7                 mov     ecx, [ebp+var_8]
.text$mn:000045CA                 mov     edx, [ecx]
.text$mn:000045CC                 mov     eax, [ebp+var_8]
.text$mn:000045CF                 mov     [edx], eax
.text$mn:000045D1                 mov     esp, ebp
.text$mn:000045D3                 pop     ebp
.text$mn:000045D4                 retn
.text$mn:000045D4 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000045D4
.text$mn:000045D4 ; ---------------------------------------------------------------------------
.text$mn:000045D5                 align 4
.text$mn:000045D5 _text$mn        ends
.text$mn:000045D5
.text$mn:000045D8 ; ===========================================================================
.text$mn:000045D8
.text$mn:000045D8 ; Segment type: Pure code
.text$mn:000045D8 ; Segment permissions: Read/Execute
.text$mn:000045D8 _text$mn        segment para public 'CODE' use32
.text$mn:000045D8                 assume cs:_text$mn
.text$mn:000045D8                 ;org 45D8h
.text$mn:000045D8 ; COMDAT (pick any)
.text$mn:000045D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000045D8
.text$mn:000045D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000045D8
.text$mn:000045D8 ; Attributes: bp-based frame
.text$mn:000045D8
.text$mn:000045D8 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:000045D8                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:000045D8 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000045D8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:000045D8
.text$mn:000045D8 var_10          = byte ptr -10h
.text$mn:000045D8 var_8           = dword ptr -8
.text$mn:000045D8 var_1           = byte ptr -1
.text$mn:000045D8
.text$mn:000045D8                 push    ebp
.text$mn:000045D9                 mov     ebp, esp
.text$mn:000045DB                 sub     esp, 10h
.text$mn:000045DE                 mov     [ebp+var_8], ecx
.text$mn:000045E1                 lea     ecx, [ebp+var_1]
.text$mn:000045E4                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000045E9                 push    1
.text$mn:000045EB                 lea     ecx, [ebp+var_1]
.text$mn:000045EE                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000045F3                 mov     ecx, [ebp+var_8]
.text$mn:000045F6                 mov     [ecx], eax
.text$mn:000045F8                 lea     ecx, [ebp+var_10] ; this
.text$mn:000045FB                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00004600                 push    eax             ; int
.text$mn:00004601                 mov     edx, [ebp+var_8]
.text$mn:00004604                 mov     eax, [edx]
.text$mn:00004606                 push    eax             ; void *
.text$mn:00004607                 lea     ecx, [ebp+var_1]
.text$mn:0000460A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000460F                 mov     ecx, [ebp+var_8]
.text$mn:00004612                 mov     edx, [ecx]
.text$mn:00004614                 mov     eax, [ebp+var_8]
.text$mn:00004617                 mov     [edx], eax
.text$mn:00004619                 mov     esp, ebp
.text$mn:0000461B                 pop     ebp
.text$mn:0000461C                 retn
.text$mn:0000461C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000461C
.text$mn:0000461C ; ---------------------------------------------------------------------------
.text$mn:0000461D                 align 10h
.text$mn:0000461D _text$mn        ends
.text$mn:0000461D
.text$mn:00004620 ; ===========================================================================
.text$mn:00004620
.text$mn:00004620 ; Segment type: Pure code
.text$mn:00004620 ; Segment permissions: Read/Execute
.text$mn:00004620 _text$mn        segment para public 'CODE' use32
.text$mn:00004620                 assume cs:_text$mn
.text$mn:00004620                 ;org 4620h
.text$mn:00004620 ; COMDAT (pick any)
.text$mn:00004620                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004620
.text$mn:00004620 ; =============== S U B R O U T I N E =======================================
.text$mn:00004620
.text$mn:00004620 ; Attributes: bp-based frame
.text$mn:00004620
.text$mn:00004620 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct TreeStateNode, class std::allocator<struct TreeStateNode>>>::_Alloc_proxy(void)
.text$mn:00004620                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAEXXZ
.text$mn:00004620 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00004620                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>(std::allocator<TreeStateNode> const &)+38p
.text$mn:00004620
.text$mn:00004620 var_10          = byte ptr -10h
.text$mn:00004620 var_8           = dword ptr -8
.text$mn:00004620 var_1           = byte ptr -1
.text$mn:00004620
.text$mn:00004620                 push    ebp
.text$mn:00004621                 mov     ebp, esp
.text$mn:00004623                 sub     esp, 10h
.text$mn:00004626                 mov     [ebp+var_8], ecx
.text$mn:00004629                 lea     ecx, [ebp+var_1]
.text$mn:0000462C                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00004631                 push    1
.text$mn:00004633                 lea     ecx, [ebp+var_1]
.text$mn:00004636                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:0000463B                 mov     ecx, [ebp+var_8]
.text$mn:0000463E                 mov     [ecx], eax
.text$mn:00004640                 lea     ecx, [ebp+var_10] ; this
.text$mn:00004643                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00004648                 push    eax             ; int
.text$mn:00004649                 mov     edx, [ebp+var_8]
.text$mn:0000464C                 mov     eax, [edx]
.text$mn:0000464E                 push    eax             ; void *
.text$mn:0000464F                 lea     ecx, [ebp+var_1]
.text$mn:00004652                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00004657                 mov     ecx, [ebp+var_8]
.text$mn:0000465A                 mov     edx, [ecx]
.text$mn:0000465C                 mov     eax, [ebp+var_8]
.text$mn:0000465F                 mov     [edx], eax
.text$mn:00004661                 mov     esp, ebp
.text$mn:00004663                 pop     ebp
.text$mn:00004664                 retn
.text$mn:00004664 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00004664
.text$mn:00004664 ; ---------------------------------------------------------------------------
.text$mn:00004665                 align 4
.text$mn:00004665 _text$mn        ends
.text$mn:00004665
.text$mn:00004668 ; ===========================================================================
.text$mn:00004668
.text$mn:00004668 ; Segment type: Pure code
.text$mn:00004668 ; Segment permissions: Read/Execute
.text$mn:00004668 _text$mn        segment para public 'CODE' use32
.text$mn:00004668                 assume cs:_text$mn
.text$mn:00004668                 ;org 4668h
.text$mn:00004668 ; COMDAT (pick any)
.text$mn:00004668                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004668
.text$mn:00004668 ; =============== S U B R O U T I N E =======================================
.text$mn:00004668
.text$mn:00004668 ; Attributes: bp-based frame
.text$mn:00004668
.text$mn:00004668 ; protected: bool __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::_Buy(unsigned int)
.text$mn:00004668                 public ?_Buy@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAE_NI@Z
.text$mn:00004668 ?_Buy@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAE_NI@Z proc near
.text$mn:00004668                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(std::vector<TreeStateNode,std::allocator<TreeStateNode>> const &)+62p
.text$mn:00004668
.text$mn:00004668 var_8           = dword ptr -8
.text$mn:00004668 var_1           = byte ptr -1
.text$mn:00004668 arg_0           = dword ptr  8
.text$mn:00004668
.text$mn:00004668                 push    ebp
.text$mn:00004669                 mov     ebp, esp
.text$mn:0000466B                 sub     esp, 8
.text$mn:0000466E                 mov     [ebp+var_8], ecx
.text$mn:00004671                 mov     eax, [ebp+var_8]
.text$mn:00004674                 mov     dword ptr [eax+4], 0
.text$mn:0000467B                 mov     ecx, [ebp+var_8]
.text$mn:0000467E                 mov     dword ptr [ecx+8], 0
.text$mn:00004685                 mov     edx, [ebp+var_8]
.text$mn:00004688                 mov     dword ptr [edx+0Ch], 0
.text$mn:0000468F                 cmp     [ebp+arg_0], 0
.text$mn:00004693                 jnz     short loc_469B
.text$mn:00004695                 xor     al, al
.text$mn:00004697                 jmp     short loc_46ED
.text$mn:00004699 ; ---------------------------------------------------------------------------
.text$mn:00004699                 jmp     short loc_46EB
.text$mn:0000469B ; ---------------------------------------------------------------------------
.text$mn:0000469B
.text$mn:0000469B loc_469B:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Buy(uint)+2Bj
.text$mn:0000469B                 mov     ecx, [ebp+var_8]
.text$mn:0000469E                 call    ?max_size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::max_size(void)
.text$mn:000046A3                 cmp     eax, [ebp+arg_0]
.text$mn:000046A6                 jnb     short loc_46B2
.text$mn:000046A8                 mov     ecx, [ebp+var_8]
.text$mn:000046AB                 call    ?_Xlen@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Xlen(void)
.text$mn:000046B0                 jmp     short loc_46EB
.text$mn:000046B2 ; ---------------------------------------------------------------------------
.text$mn:000046B2
.text$mn:000046B2 loc_46B2:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Buy(uint)+3Ej
.text$mn:000046B2                 mov     eax, [ebp+arg_0]
.text$mn:000046B5                 push    eax
.text$mn:000046B6                 lea     ecx, [ebp+var_1]
.text$mn:000046B9                 push    ecx
.text$mn:000046BA                 mov     ecx, [ebp+var_8]
.text$mn:000046BD                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Getal(void)
.text$mn:000046C2                 mov     ecx, eax
.text$mn:000046C4                 call    ?allocate@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEPAUTreeStateNode@@I@Z ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::allocate(uint)
.text$mn:000046C9                 mov     edx, [ebp+var_8]
.text$mn:000046CC                 mov     [edx+4], eax
.text$mn:000046CF                 mov     eax, [ebp+var_8]
.text$mn:000046D2                 mov     ecx, [ebp+var_8]
.text$mn:000046D5                 mov     edx, [ecx+4]
.text$mn:000046D8                 mov     [eax+8], edx
.text$mn:000046DB                 imul    eax, [ebp+arg_0], 4Ch
.text$mn:000046DF                 mov     ecx, [ebp+var_8]
.text$mn:000046E2                 add     eax, [ecx+4]
.text$mn:000046E5                 mov     edx, [ebp+var_8]
.text$mn:000046E8                 mov     [edx+0Ch], eax
.text$mn:000046EB
.text$mn:000046EB loc_46EB:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Buy(uint)+31j
.text$mn:000046EB                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Buy(uint)+48j
.text$mn:000046EB                 mov     al, 1
.text$mn:000046ED
.text$mn:000046ED loc_46ED:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Buy(uint)+2Fj
.text$mn:000046ED                 mov     esp, ebp
.text$mn:000046EF                 pop     ebp
.text$mn:000046F0                 retn    4
.text$mn:000046F0 ?_Buy@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAE_NI@Z endp
.text$mn:000046F0
.text$mn:000046F0 ; ---------------------------------------------------------------------------
.text$mn:000046F3                 align 4
.text$mn:000046F3 _text$mn        ends
.text$mn:000046F3
.text$mn:000046F4 ; ===========================================================================
.text$mn:000046F4
.text$mn:000046F4 ; Segment type: Pure code
.text$mn:000046F4 ; Segment permissions: Read/Execute
.text$mn:000046F4 _text$mn        segment para public 'CODE' use32
.text$mn:000046F4                 assume cs:_text$mn
.text$mn:000046F4                 ;org 46F4h
.text$mn:000046F4 ; COMDAT (pick any)
.text$mn:000046F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046F4
.text$mn:000046F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000046F4
.text$mn:000046F4 ; Attributes: bp-based frame
.text$mn:000046F4
.text$mn:000046F4 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Change_alloc(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:000046F4                 public ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
.text$mn:000046F4 ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z proc near
.text$mn:000046F4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Ap
.text$mn:000046F4
.text$mn:000046F4 var_4           = dword ptr -4
.text$mn:000046F4
.text$mn:000046F4                 push    ebp
.text$mn:000046F5                 mov     ebp, esp
.text$mn:000046F7                 push    ecx
.text$mn:000046F8                 mov     [ebp+var_4], ecx
.text$mn:000046FB                 mov     esp, ebp
.text$mn:000046FD                 pop     ebp
.text$mn:000046FE                 retn    4
.text$mn:000046FE ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z endp
.text$mn:000046FE
.text$mn:000046FE ; ---------------------------------------------------------------------------
.text$mn:00004701                 align 4
.text$mn:00004701 _text$mn        ends
.text$mn:00004701
.text$mn:00004704 ; ===========================================================================
.text$mn:00004704
.text$mn:00004704 ; Segment type: Pure code
.text$mn:00004704 ; Segment permissions: Read/Execute
.text$mn:00004704 _text$mn        segment para public 'CODE' use32
.text$mn:00004704                 assume cs:_text$mn
.text$mn:00004704                 ;org 4704h
.text$mn:00004704 ; COMDAT (pick any)
.text$mn:00004704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004704
.text$mn:00004704 ; =============== S U B R O U T I N E =======================================
.text$mn:00004704
.text$mn:00004704 ; Attributes: bp-based frame
.text$mn:00004704
.text$mn:00004704 ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:00004704                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:00004704 ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00004704                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Orphan_range(TreeStateNode *,TreeStateNode *)+80p
.text$mn:00004704
.text$mn:00004704 var_4           = dword ptr -4
.text$mn:00004704
.text$mn:00004704                 push    ebp
.text$mn:00004705                 mov     ebp, esp
.text$mn:00004707                 push    ecx
.text$mn:00004708                 mov     [ebp+var_4], ecx
.text$mn:0000470B                 mov     eax, [ebp+var_4]
.text$mn:0000470E                 mov     dword ptr [eax], 0
.text$mn:00004714                 mov     esp, ebp
.text$mn:00004716                 pop     ebp
.text$mn:00004717                 retn
.text$mn:00004717 ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00004717
.text$mn:00004717 _text$mn        ends
.text$mn:00004717
.text$mn:00004718 ; ===========================================================================
.text$mn:00004718
.text$mn:00004718 ; Segment type: Pure code
.text$mn:00004718 ; Segment permissions: Read/Execute
.text$mn:00004718 _text$mn        segment para public 'CODE' use32
.text$mn:00004718                 assume cs:_text$mn
.text$mn:00004718                 ;org 4718h
.text$mn:00004718 ; COMDAT (pick any)
.text$mn:00004718                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004718
.text$mn:00004718 ; =============== S U B R O U T I N E =======================================
.text$mn:00004718
.text$mn:00004718 ; Attributes: bp-based frame
.text$mn:00004718
.text$mn:00004718 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00004718                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00004718 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00004718                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00004718
.text$mn:00004718 var_20          = dword ptr -20h
.text$mn:00004718 var_1C          = dword ptr -1Ch
.text$mn:00004718 var_18          = dword ptr -18h
.text$mn:00004718 var_11          = byte ptr -11h
.text$mn:00004718 var_10          = dword ptr -10h
.text$mn:00004718 var_C           = byte ptr -0Ch
.text$mn:00004718 var_4           = dword ptr -4
.text$mn:00004718 arg_0           = dword ptr  8
.text$mn:00004718
.text$mn:00004718 ; FUNCTION CHUNK AT .text$mn:0000483A SIZE 00000009 BYTES
.text$mn:00004718
.text$mn:00004718                 push    ebp
.text$mn:00004719                 mov     ebp, esp
.text$mn:0000471B                 push    0FFFFFFFFh
.text$mn:0000471D                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00004722                 mov     eax, large fs:0
.text$mn:00004728                 push    eax
.text$mn:00004729                 push    ecx
.text$mn:0000472A                 sub     esp, 10h
.text$mn:0000472D                 push    ebx
.text$mn:0000472E                 push    esi
.text$mn:0000472F                 push    edi
.text$mn:00004730                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004735                 xor     eax, ebp
.text$mn:00004737                 push    eax
.text$mn:00004738                 lea     eax, [ebp+var_C]
.text$mn:0000473B                 mov     large fs:0, eax
.text$mn:00004741                 mov     [ebp+var_10], esp
.text$mn:00004744                 mov     [ebp+var_18], ecx
.text$mn:00004747                 mov     eax, [ebp+arg_0]
.text$mn:0000474A                 or      eax, 0Fh
.text$mn:0000474D                 mov     [ebp+var_1C], eax
.text$mn:00004750                 mov     ecx, [ebp+var_18]
.text$mn:00004753                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00004758                 cmp     eax, [ebp+var_1C]
.text$mn:0000475B                 jnb     short loc_4765
.text$mn:0000475D                 mov     ecx, [ebp+arg_0]
.text$mn:00004760                 mov     [ebp+var_1C], ecx
.text$mn:00004763                 jmp     short loc_47B7
.text$mn:00004765 ; ---------------------------------------------------------------------------
.text$mn:00004765
.text$mn:00004765 loc_4765:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00004765                 mov     edx, [ebp+var_18]
.text$mn:00004768                 mov     ecx, [edx+18h]
.text$mn:0000476B                 shr     ecx, 1
.text$mn:0000476D                 mov     eax, [ebp+var_1C]
.text$mn:00004770                 xor     edx, edx
.text$mn:00004772                 mov     esi, 3
.text$mn:00004777                 div     esi
.text$mn:00004779                 cmp     ecx, eax
.text$mn:0000477B                 ja      short loc_477F
.text$mn:0000477D                 jmp     short loc_47B7
.text$mn:0000477F ; ---------------------------------------------------------------------------
.text$mn:0000477F
.text$mn:0000477F loc_477F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:0000477F                 mov     ecx, [ebp+var_18]
.text$mn:00004782                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00004787                 mov     edx, [ebp+var_18]
.text$mn:0000478A                 mov     ecx, [edx+18h]
.text$mn:0000478D                 shr     ecx, 1
.text$mn:0000478F                 sub     eax, ecx
.text$mn:00004791                 mov     edx, [ebp+var_18]
.text$mn:00004794                 cmp     [edx+18h], eax
.text$mn:00004797                 ja      short loc_47AC
.text$mn:00004799                 mov     eax, [ebp+var_18]
.text$mn:0000479C                 mov     ecx, [eax+18h]
.text$mn:0000479F                 shr     ecx, 1
.text$mn:000047A1                 mov     edx, [ebp+var_18]
.text$mn:000047A4                 add     ecx, [edx+18h]
.text$mn:000047A7                 mov     [ebp+var_1C], ecx
.text$mn:000047AA                 jmp     short loc_47B7
.text$mn:000047AC ; ---------------------------------------------------------------------------
.text$mn:000047AC
.text$mn:000047AC loc_47AC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:000047AC                 mov     ecx, [ebp+var_18]
.text$mn:000047AF                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000047B4                 mov     [ebp+var_1C], eax
.text$mn:000047B7
.text$mn:000047B7 loc_47B7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:000047B7                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:000047B7                 mov     [ebp+var_4], 0
.text$mn:000047BE                 mov     eax, [ebp+var_1C]
.text$mn:000047C1                 add     eax, 1
.text$mn:000047C4                 push    eax
.text$mn:000047C5                 lea     ecx, [ebp+var_11]
.text$mn:000047C8                 push    ecx
.text$mn:000047C9                 mov     ecx, [ebp+var_18]
.text$mn:000047CC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000047D1                 mov     ecx, eax
.text$mn:000047D3                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000047D8                 mov     [ebp+var_20], eax
.text$mn:000047DB                 jmp     short loc_483A
.text$mn:000047DB ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:000047DB
.text$mn:000047DD
.text$mn:000047DD ; =============== S U B R O U T I N E =======================================
.text$mn:000047DD
.text$mn:000047DD
.text$mn:000047DD __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:000047DD                                         ; DATA XREF: .xdata$x:00006ECCo
.text$mn:000047DD
.text$mn:000047DD ; FUNCTION CHUNK AT .text$mn:00004824 SIZE 00000009 BYTES
.text$mn:000047DD ; FUNCTION CHUNK AT .text$mn:00004834 SIZE 00000006 BYTES
.text$mn:000047DD
.text$mn:000047DD                 mov     [ebp-10h], esp
.text$mn:000047E0                 mov     edx, [ebp+8]
.text$mn:000047E3                 mov     [ebp-1Ch], edx
.text$mn:000047E6                 mov     byte ptr [ebp-4], 2
.text$mn:000047EA                 mov     eax, [ebp-1Ch]
.text$mn:000047ED                 add     eax, 1
.text$mn:000047F0                 push    eax
.text$mn:000047F1                 lea     ecx, [ebp-12h]
.text$mn:000047F4                 push    ecx
.text$mn:000047F5                 mov     ecx, [ebp-18h]
.text$mn:000047F8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000047FD                 mov     ecx, eax
.text$mn:000047FF                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00004804                 mov     [ebp-20h], eax
.text$mn:00004807                 jmp     short loc_4824
.text$mn:00004807 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00004807
.text$mn:00004809
.text$mn:00004809 ; =============== S U B R O U T I N E =======================================
.text$mn:00004809
.text$mn:00004809 ; Attributes: noreturn
.text$mn:00004809
.text$mn:00004809 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00004809                                         ; DATA XREF: .xdata$x:00006EDCo
.text$mn:00004809                 push    0               ; Size
.text$mn:0000480B                 push    1               ; char
.text$mn:0000480D                 mov     ecx, [ebp-18h]
.text$mn:00004810                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00004815                 push    0
.text$mn:00004817                 push    0
.text$mn:00004819                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00004819 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00004819
.text$mn:0000481E ; ---------------------------------------------------------------------------
.text$mn:0000481E                 mov     eax, offset $LN17
.text$mn:00004823                 retn
.text$mn:00004824 ; ---------------------------------------------------------------------------
.text$mn:00004824 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00004824
.text$mn:00004824 loc_4824:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00004824                 mov     dword ptr [ebp-4], 1
.text$mn:0000482B                 jmp     short loc_4834
.text$mn:0000482B ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000482D
.text$mn:0000482D ; =============== S U B R O U T I N E =======================================
.text$mn:0000482D
.text$mn:0000482D
.text$mn:0000482D $LN17           proc near               ; DATA XREF: .text$mn:0000481Eo
.text$mn:0000482D                 mov     dword ptr [ebp-4], 1
.text$mn:0000482D $LN17           endp ; sp-analysis failed
.text$mn:0000482D
.text$mn:00004834 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00004834
.text$mn:00004834 loc_4834:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00004834                 mov     eax, offset $LN19
.text$mn:00004839                 retn
.text$mn:00004839 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000483A ; ---------------------------------------------------------------------------
.text$mn:0000483A ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000483A
.text$mn:0000483A loc_483A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:0000483A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004841                 jmp     short loc_484A
.text$mn:00004841 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00004843
.text$mn:00004843 ; =============== S U B R O U T I N E =======================================
.text$mn:00004843
.text$mn:00004843
.text$mn:00004843 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_4834o
.text$mn:00004843                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000484A
.text$mn:0000484A loc_484A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:0000484A                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000484E                 jbe     short loc_4869
.text$mn:00004850                 mov     edx, [ebp+0Ch]
.text$mn:00004853                 push    edx             ; Size
.text$mn:00004854                 mov     ecx, [ebp-18h]
.text$mn:00004857                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000485C                 push    eax             ; Src
.text$mn:0000485D                 mov     eax, [ebp-20h]
.text$mn:00004860                 push    eax             ; Dst
.text$mn:00004861                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00004866                 add     esp, 0Ch
.text$mn:00004869
.text$mn:00004869 loc_4869:                               ; CODE XREF: $LN19+Bj
.text$mn:00004869                 push    0               ; Size
.text$mn:0000486B                 push    1               ; char
.text$mn:0000486D                 mov     ecx, [ebp-18h]
.text$mn:00004870                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00004875                 lea     ecx, [ebp-20h]
.text$mn:00004878                 push    ecx             ; int
.text$mn:00004879                 mov     edx, [ebp-18h]
.text$mn:0000487C                 add     edx, 4
.text$mn:0000487F                 push    edx             ; void *
.text$mn:00004880                 lea     eax, [ebp-13h]
.text$mn:00004883                 push    eax
.text$mn:00004884                 mov     ecx, [ebp-18h]
.text$mn:00004887                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000488C                 mov     ecx, eax
.text$mn:0000488E                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00004893                 mov     ecx, [ebp-18h]
.text$mn:00004896                 mov     edx, [ebp-1Ch]
.text$mn:00004899                 mov     [ecx+18h], edx
.text$mn:0000489C                 mov     eax, [ebp+0Ch]
.text$mn:0000489F                 push    eax
.text$mn:000048A0                 mov     ecx, [ebp-18h]
.text$mn:000048A3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000048A8                 mov     ecx, [ebp-0Ch]
.text$mn:000048AB                 mov     large fs:0, ecx
.text$mn:000048B2                 pop     ecx
.text$mn:000048B3                 pop     edi
.text$mn:000048B4                 pop     esi
.text$mn:000048B5                 pop     ebx
.text$mn:000048B6                 mov     esp, ebp
.text$mn:000048B8                 pop     ebp
.text$mn:000048B9                 retn    8
.text$mn:000048B9 $LN19           endp ; sp-analysis failed
.text$mn:000048B9
.text$mn:000048B9 _text$mn        ends
.text$mn:000048B9
.text$x:000048BC ; ===========================================================================
.text$x:000048BC
.text$x:000048BC ; Segment type: Pure code
.text$x:000048BC ; Segment permissions: Read/Execute
.text$x:000048BC _text$x         segment para public 'CODE' use32
.text$x:000048BC                 assume cs:_text$x
.text$x:000048BC                 ;org 48BCh
.text$x:000048BC ; COMDAT (pick associative to section at 4718)
.text$x:000048BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000048BC
.text$x:000048BC ; =============== S U B R O U T I N E =======================================
.text$x:000048BC
.text$x:000048BC
.text$x:000048BC __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:000048BC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:000048BC
.text$x:000048BC arg_4           = dword ptr  8
.text$x:000048BC
.text$x:000048BC                 mov     edx, [esp+arg_4]
.text$x:000048C0                 lea     eax, [edx+0Ch]
.text$x:000048C3                 mov     ecx, [edx-24h]
.text$x:000048C6                 xor     ecx, eax
.text$x:000048C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000048CD                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:000048D2                 jmp     ___CxxFrameHandler3
.text$x:000048D2 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:000048D2
.text$x:000048D2 ; ---------------------------------------------------------------------------
.text$x:000048D7                 align 4
.text$x:000048D7 _text$x         ends
.text$x:000048D7
.text$mn:000048D8 ; ===========================================================================
.text$mn:000048D8
.text$mn:000048D8 ; Segment type: Pure code
.text$mn:000048D8 ; Segment permissions: Read/Execute
.text$mn:000048D8 _text$mn        segment para public 'CODE' use32
.text$mn:000048D8                 assume cs:_text$mn
.text$mn:000048D8                 ;org 48D8h
.text$mn:000048D8 ; COMDAT (pick any)
.text$mn:000048D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048D8
.text$mn:000048D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000048D8
.text$mn:000048D8 ; Attributes: bp-based frame
.text$mn:000048D8
.text$mn:000048D8 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:000048D8                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:000048D8 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:000048D8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:000048D8
.text$mn:000048D8 var_20          = dword ptr -20h
.text$mn:000048D8 var_1C          = dword ptr -1Ch
.text$mn:000048D8 var_18          = dword ptr -18h
.text$mn:000048D8 var_11          = byte ptr -11h
.text$mn:000048D8 var_10          = dword ptr -10h
.text$mn:000048D8 var_C           = byte ptr -0Ch
.text$mn:000048D8 var_4           = dword ptr -4
.text$mn:000048D8 arg_0           = dword ptr  8
.text$mn:000048D8
.text$mn:000048D8 ; FUNCTION CHUNK AT .text$mn:000049FA SIZE 00000009 BYTES
.text$mn:000048D8
.text$mn:000048D8                 push    ebp
.text$mn:000048D9                 mov     ebp, esp
.text$mn:000048DB                 push    0FFFFFFFFh
.text$mn:000048DD                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:000048E2                 mov     eax, large fs:0
.text$mn:000048E8                 push    eax
.text$mn:000048E9                 push    ecx
.text$mn:000048EA                 sub     esp, 10h
.text$mn:000048ED                 push    ebx
.text$mn:000048EE                 push    esi
.text$mn:000048EF                 push    edi
.text$mn:000048F0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000048F5                 xor     eax, ebp
.text$mn:000048F7                 push    eax
.text$mn:000048F8                 lea     eax, [ebp+var_C]
.text$mn:000048FB                 mov     large fs:0, eax
.text$mn:00004901                 mov     [ebp+var_10], esp
.text$mn:00004904                 mov     [ebp+var_18], ecx
.text$mn:00004907                 mov     eax, [ebp+arg_0]
.text$mn:0000490A                 or      eax, 7
.text$mn:0000490D                 mov     [ebp+var_1C], eax
.text$mn:00004910                 mov     ecx, [ebp+var_18]
.text$mn:00004913                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00004918                 cmp     eax, [ebp+var_1C]
.text$mn:0000491B                 jnb     short loc_4925
.text$mn:0000491D                 mov     ecx, [ebp+arg_0]
.text$mn:00004920                 mov     [ebp+var_1C], ecx
.text$mn:00004923                 jmp     short loc_4977
.text$mn:00004925 ; ---------------------------------------------------------------------------
.text$mn:00004925
.text$mn:00004925 loc_4925:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:00004925                 mov     edx, [ebp+var_18]
.text$mn:00004928                 mov     ecx, [edx+18h]
.text$mn:0000492B                 shr     ecx, 1
.text$mn:0000492D                 mov     eax, [ebp+var_1C]
.text$mn:00004930                 xor     edx, edx
.text$mn:00004932                 mov     esi, 3
.text$mn:00004937                 div     esi
.text$mn:00004939                 cmp     ecx, eax
.text$mn:0000493B                 ja      short loc_493F
.text$mn:0000493D                 jmp     short loc_4977
.text$mn:0000493F ; ---------------------------------------------------------------------------
.text$mn:0000493F
.text$mn:0000493F loc_493F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:0000493F                 mov     ecx, [ebp+var_18]
.text$mn:00004942                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00004947                 mov     edx, [ebp+var_18]
.text$mn:0000494A                 mov     ecx, [edx+18h]
.text$mn:0000494D                 shr     ecx, 1
.text$mn:0000494F                 sub     eax, ecx
.text$mn:00004951                 mov     edx, [ebp+var_18]
.text$mn:00004954                 cmp     [edx+18h], eax
.text$mn:00004957                 ja      short loc_496C
.text$mn:00004959                 mov     eax, [ebp+var_18]
.text$mn:0000495C                 mov     ecx, [eax+18h]
.text$mn:0000495F                 shr     ecx, 1
.text$mn:00004961                 mov     edx, [ebp+var_18]
.text$mn:00004964                 add     ecx, [edx+18h]
.text$mn:00004967                 mov     [ebp+var_1C], ecx
.text$mn:0000496A                 jmp     short loc_4977
.text$mn:0000496C ; ---------------------------------------------------------------------------
.text$mn:0000496C
.text$mn:0000496C loc_496C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:0000496C                 mov     ecx, [ebp+var_18]
.text$mn:0000496F                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00004974                 mov     [ebp+var_1C], eax
.text$mn:00004977
.text$mn:00004977 loc_4977:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:00004977                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:00004977                 mov     [ebp+var_4], 0
.text$mn:0000497E                 mov     eax, [ebp+var_1C]
.text$mn:00004981                 add     eax, 1
.text$mn:00004984                 push    eax
.text$mn:00004985                 lea     ecx, [ebp+var_11]
.text$mn:00004988                 push    ecx
.text$mn:00004989                 mov     ecx, [ebp+var_18]
.text$mn:0000498C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00004991                 mov     ecx, eax
.text$mn:00004993                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00004998                 mov     [ebp+var_20], eax
.text$mn:0000499B                 jmp     short loc_49FA
.text$mn:0000499B ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:0000499B
.text$mn:0000499D
.text$mn:0000499D ; =============== S U B R O U T I N E =======================================
.text$mn:0000499D
.text$mn:0000499D
.text$mn:0000499D __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:0000499D                                         ; DATA XREF: .xdata$x:00007244o
.text$mn:0000499D
.text$mn:0000499D ; FUNCTION CHUNK AT .text$mn:000049E4 SIZE 00000009 BYTES
.text$mn:0000499D ; FUNCTION CHUNK AT .text$mn:000049F4 SIZE 00000006 BYTES
.text$mn:0000499D
.text$mn:0000499D                 mov     [ebp-10h], esp
.text$mn:000049A0                 mov     edx, [ebp+8]
.text$mn:000049A3                 mov     [ebp-1Ch], edx
.text$mn:000049A6                 mov     byte ptr [ebp-4], 2
.text$mn:000049AA                 mov     eax, [ebp-1Ch]
.text$mn:000049AD                 add     eax, 1
.text$mn:000049B0                 push    eax
.text$mn:000049B1                 lea     ecx, [ebp-12h]
.text$mn:000049B4                 push    ecx
.text$mn:000049B5                 mov     ecx, [ebp-18h]
.text$mn:000049B8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000049BD                 mov     ecx, eax
.text$mn:000049BF                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:000049C4                 mov     [ebp-20h], eax
.text$mn:000049C7                 jmp     short loc_49E4
.text$mn:000049C7 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:000049C7
.text$mn:000049C9
.text$mn:000049C9 ; =============== S U B R O U T I N E =======================================
.text$mn:000049C9
.text$mn:000049C9 ; Attributes: noreturn
.text$mn:000049C9
.text$mn:000049C9 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:000049C9                                         ; DATA XREF: .xdata$x:00007254o
.text$mn:000049C9                 push    0
.text$mn:000049CB                 push    1
.text$mn:000049CD                 mov     ecx, [ebp-18h]
.text$mn:000049D0                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000049D5                 push    0
.text$mn:000049D7                 push    0
.text$mn:000049D9                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000049D9 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:000049D9
.text$mn:000049DE ; ---------------------------------------------------------------------------
.text$mn:000049DE                 mov     eax, offset $LN17_0
.text$mn:000049E3                 retn
.text$mn:000049E4 ; ---------------------------------------------------------------------------
.text$mn:000049E4 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:000049E4
.text$mn:000049E4 loc_49E4:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:000049E4                 mov     dword ptr [ebp-4], 1
.text$mn:000049EB                 jmp     short loc_49F4
.text$mn:000049EB ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:000049ED
.text$mn:000049ED ; =============== S U B R O U T I N E =======================================
.text$mn:000049ED
.text$mn:000049ED
.text$mn:000049ED $LN17_0         proc near               ; DATA XREF: .text$mn:000049DEo
.text$mn:000049ED                 mov     dword ptr [ebp-4], 1
.text$mn:000049ED $LN17_0         endp ; sp-analysis failed
.text$mn:000049ED
.text$mn:000049F4 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:000049F4
.text$mn:000049F4 loc_49F4:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:000049F4                 mov     eax, offset $LN19_0
.text$mn:000049F9                 retn
.text$mn:000049F9 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:000049FA ; ---------------------------------------------------------------------------
.text$mn:000049FA ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:000049FA
.text$mn:000049FA loc_49FA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:000049FA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004A01                 jmp     short loc_4A0A
.text$mn:00004A01 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00004A03
.text$mn:00004A03 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A03
.text$mn:00004A03
.text$mn:00004A03 $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_49F4o
.text$mn:00004A03                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00004A0A
.text$mn:00004A0A loc_4A0A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:00004A0A                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00004A0E                 jbe     short loc_4A29
.text$mn:00004A10                 mov     edx, [ebp+0Ch]
.text$mn:00004A13                 push    edx             ; int
.text$mn:00004A14                 mov     ecx, [ebp-18h]
.text$mn:00004A17                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004A1C                 push    eax             ; Src
.text$mn:00004A1D                 mov     eax, [ebp-20h]
.text$mn:00004A20                 push    eax             ; Dst
.text$mn:00004A21                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00004A26                 add     esp, 0Ch
.text$mn:00004A29
.text$mn:00004A29 loc_4A29:                               ; CODE XREF: $LN19_0+Bj
.text$mn:00004A29                 push    0
.text$mn:00004A2B                 push    1
.text$mn:00004A2D                 mov     ecx, [ebp-18h]
.text$mn:00004A30                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00004A35                 lea     ecx, [ebp-20h]
.text$mn:00004A38                 push    ecx             ; int
.text$mn:00004A39                 mov     edx, [ebp-18h]
.text$mn:00004A3C                 add     edx, 4
.text$mn:00004A3F                 push    edx             ; void *
.text$mn:00004A40                 lea     eax, [ebp-13h]
.text$mn:00004A43                 push    eax
.text$mn:00004A44                 mov     ecx, [ebp-18h]
.text$mn:00004A47                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00004A4C                 mov     ecx, eax
.text$mn:00004A4E                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00004A53                 mov     ecx, [ebp-18h]
.text$mn:00004A56                 mov     edx, [ebp-1Ch]
.text$mn:00004A59                 mov     [ecx+18h], edx
.text$mn:00004A5C                 mov     eax, [ebp+0Ch]
.text$mn:00004A5F                 push    eax
.text$mn:00004A60                 mov     ecx, [ebp-18h]
.text$mn:00004A63                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00004A68                 mov     ecx, [ebp-0Ch]
.text$mn:00004A6B                 mov     large fs:0, ecx
.text$mn:00004A72                 pop     ecx
.text$mn:00004A73                 pop     edi
.text$mn:00004A74                 pop     esi
.text$mn:00004A75                 pop     ebx
.text$mn:00004A76                 mov     esp, ebp
.text$mn:00004A78                 pop     ebp
.text$mn:00004A79                 retn    8
.text$mn:00004A79 $LN19_0         endp ; sp-analysis failed
.text$mn:00004A79
.text$mn:00004A79 _text$mn        ends
.text$mn:00004A79
.text$x:00004A7C ; ===========================================================================
.text$x:00004A7C
.text$x:00004A7C ; Segment type: Pure code
.text$x:00004A7C ; Segment permissions: Read/Execute
.text$x:00004A7C _text$x         segment para public 'CODE' use32
.text$x:00004A7C                 assume cs:_text$x
.text$x:00004A7C                 ;org 4A7Ch
.text$x:00004A7C ; COMDAT (pick associative to section at 48D8)
.text$x:00004A7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004A7C
.text$x:00004A7C ; =============== S U B R O U T I N E =======================================
.text$x:00004A7C
.text$x:00004A7C
.text$x:00004A7C __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:00004A7C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:00004A7C
.text$x:00004A7C arg_4           = dword ptr  8
.text$x:00004A7C
.text$x:00004A7C                 mov     edx, [esp+arg_4]
.text$x:00004A80                 lea     eax, [edx+0Ch]
.text$x:00004A83                 mov     ecx, [edx-24h]
.text$x:00004A86                 xor     ecx, eax
.text$x:00004A88                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004A8D                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:00004A92                 jmp     ___CxxFrameHandler3
.text$x:00004A92 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:00004A92
.text$x:00004A92 ; ---------------------------------------------------------------------------
.text$x:00004A97                 align 4
.text$x:00004A97 _text$x         ends
.text$x:00004A97
.text$mn:00004A98 ; ===========================================================================
.text$mn:00004A98
.text$mn:00004A98 ; Segment type: Pure code
.text$mn:00004A98 ; Segment permissions: Read/Execute
.text$mn:00004A98 _text$mn        segment para public 'CODE' use32
.text$mn:00004A98                 assume cs:_text$mn
.text$mn:00004A98                 ;org 4A98h
.text$mn:00004A98 ; COMDAT (pick any)
.text$mn:00004A98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A98
.text$mn:00004A98 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A98
.text$mn:00004A98 ; Attributes: bp-based frame
.text$mn:00004A98
.text$mn:00004A98 ; protected: void __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::_Destroy(struct TreeStateNode *, struct TreeStateNode *)
.text$mn:00004A98                 public ?_Destroy@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXPAUTreeStateNode@@0@Z
.text$mn:00004A98 ?_Destroy@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXPAUTreeStateNode@@0@Z proc near
.text$mn:00004A98                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reallocate(uint)+CBp
.text$mn:00004A98                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Tidy(void)+2Bp
.text$mn:00004A98
.text$mn:00004A98 var_8           = dword ptr -8
.text$mn:00004A98 var_1           = byte ptr -1
.text$mn:00004A98 arg_0           = dword ptr  8
.text$mn:00004A98 arg_4           = dword ptr  0Ch
.text$mn:00004A98
.text$mn:00004A98                 push    ebp
.text$mn:00004A99                 mov     ebp, esp
.text$mn:00004A9B                 sub     esp, 8
.text$mn:00004A9E                 mov     [ebp+var_8], ecx
.text$mn:00004AA1                 lea     eax, [ebp+var_1]
.text$mn:00004AA4                 push    eax
.text$mn:00004AA5                 mov     ecx, [ebp+var_8]
.text$mn:00004AA8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Getal(void)
.text$mn:00004AAD                 lea     ecx, [ebp+var_1]
.text$mn:00004AB0                 push    ecx
.text$mn:00004AB1                 mov     edx, [ebp+arg_4]
.text$mn:00004AB4                 push    edx
.text$mn:00004AB5                 mov     eax, [ebp+arg_0]
.text$mn:00004AB8                 push    eax
.text$mn:00004AB9                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@YAXPAUTreeStateNode@@0AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<TreeStateNode>>>(TreeStateNode *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &)
.text$mn:00004ABE                 add     esp, 0Ch
.text$mn:00004AC1                 mov     esp, ebp
.text$mn:00004AC3                 pop     ebp
.text$mn:00004AC4                 retn    8
.text$mn:00004AC4 ?_Destroy@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXPAUTreeStateNode@@0@Z endp
.text$mn:00004AC4
.text$mn:00004AC4 ; ---------------------------------------------------------------------------
.text$mn:00004AC7                 align 4
.text$mn:00004AC7 _text$mn        ends
.text$mn:00004AC7
.text$mn:00004AC8 ; ===========================================================================
.text$mn:00004AC8
.text$mn:00004AC8 ; Segment type: Pure code
.text$mn:00004AC8 ; Segment permissions: Read/Execute
.text$mn:00004AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00004AC8                 assume cs:_text$mn
.text$mn:00004AC8                 ;org 4AC8h
.text$mn:00004AC8 ; COMDAT (pick any)
.text$mn:00004AC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AC8
.text$mn:00004AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AC8
.text$mn:00004AC8 ; Attributes: bp-based frame
.text$mn:00004AC8
.text$mn:00004AC8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00004AC8                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00004AC8 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00004AC8                                         ; CODE XREF: $LN19+60p
.text$mn:00004AC8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00004AC8
.text$mn:00004AC8 var_8           = dword ptr -8
.text$mn:00004AC8 var_1           = byte ptr -1
.text$mn:00004AC8 arg_0           = dword ptr  8
.text$mn:00004AC8
.text$mn:00004AC8                 push    ebp
.text$mn:00004AC9                 mov     ebp, esp
.text$mn:00004ACB                 sub     esp, 8
.text$mn:00004ACE                 mov     [ebp+var_8], ecx
.text$mn:00004AD1                 mov     [ebp+var_1], 0
.text$mn:00004AD5                 mov     eax, [ebp+var_8]
.text$mn:00004AD8                 mov     ecx, [ebp+arg_0]
.text$mn:00004ADB                 mov     [eax+14h], ecx
.text$mn:00004ADE                 lea     edx, [ebp+var_1]
.text$mn:00004AE1                 push    edx
.text$mn:00004AE2                 mov     ecx, [ebp+var_8]
.text$mn:00004AE5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004AEA                 add     eax, [ebp+arg_0]
.text$mn:00004AED                 push    eax
.text$mn:00004AEE                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00004AF3                 add     esp, 8
.text$mn:00004AF6                 mov     esp, ebp
.text$mn:00004AF8                 pop     ebp
.text$mn:00004AF9                 retn    4
.text$mn:00004AF9 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00004AF9
.text$mn:00004AF9 _text$mn        ends
.text$mn:00004AF9
.text$mn:00004AFC ; ===========================================================================
.text$mn:00004AFC
.text$mn:00004AFC ; Segment type: Pure code
.text$mn:00004AFC ; Segment permissions: Read/Execute
.text$mn:00004AFC _text$mn        segment para public 'CODE' use32
.text$mn:00004AFC                 assume cs:_text$mn
.text$mn:00004AFC                 ;org 4AFCh
.text$mn:00004AFC ; COMDAT (pick any)
.text$mn:00004AFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AFC
.text$mn:00004AFC ; =============== S U B R O U T I N E =======================================
.text$mn:00004AFC
.text$mn:00004AFC ; Attributes: bp-based frame
.text$mn:00004AFC
.text$mn:00004AFC ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:00004AFC                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:00004AFC ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:00004AFC                                         ; CODE XREF: $LN19_0+60p
.text$mn:00004AFC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:00004AFC
.text$mn:00004AFC var_8           = dword ptr -8
.text$mn:00004AFC var_2           = word ptr -2
.text$mn:00004AFC arg_0           = dword ptr  8
.text$mn:00004AFC
.text$mn:00004AFC                 push    ebp
.text$mn:00004AFD                 mov     ebp, esp
.text$mn:00004AFF                 sub     esp, 8
.text$mn:00004B02                 mov     [ebp+var_8], ecx
.text$mn:00004B05                 xor     eax, eax
.text$mn:00004B07                 mov     [ebp+var_2], ax
.text$mn:00004B0B                 mov     ecx, [ebp+var_8]
.text$mn:00004B0E                 mov     edx, [ebp+arg_0]
.text$mn:00004B11                 mov     [ecx+14h], edx
.text$mn:00004B14                 lea     eax, [ebp+var_2]
.text$mn:00004B17                 push    eax
.text$mn:00004B18                 mov     ecx, [ebp+var_8]
.text$mn:00004B1B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004B20                 mov     ecx, [ebp+arg_0]
.text$mn:00004B23                 lea     edx, [eax+ecx*2]
.text$mn:00004B26                 push    edx
.text$mn:00004B27                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:00004B2C                 add     esp, 8
.text$mn:00004B2F                 mov     esp, ebp
.text$mn:00004B31                 pop     ebp
.text$mn:00004B32                 retn    4
.text$mn:00004B32 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:00004B32
.text$mn:00004B32 ; ---------------------------------------------------------------------------
.text$mn:00004B35                 align 4
.text$mn:00004B35 _text$mn        ends
.text$mn:00004B35
.text$mn:00004B38 ; ===========================================================================
.text$mn:00004B38
.text$mn:00004B38 ; Segment type: Pure code
.text$mn:00004B38 ; Segment permissions: Read/Execute
.text$mn:00004B38 _text$mn        segment para public 'CODE' use32
.text$mn:00004B38                 assume cs:_text$mn
.text$mn:00004B38                 ;org 4B38h
.text$mn:00004B38 ; COMDAT (pick any)
.text$mn:00004B38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B38
.text$mn:00004B38 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B38
.text$mn:00004B38 ; Attributes: bp-based frame
.text$mn:00004B38
.text$mn:00004B38 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00004B38                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00004B38 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00004B38                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00004B38
.text$mn:00004B38 var_8           = dword ptr -8
.text$mn:00004B38 var_1           = byte ptr -1
.text$mn:00004B38
.text$mn:00004B38                 push    ebp
.text$mn:00004B39                 mov     ebp, esp
.text$mn:00004B3B                 sub     esp, 8
.text$mn:00004B3E                 mov     [ebp+var_8], ecx
.text$mn:00004B41                 lea     ecx, [ebp+var_1]
.text$mn:00004B44                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00004B49                 mov     ecx, [ebp+var_8] ; this
.text$mn:00004B4C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00004B51                 mov     eax, [ebp+var_8]
.text$mn:00004B54                 mov     ecx, [eax]
.text$mn:00004B56                 push    ecx
.text$mn:00004B57                 lea     ecx, [ebp+var_1]
.text$mn:00004B5A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00004B5F                 push    1               ; int
.text$mn:00004B61                 mov     edx, [ebp+var_8]
.text$mn:00004B64                 mov     eax, [edx]
.text$mn:00004B66                 push    eax             ; void *
.text$mn:00004B67                 lea     ecx, [ebp+var_1]
.text$mn:00004B6A                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00004B6F                 mov     ecx, [ebp+var_8]
.text$mn:00004B72                 mov     dword ptr [ecx], 0
.text$mn:00004B78                 mov     esp, ebp
.text$mn:00004B7A                 pop     ebp
.text$mn:00004B7B                 retn
.text$mn:00004B7B ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00004B7B
.text$mn:00004B7B _text$mn        ends
.text$mn:00004B7B
.text$mn:00004B7C ; ===========================================================================
.text$mn:00004B7C
.text$mn:00004B7C ; Segment type: Pure code
.text$mn:00004B7C ; Segment permissions: Read/Execute
.text$mn:00004B7C _text$mn        segment para public 'CODE' use32
.text$mn:00004B7C                 assume cs:_text$mn
.text$mn:00004B7C                 ;org 4B7Ch
.text$mn:00004B7C ; COMDAT (pick any)
.text$mn:00004B7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B7C
.text$mn:00004B7C ; =============== S U B R O U T I N E =======================================
.text$mn:00004B7C
.text$mn:00004B7C ; Attributes: bp-based frame
.text$mn:00004B7C
.text$mn:00004B7C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00004B7C                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00004B7C ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00004B7C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:00004B7C
.text$mn:00004B7C var_8           = dword ptr -8
.text$mn:00004B7C var_1           = byte ptr -1
.text$mn:00004B7C
.text$mn:00004B7C                 push    ebp
.text$mn:00004B7D                 mov     ebp, esp
.text$mn:00004B7F                 sub     esp, 8
.text$mn:00004B82                 mov     [ebp+var_8], ecx
.text$mn:00004B85                 lea     ecx, [ebp+var_1]
.text$mn:00004B88                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00004B8D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00004B90                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00004B95                 mov     eax, [ebp+var_8]
.text$mn:00004B98                 mov     ecx, [eax]
.text$mn:00004B9A                 push    ecx
.text$mn:00004B9B                 lea     ecx, [ebp+var_1]
.text$mn:00004B9E                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00004BA3                 push    1               ; int
.text$mn:00004BA5                 mov     edx, [ebp+var_8]
.text$mn:00004BA8                 mov     eax, [edx]
.text$mn:00004BAA                 push    eax             ; void *
.text$mn:00004BAB                 lea     ecx, [ebp+var_1]
.text$mn:00004BAE                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00004BB3                 mov     ecx, [ebp+var_8]
.text$mn:00004BB6                 mov     dword ptr [ecx], 0
.text$mn:00004BBC                 mov     esp, ebp
.text$mn:00004BBE                 pop     ebp
.text$mn:00004BBF                 retn
.text$mn:00004BBF ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00004BBF
.text$mn:00004BBF _text$mn        ends
.text$mn:00004BBF
.text$mn:00004BC0 ; ===========================================================================
.text$mn:00004BC0
.text$mn:00004BC0 ; Segment type: Pure code
.text$mn:00004BC0 ; Segment permissions: Read/Execute
.text$mn:00004BC0 _text$mn        segment para public 'CODE' use32
.text$mn:00004BC0                 assume cs:_text$mn
.text$mn:00004BC0                 ;org 4BC0h
.text$mn:00004BC0 ; COMDAT (pick any)
.text$mn:00004BC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BC0
.text$mn:00004BC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BC0
.text$mn:00004BC0 ; Attributes: bp-based frame
.text$mn:00004BC0
.text$mn:00004BC0 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct TreeStateNode, class std::allocator<struct TreeStateNode>>>::_Free_proxy(void)
.text$mn:00004BC0                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAEXXZ
.text$mn:00004BC0 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00004BC0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::~_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>(void)+30p
.text$mn:00004BC0
.text$mn:00004BC0 var_8           = dword ptr -8
.text$mn:00004BC0 var_1           = byte ptr -1
.text$mn:00004BC0
.text$mn:00004BC0                 push    ebp
.text$mn:00004BC1                 mov     ebp, esp
.text$mn:00004BC3                 sub     esp, 8
.text$mn:00004BC6                 mov     [ebp+var_8], ecx
.text$mn:00004BC9                 lea     ecx, [ebp+var_1]
.text$mn:00004BCC                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00004BD1                 mov     ecx, [ebp+var_8] ; this
.text$mn:00004BD4                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00004BD9                 mov     eax, [ebp+var_8]
.text$mn:00004BDC                 mov     ecx, [eax]
.text$mn:00004BDE                 push    ecx
.text$mn:00004BDF                 lea     ecx, [ebp+var_1]
.text$mn:00004BE2                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00004BE7                 push    1               ; int
.text$mn:00004BE9                 mov     edx, [ebp+var_8]
.text$mn:00004BEC                 mov     eax, [edx]
.text$mn:00004BEE                 push    eax             ; void *
.text$mn:00004BEF                 lea     ecx, [ebp+var_1]
.text$mn:00004BF2                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00004BF7                 mov     ecx, [ebp+var_8]
.text$mn:00004BFA                 mov     dword ptr [ecx], 0
.text$mn:00004C00                 mov     esp, ebp
.text$mn:00004C02                 pop     ebp
.text$mn:00004C03                 retn
.text$mn:00004C03 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00004C03
.text$mn:00004C03 _text$mn        ends
.text$mn:00004C03
.text$mn:00004C04 ; ===========================================================================
.text$mn:00004C04
.text$mn:00004C04 ; Segment type: Pure code
.text$mn:00004C04 ; Segment permissions: Read/Execute
.text$mn:00004C04 _text$mn        segment para public 'CODE' use32
.text$mn:00004C04                 assume cs:_text$mn
.text$mn:00004C04                 ;org 4C04h
.text$mn:00004C04 ; COMDAT (pick any)
.text$mn:00004C04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C04
.text$mn:00004C04 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C04
.text$mn:00004C04 ; Attributes: bp-based frame
.text$mn:00004C04
.text$mn:00004C04 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00004C04                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00004C04 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00004C04                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00004C04                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00004C04
.text$mn:00004C04 var_4           = dword ptr -4
.text$mn:00004C04 arg_0           = dword ptr  8
.text$mn:00004C04
.text$mn:00004C04                 push    ebp
.text$mn:00004C05                 mov     ebp, esp
.text$mn:00004C07                 push    ecx
.text$mn:00004C08                 mov     [ebp+var_4], ecx
.text$mn:00004C0B                 mov     ecx, [ebp+arg_0]
.text$mn:00004C0E                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00004C13                 mov     eax, [ebp+arg_0]
.text$mn:00004C16                 mov     esp, ebp
.text$mn:00004C18                 pop     ebp
.text$mn:00004C19                 retn    4
.text$mn:00004C19 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00004C19
.text$mn:00004C19 _text$mn        ends
.text$mn:00004C19
.text$mn:00004C1C ; ===========================================================================
.text$mn:00004C1C
.text$mn:00004C1C ; Segment type: Pure code
.text$mn:00004C1C ; Segment permissions: Read/Execute
.text$mn:00004C1C _text$mn        segment para public 'CODE' use32
.text$mn:00004C1C                 assume cs:_text$mn
.text$mn:00004C1C                 ;org 4C1Ch
.text$mn:00004C1C ; COMDAT (pick any)
.text$mn:00004C1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C1C
.text$mn:00004C1C ; =============== S U B R O U T I N E =======================================
.text$mn:00004C1C
.text$mn:00004C1C ; Attributes: bp-based frame
.text$mn:00004C1C
.text$mn:00004C1C ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:00004C1C                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:00004C1C ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:00004C1C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+33p
.text$mn:00004C1C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+18p ...
.text$mn:00004C1C
.text$mn:00004C1C var_4           = dword ptr -4
.text$mn:00004C1C arg_0           = dword ptr  8
.text$mn:00004C1C
.text$mn:00004C1C                 push    ebp
.text$mn:00004C1D                 mov     ebp, esp
.text$mn:00004C1F                 push    ecx
.text$mn:00004C20                 mov     [ebp+var_4], ecx
.text$mn:00004C23                 mov     ecx, [ebp+arg_0]
.text$mn:00004C26                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:00004C2B                 mov     eax, [ebp+arg_0]
.text$mn:00004C2E                 mov     esp, ebp
.text$mn:00004C30                 pop     ebp
.text$mn:00004C31                 retn    4
.text$mn:00004C31 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00004C31
.text$mn:00004C31 _text$mn        ends
.text$mn:00004C31
.text$mn:00004C34 ; ===========================================================================
.text$mn:00004C34
.text$mn:00004C34 ; Segment type: Pure code
.text$mn:00004C34 ; Segment permissions: Read/Execute
.text$mn:00004C34 _text$mn        segment para public 'CODE' use32
.text$mn:00004C34                 assume cs:_text$mn
.text$mn:00004C34                 ;org 4C34h
.text$mn:00004C34 ; COMDAT (pick any)
.text$mn:00004C34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C34
.text$mn:00004C34 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C34
.text$mn:00004C34 ; Attributes: bp-based frame
.text$mn:00004C34
.text$mn:00004C34 ; public: struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct TreeStateNode, class std::allocator<struct TreeStateNode>>>::_Getal(void)const
.text$mn:00004C34                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@XZ
.text$mn:00004C34 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@XZ proc near
.text$mn:00004C34                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>,TreeStateNode *)+36p
.text$mn:00004C34                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Umove<TreeStateNode *>(TreeStateNode *,TreeStateNode *,TreeStateNode *)+10p ...
.text$mn:00004C34
.text$mn:00004C34 var_4           = dword ptr -4
.text$mn:00004C34 arg_0           = dword ptr  8
.text$mn:00004C34
.text$mn:00004C34                 push    ebp
.text$mn:00004C35                 mov     ebp, esp
.text$mn:00004C37                 push    ecx
.text$mn:00004C38                 mov     [ebp+var_4], ecx
.text$mn:00004C3B                 mov     ecx, [ebp+arg_0]
.text$mn:00004C3E                 call    ??0?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::_Wrap_alloc<std::allocator<TreeStateNode>>(void)
.text$mn:00004C43                 mov     eax, [ebp+arg_0]
.text$mn:00004C46                 mov     esp, ebp
.text$mn:00004C48                 pop     ebp
.text$mn:00004C49                 retn    4
.text$mn:00004C49 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@XZ endp
.text$mn:00004C49
.text$mn:00004C49 _text$mn        ends
.text$mn:00004C49
.text$mn:00004C4C ; ===========================================================================
.text$mn:00004C4C
.text$mn:00004C4C ; Segment type: Pure code
.text$mn:00004C4C ; Segment permissions: Read/Execute
.text$mn:00004C4C _text$mn        segment para public 'CODE' use32
.text$mn:00004C4C                 assume cs:_text$mn
.text$mn:00004C4C                 ;org 4C4Ch
.text$mn:00004C4C ; COMDAT (pick any)
.text$mn:00004C4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C4C
.text$mn:00004C4C ; =============== S U B R O U T I N E =======================================
.text$mn:00004C4C
.text$mn:00004C4C ; Attributes: bp-based frame
.text$mn:00004C4C
.text$mn:00004C4C ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:00004C4C                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:00004C4C ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:00004C4C                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Orphan_range(TreeStateNode *,TreeStateNode *)+3Cp
.text$mn:00004C4C
.text$mn:00004C4C var_8           = dword ptr -8
.text$mn:00004C4C var_4           = dword ptr -4
.text$mn:00004C4C
.text$mn:00004C4C                 push    ebp
.text$mn:00004C4D                 mov     ebp, esp
.text$mn:00004C4F                 sub     esp, 8
.text$mn:00004C52                 mov     [ebp+var_4], ecx
.text$mn:00004C55                 mov     eax, [ebp+var_4]
.text$mn:00004C58                 cmp     dword ptr [eax], 0
.text$mn:00004C5B                 jnz     short loc_4C66
.text$mn:00004C5D                 mov     [ebp+var_8], 0
.text$mn:00004C64                 jmp     short loc_4C71
.text$mn:00004C66 ; ---------------------------------------------------------------------------
.text$mn:00004C66
.text$mn:00004C66 loc_4C66:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:00004C66                 mov     ecx, [ebp+var_4]
.text$mn:00004C69                 mov     edx, [ecx]
.text$mn:00004C6B                 add     edx, 4
.text$mn:00004C6E                 mov     [ebp+var_8], edx
.text$mn:00004C71
.text$mn:00004C71 loc_4C71:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:00004C71                 mov     eax, [ebp+var_8]
.text$mn:00004C74                 mov     esp, ebp
.text$mn:00004C76                 pop     ebp
.text$mn:00004C77                 retn
.text$mn:00004C77 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:00004C77
.text$mn:00004C77 _text$mn        ends
.text$mn:00004C77
.text$mn:00004C78 ; ===========================================================================
.text$mn:00004C78
.text$mn:00004C78 ; Segment type: Pure code
.text$mn:00004C78 ; Segment permissions: Read/Execute
.text$mn:00004C78 _text$mn        segment para public 'CODE' use32
.text$mn:00004C78                 assume cs:_text$mn
.text$mn:00004C78                 ;org 4C78h
.text$mn:00004C78 ; COMDAT (pick any)
.text$mn:00004C78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C78
.text$mn:00004C78 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C78
.text$mn:00004C78 ; Attributes: bp-based frame
.text$mn:00004C78
.text$mn:00004C78 ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:00004C78                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:00004C78 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:00004C78                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Orphan_range(TreeStateNode *,TreeStateNode *)+71p
.text$mn:00004C78                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Orphan_range(TreeStateNode *,TreeStateNode *)+8Ap
.text$mn:00004C78
.text$mn:00004C78 var_4           = dword ptr -4
.text$mn:00004C78
.text$mn:00004C78                 push    ebp
.text$mn:00004C79                 mov     ebp, esp
.text$mn:00004C7B                 push    ecx
.text$mn:00004C7C                 mov     [ebp+var_4], ecx
.text$mn:00004C7F                 mov     eax, [ebp+var_4]
.text$mn:00004C82                 add     eax, 4
.text$mn:00004C85                 mov     esp, ebp
.text$mn:00004C87                 pop     ebp
.text$mn:00004C88                 retn
.text$mn:00004C88 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:00004C88
.text$mn:00004C88 ; ---------------------------------------------------------------------------
.text$mn:00004C89                 align 4
.text$mn:00004C89 _text$mn        ends
.text$mn:00004C89
.text$mn:00004C8C ; ===========================================================================
.text$mn:00004C8C
.text$mn:00004C8C ; Segment type: Pure code
.text$mn:00004C8C ; Segment permissions: Read/Execute
.text$mn:00004C8C _text$mn        segment para public 'CODE' use32
.text$mn:00004C8C                 assume cs:_text$mn
.text$mn:00004C8C                 ;org 4C8Ch
.text$mn:00004C8C ; COMDAT (pick any)
.text$mn:00004C8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C8C
.text$mn:00004C8C ; =============== S U B R O U T I N E =======================================
.text$mn:00004C8C
.text$mn:00004C8C ; Attributes: bp-based frame
.text$mn:00004C8C
.text$mn:00004C8C ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00004C8C                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00004C8C ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00004C8C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00004C8C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00004C8C
.text$mn:00004C8C var_C           = dword ptr -0Ch
.text$mn:00004C8C Size            = dword ptr -8
.text$mn:00004C8C var_4           = dword ptr -4
.text$mn:00004C8C arg_0           = dword ptr  8
.text$mn:00004C8C arg_4           = byte ptr  0Ch
.text$mn:00004C8C
.text$mn:00004C8C                 push    ebp
.text$mn:00004C8D                 mov     ebp, esp
.text$mn:00004C8F                 sub     esp, 0Ch
.text$mn:00004C92                 mov     [ebp+var_4], ecx
.text$mn:00004C95                 mov     ecx, [ebp+var_4]
.text$mn:00004C98                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00004C9D                 cmp     eax, [ebp+arg_0]
.text$mn:00004CA0                 jnb     short loc_4CAA
.text$mn:00004CA2                 mov     ecx, [ebp+var_4]
.text$mn:00004CA5                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00004CAA
.text$mn:00004CAA loc_4CAA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00004CAA                 mov     eax, [ebp+var_4]
.text$mn:00004CAD                 mov     ecx, [eax+18h]
.text$mn:00004CB0                 cmp     ecx, [ebp+arg_0]
.text$mn:00004CB3                 jnb     short loc_4CCA
.text$mn:00004CB5                 mov     edx, [ebp+var_4]
.text$mn:00004CB8                 mov     eax, [edx+14h]
.text$mn:00004CBB                 push    eax
.text$mn:00004CBC                 mov     ecx, [ebp+arg_0]
.text$mn:00004CBF                 push    ecx
.text$mn:00004CC0                 mov     ecx, [ebp+var_4]
.text$mn:00004CC3                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00004CC8                 jmp     short loc_4D14
.text$mn:00004CCA ; ---------------------------------------------------------------------------
.text$mn:00004CCA
.text$mn:00004CCA loc_4CCA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00004CCA                 movzx   edx, [ebp+arg_4]
.text$mn:00004CCE                 test    edx, edx
.text$mn:00004CD0                 jz      short loc_4D04
.text$mn:00004CD2                 cmp     [ebp+arg_0], 10h
.text$mn:00004CD6                 jnb     short loc_4D04
.text$mn:00004CD8                 mov     eax, [ebp+var_4]
.text$mn:00004CDB                 mov     ecx, [ebp+arg_0]
.text$mn:00004CDE                 cmp     ecx, [eax+14h]
.text$mn:00004CE1                 jnb     short loc_4CEB
.text$mn:00004CE3                 mov     edx, [ebp+arg_0]
.text$mn:00004CE6                 mov     [ebp+Size], edx
.text$mn:00004CE9                 jmp     short loc_4CF4
.text$mn:00004CEB ; ---------------------------------------------------------------------------
.text$mn:00004CEB
.text$mn:00004CEB loc_4CEB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00004CEB                 mov     eax, [ebp+var_4]
.text$mn:00004CEE                 mov     ecx, [eax+14h]
.text$mn:00004CF1                 mov     [ebp+Size], ecx
.text$mn:00004CF4
.text$mn:00004CF4 loc_4CF4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00004CF4                 mov     edx, [ebp+Size]
.text$mn:00004CF7                 push    edx             ; Size
.text$mn:00004CF8                 push    1               ; char
.text$mn:00004CFA                 mov     ecx, [ebp+var_4]
.text$mn:00004CFD                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00004D02                 jmp     short loc_4D14
.text$mn:00004D04 ; ---------------------------------------------------------------------------
.text$mn:00004D04
.text$mn:00004D04 loc_4D04:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00004D04                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00004D04                 cmp     [ebp+arg_0], 0
.text$mn:00004D08                 jnz     short loc_4D14
.text$mn:00004D0A                 push    0
.text$mn:00004D0C                 mov     ecx, [ebp+var_4]
.text$mn:00004D0F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00004D14
.text$mn:00004D14 loc_4D14:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00004D14                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00004D14                 cmp     [ebp+arg_0], 0
.text$mn:00004D18                 jbe     short loc_4D23
.text$mn:00004D1A                 mov     [ebp+var_C], 1
.text$mn:00004D21                 jmp     short loc_4D2A
.text$mn:00004D23 ; ---------------------------------------------------------------------------
.text$mn:00004D23
.text$mn:00004D23 loc_4D23:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00004D23                 mov     [ebp+var_C], 0
.text$mn:00004D2A
.text$mn:00004D2A loc_4D2A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00004D2A                 mov     al, byte ptr [ebp+var_C]
.text$mn:00004D2D                 mov     esp, ebp
.text$mn:00004D2F                 pop     ebp
.text$mn:00004D30                 retn    8
.text$mn:00004D30 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00004D30
.text$mn:00004D30 ; ---------------------------------------------------------------------------
.text$mn:00004D33                 align 4
.text$mn:00004D33 _text$mn        ends
.text$mn:00004D33
.text$mn:00004D34 ; ===========================================================================
.text$mn:00004D34
.text$mn:00004D34 ; Segment type: Pure code
.text$mn:00004D34 ; Segment permissions: Read/Execute
.text$mn:00004D34 _text$mn        segment para public 'CODE' use32
.text$mn:00004D34                 assume cs:_text$mn
.text$mn:00004D34                 ;org 4D34h
.text$mn:00004D34 ; COMDAT (pick any)
.text$mn:00004D34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D34
.text$mn:00004D34 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D34
.text$mn:00004D34 ; Attributes: bp-based frame
.text$mn:00004D34
.text$mn:00004D34 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:00004D34                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:00004D34 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:00004D34                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Ap
.text$mn:00004D34                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+61p
.text$mn:00004D34
.text$mn:00004D34 var_C           = dword ptr -0Ch
.text$mn:00004D34 var_8           = dword ptr -8
.text$mn:00004D34 var_4           = dword ptr -4
.text$mn:00004D34 arg_0           = dword ptr  8
.text$mn:00004D34 arg_4           = byte ptr  0Ch
.text$mn:00004D34
.text$mn:00004D34                 push    ebp
.text$mn:00004D35                 mov     ebp, esp
.text$mn:00004D37                 sub     esp, 0Ch
.text$mn:00004D3A                 mov     [ebp+var_4], ecx
.text$mn:00004D3D                 mov     ecx, [ebp+var_4]
.text$mn:00004D40                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00004D45                 cmp     eax, [ebp+arg_0]
.text$mn:00004D48                 jnb     short loc_4D52
.text$mn:00004D4A                 mov     ecx, [ebp+var_4]
.text$mn:00004D4D                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00004D52
.text$mn:00004D52 loc_4D52:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:00004D52                 mov     eax, [ebp+var_4]
.text$mn:00004D55                 mov     ecx, [eax+18h]
.text$mn:00004D58                 cmp     ecx, [ebp+arg_0]
.text$mn:00004D5B                 jnb     short loc_4D72
.text$mn:00004D5D                 mov     edx, [ebp+var_4]
.text$mn:00004D60                 mov     eax, [edx+14h]
.text$mn:00004D63                 push    eax
.text$mn:00004D64                 mov     ecx, [ebp+arg_0]
.text$mn:00004D67                 push    ecx
.text$mn:00004D68                 mov     ecx, [ebp+var_4]
.text$mn:00004D6B                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:00004D70                 jmp     short loc_4DBC
.text$mn:00004D72 ; ---------------------------------------------------------------------------
.text$mn:00004D72
.text$mn:00004D72 loc_4D72:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:00004D72                 movzx   edx, [ebp+arg_4]
.text$mn:00004D76                 test    edx, edx
.text$mn:00004D78                 jz      short loc_4DAC
.text$mn:00004D7A                 cmp     [ebp+arg_0], 8
.text$mn:00004D7E                 jnb     short loc_4DAC
.text$mn:00004D80                 mov     eax, [ebp+var_4]
.text$mn:00004D83                 mov     ecx, [ebp+arg_0]
.text$mn:00004D86                 cmp     ecx, [eax+14h]
.text$mn:00004D89                 jnb     short loc_4D93
.text$mn:00004D8B                 mov     edx, [ebp+arg_0]
.text$mn:00004D8E                 mov     [ebp+var_8], edx
.text$mn:00004D91                 jmp     short loc_4D9C
.text$mn:00004D93 ; ---------------------------------------------------------------------------
.text$mn:00004D93
.text$mn:00004D93 loc_4D93:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:00004D93                 mov     eax, [ebp+var_4]
.text$mn:00004D96                 mov     ecx, [eax+14h]
.text$mn:00004D99                 mov     [ebp+var_8], ecx
.text$mn:00004D9C
.text$mn:00004D9C loc_4D9C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:00004D9C                 mov     edx, [ebp+var_8]
.text$mn:00004D9F                 push    edx
.text$mn:00004DA0                 push    1
.text$mn:00004DA2                 mov     ecx, [ebp+var_4]
.text$mn:00004DA5                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00004DAA                 jmp     short loc_4DBC
.text$mn:00004DAC ; ---------------------------------------------------------------------------
.text$mn:00004DAC
.text$mn:00004DAC loc_4DAC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:00004DAC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:00004DAC                 cmp     [ebp+arg_0], 0
.text$mn:00004DB0                 jnz     short loc_4DBC
.text$mn:00004DB2                 push    0
.text$mn:00004DB4                 mov     ecx, [ebp+var_4]
.text$mn:00004DB7                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00004DBC
.text$mn:00004DBC loc_4DBC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:00004DBC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:00004DBC                 cmp     [ebp+arg_0], 0
.text$mn:00004DC0                 jbe     short loc_4DCB
.text$mn:00004DC2                 mov     [ebp+var_C], 1
.text$mn:00004DC9                 jmp     short loc_4DD2
.text$mn:00004DCB ; ---------------------------------------------------------------------------
.text$mn:00004DCB
.text$mn:00004DCB loc_4DCB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:00004DCB                 mov     [ebp+var_C], 0
.text$mn:00004DD2
.text$mn:00004DD2 loc_4DD2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:00004DD2                 mov     al, byte ptr [ebp+var_C]
.text$mn:00004DD5                 mov     esp, ebp
.text$mn:00004DD7                 pop     ebp
.text$mn:00004DD8                 retn    8
.text$mn:00004DD8 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:00004DD8
.text$mn:00004DD8 ; ---------------------------------------------------------------------------
.text$mn:00004DDB                 align 4
.text$mn:00004DDB _text$mn        ends
.text$mn:00004DDB
.text$mn:00004DDC ; ===========================================================================
.text$mn:00004DDC
.text$mn:00004DDC ; Segment type: Pure code
.text$mn:00004DDC ; Segment permissions: Read/Execute
.text$mn:00004DDC _text$mn        segment para public 'CODE' use32
.text$mn:00004DDC                 assume cs:_text$mn
.text$mn:00004DDC                 ;org 4DDCh
.text$mn:00004DDC ; COMDAT (pick any)
.text$mn:00004DDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004DDC
.text$mn:00004DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00004DDC
.text$mn:00004DDC ; Attributes: bp-based frame
.text$mn:00004DDC
.text$mn:00004DDC ; protected: unsigned int __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::_Grow_to(unsigned int)const
.text$mn:00004DDC                 public ?_Grow_to@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEII@Z
.text$mn:00004DDC ?_Grow_to@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEII@Z proc near
.text$mn:00004DDC                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reserve(uint)+45p
.text$mn:00004DDC
.text$mn:00004DDC var_C           = dword ptr -0Ch
.text$mn:00004DDC var_8           = dword ptr -8
.text$mn:00004DDC var_4           = dword ptr -4
.text$mn:00004DDC arg_0           = dword ptr  8
.text$mn:00004DDC
.text$mn:00004DDC                 push    ebp
.text$mn:00004DDD                 mov     ebp, esp
.text$mn:00004DDF                 sub     esp, 0Ch
.text$mn:00004DE2                 mov     [ebp+var_8], ecx
.text$mn:00004DE5                 mov     ecx, [ebp+var_8]
.text$mn:00004DE8                 call    ?capacity@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::capacity(void)
.text$mn:00004DED                 mov     [ebp+var_4], eax
.text$mn:00004DF0                 mov     ecx, [ebp+var_8]
.text$mn:00004DF3                 call    ?max_size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::max_size(void)
.text$mn:00004DF8                 mov     ecx, [ebp+var_4]
.text$mn:00004DFB                 shr     ecx, 1
.text$mn:00004DFD                 sub     eax, ecx
.text$mn:00004DFF                 cmp     eax, [ebp+var_4]
.text$mn:00004E02                 jnb     short loc_4E0D
.text$mn:00004E04                 mov     [ebp+var_C], 0
.text$mn:00004E0B                 jmp     short loc_4E18
.text$mn:00004E0D ; ---------------------------------------------------------------------------
.text$mn:00004E0D
.text$mn:00004E0D loc_4E0D:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Grow_to(uint)+26j
.text$mn:00004E0D                 mov     edx, [ebp+var_4]
.text$mn:00004E10                 shr     edx, 1
.text$mn:00004E12                 add     edx, [ebp+var_4]
.text$mn:00004E15                 mov     [ebp+var_C], edx
.text$mn:00004E18
.text$mn:00004E18 loc_4E18:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Grow_to(uint)+2Fj
.text$mn:00004E18                 mov     eax, [ebp+var_C]
.text$mn:00004E1B                 mov     [ebp+var_4], eax
.text$mn:00004E1E                 mov     ecx, [ebp+var_4]
.text$mn:00004E21                 cmp     ecx, [ebp+arg_0]
.text$mn:00004E24                 jnb     short loc_4E2C
.text$mn:00004E26                 mov     edx, [ebp+arg_0]
.text$mn:00004E29                 mov     [ebp+var_4], edx
.text$mn:00004E2C
.text$mn:00004E2C loc_4E2C:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Grow_to(uint)+48j
.text$mn:00004E2C                 mov     eax, [ebp+var_4]
.text$mn:00004E2F                 mov     esp, ebp
.text$mn:00004E31                 pop     ebp
.text$mn:00004E32                 retn    4
.text$mn:00004E32 ?_Grow_to@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEII@Z endp
.text$mn:00004E32
.text$mn:00004E32 ; ---------------------------------------------------------------------------
.text$mn:00004E35                 align 4
.text$mn:00004E35 _text$mn        ends
.text$mn:00004E35
.text$mn:00004E38 ; ===========================================================================
.text$mn:00004E38
.text$mn:00004E38 ; Segment type: Pure code
.text$mn:00004E38 ; Segment permissions: Read/Execute
.text$mn:00004E38 _text$mn        segment para public 'CODE' use32
.text$mn:00004E38                 assume cs:_text$mn
.text$mn:00004E38                 ;org 4E38h
.text$mn:00004E38 ; COMDAT (pick any)
.text$mn:00004E38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E38
.text$mn:00004E38 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E38
.text$mn:00004E38 ; Attributes: bp-based frame
.text$mn:00004E38
.text$mn:00004E38 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00004E38                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00004E38 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00004E38                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00004E38
.text$mn:00004E38 var_4           = dword ptr -4
.text$mn:00004E38 arg_0           = dword ptr  8
.text$mn:00004E38
.text$mn:00004E38                 push    ebp
.text$mn:00004E39                 mov     ebp, esp
.text$mn:00004E3B                 push    ecx
.text$mn:00004E3C                 mov     [ebp+var_4], ecx
.text$mn:00004E3F                 cmp     [ebp+arg_0], 0
.text$mn:00004E43                 jz      short loc_4E65
.text$mn:00004E45                 mov     ecx, [ebp+var_4]
.text$mn:00004E48                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004E4D                 cmp     [ebp+arg_0], eax
.text$mn:00004E50                 jb      short loc_4E65
.text$mn:00004E52                 mov     ecx, [ebp+var_4]
.text$mn:00004E55                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004E5A                 mov     ecx, [ebp+var_4]
.text$mn:00004E5D                 add     eax, [ecx+14h]
.text$mn:00004E60                 cmp     eax, [ebp+arg_0]
.text$mn:00004E63                 ja      short loc_4E6B
.text$mn:00004E65
.text$mn:00004E65 loc_4E65:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00004E65                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00004E65                 xor     al, al
.text$mn:00004E67                 jmp     short loc_4E6D
.text$mn:00004E69 ; ---------------------------------------------------------------------------
.text$mn:00004E69                 jmp     short loc_4E6D
.text$mn:00004E6B ; ---------------------------------------------------------------------------
.text$mn:00004E6B
.text$mn:00004E6B loc_4E6B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00004E6B                 mov     al, 1
.text$mn:00004E6D
.text$mn:00004E6D loc_4E6D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00004E6D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00004E6D                 mov     esp, ebp
.text$mn:00004E6F                 pop     ebp
.text$mn:00004E70                 retn    4
.text$mn:00004E70 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00004E70
.text$mn:00004E70 ; ---------------------------------------------------------------------------
.text$mn:00004E73                 align 4
.text$mn:00004E73 _text$mn        ends
.text$mn:00004E73
.text$mn:00004E74 ; ===========================================================================
.text$mn:00004E74
.text$mn:00004E74 ; Segment type: Pure code
.text$mn:00004E74 ; Segment permissions: Read/Execute
.text$mn:00004E74 _text$mn        segment para public 'CODE' use32
.text$mn:00004E74                 assume cs:_text$mn
.text$mn:00004E74                 ;org 4E74h
.text$mn:00004E74 ; COMDAT (pick any)
.text$mn:00004E74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E74
.text$mn:00004E74 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E74
.text$mn:00004E74 ; Attributes: bp-based frame
.text$mn:00004E74
.text$mn:00004E74 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00004E74                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:00004E74 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:00004E74                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap
.text$mn:00004E74
.text$mn:00004E74 var_4           = dword ptr -4
.text$mn:00004E74 arg_0           = dword ptr  8
.text$mn:00004E74
.text$mn:00004E74                 push    ebp
.text$mn:00004E75                 mov     ebp, esp
.text$mn:00004E77                 push    ecx
.text$mn:00004E78                 mov     [ebp+var_4], ecx
.text$mn:00004E7B                 cmp     [ebp+arg_0], 0
.text$mn:00004E7F                 jz      short loc_4EA4
.text$mn:00004E81                 mov     ecx, [ebp+var_4]
.text$mn:00004E84                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004E89                 cmp     [ebp+arg_0], eax
.text$mn:00004E8C                 jb      short loc_4EA4
.text$mn:00004E8E                 mov     ecx, [ebp+var_4]
.text$mn:00004E91                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004E96                 mov     ecx, [ebp+var_4]
.text$mn:00004E99                 mov     edx, [ecx+14h]
.text$mn:00004E9C                 lea     eax, [eax+edx*2]
.text$mn:00004E9F                 cmp     eax, [ebp+arg_0]
.text$mn:00004EA2                 ja      short loc_4EAA
.text$mn:00004EA4
.text$mn:00004EA4 loc_4EA4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:00004EA4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:00004EA4                 xor     al, al
.text$mn:00004EA6                 jmp     short loc_4EAC
.text$mn:00004EA8 ; ---------------------------------------------------------------------------
.text$mn:00004EA8                 jmp     short loc_4EAC
.text$mn:00004EAA ; ---------------------------------------------------------------------------
.text$mn:00004EAA
.text$mn:00004EAA loc_4EAA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:00004EAA                 mov     al, 1
.text$mn:00004EAC
.text$mn:00004EAC loc_4EAC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:00004EAC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:00004EAC                 mov     esp, ebp
.text$mn:00004EAE                 pop     ebp
.text$mn:00004EAF                 retn    4
.text$mn:00004EAF ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:00004EAF
.text$mn:00004EAF ; ---------------------------------------------------------------------------
.text$mn:00004EB2                 align 4
.text$mn:00004EB2 _text$mn        ends
.text$mn:00004EB2
.text$mn:00004EB4 ; ===========================================================================
.text$mn:00004EB4
.text$mn:00004EB4 ; Segment type: Pure code
.text$mn:00004EB4 ; Segment permissions: Read/Execute
.text$mn:00004EB4 _text$mn        segment para public 'CODE' use32
.text$mn:00004EB4                 assume cs:_text$mn
.text$mn:00004EB4                 ;org 4EB4h
.text$mn:00004EB4 ; COMDAT (pick any)
.text$mn:00004EB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004EB4
.text$mn:00004EB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004EB4
.text$mn:00004EB4 ; Attributes: bp-based frame
.text$mn:00004EB4
.text$mn:00004EB4 ; protected: bool __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::_Inside(struct TreeStateNode const *)const
.text$mn:00004EB4                 public ?_Inside@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBE_NPBUTreeStateNode@@@Z
.text$mn:00004EB4 ?_Inside@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBE_NPBUTreeStateNode@@@Z proc near
.text$mn:00004EB4                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::push_back(TreeStateNode &&)+19p
.text$mn:00004EB4
.text$mn:00004EB4 var_8           = dword ptr -8
.text$mn:00004EB4 var_4           = dword ptr -4
.text$mn:00004EB4 arg_0           = dword ptr  8
.text$mn:00004EB4
.text$mn:00004EB4                 push    ebp
.text$mn:00004EB5                 mov     ebp, esp
.text$mn:00004EB7                 sub     esp, 8
.text$mn:00004EBA                 mov     [ebp+var_4], ecx
.text$mn:00004EBD                 mov     eax, [ebp+var_4]
.text$mn:00004EC0                 mov     ecx, [ebp+arg_0]
.text$mn:00004EC3                 cmp     ecx, [eax+8]
.text$mn:00004EC6                 jnb     short loc_4EDC
.text$mn:00004EC8                 mov     edx, [ebp+var_4]
.text$mn:00004ECB                 mov     eax, [edx+4]
.text$mn:00004ECE                 cmp     eax, [ebp+arg_0]
.text$mn:00004ED1                 ja      short loc_4EDC
.text$mn:00004ED3                 mov     [ebp+var_8], 1
.text$mn:00004EDA                 jmp     short loc_4EE3
.text$mn:00004EDC ; ---------------------------------------------------------------------------
.text$mn:00004EDC
.text$mn:00004EDC loc_4EDC:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Inside(TreeStateNode const *)+12j
.text$mn:00004EDC                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Inside(TreeStateNode const *)+1Dj
.text$mn:00004EDC                 mov     [ebp+var_8], 0
.text$mn:00004EE3
.text$mn:00004EE3 loc_4EE3:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Inside(TreeStateNode const *)+26j
.text$mn:00004EE3                 mov     al, byte ptr [ebp+var_8]
.text$mn:00004EE6                 mov     esp, ebp
.text$mn:00004EE8                 pop     ebp
.text$mn:00004EE9                 retn    4
.text$mn:00004EE9 ?_Inside@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBE_NPBUTreeStateNode@@@Z endp
.text$mn:00004EE9
.text$mn:00004EE9 _text$mn        ends
.text$mn:00004EE9
.text$mn:00004EEC ; ===========================================================================
.text$mn:00004EEC
.text$mn:00004EEC ; Segment type: Pure code
.text$mn:00004EEC ; Segment permissions: Read/Execute
.text$mn:00004EEC _text$mn        segment para public 'CODE' use32
.text$mn:00004EEC                 assume cs:_text$mn
.text$mn:00004EEC                 ;org 4EECh
.text$mn:00004EEC ; COMDAT (pick any)
.text$mn:00004EEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004EEC
.text$mn:00004EEC ; =============== S U B R O U T I N E =======================================
.text$mn:00004EEC
.text$mn:00004EEC ; Attributes: bp-based frame
.text$mn:00004EEC
.text$mn:00004EEC ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004EEC                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00004EEC ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00004EEC                                         ; CODE XREF: $LN19+14p
.text$mn:00004EEC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00004EEC
.text$mn:00004EEC var_8           = dword ptr -8
.text$mn:00004EEC var_4           = dword ptr -4
.text$mn:00004EEC
.text$mn:00004EEC                 push    ebp
.text$mn:00004EED                 mov     ebp, esp
.text$mn:00004EEF                 sub     esp, 8
.text$mn:00004EF2                 mov     [ebp+var_4], ecx
.text$mn:00004EF5                 mov     eax, [ebp+var_4]
.text$mn:00004EF8                 cmp     dword ptr [eax+18h], 10h
.text$mn:00004EFC                 jb      short loc_4F12
.text$mn:00004EFE                 mov     ecx, [ebp+var_4]
.text$mn:00004F01                 mov     edx, [ecx+4]
.text$mn:00004F04                 push    edx
.text$mn:00004F05                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00004F0A                 add     esp, 4
.text$mn:00004F0D                 mov     [ebp+var_8], eax
.text$mn:00004F10                 jmp     short loc_4F1B
.text$mn:00004F12 ; ---------------------------------------------------------------------------
.text$mn:00004F12
.text$mn:00004F12 loc_4F12:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00004F12                 mov     eax, [ebp+var_4]
.text$mn:00004F15                 add     eax, 4
.text$mn:00004F18                 mov     [ebp+var_8], eax
.text$mn:00004F1B
.text$mn:00004F1B loc_4F1B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00004F1B                 mov     eax, [ebp+var_8]
.text$mn:00004F1E                 mov     esp, ebp
.text$mn:00004F20                 pop     ebp
.text$mn:00004F21                 retn
.text$mn:00004F21 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00004F21
.text$mn:00004F21 ; ---------------------------------------------------------------------------
.text$mn:00004F22                 align 4
.text$mn:00004F22 _text$mn        ends
.text$mn:00004F22
.text$mn:00004F24 ; ===========================================================================
.text$mn:00004F24
.text$mn:00004F24 ; Segment type: Pure code
.text$mn:00004F24 ; Segment permissions: Read/Execute
.text$mn:00004F24 _text$mn        segment para public 'CODE' use32
.text$mn:00004F24                 assume cs:_text$mn
.text$mn:00004F24                 ;org 4F24h
.text$mn:00004F24 ; COMDAT (pick any)
.text$mn:00004F24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F24
.text$mn:00004F24 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F24
.text$mn:00004F24 ; Attributes: bp-based frame
.text$mn:00004F24
.text$mn:00004F24 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00004F24                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00004F24 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00004F24                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00004F24
.text$mn:00004F24 var_8           = dword ptr -8
.text$mn:00004F24 var_4           = dword ptr -4
.text$mn:00004F24
.text$mn:00004F24                 push    ebp
.text$mn:00004F25                 mov     ebp, esp
.text$mn:00004F27                 sub     esp, 8
.text$mn:00004F2A                 mov     [ebp+var_4], ecx
.text$mn:00004F2D                 mov     eax, [ebp+var_4]
.text$mn:00004F30                 cmp     dword ptr [eax+18h], 10h
.text$mn:00004F34                 jb      short loc_4F4A
.text$mn:00004F36                 mov     ecx, [ebp+var_4]
.text$mn:00004F39                 mov     edx, [ecx+4]
.text$mn:00004F3C                 push    edx
.text$mn:00004F3D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00004F42                 add     esp, 4
.text$mn:00004F45                 mov     [ebp+var_8], eax
.text$mn:00004F48                 jmp     short loc_4F53
.text$mn:00004F4A ; ---------------------------------------------------------------------------
.text$mn:00004F4A
.text$mn:00004F4A loc_4F4A:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00004F4A                 mov     eax, [ebp+var_4]
.text$mn:00004F4D                 add     eax, 4
.text$mn:00004F50                 mov     [ebp+var_8], eax
.text$mn:00004F53
.text$mn:00004F53 loc_4F53:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00004F53                 mov     eax, [ebp+var_8]
.text$mn:00004F56                 mov     esp, ebp
.text$mn:00004F58                 pop     ebp
.text$mn:00004F59                 retn
.text$mn:00004F59 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00004F59
.text$mn:00004F59 ; ---------------------------------------------------------------------------
.text$mn:00004F5A                 align 4
.text$mn:00004F5A _text$mn        ends
.text$mn:00004F5A
.text$mn:00004F5C ; ===========================================================================
.text$mn:00004F5C
.text$mn:00004F5C ; Segment type: Pure code
.text$mn:00004F5C ; Segment permissions: Read/Execute
.text$mn:00004F5C _text$mn        segment para public 'CODE' use32
.text$mn:00004F5C                 assume cs:_text$mn
.text$mn:00004F5C                 ;org 4F5Ch
.text$mn:00004F5C ; COMDAT (pick any)
.text$mn:00004F5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F5C
.text$mn:00004F5C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F5C
.text$mn:00004F5C ; Attributes: bp-based frame
.text$mn:00004F5C
.text$mn:00004F5C ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004F5C                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:00004F5C ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:00004F5C                                         ; CODE XREF: $LN19_0+14p
.text$mn:00004F5C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp ...
.text$mn:00004F5C
.text$mn:00004F5C var_8           = dword ptr -8
.text$mn:00004F5C var_4           = dword ptr -4
.text$mn:00004F5C
.text$mn:00004F5C                 push    ebp
.text$mn:00004F5D                 mov     ebp, esp
.text$mn:00004F5F                 sub     esp, 8
.text$mn:00004F62                 mov     [ebp+var_4], ecx
.text$mn:00004F65                 mov     eax, [ebp+var_4]
.text$mn:00004F68                 cmp     dword ptr [eax+18h], 8
.text$mn:00004F6C                 jb      short loc_4F82
.text$mn:00004F6E                 mov     ecx, [ebp+var_4]
.text$mn:00004F71                 mov     edx, [ecx+4]
.text$mn:00004F74                 push    edx
.text$mn:00004F75                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00004F7A                 add     esp, 4
.text$mn:00004F7D                 mov     [ebp+var_8], eax
.text$mn:00004F80                 jmp     short loc_4F8B
.text$mn:00004F82 ; ---------------------------------------------------------------------------
.text$mn:00004F82
.text$mn:00004F82 loc_4F82:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00004F82                 mov     eax, [ebp+var_4]
.text$mn:00004F85                 add     eax, 4
.text$mn:00004F88                 mov     [ebp+var_8], eax
.text$mn:00004F8B
.text$mn:00004F8B loc_4F8B:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00004F8B                 mov     eax, [ebp+var_8]
.text$mn:00004F8E                 mov     esp, ebp
.text$mn:00004F90                 pop     ebp
.text$mn:00004F91                 retn
.text$mn:00004F91 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:00004F91
.text$mn:00004F91 ; ---------------------------------------------------------------------------
.text$mn:00004F92                 align 4
.text$mn:00004F92 _text$mn        ends
.text$mn:00004F92
.text$mn:00004F94 ; ===========================================================================
.text$mn:00004F94
.text$mn:00004F94 ; Segment type: Pure code
.text$mn:00004F94 ; Segment permissions: Read/Execute
.text$mn:00004F94 _text$mn        segment para public 'CODE' use32
.text$mn:00004F94                 assume cs:_text$mn
.text$mn:00004F94                 ;org 4F94h
.text$mn:00004F94 ; COMDAT (pick any)
.text$mn:00004F94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F94
.text$mn:00004F94 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F94
.text$mn:00004F94 ; Attributes: bp-based frame
.text$mn:00004F94
.text$mn:00004F94 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:00004F94                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:00004F94 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:00004F94                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp
.text$mn:00004F94                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+13p ...
.text$mn:00004F94
.text$mn:00004F94 var_8           = dword ptr -8
.text$mn:00004F94 var_4           = dword ptr -4
.text$mn:00004F94
.text$mn:00004F94                 push    ebp
.text$mn:00004F95                 mov     ebp, esp
.text$mn:00004F97                 sub     esp, 8
.text$mn:00004F9A                 mov     [ebp+var_4], ecx
.text$mn:00004F9D                 mov     eax, [ebp+var_4]
.text$mn:00004FA0                 cmp     dword ptr [eax+18h], 8
.text$mn:00004FA4                 jb      short loc_4FBA
.text$mn:00004FA6                 mov     ecx, [ebp+var_4]
.text$mn:00004FA9                 mov     edx, [ecx+4]
.text$mn:00004FAC                 push    edx
.text$mn:00004FAD                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00004FB2                 add     esp, 4
.text$mn:00004FB5                 mov     [ebp+var_8], eax
.text$mn:00004FB8                 jmp     short loc_4FC3
.text$mn:00004FBA ; ---------------------------------------------------------------------------
.text$mn:00004FBA
.text$mn:00004FBA loc_4FBA:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00004FBA                 mov     eax, [ebp+var_4]
.text$mn:00004FBD                 add     eax, 4
.text$mn:00004FC0                 mov     [ebp+var_8], eax
.text$mn:00004FC3
.text$mn:00004FC3 loc_4FC3:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00004FC3                 mov     eax, [ebp+var_8]
.text$mn:00004FC6                 mov     esp, ebp
.text$mn:00004FC8                 pop     ebp
.text$mn:00004FC9                 retn
.text$mn:00004FC9 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:00004FC9
.text$mn:00004FC9 ; ---------------------------------------------------------------------------
.text$mn:00004FCA                 align 4
.text$mn:00004FCA _text$mn        ends
.text$mn:00004FCA
.text$mn:00004FCC ; ===========================================================================
.text$mn:00004FCC
.text$mn:00004FCC ; Segment type: Pure code
.text$mn:00004FCC ; Segment permissions: Read/Execute
.text$mn:00004FCC _text$mn        segment para public 'CODE' use32
.text$mn:00004FCC                 assume cs:_text$mn
.text$mn:00004FCC                 ;org 4FCCh
.text$mn:00004FCC ; COMDAT (pick any)
.text$mn:00004FCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FCC
.text$mn:00004FCC ; =============== S U B R O U T I N E =======================================
.text$mn:00004FCC
.text$mn:00004FCC ; Attributes: bp-based frame
.text$mn:00004FCC
.text$mn:00004FCC ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00004FCC                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00004FCC ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00004FCC                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00004FCC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:00004FCC
.text$mn:00004FCC var_18          = byte ptr -18h
.text$mn:00004FCC var_14          = dword ptr -14h
.text$mn:00004FCC var_10          = dword ptr -10h
.text$mn:00004FCC var_C           = dword ptr -0Ch
.text$mn:00004FCC var_4           = dword ptr -4
.text$mn:00004FCC
.text$mn:00004FCC                 push    ebp
.text$mn:00004FCD                 mov     ebp, esp
.text$mn:00004FCF                 push    0FFFFFFFFh
.text$mn:00004FD1                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00004FD6                 mov     eax, large fs:0
.text$mn:00004FDC                 push    eax
.text$mn:00004FDD                 sub     esp, 0Ch
.text$mn:00004FE0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004FE5                 xor     eax, ebp
.text$mn:00004FE7                 push    eax
.text$mn:00004FE8                 lea     eax, [ebp+var_C]
.text$mn:00004FEB                 mov     large fs:0, eax
.text$mn:00004FF1                 mov     [ebp+var_14], ecx
.text$mn:00004FF4                 mov     eax, [ebp+var_14]
.text$mn:00004FF7                 cmp     dword ptr [eax], 0
.text$mn:00004FFA                 jz      short loc_5057
.text$mn:00004FFC                 push    3               ; int
.text$mn:00004FFE                 lea     ecx, [ebp+var_18] ; this
.text$mn:00005001                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00005006                 mov     [ebp+var_4], 0
.text$mn:0000500D                 mov     ecx, [ebp+var_14]
.text$mn:00005010                 mov     edx, [ecx]
.text$mn:00005012                 add     edx, 4
.text$mn:00005015                 mov     [ebp+var_10], edx
.text$mn:00005018                 jmp     short loc_5027
.text$mn:0000501A ; ---------------------------------------------------------------------------
.text$mn:0000501A
.text$mn:0000501A loc_501A:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:0000501A                 mov     eax, [ebp+var_10]
.text$mn:0000501D                 mov     ecx, [eax]
.text$mn:0000501F                 mov     edx, [ebp+var_10]
.text$mn:00005022                 mov     eax, [ecx+4]
.text$mn:00005025                 mov     [edx], eax
.text$mn:00005027
.text$mn:00005027 loc_5027:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00005027                 mov     ecx, [ebp+var_10]
.text$mn:0000502A                 cmp     dword ptr [ecx], 0
.text$mn:0000502D                 jz      short loc_503C
.text$mn:0000502F                 mov     edx, [ebp+var_10]
.text$mn:00005032                 mov     eax, [edx]
.text$mn:00005034                 mov     dword ptr [eax], 0
.text$mn:0000503A                 jmp     short loc_501A
.text$mn:0000503C ; ---------------------------------------------------------------------------
.text$mn:0000503C
.text$mn:0000503C loc_503C:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:0000503C                 mov     ecx, [ebp+var_14]
.text$mn:0000503F                 mov     edx, [ecx]
.text$mn:00005041                 mov     dword ptr [edx+4], 0
.text$mn:00005048                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000504F                 lea     ecx, [ebp+var_18] ; this
.text$mn:00005052                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00005057
.text$mn:00005057 loc_5057:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00005057                 mov     ecx, [ebp+var_C]
.text$mn:0000505A                 mov     large fs:0, ecx
.text$mn:00005061                 pop     ecx
.text$mn:00005062                 mov     esp, ebp
.text$mn:00005064                 pop     ebp
.text$mn:00005065                 retn
.text$mn:00005065 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00005065
.text$mn:00005065 ; ---------------------------------------------------------------------------
.text$mn:00005066                 align 4
.text$mn:00005066 _text$mn        ends
.text$mn:00005066
.text$x:00005068 ; ===========================================================================
.text$x:00005068
.text$x:00005068 ; Segment type: Pure code
.text$x:00005068 ; Segment permissions: Read/Execute
.text$x:00005068 _text$x         segment para public 'CODE' use32
.text$x:00005068                 assume cs:_text$x
.text$x:00005068                 ;org 5068h
.text$x:00005068 ; COMDAT (pick associative to section at 4FCC)
.text$x:00005068                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005068
.text$x:00005068 ; =============== S U B R O U T I N E =======================================
.text$x:00005068
.text$x:00005068
.text$x:00005068 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00005068                                         ; DATA XREF: .xdata$x:00006D04o
.text$x:00005068                 lea     ecx, [ebp-18h]  ; this
.text$x:0000506B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000506B __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:0000506B
.text$x:00005070
.text$x:00005070 ; =============== S U B R O U T I N E =======================================
.text$x:00005070
.text$x:00005070
.text$x:00005070 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00005070                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00005070
.text$x:00005070 arg_4           = dword ptr  8
.text$x:00005070
.text$x:00005070                 mov     edx, [esp+arg_4]
.text$x:00005074                 lea     eax, [edx+0Ch]
.text$x:00005077                 mov     ecx, [edx-10h]
.text$x:0000507A                 xor     ecx, eax
.text$x:0000507C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005081                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00005086                 jmp     ___CxxFrameHandler3
.text$x:00005086 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00005086
.text$x:00005086 ; ---------------------------------------------------------------------------
.text$x:0000508B                 align 4
.text$x:0000508B _text$x         ends
.text$x:0000508B
.text$mn:0000508C ; ===========================================================================
.text$mn:0000508C
.text$mn:0000508C ; Segment type: Pure code
.text$mn:0000508C ; Segment permissions: Read/Execute
.text$mn:0000508C _text$mn        segment para public 'CODE' use32
.text$mn:0000508C                 assume cs:_text$mn
.text$mn:0000508C                 ;org 508Ch
.text$mn:0000508C ; COMDAT (pick any)
.text$mn:0000508C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000508C
.text$mn:0000508C ; =============== S U B R O U T I N E =======================================
.text$mn:0000508C
.text$mn:0000508C ; Attributes: bp-based frame
.text$mn:0000508C
.text$mn:0000508C ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:0000508C                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:0000508C ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:0000508C                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:0000508C                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:0000508C
.text$mn:0000508C var_8           = dword ptr -8
.text$mn:0000508C var_4           = dword ptr -4
.text$mn:0000508C
.text$mn:0000508C                 push    ebp
.text$mn:0000508D                 mov     ebp, esp
.text$mn:0000508F                 sub     esp, 8
.text$mn:00005092                 mov     [ebp+var_8], ecx
.text$mn:00005095                 mov     eax, [ebp+var_8]
.text$mn:00005098                 cmp     dword ptr [eax], 0
.text$mn:0000509B                 jz      short loc_50FA
.text$mn:0000509D                 mov     ecx, [ebp+var_8]
.text$mn:000050A0                 mov     edx, [ecx]
.text$mn:000050A2                 add     edx, 4
.text$mn:000050A5                 mov     [ebp+var_4], edx
.text$mn:000050A8
.text$mn:000050A8 loc_50A8:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:000050A8                 mov     eax, [ebp+var_4]
.text$mn:000050AB                 cmp     dword ptr [eax], 0
.text$mn:000050AE                 jz      short loc_50C7
.text$mn:000050B0                 mov     ecx, [ebp+var_4]
.text$mn:000050B3                 mov     edx, [ecx]
.text$mn:000050B5                 cmp     edx, [ebp+var_8]
.text$mn:000050B8                 jz      short loc_50C7
.text$mn:000050BA                 mov     eax, [ebp+var_4]
.text$mn:000050BD                 mov     ecx, [eax]
.text$mn:000050BF                 add     ecx, 4
.text$mn:000050C2                 mov     [ebp+var_4], ecx
.text$mn:000050C5                 jmp     short loc_50A8
.text$mn:000050C7 ; ---------------------------------------------------------------------------
.text$mn:000050C7
.text$mn:000050C7 loc_50C7:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:000050C7                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:000050C7                 mov     edx, [ebp+var_4]
.text$mn:000050CA                 cmp     dword ptr [edx], 0
.text$mn:000050CD                 jnz     short loc_50E6
.text$mn:000050CF                 push    0C9h ; '+'      ; unsigned int
.text$mn:000050D4                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000050D9                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:000050DE                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000050E3                 add     esp, 0Ch
.text$mn:000050E6
.text$mn:000050E6 loc_50E6:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:000050E6                 mov     eax, [ebp+var_4]
.text$mn:000050E9                 mov     ecx, [ebp+var_8]
.text$mn:000050EC                 mov     edx, [ecx+4]
.text$mn:000050EF                 mov     [eax], edx
.text$mn:000050F1                 mov     eax, [ebp+var_8]
.text$mn:000050F4                 mov     dword ptr [eax], 0
.text$mn:000050FA
.text$mn:000050FA loc_50FA:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:000050FA                 mov     esp, ebp
.text$mn:000050FC                 pop     ebp
.text$mn:000050FD                 retn
.text$mn:000050FD ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:000050FD
.text$mn:000050FD ; ---------------------------------------------------------------------------
.text$mn:000050FE                 align 10h
.text$mn:000050FE _text$mn        ends
.text$mn:000050FE
.text$mn:00005100 ; ===========================================================================
.text$mn:00005100
.text$mn:00005100 ; Segment type: Pure code
.text$mn:00005100 ; Segment permissions: Read/Execute
.text$mn:00005100 _text$mn        segment para public 'CODE' use32
.text$mn:00005100                 assume cs:_text$mn
.text$mn:00005100                 ;org 5100h
.text$mn:00005100 ; COMDAT (pick any)
.text$mn:00005100                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005100
.text$mn:00005100 ; =============== S U B R O U T I N E =======================================
.text$mn:00005100
.text$mn:00005100 ; Attributes: bp-based frame
.text$mn:00005100
.text$mn:00005100 ; protected: void __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::_Orphan_range(struct TreeStateNode *, struct TreeStateNode *)const
.text$mn:00005100                 public ?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z
.text$mn:00005100 ?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z proc near
.text$mn:00005100                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::push_back(TreeStateNode &&)+6Fp
.text$mn:00005100                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::push_back(TreeStateNode &&)+DCp
.text$mn:00005100
.text$mn:00005100 var_18          = byte ptr -18h
.text$mn:00005100 var_14          = dword ptr -14h
.text$mn:00005100 var_10          = dword ptr -10h
.text$mn:00005100 var_C           = dword ptr -0Ch
.text$mn:00005100 var_4           = dword ptr -4
.text$mn:00005100 arg_0           = dword ptr  8
.text$mn:00005100 arg_4           = dword ptr  0Ch
.text$mn:00005100
.text$mn:00005100                 push    ebp
.text$mn:00005101                 mov     ebp, esp
.text$mn:00005103                 push    0FFFFFFFFh
.text$mn:00005105                 push    offset __ehhandler$?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z
.text$mn:0000510A                 mov     eax, large fs:0
.text$mn:00005110                 push    eax
.text$mn:00005111                 sub     esp, 0Ch
.text$mn:00005114                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005119                 xor     eax, ebp
.text$mn:0000511B                 push    eax
.text$mn:0000511C                 lea     eax, [ebp+var_C]
.text$mn:0000511F                 mov     large fs:0, eax
.text$mn:00005125                 mov     [ebp+var_14], ecx
.text$mn:00005128                 push    3               ; int
.text$mn:0000512A                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000512D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00005132                 mov     [ebp+var_4], 0
.text$mn:00005139                 mov     ecx, [ebp+var_14] ; this
.text$mn:0000513C                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00005141                 mov     [ebp+var_10], eax
.text$mn:00005144                 cmp     [ebp+var_10], 0
.text$mn:00005148                 jz      short loc_5198
.text$mn:0000514A
.text$mn:0000514A loc_514A:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Orphan_range(TreeStateNode *,TreeStateNode *):loc_5196j
.text$mn:0000514A                 mov     eax, [ebp+var_10]
.text$mn:0000514D                 cmp     dword ptr [eax], 0
.text$mn:00005150                 jz      short loc_5198
.text$mn:00005152                 mov     ecx, [ebp+var_10]
.text$mn:00005155                 mov     edx, [ecx]
.text$mn:00005157                 mov     eax, [edx+8]
.text$mn:0000515A                 cmp     eax, [ebp+arg_0]
.text$mn:0000515D                 jb      short loc_516C
.text$mn:0000515F                 mov     ecx, [ebp+var_10]
.text$mn:00005162                 mov     edx, [ecx]
.text$mn:00005164                 mov     eax, [ebp+arg_4]
.text$mn:00005167                 cmp     eax, [edx+8]
.text$mn:0000516A                 jnb     short loc_517B
.text$mn:0000516C
.text$mn:0000516C loc_516C:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Orphan_range(TreeStateNode *,TreeStateNode *)+5Dj
.text$mn:0000516C                 mov     ecx, [ebp+var_10]
.text$mn:0000516F                 mov     ecx, [ecx]      ; this
.text$mn:00005171                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00005176                 mov     [ebp+var_10], eax
.text$mn:00005179                 jmp     short loc_5196
.text$mn:0000517B ; ---------------------------------------------------------------------------
.text$mn:0000517B
.text$mn:0000517B loc_517B:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Orphan_range(TreeStateNode *,TreeStateNode *)+6Aj
.text$mn:0000517B                 mov     edx, [ebp+var_10]
.text$mn:0000517E                 mov     ecx, [edx]      ; this
.text$mn:00005180                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00005185                 mov     eax, [ebp+var_10]
.text$mn:00005188                 mov     ecx, [eax]      ; this
.text$mn:0000518A                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000518F                 mov     ecx, [ebp+var_10]
.text$mn:00005192                 mov     edx, [eax]
.text$mn:00005194                 mov     [ecx], edx
.text$mn:00005196
.text$mn:00005196 loc_5196:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Orphan_range(TreeStateNode *,TreeStateNode *)+79j
.text$mn:00005196                 jmp     short loc_514A
.text$mn:00005198 ; ---------------------------------------------------------------------------
.text$mn:00005198
.text$mn:00005198 loc_5198:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Orphan_range(TreeStateNode *,TreeStateNode *)+48j
.text$mn:00005198                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Orphan_range(TreeStateNode *,TreeStateNode *)+50j
.text$mn:00005198                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000519F                 lea     ecx, [ebp+var_18] ; this
.text$mn:000051A2                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000051A7                 mov     ecx, [ebp+var_C]
.text$mn:000051AA                 mov     large fs:0, ecx
.text$mn:000051B1                 pop     ecx
.text$mn:000051B2                 mov     esp, ebp
.text$mn:000051B4                 pop     ebp
.text$mn:000051B5                 retn    8
.text$mn:000051B5 ?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z endp
.text$mn:000051B5
.text$mn:000051B5 _text$mn        ends
.text$mn:000051B5
.text$x:000051B8 ; ===========================================================================
.text$x:000051B8
.text$x:000051B8 ; Segment type: Pure code
.text$x:000051B8 ; Segment permissions: Read/Execute
.text$x:000051B8 _text$x         segment para public 'CODE' use32
.text$x:000051B8                 assume cs:_text$x
.text$x:000051B8                 ;org 51B8h
.text$x:000051B8 ; COMDAT (pick associative to section at 5100)
.text$x:000051B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000051B8
.text$x:000051B8 ; =============== S U B R O U T I N E =======================================
.text$x:000051B8
.text$x:000051B8
.text$x:000051B8 __unwindfunclet$?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z$0 proc near
.text$x:000051B8                                         ; DATA XREF: .xdata$x:0000751Co
.text$x:000051B8                 lea     ecx, [ebp-18h]  ; this
.text$x:000051BB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000051BB __unwindfunclet$?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z$0 endp
.text$x:000051BB
.text$x:000051C0
.text$x:000051C0 ; =============== S U B R O U T I N E =======================================
.text$x:000051C0
.text$x:000051C0
.text$x:000051C0 __ehhandler$?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z proc near
.text$x:000051C0                                         ; DATA XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Orphan_range(TreeStateNode *,TreeStateNode *)+5o
.text$x:000051C0
.text$x:000051C0 arg_4           = dword ptr  8
.text$x:000051C0
.text$x:000051C0                 mov     edx, [esp+arg_4]
.text$x:000051C4                 lea     eax, [edx+0Ch]
.text$x:000051C7                 mov     ecx, [edx-10h]
.text$x:000051CA                 xor     ecx, eax
.text$x:000051CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000051D1                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z
.text$x:000051D6                 jmp     ___CxxFrameHandler3
.text$x:000051D6 __ehhandler$?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z endp
.text$x:000051D6
.text$x:000051D6 ; ---------------------------------------------------------------------------
.text$x:000051DB                 align 4
.text$x:000051DB _text$x         ends
.text$x:000051DB
.text$mn:000051DC ; ===========================================================================
.text$mn:000051DC
.text$mn:000051DC ; Segment type: Pure code
.text$mn:000051DC ; Segment permissions: Read/Execute
.text$mn:000051DC _text$mn        segment para public 'CODE' use32
.text$mn:000051DC                 assume cs:_text$mn
.text$mn:000051DC                 ;org 51DCh
.text$mn:000051DC ; COMDAT (pick any)
.text$mn:000051DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000051DC
.text$mn:000051DC ; =============== S U B R O U T I N E =======================================
.text$mn:000051DC
.text$mn:000051DC ; Attributes: bp-based frame
.text$mn:000051DC
.text$mn:000051DC ; protected: void __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::_Reallocate(unsigned int)
.text$mn:000051DC                 public ?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z
.text$mn:000051DC ?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z proc near
.text$mn:000051DC                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reserve(uint)+4Ep
.text$mn:000051DC
.text$mn:000051DC var_20          = dword ptr -20h
.text$mn:000051DC var_1C          = dword ptr -1Ch
.text$mn:000051DC var_18          = dword ptr -18h
.text$mn:000051DC var_13          = byte ptr -13h
.text$mn:000051DC var_11          = byte ptr -11h
.text$mn:000051DC var_10          = dword ptr -10h
.text$mn:000051DC var_C           = dword ptr -0Ch
.text$mn:000051DC var_4           = dword ptr -4
.text$mn:000051DC arg_0           = dword ptr  8
.text$mn:000051DC
.text$mn:000051DC ; FUNCTION CHUNK AT .text$mn:00005272 SIZE 00000009 BYTES
.text$mn:000051DC ; FUNCTION CHUNK AT .text$mn:00005282 SIZE 00000098 BYTES
.text$mn:000051DC
.text$mn:000051DC                 push    ebp
.text$mn:000051DD                 mov     ebp, esp
.text$mn:000051DF                 push    0FFFFFFFFh
.text$mn:000051E1                 push    offset __ehhandler$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z
.text$mn:000051E6                 mov     eax, large fs:0
.text$mn:000051EC                 push    eax
.text$mn:000051ED                 push    ecx
.text$mn:000051EE                 sub     esp, 10h
.text$mn:000051F1                 push    ebx
.text$mn:000051F2                 push    esi
.text$mn:000051F3                 push    edi
.text$mn:000051F4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000051F9                 xor     eax, ebp
.text$mn:000051FB                 push    eax
.text$mn:000051FC                 lea     eax, [ebp+var_C]
.text$mn:000051FF                 mov     large fs:0, eax
.text$mn:00005205                 mov     [ebp+var_10], esp
.text$mn:00005208                 mov     [ebp+var_18], ecx
.text$mn:0000520B                 mov     eax, [ebp+arg_0]
.text$mn:0000520E                 push    eax
.text$mn:0000520F                 lea     ecx, [ebp+var_11]
.text$mn:00005212                 push    ecx
.text$mn:00005213                 mov     ecx, [ebp+var_18]
.text$mn:00005216                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Getal(void)
.text$mn:0000521B                 mov     ecx, eax
.text$mn:0000521D                 call    ?allocate@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEPAUTreeStateNode@@I@Z ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::allocate(uint)
.text$mn:00005222                 mov     [ebp+var_1C], eax
.text$mn:00005225                 mov     [ebp+var_4], 0
.text$mn:0000522C                 mov     edx, [ebp+var_1C]
.text$mn:0000522F                 push    edx
.text$mn:00005230                 mov     eax, [ebp+var_18]
.text$mn:00005233                 mov     ecx, [eax+8]
.text$mn:00005236                 push    ecx
.text$mn:00005237                 mov     edx, [ebp+var_18]
.text$mn:0000523A                 mov     eax, [edx+4]
.text$mn:0000523D                 push    eax
.text$mn:0000523E                 mov     ecx, [ebp+var_18]
.text$mn:00005241                 call    ??$_Umove@PAUTreeStateNode@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@PAU2@00@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Umove<TreeStateNode *>(TreeStateNode *,TreeStateNode *,TreeStateNode *)
.text$mn:00005246                 jmp     short loc_5272
.text$mn:00005246 ?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z endp
.text$mn:00005246
.text$mn:00005248
.text$mn:00005248 ; =============== S U B R O U T I N E =======================================
.text$mn:00005248
.text$mn:00005248 ; Attributes: noreturn
.text$mn:00005248
.text$mn:00005248 __catch$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00005248                                         ; DATA XREF: .xdata$x:000074CCo
.text$mn:00005248                 mov     ecx, [ebp+8]
.text$mn:0000524B                 push    ecx             ; int
.text$mn:0000524C                 mov     edx, [ebp-1Ch]
.text$mn:0000524F                 push    edx             ; void *
.text$mn:00005250                 lea     eax, [ebp-12h]
.text$mn:00005253                 push    eax
.text$mn:00005254                 mov     ecx, [ebp-18h]
.text$mn:00005257                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Getal(void)
.text$mn:0000525C                 mov     ecx, eax
.text$mn:0000525E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@I@Z ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::deallocate(TreeStateNode *,uint)
.text$mn:00005263                 push    0
.text$mn:00005265                 push    0
.text$mn:00005267                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00005267 __catch$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:00005267
.text$mn:0000526C ; ---------------------------------------------------------------------------
.text$mn:0000526C                 mov     eax, offset $LN8
.text$mn:00005271                 retn
.text$mn:00005272 ; ---------------------------------------------------------------------------
.text$mn:00005272 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z
.text$mn:00005272
.text$mn:00005272 loc_5272:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reallocate(uint)+6Aj
.text$mn:00005272                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005279                 jmp     short loc_5282
.text$mn:00005279 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z
.text$mn:0000527B
.text$mn:0000527B ; =============== S U B R O U T I N E =======================================
.text$mn:0000527B
.text$mn:0000527B
.text$mn:0000527B $LN8            proc near               ; DATA XREF: .text$mn:0000526Co
.text$mn:0000527B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000527B $LN8            endp ; sp-analysis failed
.text$mn:0000527B
.text$mn:00005282 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z
.text$mn:00005282
.text$mn:00005282 loc_5282:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reallocate(uint)+9Dj
.text$mn:00005282                 mov     ecx, [ebp+var_18]
.text$mn:00005285                 call    ?size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::size(void)
.text$mn:0000528A                 mov     [ebp+var_20], eax
.text$mn:0000528D                 mov     ecx, [ebp+var_18]
.text$mn:00005290                 cmp     dword ptr [ecx+4], 0
.text$mn:00005294                 jz      short loc_52DB
.text$mn:00005296                 mov     edx, [ebp+var_18]
.text$mn:00005299                 mov     eax, [edx+8]
.text$mn:0000529C                 push    eax
.text$mn:0000529D                 mov     ecx, [ebp+var_18]
.text$mn:000052A0                 mov     edx, [ecx+4]
.text$mn:000052A3                 push    edx
.text$mn:000052A4                 mov     ecx, [ebp+var_18]
.text$mn:000052A7                 call    ?_Destroy@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXPAUTreeStateNode@@0@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Destroy(TreeStateNode *,TreeStateNode *)
.text$mn:000052AC                 mov     eax, [ebp+var_18]
.text$mn:000052AF                 mov     ecx, [ebp+var_18]
.text$mn:000052B2                 mov     eax, [eax+0Ch]
.text$mn:000052B5                 sub     eax, [ecx+4]
.text$mn:000052B8                 cdq
.text$mn:000052B9                 mov     ecx, 4Ch ; 'L'
.text$mn:000052BE                 idiv    ecx
.text$mn:000052C0                 push    eax             ; int
.text$mn:000052C1                 mov     edx, [ebp+var_18]
.text$mn:000052C4                 mov     eax, [edx+4]
.text$mn:000052C7                 push    eax             ; void *
.text$mn:000052C8                 lea     ecx, [ebp+var_13]
.text$mn:000052CB                 push    ecx
.text$mn:000052CC                 mov     ecx, [ebp+var_18]
.text$mn:000052CF                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Getal(void)
.text$mn:000052D4                 mov     ecx, eax
.text$mn:000052D6                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@I@Z ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::deallocate(TreeStateNode *,uint)
.text$mn:000052DB
.text$mn:000052DB loc_52DB:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reallocate(uint)+B8j
.text$mn:000052DB                 mov     ecx, [ebp+var_18] ; this
.text$mn:000052DE                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000052E3                 imul    edx, [ebp+arg_0], 4Ch
.text$mn:000052E7                 add     edx, [ebp+var_1C]
.text$mn:000052EA                 mov     eax, [ebp+var_18]
.text$mn:000052ED                 mov     [eax+0Ch], edx
.text$mn:000052F0                 imul    ecx, [ebp+var_20], 4Ch
.text$mn:000052F4                 add     ecx, [ebp+var_1C]
.text$mn:000052F7                 mov     edx, [ebp+var_18]
.text$mn:000052FA                 mov     [edx+8], ecx
.text$mn:000052FD                 mov     eax, [ebp+var_18]
.text$mn:00005300                 mov     ecx, [ebp+var_1C]
.text$mn:00005303                 mov     [eax+4], ecx
.text$mn:00005306                 mov     ecx, [ebp+var_C]
.text$mn:00005309                 mov     large fs:0, ecx
.text$mn:00005310                 pop     ecx
.text$mn:00005311                 pop     edi
.text$mn:00005312                 pop     esi
.text$mn:00005313                 pop     ebx
.text$mn:00005314                 mov     esp, ebp
.text$mn:00005316                 pop     ebp
.text$mn:00005317                 retn    4
.text$mn:00005317 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z
.text$mn:00005317 ; ---------------------------------------------------------------------------
.text$mn:0000531A                 align 4
.text$mn:0000531A _text$mn        ends
.text$mn:0000531A
.text$x:0000531C ; ===========================================================================
.text$x:0000531C
.text$x:0000531C ; Segment type: Pure code
.text$x:0000531C ; Segment permissions: Read/Execute
.text$x:0000531C _text$x         segment para public 'CODE' use32
.text$x:0000531C                 assume cs:_text$x
.text$x:0000531C                 ;org 531Ch
.text$x:0000531C ; COMDAT (pick associative to section at 51DC)
.text$x:0000531C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000531C
.text$x:0000531C ; =============== S U B R O U T I N E =======================================
.text$x:0000531C
.text$x:0000531C
.text$x:0000531C __ehhandler$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z proc near
.text$x:0000531C                                         ; DATA XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reallocate(uint)+5o
.text$x:0000531C
.text$x:0000531C arg_4           = dword ptr  8
.text$x:0000531C
.text$x:0000531C                 mov     edx, [esp+arg_4]
.text$x:00005320                 lea     eax, [edx+0Ch]
.text$x:00005323                 mov     ecx, [edx-24h]
.text$x:00005326                 xor     ecx, eax
.text$x:00005328                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000532D                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z
.text$x:00005332                 jmp     ___CxxFrameHandler3
.text$x:00005332 __ehhandler$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z endp
.text$x:00005332
.text$x:00005332 ; ---------------------------------------------------------------------------
.text$x:00005337                 align 4
.text$x:00005337 _text$x         ends
.text$x:00005337
.text$mn:00005338 ; ===========================================================================
.text$mn:00005338
.text$mn:00005338 ; Segment type: Pure code
.text$mn:00005338 ; Segment permissions: Read/Execute
.text$mn:00005338 _text$mn        segment para public 'CODE' use32
.text$mn:00005338                 assume cs:_text$mn
.text$mn:00005338                 ;org 5338h
.text$mn:00005338 ; COMDAT (pick any)
.text$mn:00005338                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005338
.text$mn:00005338 ; =============== S U B R O U T I N E =======================================
.text$mn:00005338
.text$mn:00005338 ; Attributes: bp-based frame
.text$mn:00005338
.text$mn:00005338 ; protected: void __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::_Reserve(unsigned int)
.text$mn:00005338                 public ?_Reserve@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z
.text$mn:00005338 ?_Reserve@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z proc near
.text$mn:00005338                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::push_back(TreeStateNode &&)+59p
.text$mn:00005338                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::push_back(TreeStateNode &&)+C6p
.text$mn:00005338
.text$mn:00005338 var_4           = dword ptr -4
.text$mn:00005338 arg_0           = dword ptr  8
.text$mn:00005338
.text$mn:00005338                 push    ebp
.text$mn:00005339                 mov     ebp, esp
.text$mn:0000533B                 push    ecx
.text$mn:0000533C                 push    esi
.text$mn:0000533D                 mov     [ebp+var_4], ecx
.text$mn:00005340                 mov     ecx, [ebp+var_4]
.text$mn:00005343                 call    ?_Unused_capacity@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Unused_capacity(void)
.text$mn:00005348                 cmp     eax, [ebp+arg_0]
.text$mn:0000534B                 jnb     short loc_538B
.text$mn:0000534D                 mov     ecx, [ebp+var_4]
.text$mn:00005350                 call    ?max_size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::max_size(void)
.text$mn:00005355                 mov     esi, eax
.text$mn:00005357                 mov     ecx, [ebp+var_4]
.text$mn:0000535A                 call    ?size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::size(void)
.text$mn:0000535F                 sub     esi, eax
.text$mn:00005361                 cmp     esi, [ebp+arg_0]
.text$mn:00005364                 jnb     short loc_536E
.text$mn:00005366                 mov     ecx, [ebp+var_4]
.text$mn:00005369                 call    ?_Xlen@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Xlen(void)
.text$mn:0000536E
.text$mn:0000536E loc_536E:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reserve(uint)+2Cj
.text$mn:0000536E                 mov     ecx, [ebp+var_4]
.text$mn:00005371                 call    ?size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::size(void)
.text$mn:00005376                 add     eax, [ebp+arg_0]
.text$mn:00005379                 push    eax
.text$mn:0000537A                 mov     ecx, [ebp+var_4]
.text$mn:0000537D                 call    ?_Grow_to@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEII@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Grow_to(uint)
.text$mn:00005382                 push    eax
.text$mn:00005383                 mov     ecx, [ebp+var_4]
.text$mn:00005386                 call    ?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reallocate(uint)
.text$mn:0000538B
.text$mn:0000538B loc_538B:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reserve(uint)+13j
.text$mn:0000538B                 pop     esi
.text$mn:0000538C                 mov     esp, ebp
.text$mn:0000538E                 pop     ebp
.text$mn:0000538F                 retn    4
.text$mn:0000538F ?_Reserve@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z endp
.text$mn:0000538F
.text$mn:0000538F ; ---------------------------------------------------------------------------
.text$mn:00005392                 align 4
.text$mn:00005392 _text$mn        ends
.text$mn:00005392
.text$mn:00005394 ; ===========================================================================
.text$mn:00005394
.text$mn:00005394 ; Segment type: Pure code
.text$mn:00005394 ; Segment permissions: Read/Execute
.text$mn:00005394 _text$mn        segment para public 'CODE' use32
.text$mn:00005394                 assume cs:_text$mn
.text$mn:00005394                 ;org 5394h
.text$mn:00005394 ; COMDAT (pick any)
.text$mn:00005394                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005394
.text$mn:00005394 ; =============== S U B R O U T I N E =======================================
.text$mn:00005394
.text$mn:00005394 ; Attributes: bp-based frame
.text$mn:00005394
.text$mn:00005394 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00005394                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00005394 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00005394                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00005394                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00005394
.text$mn:00005394 var_C           = dword ptr -0Ch
.text$mn:00005394 var_8           = dword ptr -8
.text$mn:00005394 var_2           = byte ptr -2
.text$mn:00005394 var_1           = byte ptr -1
.text$mn:00005394 arg_0           = byte ptr  8
.text$mn:00005394 Size            = dword ptr  0Ch
.text$mn:00005394
.text$mn:00005394                 push    ebp
.text$mn:00005395                 mov     ebp, esp
.text$mn:00005397                 sub     esp, 0Ch
.text$mn:0000539A                 mov     [ebp+var_8], ecx
.text$mn:0000539D                 movzx   eax, [ebp+arg_0]
.text$mn:000053A1                 test    eax, eax
.text$mn:000053A3                 jnz     short loc_53A7
.text$mn:000053A5                 jmp     short loc_541A
.text$mn:000053A7 ; ---------------------------------------------------------------------------
.text$mn:000053A7
.text$mn:000053A7 loc_53A7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:000053A7                 mov     ecx, [ebp+var_8]
.text$mn:000053AA                 cmp     dword ptr [ecx+18h], 10h
.text$mn:000053AE                 jb      short loc_541A
.text$mn:000053B0                 mov     edx, [ebp+var_8]
.text$mn:000053B3                 mov     eax, [edx+4]
.text$mn:000053B6                 mov     [ebp+var_C], eax
.text$mn:000053B9                 mov     ecx, [ebp+var_8]
.text$mn:000053BC                 add     ecx, 4
.text$mn:000053BF                 push    ecx
.text$mn:000053C0                 lea     edx, [ebp+var_1]
.text$mn:000053C3                 push    edx
.text$mn:000053C4                 mov     ecx, [ebp+var_8]
.text$mn:000053C7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000053CC                 mov     ecx, eax
.text$mn:000053CE                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000053D3                 cmp     [ebp+Size], 0
.text$mn:000053D7                 jbe     short loc_53F9
.text$mn:000053D9                 mov     eax, [ebp+Size]
.text$mn:000053DC                 push    eax             ; Size
.text$mn:000053DD                 mov     ecx, [ebp+var_C]
.text$mn:000053E0                 push    ecx
.text$mn:000053E1                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000053E6                 add     esp, 4
.text$mn:000053E9                 push    eax             ; Src
.text$mn:000053EA                 mov     edx, [ebp+var_8]
.text$mn:000053ED                 add     edx, 4
.text$mn:000053F0                 push    edx             ; Dst
.text$mn:000053F1                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000053F6                 add     esp, 0Ch
.text$mn:000053F9
.text$mn:000053F9 loc_53F9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:000053F9                 mov     eax, [ebp+var_8]
.text$mn:000053FC                 mov     ecx, [eax+18h]
.text$mn:000053FF                 add     ecx, 1
.text$mn:00005402                 push    ecx             ; int
.text$mn:00005403                 mov     edx, [ebp+var_C]
.text$mn:00005406                 push    edx             ; void *
.text$mn:00005407                 lea     eax, [ebp+var_2]
.text$mn:0000540A                 push    eax
.text$mn:0000540B                 mov     ecx, [ebp+var_8]
.text$mn:0000540E                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00005413                 mov     ecx, eax
.text$mn:00005415                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:0000541A
.text$mn:0000541A loc_541A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:0000541A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:0000541A                 mov     ecx, [ebp+var_8]
.text$mn:0000541D                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00005424                 mov     edx, [ebp+Size]
.text$mn:00005427                 push    edx
.text$mn:00005428                 mov     ecx, [ebp+var_8]
.text$mn:0000542B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00005430                 mov     esp, ebp
.text$mn:00005432                 pop     ebp
.text$mn:00005433                 retn    8
.text$mn:00005433 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00005433
.text$mn:00005433 ; ---------------------------------------------------------------------------
.text$mn:00005436                 align 4
.text$mn:00005436 _text$mn        ends
.text$mn:00005436
.text$mn:00005438 ; ===========================================================================
.text$mn:00005438
.text$mn:00005438 ; Segment type: Pure code
.text$mn:00005438 ; Segment permissions: Read/Execute
.text$mn:00005438 _text$mn        segment para public 'CODE' use32
.text$mn:00005438                 assume cs:_text$mn
.text$mn:00005438                 ;org 5438h
.text$mn:00005438 ; COMDAT (pick any)
.text$mn:00005438                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005438
.text$mn:00005438 ; =============== S U B R O U T I N E =======================================
.text$mn:00005438
.text$mn:00005438 ; Attributes: bp-based frame
.text$mn:00005438
.text$mn:00005438 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:00005438                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:00005438 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:00005438                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+56p
.text$mn:00005438                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+47p ...
.text$mn:00005438
.text$mn:00005438 var_C           = dword ptr -0Ch
.text$mn:00005438 var_8           = dword ptr -8
.text$mn:00005438 var_2           = byte ptr -2
.text$mn:00005438 var_1           = byte ptr -1
.text$mn:00005438 arg_0           = byte ptr  8
.text$mn:00005438 arg_4           = dword ptr  0Ch
.text$mn:00005438
.text$mn:00005438                 push    ebp
.text$mn:00005439                 mov     ebp, esp
.text$mn:0000543B                 sub     esp, 0Ch
.text$mn:0000543E                 mov     [ebp+var_8], ecx
.text$mn:00005441                 movzx   eax, [ebp+arg_0]
.text$mn:00005445                 test    eax, eax
.text$mn:00005447                 jnz     short loc_544B
.text$mn:00005449                 jmp     short loc_54BE
.text$mn:0000544B ; ---------------------------------------------------------------------------
.text$mn:0000544B
.text$mn:0000544B loc_544B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:0000544B                 mov     ecx, [ebp+var_8]
.text$mn:0000544E                 cmp     dword ptr [ecx+18h], 8
.text$mn:00005452                 jb      short loc_54BE
.text$mn:00005454                 mov     edx, [ebp+var_8]
.text$mn:00005457                 mov     eax, [edx+4]
.text$mn:0000545A                 mov     [ebp+var_C], eax
.text$mn:0000545D                 mov     ecx, [ebp+var_8]
.text$mn:00005460                 add     ecx, 4
.text$mn:00005463                 push    ecx
.text$mn:00005464                 lea     edx, [ebp+var_1]
.text$mn:00005467                 push    edx
.text$mn:00005468                 mov     ecx, [ebp+var_8]
.text$mn:0000546B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00005470                 mov     ecx, eax
.text$mn:00005472                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00005477                 cmp     [ebp+arg_4], 0
.text$mn:0000547B                 jbe     short loc_549D
.text$mn:0000547D                 mov     eax, [ebp+arg_4]
.text$mn:00005480                 push    eax             ; int
.text$mn:00005481                 mov     ecx, [ebp+var_C]
.text$mn:00005484                 push    ecx
.text$mn:00005485                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000548A                 add     esp, 4
.text$mn:0000548D                 push    eax             ; Src
.text$mn:0000548E                 mov     edx, [ebp+var_8]
.text$mn:00005491                 add     edx, 4
.text$mn:00005494                 push    edx             ; Dst
.text$mn:00005495                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000549A                 add     esp, 0Ch
.text$mn:0000549D
.text$mn:0000549D loc_549D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:0000549D                 mov     eax, [ebp+var_8]
.text$mn:000054A0                 mov     ecx, [eax+18h]
.text$mn:000054A3                 add     ecx, 1
.text$mn:000054A6                 push    ecx             ; int
.text$mn:000054A7                 mov     edx, [ebp+var_C]
.text$mn:000054AA                 push    edx             ; void *
.text$mn:000054AB                 lea     eax, [ebp+var_2]
.text$mn:000054AE                 push    eax
.text$mn:000054AF                 mov     ecx, [ebp+var_8]
.text$mn:000054B2                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000054B7                 mov     ecx, eax
.text$mn:000054B9                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:000054BE
.text$mn:000054BE loc_54BE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:000054BE                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:000054BE                 mov     ecx, [ebp+var_8]
.text$mn:000054C1                 mov     dword ptr [ecx+18h], 7
.text$mn:000054C8                 mov     edx, [ebp+arg_4]
.text$mn:000054CB                 push    edx
.text$mn:000054CC                 mov     ecx, [ebp+var_8]
.text$mn:000054CF                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000054D4                 mov     esp, ebp
.text$mn:000054D6                 pop     ebp
.text$mn:000054D7                 retn    8
.text$mn:000054D7 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:000054D7
.text$mn:000054D7 ; ---------------------------------------------------------------------------
.text$mn:000054DA                 align 4
.text$mn:000054DA _text$mn        ends
.text$mn:000054DA
.text$mn:000054DC ; ===========================================================================
.text$mn:000054DC
.text$mn:000054DC ; Segment type: Pure code
.text$mn:000054DC ; Segment permissions: Read/Execute
.text$mn:000054DC _text$mn        segment para public 'CODE' use32
.text$mn:000054DC                 assume cs:_text$mn
.text$mn:000054DC                 ;org 54DCh
.text$mn:000054DC ; COMDAT (pick any)
.text$mn:000054DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000054DC
.text$mn:000054DC ; =============== S U B R O U T I N E =======================================
.text$mn:000054DC
.text$mn:000054DC ; Attributes: bp-based frame
.text$mn:000054DC
.text$mn:000054DC ; protected: void __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::_Tidy(void)
.text$mn:000054DC                 public ?_Tidy@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXXZ
.text$mn:000054DC ?_Tidy@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXXZ proc near
.text$mn:000054DC                                         ; CODE XREF: __catch$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$0+3p
.text$mn:000054DC                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::~vector<TreeStateNode,std::allocator<TreeStateNode>>(void)+30p
.text$mn:000054DC
.text$mn:000054DC var_8           = dword ptr -8
.text$mn:000054DC var_1           = byte ptr -1
.text$mn:000054DC
.text$mn:000054DC                 push    ebp
.text$mn:000054DD                 mov     ebp, esp
.text$mn:000054DF                 sub     esp, 8
.text$mn:000054E2                 mov     [ebp+var_8], ecx
.text$mn:000054E5                 mov     eax, [ebp+var_8]
.text$mn:000054E8                 cmp     dword ptr [eax+4], 0
.text$mn:000054EC                 jz      short loc_555B
.text$mn:000054EE                 mov     ecx, [ebp+var_8] ; this
.text$mn:000054F1                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000054F6                 mov     ecx, [ebp+var_8]
.text$mn:000054F9                 mov     edx, [ecx+8]
.text$mn:000054FC                 push    edx
.text$mn:000054FD                 mov     eax, [ebp+var_8]
.text$mn:00005500                 mov     ecx, [eax+4]
.text$mn:00005503                 push    ecx
.text$mn:00005504                 mov     ecx, [ebp+var_8]
.text$mn:00005507                 call    ?_Destroy@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXPAUTreeStateNode@@0@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Destroy(TreeStateNode *,TreeStateNode *)
.text$mn:0000550C                 mov     edx, [ebp+var_8]
.text$mn:0000550F                 mov     eax, [ebp+var_8]
.text$mn:00005512                 mov     ecx, [edx+0Ch]
.text$mn:00005515                 sub     ecx, [eax+4]
.text$mn:00005518                 mov     eax, ecx
.text$mn:0000551A                 cdq
.text$mn:0000551B                 mov     ecx, 4Ch ; 'L'
.text$mn:00005520                 idiv    ecx
.text$mn:00005522                 push    eax             ; int
.text$mn:00005523                 mov     edx, [ebp+var_8]
.text$mn:00005526                 mov     eax, [edx+4]
.text$mn:00005529                 push    eax             ; void *
.text$mn:0000552A                 lea     ecx, [ebp+var_1]
.text$mn:0000552D                 push    ecx
.text$mn:0000552E                 mov     ecx, [ebp+var_8]
.text$mn:00005531                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Getal(void)
.text$mn:00005536                 mov     ecx, eax
.text$mn:00005538                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@I@Z ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::deallocate(TreeStateNode *,uint)
.text$mn:0000553D                 mov     edx, [ebp+var_8]
.text$mn:00005540                 mov     dword ptr [edx+4], 0
.text$mn:00005547                 mov     eax, [ebp+var_8]
.text$mn:0000554A                 mov     dword ptr [eax+8], 0
.text$mn:00005551                 mov     ecx, [ebp+var_8]
.text$mn:00005554                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000555B
.text$mn:0000555B loc_555B:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Tidy(void)+10j
.text$mn:0000555B                 mov     esp, ebp
.text$mn:0000555D                 pop     ebp
.text$mn:0000555E                 retn
.text$mn:0000555E ?_Tidy@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXXZ endp
.text$mn:0000555E
.text$mn:0000555E ; ---------------------------------------------------------------------------
.text$mn:0000555F                 align 10h
.text$mn:0000555F _text$mn        ends
.text$mn:0000555F
.text$mn:00005560 ; ===========================================================================
.text$mn:00005560
.text$mn:00005560 ; Segment type: Pure code
.text$mn:00005560 ; Segment permissions: Read/Execute
.text$mn:00005560 _text$mn        segment para public 'CODE' use32
.text$mn:00005560                 assume cs:_text$mn
.text$mn:00005560                 ;org 5560h
.text$mn:00005560 ; COMDAT (pick any)
.text$mn:00005560                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005560
.text$mn:00005560 ; =============== S U B R O U T I N E =======================================
.text$mn:00005560
.text$mn:00005560 ; Attributes: bp-based frame
.text$mn:00005560
.text$mn:00005560 ; public: struct TreeStateNode const * __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>>::_Unchecked(void)const
.text$mn:00005560                 public ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QBEPBUTreeStateNode@@XZ
.text$mn:00005560 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QBEPBUTreeStateNode@@XZ proc near
.text$mn:00005560                                         ; CODE XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>)+2Dp
.text$mn:00005560
.text$mn:00005560 var_4           = dword ptr -4
.text$mn:00005560
.text$mn:00005560                 push    ebp
.text$mn:00005561                 mov     ebp, esp
.text$mn:00005563                 push    ecx
.text$mn:00005564                 mov     [ebp+var_4], ecx
.text$mn:00005567                 mov     eax, [ebp+var_4]
.text$mn:0000556A                 mov     eax, [eax+8]
.text$mn:0000556D                 mov     esp, ebp
.text$mn:0000556F                 pop     ebp
.text$mn:00005570                 retn
.text$mn:00005570 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QBEPBUTreeStateNode@@XZ endp
.text$mn:00005570
.text$mn:00005570 ; ---------------------------------------------------------------------------
.text$mn:00005571                 align 4
.text$mn:00005571 _text$mn        ends
.text$mn:00005571
.text$mn:00005574 ; ===========================================================================
.text$mn:00005574
.text$mn:00005574 ; Segment type: Pure code
.text$mn:00005574 ; Segment permissions: Read/Execute
.text$mn:00005574 _text$mn        segment para public 'CODE' use32
.text$mn:00005574                 assume cs:_text$mn
.text$mn:00005574                 ;org 5574h
.text$mn:00005574 ; COMDAT (pick any)
.text$mn:00005574                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005574
.text$mn:00005574 ; =============== S U B R O U T I N E =======================================
.text$mn:00005574
.text$mn:00005574 ; Attributes: bp-based frame
.text$mn:00005574
.text$mn:00005574 ; public: unsigned int __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::_Unused_capacity(void)const
.text$mn:00005574                 public ?_Unused_capacity@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ
.text$mn:00005574 ?_Unused_capacity@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ proc near
.text$mn:00005574                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reserve(uint)+Bp
.text$mn:00005574
.text$mn:00005574 var_4           = dword ptr -4
.text$mn:00005574
.text$mn:00005574                 push    ebp
.text$mn:00005575                 mov     ebp, esp
.text$mn:00005577                 push    ecx
.text$mn:00005578                 mov     [ebp+var_4], ecx
.text$mn:0000557B                 mov     eax, [ebp+var_4]
.text$mn:0000557E                 mov     ecx, [ebp+var_4]
.text$mn:00005581                 mov     eax, [eax+0Ch]
.text$mn:00005584                 sub     eax, [ecx+8]
.text$mn:00005587                 cdq
.text$mn:00005588                 mov     ecx, 4Ch ; 'L'
.text$mn:0000558D                 idiv    ecx
.text$mn:0000558F                 mov     esp, ebp
.text$mn:00005591                 pop     ebp
.text$mn:00005592                 retn
.text$mn:00005592 ?_Unused_capacity@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ endp
.text$mn:00005592
.text$mn:00005592 ; ---------------------------------------------------------------------------
.text$mn:00005593                 align 4
.text$mn:00005593 _text$mn        ends
.text$mn:00005593
.text$mn:00005594 ; ===========================================================================
.text$mn:00005594
.text$mn:00005594 ; Segment type: Pure code
.text$mn:00005594 ; Segment permissions: Read/Execute
.text$mn:00005594 _text$mn        segment para public 'CODE' use32
.text$mn:00005594                 assume cs:_text$mn
.text$mn:00005594                 ;org 5594h
.text$mn:00005594 ; COMDAT (pick any)
.text$mn:00005594                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005594
.text$mn:00005594 ; =============== S U B R O U T I N E =======================================
.text$mn:00005594
.text$mn:00005594 ; Attributes: bp-based frame
.text$mn:00005594
.text$mn:00005594 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00005594                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00005594 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00005594                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00005594
.text$mn:00005594 var_4           = dword ptr -4
.text$mn:00005594
.text$mn:00005594                 push    ebp
.text$mn:00005595                 mov     ebp, esp
.text$mn:00005597                 push    ecx
.text$mn:00005598                 mov     [ebp+var_4], ecx
.text$mn:0000559B                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000055A0                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000055A5                 mov     esp, ebp
.text$mn:000055A7                 pop     ebp
.text$mn:000055A8                 retn
.text$mn:000055A8 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000055A8
.text$mn:000055A8 ; ---------------------------------------------------------------------------
.text$mn:000055A9                 align 4
.text$mn:000055A9 _text$mn        ends
.text$mn:000055A9
.text$mn:000055AC ; ===========================================================================
.text$mn:000055AC
.text$mn:000055AC ; Segment type: Pure code
.text$mn:000055AC ; Segment permissions: Read/Execute
.text$mn:000055AC _text$mn        segment para public 'CODE' use32
.text$mn:000055AC                 assume cs:_text$mn
.text$mn:000055AC                 ;org 55ACh
.text$mn:000055AC ; COMDAT (pick any)
.text$mn:000055AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000055AC
.text$mn:000055AC ; =============== S U B R O U T I N E =======================================
.text$mn:000055AC
.text$mn:000055AC ; Attributes: bp-based frame
.text$mn:000055AC
.text$mn:000055AC ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:000055AC                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:000055AC ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:000055AC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:000055AC
.text$mn:000055AC var_4           = dword ptr -4
.text$mn:000055AC
.text$mn:000055AC                 push    ebp
.text$mn:000055AD                 mov     ebp, esp
.text$mn:000055AF                 push    ecx
.text$mn:000055B0                 mov     [ebp+var_4], ecx
.text$mn:000055B3                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000055B8                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000055BD                 mov     esp, ebp
.text$mn:000055BF                 pop     ebp
.text$mn:000055C0                 retn
.text$mn:000055C0 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:000055C0
.text$mn:000055C0 ; ---------------------------------------------------------------------------
.text$mn:000055C1                 align 4
.text$mn:000055C1 _text$mn        ends
.text$mn:000055C1
.text$mn:000055C4 ; ===========================================================================
.text$mn:000055C4
.text$mn:000055C4 ; Segment type: Pure code
.text$mn:000055C4 ; Segment permissions: Read/Execute
.text$mn:000055C4 _text$mn        segment para public 'CODE' use32
.text$mn:000055C4                 assume cs:_text$mn
.text$mn:000055C4                 ;org 55C4h
.text$mn:000055C4 ; COMDAT (pick any)
.text$mn:000055C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000055C4
.text$mn:000055C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000055C4
.text$mn:000055C4 ; Attributes: bp-based frame
.text$mn:000055C4
.text$mn:000055C4 ; protected: void __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::_Xlen(void)const
.text$mn:000055C4                 public ?_Xlen@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXXZ
.text$mn:000055C4 ?_Xlen@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXXZ proc near
.text$mn:000055C4                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Buy(uint)+43p
.text$mn:000055C4                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reserve(uint)+31p
.text$mn:000055C4
.text$mn:000055C4 var_4           = dword ptr -4
.text$mn:000055C4
.text$mn:000055C4                 push    ebp
.text$mn:000055C5                 mov     ebp, esp
.text$mn:000055C7                 push    ecx
.text$mn:000055C8                 mov     [ebp+var_4], ecx
.text$mn:000055CB                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:000055D0                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000055D5                 mov     esp, ebp
.text$mn:000055D7                 pop     ebp
.text$mn:000055D8                 retn
.text$mn:000055D8 ?_Xlen@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXXZ endp
.text$mn:000055D8
.text$mn:000055D8 ; ---------------------------------------------------------------------------
.text$mn:000055D9                 align 4
.text$mn:000055D9 _text$mn        ends
.text$mn:000055D9
.text$mn:000055DC ; ===========================================================================
.text$mn:000055DC
.text$mn:000055DC ; Segment type: Pure code
.text$mn:000055DC ; Segment permissions: Read/Execute
.text$mn:000055DC _text$mn        segment para public 'CODE' use32
.text$mn:000055DC                 assume cs:_text$mn
.text$mn:000055DC                 ;org 55DCh
.text$mn:000055DC ; COMDAT (pick any)
.text$mn:000055DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000055DC
.text$mn:000055DC ; =============== S U B R O U T I N E =======================================
.text$mn:000055DC
.text$mn:000055DC ; Attributes: bp-based frame
.text$mn:000055DC
.text$mn:000055DC ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000055DC                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000055DC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000055DC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000055DC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:000055DC
.text$mn:000055DC var_4           = dword ptr -4
.text$mn:000055DC
.text$mn:000055DC                 push    ebp
.text$mn:000055DD                 mov     ebp, esp
.text$mn:000055DF                 push    ecx
.text$mn:000055E0                 mov     [ebp+var_4], ecx
.text$mn:000055E3                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000055E8                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000055ED                 mov     esp, ebp
.text$mn:000055EF                 pop     ebp
.text$mn:000055F0                 retn
.text$mn:000055F0 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000055F0
.text$mn:000055F0 ; ---------------------------------------------------------------------------
.text$mn:000055F1                 align 4
.text$mn:000055F1 _text$mn        ends
.text$mn:000055F1
.text$mn:000055F4 ; ===========================================================================
.text$mn:000055F4
.text$mn:000055F4 ; Segment type: Pure code
.text$mn:000055F4 ; Segment permissions: Read/Execute
.text$mn:000055F4 _text$mn        segment para public 'CODE' use32
.text$mn:000055F4                 assume cs:_text$mn
.text$mn:000055F4                 ;org 55F4h
.text$mn:000055F4 ; COMDAT (pick any)
.text$mn:000055F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000055F4
.text$mn:000055F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000055F4
.text$mn:000055F4 ; Attributes: bp-based frame
.text$mn:000055F4
.text$mn:000055F4 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:000055F4                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:000055F4 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:000055F4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:000055F4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+33p ...
.text$mn:000055F4
.text$mn:000055F4 var_4           = dword ptr -4
.text$mn:000055F4
.text$mn:000055F4                 push    ebp
.text$mn:000055F5                 mov     ebp, esp
.text$mn:000055F7                 push    ecx
.text$mn:000055F8                 mov     [ebp+var_4], ecx
.text$mn:000055FB                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00005600                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00005605                 mov     esp, ebp
.text$mn:00005607                 pop     ebp
.text$mn:00005608                 retn
.text$mn:00005608 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00005608
.text$mn:00005608 ; ---------------------------------------------------------------------------
.text$mn:00005609                 align 4
.text$mn:00005609 _text$mn        ends
.text$mn:00005609
.text$mn:0000560C ; ===========================================================================
.text$mn:0000560C
.text$mn:0000560C ; Segment type: Pure code
.text$mn:0000560C ; Segment permissions: Read/Execute
.text$mn:0000560C _text$mn        segment para public 'CODE' use32
.text$mn:0000560C                 assume cs:_text$mn
.text$mn:0000560C                 ;org 560Ch
.text$mn:0000560C ; COMDAT (pick any)
.text$mn:0000560C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000560C
.text$mn:0000560C ; =============== S U B R O U T I N E =======================================
.text$mn:0000560C
.text$mn:0000560C ; Attributes: bp-based frame
.text$mn:0000560C
.text$mn:0000560C ; protected: void __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::_Xran(void)const
.text$mn:0000560C                 public ?_Xran@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXXZ
.text$mn:0000560C ?_Xran@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXXZ proc near
.text$mn:0000560C                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::at(uint)+17p
.text$mn:0000560C                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::at(uint)+17p
.text$mn:0000560C
.text$mn:0000560C var_4           = dword ptr -4
.text$mn:0000560C
.text$mn:0000560C                 push    ebp
.text$mn:0000560D                 mov     ebp, esp
.text$mn:0000560F                 push    ecx
.text$mn:00005610                 mov     [ebp+var_4], ecx
.text$mn:00005613                 push    offset ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; "invalid vector<T> subscript"
.text$mn:00005618                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:0000561D                 mov     esp, ebp
.text$mn:0000561F                 pop     ebp
.text$mn:00005620                 retn
.text$mn:00005620 ?_Xran@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXXZ endp
.text$mn:00005620
.text$mn:00005620 ; ---------------------------------------------------------------------------
.text$mn:00005621                 align 4
.text$mn:00005621 _text$mn        ends
.text$mn:00005621
.text$mn:00005624 ; ===========================================================================
.text$mn:00005624
.text$mn:00005624 ; Segment type: Pure code
.text$mn:00005624 ; Segment permissions: Read/Execute
.text$mn:00005624 _text$mn        segment para public 'CODE' use32
.text$mn:00005624                 assume cs:_text$mn
.text$mn:00005624                 ;org 5624h
.text$mn:00005624 ; COMDAT (pick any)
.text$mn:00005624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005624
.text$mn:00005624 ; =============== S U B R O U T I N E =======================================
.text$mn:00005624
.text$mn:00005624 ; Attributes: bp-based frame
.text$mn:00005624
.text$mn:00005624 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00005624                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00005624 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00005624                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00005624                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00005624
.text$mn:00005624 var_4           = dword ptr -4
.text$mn:00005624 arg_0           = dword ptr  8
.text$mn:00005624
.text$mn:00005624                 push    ebp
.text$mn:00005625                 mov     ebp, esp
.text$mn:00005627                 push    ecx
.text$mn:00005628                 mov     [ebp+var_4], ecx
.text$mn:0000562B                 mov     eax, [ebp+arg_0]
.text$mn:0000562E                 push    eax
.text$mn:0000562F                 mov     ecx, [ebp+var_4]
.text$mn:00005632                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00005637                 mov     esp, ebp
.text$mn:00005639                 pop     ebp
.text$mn:0000563A                 retn    4
.text$mn:0000563A ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:0000563A
.text$mn:0000563A ; ---------------------------------------------------------------------------
.text$mn:0000563D                 align 10h
.text$mn:0000563D _text$mn        ends
.text$mn:0000563D
.text$mn:00005640 ; ===========================================================================
.text$mn:00005640
.text$mn:00005640 ; Segment type: Pure code
.text$mn:00005640 ; Segment permissions: Read/Execute
.text$mn:00005640 _text$mn        segment para public 'CODE' use32
.text$mn:00005640                 assume cs:_text$mn
.text$mn:00005640                 ;org 5640h
.text$mn:00005640 ; COMDAT (pick any)
.text$mn:00005640                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005640
.text$mn:00005640 ; =============== S U B R O U T I N E =======================================
.text$mn:00005640
.text$mn:00005640 ; Attributes: bp-based frame
.text$mn:00005640
.text$mn:00005640 ; public: struct TreeStateNode * __thiscall std::_Wrap_alloc<class std::allocator<struct TreeStateNode>>::allocate(unsigned int)
.text$mn:00005640                 public ?allocate@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEPAUTreeStateNode@@I@Z
.text$mn:00005640 ?allocate@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEPAUTreeStateNode@@I@Z proc near
.text$mn:00005640                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Buy(uint)+5Cp
.text$mn:00005640                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reallocate(uint)+41p
.text$mn:00005640
.text$mn:00005640 var_4           = dword ptr -4
.text$mn:00005640 arg_0           = dword ptr  8
.text$mn:00005640
.text$mn:00005640                 push    ebp
.text$mn:00005641                 mov     ebp, esp
.text$mn:00005643                 push    ecx
.text$mn:00005644                 mov     [ebp+var_4], ecx
.text$mn:00005647                 mov     eax, [ebp+arg_0]
.text$mn:0000564A                 push    eax
.text$mn:0000564B                 mov     ecx, [ebp+var_4]
.text$mn:0000564E                 call    ?allocate@?$allocator@UTreeStateNode@@@std@@QAEPAUTreeStateNode@@I@Z ; std::allocator<TreeStateNode>::allocate(uint)
.text$mn:00005653                 mov     esp, ebp
.text$mn:00005655                 pop     ebp
.text$mn:00005656                 retn    4
.text$mn:00005656 ?allocate@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEPAUTreeStateNode@@I@Z endp
.text$mn:00005656
.text$mn:00005656 ; ---------------------------------------------------------------------------
.text$mn:00005659                 align 4
.text$mn:00005659 _text$mn        ends
.text$mn:00005659
.text$mn:0000565C ; ===========================================================================
.text$mn:0000565C
.text$mn:0000565C ; Segment type: Pure code
.text$mn:0000565C ; Segment permissions: Read/Execute
.text$mn:0000565C _text$mn        segment para public 'CODE' use32
.text$mn:0000565C                 assume cs:_text$mn
.text$mn:0000565C                 ;org 565Ch
.text$mn:0000565C ; COMDAT (pick any)
.text$mn:0000565C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000565C
.text$mn:0000565C ; =============== S U B R O U T I N E =======================================
.text$mn:0000565C
.text$mn:0000565C ; Attributes: bp-based frame
.text$mn:0000565C
.text$mn:0000565C ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:0000565C                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:0000565C ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:0000565C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Alloc_proxy(void)+16p
.text$mn:0000565C
.text$mn:0000565C var_4           = dword ptr -4
.text$mn:0000565C arg_0           = dword ptr  8
.text$mn:0000565C
.text$mn:0000565C                 push    ebp
.text$mn:0000565D                 mov     ebp, esp
.text$mn:0000565F                 push    ecx
.text$mn:00005660                 mov     [ebp+var_4], ecx
.text$mn:00005663                 mov     eax, [ebp+arg_0]
.text$mn:00005666                 push    eax
.text$mn:00005667                 mov     ecx, [ebp+var_4]
.text$mn:0000566A                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:0000566F                 mov     esp, ebp
.text$mn:00005671                 pop     ebp
.text$mn:00005672                 retn    4
.text$mn:00005672 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00005672
.text$mn:00005672 ; ---------------------------------------------------------------------------
.text$mn:00005675                 align 4
.text$mn:00005675 _text$mn        ends
.text$mn:00005675
.text$mn:00005678 ; ===========================================================================
.text$mn:00005678
.text$mn:00005678 ; Segment type: Pure code
.text$mn:00005678 ; Segment permissions: Read/Execute
.text$mn:00005678 _text$mn        segment para public 'CODE' use32
.text$mn:00005678                 assume cs:_text$mn
.text$mn:00005678                 ;org 5678h
.text$mn:00005678 ; COMDAT (pick any)
.text$mn:00005678                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005678
.text$mn:00005678 ; =============== S U B R O U T I N E =======================================
.text$mn:00005678
.text$mn:00005678 ; Attributes: bp-based frame
.text$mn:00005678
.text$mn:00005678 ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:00005678                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:00005678 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:00005678                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:00005678                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:00005678
.text$mn:00005678 var_4           = dword ptr -4
.text$mn:00005678 arg_0           = dword ptr  8
.text$mn:00005678
.text$mn:00005678                 push    ebp
.text$mn:00005679                 mov     ebp, esp
.text$mn:0000567B                 push    ecx
.text$mn:0000567C                 mov     [ebp+var_4], ecx
.text$mn:0000567F                 mov     eax, [ebp+arg_0]
.text$mn:00005682                 push    eax
.text$mn:00005683                 mov     ecx, [ebp+var_4]
.text$mn:00005686                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:0000568B                 mov     esp, ebp
.text$mn:0000568D                 pop     ebp
.text$mn:0000568E                 retn    4
.text$mn:0000568E ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:0000568E
.text$mn:0000568E ; ---------------------------------------------------------------------------
.text$mn:00005691                 align 4
.text$mn:00005691 _text$mn        ends
.text$mn:00005691
.text$mn:00005694 ; ===========================================================================
.text$mn:00005694
.text$mn:00005694 ; Segment type: Pure code
.text$mn:00005694 ; Segment permissions: Read/Execute
.text$mn:00005694 _text$mn        segment para public 'CODE' use32
.text$mn:00005694                 assume cs:_text$mn
.text$mn:00005694                 ;org 5694h
.text$mn:00005694 ; COMDAT (pick any)
.text$mn:00005694                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005694
.text$mn:00005694 ; =============== S U B R O U T I N E =======================================
.text$mn:00005694
.text$mn:00005694 ; Attributes: bp-based frame
.text$mn:00005694
.text$mn:00005694 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00005694                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00005694 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00005694                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00005694
.text$mn:00005694 var_4           = dword ptr -4
.text$mn:00005694 arg_0           = dword ptr  8
.text$mn:00005694
.text$mn:00005694                 push    ebp
.text$mn:00005695                 mov     ebp, esp
.text$mn:00005697                 push    ecx
.text$mn:00005698                 mov     [ebp+var_4], ecx
.text$mn:0000569B                 push    0
.text$mn:0000569D                 mov     eax, [ebp+arg_0]
.text$mn:000056A0                 push    eax
.text$mn:000056A1                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:000056A6                 add     esp, 8
.text$mn:000056A9                 mov     esp, ebp
.text$mn:000056AB                 pop     ebp
.text$mn:000056AC                 retn    4
.text$mn:000056AC ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:000056AC
.text$mn:000056AC ; ---------------------------------------------------------------------------
.text$mn:000056AF                 align 10h
.text$mn:000056AF _text$mn        ends
.text$mn:000056AF
.text$mn:000056B0 ; ===========================================================================
.text$mn:000056B0
.text$mn:000056B0 ; Segment type: Pure code
.text$mn:000056B0 ; Segment permissions: Read/Execute
.text$mn:000056B0 _text$mn        segment para public 'CODE' use32
.text$mn:000056B0                 assume cs:_text$mn
.text$mn:000056B0                 ;org 56B0h
.text$mn:000056B0 ; COMDAT (pick any)
.text$mn:000056B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000056B0
.text$mn:000056B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000056B0
.text$mn:000056B0 ; Attributes: bp-based frame
.text$mn:000056B0
.text$mn:000056B0 ; public: struct TreeStateNode * __thiscall std::allocator<struct TreeStateNode>::allocate(unsigned int)
.text$mn:000056B0                 public ?allocate@?$allocator@UTreeStateNode@@@std@@QAEPAUTreeStateNode@@I@Z
.text$mn:000056B0 ?allocate@?$allocator@UTreeStateNode@@@std@@QAEPAUTreeStateNode@@I@Z proc near
.text$mn:000056B0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TreeStateNode>>::allocate(uint)+Ep
.text$mn:000056B0
.text$mn:000056B0 var_4           = dword ptr -4
.text$mn:000056B0 arg_0           = dword ptr  8
.text$mn:000056B0
.text$mn:000056B0                 push    ebp
.text$mn:000056B1                 mov     ebp, esp
.text$mn:000056B3                 push    ecx
.text$mn:000056B4                 mov     [ebp+var_4], ecx
.text$mn:000056B7                 push    0
.text$mn:000056B9                 mov     eax, [ebp+arg_0]
.text$mn:000056BC                 push    eax
.text$mn:000056BD                 call    ??$_Allocate@UTreeStateNode@@@std@@YAPAUTreeStateNode@@IPAU1@@Z ; std::_Allocate<TreeStateNode>(uint,TreeStateNode *)
.text$mn:000056C2                 add     esp, 8
.text$mn:000056C5                 mov     esp, ebp
.text$mn:000056C7                 pop     ebp
.text$mn:000056C8                 retn    4
.text$mn:000056C8 ?allocate@?$allocator@UTreeStateNode@@@std@@QAEPAUTreeStateNode@@I@Z endp
.text$mn:000056C8
.text$mn:000056C8 ; ---------------------------------------------------------------------------
.text$mn:000056CB                 align 4
.text$mn:000056CB _text$mn        ends
.text$mn:000056CB
.text$mn:000056CC ; ===========================================================================
.text$mn:000056CC
.text$mn:000056CC ; Segment type: Pure code
.text$mn:000056CC ; Segment permissions: Read/Execute
.text$mn:000056CC _text$mn        segment para public 'CODE' use32
.text$mn:000056CC                 assume cs:_text$mn
.text$mn:000056CC                 ;org 56CCh
.text$mn:000056CC ; COMDAT (pick any)
.text$mn:000056CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000056CC
.text$mn:000056CC ; =============== S U B R O U T I N E =======================================
.text$mn:000056CC
.text$mn:000056CC ; Attributes: bp-based frame
.text$mn:000056CC
.text$mn:000056CC ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:000056CC                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000056CC ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000056CC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:000056CC                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p ...
.text$mn:000056CC
.text$mn:000056CC var_4           = dword ptr -4
.text$mn:000056CC arg_0           = dword ptr  8
.text$mn:000056CC
.text$mn:000056CC                 push    ebp
.text$mn:000056CD                 mov     ebp, esp
.text$mn:000056CF                 push    ecx
.text$mn:000056D0                 mov     [ebp+var_4], ecx
.text$mn:000056D3                 push    0
.text$mn:000056D5                 mov     eax, [ebp+arg_0]
.text$mn:000056D8                 push    eax
.text$mn:000056D9                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:000056DE                 add     esp, 8
.text$mn:000056E1                 mov     esp, ebp
.text$mn:000056E3                 pop     ebp
.text$mn:000056E4                 retn    4
.text$mn:000056E4 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:000056E4
.text$mn:000056E4 ; ---------------------------------------------------------------------------
.text$mn:000056E7                 align 4
.text$mn:000056E7 _text$mn        ends
.text$mn:000056E7
.text$mn:000056E8 ; ===========================================================================
.text$mn:000056E8
.text$mn:000056E8 ; Segment type: Pure code
.text$mn:000056E8 ; Segment permissions: Read/Execute
.text$mn:000056E8 _text$mn        segment para public 'CODE' use32
.text$mn:000056E8                 assume cs:_text$mn
.text$mn:000056E8                 ;org 56E8h
.text$mn:000056E8 ; COMDAT (pick any)
.text$mn:000056E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000056E8
.text$mn:000056E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000056E8
.text$mn:000056E8 ; Attributes: bp-based frame
.text$mn:000056E8
.text$mn:000056E8 ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:000056E8                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:000056E8 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:000056E8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:000056E8
.text$mn:000056E8 var_4           = dword ptr -4
.text$mn:000056E8 arg_0           = dword ptr  8
.text$mn:000056E8
.text$mn:000056E8                 push    ebp
.text$mn:000056E9                 mov     ebp, esp
.text$mn:000056EB                 push    ecx
.text$mn:000056EC                 mov     [ebp+var_4], ecx
.text$mn:000056EF                 push    0
.text$mn:000056F1                 mov     eax, [ebp+arg_0]
.text$mn:000056F4                 push    eax
.text$mn:000056F5                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:000056FA                 add     esp, 8
.text$mn:000056FD                 mov     esp, ebp
.text$mn:000056FF                 pop     ebp
.text$mn:00005700                 retn    4
.text$mn:00005700 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:00005700
.text$mn:00005700 ; ---------------------------------------------------------------------------
.text$mn:00005703                 align 4
.text$mn:00005703 _text$mn        ends
.text$mn:00005703
.text$mn:00005704 ; ===========================================================================
.text$mn:00005704
.text$mn:00005704 ; Segment type: Pure code
.text$mn:00005704 ; Segment permissions: Read/Execute
.text$mn:00005704 _text$mn        segment para public 'CODE' use32
.text$mn:00005704                 assume cs:_text$mn
.text$mn:00005704                 ;org 5704h
.text$mn:00005704 ; COMDAT (pick any)
.text$mn:00005704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005704
.text$mn:00005704 ; =============== S U B R O U T I N E =======================================
.text$mn:00005704
.text$mn:00005704 ; Attributes: bp-based frame
.text$mn:00005704
.text$mn:00005704 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00005704                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00005704 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00005704                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00005704
.text$mn:00005704 Size            = dword ptr -8
.text$mn:00005704 var_4           = dword ptr -4
.text$mn:00005704 arg_0           = dword ptr  8
.text$mn:00005704 arg_4           = dword ptr  0Ch
.text$mn:00005704 arg_8           = dword ptr  10h
.text$mn:00005704
.text$mn:00005704                 push    ebp
.text$mn:00005705                 mov     ebp, esp
.text$mn:00005707                 sub     esp, 8
.text$mn:0000570A                 mov     [ebp+var_4], ecx
.text$mn:0000570D                 mov     ecx, [ebp+arg_0]
.text$mn:00005710                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00005715                 cmp     eax, [ebp+arg_4]
.text$mn:00005718                 jnb     short loc_5722
.text$mn:0000571A                 mov     ecx, [ebp+var_4]
.text$mn:0000571D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00005722
.text$mn:00005722 loc_5722:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00005722                 mov     ecx, [ebp+arg_0]
.text$mn:00005725                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000572A                 sub     eax, [ebp+arg_4]
.text$mn:0000572D                 mov     [ebp+Size], eax
.text$mn:00005730                 mov     eax, [ebp+arg_8]
.text$mn:00005733                 cmp     eax, [ebp+Size]
.text$mn:00005736                 jnb     short loc_573E
.text$mn:00005738                 mov     ecx, [ebp+arg_8]
.text$mn:0000573B                 mov     [ebp+Size], ecx
.text$mn:0000573E
.text$mn:0000573E loc_573E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000573E                 mov     edx, [ebp+var_4]
.text$mn:00005741                 cmp     edx, [ebp+arg_0]
.text$mn:00005744                 jnz     short loc_5765
.text$mn:00005746                 mov     eax, [ebp+arg_4]
.text$mn:00005749                 add     eax, [ebp+Size]
.text$mn:0000574C                 push    eax
.text$mn:0000574D                 mov     ecx, [ebp+var_4]
.text$mn:00005750                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00005755                 mov     ecx, [ebp+arg_4]
.text$mn:00005758                 push    ecx
.text$mn:00005759                 push    0
.text$mn:0000575B                 mov     ecx, [ebp+var_4]
.text$mn:0000575E                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00005763                 jmp     short loc_57A7
.text$mn:00005765 ; ---------------------------------------------------------------------------
.text$mn:00005765
.text$mn:00005765 loc_5765:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00005765                 push    0
.text$mn:00005767                 mov     edx, [ebp+Size]
.text$mn:0000576A                 push    edx
.text$mn:0000576B                 mov     ecx, [ebp+var_4]
.text$mn:0000576E                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00005773                 movzx   eax, al
.text$mn:00005776                 test    eax, eax
.text$mn:00005778                 jz      short loc_57A7
.text$mn:0000577A                 mov     ecx, [ebp+Size]
.text$mn:0000577D                 push    ecx             ; Size
.text$mn:0000577E                 mov     ecx, [ebp+arg_0]
.text$mn:00005781                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00005786                 add     eax, [ebp+arg_4]
.text$mn:00005789                 push    eax             ; Src
.text$mn:0000578A                 mov     ecx, [ebp+var_4]
.text$mn:0000578D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00005792                 push    eax             ; Dst
.text$mn:00005793                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00005798                 add     esp, 0Ch
.text$mn:0000579B                 mov     edx, [ebp+Size]
.text$mn:0000579E                 push    edx
.text$mn:0000579F                 mov     ecx, [ebp+var_4]
.text$mn:000057A2                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000057A7
.text$mn:000057A7 loc_57A7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000057A7                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000057A7                 mov     eax, [ebp+var_4]
.text$mn:000057AA                 mov     esp, ebp
.text$mn:000057AC                 pop     ebp
.text$mn:000057AD                 retn    0Ch
.text$mn:000057AD ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000057AD
.text$mn:000057AD _text$mn        ends
.text$mn:000057AD
.text$mn:000057B0 ; ===========================================================================
.text$mn:000057B0
.text$mn:000057B0 ; Segment type: Pure code
.text$mn:000057B0 ; Segment permissions: Read/Execute
.text$mn:000057B0 _text$mn        segment para public 'CODE' use32
.text$mn:000057B0                 assume cs:_text$mn
.text$mn:000057B0                 ;org 57B0h
.text$mn:000057B0 ; COMDAT (pick any)
.text$mn:000057B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000057B0
.text$mn:000057B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000057B0
.text$mn:000057B0 ; Attributes: bp-based frame
.text$mn:000057B0
.text$mn:000057B0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:000057B0                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:000057B0 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:000057B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:000057B0
.text$mn:000057B0 var_4           = dword ptr -4
.text$mn:000057B0 Str             = dword ptr  8
.text$mn:000057B0
.text$mn:000057B0                 push    ebp
.text$mn:000057B1                 mov     ebp, esp
.text$mn:000057B3                 push    ecx
.text$mn:000057B4                 mov     [ebp+var_4], ecx
.text$mn:000057B7                 push    490h            ; unsigned int
.text$mn:000057BC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000057C1                 mov     eax, [ebp+Str]
.text$mn:000057C4                 push    eax             ; int
.text$mn:000057C5                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000057CA                 add     esp, 0Ch
.text$mn:000057CD                 mov     ecx, [ebp+Str]
.text$mn:000057D0                 push    ecx             ; Str
.text$mn:000057D1                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:000057D6                 add     esp, 4
.text$mn:000057D9                 push    eax             ; Size
.text$mn:000057DA                 mov     edx, [ebp+Str]
.text$mn:000057DD                 push    edx             ; Src
.text$mn:000057DE                 mov     ecx, [ebp+var_4]
.text$mn:000057E1                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:000057E6                 mov     esp, ebp
.text$mn:000057E8                 pop     ebp
.text$mn:000057E9                 retn    4
.text$mn:000057E9 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:000057E9
.text$mn:000057E9 _text$mn        ends
.text$mn:000057E9
.text$mn:000057EC ; ===========================================================================
.text$mn:000057EC
.text$mn:000057EC ; Segment type: Pure code
.text$mn:000057EC ; Segment permissions: Read/Execute
.text$mn:000057EC _text$mn        segment para public 'CODE' use32
.text$mn:000057EC                 assume cs:_text$mn
.text$mn:000057EC                 ;org 57ECh
.text$mn:000057EC ; COMDAT (pick any)
.text$mn:000057EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000057EC
.text$mn:000057EC ; =============== S U B R O U T I N E =======================================
.text$mn:000057EC
.text$mn:000057EC ; Attributes: bp-based frame
.text$mn:000057EC
.text$mn:000057EC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:000057EC                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:000057EC ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:000057EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:000057EC
.text$mn:000057EC var_4           = dword ptr -4
.text$mn:000057EC Src             = dword ptr  8
.text$mn:000057EC Size            = dword ptr  0Ch
.text$mn:000057EC
.text$mn:000057EC                 push    ebp
.text$mn:000057ED                 mov     ebp, esp
.text$mn:000057EF                 push    ecx
.text$mn:000057F0                 mov     [ebp+var_4], ecx
.text$mn:000057F3                 cmp     [ebp+Size], 0
.text$mn:000057F7                 jz      short loc_580F
.text$mn:000057F9                 push    47Fh            ; unsigned int
.text$mn:000057FE                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005803                 mov     eax, [ebp+Src]
.text$mn:00005806                 push    eax             ; int
.text$mn:00005807                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000580C                 add     esp, 0Ch
.text$mn:0000580F
.text$mn:0000580F loc_580F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000580F                 mov     ecx, [ebp+Src]
.text$mn:00005812                 push    ecx
.text$mn:00005813                 mov     ecx, [ebp+var_4]
.text$mn:00005816                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000581B                 movzx   edx, al
.text$mn:0000581E                 test    edx, edx
.text$mn:00005820                 jz      short loc_5842
.text$mn:00005822                 mov     eax, [ebp+Size]
.text$mn:00005825                 push    eax
.text$mn:00005826                 mov     ecx, [ebp+var_4]
.text$mn:00005829                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000582E                 mov     ecx, [ebp+Src]
.text$mn:00005831                 sub     ecx, eax
.text$mn:00005833                 push    ecx
.text$mn:00005834                 mov     edx, [ebp+var_4]
.text$mn:00005837                 push    edx
.text$mn:00005838                 mov     ecx, [ebp+var_4]
.text$mn:0000583B                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00005840                 jmp     short loc_587F
.text$mn:00005842 ; ---------------------------------------------------------------------------
.text$mn:00005842
.text$mn:00005842 loc_5842:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00005842                 push    0
.text$mn:00005844                 mov     eax, [ebp+Size]
.text$mn:00005847                 push    eax
.text$mn:00005848                 mov     ecx, [ebp+var_4]
.text$mn:0000584B                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00005850                 movzx   ecx, al
.text$mn:00005853                 test    ecx, ecx
.text$mn:00005855                 jz      short loc_587C
.text$mn:00005857                 mov     edx, [ebp+Size]
.text$mn:0000585A                 push    edx             ; Size
.text$mn:0000585B                 mov     eax, [ebp+Src]
.text$mn:0000585E                 push    eax             ; Src
.text$mn:0000585F                 mov     ecx, [ebp+var_4]
.text$mn:00005862                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00005867                 push    eax             ; Dst
.text$mn:00005868                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000586D                 add     esp, 0Ch
.text$mn:00005870                 mov     ecx, [ebp+Size]
.text$mn:00005873                 push    ecx
.text$mn:00005874                 mov     ecx, [ebp+var_4]
.text$mn:00005877                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000587C
.text$mn:0000587C loc_587C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:0000587C                 mov     eax, [ebp+var_4]
.text$mn:0000587F
.text$mn:0000587F loc_587F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:0000587F                 mov     esp, ebp
.text$mn:00005881                 pop     ebp
.text$mn:00005882                 retn    8
.text$mn:00005882 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00005882
.text$mn:00005882 ; ---------------------------------------------------------------------------
.text$mn:00005885                 align 4
.text$mn:00005885 _text$mn        ends
.text$mn:00005885
.text$mn:00005888 ; ===========================================================================
.text$mn:00005888
.text$mn:00005888 ; Segment type: Pure code
.text$mn:00005888 ; Segment permissions: Read/Execute
.text$mn:00005888 _text$mn        segment para public 'CODE' use32
.text$mn:00005888                 assume cs:_text$mn
.text$mn:00005888                 ;org 5888h
.text$mn:00005888 ; COMDAT (pick any)
.text$mn:00005888                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005888
.text$mn:00005888 ; =============== S U B R O U T I N E =======================================
.text$mn:00005888
.text$mn:00005888 ; Attributes: bp-based frame
.text$mn:00005888
.text$mn:00005888 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00005888                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
.text$mn:00005888 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z proc near
.text$mn:00005888                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+66p
.text$mn:00005888
.text$mn:00005888 var_4           = dword ptr -4
.text$mn:00005888 arg_0           = dword ptr  8
.text$mn:00005888
.text$mn:00005888                 push    ebp
.text$mn:00005889                 mov     ebp, esp
.text$mn:0000588B                 push    ecx
.text$mn:0000588C                 mov     [ebp+var_4], ecx
.text$mn:0000588F                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00005894                 push    eax
.text$mn:00005895                 push    0
.text$mn:00005897                 mov     ecx, [ebp+arg_0]
.text$mn:0000589A                 push    ecx
.text$mn:0000589B                 mov     ecx, [ebp+var_4]
.text$mn:0000589E                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:000058A3                 mov     esp, ebp
.text$mn:000058A5                 pop     ebp
.text$mn:000058A6                 retn    4
.text$mn:000058A6 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z endp
.text$mn:000058A6
.text$mn:000058A6 ; ---------------------------------------------------------------------------
.text$mn:000058A9                 align 4
.text$mn:000058A9 _text$mn        ends
.text$mn:000058A9
.text$mn:000058AC ; ===========================================================================
.text$mn:000058AC
.text$mn:000058AC ; Segment type: Pure code
.text$mn:000058AC ; Segment permissions: Read/Execute
.text$mn:000058AC _text$mn        segment para public 'CODE' use32
.text$mn:000058AC                 assume cs:_text$mn
.text$mn:000058AC                 ;org 58ACh
.text$mn:000058AC ; COMDAT (pick any)
.text$mn:000058AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000058AC
.text$mn:000058AC ; =============== S U B R O U T I N E =======================================
.text$mn:000058AC
.text$mn:000058AC ; Attributes: bp-based frame
.text$mn:000058AC
.text$mn:000058AC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:000058AC                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:000058AC ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:000058AC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Bp
.text$mn:000058AC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+16p ...
.text$mn:000058AC
.text$mn:000058AC var_8           = dword ptr -8
.text$mn:000058AC var_4           = dword ptr -4
.text$mn:000058AC arg_0           = dword ptr  8
.text$mn:000058AC arg_4           = dword ptr  0Ch
.text$mn:000058AC arg_8           = dword ptr  10h
.text$mn:000058AC
.text$mn:000058AC                 push    ebp
.text$mn:000058AD                 mov     ebp, esp
.text$mn:000058AF                 sub     esp, 8
.text$mn:000058B2                 mov     [ebp+var_4], ecx
.text$mn:000058B5                 mov     ecx, [ebp+arg_0]
.text$mn:000058B8                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:000058BD                 cmp     eax, [ebp+arg_4]
.text$mn:000058C0                 jnb     short loc_58CA
.text$mn:000058C2                 mov     ecx, [ebp+var_4]
.text$mn:000058C5                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:000058CA
.text$mn:000058CA loc_58CA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:000058CA                 mov     ecx, [ebp+arg_0]
.text$mn:000058CD                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:000058D2                 sub     eax, [ebp+arg_4]
.text$mn:000058D5                 mov     [ebp+var_8], eax
.text$mn:000058D8                 mov     eax, [ebp+arg_8]
.text$mn:000058DB                 cmp     eax, [ebp+var_8]
.text$mn:000058DE                 jnb     short loc_58E6
.text$mn:000058E0                 mov     ecx, [ebp+arg_8]
.text$mn:000058E3                 mov     [ebp+var_8], ecx
.text$mn:000058E6
.text$mn:000058E6 loc_58E6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:000058E6                 mov     edx, [ebp+var_4]
.text$mn:000058E9                 cmp     edx, [ebp+arg_0]
.text$mn:000058EC                 jnz     short loc_590D
.text$mn:000058EE                 mov     eax, [ebp+arg_4]
.text$mn:000058F1                 add     eax, [ebp+var_8]
.text$mn:000058F4                 push    eax
.text$mn:000058F5                 mov     ecx, [ebp+var_4]
.text$mn:000058F8                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:000058FD                 mov     ecx, [ebp+arg_4]
.text$mn:00005900                 push    ecx
.text$mn:00005901                 push    0
.text$mn:00005903                 mov     ecx, [ebp+var_4]
.text$mn:00005906                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:0000590B                 jmp     short loc_5952
.text$mn:0000590D ; ---------------------------------------------------------------------------
.text$mn:0000590D
.text$mn:0000590D loc_590D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:0000590D                 push    0
.text$mn:0000590F                 mov     edx, [ebp+var_8]
.text$mn:00005912                 push    edx
.text$mn:00005913                 mov     ecx, [ebp+var_4]
.text$mn:00005916                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000591B                 movzx   eax, al
.text$mn:0000591E                 test    eax, eax
.text$mn:00005920                 jz      short loc_5952
.text$mn:00005922                 mov     ecx, [ebp+var_8]
.text$mn:00005925                 push    ecx             ; int
.text$mn:00005926                 mov     ecx, [ebp+arg_0]
.text$mn:00005929                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000592E                 mov     edx, [ebp+arg_4]
.text$mn:00005931                 lea     eax, [eax+edx*2]
.text$mn:00005934                 push    eax             ; Src
.text$mn:00005935                 mov     ecx, [ebp+var_4]
.text$mn:00005938                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000593D                 push    eax             ; Dst
.text$mn:0000593E                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00005943                 add     esp, 0Ch
.text$mn:00005946                 mov     ecx, [ebp+var_8]
.text$mn:00005949                 push    ecx
.text$mn:0000594A                 mov     ecx, [ebp+var_4]
.text$mn:0000594D                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00005952
.text$mn:00005952 loc_5952:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:00005952                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:00005952                 mov     eax, [ebp+var_4]
.text$mn:00005955                 mov     esp, ebp
.text$mn:00005957                 pop     ebp
.text$mn:00005958                 retn    0Ch
.text$mn:00005958 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00005958
.text$mn:00005958 ; ---------------------------------------------------------------------------
.text$mn:0000595B                 align 4
.text$mn:0000595B _text$mn        ends
.text$mn:0000595B
.text$mn:0000595C ; ===========================================================================
.text$mn:0000595C
.text$mn:0000595C ; Segment type: Pure code
.text$mn:0000595C ; Segment permissions: Read/Execute
.text$mn:0000595C _text$mn        segment para public 'CODE' use32
.text$mn:0000595C                 assume cs:_text$mn
.text$mn:0000595C                 ;org 595Ch
.text$mn:0000595C ; COMDAT (pick any)
.text$mn:0000595C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000595C
.text$mn:0000595C ; =============== S U B R O U T I N E =======================================
.text$mn:0000595C
.text$mn:0000595C ; Attributes: bp-based frame
.text$mn:0000595C
.text$mn:0000595C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:0000595C                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:0000595C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:0000595C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+53p
.text$mn:0000595C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)+Ep
.text$mn:0000595C
.text$mn:0000595C var_4           = dword ptr -4
.text$mn:0000595C Str             = dword ptr  8
.text$mn:0000595C
.text$mn:0000595C                 push    ebp
.text$mn:0000595D                 mov     ebp, esp
.text$mn:0000595F                 push    ecx
.text$mn:00005960                 mov     [ebp+var_4], ecx
.text$mn:00005963                 push    490h            ; unsigned int
.text$mn:00005968                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000596D                 mov     eax, [ebp+Str]
.text$mn:00005970                 push    eax             ; int
.text$mn:00005971                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00005976                 add     esp, 0Ch
.text$mn:00005979                 mov     ecx, [ebp+Str]
.text$mn:0000597C                 push    ecx             ; Str
.text$mn:0000597D                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:00005982                 add     esp, 4
.text$mn:00005985                 push    eax             ; int
.text$mn:00005986                 mov     edx, [ebp+Str]
.text$mn:00005989                 push    edx             ; Src
.text$mn:0000598A                 mov     ecx, [ebp+var_4]
.text$mn:0000598D                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:00005992                 mov     esp, ebp
.text$mn:00005994                 pop     ebp
.text$mn:00005995                 retn    4
.text$mn:00005995 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:00005995
.text$mn:00005995 _text$mn        ends
.text$mn:00005995
.text$mn:00005998 ; ===========================================================================
.text$mn:00005998
.text$mn:00005998 ; Segment type: Pure code
.text$mn:00005998 ; Segment permissions: Read/Execute
.text$mn:00005998 _text$mn        segment para public 'CODE' use32
.text$mn:00005998                 assume cs:_text$mn
.text$mn:00005998                 ;org 5998h
.text$mn:00005998 ; COMDAT (pick any)
.text$mn:00005998                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005998
.text$mn:00005998 ; =============== S U B R O U T I N E =======================================
.text$mn:00005998
.text$mn:00005998 ; Attributes: bp-based frame
.text$mn:00005998
.text$mn:00005998 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:00005998                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:00005998 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:00005998                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:00005998
.text$mn:00005998 var_4           = dword ptr -4
.text$mn:00005998 Src             = dword ptr  8
.text$mn:00005998 arg_4           = dword ptr  0Ch
.text$mn:00005998
.text$mn:00005998                 push    ebp
.text$mn:00005999                 mov     ebp, esp
.text$mn:0000599B                 push    ecx
.text$mn:0000599C                 mov     [ebp+var_4], ecx
.text$mn:0000599F                 cmp     [ebp+arg_4], 0
.text$mn:000059A3                 jz      short loc_59BB
.text$mn:000059A5                 push    47Fh            ; unsigned int
.text$mn:000059AA                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000059AF                 mov     eax, [ebp+Src]
.text$mn:000059B2                 push    eax             ; int
.text$mn:000059B3                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000059B8                 add     esp, 0Ch
.text$mn:000059BB
.text$mn:000059BB loc_59BB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:000059BB                 mov     ecx, [ebp+Src]
.text$mn:000059BE                 push    ecx
.text$mn:000059BF                 mov     ecx, [ebp+var_4]
.text$mn:000059C2                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:000059C7                 movzx   edx, al
.text$mn:000059CA                 test    edx, edx
.text$mn:000059CC                 jz      short loc_59F0
.text$mn:000059CE                 mov     eax, [ebp+arg_4]
.text$mn:000059D1                 push    eax
.text$mn:000059D2                 mov     ecx, [ebp+var_4]
.text$mn:000059D5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000059DA                 mov     ecx, [ebp+Src]
.text$mn:000059DD                 sub     ecx, eax
.text$mn:000059DF                 sar     ecx, 1
.text$mn:000059E1                 push    ecx
.text$mn:000059E2                 mov     edx, [ebp+var_4]
.text$mn:000059E5                 push    edx
.text$mn:000059E6                 mov     ecx, [ebp+var_4]
.text$mn:000059E9                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:000059EE                 jmp     short loc_5A2D
.text$mn:000059F0 ; ---------------------------------------------------------------------------
.text$mn:000059F0
.text$mn:000059F0 loc_59F0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:000059F0                 push    0
.text$mn:000059F2                 mov     eax, [ebp+arg_4]
.text$mn:000059F5                 push    eax
.text$mn:000059F6                 mov     ecx, [ebp+var_4]
.text$mn:000059F9                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:000059FE                 movzx   ecx, al
.text$mn:00005A01                 test    ecx, ecx
.text$mn:00005A03                 jz      short loc_5A2A
.text$mn:00005A05                 mov     edx, [ebp+arg_4]
.text$mn:00005A08                 push    edx             ; int
.text$mn:00005A09                 mov     eax, [ebp+Src]
.text$mn:00005A0C                 push    eax             ; Src
.text$mn:00005A0D                 mov     ecx, [ebp+var_4]
.text$mn:00005A10                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00005A15                 push    eax             ; Dst
.text$mn:00005A16                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00005A1B                 add     esp, 0Ch
.text$mn:00005A1E                 mov     ecx, [ebp+arg_4]
.text$mn:00005A21                 push    ecx
.text$mn:00005A22                 mov     ecx, [ebp+var_4]
.text$mn:00005A25                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00005A2A
.text$mn:00005A2A loc_5A2A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:00005A2A                 mov     eax, [ebp+var_4]
.text$mn:00005A2D
.text$mn:00005A2D loc_5A2D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:00005A2D                 mov     esp, ebp
.text$mn:00005A2F                 pop     ebp
.text$mn:00005A30                 retn    8
.text$mn:00005A30 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:00005A30
.text$mn:00005A30 ; ---------------------------------------------------------------------------
.text$mn:00005A33                 align 4
.text$mn:00005A33 _text$mn        ends
.text$mn:00005A33
.text$mn:00005A34 ; ===========================================================================
.text$mn:00005A34
.text$mn:00005A34 ; Segment type: Pure code
.text$mn:00005A34 ; Segment permissions: Read/Execute
.text$mn:00005A34 _text$mn        segment para public 'CODE' use32
.text$mn:00005A34                 assume cs:_text$mn
.text$mn:00005A34                 ;org 5A34h
.text$mn:00005A34 ; COMDAT (pick any)
.text$mn:00005A34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A34
.text$mn:00005A34 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A34
.text$mn:00005A34 ; Attributes: bp-based frame
.text$mn:00005A34
.text$mn:00005A34 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00005A34                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00005A34 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00005A34                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00005A34
.text$mn:00005A34 arg_0           = dword ptr  8
.text$mn:00005A34 arg_4           = dword ptr  0Ch
.text$mn:00005A34
.text$mn:00005A34                 push    ebp
.text$mn:00005A35                 mov     ebp, esp
.text$mn:00005A37                 mov     eax, [ebp+arg_0]
.text$mn:00005A3A                 mov     ecx, [ebp+arg_4]
.text$mn:00005A3D                 mov     dl, [ecx]
.text$mn:00005A3F                 mov     [eax], dl
.text$mn:00005A41                 pop     ebp
.text$mn:00005A42                 retn
.text$mn:00005A42 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00005A42
.text$mn:00005A42 ; ---------------------------------------------------------------------------
.text$mn:00005A43                 align 4
.text$mn:00005A43 _text$mn        ends
.text$mn:00005A43
.text$mn:00005A44 ; ===========================================================================
.text$mn:00005A44
.text$mn:00005A44 ; Segment type: Pure code
.text$mn:00005A44 ; Segment permissions: Read/Execute
.text$mn:00005A44 _text$mn        segment para public 'CODE' use32
.text$mn:00005A44                 assume cs:_text$mn
.text$mn:00005A44                 ;org 5A44h
.text$mn:00005A44 ; COMDAT (pick any)
.text$mn:00005A44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A44
.text$mn:00005A44 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A44
.text$mn:00005A44 ; Attributes: bp-based frame
.text$mn:00005A44
.text$mn:00005A44 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:00005A44                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:00005A44 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:00005A44                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:00005A44
.text$mn:00005A44 arg_0           = dword ptr  8
.text$mn:00005A44 arg_4           = dword ptr  0Ch
.text$mn:00005A44
.text$mn:00005A44                 push    ebp
.text$mn:00005A45                 mov     ebp, esp
.text$mn:00005A47                 mov     eax, [ebp+arg_0]
.text$mn:00005A4A                 mov     ecx, [ebp+arg_4]
.text$mn:00005A4D                 mov     dx, [ecx]
.text$mn:00005A50                 mov     [eax], dx
.text$mn:00005A53                 pop     ebp
.text$mn:00005A54                 retn
.text$mn:00005A54 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:00005A54
.text$mn:00005A54 ; ---------------------------------------------------------------------------
.text$mn:00005A55                 align 4
.text$mn:00005A55 _text$mn        ends
.text$mn:00005A55
.text$mn:00005A58 ; ===========================================================================
.text$mn:00005A58
.text$mn:00005A58 ; Segment type: Pure code
.text$mn:00005A58 ; Segment permissions: Read/Execute
.text$mn:00005A58 _text$mn        segment para public 'CODE' use32
.text$mn:00005A58                 assume cs:_text$mn
.text$mn:00005A58                 ;org 5A58h
.text$mn:00005A58 ; COMDAT (pick any)
.text$mn:00005A58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A58
.text$mn:00005A58 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A58
.text$mn:00005A58 ; Attributes: bp-based frame
.text$mn:00005A58
.text$mn:00005A58 ; public: struct TreeStateNode & __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::at(unsigned int)
.text$mn:00005A58                 public ?at@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAEAAUTreeStateNode@@I@Z
.text$mn:00005A58 ?at@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAEAAUTreeStateNode@@I@Z proc near
.text$mn:00005A58                                         ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+1ABp
.text$mn:00005A58
.text$mn:00005A58 var_4           = dword ptr -4
.text$mn:00005A58 arg_0           = dword ptr  8
.text$mn:00005A58
.text$mn:00005A58                 push    ebp
.text$mn:00005A59                 mov     ebp, esp
.text$mn:00005A5B                 push    ecx
.text$mn:00005A5C                 mov     [ebp+var_4], ecx
.text$mn:00005A5F                 mov     ecx, [ebp+var_4]
.text$mn:00005A62                 call    ?size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::size(void)
.text$mn:00005A67                 cmp     eax, [ebp+arg_0]
.text$mn:00005A6A                 ja      short loc_5A74
.text$mn:00005A6C                 mov     ecx, [ebp+var_4]
.text$mn:00005A6F                 call    ?_Xran@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Xran(void)
.text$mn:00005A74
.text$mn:00005A74 loc_5A74:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::at(uint)+12j
.text$mn:00005A74                 imul    eax, [ebp+arg_0], 4Ch
.text$mn:00005A78                 mov     ecx, [ebp+var_4]
.text$mn:00005A7B                 add     eax, [ecx+4]
.text$mn:00005A7E                 mov     esp, ebp
.text$mn:00005A80                 pop     ebp
.text$mn:00005A81                 retn    4
.text$mn:00005A81 ?at@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAEAAUTreeStateNode@@I@Z endp
.text$mn:00005A81
.text$mn:00005A81 _text$mn        ends
.text$mn:00005A81
.text$mn:00005A84 ; ===========================================================================
.text$mn:00005A84
.text$mn:00005A84 ; Segment type: Pure code
.text$mn:00005A84 ; Segment permissions: Read/Execute
.text$mn:00005A84 _text$mn        segment para public 'CODE' use32
.text$mn:00005A84                 assume cs:_text$mn
.text$mn:00005A84                 ;org 5A84h
.text$mn:00005A84 ; COMDAT (pick any)
.text$mn:00005A84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A84
.text$mn:00005A84 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A84
.text$mn:00005A84 ; Attributes: bp-based frame
.text$mn:00005A84
.text$mn:00005A84 ; public: struct TreeStateNode const & __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::at(unsigned int)const
.text$mn:00005A84                 public ?at@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEABUTreeStateNode@@I@Z
.text$mn:00005A84 ?at@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEABUTreeStateNode@@I@Z proc near
.text$mn:00005A84                                         ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+174p
.text$mn:00005A84
.text$mn:00005A84 var_4           = dword ptr -4
.text$mn:00005A84 arg_0           = dword ptr  8
.text$mn:00005A84
.text$mn:00005A84                 push    ebp
.text$mn:00005A85                 mov     ebp, esp
.text$mn:00005A87                 push    ecx
.text$mn:00005A88                 mov     [ebp+var_4], ecx
.text$mn:00005A8B                 mov     ecx, [ebp+var_4]
.text$mn:00005A8E                 call    ?size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::size(void)
.text$mn:00005A93                 cmp     eax, [ebp+arg_0]
.text$mn:00005A96                 ja      short loc_5AA0
.text$mn:00005A98                 mov     ecx, [ebp+var_4]
.text$mn:00005A9B                 call    ?_Xran@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXXZ ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Xran(void)
.text$mn:00005AA0
.text$mn:00005AA0 loc_5AA0:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::at(uint)+12j
.text$mn:00005AA0                 imul    eax, [ebp+arg_0], 4Ch
.text$mn:00005AA4                 mov     ecx, [ebp+var_4]
.text$mn:00005AA7                 add     eax, [ecx+4]
.text$mn:00005AAA                 mov     esp, ebp
.text$mn:00005AAC                 pop     ebp
.text$mn:00005AAD                 retn    4
.text$mn:00005AAD ?at@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEABUTreeStateNode@@I@Z endp
.text$mn:00005AAD
.text$mn:00005AAD _text$mn        ends
.text$mn:00005AAD
.text$mn:00005AB0 ; ===========================================================================
.text$mn:00005AB0
.text$mn:00005AB0 ; Segment type: Pure code
.text$mn:00005AB0 ; Segment permissions: Read/Execute
.text$mn:00005AB0 _text$mn        segment para public 'CODE' use32
.text$mn:00005AB0                 assume cs:_text$mn
.text$mn:00005AB0                 ;org 5AB0h
.text$mn:00005AB0 ; COMDAT (pick any)
.text$mn:00005AB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005AB0
.text$mn:00005AB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AB0
.text$mn:00005AB0 ; Attributes: bp-based frame
.text$mn:00005AB0
.text$mn:00005AB0 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>> __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::begin(void)const
.text$mn:00005AB0                 public ?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ
.text$mn:00005AB0 ?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ proc near
.text$mn:00005AB0                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(std::vector<TreeStateNode,std::allocator<TreeStateNode>> const &)+A7p
.text$mn:00005AB0
.text$mn:00005AB0 var_14          = dword ptr -14h
.text$mn:00005AB0 var_10          = dword ptr -10h
.text$mn:00005AB0 var_C           = dword ptr -0Ch
.text$mn:00005AB0 var_4           = dword ptr -4
.text$mn:00005AB0 arg_0           = dword ptr  8
.text$mn:00005AB0
.text$mn:00005AB0                 push    ebp
.text$mn:00005AB1                 mov     ebp, esp
.text$mn:00005AB3                 push    0FFFFFFFFh
.text$mn:00005AB5                 push    offset __ehhandler$?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ
.text$mn:00005ABA                 mov     eax, large fs:0
.text$mn:00005AC0                 push    eax
.text$mn:00005AC1                 sub     esp, 8
.text$mn:00005AC4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005AC9                 xor     eax, ebp
.text$mn:00005ACB                 push    eax
.text$mn:00005ACC                 lea     eax, [ebp+var_C]
.text$mn:00005ACF                 mov     large fs:0, eax
.text$mn:00005AD5                 mov     [ebp+var_10], ecx
.text$mn:00005AD8                 mov     [ebp+var_14], 0
.text$mn:00005ADF                 mov     eax, [ebp+var_10]
.text$mn:00005AE2                 push    eax             ; struct std::_Container_base12 *
.text$mn:00005AE3                 mov     ecx, [ebp+var_10]
.text$mn:00005AE6                 mov     edx, [ecx+4]
.text$mn:00005AE9                 push    edx             ; int
.text$mn:00005AEA                 mov     ecx, [ebp+arg_0]
.text$mn:00005AED                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(TreeStateNode *,std::_Container_base12 const *)
.text$mn:00005AF2                 mov     [ebp+var_4], 0
.text$mn:00005AF9                 mov     eax, [ebp+var_14]
.text$mn:00005AFC                 or      eax, 1
.text$mn:00005AFF                 mov     [ebp+var_14], eax
.text$mn:00005B02                 mov     eax, [ebp+arg_0]
.text$mn:00005B05                 mov     ecx, [ebp+var_C]
.text$mn:00005B08                 mov     large fs:0, ecx
.text$mn:00005B0F                 pop     ecx
.text$mn:00005B10                 mov     esp, ebp
.text$mn:00005B12                 pop     ebp
.text$mn:00005B13                 retn    4
.text$mn:00005B13 ?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ endp
.text$mn:00005B13
.text$mn:00005B13 ; ---------------------------------------------------------------------------
.text$mn:00005B16                 align 4
.text$mn:00005B16 _text$mn        ends
.text$mn:00005B16
.text$x:00005B18 ; ===========================================================================
.text$x:00005B18
.text$x:00005B18 ; Segment type: Pure code
.text$x:00005B18 ; Segment permissions: Read/Execute
.text$x:00005B18 _text$x         segment para public 'CODE' use32
.text$x:00005B18                 assume cs:_text$x
.text$x:00005B18                 ;org 5B18h
.text$x:00005B18 ; COMDAT (pick associative to section at 5AB0)
.text$x:00005B18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005B18
.text$x:00005B18 ; =============== S U B R O U T I N E =======================================
.text$x:00005B18
.text$x:00005B18
.text$x:00005B18 __unwindfunclet$?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ$0 proc near
.text$x:00005B18                                         ; DATA XREF: .xdata$x:0000746Co
.text$x:00005B18                 mov     eax, [ebp-14h]
.text$x:00005B1B                 and     eax, 1
.text$x:00005B1E                 jz      $LN4
.text$x:00005B24                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00005B28                 mov     ecx, [ebp+8]
.text$x:00005B2B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$x:00005B30 ; ---------------------------------------------------------------------------
.text$x:00005B30
.text$x:00005B30 $LN4:                                   ; CODE XREF: __unwindfunclet$?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ$0+6j
.text$x:00005B30                 retn
.text$x:00005B30 __unwindfunclet$?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ$0 endp
.text$x:00005B30
.text$x:00005B31
.text$x:00005B31 ; =============== S U B R O U T I N E =======================================
.text$x:00005B31
.text$x:00005B31
.text$x:00005B31 __ehhandler$?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ proc near
.text$x:00005B31                                         ; DATA XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::begin(void)+5o
.text$x:00005B31
.text$x:00005B31 arg_4           = dword ptr  8
.text$x:00005B31
.text$x:00005B31                 mov     edx, [esp+arg_4]
.text$x:00005B35                 lea     eax, [edx+0Ch]
.text$x:00005B38                 mov     ecx, [edx-0Ch]
.text$x:00005B3B                 xor     ecx, eax
.text$x:00005B3D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005B42                 mov     eax, offset __ehfuncinfo$?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ
.text$x:00005B47                 jmp     ___CxxFrameHandler3
.text$x:00005B47 __ehhandler$?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ endp
.text$x:00005B47
.text$x:00005B47 _text$x         ends
.text$x:00005B47
.text$mn:00005B4C ; ===========================================================================
.text$mn:00005B4C
.text$mn:00005B4C ; Segment type: Pure code
.text$mn:00005B4C ; Segment permissions: Read/Execute
.text$mn:00005B4C _text$mn        segment para public 'CODE' use32
.text$mn:00005B4C                 assume cs:_text$mn
.text$mn:00005B4C                 ;org 5B4Ch
.text$mn:00005B4C ; COMDAT (pick any)
.text$mn:00005B4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005B4C
.text$mn:00005B4C ; =============== S U B R O U T I N E =======================================
.text$mn:00005B4C
.text$mn:00005B4C ; Attributes: bp-based frame
.text$mn:00005B4C
.text$mn:00005B4C ; public: unsigned int __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::capacity(void)const
.text$mn:00005B4C                 public ?capacity@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ
.text$mn:00005B4C ?capacity@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ proc near
.text$mn:00005B4C                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Grow_to(uint)+Cp
.text$mn:00005B4C
.text$mn:00005B4C var_4           = dword ptr -4
.text$mn:00005B4C
.text$mn:00005B4C                 push    ebp
.text$mn:00005B4D                 mov     ebp, esp
.text$mn:00005B4F                 push    ecx
.text$mn:00005B50                 mov     [ebp+var_4], ecx
.text$mn:00005B53                 mov     eax, [ebp+var_4]
.text$mn:00005B56                 mov     ecx, [ebp+var_4]
.text$mn:00005B59                 mov     eax, [eax+0Ch]
.text$mn:00005B5C                 sub     eax, [ecx+4]
.text$mn:00005B5F                 cdq
.text$mn:00005B60                 mov     ecx, 4Ch ; 'L'
.text$mn:00005B65                 idiv    ecx
.text$mn:00005B67                 mov     esp, ebp
.text$mn:00005B69                 pop     ebp
.text$mn:00005B6A                 retn
.text$mn:00005B6A ?capacity@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ endp
.text$mn:00005B6A
.text$mn:00005B6A ; ---------------------------------------------------------------------------
.text$mn:00005B6B                 align 4
.text$mn:00005B6B _text$mn        ends
.text$mn:00005B6B
.text$mn:00005B6C ; ===========================================================================
.text$mn:00005B6C
.text$mn:00005B6C ; Segment type: Pure code
.text$mn:00005B6C ; Segment permissions: Read/Execute
.text$mn:00005B6C _text$mn        segment para public 'CODE' use32
.text$mn:00005B6C                 assume cs:_text$mn
.text$mn:00005B6C                 ;org 5B6Ch
.text$mn:00005B6C ; COMDAT (pick any)
.text$mn:00005B6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005B6C
.text$mn:00005B6C ; =============== S U B R O U T I N E =======================================
.text$mn:00005B6C
.text$mn:00005B6C ; Attributes: bp-based frame
.text$mn:00005B6C
.text$mn:00005B6C ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00005B6C                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00005B6C ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00005B6C                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00005B6C
.text$mn:00005B6C var_4           = dword ptr -4
.text$mn:00005B6C
.text$mn:00005B6C                 push    ebp
.text$mn:00005B6D                 mov     ebp, esp
.text$mn:00005B6F                 push    ecx
.text$mn:00005B70                 mov     [ebp+var_4], ecx
.text$mn:00005B73                 mov     eax, [ebp+var_4]
.text$mn:00005B76                 mov     eax, [eax+4]
.text$mn:00005B79                 mov     esp, ebp
.text$mn:00005B7B                 pop     ebp
.text$mn:00005B7C                 retn
.text$mn:00005B7C ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00005B7C
.text$mn:00005B7C ; ---------------------------------------------------------------------------
.text$mn:00005B7D                 align 10h
.text$mn:00005B7D _text$mn        ends
.text$mn:00005B7D
.text$mn:00005B80 ; ===========================================================================
.text$mn:00005B80
.text$mn:00005B80 ; Segment type: Pure code
.text$mn:00005B80 ; Segment permissions: Read/Execute
.text$mn:00005B80 _text$mn        segment para public 'CODE' use32
.text$mn:00005B80                 assume cs:_text$mn
.text$mn:00005B80                 ;org 5B80h
.text$mn:00005B80 ; COMDAT (pick any)
.text$mn:00005B80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005B80
.text$mn:00005B80 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B80
.text$mn:00005B80 ; Attributes: bp-based frame
.text$mn:00005B80
.text$mn:00005B80 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00005B80                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00005B80 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00005B80                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00005B80                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00005B80
.text$mn:00005B80 var_4           = dword ptr -4
.text$mn:00005B80
.text$mn:00005B80                 push    ebp
.text$mn:00005B81                 mov     ebp, esp
.text$mn:00005B83                 push    ecx
.text$mn:00005B84                 mov     [ebp+var_4], ecx
.text$mn:00005B87                 mov     eax, [ebp+var_4]
.text$mn:00005B8A                 mov     eax, [eax+4]
.text$mn:00005B8D                 mov     esp, ebp
.text$mn:00005B8F                 pop     ebp
.text$mn:00005B90                 retn
.text$mn:00005B90 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00005B90
.text$mn:00005B90 ; ---------------------------------------------------------------------------
.text$mn:00005B91                 align 4
.text$mn:00005B91 _text$mn        ends
.text$mn:00005B91
.text$mn:00005B94 ; ===========================================================================
.text$mn:00005B94
.text$mn:00005B94 ; Segment type: Pure code
.text$mn:00005B94 ; Segment permissions: Read/Execute
.text$mn:00005B94 _text$mn        segment para public 'CODE' use32
.text$mn:00005B94                 assume cs:_text$mn
.text$mn:00005B94                 ;org 5B94h
.text$mn:00005B94 ; COMDAT (pick any)
.text$mn:00005B94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005B94
.text$mn:00005B94 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B94
.text$mn:00005B94 ; Attributes: bp-based frame
.text$mn:00005B94
.text$mn:00005B94 ; public: int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::compare(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)const
.text$mn:00005B94                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z
.text$mn:00005B94 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z proc near
.text$mn:00005B94                                         ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+Bp
.text$mn:00005B94
.text$mn:00005B94 var_4           = dword ptr -4
.text$mn:00005B94 arg_0           = dword ptr  8
.text$mn:00005B94
.text$mn:00005B94                 push    ebp
.text$mn:00005B95                 mov     ebp, esp
.text$mn:00005B97                 push    ecx
.text$mn:00005B98                 mov     [ebp+var_4], ecx
.text$mn:00005B9B                 mov     ecx, [ebp+arg_0]
.text$mn:00005B9E                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00005BA3                 push    eax
.text$mn:00005BA4                 mov     ecx, [ebp+arg_0]
.text$mn:00005BA7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00005BAC                 push    eax
.text$mn:00005BAD                 mov     eax, [ebp+var_4]
.text$mn:00005BB0                 mov     ecx, [eax+14h]
.text$mn:00005BB3                 push    ecx
.text$mn:00005BB4                 push    0
.text$mn:00005BB6                 mov     ecx, [ebp+var_4]
.text$mn:00005BB9                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)
.text$mn:00005BBE                 mov     esp, ebp
.text$mn:00005BC0                 pop     ebp
.text$mn:00005BC1                 retn    4
.text$mn:00005BC1 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z endp
.text$mn:00005BC1
.text$mn:00005BC1 _text$mn        ends
.text$mn:00005BC1
.text$mn:00005BC4 ; ===========================================================================
.text$mn:00005BC4
.text$mn:00005BC4 ; Segment type: Pure code
.text$mn:00005BC4 ; Segment permissions: Read/Execute
.text$mn:00005BC4 _text$mn        segment para public 'CODE' use32
.text$mn:00005BC4                 assume cs:_text$mn
.text$mn:00005BC4                 ;org 5BC4h
.text$mn:00005BC4 ; COMDAT (pick any)
.text$mn:00005BC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005BC4
.text$mn:00005BC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005BC4
.text$mn:00005BC4 ; Attributes: bp-based frame
.text$mn:00005BC4
.text$mn:00005BC4 ; public: int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::compare(unsigned int, unsigned int, wchar_t const *, unsigned int)const
.text$mn:00005BC4                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z
.text$mn:00005BC4 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z proc near
.text$mn:00005BC4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+25p
.text$mn:00005BC4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)+3Ap
.text$mn:00005BC4
.text$mn:00005BC4 var_18          = dword ptr -18h
.text$mn:00005BC4 var_14          = dword ptr -14h
.text$mn:00005BC4 var_10          = dword ptr -10h
.text$mn:00005BC4 var_C           = dword ptr -0Ch
.text$mn:00005BC4 var_8           = dword ptr -8
.text$mn:00005BC4 var_4           = dword ptr -4
.text$mn:00005BC4 arg_0           = dword ptr  8
.text$mn:00005BC4 arg_4           = dword ptr  0Ch
.text$mn:00005BC4 arg_8           = dword ptr  10h
.text$mn:00005BC4 arg_C           = dword ptr  14h
.text$mn:00005BC4
.text$mn:00005BC4                 push    ebp
.text$mn:00005BC5                 mov     ebp, esp
.text$mn:00005BC7                 sub     esp, 18h
.text$mn:00005BCA                 mov     [ebp+var_4], ecx
.text$mn:00005BCD                 cmp     [ebp+arg_C], 0
.text$mn:00005BD1                 jz      short loc_5BE9
.text$mn:00005BD3                 push    87Dh            ; unsigned int
.text$mn:00005BD8                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005BDD                 mov     eax, [ebp+arg_8]
.text$mn:00005BE0                 push    eax             ; int
.text$mn:00005BE1                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00005BE6                 add     esp, 0Ch
.text$mn:00005BE9
.text$mn:00005BE9 loc_5BE9:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+Dj
.text$mn:00005BE9                 mov     ecx, [ebp+var_4]
.text$mn:00005BEC                 mov     edx, [ecx+14h]
.text$mn:00005BEF                 cmp     edx, [ebp+arg_0]
.text$mn:00005BF2                 jnb     short loc_5BFC
.text$mn:00005BF4                 mov     ecx, [ebp+var_4]
.text$mn:00005BF7                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00005BFC
.text$mn:00005BFC loc_5BFC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+2Ej
.text$mn:00005BFC                 mov     eax, [ebp+var_4]
.text$mn:00005BFF                 mov     ecx, [eax+14h]
.text$mn:00005C02                 sub     ecx, [ebp+arg_0]
.text$mn:00005C05                 cmp     ecx, [ebp+arg_4]
.text$mn:00005C08                 jnb     short loc_5C16
.text$mn:00005C0A                 mov     edx, [ebp+var_4]
.text$mn:00005C0D                 mov     eax, [edx+14h]
.text$mn:00005C10                 sub     eax, [ebp+arg_0]
.text$mn:00005C13                 mov     [ebp+arg_4], eax
.text$mn:00005C16
.text$mn:00005C16 loc_5C16:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+44j
.text$mn:00005C16                 mov     ecx, [ebp+arg_4]
.text$mn:00005C19                 cmp     ecx, [ebp+arg_C]
.text$mn:00005C1C                 jnb     short loc_5C26
.text$mn:00005C1E                 mov     edx, [ebp+arg_4]
.text$mn:00005C21                 mov     [ebp+var_8], edx
.text$mn:00005C24                 jmp     short loc_5C2C
.text$mn:00005C26 ; ---------------------------------------------------------------------------
.text$mn:00005C26
.text$mn:00005C26 loc_5C26:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+58j
.text$mn:00005C26                 mov     eax, [ebp+arg_C]
.text$mn:00005C29                 mov     [ebp+var_8], eax
.text$mn:00005C2C
.text$mn:00005C2C loc_5C2C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+60j
.text$mn:00005C2C                 mov     ecx, [ebp+var_8]
.text$mn:00005C2F                 push    ecx
.text$mn:00005C30                 mov     edx, [ebp+arg_8]
.text$mn:00005C33                 push    edx
.text$mn:00005C34                 mov     ecx, [ebp+var_4]
.text$mn:00005C37                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00005C3C                 mov     ecx, [ebp+arg_0]
.text$mn:00005C3F                 lea     edx, [eax+ecx*2]
.text$mn:00005C42                 push    edx
.text$mn:00005C43                 call    ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z ; std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)
.text$mn:00005C48                 add     esp, 0Ch
.text$mn:00005C4B                 mov     [ebp+var_C], eax
.text$mn:00005C4E                 cmp     [ebp+var_C], 0
.text$mn:00005C52                 jz      short loc_5C5C
.text$mn:00005C54                 mov     eax, [ebp+var_C]
.text$mn:00005C57                 mov     [ebp+var_18], eax
.text$mn:00005C5A                 jmp     short loc_5C91
.text$mn:00005C5C ; ---------------------------------------------------------------------------
.text$mn:00005C5C
.text$mn:00005C5C loc_5C5C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+8Ej
.text$mn:00005C5C                 mov     ecx, [ebp+arg_4]
.text$mn:00005C5F                 cmp     ecx, [ebp+arg_C]
.text$mn:00005C62                 jnb     short loc_5C6D
.text$mn:00005C64                 mov     [ebp+var_14], 0FFFFFFFFh
.text$mn:00005C6B                 jmp     short loc_5C8B
.text$mn:00005C6D ; ---------------------------------------------------------------------------
.text$mn:00005C6D
.text$mn:00005C6D loc_5C6D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+9Ej
.text$mn:00005C6D                 mov     edx, [ebp+arg_4]
.text$mn:00005C70                 cmp     edx, [ebp+arg_C]
.text$mn:00005C73                 jnz     short loc_5C7E
.text$mn:00005C75                 mov     [ebp+var_10], 0
.text$mn:00005C7C                 jmp     short loc_5C85
.text$mn:00005C7E ; ---------------------------------------------------------------------------
.text$mn:00005C7E
.text$mn:00005C7E loc_5C7E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+AFj
.text$mn:00005C7E                 mov     [ebp+var_10], 1
.text$mn:00005C85
.text$mn:00005C85 loc_5C85:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+B8j
.text$mn:00005C85                 mov     eax, [ebp+var_10]
.text$mn:00005C88                 mov     [ebp+var_14], eax
.text$mn:00005C8B
.text$mn:00005C8B loc_5C8B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+A7j
.text$mn:00005C8B                 mov     ecx, [ebp+var_14]
.text$mn:00005C8E                 mov     [ebp+var_18], ecx
.text$mn:00005C91
.text$mn:00005C91 loc_5C91:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+96j
.text$mn:00005C91                 mov     eax, [ebp+var_18]
.text$mn:00005C94                 mov     esp, ebp
.text$mn:00005C96                 pop     ebp
.text$mn:00005C97                 retn    10h
.text$mn:00005C97 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z endp
.text$mn:00005C97
.text$mn:00005C97 ; ---------------------------------------------------------------------------
.text$mn:00005C9A                 align 4
.text$mn:00005C9A _text$mn        ends
.text$mn:00005C9A
.text$mn:00005C9C ; ===========================================================================
.text$mn:00005C9C
.text$mn:00005C9C ; Segment type: Pure code
.text$mn:00005C9C ; Segment permissions: Read/Execute
.text$mn:00005C9C _text$mn        segment para public 'CODE' use32
.text$mn:00005C9C                 assume cs:_text$mn
.text$mn:00005C9C                 ;org 5C9Ch
.text$mn:00005C9C ; COMDAT (pick any)
.text$mn:00005C9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005C9C
.text$mn:00005C9C ; =============== S U B R O U T I N E =======================================
.text$mn:00005C9C
.text$mn:00005C9C ; Attributes: bp-based frame
.text$mn:00005C9C
.text$mn:00005C9C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t *Str)
.text$mn:00005C9C                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z
.text$mn:00005C9C ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z proc near
.text$mn:00005C9C                                         ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+Bp
.text$mn:00005C9C
.text$mn:00005C9C var_4           = dword ptr -4
.text$mn:00005C9C Str             = dword ptr  8
.text$mn:00005C9C
.text$mn:00005C9C                 push    ebp
.text$mn:00005C9D                 mov     ebp, esp
.text$mn:00005C9F                 push    ecx
.text$mn:00005CA0                 mov     [ebp+var_4], ecx
.text$mn:00005CA3                 push    86Eh            ; unsigned int
.text$mn:00005CA8                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005CAD                 mov     eax, [ebp+Str]
.text$mn:00005CB0                 push    eax             ; int
.text$mn:00005CB1                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00005CB6                 add     esp, 0Ch
.text$mn:00005CB9                 mov     ecx, [ebp+Str]
.text$mn:00005CBC                 push    ecx             ; Str
.text$mn:00005CBD                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:00005CC2                 add     esp, 4
.text$mn:00005CC5                 push    eax
.text$mn:00005CC6                 mov     edx, [ebp+Str]
.text$mn:00005CC9                 push    edx
.text$mn:00005CCA                 mov     eax, [ebp+var_4]
.text$mn:00005CCD                 mov     ecx, [eax+14h]
.text$mn:00005CD0                 push    ecx
.text$mn:00005CD1                 push    0
.text$mn:00005CD3                 mov     ecx, [ebp+var_4]
.text$mn:00005CD6                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)
.text$mn:00005CDB                 mov     esp, ebp
.text$mn:00005CDD                 pop     ebp
.text$mn:00005CDE                 retn    4
.text$mn:00005CDE ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z endp
.text$mn:00005CDE
.text$mn:00005CDE ; ---------------------------------------------------------------------------
.text$mn:00005CE1                 align 4
.text$mn:00005CE1 _text$mn        ends
.text$mn:00005CE1
.text$mn:00005CE4 ; ===========================================================================
.text$mn:00005CE4
.text$mn:00005CE4 ; Segment type: Pure code
.text$mn:00005CE4 ; Segment permissions: Read/Execute
.text$mn:00005CE4 _text$mn        segment para public 'CODE' use32
.text$mn:00005CE4                 assume cs:_text$mn
.text$mn:00005CE4                 ;org 5CE4h
.text$mn:00005CE4 ; COMDAT (pick any)
.text$mn:00005CE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005CE4
.text$mn:00005CE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005CE4
.text$mn:00005CE4 ; Attributes: bp-based frame
.text$mn:00005CE4
.text$mn:00005CE4 ; public: static int __cdecl std::char_traits<wchar_t>::compare(wchar_t const *, wchar_t const *, unsigned int)
.text$mn:00005CE4                 public ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z
.text$mn:00005CE4 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z proc near
.text$mn:00005CE4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+7Fp
.text$mn:00005CE4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+CBp
.text$mn:00005CE4
.text$mn:00005CE4 var_4           = dword ptr -4
.text$mn:00005CE4 arg_0           = dword ptr  8
.text$mn:00005CE4 arg_4           = dword ptr  0Ch
.text$mn:00005CE4 arg_8           = dword ptr  10h
.text$mn:00005CE4
.text$mn:00005CE4                 push    ebp
.text$mn:00005CE5                 mov     ebp, esp
.text$mn:00005CE7                 push    ecx
.text$mn:00005CE8                 cmp     [ebp+arg_8], 0
.text$mn:00005CEC                 jnz     short loc_5CF7
.text$mn:00005CEE                 mov     [ebp+var_4], 0
.text$mn:00005CF5                 jmp     short loc_5D0E
.text$mn:00005CF7 ; ---------------------------------------------------------------------------
.text$mn:00005CF7
.text$mn:00005CF7 loc_5CF7:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+8j
.text$mn:00005CF7                 mov     eax, [ebp+arg_8]
.text$mn:00005CFA                 push    eax
.text$mn:00005CFB                 mov     ecx, [ebp+arg_4]
.text$mn:00005CFE                 push    ecx
.text$mn:00005CFF                 mov     edx, [ebp+arg_0]
.text$mn:00005D02                 push    edx
.text$mn:00005D03                 call    _wmemcmp
.text$mn:00005D08                 add     esp, 0Ch
.text$mn:00005D0B                 mov     [ebp+var_4], eax
.text$mn:00005D0E
.text$mn:00005D0E loc_5D0E:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+11j
.text$mn:00005D0E                 mov     eax, [ebp+var_4]
.text$mn:00005D11                 mov     esp, ebp
.text$mn:00005D13                 pop     ebp
.text$mn:00005D14                 retn
.text$mn:00005D14 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z endp
.text$mn:00005D14
.text$mn:00005D14 ; ---------------------------------------------------------------------------
.text$mn:00005D15                 align 4
.text$mn:00005D15 _text$mn        ends
.text$mn:00005D15
.text$mn:00005D18 ; ===========================================================================
.text$mn:00005D18
.text$mn:00005D18 ; Segment type: Pure code
.text$mn:00005D18 ; Segment permissions: Read/Execute
.text$mn:00005D18 _text$mn        segment para public 'CODE' use32
.text$mn:00005D18                 assume cs:_text$mn
.text$mn:00005D18                 ;org 5D18h
.text$mn:00005D18 ; COMDAT (pick any)
.text$mn:00005D18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D18
.text$mn:00005D18 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D18
.text$mn:00005D18 ; Attributes: bp-based frame
.text$mn:00005D18
.text$mn:00005D18 ; int __stdcall std::allocator<TreeStateNode>::construct(void *, int)
.text$mn:00005D18                 public ?construct@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@ABU3@@Z
.text$mn:00005D18 ?construct@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@ABU3@@Z proc near
.text$mn:00005D18                                         ; CODE XREF: std::allocator_traits<std::allocator<TreeStateNode>>::construct<TreeStateNode,TreeStateNode const &>(std::allocator<TreeStateNode> &,TreeStateNode *,TreeStateNode const &)+17p
.text$mn:00005D18
.text$mn:00005D18 var_1C          = dword ptr -1Ch
.text$mn:00005D18 var_18          = dword ptr -18h
.text$mn:00005D18 var_14          = dword ptr -14h
.text$mn:00005D18 var_10          = dword ptr -10h
.text$mn:00005D18 var_C           = dword ptr -0Ch
.text$mn:00005D18 var_4           = dword ptr -4
.text$mn:00005D18 arg_0           = dword ptr  8
.text$mn:00005D18 arg_4           = dword ptr  0Ch
.text$mn:00005D18
.text$mn:00005D18                 push    ebp
.text$mn:00005D19                 mov     ebp, esp
.text$mn:00005D1B                 push    0FFFFFFFFh
.text$mn:00005D1D                 push    offset __ehhandler$?construct@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@ABU3@@Z
.text$mn:00005D22                 mov     eax, large fs:0
.text$mn:00005D28                 push    eax
.text$mn:00005D29                 sub     esp, 10h
.text$mn:00005D2C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005D31                 xor     eax, ebp
.text$mn:00005D33                 push    eax
.text$mn:00005D34                 lea     eax, [ebp+var_C]
.text$mn:00005D37                 mov     large fs:0, eax
.text$mn:00005D3D                 mov     [ebp+var_18], ecx
.text$mn:00005D40                 mov     eax, [ebp+arg_0]
.text$mn:00005D43                 push    eax             ; void *
.text$mn:00005D44                 push    4Ch ; 'L'       ; unsigned int
.text$mn:00005D46                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00005D4B                 add     esp, 8
.text$mn:00005D4E                 mov     [ebp+var_10], eax
.text$mn:00005D51                 mov     [ebp+var_4], 0
.text$mn:00005D58                 cmp     [ebp+var_10], 0
.text$mn:00005D5C                 jz      short loc_5D6F
.text$mn:00005D5E                 mov     ecx, [ebp+arg_4]
.text$mn:00005D61                 push    ecx
.text$mn:00005D62                 mov     ecx, [ebp+var_10]
.text$mn:00005D65                 call    ??0TreeStateNode@@QAE@ABU0@@Z ; TreeStateNode::TreeStateNode(TreeStateNode const &)
.text$mn:00005D6A                 mov     [ebp+var_14], eax
.text$mn:00005D6D                 jmp     short loc_5D76
.text$mn:00005D6F ; ---------------------------------------------------------------------------
.text$mn:00005D6F
.text$mn:00005D6F loc_5D6F:                               ; CODE XREF: std::allocator<TreeStateNode>::construct(TreeStateNode *,TreeStateNode const &)+44j
.text$mn:00005D6F                 mov     [ebp+var_14], 0
.text$mn:00005D76
.text$mn:00005D76 loc_5D76:                               ; CODE XREF: std::allocator<TreeStateNode>::construct(TreeStateNode *,TreeStateNode const &)+55j
.text$mn:00005D76                 mov     edx, [ebp+var_14]
.text$mn:00005D79                 mov     [ebp+var_1C], edx
.text$mn:00005D7C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005D83                 mov     ecx, [ebp+var_C]
.text$mn:00005D86                 mov     large fs:0, ecx
.text$mn:00005D8D                 pop     ecx
.text$mn:00005D8E                 mov     esp, ebp
.text$mn:00005D90                 pop     ebp
.text$mn:00005D91                 retn    8
.text$mn:00005D91 ?construct@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@ABU3@@Z endp
.text$mn:00005D91
.text$mn:00005D91 _text$mn        ends
.text$mn:00005D91
.text$x:00005D94 ; ===========================================================================
.text$x:00005D94
.text$x:00005D94 ; Segment type: Pure code
.text$x:00005D94 ; Segment permissions: Read/Execute
.text$x:00005D94 _text$x         segment para public 'CODE' use32
.text$x:00005D94                 assume cs:_text$x
.text$x:00005D94                 ;org 5D94h
.text$x:00005D94 ; COMDAT (pick associative to section at 5D18)
.text$x:00005D94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005D94
.text$x:00005D94 ; =============== S U B R O U T I N E =======================================
.text$x:00005D94
.text$x:00005D94
.text$x:00005D94 __unwindfunclet$?construct@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@ABU3@@Z$0 proc near
.text$x:00005D94                                         ; DATA XREF: .xdata$x:000072C8o
.text$x:00005D94                 mov     eax, [ebp+8]
.text$x:00005D97                 push    eax
.text$x:00005D98                 mov     eax, [ebp-10h]
.text$x:00005D9B                 push    eax             ; void *
.text$x:00005D9C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00005DA1                 add     esp, 8
.text$x:00005DA4                 retn
.text$x:00005DA4 __unwindfunclet$?construct@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@ABU3@@Z$0 endp
.text$x:00005DA4
.text$x:00005DA5
.text$x:00005DA5 ; =============== S U B R O U T I N E =======================================
.text$x:00005DA5
.text$x:00005DA5
.text$x:00005DA5 __ehhandler$?construct@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@ABU3@@Z proc near
.text$x:00005DA5                                         ; DATA XREF: std::allocator<TreeStateNode>::construct(TreeStateNode *,TreeStateNode const &)+5o
.text$x:00005DA5
.text$x:00005DA5 arg_4           = dword ptr  8
.text$x:00005DA5
.text$x:00005DA5                 mov     edx, [esp+arg_4]
.text$x:00005DA9                 lea     eax, [edx+0Ch]
.text$x:00005DAC                 mov     ecx, [edx-14h]
.text$x:00005DAF                 xor     ecx, eax
.text$x:00005DB1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005DB6                 mov     eax, offset __ehfuncinfo$?construct@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@ABU3@@Z
.text$x:00005DBB                 jmp     ___CxxFrameHandler3
.text$x:00005DBB __ehhandler$?construct@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@ABU3@@Z endp
.text$x:00005DBB
.text$x:00005DBB _text$x         ends
.text$x:00005DBB
.text$mn:00005DC0 ; ===========================================================================
.text$mn:00005DC0
.text$mn:00005DC0 ; Segment type: Pure code
.text$mn:00005DC0 ; Segment permissions: Read/Execute
.text$mn:00005DC0 _text$mn        segment para public 'CODE' use32
.text$mn:00005DC0                 assume cs:_text$mn
.text$mn:00005DC0                 ;org 5DC0h
.text$mn:00005DC0 ; COMDAT (pick any)
.text$mn:00005DC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DC0
.text$mn:00005DC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005DC0
.text$mn:00005DC0 ; Attributes: bp-based frame
.text$mn:00005DC0
.text$mn:00005DC0 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00005DC0                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00005DC0 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00005DC0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00005DC0
.text$mn:00005DC0 var_4           = dword ptr -4
.text$mn:00005DC0 Dst             = dword ptr  8
.text$mn:00005DC0 Src             = dword ptr  0Ch
.text$mn:00005DC0 Size            = dword ptr  10h
.text$mn:00005DC0
.text$mn:00005DC0                 push    ebp
.text$mn:00005DC1                 mov     ebp, esp
.text$mn:00005DC3                 push    ecx
.text$mn:00005DC4                 cmp     [ebp+Size], 0
.text$mn:00005DC8                 jnz     short loc_5DD2
.text$mn:00005DCA                 mov     eax, [ebp+Dst]
.text$mn:00005DCD                 mov     [ebp+var_4], eax
.text$mn:00005DD0                 jmp     short loc_5DE9
.text$mn:00005DD2 ; ---------------------------------------------------------------------------
.text$mn:00005DD2
.text$mn:00005DD2 loc_5DD2:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00005DD2                 mov     ecx, [ebp+Size]
.text$mn:00005DD5                 push    ecx             ; Size
.text$mn:00005DD6                 mov     edx, [ebp+Src]
.text$mn:00005DD9                 push    edx             ; Src
.text$mn:00005DDA                 mov     eax, [ebp+Dst]
.text$mn:00005DDD                 push    eax             ; Dst
.text$mn:00005DDE                 call    _memcpy
.text$mn:00005DE3                 add     esp, 0Ch
.text$mn:00005DE6                 mov     [ebp+var_4], eax
.text$mn:00005DE9
.text$mn:00005DE9 loc_5DE9:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00005DE9                 mov     eax, [ebp+var_4]
.text$mn:00005DEC                 mov     esp, ebp
.text$mn:00005DEE                 pop     ebp
.text$mn:00005DEF                 retn
.text$mn:00005DEF ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00005DEF
.text$mn:00005DEF _text$mn        ends
.text$mn:00005DEF
.text$mn:00005DF0 ; ===========================================================================
.text$mn:00005DF0
.text$mn:00005DF0 ; Segment type: Pure code
.text$mn:00005DF0 ; Segment permissions: Read/Execute
.text$mn:00005DF0 _text$mn        segment para public 'CODE' use32
.text$mn:00005DF0                 assume cs:_text$mn
.text$mn:00005DF0                 ;org 5DF0h
.text$mn:00005DF0 ; COMDAT (pick any)
.text$mn:00005DF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DF0
.text$mn:00005DF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005DF0
.text$mn:00005DF0 ; Attributes: bp-based frame
.text$mn:00005DF0
.text$mn:00005DF0 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:00005DF0                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00005DF0 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00005DF0                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:00005DF0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00005DF0
.text$mn:00005DF0 var_4           = dword ptr -4
.text$mn:00005DF0 Dst             = dword ptr  8
.text$mn:00005DF0 Src             = dword ptr  0Ch
.text$mn:00005DF0 arg_8           = dword ptr  10h
.text$mn:00005DF0
.text$mn:00005DF0                 push    ebp
.text$mn:00005DF1                 mov     ebp, esp
.text$mn:00005DF3                 push    ecx
.text$mn:00005DF4                 cmp     [ebp+arg_8], 0
.text$mn:00005DF8                 jnz     short loc_5E02
.text$mn:00005DFA                 mov     eax, [ebp+Dst]
.text$mn:00005DFD                 mov     [ebp+var_4], eax
.text$mn:00005E00                 jmp     short loc_5E19
.text$mn:00005E02 ; ---------------------------------------------------------------------------
.text$mn:00005E02
.text$mn:00005E02 loc_5E02:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00005E02                 mov     ecx, [ebp+arg_8]
.text$mn:00005E05                 push    ecx             ; int
.text$mn:00005E06                 mov     edx, [ebp+Src]
.text$mn:00005E09                 push    edx             ; Src
.text$mn:00005E0A                 mov     eax, [ebp+Dst]
.text$mn:00005E0D                 push    eax             ; Dst
.text$mn:00005E0E                 call    _wmemcpy
.text$mn:00005E13                 add     esp, 0Ch
.text$mn:00005E16                 mov     [ebp+var_4], eax
.text$mn:00005E19
.text$mn:00005E19 loc_5E19:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00005E19                 mov     eax, [ebp+var_4]
.text$mn:00005E1C                 mov     esp, ebp
.text$mn:00005E1E                 pop     ebp
.text$mn:00005E1F                 retn
.text$mn:00005E1F ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00005E1F
.text$mn:00005E1F _text$mn        ends
.text$mn:00005E1F
.text$mn:00005E20 ; ===========================================================================
.text$mn:00005E20
.text$mn:00005E20 ; Segment type: Pure code
.text$mn:00005E20 ; Segment permissions: Read/Execute
.text$mn:00005E20 _text$mn        segment para public 'CODE' use32
.text$mn:00005E20                 assume cs:_text$mn
.text$mn:00005E20                 ;org 5E20h
.text$mn:00005E20 ; COMDAT (pick any)
.text$mn:00005E20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E20
.text$mn:00005E20 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E20
.text$mn:00005E20 ; Attributes: bp-based frame
.text$mn:00005E20
.text$mn:00005E20 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00005E20                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00005E20 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00005E20                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00005E20
.text$mn:00005E20 var_4           = dword ptr -4
.text$mn:00005E20 arg_0           = dword ptr  8
.text$mn:00005E20 arg_4           = dword ptr  0Ch
.text$mn:00005E20
.text$mn:00005E20                 push    ebp
.text$mn:00005E21                 mov     ebp, esp
.text$mn:00005E23                 push    ecx
.text$mn:00005E24                 mov     [ebp+var_4], ecx
.text$mn:00005E27                 mov     eax, [ebp+arg_4]
.text$mn:00005E2A                 push    eax             ; int
.text$mn:00005E2B                 mov     ecx, [ebp+arg_0]
.text$mn:00005E2E                 push    ecx             ; void *
.text$mn:00005E2F                 mov     ecx, [ebp+var_4]
.text$mn:00005E32                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00005E37                 mov     esp, ebp
.text$mn:00005E39                 pop     ebp
.text$mn:00005E3A                 retn    8
.text$mn:00005E3A ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00005E3A
.text$mn:00005E3A ; ---------------------------------------------------------------------------
.text$mn:00005E3D                 align 10h
.text$mn:00005E3D _text$mn        ends
.text$mn:00005E3D
.text$mn:00005E40 ; ===========================================================================
.text$mn:00005E40
.text$mn:00005E40 ; Segment type: Pure code
.text$mn:00005E40 ; Segment permissions: Read/Execute
.text$mn:00005E40 _text$mn        segment para public 'CODE' use32
.text$mn:00005E40                 assume cs:_text$mn
.text$mn:00005E40                 ;org 5E40h
.text$mn:00005E40 ; COMDAT (pick any)
.text$mn:00005E40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E40
.text$mn:00005E40 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E40
.text$mn:00005E40 ; Attributes: bp-based frame
.text$mn:00005E40
.text$mn:00005E40 ; int __stdcall std::_Wrap_alloc<std::allocator<TreeStateNode>>::deallocate(void *, int)
.text$mn:00005E40                 public ?deallocate@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@I@Z
.text$mn:00005E40 ?deallocate@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@I@Z proc near
.text$mn:00005E40                                         ; CODE XREF: __catch$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:00005E40                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reallocate(uint)+FAp ...
.text$mn:00005E40
.text$mn:00005E40 var_4           = dword ptr -4
.text$mn:00005E40 arg_0           = dword ptr  8
.text$mn:00005E40 arg_4           = dword ptr  0Ch
.text$mn:00005E40
.text$mn:00005E40                 push    ebp
.text$mn:00005E41                 mov     ebp, esp
.text$mn:00005E43                 push    ecx
.text$mn:00005E44                 mov     [ebp+var_4], ecx
.text$mn:00005E47                 mov     eax, [ebp+arg_4]
.text$mn:00005E4A                 push    eax             ; int
.text$mn:00005E4B                 mov     ecx, [ebp+arg_0]
.text$mn:00005E4E                 push    ecx             ; void *
.text$mn:00005E4F                 mov     ecx, [ebp+var_4]
.text$mn:00005E52                 call    ?deallocate@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@I@Z ; std::allocator<TreeStateNode>::deallocate(TreeStateNode *,uint)
.text$mn:00005E57                 mov     esp, ebp
.text$mn:00005E59                 pop     ebp
.text$mn:00005E5A                 retn    8
.text$mn:00005E5A ?deallocate@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@I@Z endp
.text$mn:00005E5A
.text$mn:00005E5A ; ---------------------------------------------------------------------------
.text$mn:00005E5D                 align 10h
.text$mn:00005E5D _text$mn        ends
.text$mn:00005E5D
.text$mn:00005E60 ; ===========================================================================
.text$mn:00005E60
.text$mn:00005E60 ; Segment type: Pure code
.text$mn:00005E60 ; Segment permissions: Read/Execute
.text$mn:00005E60 _text$mn        segment para public 'CODE' use32
.text$mn:00005E60                 assume cs:_text$mn
.text$mn:00005E60                 ;org 5E60h
.text$mn:00005E60 ; COMDAT (pick any)
.text$mn:00005E60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E60
.text$mn:00005E60 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E60
.text$mn:00005E60 ; Attributes: bp-based frame
.text$mn:00005E60
.text$mn:00005E60 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:00005E60                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00005E60 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00005E60                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Free_proxy(void)+32p
.text$mn:00005E60
.text$mn:00005E60 var_4           = dword ptr -4
.text$mn:00005E60 arg_0           = dword ptr  8
.text$mn:00005E60 arg_4           = dword ptr  0Ch
.text$mn:00005E60
.text$mn:00005E60                 push    ebp
.text$mn:00005E61                 mov     ebp, esp
.text$mn:00005E63                 push    ecx
.text$mn:00005E64                 mov     [ebp+var_4], ecx
.text$mn:00005E67                 mov     eax, [ebp+arg_4]
.text$mn:00005E6A                 push    eax             ; int
.text$mn:00005E6B                 mov     ecx, [ebp+arg_0]
.text$mn:00005E6E                 push    ecx             ; void *
.text$mn:00005E6F                 mov     ecx, [ebp+var_4]
.text$mn:00005E72                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00005E77                 mov     esp, ebp
.text$mn:00005E79                 pop     ebp
.text$mn:00005E7A                 retn    8
.text$mn:00005E7A ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00005E7A
.text$mn:00005E7A ; ---------------------------------------------------------------------------
.text$mn:00005E7D                 align 10h
.text$mn:00005E7D _text$mn        ends
.text$mn:00005E7D
.text$mn:00005E80 ; ===========================================================================
.text$mn:00005E80
.text$mn:00005E80 ; Segment type: Pure code
.text$mn:00005E80 ; Segment permissions: Read/Execute
.text$mn:00005E80 _text$mn        segment para public 'CODE' use32
.text$mn:00005E80                 assume cs:_text$mn
.text$mn:00005E80                 ;org 5E80h
.text$mn:00005E80 ; COMDAT (pick any)
.text$mn:00005E80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E80
.text$mn:00005E80 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E80
.text$mn:00005E80 ; Attributes: bp-based frame
.text$mn:00005E80
.text$mn:00005E80 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:00005E80                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:00005E80 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:00005E80                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:00005E80
.text$mn:00005E80 var_4           = dword ptr -4
.text$mn:00005E80 arg_0           = dword ptr  8
.text$mn:00005E80 arg_4           = dword ptr  0Ch
.text$mn:00005E80
.text$mn:00005E80                 push    ebp
.text$mn:00005E81                 mov     ebp, esp
.text$mn:00005E83                 push    ecx
.text$mn:00005E84                 mov     [ebp+var_4], ecx
.text$mn:00005E87                 mov     eax, [ebp+arg_4]
.text$mn:00005E8A                 push    eax             ; int
.text$mn:00005E8B                 mov     ecx, [ebp+arg_0]
.text$mn:00005E8E                 push    ecx             ; void *
.text$mn:00005E8F                 mov     ecx, [ebp+var_4]
.text$mn:00005E92                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:00005E97                 mov     esp, ebp
.text$mn:00005E99                 pop     ebp
.text$mn:00005E9A                 retn    8
.text$mn:00005E9A ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:00005E9A
.text$mn:00005E9A ; ---------------------------------------------------------------------------
.text$mn:00005E9D                 align 10h
.text$mn:00005E9D _text$mn        ends
.text$mn:00005E9D
.text$mn:00005EA0 ; ===========================================================================
.text$mn:00005EA0
.text$mn:00005EA0 ; Segment type: Pure code
.text$mn:00005EA0 ; Segment permissions: Read/Execute
.text$mn:00005EA0 _text$mn        segment para public 'CODE' use32
.text$mn:00005EA0                 assume cs:_text$mn
.text$mn:00005EA0                 ;org 5EA0h
.text$mn:00005EA0 ; COMDAT (pick any)
.text$mn:00005EA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005EA0
.text$mn:00005EA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005EA0
.text$mn:00005EA0 ; Attributes: bp-based frame
.text$mn:00005EA0
.text$mn:00005EA0 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00005EA0                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00005EA0 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00005EA0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00005EA0
.text$mn:00005EA0 var_4           = dword ptr -4
.text$mn:00005EA0 arg_0           = dword ptr  8
.text$mn:00005EA0
.text$mn:00005EA0                 push    ebp
.text$mn:00005EA1                 mov     ebp, esp
.text$mn:00005EA3                 push    ecx
.text$mn:00005EA4                 mov     [ebp+var_4], ecx
.text$mn:00005EA7                 mov     eax, [ebp+arg_0]
.text$mn:00005EAA                 push    eax             ; void *
.text$mn:00005EAB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005EB0                 add     esp, 4
.text$mn:00005EB3                 mov     esp, ebp
.text$mn:00005EB5                 pop     ebp
.text$mn:00005EB6                 retn    8
.text$mn:00005EB6 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00005EB6
.text$mn:00005EB6 ; ---------------------------------------------------------------------------
.text$mn:00005EB9                 align 4
.text$mn:00005EB9 _text$mn        ends
.text$mn:00005EB9
.text$mn:00005EBC ; ===========================================================================
.text$mn:00005EBC
.text$mn:00005EBC ; Segment type: Pure code
.text$mn:00005EBC ; Segment permissions: Read/Execute
.text$mn:00005EBC _text$mn        segment para public 'CODE' use32
.text$mn:00005EBC                 assume cs:_text$mn
.text$mn:00005EBC                 ;org 5EBCh
.text$mn:00005EBC ; COMDAT (pick any)
.text$mn:00005EBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005EBC
.text$mn:00005EBC ; =============== S U B R O U T I N E =======================================
.text$mn:00005EBC
.text$mn:00005EBC ; Attributes: bp-based frame
.text$mn:00005EBC
.text$mn:00005EBC ; int __stdcall std::allocator<TreeStateNode>::deallocate(void *, int)
.text$mn:00005EBC                 public ?deallocate@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@I@Z
.text$mn:00005EBC ?deallocate@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@I@Z proc near
.text$mn:00005EBC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TreeStateNode>>::deallocate(TreeStateNode *,uint)+12p
.text$mn:00005EBC
.text$mn:00005EBC var_4           = dword ptr -4
.text$mn:00005EBC arg_0           = dword ptr  8
.text$mn:00005EBC
.text$mn:00005EBC                 push    ebp
.text$mn:00005EBD                 mov     ebp, esp
.text$mn:00005EBF                 push    ecx
.text$mn:00005EC0                 mov     [ebp+var_4], ecx
.text$mn:00005EC3                 mov     eax, [ebp+arg_0]
.text$mn:00005EC6                 push    eax             ; void *
.text$mn:00005EC7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005ECC                 add     esp, 4
.text$mn:00005ECF                 mov     esp, ebp
.text$mn:00005ED1                 pop     ebp
.text$mn:00005ED2                 retn    8
.text$mn:00005ED2 ?deallocate@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@I@Z endp
.text$mn:00005ED2
.text$mn:00005ED2 ; ---------------------------------------------------------------------------
.text$mn:00005ED5                 align 4
.text$mn:00005ED5 _text$mn        ends
.text$mn:00005ED5
.text$mn:00005ED8 ; ===========================================================================
.text$mn:00005ED8
.text$mn:00005ED8 ; Segment type: Pure code
.text$mn:00005ED8 ; Segment permissions: Read/Execute
.text$mn:00005ED8 _text$mn        segment para public 'CODE' use32
.text$mn:00005ED8                 assume cs:_text$mn
.text$mn:00005ED8                 ;org 5ED8h
.text$mn:00005ED8 ; COMDAT (pick any)
.text$mn:00005ED8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005ED8
.text$mn:00005ED8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005ED8
.text$mn:00005ED8 ; Attributes: bp-based frame
.text$mn:00005ED8
.text$mn:00005ED8 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00005ED8                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00005ED8 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00005ED8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00005ED8                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p ...
.text$mn:00005ED8
.text$mn:00005ED8 var_4           = dword ptr -4
.text$mn:00005ED8 arg_0           = dword ptr  8
.text$mn:00005ED8
.text$mn:00005ED8                 push    ebp
.text$mn:00005ED9                 mov     ebp, esp
.text$mn:00005EDB                 push    ecx
.text$mn:00005EDC                 mov     [ebp+var_4], ecx
.text$mn:00005EDF                 mov     eax, [ebp+arg_0]
.text$mn:00005EE2                 push    eax             ; void *
.text$mn:00005EE3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005EE8                 add     esp, 4
.text$mn:00005EEB                 mov     esp, ebp
.text$mn:00005EED                 pop     ebp
.text$mn:00005EEE                 retn    8
.text$mn:00005EEE ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00005EEE
.text$mn:00005EEE ; ---------------------------------------------------------------------------
.text$mn:00005EF1                 align 4
.text$mn:00005EF1 _text$mn        ends
.text$mn:00005EF1
.text$mn:00005EF4 ; ===========================================================================
.text$mn:00005EF4
.text$mn:00005EF4 ; Segment type: Pure code
.text$mn:00005EF4 ; Segment permissions: Read/Execute
.text$mn:00005EF4 _text$mn        segment para public 'CODE' use32
.text$mn:00005EF4                 assume cs:_text$mn
.text$mn:00005EF4                 ;org 5EF4h
.text$mn:00005EF4 ; COMDAT (pick any)
.text$mn:00005EF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005EF4
.text$mn:00005EF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005EF4
.text$mn:00005EF4 ; Attributes: bp-based frame
.text$mn:00005EF4
.text$mn:00005EF4 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:00005EF4                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:00005EF4 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:00005EF4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:00005EF4
.text$mn:00005EF4 var_4           = dword ptr -4
.text$mn:00005EF4 arg_0           = dword ptr  8
.text$mn:00005EF4
.text$mn:00005EF4                 push    ebp
.text$mn:00005EF5                 mov     ebp, esp
.text$mn:00005EF7                 push    ecx
.text$mn:00005EF8                 mov     [ebp+var_4], ecx
.text$mn:00005EFB                 mov     eax, [ebp+arg_0]
.text$mn:00005EFE                 push    eax             ; void *
.text$mn:00005EFF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005F04                 add     esp, 4
.text$mn:00005F07                 mov     esp, ebp
.text$mn:00005F09                 pop     ebp
.text$mn:00005F0A                 retn    8
.text$mn:00005F0A ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:00005F0A
.text$mn:00005F0A ; ---------------------------------------------------------------------------
.text$mn:00005F0D                 align 10h
.text$mn:00005F0D _text$mn        ends
.text$mn:00005F0D
.text$mn:00005F10 ; ===========================================================================
.text$mn:00005F10
.text$mn:00005F10 ; Segment type: Pure code
.text$mn:00005F10 ; Segment permissions: Read/Execute
.text$mn:00005F10 _text$mn        segment para public 'CODE' use32
.text$mn:00005F10                 assume cs:_text$mn
.text$mn:00005F10                 ;org 5F10h
.text$mn:00005F10 ; COMDAT (pick any)
.text$mn:00005F10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F10
.text$mn:00005F10 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F10
.text$mn:00005F10 ; Attributes: bp-based frame
.text$mn:00005F10
.text$mn:00005F10 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00005F10                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00005F10 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00005F10                                         ; DATA XREF: .rdata:00007BD8o
.text$mn:00005F10
.text$mn:00005F10 var_4           = dword ptr -4
.text$mn:00005F10 arg_0           = dword ptr  8
.text$mn:00005F10 arg_4           = dword ptr  0Ch
.text$mn:00005F10
.text$mn:00005F10                 push    ebp
.text$mn:00005F11                 mov     ebp, esp
.text$mn:00005F13                 push    ecx
.text$mn:00005F14                 mov     [ebp+var_4], ecx
.text$mn:00005F17                 mov     eax, [ebp+arg_4]
.text$mn:00005F1A                 push    eax             ; int
.text$mn:00005F1B                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00005F20                 add     esp, 4
.text$mn:00005F23                 test    eax, eax
.text$mn:00005F25                 jz      short loc_5F40
.text$mn:00005F27                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00005F2C                 push    eax             ; struct std::error_category *
.text$mn:00005F2D                 mov     ecx, [ebp+arg_4]
.text$mn:00005F30                 push    ecx             ; int
.text$mn:00005F31                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005F34                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00005F39                 mov     eax, [ebp+arg_0]
.text$mn:00005F3C                 jmp     short loc_5F55
.text$mn:00005F3E ; ---------------------------------------------------------------------------
.text$mn:00005F3E                 jmp     short loc_5F55
.text$mn:00005F40 ; ---------------------------------------------------------------------------
.text$mn:00005F40
.text$mn:00005F40 loc_5F40:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00005F40                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00005F45                 push    eax             ; struct std::error_category *
.text$mn:00005F46                 mov     edx, [ebp+arg_4]
.text$mn:00005F49                 push    edx             ; int
.text$mn:00005F4A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005F4D                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00005F52                 mov     eax, [ebp+arg_0]
.text$mn:00005F55
.text$mn:00005F55 loc_5F55:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00005F55                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00005F55                 mov     esp, ebp
.text$mn:00005F57                 pop     ebp
.text$mn:00005F58                 retn    8
.text$mn:00005F58 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00005F58
.text$mn:00005F58 ; ---------------------------------------------------------------------------
.text$mn:00005F5B                 align 4
.text$mn:00005F5B _text$mn        ends
.text$mn:00005F5B
.text$mn:00005F5C ; ===========================================================================
.text$mn:00005F5C
.text$mn:00005F5C ; Segment type: Pure code
.text$mn:00005F5C ; Segment permissions: Read/Execute
.text$mn:00005F5C _text$mn        segment para public 'CODE' use32
.text$mn:00005F5C                 assume cs:_text$mn
.text$mn:00005F5C                 ;org 5F5Ch
.text$mn:00005F5C ; COMDAT (pick any)
.text$mn:00005F5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F5C
.text$mn:00005F5C ; =============== S U B R O U T I N E =======================================
.text$mn:00005F5C
.text$mn:00005F5C ; Attributes: bp-based frame
.text$mn:00005F5C
.text$mn:00005F5C ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00005F5C                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00005F5C ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00005F5C                                         ; DATA XREF: .rdata:00007B48o
.text$mn:00005F5C                                         ; .rdata:00007B64o ...
.text$mn:00005F5C
.text$mn:00005F5C var_4           = dword ptr -4
.text$mn:00005F5C arg_0           = dword ptr  8
.text$mn:00005F5C arg_4           = dword ptr  0Ch
.text$mn:00005F5C
.text$mn:00005F5C                 push    ebp
.text$mn:00005F5D                 mov     ebp, esp
.text$mn:00005F5F                 push    ecx
.text$mn:00005F60                 mov     [ebp+var_4], ecx
.text$mn:00005F63                 mov     eax, [ebp+var_4]
.text$mn:00005F66                 push    eax             ; struct std::error_category *
.text$mn:00005F67                 mov     ecx, [ebp+arg_4]
.text$mn:00005F6A                 push    ecx             ; int
.text$mn:00005F6B                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005F6E                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00005F73                 mov     eax, [ebp+arg_0]
.text$mn:00005F76                 mov     esp, ebp
.text$mn:00005F78                 pop     ebp
.text$mn:00005F79                 retn    8
.text$mn:00005F79 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00005F79
.text$mn:00005F79 _text$mn        ends
.text$mn:00005F79
.text$mn:00005F7C ; ===========================================================================
.text$mn:00005F7C
.text$mn:00005F7C ; Segment type: Pure code
.text$mn:00005F7C ; Segment permissions: Read/Execute
.text$mn:00005F7C _text$mn        segment para public 'CODE' use32
.text$mn:00005F7C                 assume cs:_text$mn
.text$mn:00005F7C                 ;org 5F7Ch
.text$mn:00005F7C ; COMDAT (pick any)
.text$mn:00005F7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F7C
.text$mn:00005F7C ; =============== S U B R O U T I N E =======================================
.text$mn:00005F7C
.text$mn:00005F7C ; Attributes: bp-based frame
.text$mn:00005F7C
.text$mn:00005F7C ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct TreeStateNode>>> __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::end(void)const
.text$mn:00005F7C                 public ?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ
.text$mn:00005F7C ?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ proc near
.text$mn:00005F7C                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(std::vector<TreeStateNode,std::allocator<TreeStateNode>> const &)+89p
.text$mn:00005F7C
.text$mn:00005F7C var_14          = dword ptr -14h
.text$mn:00005F7C var_10          = dword ptr -10h
.text$mn:00005F7C var_C           = dword ptr -0Ch
.text$mn:00005F7C var_4           = dword ptr -4
.text$mn:00005F7C arg_0           = dword ptr  8
.text$mn:00005F7C
.text$mn:00005F7C                 push    ebp
.text$mn:00005F7D                 mov     ebp, esp
.text$mn:00005F7F                 push    0FFFFFFFFh
.text$mn:00005F81                 push    offset __ehhandler$?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ
.text$mn:00005F86                 mov     eax, large fs:0
.text$mn:00005F8C                 push    eax
.text$mn:00005F8D                 sub     esp, 8
.text$mn:00005F90                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005F95                 xor     eax, ebp
.text$mn:00005F97                 push    eax
.text$mn:00005F98                 lea     eax, [ebp+var_C]
.text$mn:00005F9B                 mov     large fs:0, eax
.text$mn:00005FA1                 mov     [ebp+var_10], ecx
.text$mn:00005FA4                 mov     [ebp+var_14], 0
.text$mn:00005FAB                 mov     eax, [ebp+var_10]
.text$mn:00005FAE                 push    eax             ; struct std::_Container_base12 *
.text$mn:00005FAF                 mov     ecx, [ebp+var_10]
.text$mn:00005FB2                 mov     edx, [ecx+8]
.text$mn:00005FB5                 push    edx             ; int
.text$mn:00005FB6                 mov     ecx, [ebp+arg_0]
.text$mn:00005FB9                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(TreeStateNode *,std::_Container_base12 const *)
.text$mn:00005FBE                 mov     [ebp+var_4], 0
.text$mn:00005FC5                 mov     eax, [ebp+var_14]
.text$mn:00005FC8                 or      eax, 1
.text$mn:00005FCB                 mov     [ebp+var_14], eax
.text$mn:00005FCE                 mov     eax, [ebp+arg_0]
.text$mn:00005FD1                 mov     ecx, [ebp+var_C]
.text$mn:00005FD4                 mov     large fs:0, ecx
.text$mn:00005FDB                 pop     ecx
.text$mn:00005FDC                 mov     esp, ebp
.text$mn:00005FDE                 pop     ebp
.text$mn:00005FDF                 retn    4
.text$mn:00005FDF ?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ endp
.text$mn:00005FDF
.text$mn:00005FDF ; ---------------------------------------------------------------------------
.text$mn:00005FE2                 align 4
.text$mn:00005FE2 _text$mn        ends
.text$mn:00005FE2
.text$x:00005FE4 ; ===========================================================================
.text$x:00005FE4
.text$x:00005FE4 ; Segment type: Pure code
.text$x:00005FE4 ; Segment permissions: Read/Execute
.text$x:00005FE4 _text$x         segment para public 'CODE' use32
.text$x:00005FE4                 assume cs:_text$x
.text$x:00005FE4                 ;org 5FE4h
.text$x:00005FE4 ; COMDAT (pick associative to section at 5F7C)
.text$x:00005FE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005FE4
.text$x:00005FE4 ; =============== S U B R O U T I N E =======================================
.text$x:00005FE4
.text$x:00005FE4
.text$x:00005FE4 __unwindfunclet$?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ$0 proc near
.text$x:00005FE4                                         ; DATA XREF: .xdata$x:00007498o
.text$x:00005FE4                 mov     eax, [ebp-14h]
.text$x:00005FE7                 and     eax, 1
.text$x:00005FEA                 jz      $LN4_0
.text$x:00005FF0                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00005FF4                 mov     ecx, [ebp+8]
.text$x:00005FF7                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TreeStateNode>>>(void)
.text$x:00005FFC ; ---------------------------------------------------------------------------
.text$x:00005FFC
.text$x:00005FFC $LN4_0:                                 ; CODE XREF: __unwindfunclet$?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ$0+6j
.text$x:00005FFC                 retn
.text$x:00005FFC __unwindfunclet$?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ$0 endp
.text$x:00005FFC
.text$x:00005FFD
.text$x:00005FFD ; =============== S U B R O U T I N E =======================================
.text$x:00005FFD
.text$x:00005FFD
.text$x:00005FFD __ehhandler$?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ proc near
.text$x:00005FFD                                         ; DATA XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::end(void)+5o
.text$x:00005FFD
.text$x:00005FFD arg_4           = dword ptr  8
.text$x:00005FFD
.text$x:00005FFD                 mov     edx, [esp+arg_4]
.text$x:00006001                 lea     eax, [edx+0Ch]
.text$x:00006004                 mov     ecx, [edx-0Ch]
.text$x:00006007                 xor     ecx, eax
.text$x:00006009                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000600E                 mov     eax, offset __ehfuncinfo$?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ
.text$x:00006013                 jmp     ___CxxFrameHandler3
.text$x:00006013 __ehhandler$?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ endp
.text$x:00006013
.text$x:00006013 _text$x         ends
.text$x:00006013
.text$mn:00006018 ; ===========================================================================
.text$mn:00006018
.text$mn:00006018 ; Segment type: Pure code
.text$mn:00006018 ; Segment permissions: Read/Execute
.text$mn:00006018 _text$mn        segment para public 'CODE' use32
.text$mn:00006018                 assume cs:_text$mn
.text$mn:00006018                 ;org 6018h
.text$mn:00006018 ; COMDAT (pick any)
.text$mn:00006018                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006018
.text$mn:00006018 ; =============== S U B R O U T I N E =======================================
.text$mn:00006018
.text$mn:00006018 ; Attributes: bp-based frame
.text$mn:00006018
.text$mn:00006018 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00006018                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00006018 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00006018                                         ; DATA XREF: .rdata:00007B4Co
.text$mn:00006018                                         ; .rdata:00007B68o ...
.text$mn:00006018
.text$mn:00006018 var_8           = dword ptr -8
.text$mn:00006018 var_4           = dword ptr -4
.text$mn:00006018 arg_0           = dword ptr  8
.text$mn:00006018 arg_4           = dword ptr  0Ch
.text$mn:00006018
.text$mn:00006018                 push    ebp
.text$mn:00006019                 mov     ebp, esp
.text$mn:0000601B                 sub     esp, 8
.text$mn:0000601E                 mov     [ebp+var_8], ecx
.text$mn:00006021                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006024                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00006029                 push    eax
.text$mn:0000602A                 mov     ecx, [ebp+var_8]
.text$mn:0000602D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00006032                 movzx   eax, al
.text$mn:00006035                 test    eax, eax
.text$mn:00006037                 jz      short loc_604F
.text$mn:00006039                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000603C                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00006041                 cmp     eax, [ebp+arg_4]
.text$mn:00006044                 jnz     short loc_604F
.text$mn:00006046                 mov     [ebp+var_4], 1
.text$mn:0000604D                 jmp     short loc_6056
.text$mn:0000604F ; ---------------------------------------------------------------------------
.text$mn:0000604F
.text$mn:0000604F loc_604F:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000604F                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000604F                 mov     [ebp+var_4], 0
.text$mn:00006056
.text$mn:00006056 loc_6056:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00006056                 mov     al, byte ptr [ebp+var_4]
.text$mn:00006059                 mov     esp, ebp
.text$mn:0000605B                 pop     ebp
.text$mn:0000605C                 retn    8
.text$mn:0000605C ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:0000605C
.text$mn:0000605C ; ---------------------------------------------------------------------------
.text$mn:0000605F                 align 10h
.text$mn:0000605F _text$mn        ends
.text$mn:0000605F
.text$mn:00006060 ; ===========================================================================
.text$mn:00006060
.text$mn:00006060 ; Segment type: Pure code
.text$mn:00006060 ; Segment permissions: Read/Execute
.text$mn:00006060 _text$mn        segment para public 'CODE' use32
.text$mn:00006060                 assume cs:_text$mn
.text$mn:00006060                 ;org 6060h
.text$mn:00006060 ; COMDAT (pick any)
.text$mn:00006060                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006060
.text$mn:00006060 ; =============== S U B R O U T I N E =======================================
.text$mn:00006060
.text$mn:00006060 ; Attributes: bp-based frame
.text$mn:00006060
.text$mn:00006060 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00006060                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00006060 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00006060                                         ; DATA XREF: .rdata:00007B50o
.text$mn:00006060                                         ; .rdata:00007B6Co ...
.text$mn:00006060
.text$mn:00006060 var_C           = byte ptr -0Ch
.text$mn:00006060 var_4           = dword ptr -4
.text$mn:00006060 arg_0           = dword ptr  8
.text$mn:00006060 arg_4           = dword ptr  0Ch
.text$mn:00006060
.text$mn:00006060                 push    ebp
.text$mn:00006061                 mov     ebp, esp
.text$mn:00006063                 sub     esp, 0Ch
.text$mn:00006066                 mov     [ebp+var_4], ecx
.text$mn:00006069                 mov     eax, [ebp+arg_4]
.text$mn:0000606C                 push    eax             ; std::error_condition *
.text$mn:0000606D                 mov     ecx, [ebp+arg_0]
.text$mn:00006070                 push    ecx
.text$mn:00006071                 lea     edx, [ebp+var_C]
.text$mn:00006074                 push    edx
.text$mn:00006075                 mov     eax, [ebp+var_4]
.text$mn:00006078                 mov     edx, [eax]
.text$mn:0000607A                 mov     ecx, [ebp+var_4]
.text$mn:0000607D                 mov     eax, [edx+0Ch]
.text$mn:00006080                 call    eax
.text$mn:00006082                 mov     ecx, eax
.text$mn:00006084                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00006089                 mov     esp, ebp
.text$mn:0000608B                 pop     ebp
.text$mn:0000608C                 retn    8
.text$mn:0000608C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:0000608C
.text$mn:0000608C ; ---------------------------------------------------------------------------
.text$mn:0000608F                 align 10h
.text$mn:0000608F _text$mn        ends
.text$mn:0000608F
.text$mn:00006090 ; ===========================================================================
.text$mn:00006090
.text$mn:00006090 ; Segment type: Pure code
.text$mn:00006090 ; Segment permissions: Read/Execute
.text$mn:00006090 _text$mn        segment para public 'CODE' use32
.text$mn:00006090                 assume cs:_text$mn
.text$mn:00006090                 ;org 6090h
.text$mn:00006090 ; COMDAT (pick any)
.text$mn:00006090                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006090
.text$mn:00006090 ; =============== S U B R O U T I N E =======================================
.text$mn:00006090
.text$mn:00006090 ; Attributes: bp-based frame
.text$mn:00006090
.text$mn:00006090 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00006090                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00006090 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00006090                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00006090
.text$mn:00006090 var_4           = dword ptr -4
.text$mn:00006090 arg_0           = dword ptr  8
.text$mn:00006090
.text$mn:00006090                 push    ebp
.text$mn:00006091                 mov     ebp, esp
.text$mn:00006093                 push    ecx
.text$mn:00006094                 mov     [ebp+var_4], ecx
.text$mn:00006097                 mov     eax, [ebp+var_4]
.text$mn:0000609A                 mov     ecx, [eax+14h]
.text$mn:0000609D                 cmp     ecx, [ebp+arg_0]
.text$mn:000060A0                 jnb     short loc_60AA
.text$mn:000060A2                 mov     ecx, [ebp+var_4]
.text$mn:000060A5                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000060AA
.text$mn:000060AA loc_60AA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:000060AA                 mov     edx, [ebp+arg_0]
.text$mn:000060AD                 push    edx
.text$mn:000060AE                 mov     ecx, [ebp+var_4]
.text$mn:000060B1                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000060B6                 mov     eax, [ebp+var_4]
.text$mn:000060B9                 mov     esp, ebp
.text$mn:000060BB                 pop     ebp
.text$mn:000060BC                 retn    4
.text$mn:000060BC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:000060BC
.text$mn:000060BC ; ---------------------------------------------------------------------------
.text$mn:000060BF                 align 10h
.text$mn:000060BF _text$mn        ends
.text$mn:000060BF
.text$mn:000060C0 ; ===========================================================================
.text$mn:000060C0
.text$mn:000060C0 ; Segment type: Pure code
.text$mn:000060C0 ; Segment permissions: Read/Execute
.text$mn:000060C0 _text$mn        segment para public 'CODE' use32
.text$mn:000060C0                 assume cs:_text$mn
.text$mn:000060C0                 ;org 60C0h
.text$mn:000060C0 ; COMDAT (pick any)
.text$mn:000060C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000060C0
.text$mn:000060C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000060C0
.text$mn:000060C0 ; Attributes: bp-based frame
.text$mn:000060C0
.text$mn:000060C0 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:000060C0                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:000060C0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:000060C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:000060C0
.text$mn:000060C0 var_C           = dword ptr -0Ch
.text$mn:000060C0 Dst             = dword ptr -8
.text$mn:000060C0 var_4           = dword ptr -4
.text$mn:000060C0 arg_0           = dword ptr  8
.text$mn:000060C0 arg_4           = dword ptr  0Ch
.text$mn:000060C0
.text$mn:000060C0                 push    ebp
.text$mn:000060C1                 mov     ebp, esp
.text$mn:000060C3                 sub     esp, 0Ch
.text$mn:000060C6                 mov     [ebp+var_4], ecx
.text$mn:000060C9                 mov     eax, [ebp+var_4]
.text$mn:000060CC                 mov     ecx, [eax+14h]
.text$mn:000060CF                 cmp     ecx, [ebp+arg_0]
.text$mn:000060D2                 jnb     short loc_60DC
.text$mn:000060D4                 mov     ecx, [ebp+var_4]
.text$mn:000060D7                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000060DC
.text$mn:000060DC loc_60DC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:000060DC                 mov     edx, [ebp+var_4]
.text$mn:000060DF                 mov     eax, [edx+14h]
.text$mn:000060E2                 sub     eax, [ebp+arg_0]
.text$mn:000060E5                 cmp     eax, [ebp+arg_4]
.text$mn:000060E8                 ja      short loc_60F8
.text$mn:000060EA                 mov     ecx, [ebp+arg_0]
.text$mn:000060ED                 push    ecx
.text$mn:000060EE                 mov     ecx, [ebp+var_4]
.text$mn:000060F1                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000060F6                 jmp     short loc_613E
.text$mn:000060F8 ; ---------------------------------------------------------------------------
.text$mn:000060F8
.text$mn:000060F8 loc_60F8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:000060F8                 cmp     [ebp+arg_4], 0
.text$mn:000060FC                 jbe     short loc_613E
.text$mn:000060FE                 mov     ecx, [ebp+var_4]
.text$mn:00006101                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006106                 add     eax, [ebp+arg_0]
.text$mn:00006109                 mov     [ebp+Dst], eax
.text$mn:0000610C                 mov     edx, [ebp+var_4]
.text$mn:0000610F                 mov     eax, [edx+14h]
.text$mn:00006112                 sub     eax, [ebp+arg_4]
.text$mn:00006115                 mov     [ebp+var_C], eax
.text$mn:00006118                 mov     ecx, [ebp+var_C]
.text$mn:0000611B                 sub     ecx, [ebp+arg_0]
.text$mn:0000611E                 push    ecx             ; Size
.text$mn:0000611F                 mov     edx, [ebp+Dst]
.text$mn:00006122                 add     edx, [ebp+arg_4]
.text$mn:00006125                 push    edx             ; Src
.text$mn:00006126                 mov     eax, [ebp+Dst]
.text$mn:00006129                 push    eax             ; Dst
.text$mn:0000612A                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000612F                 add     esp, 0Ch
.text$mn:00006132                 mov     ecx, [ebp+var_C]
.text$mn:00006135                 push    ecx
.text$mn:00006136                 mov     ecx, [ebp+var_4]
.text$mn:00006139                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000613E
.text$mn:0000613E loc_613E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000613E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000613E                 mov     eax, [ebp+var_4]
.text$mn:00006141                 mov     esp, ebp
.text$mn:00006143                 pop     ebp
.text$mn:00006144                 retn    8
.text$mn:00006144 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00006144
.text$mn:00006144 ; ---------------------------------------------------------------------------
.text$mn:00006147                 align 4
.text$mn:00006147 _text$mn        ends
.text$mn:00006147
.text$mn:00006148 ; ===========================================================================
.text$mn:00006148
.text$mn:00006148 ; Segment type: Pure code
.text$mn:00006148 ; Segment permissions: Read/Execute
.text$mn:00006148 _text$mn        segment para public 'CODE' use32
.text$mn:00006148                 assume cs:_text$mn
.text$mn:00006148                 ;org 6148h
.text$mn:00006148 ; COMDAT (pick any)
.text$mn:00006148                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006148
.text$mn:00006148 ; =============== S U B R O U T I N E =======================================
.text$mn:00006148
.text$mn:00006148 ; Attributes: bp-based frame
.text$mn:00006148
.text$mn:00006148 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:00006148                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:00006148 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00006148                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:00006148
.text$mn:00006148 var_4           = dword ptr -4
.text$mn:00006148 arg_0           = dword ptr  8
.text$mn:00006148
.text$mn:00006148                 push    ebp
.text$mn:00006149                 mov     ebp, esp
.text$mn:0000614B                 push    ecx
.text$mn:0000614C                 mov     [ebp+var_4], ecx
.text$mn:0000614F                 mov     eax, [ebp+var_4]
.text$mn:00006152                 mov     ecx, [eax+14h]
.text$mn:00006155                 cmp     ecx, [ebp+arg_0]
.text$mn:00006158                 jnb     short loc_6162
.text$mn:0000615A                 mov     ecx, [ebp+var_4]
.text$mn:0000615D                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00006162
.text$mn:00006162 loc_6162:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:00006162                 mov     edx, [ebp+arg_0]
.text$mn:00006165                 push    edx
.text$mn:00006166                 mov     ecx, [ebp+var_4]
.text$mn:00006169                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000616E                 mov     eax, [ebp+var_4]
.text$mn:00006171                 mov     esp, ebp
.text$mn:00006173                 pop     ebp
.text$mn:00006174                 retn    4
.text$mn:00006174 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:00006174
.text$mn:00006174 ; ---------------------------------------------------------------------------
.text$mn:00006177                 align 4
.text$mn:00006177 _text$mn        ends
.text$mn:00006177
.text$mn:00006178 ; ===========================================================================
.text$mn:00006178
.text$mn:00006178 ; Segment type: Pure code
.text$mn:00006178 ; Segment permissions: Read/Execute
.text$mn:00006178 _text$mn        segment para public 'CODE' use32
.text$mn:00006178                 assume cs:_text$mn
.text$mn:00006178                 ;org 6178h
.text$mn:00006178 ; COMDAT (pick any)
.text$mn:00006178                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006178
.text$mn:00006178 ; =============== S U B R O U T I N E =======================================
.text$mn:00006178
.text$mn:00006178 ; Attributes: bp-based frame
.text$mn:00006178
.text$mn:00006178 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:00006178                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:00006178 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00006178                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:00006178
.text$mn:00006178 var_C           = dword ptr -0Ch
.text$mn:00006178 Dst             = dword ptr -8
.text$mn:00006178 var_4           = dword ptr -4
.text$mn:00006178 arg_0           = dword ptr  8
.text$mn:00006178 arg_4           = dword ptr  0Ch
.text$mn:00006178
.text$mn:00006178                 push    ebp
.text$mn:00006179                 mov     ebp, esp
.text$mn:0000617B                 sub     esp, 0Ch
.text$mn:0000617E                 mov     [ebp+var_4], ecx
.text$mn:00006181                 mov     eax, [ebp+var_4]
.text$mn:00006184                 mov     ecx, [eax+14h]
.text$mn:00006187                 cmp     ecx, [ebp+arg_0]
.text$mn:0000618A                 jnb     short loc_6194
.text$mn:0000618C                 mov     ecx, [ebp+var_4]
.text$mn:0000618F                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00006194
.text$mn:00006194 loc_6194:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:00006194                 mov     edx, [ebp+var_4]
.text$mn:00006197                 mov     eax, [edx+14h]
.text$mn:0000619A                 sub     eax, [ebp+arg_0]
.text$mn:0000619D                 cmp     eax, [ebp+arg_4]
.text$mn:000061A0                 ja      short loc_61B0
.text$mn:000061A2                 mov     ecx, [ebp+arg_0]
.text$mn:000061A5                 push    ecx
.text$mn:000061A6                 mov     ecx, [ebp+var_4]
.text$mn:000061A9                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000061AE                 jmp     short loc_61FC
.text$mn:000061B0 ; ---------------------------------------------------------------------------
.text$mn:000061B0
.text$mn:000061B0 loc_61B0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:000061B0                 cmp     [ebp+arg_4], 0
.text$mn:000061B4                 jbe     short loc_61FC
.text$mn:000061B6                 mov     ecx, [ebp+var_4]
.text$mn:000061B9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000061BE                 mov     edx, [ebp+arg_0]
.text$mn:000061C1                 lea     eax, [eax+edx*2]
.text$mn:000061C4                 mov     [ebp+Dst], eax
.text$mn:000061C7                 mov     ecx, [ebp+var_4]
.text$mn:000061CA                 mov     edx, [ecx+14h]
.text$mn:000061CD                 sub     edx, [ebp+arg_4]
.text$mn:000061D0                 mov     [ebp+var_C], edx
.text$mn:000061D3                 mov     eax, [ebp+var_C]
.text$mn:000061D6                 sub     eax, [ebp+arg_0]
.text$mn:000061D9                 push    eax             ; int
.text$mn:000061DA                 mov     ecx, [ebp+arg_4]
.text$mn:000061DD                 mov     edx, [ebp+Dst]
.text$mn:000061E0                 lea     eax, [edx+ecx*2]
.text$mn:000061E3                 push    eax             ; Src
.text$mn:000061E4                 mov     ecx, [ebp+Dst]
.text$mn:000061E7                 push    ecx             ; Dst
.text$mn:000061E8                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000061ED                 add     esp, 0Ch
.text$mn:000061F0                 mov     edx, [ebp+var_C]
.text$mn:000061F3                 push    edx
.text$mn:000061F4                 mov     ecx, [ebp+var_4]
.text$mn:000061F7                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000061FC
.text$mn:000061FC loc_61FC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:000061FC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:000061FC                 mov     eax, [ebp+var_4]
.text$mn:000061FF                 mov     esp, ebp
.text$mn:00006201                 pop     ebp
.text$mn:00006202                 retn    8
.text$mn:00006202 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:00006202
.text$mn:00006202 ; ---------------------------------------------------------------------------
.text$mn:00006205                 align 4
.text$mn:00006205 _text$mn        ends
.text$mn:00006205
.text$mn:00006208 ; ===========================================================================
.text$mn:00006208
.text$mn:00006208 ; Segment type: Pure code
.text$mn:00006208 ; Segment permissions: Read/Execute
.text$mn:00006208 _text$mn        segment para public 'CODE' use32
.text$mn:00006208                 assume cs:_text$mn
.text$mn:00006208                 ;org 6208h
.text$mn:00006208 ; COMDAT (pick any)
.text$mn:00006208                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006208
.text$mn:00006208 ; =============== S U B R O U T I N E =======================================
.text$mn:00006208
.text$mn:00006208 ; Attributes: bp-based frame
.text$mn:00006208
.text$mn:00006208 ; void __thiscall TreeView::expand(TreeView *this, struct _TREEITEM *)
.text$mn:00006208                 public ?expand@TreeView@@QBEXPAU_TREEITEM@@@Z
.text$mn:00006208 ?expand@TreeView@@QBEXPAU_TREEITEM@@@Z proc near
.text$mn:00006208                                         ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+D0p
.text$mn:00006208
.text$mn:00006208 var_4           = dword ptr -4
.text$mn:00006208 lParam          = dword ptr  8
.text$mn:00006208
.text$mn:00006208                 push    ebp
.text$mn:00006209                 mov     ebp, esp
.text$mn:0000620B                 push    ecx
.text$mn:0000620C                 mov     [ebp+var_4], ecx
.text$mn:0000620F                 mov     eax, [ebp+lParam]
.text$mn:00006212                 push    eax             ; lParam
.text$mn:00006213                 push    2               ; wParam
.text$mn:00006215                 push    1102h           ; Msg
.text$mn:0000621A                 mov     ecx, [ebp+var_4]
.text$mn:0000621D                 mov     edx, [ecx+0Ch]
.text$mn:00006220                 push    edx             ; hWnd
.text$mn:00006221                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00006227                 mov     esp, ebp
.text$mn:00006229                 pop     ebp
.text$mn:0000622A                 retn    4
.text$mn:0000622A ?expand@TreeView@@QBEXPAU_TREEITEM@@@Z endp
.text$mn:0000622A
.text$mn:0000622A ; ---------------------------------------------------------------------------
.text$mn:0000622D                 align 10h
.text$mn:0000622D _text$mn        ends
.text$mn:0000622D
.text$mn:00006230 ; ===========================================================================
.text$mn:00006230
.text$mn:00006230 ; Segment type: Pure code
.text$mn:00006230 ; Segment permissions: Read/Execute
.text$mn:00006230 _text$mn        segment para public 'CODE' use32
.text$mn:00006230                 assume cs:_text$mn
.text$mn:00006230                 ;org 6230h
.text$mn:00006230 ; COMDAT (pick any)
.text$mn:00006230                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006230
.text$mn:00006230 ; =============== S U B R O U T I N E =======================================
.text$mn:00006230
.text$mn:00006230 ; Attributes: bp-based frame
.text$mn:00006230
.text$mn:00006230 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::find(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int)const
.text$mn:00006230                 public ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIABV12@I@Z
.text$mn:00006230 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIABV12@I@Z proc near
.text$mn:00006230                                         ; CODE XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+13Fp
.text$mn:00006230
.text$mn:00006230 var_4           = dword ptr -4
.text$mn:00006230 arg_0           = dword ptr  8
.text$mn:00006230 arg_4           = dword ptr  0Ch
.text$mn:00006230
.text$mn:00006230                 push    ebp
.text$mn:00006231                 mov     ebp, esp
.text$mn:00006233                 push    ecx
.text$mn:00006234                 mov     [ebp+var_4], ecx
.text$mn:00006237                 mov     ecx, [ebp+arg_0]
.text$mn:0000623A                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000623F                 push    eax
.text$mn:00006240                 mov     eax, [ebp+arg_4]
.text$mn:00006243                 push    eax
.text$mn:00006244                 mov     ecx, [ebp+arg_0]
.text$mn:00006247                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000624C                 push    eax
.text$mn:0000624D                 mov     ecx, [ebp+var_4]
.text$mn:00006250                 call    ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)
.text$mn:00006255                 mov     esp, ebp
.text$mn:00006257                 pop     ebp
.text$mn:00006258                 retn    8
.text$mn:00006258 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIABV12@I@Z endp
.text$mn:00006258
.text$mn:00006258 ; ---------------------------------------------------------------------------
.text$mn:0000625B                 align 4
.text$mn:0000625B _text$mn        ends
.text$mn:0000625B
.text$mn:0000625C ; ===========================================================================
.text$mn:0000625C
.text$mn:0000625C ; Segment type: Pure code
.text$mn:0000625C ; Segment permissions: Read/Execute
.text$mn:0000625C _text$mn        segment para public 'CODE' use32
.text$mn:0000625C                 assume cs:_text$mn
.text$mn:0000625C                 ;org 625Ch
.text$mn:0000625C ; COMDAT (pick any)
.text$mn:0000625C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000625C
.text$mn:0000625C ; =============== S U B R O U T I N E =======================================
.text$mn:0000625C
.text$mn:0000625C ; Attributes: bp-based frame
.text$mn:0000625C
.text$mn:0000625C ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::find(wchar_t const *, unsigned int, unsigned int)const
.text$mn:0000625C                 public ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z
.text$mn:0000625C ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z proc near
.text$mn:0000625C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+20p
.text$mn:0000625C
.text$mn:0000625C var_10          = dword ptr -10h
.text$mn:0000625C var_C           = dword ptr -0Ch
.text$mn:0000625C var_8           = dword ptr -8
.text$mn:0000625C var_4           = dword ptr -4
.text$mn:0000625C arg_0           = dword ptr  8
.text$mn:0000625C arg_4           = dword ptr  0Ch
.text$mn:0000625C arg_8           = dword ptr  10h
.text$mn:0000625C
.text$mn:0000625C                 push    ebp
.text$mn:0000625D                 mov     ebp, esp
.text$mn:0000625F                 sub     esp, 10h
.text$mn:00006262                 mov     [ebp+var_8], ecx
.text$mn:00006265                 cmp     [ebp+arg_8], 0
.text$mn:00006269                 jz      short loc_6281
.text$mn:0000626B                 push    768h            ; unsigned int
.text$mn:00006270                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006275                 mov     eax, [ebp+arg_0]
.text$mn:00006278                 push    eax             ; int
.text$mn:00006279                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000627E                 add     esp, 0Ch
.text$mn:00006281
.text$mn:00006281 loc_6281:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+Dj
.text$mn:00006281                 cmp     [ebp+arg_8], 0
.text$mn:00006285                 jnz     short loc_629A
.text$mn:00006287                 mov     ecx, [ebp+var_8]
.text$mn:0000628A                 mov     edx, [ebp+arg_4]
.text$mn:0000628D                 cmp     edx, [ecx+14h]
.text$mn:00006290                 ja      short loc_629A
.text$mn:00006292                 mov     eax, [ebp+arg_4]
.text$mn:00006295                 jmp     loc_634D
.text$mn:0000629A ; ---------------------------------------------------------------------------
.text$mn:0000629A
.text$mn:0000629A loc_629A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+29j
.text$mn:0000629A                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+34j
.text$mn:0000629A                 mov     eax, [ebp+var_8]
.text$mn:0000629D                 mov     ecx, [ebp+arg_4]
.text$mn:000062A0                 cmp     ecx, [eax+14h]
.text$mn:000062A3                 jnb     loc_6348
.text$mn:000062A9                 mov     edx, [ebp+var_8]
.text$mn:000062AC                 mov     eax, [edx+14h]
.text$mn:000062AF                 sub     eax, [ebp+arg_4]
.text$mn:000062B2                 mov     [ebp+var_4], eax
.text$mn:000062B5                 mov     ecx, [ebp+arg_8]
.text$mn:000062B8                 cmp     ecx, [ebp+var_4]
.text$mn:000062BB                 ja      loc_6348
.text$mn:000062C1                 mov     edx, [ebp+arg_8]
.text$mn:000062C4                 sub     edx, 1
.text$mn:000062C7                 mov     eax, [ebp+var_4]
.text$mn:000062CA                 sub     eax, edx
.text$mn:000062CC                 mov     [ebp+var_4], eax
.text$mn:000062CF                 mov     ecx, [ebp+var_8]
.text$mn:000062D2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000062D7                 mov     ecx, [ebp+arg_4]
.text$mn:000062DA                 lea     edx, [eax+ecx*2]
.text$mn:000062DD                 mov     [ebp+var_10], edx
.text$mn:000062E0                 jmp     short loc_62FE
.text$mn:000062E2 ; ---------------------------------------------------------------------------
.text$mn:000062E2
.text$mn:000062E2 loc_62E2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint):loc_6346j
.text$mn:000062E2                 mov     eax, [ebp+var_C]
.text$mn:000062E5                 sub     eax, [ebp+var_10]
.text$mn:000062E8                 sar     eax, 1
.text$mn:000062EA                 add     eax, 1
.text$mn:000062ED                 mov     ecx, [ebp+var_4]
.text$mn:000062F0                 sub     ecx, eax
.text$mn:000062F2                 mov     [ebp+var_4], ecx
.text$mn:000062F5                 mov     edx, [ebp+var_C]
.text$mn:000062F8                 add     edx, 2
.text$mn:000062FB                 mov     [ebp+var_10], edx
.text$mn:000062FE
.text$mn:000062FE loc_62FE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+84j
.text$mn:000062FE                 mov     eax, [ebp+arg_0]
.text$mn:00006301                 push    eax
.text$mn:00006302                 mov     ecx, [ebp+var_4]
.text$mn:00006305                 push    ecx
.text$mn:00006306                 mov     edx, [ebp+var_10]
.text$mn:00006309                 push    edx
.text$mn:0000630A                 call    ?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z ; std::char_traits<wchar_t>::find(wchar_t const *,uint,wchar_t const &)
.text$mn:0000630F                 add     esp, 0Ch
.text$mn:00006312                 mov     [ebp+var_C], eax
.text$mn:00006315                 cmp     [ebp+var_C], 0
.text$mn:00006319                 jz      short loc_6348
.text$mn:0000631B                 mov     eax, [ebp+arg_8]
.text$mn:0000631E                 push    eax
.text$mn:0000631F                 mov     ecx, [ebp+arg_0]
.text$mn:00006322                 push    ecx
.text$mn:00006323                 mov     edx, [ebp+var_C]
.text$mn:00006326                 push    edx
.text$mn:00006327                 call    ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z ; std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)
.text$mn:0000632C                 add     esp, 0Ch
.text$mn:0000632F                 test    eax, eax
.text$mn:00006331                 jnz     short loc_6346
.text$mn:00006333                 mov     ecx, [ebp+var_8]
.text$mn:00006336                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000633B                 mov     ecx, [ebp+var_C]
.text$mn:0000633E                 sub     ecx, eax
.text$mn:00006340                 sar     ecx, 1
.text$mn:00006342                 mov     eax, ecx
.text$mn:00006344                 jmp     short loc_634D
.text$mn:00006346 ; ---------------------------------------------------------------------------
.text$mn:00006346
.text$mn:00006346 loc_6346:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+D5j
.text$mn:00006346                 jmp     short loc_62E2
.text$mn:00006348 ; ---------------------------------------------------------------------------
.text$mn:00006348
.text$mn:00006348 loc_6348:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+47j
.text$mn:00006348                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+5Fj ...
.text$mn:00006348                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000634D
.text$mn:0000634D loc_634D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+39j
.text$mn:0000634D                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+E8j
.text$mn:0000634D                 mov     esp, ebp
.text$mn:0000634F                 pop     ebp
.text$mn:00006350                 retn    0Ch
.text$mn:00006350 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z endp
.text$mn:00006350
.text$mn:00006350 ; ---------------------------------------------------------------------------
.text$mn:00006353                 align 4
.text$mn:00006353 _text$mn        ends
.text$mn:00006353
.text$mn:00006354 ; ===========================================================================
.text$mn:00006354
.text$mn:00006354 ; Segment type: Pure code
.text$mn:00006354 ; Segment permissions: Read/Execute
.text$mn:00006354 _text$mn        segment para public 'CODE' use32
.text$mn:00006354                 assume cs:_text$mn
.text$mn:00006354                 ;org 6354h
.text$mn:00006354 ; COMDAT (pick any)
.text$mn:00006354                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006354
.text$mn:00006354 ; =============== S U B R O U T I N E =======================================
.text$mn:00006354
.text$mn:00006354 ; Attributes: bp-based frame
.text$mn:00006354
.text$mn:00006354 ; public: static wchar_t const * __cdecl std::char_traits<wchar_t>::find(wchar_t const *, unsigned int, wchar_t const &)
.text$mn:00006354                 public ?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z
.text$mn:00006354 ?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z proc near
.text$mn:00006354                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+AEp
.text$mn:00006354
.text$mn:00006354 var_4           = dword ptr -4
.text$mn:00006354 arg_0           = dword ptr  8
.text$mn:00006354 arg_4           = dword ptr  0Ch
.text$mn:00006354 arg_8           = dword ptr  10h
.text$mn:00006354
.text$mn:00006354                 push    ebp
.text$mn:00006355                 mov     ebp, esp
.text$mn:00006357                 push    ecx
.text$mn:00006358                 cmp     [ebp+arg_4], 0
.text$mn:0000635C                 jnz     short loc_6367
.text$mn:0000635E                 mov     [ebp+var_4], 0
.text$mn:00006365                 jmp     short loc_6381
.text$mn:00006367 ; ---------------------------------------------------------------------------
.text$mn:00006367
.text$mn:00006367 loc_6367:                               ; CODE XREF: std::char_traits<wchar_t>::find(wchar_t const *,uint,wchar_t const &)+8j
.text$mn:00006367                 mov     eax, [ebp+arg_4]
.text$mn:0000636A                 push    eax
.text$mn:0000636B                 mov     ecx, [ebp+arg_8]
.text$mn:0000636E                 movzx   edx, word ptr [ecx]
.text$mn:00006371                 push    edx
.text$mn:00006372                 mov     eax, [ebp+arg_0]
.text$mn:00006375                 push    eax
.text$mn:00006376                 call    _wmemchr
.text$mn:0000637B                 add     esp, 0Ch
.text$mn:0000637E                 mov     [ebp+var_4], eax
.text$mn:00006381
.text$mn:00006381 loc_6381:                               ; CODE XREF: std::char_traits<wchar_t>::find(wchar_t const *,uint,wchar_t const &)+11j
.text$mn:00006381                 mov     eax, [ebp+var_4]
.text$mn:00006384                 mov     esp, ebp
.text$mn:00006386                 pop     ebp
.text$mn:00006387                 retn
.text$mn:00006387 ?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z endp
.text$mn:00006387
.text$mn:00006387 _text$mn        ends
.text$mn:00006387
.text$mn:00006388 ; ===========================================================================
.text$mn:00006388
.text$mn:00006388 ; Segment type: Pure code
.text$mn:00006388 ; Segment permissions: Read/Execute
.text$mn:00006388 _text$mn        segment para public 'CODE' use32
.text$mn:00006388                 assume cs:_text$mn
.text$mn:00006388                 ;org 6388h
.text$mn:00006388 ; COMDAT (pick any)
.text$mn:00006388                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006388
.text$mn:00006388 ; =============== S U B R O U T I N E =======================================
.text$mn:00006388
.text$mn:00006388 ; Attributes: bp-based frame
.text$mn:00006388
.text$mn:00006388 ; void __thiscall TreeView::fold(TreeView *this, struct _TREEITEM *)
.text$mn:00006388                 public ?fold@TreeView@@QBEXPAU_TREEITEM@@@Z
.text$mn:00006388 ?fold@TreeView@@QBEXPAU_TREEITEM@@@Z proc near
.text$mn:00006388                                         ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+E1p
.text$mn:00006388
.text$mn:00006388 var_4           = dword ptr -4
.text$mn:00006388 lParam          = dword ptr  8
.text$mn:00006388
.text$mn:00006388                 push    ebp
.text$mn:00006389                 mov     ebp, esp
.text$mn:0000638B                 push    ecx
.text$mn:0000638C                 mov     [ebp+var_4], ecx
.text$mn:0000638F                 mov     eax, [ebp+lParam]
.text$mn:00006392                 push    eax             ; lParam
.text$mn:00006393                 push    1               ; wParam
.text$mn:00006395                 push    1102h           ; Msg
.text$mn:0000639A                 mov     ecx, [ebp+var_4]
.text$mn:0000639D                 mov     edx, [ecx+0Ch]
.text$mn:000063A0                 push    edx             ; hWnd
.text$mn:000063A1                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000063A7                 mov     esp, ebp
.text$mn:000063A9                 pop     ebp
.text$mn:000063AA                 retn    4
.text$mn:000063AA ?fold@TreeView@@QBEXPAU_TREEITEM@@@Z endp
.text$mn:000063AA
.text$mn:000063AA ; ---------------------------------------------------------------------------
.text$mn:000063AD                 align 10h
.text$mn:000063AD _text$mn        ends
.text$mn:000063AD
.text$mn:000063B0 ; ===========================================================================
.text$mn:000063B0
.text$mn:000063B0 ; Segment type: Pure code
.text$mn:000063B0 ; Segment permissions: Read/Execute
.text$mn:000063B0 _text$mn        segment para public 'CODE' use32
.text$mn:000063B0                 assume cs:_text$mn
.text$mn:000063B0                 ;org 63B0h
.text$mn:000063B0 ; COMDAT (pick any)
.text$mn:000063B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000063B0
.text$mn:000063B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000063B0
.text$mn:000063B0 ; Attributes: bp-based frame
.text$mn:000063B0
.text$mn:000063B0 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:000063B0                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:000063B0 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000063B0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:000063B0                 push    ebp
.text$mn:000063B1                 mov     ebp, esp
.text$mn:000063B3                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:000063B8                 pop     ebp
.text$mn:000063B9                 retn
.text$mn:000063B9 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000063B9
.text$mn:000063B9 ; ---------------------------------------------------------------------------
.text$mn:000063BA                 align 4
.text$mn:000063BA _text$mn        ends
.text$mn:000063BA
.text$mn:000063BC ; ===========================================================================
.text$mn:000063BC
.text$mn:000063BC ; Segment type: Pure code
.text$mn:000063BC ; Segment permissions: Read/Execute
.text$mn:000063BC _text$mn        segment para public 'CODE' use32
.text$mn:000063BC                 assume cs:_text$mn
.text$mn:000063BC                 ;org 63BCh
.text$mn:000063BC ; COMDAT (pick any)
.text$mn:000063BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000063BC
.text$mn:000063BC ; =============== S U B R O U T I N E =======================================
.text$mn:000063BC
.text$mn:000063BC ; Attributes: bp-based frame
.text$mn:000063BC
.text$mn:000063BC ; struct _TREEITEM *__thiscall TreeView::getChildFrom(TreeView *this, struct _TREEITEM *)
.text$mn:000063BC                 public ?getChildFrom@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z
.text$mn:000063BC ?getChildFrom@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z proc near
.text$mn:000063BC                                         ; CODE XREF: TreeView::searchSubItemByName(wchar_t const *,_TREEITEM *)+33p
.text$mn:000063BC                                         ; TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+11Bp ...
.text$mn:000063BC
.text$mn:000063BC var_4           = dword ptr -4
.text$mn:000063BC lParam          = dword ptr  8
.text$mn:000063BC
.text$mn:000063BC                 push    ebp
.text$mn:000063BD                 mov     ebp, esp
.text$mn:000063BF                 push    ecx
.text$mn:000063C0                 mov     [ebp+var_4], ecx
.text$mn:000063C3                 mov     eax, [ebp+lParam]
.text$mn:000063C6                 push    eax             ; lParam
.text$mn:000063C7                 push    4               ; wParam
.text$mn:000063C9                 push    110Ah           ; Msg
.text$mn:000063CE                 mov     ecx, [ebp+var_4]
.text$mn:000063D1                 mov     edx, [ecx+0Ch]
.text$mn:000063D4                 push    edx             ; hWnd
.text$mn:000063D5                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000063DB                 mov     esp, ebp
.text$mn:000063DD                 pop     ebp
.text$mn:000063DE                 retn    4
.text$mn:000063DE ?getChildFrom@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z endp
.text$mn:000063DE
.text$mn:000063DE ; ---------------------------------------------------------------------------
.text$mn:000063E1                 align 4
.text$mn:000063E1 _text$mn        ends
.text$mn:000063E1
.text$mn:000063E4 ; ===========================================================================
.text$mn:000063E4
.text$mn:000063E4 ; Segment type: Pure code
.text$mn:000063E4 ; Segment permissions: Read/Execute
.text$mn:000063E4 _text$mn        segment para public 'CODE' use32
.text$mn:000063E4                 assume cs:_text$mn
.text$mn:000063E4                 ;org 63E4h
.text$mn:000063E4 ; COMDAT (pick any)
.text$mn:000063E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000063E4
.text$mn:000063E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000063E4
.text$mn:000063E4 ; Attributes: bp-based frame
.text$mn:000063E4
.text$mn:000063E4 ; struct _TREEITEM *__thiscall TreeView::getNextSibling(TreeView *this, struct _TREEITEM *)
.text$mn:000063E4                 public ?getNextSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z
.text$mn:000063E4 ?getNextSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z proc near
.text$mn:000063E4                                         ; CODE XREF: TreeView::searchSubItemByName(wchar_t const *,_TREEITEM *)+60p
.text$mn:000063E4                                         ; TreeView::removeAllItems(void)+1Dp ...
.text$mn:000063E4
.text$mn:000063E4 var_4           = dword ptr -4
.text$mn:000063E4 lParam          = dword ptr  8
.text$mn:000063E4
.text$mn:000063E4                 push    ebp
.text$mn:000063E5                 mov     ebp, esp
.text$mn:000063E7                 push    ecx
.text$mn:000063E8                 mov     [ebp+var_4], ecx
.text$mn:000063EB                 mov     eax, [ebp+lParam]
.text$mn:000063EE                 push    eax             ; lParam
.text$mn:000063EF                 push    1               ; wParam
.text$mn:000063F1                 push    110Ah           ; Msg
.text$mn:000063F6                 mov     ecx, [ebp+var_4]
.text$mn:000063F9                 mov     edx, [ecx+0Ch]
.text$mn:000063FC                 push    edx             ; hWnd
.text$mn:000063FD                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00006403                 mov     esp, ebp
.text$mn:00006405                 pop     ebp
.text$mn:00006406                 retn    4
.text$mn:00006406 ?getNextSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z endp
.text$mn:00006406
.text$mn:00006406 ; ---------------------------------------------------------------------------
.text$mn:00006409                 align 4
.text$mn:00006409 _text$mn        ends
.text$mn:00006409
.text$mn:0000640C ; ===========================================================================
.text$mn:0000640C
.text$mn:0000640C ; Segment type: Pure code
.text$mn:0000640C ; Segment permissions: Read/Execute
.text$mn:0000640C _text$mn        segment para public 'CODE' use32
.text$mn:0000640C                 assume cs:_text$mn
.text$mn:0000640C                 ;org 640Ch
.text$mn:0000640C ; COMDAT (pick any)
.text$mn:0000640C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000640C
.text$mn:0000640C ; =============== S U B R O U T I N E =======================================
.text$mn:0000640C
.text$mn:0000640C ; Attributes: bp-based frame
.text$mn:0000640C
.text$mn:0000640C ; struct _TREEITEM *__thiscall TreeView::getParent(TreeView *this, struct _TREEITEM *)
.text$mn:0000640C                 public ?getParent@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z
.text$mn:0000640C ?getParent@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z proc near
.text$mn:0000640C                                         ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+E0p
.text$mn:0000640C                                         ; TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+F5p ...
.text$mn:0000640C
.text$mn:0000640C var_4           = dword ptr -4
.text$mn:0000640C lParam          = dword ptr  8
.text$mn:0000640C
.text$mn:0000640C                 push    ebp
.text$mn:0000640D                 mov     ebp, esp
.text$mn:0000640F                 push    ecx
.text$mn:00006410                 mov     [ebp+var_4], ecx
.text$mn:00006413                 mov     eax, [ebp+lParam]
.text$mn:00006416                 push    eax             ; lParam
.text$mn:00006417                 push    3               ; wParam
.text$mn:00006419                 push    110Ah           ; Msg
.text$mn:0000641E                 mov     ecx, [ebp+var_4]
.text$mn:00006421                 mov     edx, [ecx+0Ch]
.text$mn:00006424                 push    edx             ; hWnd
.text$mn:00006425                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000642B                 mov     esp, ebp
.text$mn:0000642D                 pop     ebp
.text$mn:0000642E                 retn    4
.text$mn:0000642E ?getParent@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z endp
.text$mn:0000642E
.text$mn:0000642E ; ---------------------------------------------------------------------------
.text$mn:00006431                 align 4
.text$mn:00006431 _text$mn        ends
.text$mn:00006431
.text$mn:00006434 ; ===========================================================================
.text$mn:00006434
.text$mn:00006434 ; Segment type: Pure code
.text$mn:00006434 ; Segment permissions: Read/Execute
.text$mn:00006434 _text$mn        segment para public 'CODE' use32
.text$mn:00006434                 assume cs:_text$mn
.text$mn:00006434                 ;org 6434h
.text$mn:00006434 ; COMDAT (pick any)
.text$mn:00006434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006434
.text$mn:00006434 ; =============== S U B R O U T I N E =======================================
.text$mn:00006434
.text$mn:00006434 ; Attributes: bp-based frame
.text$mn:00006434
.text$mn:00006434 ; struct _TREEITEM *__thiscall TreeView::getPrevSibling(TreeView *this, struct _TREEITEM *)
.text$mn:00006434                 public ?getPrevSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z
.text$mn:00006434 ?getPrevSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z proc near
.text$mn:00006434                                         ; CODE XREF: TreeView::moveUp(_TREEITEM *)+10p
.text$mn:00006434                                         ; TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+9Ep
.text$mn:00006434
.text$mn:00006434 var_4           = dword ptr -4
.text$mn:00006434 lParam          = dword ptr  8
.text$mn:00006434
.text$mn:00006434                 push    ebp
.text$mn:00006435                 mov     ebp, esp
.text$mn:00006437                 push    ecx
.text$mn:00006438                 mov     [ebp+var_4], ecx
.text$mn:0000643B                 mov     eax, [ebp+lParam]
.text$mn:0000643E                 push    eax             ; lParam
.text$mn:0000643F                 push    2               ; wParam
.text$mn:00006441                 push    110Ah           ; Msg
.text$mn:00006446                 mov     ecx, [ebp+var_4]
.text$mn:00006449                 mov     edx, [ecx+0Ch]
.text$mn:0000644C                 push    edx             ; hWnd
.text$mn:0000644D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00006453                 mov     esp, ebp
.text$mn:00006455                 pop     ebp
.text$mn:00006456                 retn    4
.text$mn:00006456 ?getPrevSibling@TreeView@@QBEPAU_TREEITEM@@PAU2@@Z endp
.text$mn:00006456
.text$mn:00006456 ; ---------------------------------------------------------------------------
.text$mn:00006459                 align 4
.text$mn:00006459 _text$mn        ends
.text$mn:00006459
.text$mn:0000645C ; ===========================================================================
.text$mn:0000645C
.text$mn:0000645C ; Segment type: Pure code
.text$mn:0000645C ; Segment permissions: Read/Execute
.text$mn:0000645C _text$mn        segment para public 'CODE' use32
.text$mn:0000645C                 assume cs:_text$mn
.text$mn:0000645C                 ;org 645Ch
.text$mn:0000645C ; COMDAT (pick any)
.text$mn:0000645C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000645C
.text$mn:0000645C ; =============== S U B R O U T I N E =======================================
.text$mn:0000645C
.text$mn:0000645C ; Attributes: bp-based frame
.text$mn:0000645C
.text$mn:0000645C ; struct _TREEITEM *__thiscall TreeView::getRoot(TreeView *__hidden this)
.text$mn:0000645C                 public ?getRoot@TreeView@@QBEPAU_TREEITEM@@XZ
.text$mn:0000645C ?getRoot@TreeView@@QBEPAU_TREEITEM@@XZ proc near
.text$mn:0000645C                                         ; CODE XREF: TreeView::searchSubItemByName(wchar_t const *,_TREEITEM *)+46p
.text$mn:0000645C                                         ; TreeView::removeAllItems(void)+Cp ...
.text$mn:0000645C
.text$mn:0000645C var_4           = dword ptr -4
.text$mn:0000645C
.text$mn:0000645C                 push    ebp
.text$mn:0000645D                 mov     ebp, esp
.text$mn:0000645F                 push    ecx
.text$mn:00006460                 mov     [ebp+var_4], ecx
.text$mn:00006463                 push    0               ; lParam
.text$mn:00006465                 push    0               ; wParam
.text$mn:00006467                 push    110Ah           ; Msg
.text$mn:0000646C                 mov     eax, [ebp+var_4]
.text$mn:0000646F                 mov     ecx, [eax+0Ch]
.text$mn:00006472                 push    ecx             ; hWnd
.text$mn:00006473                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00006479                 mov     esp, ebp
.text$mn:0000647B                 pop     ebp
.text$mn:0000647C                 retn
.text$mn:0000647C ?getRoot@TreeView@@QBEPAU_TREEITEM@@XZ endp
.text$mn:0000647C
.text$mn:0000647C ; ---------------------------------------------------------------------------
.text$mn:0000647D                 align 10h
.text$mn:0000647D _text$mn        ends
.text$mn:0000647D
.text$mn:00006480 ; ===========================================================================
.text$mn:00006480
.text$mn:00006480 ; Segment type: Pure code
.text$mn:00006480 ; Segment permissions: Read/Execute
.text$mn:00006480 _text$mn        segment para public 'CODE' use32
.text$mn:00006480                 assume cs:_text$mn
.text$mn:00006480                 ;org 6480h
.text$mn:00006480 ; COMDAT (pick any)
.text$mn:00006480                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006480
.text$mn:00006480 ; =============== S U B R O U T I N E =======================================
.text$mn:00006480
.text$mn:00006480 ; Attributes: bp-based frame
.text$mn:00006480
.text$mn:00006480 ; struct _TREEITEM *__thiscall TreeView::getSelection(TreeView *__hidden this)
.text$mn:00006480                 public ?getSelection@TreeView@@QBEPAU_TREEITEM@@XZ
.text$mn:00006480 ?getSelection@TreeView@@QBEPAU_TREEITEM@@XZ proc near
.text$mn:00006480                                         ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+39p
.text$mn:00006480
.text$mn:00006480 var_4           = dword ptr -4
.text$mn:00006480
.text$mn:00006480                 push    ebp
.text$mn:00006481                 mov     ebp, esp
.text$mn:00006483                 push    ecx
.text$mn:00006484                 mov     [ebp+var_4], ecx
.text$mn:00006487                 push    0               ; lParam
.text$mn:00006489                 push    9               ; wParam
.text$mn:0000648B                 push    110Ah           ; Msg
.text$mn:00006490                 mov     eax, [ebp+var_4]
.text$mn:00006493                 mov     ecx, [eax+0Ch]
.text$mn:00006496                 push    ecx             ; hWnd
.text$mn:00006497                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000649D                 mov     esp, ebp
.text$mn:0000649F                 pop     ebp
.text$mn:000064A0                 retn
.text$mn:000064A0 ?getSelection@TreeView@@QBEPAU_TREEITEM@@XZ endp
.text$mn:000064A0
.text$mn:000064A0 ; ---------------------------------------------------------------------------
.text$mn:000064A1                 align 4
.text$mn:000064A1 _text$mn        ends
.text$mn:000064A1
.text$mn:000064A4 ; ===========================================================================
.text$mn:000064A4
.text$mn:000064A4 ; Segment type: Pure code
.text$mn:000064A4 ; Segment permissions: Read/Execute
.text$mn:000064A4 _text$mn        segment para public 'CODE' use32
.text$mn:000064A4                 assume cs:_text$mn
.text$mn:000064A4                 ;org 64A4h
.text$mn:000064A4 ; COMDAT (pick any)
.text$mn:000064A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000064A4
.text$mn:000064A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000064A4
.text$mn:000064A4 ; Attributes: bp-based frame
.text$mn:000064A4
.text$mn:000064A4 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:000064A4                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:000064A4 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:000064A4                                         ; CODE XREF: TreeView::init(HINSTANCE__ *,HWND__ *,int)+12p
.text$mn:000064A4
.text$mn:000064A4 var_4           = dword ptr -4
.text$mn:000064A4 arg_0           = dword ptr  8
.text$mn:000064A4 arg_4           = dword ptr  0Ch
.text$mn:000064A4
.text$mn:000064A4                 push    ebp
.text$mn:000064A5                 mov     ebp, esp
.text$mn:000064A7                 push    ecx
.text$mn:000064A8                 mov     [ebp+var_4], ecx
.text$mn:000064AB                 mov     eax, [ebp+var_4]
.text$mn:000064AE                 mov     ecx, [ebp+arg_0]
.text$mn:000064B1                 mov     [eax+4], ecx
.text$mn:000064B4                 mov     edx, [ebp+var_4]
.text$mn:000064B7                 mov     eax, [ebp+arg_4]
.text$mn:000064BA                 mov     [edx+8], eax
.text$mn:000064BD                 mov     esp, ebp
.text$mn:000064BF                 pop     ebp
.text$mn:000064C0                 retn    8
.text$mn:000064C0 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:000064C0
.text$mn:000064C0 ; ---------------------------------------------------------------------------
.text$mn:000064C3                 align 4
.text$mn:000064C3 _text$mn        ends
.text$mn:000064C3
.text$mn:000064C4 ; ===========================================================================
.text$mn:000064C4
.text$mn:000064C4 ; Segment type: Pure code
.text$mn:000064C4 ; Segment permissions: Read/Execute
.text$mn:000064C4 _text$mn        segment para public 'CODE' use32
.text$mn:000064C4                 assume cs:_text$mn
.text$mn:000064C4                 ;org 64C4h
.text$mn:000064C4 ; COMDAT (pick any)
.text$mn:000064C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000064C4
.text$mn:000064C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000064C4
.text$mn:000064C4 ; Attributes: bp-based frame
.text$mn:000064C4
.text$mn:000064C4 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:000064C4                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:000064C4 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:000064C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:000064C4
.text$mn:000064C4 var_4           = dword ptr -4
.text$mn:000064C4 Str             = dword ptr  8
.text$mn:000064C4
.text$mn:000064C4                 push    ebp
.text$mn:000064C5                 mov     ebp, esp
.text$mn:000064C7                 push    ecx
.text$mn:000064C8                 mov     eax, [ebp+Str]
.text$mn:000064CB                 movsx   ecx, byte ptr [eax]
.text$mn:000064CE                 test    ecx, ecx
.text$mn:000064D0                 jnz     short loc_64DB
.text$mn:000064D2                 mov     [ebp+var_4], 0
.text$mn:000064D9                 jmp     short loc_64EA
.text$mn:000064DB ; ---------------------------------------------------------------------------
.text$mn:000064DB
.text$mn:000064DB loc_64DB:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:000064DB                 mov     edx, [ebp+Str]
.text$mn:000064DE                 push    edx             ; Str
.text$mn:000064DF                 call    _strlen
.text$mn:000064E4                 add     esp, 4
.text$mn:000064E7                 mov     [ebp+var_4], eax
.text$mn:000064EA
.text$mn:000064EA loc_64EA:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:000064EA                 mov     eax, [ebp+var_4]
.text$mn:000064ED                 mov     esp, ebp
.text$mn:000064EF                 pop     ebp
.text$mn:000064F0                 retn
.text$mn:000064F0 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:000064F0
.text$mn:000064F0 ; ---------------------------------------------------------------------------
.text$mn:000064F1                 align 4
.text$mn:000064F1 _text$mn        ends
.text$mn:000064F1
.text$mn:000064F4 ; ===========================================================================
.text$mn:000064F4
.text$mn:000064F4 ; Segment type: Pure code
.text$mn:000064F4 ; Segment permissions: Read/Execute
.text$mn:000064F4 _text$mn        segment para public 'CODE' use32
.text$mn:000064F4                 assume cs:_text$mn
.text$mn:000064F4                 ;org 64F4h
.text$mn:000064F4 ; COMDAT (pick any)
.text$mn:000064F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000064F4
.text$mn:000064F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000064F4
.text$mn:000064F4 ; Attributes: bp-based frame
.text$mn:000064F4
.text$mn:000064F4 ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:000064F4                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:000064F4 ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:000064F4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p
.text$mn:000064F4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)+21p
.text$mn:000064F4
.text$mn:000064F4 var_4           = dword ptr -4
.text$mn:000064F4 Str             = dword ptr  8
.text$mn:000064F4
.text$mn:000064F4                 push    ebp
.text$mn:000064F5                 mov     ebp, esp
.text$mn:000064F7                 push    ecx
.text$mn:000064F8                 mov     eax, [ebp+Str]
.text$mn:000064FB                 movzx   ecx, word ptr [eax]
.text$mn:000064FE                 test    ecx, ecx
.text$mn:00006500                 jnz     short loc_650B
.text$mn:00006502                 mov     [ebp+var_4], 0
.text$mn:00006509                 jmp     short loc_651A
.text$mn:0000650B ; ---------------------------------------------------------------------------
.text$mn:0000650B
.text$mn:0000650B loc_650B:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:0000650B                 mov     edx, [ebp+Str]
.text$mn:0000650E                 push    edx             ; Str
.text$mn:0000650F                 call    _wcslen
.text$mn:00006514                 add     esp, 4
.text$mn:00006517                 mov     [ebp+var_4], eax
.text$mn:0000651A
.text$mn:0000651A loc_651A:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:0000651A                 mov     eax, [ebp+var_4]
.text$mn:0000651D                 mov     esp, ebp
.text$mn:0000651F                 pop     ebp
.text$mn:00006520                 retn
.text$mn:00006520 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:00006520
.text$mn:00006520 ; ---------------------------------------------------------------------------
.text$mn:00006521                 align 4
.text$mn:00006521 _text$mn        ends
.text$mn:00006521
.text$mn:00006524 ; ===========================================================================
.text$mn:00006524
.text$mn:00006524 ; Segment type: Pure code
.text$mn:00006524 ; Segment permissions: Read/Execute
.text$mn:00006524 _text$mn        segment para public 'CODE' use32
.text$mn:00006524                 assume cs:_text$mn
.text$mn:00006524                 ;org 6524h
.text$mn:00006524 ; COMDAT (pick any)
.text$mn:00006524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006524
.text$mn:00006524 ; =============== S U B R O U T I N E =======================================
.text$mn:00006524
.text$mn:00006524 ; Attributes: bp-based frame
.text$mn:00006524
.text$mn:00006524 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00006524                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00006524 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00006524                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00006524
.text$mn:00006524 var_4           = dword ptr -4
.text$mn:00006524
.text$mn:00006524                 push    ebp
.text$mn:00006525                 mov     ebp, esp
.text$mn:00006527                 push    ecx
.text$mn:00006528                 mov     [ebp+var_4], ecx
.text$mn:0000652B                 mov     eax, [ebp+var_4]
.text$mn:0000652E                 push    eax
.text$mn:0000652F                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00006534                 add     esp, 4
.text$mn:00006537                 mov     esp, ebp
.text$mn:00006539                 pop     ebp
.text$mn:0000653A                 retn
.text$mn:0000653A ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000653A
.text$mn:0000653A ; ---------------------------------------------------------------------------
.text$mn:0000653B                 align 4
.text$mn:0000653B _text$mn        ends
.text$mn:0000653B
.text$mn:0000653C ; ===========================================================================
.text$mn:0000653C
.text$mn:0000653C ; Segment type: Pure code
.text$mn:0000653C ; Segment permissions: Read/Execute
.text$mn:0000653C _text$mn        segment para public 'CODE' use32
.text$mn:0000653C                 assume cs:_text$mn
.text$mn:0000653C                 ;org 653Ch
.text$mn:0000653C ; COMDAT (pick any)
.text$mn:0000653C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000653C
.text$mn:0000653C ; =============== S U B R O U T I N E =======================================
.text$mn:0000653C
.text$mn:0000653C ; Attributes: bp-based frame
.text$mn:0000653C
.text$mn:0000653C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct TreeStateNode>>::max_size(void)const
.text$mn:0000653C                 public ?max_size@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ
.text$mn:0000653C ?max_size@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ proc near
.text$mn:0000653C                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::max_size(void)+17p
.text$mn:0000653C
.text$mn:0000653C var_4           = dword ptr -4
.text$mn:0000653C
.text$mn:0000653C                 push    ebp
.text$mn:0000653D                 mov     ebp, esp
.text$mn:0000653F                 push    ecx
.text$mn:00006540                 mov     [ebp+var_4], ecx
.text$mn:00006543                 mov     eax, [ebp+var_4]
.text$mn:00006546                 push    eax
.text$mn:00006547                 call    ?max_size@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAIABV?$allocator@UTreeStateNode@@@2@@Z ; std::allocator_traits<std::allocator<TreeStateNode>>::max_size(std::allocator<TreeStateNode> const &)
.text$mn:0000654C                 add     esp, 4
.text$mn:0000654F                 mov     esp, ebp
.text$mn:00006551                 pop     ebp
.text$mn:00006552                 retn
.text$mn:00006552 ?max_size@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ endp
.text$mn:00006552
.text$mn:00006552 ; ---------------------------------------------------------------------------
.text$mn:00006553                 align 4
.text$mn:00006553 _text$mn        ends
.text$mn:00006553
.text$mn:00006554 ; ===========================================================================
.text$mn:00006554
.text$mn:00006554 ; Segment type: Pure code
.text$mn:00006554 ; Segment permissions: Read/Execute
.text$mn:00006554 _text$mn        segment para public 'CODE' use32
.text$mn:00006554                 assume cs:_text$mn
.text$mn:00006554                 ;org 6554h
.text$mn:00006554 ; COMDAT (pick any)
.text$mn:00006554                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006554
.text$mn:00006554 ; =============== S U B R O U T I N E =======================================
.text$mn:00006554
.text$mn:00006554 ; Attributes: bp-based frame
.text$mn:00006554
.text$mn:00006554 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:00006554                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:00006554 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:00006554                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:00006554
.text$mn:00006554 var_4           = dword ptr -4
.text$mn:00006554
.text$mn:00006554                 push    ebp
.text$mn:00006555                 mov     ebp, esp
.text$mn:00006557                 push    ecx
.text$mn:00006558                 mov     [ebp+var_4], ecx
.text$mn:0000655B                 mov     eax, [ebp+var_4]
.text$mn:0000655E                 push    eax
.text$mn:0000655F                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:00006564                 add     esp, 4
.text$mn:00006567                 mov     esp, ebp
.text$mn:00006569                 pop     ebp
.text$mn:0000656A                 retn
.text$mn:0000656A ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000656A
.text$mn:0000656A ; ---------------------------------------------------------------------------
.text$mn:0000656B                 align 4
.text$mn:0000656B _text$mn        ends
.text$mn:0000656B
.text$mn:0000656C ; ===========================================================================
.text$mn:0000656C
.text$mn:0000656C ; Segment type: Pure code
.text$mn:0000656C ; Segment permissions: Read/Execute
.text$mn:0000656C _text$mn        segment para public 'CODE' use32
.text$mn:0000656C                 assume cs:_text$mn
.text$mn:0000656C                 ;org 656Ch
.text$mn:0000656C ; COMDAT (pick any)
.text$mn:0000656C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000656C
.text$mn:0000656C ; =============== S U B R O U T I N E =======================================
.text$mn:0000656C
.text$mn:0000656C ; Attributes: bp-based frame
.text$mn:0000656C
.text$mn:0000656C ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:0000656C                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:0000656C ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:0000656C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:0000656C
.text$mn:0000656C var_4           = dword ptr -4
.text$mn:0000656C
.text$mn:0000656C                 push    ebp
.text$mn:0000656D                 mov     ebp, esp
.text$mn:0000656F                 push    ecx
.text$mn:00006570                 mov     [ebp+var_4], ecx
.text$mn:00006573                 or      eax, 0FFFFFFFFh
.text$mn:00006576                 mov     esp, ebp
.text$mn:00006578                 pop     ebp
.text$mn:00006579                 retn
.text$mn:00006579 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00006579
.text$mn:00006579 ; ---------------------------------------------------------------------------
.text$mn:0000657A                 align 4
.text$mn:0000657A _text$mn        ends
.text$mn:0000657A
.text$mn:0000657C ; ===========================================================================
.text$mn:0000657C
.text$mn:0000657C ; Segment type: Pure code
.text$mn:0000657C ; Segment permissions: Read/Execute
.text$mn:0000657C _text$mn        segment para public 'CODE' use32
.text$mn:0000657C                 assume cs:_text$mn
.text$mn:0000657C                 ;org 657Ch
.text$mn:0000657C ; COMDAT (pick any)
.text$mn:0000657C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000657C
.text$mn:0000657C ; =============== S U B R O U T I N E =======================================
.text$mn:0000657C
.text$mn:0000657C ; Attributes: bp-based frame
.text$mn:0000657C
.text$mn:0000657C ; public: unsigned int __thiscall std::allocator<struct TreeStateNode>::max_size(void)const
.text$mn:0000657C                 public ?max_size@?$allocator@UTreeStateNode@@@std@@QBEIXZ
.text$mn:0000657C ?max_size@?$allocator@UTreeStateNode@@@std@@QBEIXZ proc near
.text$mn:0000657C                                         ; CODE XREF: std::allocator_traits<std::allocator<TreeStateNode>>::max_size(std::allocator<TreeStateNode> const &)+6p
.text$mn:0000657C
.text$mn:0000657C var_4           = dword ptr -4
.text$mn:0000657C
.text$mn:0000657C                 push    ebp
.text$mn:0000657D                 mov     ebp, esp
.text$mn:0000657F                 push    ecx
.text$mn:00006580                 mov     [ebp+var_4], ecx
.text$mn:00006583                 mov     eax, 35E50D7h
.text$mn:00006588                 mov     esp, ebp
.text$mn:0000658A                 pop     ebp
.text$mn:0000658B                 retn
.text$mn:0000658B ?max_size@?$allocator@UTreeStateNode@@@std@@QBEIXZ endp
.text$mn:0000658B
.text$mn:0000658B _text$mn        ends
.text$mn:0000658B
.text$mn:0000658C ; ===========================================================================
.text$mn:0000658C
.text$mn:0000658C ; Segment type: Pure code
.text$mn:0000658C ; Segment permissions: Read/Execute
.text$mn:0000658C _text$mn        segment para public 'CODE' use32
.text$mn:0000658C                 assume cs:_text$mn
.text$mn:0000658C                 ;org 658Ch
.text$mn:0000658C ; COMDAT (pick any)
.text$mn:0000658C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000658C
.text$mn:0000658C ; =============== S U B R O U T I N E =======================================
.text$mn:0000658C
.text$mn:0000658C ; Attributes: bp-based frame
.text$mn:0000658C
.text$mn:0000658C ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:0000658C                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:0000658C ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:0000658C                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:0000658C
.text$mn:0000658C var_4           = dword ptr -4
.text$mn:0000658C
.text$mn:0000658C                 push    ebp
.text$mn:0000658D                 mov     ebp, esp
.text$mn:0000658F                 push    ecx
.text$mn:00006590                 mov     [ebp+var_4], ecx
.text$mn:00006593                 mov     eax, 7FFFFFFFh
.text$mn:00006598                 mov     esp, ebp
.text$mn:0000659A                 pop     ebp
.text$mn:0000659B                 retn
.text$mn:0000659B ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:0000659B
.text$mn:0000659B _text$mn        ends
.text$mn:0000659B
.text$mn:0000659C ; ===========================================================================
.text$mn:0000659C
.text$mn:0000659C ; Segment type: Pure code
.text$mn:0000659C ; Segment permissions: Read/Execute
.text$mn:0000659C _text$mn        segment para public 'CODE' use32
.text$mn:0000659C                 assume cs:_text$mn
.text$mn:0000659C                 ;org 659Ch
.text$mn:0000659C ; COMDAT (pick any)
.text$mn:0000659C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000659C
.text$mn:0000659C ; =============== S U B R O U T I N E =======================================
.text$mn:0000659C
.text$mn:0000659C ; Attributes: bp-based frame
.text$mn:0000659C
.text$mn:0000659C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:0000659C                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:0000659C ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:0000659C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:0000659C
.text$mn:0000659C arg_0           = dword ptr  8
.text$mn:0000659C
.text$mn:0000659C                 push    ebp
.text$mn:0000659D                 mov     ebp, esp
.text$mn:0000659F                 mov     ecx, [ebp+arg_0]
.text$mn:000065A2                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000065A7                 pop     ebp
.text$mn:000065A8                 retn
.text$mn:000065A8 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000065A8
.text$mn:000065A8 ; ---------------------------------------------------------------------------
.text$mn:000065A9                 align 4
.text$mn:000065A9 _text$mn        ends
.text$mn:000065A9
.text$mn:000065AC ; ===========================================================================
.text$mn:000065AC
.text$mn:000065AC ; Segment type: Pure code
.text$mn:000065AC ; Segment permissions: Read/Execute
.text$mn:000065AC _text$mn        segment para public 'CODE' use32
.text$mn:000065AC                 assume cs:_text$mn
.text$mn:000065AC                 ;org 65ACh
.text$mn:000065AC ; COMDAT (pick any)
.text$mn:000065AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000065AC
.text$mn:000065AC ; =============== S U B R O U T I N E =======================================
.text$mn:000065AC
.text$mn:000065AC ; Attributes: bp-based frame
.text$mn:000065AC
.text$mn:000065AC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct TreeStateNode>>::max_size(class std::allocator<struct TreeStateNode> const &)
.text$mn:000065AC                 public ?max_size@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAIABV?$allocator@UTreeStateNode@@@2@@Z
.text$mn:000065AC ?max_size@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAIABV?$allocator@UTreeStateNode@@@2@@Z proc near
.text$mn:000065AC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TreeStateNode>>::max_size(void)+Bp
.text$mn:000065AC
.text$mn:000065AC arg_0           = dword ptr  8
.text$mn:000065AC
.text$mn:000065AC                 push    ebp
.text$mn:000065AD                 mov     ebp, esp
.text$mn:000065AF                 mov     ecx, [ebp+arg_0]
.text$mn:000065B2                 call    ?max_size@?$allocator@UTreeStateNode@@@std@@QBEIXZ ; std::allocator<TreeStateNode>::max_size(void)
.text$mn:000065B7                 pop     ebp
.text$mn:000065B8                 retn
.text$mn:000065B8 ?max_size@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SAIABV?$allocator@UTreeStateNode@@@2@@Z endp
.text$mn:000065B8
.text$mn:000065B8 ; ---------------------------------------------------------------------------
.text$mn:000065B9                 align 4
.text$mn:000065B9 _text$mn        ends
.text$mn:000065B9
.text$mn:000065BC ; ===========================================================================
.text$mn:000065BC
.text$mn:000065BC ; Segment type: Pure code
.text$mn:000065BC ; Segment permissions: Read/Execute
.text$mn:000065BC _text$mn        segment para public 'CODE' use32
.text$mn:000065BC                 assume cs:_text$mn
.text$mn:000065BC                 ;org 65BCh
.text$mn:000065BC ; COMDAT (pick any)
.text$mn:000065BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000065BC
.text$mn:000065BC ; =============== S U B R O U T I N E =======================================
.text$mn:000065BC
.text$mn:000065BC ; Attributes: bp-based frame
.text$mn:000065BC
.text$mn:000065BC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:000065BC                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:000065BC ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:000065BC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:000065BC
.text$mn:000065BC arg_0           = dword ptr  8
.text$mn:000065BC
.text$mn:000065BC                 push    ebp
.text$mn:000065BD                 mov     ebp, esp
.text$mn:000065BF                 mov     ecx, [ebp+arg_0]
.text$mn:000065C2                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:000065C7                 pop     ebp
.text$mn:000065C8                 retn
.text$mn:000065C8 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:000065C8
.text$mn:000065C8 ; ---------------------------------------------------------------------------
.text$mn:000065C9                 align 4
.text$mn:000065C9 _text$mn        ends
.text$mn:000065C9
.text$mn:000065CC ; ===========================================================================
.text$mn:000065CC
.text$mn:000065CC ; Segment type: Pure code
.text$mn:000065CC ; Segment permissions: Read/Execute
.text$mn:000065CC _text$mn        segment para public 'CODE' use32
.text$mn:000065CC                 assume cs:_text$mn
.text$mn:000065CC                 ;org 65CCh
.text$mn:000065CC ; COMDAT (pick any)
.text$mn:000065CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000065CC
.text$mn:000065CC ; =============== S U B R O U T I N E =======================================
.text$mn:000065CC
.text$mn:000065CC ; Attributes: bp-based frame
.text$mn:000065CC
.text$mn:000065CC ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000065CC                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000065CC ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000065CC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000065CC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000065CC
.text$mn:000065CC var_10          = dword ptr -10h
.text$mn:000065CC var_C           = dword ptr -0Ch
.text$mn:000065CC var_8           = dword ptr -8
.text$mn:000065CC var_1           = byte ptr -1
.text$mn:000065CC
.text$mn:000065CC                 push    ebp
.text$mn:000065CD                 mov     ebp, esp
.text$mn:000065CF                 sub     esp, 10h
.text$mn:000065D2                 mov     [ebp+var_10], ecx
.text$mn:000065D5                 lea     eax, [ebp+var_1]
.text$mn:000065D8                 push    eax
.text$mn:000065D9                 mov     ecx, [ebp+var_10]
.text$mn:000065DC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000065E1                 mov     ecx, eax
.text$mn:000065E3                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:000065E8                 mov     [ebp+var_8], eax
.text$mn:000065EB                 cmp     [ebp+var_8], 1
.text$mn:000065EF                 ja      short loc_65FA
.text$mn:000065F1                 mov     [ebp+var_C], 1
.text$mn:000065F8                 jmp     short loc_6603
.text$mn:000065FA ; ---------------------------------------------------------------------------
.text$mn:000065FA
.text$mn:000065FA loc_65FA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:000065FA                 mov     ecx, [ebp+var_8]
.text$mn:000065FD                 sub     ecx, 1
.text$mn:00006600                 mov     [ebp+var_C], ecx
.text$mn:00006603
.text$mn:00006603 loc_6603:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00006603                 mov     eax, [ebp+var_C]
.text$mn:00006606                 mov     esp, ebp
.text$mn:00006608                 pop     ebp
.text$mn:00006609                 retn
.text$mn:00006609 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00006609
.text$mn:00006609 ; ---------------------------------------------------------------------------
.text$mn:0000660A                 align 4
.text$mn:0000660A _text$mn        ends
.text$mn:0000660A
.text$mn:0000660C ; ===========================================================================
.text$mn:0000660C
.text$mn:0000660C ; Segment type: Pure code
.text$mn:0000660C ; Segment permissions: Read/Execute
.text$mn:0000660C _text$mn        segment para public 'CODE' use32
.text$mn:0000660C                 assume cs:_text$mn
.text$mn:0000660C                 ;org 660Ch
.text$mn:0000660C ; COMDAT (pick any)
.text$mn:0000660C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000660C
.text$mn:0000660C ; =============== S U B R O U T I N E =======================================
.text$mn:0000660C
.text$mn:0000660C ; Attributes: bp-based frame
.text$mn:0000660C
.text$mn:0000660C ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000660C                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000660C ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000660C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:0000660C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000660C
.text$mn:0000660C var_10          = dword ptr -10h
.text$mn:0000660C var_C           = dword ptr -0Ch
.text$mn:0000660C var_8           = dword ptr -8
.text$mn:0000660C var_1           = byte ptr -1
.text$mn:0000660C
.text$mn:0000660C                 push    ebp
.text$mn:0000660D                 mov     ebp, esp
.text$mn:0000660F                 sub     esp, 10h
.text$mn:00006612                 mov     [ebp+var_10], ecx
.text$mn:00006615                 lea     eax, [ebp+var_1]
.text$mn:00006618                 push    eax
.text$mn:00006619                 mov     ecx, [ebp+var_10]
.text$mn:0000661C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00006621                 mov     ecx, eax
.text$mn:00006623                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:00006628                 mov     [ebp+var_8], eax
.text$mn:0000662B                 cmp     [ebp+var_8], 1
.text$mn:0000662F                 ja      short loc_663A
.text$mn:00006631                 mov     [ebp+var_C], 1
.text$mn:00006638                 jmp     short loc_6643
.text$mn:0000663A ; ---------------------------------------------------------------------------
.text$mn:0000663A
.text$mn:0000663A loc_663A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:0000663A                 mov     ecx, [ebp+var_8]
.text$mn:0000663D                 sub     ecx, 1
.text$mn:00006640                 mov     [ebp+var_C], ecx
.text$mn:00006643
.text$mn:00006643 loc_6643:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:00006643                 mov     eax, [ebp+var_C]
.text$mn:00006646                 mov     esp, ebp
.text$mn:00006648                 pop     ebp
.text$mn:00006649                 retn
.text$mn:00006649 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00006649
.text$mn:00006649 ; ---------------------------------------------------------------------------
.text$mn:0000664A                 align 4
.text$mn:0000664A _text$mn        ends
.text$mn:0000664A
.text$mn:0000664C ; ===========================================================================
.text$mn:0000664C
.text$mn:0000664C ; Segment type: Pure code
.text$mn:0000664C ; Segment permissions: Read/Execute
.text$mn:0000664C _text$mn        segment para public 'CODE' use32
.text$mn:0000664C                 assume cs:_text$mn
.text$mn:0000664C                 ;org 664Ch
.text$mn:0000664C ; COMDAT (pick any)
.text$mn:0000664C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000664C
.text$mn:0000664C ; =============== S U B R O U T I N E =======================================
.text$mn:0000664C
.text$mn:0000664C ; Attributes: bp-based frame
.text$mn:0000664C
.text$mn:0000664C ; public: unsigned int __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::max_size(void)const
.text$mn:0000664C                 public ?max_size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ
.text$mn:0000664C ?max_size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ proc near
.text$mn:0000664C                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Buy(uint)+36p
.text$mn:0000664C                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Grow_to(uint)+17p ...
.text$mn:0000664C
.text$mn:0000664C var_8           = dword ptr -8
.text$mn:0000664C var_1           = byte ptr -1
.text$mn:0000664C
.text$mn:0000664C                 push    ebp
.text$mn:0000664D                 mov     ebp, esp
.text$mn:0000664F                 sub     esp, 8
.text$mn:00006652                 mov     [ebp+var_8], ecx
.text$mn:00006655                 lea     eax, [ebp+var_1]
.text$mn:00006658                 push    eax
.text$mn:00006659                 mov     ecx, [ebp+var_8]
.text$mn:0000665C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Getal(void)
.text$mn:00006661                 mov     ecx, eax
.text$mn:00006663                 call    ?max_size@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::max_size(void)
.text$mn:00006668                 mov     esp, ebp
.text$mn:0000666A                 pop     ebp
.text$mn:0000666B                 retn
.text$mn:0000666B ?max_size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ endp
.text$mn:0000666B
.text$mn:0000666B _text$mn        ends
.text$mn:0000666B
.text$mn:0000666C ; ===========================================================================
.text$mn:0000666C
.text$mn:0000666C ; Segment type: Pure code
.text$mn:0000666C ; Segment permissions: Read/Execute
.text$mn:0000666C _text$mn        segment para public 'CODE' use32
.text$mn:0000666C                 assume cs:_text$mn
.text$mn:0000666C                 ;org 666Ch
.text$mn:0000666C ; COMDAT (pick any)
.text$mn:0000666C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000666C
.text$mn:0000666C ; =============== S U B R O U T I N E =======================================
.text$mn:0000666C
.text$mn:0000666C ; Attributes: bp-based frame
.text$mn:0000666C
.text$mn:0000666C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:0000666C                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000666C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000666C                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:0000666C                                         ; DATA XREF: .rdata:00007B60o
.text$mn:0000666C
.text$mn:0000666C var_1C          = dword ptr -1Ch
.text$mn:0000666C var_18          = dword ptr -18h
.text$mn:0000666C Str             = dword ptr -14h
.text$mn:0000666C var_10          = dword ptr -10h
.text$mn:0000666C var_C           = dword ptr -0Ch
.text$mn:0000666C var_4           = dword ptr -4
.text$mn:0000666C arg_0           = dword ptr  8
.text$mn:0000666C arg_4           = dword ptr  0Ch
.text$mn:0000666C
.text$mn:0000666C                 push    ebp
.text$mn:0000666D                 mov     ebp, esp
.text$mn:0000666F                 push    0FFFFFFFFh
.text$mn:00006671                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00006676                 mov     eax, large fs:0
.text$mn:0000667C                 push    eax
.text$mn:0000667D                 sub     esp, 10h
.text$mn:00006680                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006685                 xor     eax, ebp
.text$mn:00006687                 push    eax
.text$mn:00006688                 lea     eax, [ebp+var_C]
.text$mn:0000668B                 mov     large fs:0, eax
.text$mn:00006691                 mov     [ebp+var_1C], ecx
.text$mn:00006694                 mov     [ebp+var_18], 0
.text$mn:0000669B                 mov     eax, [ebp+arg_4]
.text$mn:0000669E                 push    eax             ; int
.text$mn:0000669F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000066A4                 add     esp, 4
.text$mn:000066A7                 mov     [ebp+var_10], eax
.text$mn:000066AA                 cmp     [ebp+var_10], 0
.text$mn:000066AE                 jz      short loc_66B8
.text$mn:000066B0                 mov     ecx, [ebp+var_10]
.text$mn:000066B3                 mov     [ebp+Str], ecx
.text$mn:000066B6                 jmp     short loc_66BF
.text$mn:000066B8 ; ---------------------------------------------------------------------------
.text$mn:000066B8
.text$mn:000066B8 loc_66B8:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:000066B8                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000066BF
.text$mn:000066BF loc_66BF:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:000066BF                 mov     edx, [ebp+Str]
.text$mn:000066C2                 push    edx             ; Str
.text$mn:000066C3                 mov     ecx, [ebp+arg_0]
.text$mn:000066C6                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000066CB                 mov     [ebp+var_4], 0
.text$mn:000066D2                 mov     eax, [ebp+var_18]
.text$mn:000066D5                 or      eax, 1
.text$mn:000066D8                 mov     [ebp+var_18], eax
.text$mn:000066DB                 mov     eax, [ebp+arg_0]
.text$mn:000066DE                 mov     ecx, [ebp+var_C]
.text$mn:000066E1                 mov     large fs:0, ecx
.text$mn:000066E8                 pop     ecx
.text$mn:000066E9                 mov     esp, ebp
.text$mn:000066EB                 pop     ebp
.text$mn:000066EC                 retn    8
.text$mn:000066EC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000066EC
.text$mn:000066EC ; ---------------------------------------------------------------------------
.text$mn:000066EF                 align 10h
.text$mn:000066EF _text$mn        ends
.text$mn:000066EF
.text$x:000066F0 ; ===========================================================================
.text$x:000066F0
.text$x:000066F0 ; Segment type: Pure code
.text$x:000066F0 ; Segment permissions: Read/Execute
.text$x:000066F0 _text$x         segment para public 'CODE' use32
.text$x:000066F0                 assume cs:_text$x
.text$x:000066F0                 ;org 66F0h
.text$x:000066F0 ; COMDAT (pick associative to section at 666C)
.text$x:000066F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000066F0
.text$x:000066F0 ; =============== S U B R O U T I N E =======================================
.text$x:000066F0
.text$x:000066F0
.text$x:000066F0 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000066F0                                         ; DATA XREF: .xdata$x:00006F7Co
.text$x:000066F0                 mov     eax, [ebp-18h]
.text$x:000066F3                 and     eax, 1
.text$x:000066F6                 jz      $LN6
.text$x:000066FC                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00006700                 mov     ecx, [ebp+8]
.text$x:00006703                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00006708 ; ---------------------------------------------------------------------------
.text$x:00006708
.text$x:00006708 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00006708                 retn
.text$x:00006708 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00006708
.text$x:00006709
.text$x:00006709 ; =============== S U B R O U T I N E =======================================
.text$x:00006709
.text$x:00006709
.text$x:00006709 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00006709                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00006709
.text$x:00006709 arg_4           = dword ptr  8
.text$x:00006709
.text$x:00006709                 mov     edx, [esp+arg_4]
.text$x:0000670D                 lea     eax, [edx+0Ch]
.text$x:00006710                 mov     ecx, [edx-14h]
.text$x:00006713                 xor     ecx, eax
.text$x:00006715                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000671A                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000671F                 jmp     ___CxxFrameHandler3
.text$x:0000671F __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000671F
.text$x:0000671F _text$x         ends
.text$x:0000671F
.text$mn:00006724 ; ===========================================================================
.text$mn:00006724
.text$mn:00006724 ; Segment type: Pure code
.text$mn:00006724 ; Segment permissions: Read/Execute
.text$mn:00006724 _text$mn        segment para public 'CODE' use32
.text$mn:00006724                 assume cs:_text$mn
.text$mn:00006724                 ;org 6724h
.text$mn:00006724 ; COMDAT (pick any)
.text$mn:00006724                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006724
.text$mn:00006724 ; =============== S U B R O U T I N E =======================================
.text$mn:00006724
.text$mn:00006724 ; Attributes: bp-based frame
.text$mn:00006724
.text$mn:00006724 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00006724                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00006724 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00006724                                         ; DATA XREF: .rdata:00007B94o
.text$mn:00006724
.text$mn:00006724 var_14          = dword ptr -14h
.text$mn:00006724 var_10          = dword ptr -10h
.text$mn:00006724 var_C           = dword ptr -0Ch
.text$mn:00006724 var_4           = dword ptr -4
.text$mn:00006724 arg_0           = dword ptr  8
.text$mn:00006724 arg_4           = dword ptr  0Ch
.text$mn:00006724
.text$mn:00006724                 push    ebp
.text$mn:00006725                 mov     ebp, esp
.text$mn:00006727                 push    0FFFFFFFFh
.text$mn:00006729                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000672E                 mov     eax, large fs:0
.text$mn:00006734                 push    eax
.text$mn:00006735                 sub     esp, 8
.text$mn:00006738                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000673D                 xor     eax, ebp
.text$mn:0000673F                 push    eax
.text$mn:00006740                 lea     eax, [ebp+var_C]
.text$mn:00006743                 mov     large fs:0, eax
.text$mn:00006749                 mov     [ebp+var_14], ecx
.text$mn:0000674C                 mov     [ebp+var_10], 0
.text$mn:00006753                 cmp     [ebp+arg_4], 1
.text$mn:00006757                 jnz     short loc_677D
.text$mn:00006759                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:0000675E                 mov     ecx, [ebp+arg_0]
.text$mn:00006761                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00006766                 mov     [ebp+var_4], 0
.text$mn:0000676D                 mov     eax, [ebp+var_10]
.text$mn:00006770                 or      eax, 1
.text$mn:00006773                 mov     [ebp+var_10], eax
.text$mn:00006776                 mov     eax, [ebp+arg_0]
.text$mn:00006779                 jmp     short loc_67A0
.text$mn:0000677B ; ---------------------------------------------------------------------------
.text$mn:0000677B                 jmp     short loc_67A0
.text$mn:0000677D ; ---------------------------------------------------------------------------
.text$mn:0000677D
.text$mn:0000677D loc_677D:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:0000677D                 mov     ecx, [ebp+arg_4]
.text$mn:00006780                 push    ecx
.text$mn:00006781                 mov     edx, [ebp+arg_0]
.text$mn:00006784                 push    edx
.text$mn:00006785                 mov     ecx, [ebp+var_14]
.text$mn:00006788                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:0000678D                 mov     [ebp+var_4], 0
.text$mn:00006794                 mov     eax, [ebp+var_10]
.text$mn:00006797                 or      eax, 1
.text$mn:0000679A                 mov     [ebp+var_10], eax
.text$mn:0000679D                 mov     eax, [ebp+arg_0]
.text$mn:000067A0
.text$mn:000067A0 loc_67A0:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:000067A0                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:000067A0                 mov     ecx, [ebp+var_C]
.text$mn:000067A3                 mov     large fs:0, ecx
.text$mn:000067AA                 pop     ecx
.text$mn:000067AB                 mov     esp, ebp
.text$mn:000067AD                 pop     ebp
.text$mn:000067AE                 retn    8
.text$mn:000067AE ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000067AE
.text$mn:000067AE ; ---------------------------------------------------------------------------
.text$mn:000067B1                 align 4
.text$mn:000067B1 _text$mn        ends
.text$mn:000067B1
.text$x:000067B4 ; ===========================================================================
.text$x:000067B4
.text$x:000067B4 ; Segment type: Pure code
.text$x:000067B4 ; Segment permissions: Read/Execute
.text$x:000067B4 _text$x         segment para public 'CODE' use32
.text$x:000067B4                 assume cs:_text$x
.text$x:000067B4                 ;org 67B4h
.text$x:000067B4 ; COMDAT (pick associative to section at 6724)
.text$x:000067B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000067B4
.text$x:000067B4 ; =============== S U B R O U T I N E =======================================
.text$x:000067B4
.text$x:000067B4
.text$x:000067B4 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000067B4                                         ; DATA XREF: .xdata$x:00007000o
.text$x:000067B4                 mov     eax, [ebp-10h]
.text$x:000067B7                 and     eax, 1
.text$x:000067BA                 jz      $LN6_0
.text$x:000067C0                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000067C4                 mov     ecx, [ebp+8]
.text$x:000067C7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000067CC ; ---------------------------------------------------------------------------
.text$x:000067CC
.text$x:000067CC $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000067CC                 retn
.text$x:000067CC __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000067CC
.text$x:000067CD
.text$x:000067CD ; =============== S U B R O U T I N E =======================================
.text$x:000067CD
.text$x:000067CD
.text$x:000067CD __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000067CD                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:000067CD
.text$x:000067CD arg_4           = dword ptr  8
.text$x:000067CD
.text$x:000067CD                 mov     edx, [esp+arg_4]
.text$x:000067D1                 lea     eax, [edx+0Ch]
.text$x:000067D4                 mov     ecx, [edx-0Ch]
.text$x:000067D7                 xor     ecx, eax
.text$x:000067D9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000067DE                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000067E3                 jmp     ___CxxFrameHandler3
.text$x:000067E3 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000067E3
.text$x:000067E3 _text$x         ends
.text$x:000067E3
.text$mn:000067E8 ; ===========================================================================
.text$mn:000067E8
.text$mn:000067E8 ; Segment type: Pure code
.text$mn:000067E8 ; Segment permissions: Read/Execute
.text$mn:000067E8 _text$mn        segment para public 'CODE' use32
.text$mn:000067E8                 assume cs:_text$mn
.text$mn:000067E8                 ;org 67E8h
.text$mn:000067E8 ; COMDAT (pick any)
.text$mn:000067E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000067E8
.text$mn:000067E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000067E8
.text$mn:000067E8 ; Attributes: bp-based frame
.text$mn:000067E8
.text$mn:000067E8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:000067E8                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000067E8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000067E8                                         ; DATA XREF: .rdata:00007BD4o
.text$mn:000067E8
.text$mn:000067E8 var_1C          = dword ptr -1Ch
.text$mn:000067E8 var_18          = dword ptr -18h
.text$mn:000067E8 Str             = dword ptr -14h
.text$mn:000067E8 var_10          = dword ptr -10h
.text$mn:000067E8 var_C           = dword ptr -0Ch
.text$mn:000067E8 var_4           = dword ptr -4
.text$mn:000067E8 arg_0           = dword ptr  8
.text$mn:000067E8 arg_4           = dword ptr  0Ch
.text$mn:000067E8
.text$mn:000067E8                 push    ebp
.text$mn:000067E9                 mov     ebp, esp
.text$mn:000067EB                 push    0FFFFFFFFh
.text$mn:000067ED                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000067F2                 mov     eax, large fs:0
.text$mn:000067F8                 push    eax
.text$mn:000067F9                 sub     esp, 10h
.text$mn:000067FC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006801                 xor     eax, ebp
.text$mn:00006803                 push    eax
.text$mn:00006804                 lea     eax, [ebp+var_C]
.text$mn:00006807                 mov     large fs:0, eax
.text$mn:0000680D                 mov     [ebp+var_1C], ecx
.text$mn:00006810                 mov     [ebp+var_18], 0
.text$mn:00006817                 mov     eax, [ebp+arg_4]
.text$mn:0000681A                 push    eax             ; int
.text$mn:0000681B                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00006820                 add     esp, 4
.text$mn:00006823                 mov     [ebp+var_10], eax
.text$mn:00006826                 cmp     [ebp+var_10], 0
.text$mn:0000682A                 jz      short loc_6834
.text$mn:0000682C                 mov     ecx, [ebp+var_10]
.text$mn:0000682F                 mov     [ebp+Str], ecx
.text$mn:00006832                 jmp     short loc_683B
.text$mn:00006834 ; ---------------------------------------------------------------------------
.text$mn:00006834
.text$mn:00006834 loc_6834:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00006834                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000683B
.text$mn:0000683B loc_683B:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:0000683B                 mov     edx, [ebp+Str]
.text$mn:0000683E                 push    edx             ; Str
.text$mn:0000683F                 mov     ecx, [ebp+arg_0]
.text$mn:00006842                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00006847                 mov     [ebp+var_4], 0
.text$mn:0000684E                 mov     eax, [ebp+var_18]
.text$mn:00006851                 or      eax, 1
.text$mn:00006854                 mov     [ebp+var_18], eax
.text$mn:00006857                 mov     eax, [ebp+arg_0]
.text$mn:0000685A                 mov     ecx, [ebp+var_C]
.text$mn:0000685D                 mov     large fs:0, ecx
.text$mn:00006864                 pop     ecx
.text$mn:00006865                 mov     esp, ebp
.text$mn:00006867                 pop     ebp
.text$mn:00006868                 retn    8
.text$mn:00006868 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00006868
.text$mn:00006868 ; ---------------------------------------------------------------------------
.text$mn:0000686B                 align 4
.text$mn:0000686B _text$mn        ends
.text$mn:0000686B
.text$x:0000686C ; ===========================================================================
.text$x:0000686C
.text$x:0000686C ; Segment type: Pure code
.text$x:0000686C ; Segment permissions: Read/Execute
.text$x:0000686C _text$x         segment para public 'CODE' use32
.text$x:0000686C                 assume cs:_text$x
.text$x:0000686C                 ;org 686Ch
.text$x:0000686C ; COMDAT (pick associative to section at 67E8)
.text$x:0000686C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000686C
.text$x:0000686C ; =============== S U B R O U T I N E =======================================
.text$x:0000686C
.text$x:0000686C
.text$x:0000686C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000686C                                         ; DATA XREF: .xdata$x:00007084o
.text$x:0000686C                 mov     eax, [ebp-18h]
.text$x:0000686F                 and     eax, 1
.text$x:00006872                 jz      $LN6_1
.text$x:00006878                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000687C                 mov     ecx, [ebp+8]
.text$x:0000687F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00006884 ; ---------------------------------------------------------------------------
.text$x:00006884
.text$x:00006884 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00006884                 retn
.text$x:00006884 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00006884
.text$x:00006885
.text$x:00006885 ; =============== S U B R O U T I N E =======================================
.text$x:00006885
.text$x:00006885
.text$x:00006885 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00006885                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00006885
.text$x:00006885 arg_4           = dword ptr  8
.text$x:00006885
.text$x:00006885                 mov     edx, [esp+arg_4]
.text$x:00006889                 lea     eax, [edx+0Ch]
.text$x:0000688C                 mov     ecx, [edx-14h]
.text$x:0000688F                 xor     ecx, eax
.text$x:00006891                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006896                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000689B                 jmp     ___CxxFrameHandler3
.text$x:0000689B __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000689B
.text$x:0000689B _text$x         ends
.text$x:0000689B
.text$mn:000068A0 ; ===========================================================================
.text$mn:000068A0
.text$mn:000068A0 ; Segment type: Pure code
.text$mn:000068A0 ; Segment permissions: Read/Execute
.text$mn:000068A0 _text$mn        segment para public 'CODE' use32
.text$mn:000068A0                 assume cs:_text$mn
.text$mn:000068A0                 ;org 68A0h
.text$mn:000068A0 ; COMDAT (pick any)
.text$mn:000068A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000068A0
.text$mn:000068A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000068A0
.text$mn:000068A0 ; Attributes: bp-based frame
.text$mn:000068A0
.text$mn:000068A0 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:000068A0                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000068A0 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:000068A0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:000068A0
.text$mn:000068A0 var_4           = dword ptr -4
.text$mn:000068A0 Dst             = dword ptr  8
.text$mn:000068A0 Src             = dword ptr  0Ch
.text$mn:000068A0 Size            = dword ptr  10h
.text$mn:000068A0
.text$mn:000068A0                 push    ebp
.text$mn:000068A1                 mov     ebp, esp
.text$mn:000068A3                 push    ecx
.text$mn:000068A4                 cmp     [ebp+Size], 0
.text$mn:000068A8                 jnz     short loc_68B2
.text$mn:000068AA                 mov     eax, [ebp+Dst]
.text$mn:000068AD                 mov     [ebp+var_4], eax
.text$mn:000068B0                 jmp     short loc_68C9
.text$mn:000068B2 ; ---------------------------------------------------------------------------
.text$mn:000068B2
.text$mn:000068B2 loc_68B2:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:000068B2                 mov     ecx, [ebp+Size]
.text$mn:000068B5                 push    ecx             ; Size
.text$mn:000068B6                 mov     edx, [ebp+Src]
.text$mn:000068B9                 push    edx             ; Src
.text$mn:000068BA                 mov     eax, [ebp+Dst]
.text$mn:000068BD                 push    eax             ; Dst
.text$mn:000068BE                 call    _memmove
.text$mn:000068C3                 add     esp, 0Ch
.text$mn:000068C6                 mov     [ebp+var_4], eax
.text$mn:000068C9
.text$mn:000068C9 loc_68C9:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:000068C9                 mov     eax, [ebp+var_4]
.text$mn:000068CC                 mov     esp, ebp
.text$mn:000068CE                 pop     ebp
.text$mn:000068CF                 retn
.text$mn:000068CF ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000068CF
.text$mn:000068CF _text$mn        ends
.text$mn:000068CF
.text$mn:000068D0 ; ===========================================================================
.text$mn:000068D0
.text$mn:000068D0 ; Segment type: Pure code
.text$mn:000068D0 ; Segment permissions: Read/Execute
.text$mn:000068D0 _text$mn        segment para public 'CODE' use32
.text$mn:000068D0                 assume cs:_text$mn
.text$mn:000068D0                 ;org 68D0h
.text$mn:000068D0 ; COMDAT (pick any)
.text$mn:000068D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000068D0
.text$mn:000068D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000068D0
.text$mn:000068D0 ; Attributes: bp-based frame
.text$mn:000068D0
.text$mn:000068D0 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:000068D0                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:000068D0 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:000068D0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:000068D0
.text$mn:000068D0 var_4           = dword ptr -4
.text$mn:000068D0 Dst             = dword ptr  8
.text$mn:000068D0 Src             = dword ptr  0Ch
.text$mn:000068D0 arg_8           = dword ptr  10h
.text$mn:000068D0
.text$mn:000068D0                 push    ebp
.text$mn:000068D1                 mov     ebp, esp
.text$mn:000068D3                 push    ecx
.text$mn:000068D4                 cmp     [ebp+arg_8], 0
.text$mn:000068D8                 jnz     short loc_68E2
.text$mn:000068DA                 mov     eax, [ebp+Dst]
.text$mn:000068DD                 mov     [ebp+var_4], eax
.text$mn:000068E0                 jmp     short loc_68F9
.text$mn:000068E2 ; ---------------------------------------------------------------------------
.text$mn:000068E2
.text$mn:000068E2 loc_68E2:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:000068E2                 mov     ecx, [ebp+arg_8]
.text$mn:000068E5                 push    ecx             ; int
.text$mn:000068E6                 mov     edx, [ebp+Src]
.text$mn:000068E9                 push    edx             ; Src
.text$mn:000068EA                 mov     eax, [ebp+Dst]
.text$mn:000068ED                 push    eax             ; Dst
.text$mn:000068EE                 call    _wmemmove
.text$mn:000068F3                 add     esp, 0Ch
.text$mn:000068F6                 mov     [ebp+var_4], eax
.text$mn:000068F9
.text$mn:000068F9 loc_68F9:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:000068F9                 mov     eax, [ebp+var_4]
.text$mn:000068FC                 mov     esp, ebp
.text$mn:000068FE                 pop     ebp
.text$mn:000068FF                 retn
.text$mn:000068FF ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:000068FF
.text$mn:000068FF _text$mn        ends
.text$mn:000068FF
.text$mn:00006900 ; ===========================================================================
.text$mn:00006900
.text$mn:00006900 ; Segment type: Pure code
.text$mn:00006900 ; Segment permissions: Read/Execute
.text$mn:00006900 _text$mn        segment para public 'CODE' use32
.text$mn:00006900                 assume cs:_text$mn
.text$mn:00006900                 ;org 6900h
.text$mn:00006900 ; COMDAT (pick any)
.text$mn:00006900                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006900
.text$mn:00006900 ; =============== S U B R O U T I N E =======================================
.text$mn:00006900
.text$mn:00006900 ; Attributes: bp-based frame
.text$mn:00006900
.text$mn:00006900 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00006900                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00006900 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00006900                                         ; DATA XREF: .rdata:00007B5Co
.text$mn:00006900
.text$mn:00006900 var_4           = dword ptr -4
.text$mn:00006900
.text$mn:00006900                 push    ebp
.text$mn:00006901                 mov     ebp, esp
.text$mn:00006903                 push    ecx
.text$mn:00006904                 mov     [ebp+var_4], ecx
.text$mn:00006907                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:0000690C                 mov     esp, ebp
.text$mn:0000690E                 pop     ebp
.text$mn:0000690F                 retn
.text$mn:0000690F ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000690F
.text$mn:0000690F _text$mn        ends
.text$mn:0000690F
.text$mn:00006910 ; ===========================================================================
.text$mn:00006910
.text$mn:00006910 ; Segment type: Pure code
.text$mn:00006910 ; Segment permissions: Read/Execute
.text$mn:00006910 _text$mn        segment para public 'CODE' use32
.text$mn:00006910                 assume cs:_text$mn
.text$mn:00006910                 ;org 6910h
.text$mn:00006910 ; COMDAT (pick any)
.text$mn:00006910                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006910
.text$mn:00006910 ; =============== S U B R O U T I N E =======================================
.text$mn:00006910
.text$mn:00006910 ; Attributes: bp-based frame
.text$mn:00006910
.text$mn:00006910 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00006910                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00006910 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00006910                                         ; DATA XREF: .rdata:00007B90o
.text$mn:00006910
.text$mn:00006910 var_4           = dword ptr -4
.text$mn:00006910
.text$mn:00006910                 push    ebp
.text$mn:00006911                 mov     ebp, esp
.text$mn:00006913                 push    ecx
.text$mn:00006914                 mov     [ebp+var_4], ecx
.text$mn:00006917                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:0000691C                 mov     esp, ebp
.text$mn:0000691E                 pop     ebp
.text$mn:0000691F                 retn
.text$mn:0000691F ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000691F
.text$mn:0000691F _text$mn        ends
.text$mn:0000691F
.text$mn:00006920 ; ===========================================================================
.text$mn:00006920
.text$mn:00006920 ; Segment type: Pure code
.text$mn:00006920 ; Segment permissions: Read/Execute
.text$mn:00006920 _text$mn        segment para public 'CODE' use32
.text$mn:00006920                 assume cs:_text$mn
.text$mn:00006920                 ;org 6920h
.text$mn:00006920 ; COMDAT (pick any)
.text$mn:00006920                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006920
.text$mn:00006920 ; =============== S U B R O U T I N E =======================================
.text$mn:00006920
.text$mn:00006920 ; Attributes: bp-based frame
.text$mn:00006920
.text$mn:00006920 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00006920                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00006920 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00006920                                         ; DATA XREF: .rdata:00007BD0o
.text$mn:00006920
.text$mn:00006920 var_4           = dword ptr -4
.text$mn:00006920
.text$mn:00006920                 push    ebp
.text$mn:00006921                 mov     ebp, esp
.text$mn:00006923                 push    ecx
.text$mn:00006924                 mov     [ebp+var_4], ecx
.text$mn:00006927                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:0000692C                 mov     esp, ebp
.text$mn:0000692E                 pop     ebp
.text$mn:0000692F                 retn
.text$mn:0000692F ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000692F
.text$mn:0000692F _text$mn        ends
.text$mn:0000692F
.text$mn:00006930 ; ===========================================================================
.text$mn:00006930
.text$mn:00006930 ; Segment type: Pure code
.text$mn:00006930 ; Segment permissions: Read/Execute
.text$mn:00006930 _text$mn        segment para public 'CODE' use32
.text$mn:00006930                 assume cs:_text$mn
.text$mn:00006930                 ;org 6930h
.text$mn:00006930 ; COMDAT (pick any)
.text$mn:00006930                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006930
.text$mn:00006930 ; =============== S U B R O U T I N E =======================================
.text$mn:00006930
.text$mn:00006930 ; Attributes: bp-based frame
.text$mn:00006930
.text$mn:00006930 ; public: void __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::push_back(struct TreeStateNode &&)
.text$mn:00006930                 public ?push_back@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAEX$$QAUTreeStateNode@@@Z
.text$mn:00006930 ?push_back@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAEX$$QAUTreeStateNode@@@Z proc near
.text$mn:00006930                                         ; CODE XREF: TreeView::retrieveFoldingStateTo(TreeStateNode &,_TREEITEM *)+180p
.text$mn:00006930
.text$mn:00006930 var_C           = dword ptr -0Ch
.text$mn:00006930 var_8           = dword ptr -8
.text$mn:00006930 var_2           = byte ptr -2
.text$mn:00006930 var_1           = byte ptr -1
.text$mn:00006930 arg_0           = dword ptr  8
.text$mn:00006930
.text$mn:00006930                 push    ebp
.text$mn:00006931                 mov     ebp, esp
.text$mn:00006933                 sub     esp, 0Ch
.text$mn:00006936                 mov     [ebp+var_8], ecx
.text$mn:00006939                 mov     eax, [ebp+arg_0]
.text$mn:0000693C                 push    eax
.text$mn:0000693D                 call    ??$addressof@UTreeStateNode@@@std@@YAPAUTreeStateNode@@AAU1@@Z ; std::addressof<TreeStateNode>(TreeStateNode &)
.text$mn:00006942                 add     esp, 4
.text$mn:00006945                 push    eax
.text$mn:00006946                 mov     ecx, [ebp+var_8]
.text$mn:00006949                 call    ?_Inside@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBE_NPBUTreeStateNode@@@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Inside(TreeStateNode const *)
.text$mn:0000694E                 movzx   ecx, al
.text$mn:00006951                 test    ecx, ecx
.text$mn:00006953                 jz      loc_69E3
.text$mn:00006959                 mov     edx, [ebp+arg_0]
.text$mn:0000695C                 push    edx
.text$mn:0000695D                 call    ??$addressof@UTreeStateNode@@@std@@YAPAUTreeStateNode@@AAU1@@Z ; std::addressof<TreeStateNode>(TreeStateNode &)
.text$mn:00006962                 add     esp, 4
.text$mn:00006965                 mov     ecx, [ebp+var_8]
.text$mn:00006968                 sub     eax, [ecx+4]
.text$mn:0000696B                 cdq
.text$mn:0000696C                 mov     ecx, 4Ch ; 'L'
.text$mn:00006971                 idiv    ecx
.text$mn:00006973                 mov     [ebp+var_C], eax
.text$mn:00006976                 mov     edx, [ebp+var_8]
.text$mn:00006979                 mov     eax, [ebp+var_8]
.text$mn:0000697C                 mov     ecx, [edx+8]
.text$mn:0000697F                 cmp     ecx, [eax+0Ch]
.text$mn:00006982                 jnz     short loc_698E
.text$mn:00006984                 push    1
.text$mn:00006986                 mov     ecx, [ebp+var_8]
.text$mn:00006989                 call    ?_Reserve@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reserve(uint)
.text$mn:0000698E
.text$mn:0000698E loc_698E:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::push_back(TreeStateNode &&)+52j
.text$mn:0000698E                 mov     edx, [ebp+var_8]
.text$mn:00006991                 mov     eax, [edx+8]
.text$mn:00006994                 push    eax
.text$mn:00006995                 mov     ecx, [ebp+var_8]
.text$mn:00006998                 mov     edx, [ecx+8]
.text$mn:0000699B                 push    edx
.text$mn:0000699C                 mov     ecx, [ebp+var_8]
.text$mn:0000699F                 call    ?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Orphan_range(TreeStateNode *,TreeStateNode *)
.text$mn:000069A4                 imul    eax, [ebp+var_C], 4Ch
.text$mn:000069A8                 mov     ecx, [ebp+var_8]
.text$mn:000069AB                 add     eax, [ecx+4]
.text$mn:000069AE                 push    eax
.text$mn:000069AF                 call    ??$forward@UTreeStateNode@@@std@@YA$$QAUTreeStateNode@@AAU1@@Z ; std::forward<TreeStateNode>(TreeStateNode &)
.text$mn:000069B4                 add     esp, 4
.text$mn:000069B7                 push    eax
.text$mn:000069B8                 mov     edx, [ebp+var_8]
.text$mn:000069BB                 mov     eax, [edx+8]
.text$mn:000069BE                 push    eax
.text$mn:000069BF                 lea     ecx, [ebp+var_1]
.text$mn:000069C2                 push    ecx
.text$mn:000069C3                 mov     ecx, [ebp+var_8]
.text$mn:000069C6                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Getal(void)
.text$mn:000069CB                 mov     ecx, eax
.text$mn:000069CD                 call    ??$construct@UTreeStateNode@@U1@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::construct<TreeStateNode,TreeStateNode>(TreeStateNode *,TreeStateNode &&)
.text$mn:000069D2                 mov     edx, [ebp+var_8]
.text$mn:000069D5                 mov     eax, [edx+8]
.text$mn:000069D8                 add     eax, 4Ch ; 'L'
.text$mn:000069DB                 mov     ecx, [ebp+var_8]
.text$mn:000069DE                 mov     [ecx+8], eax
.text$mn:000069E1                 jmp     short loc_6A47
.text$mn:000069E3 ; ---------------------------------------------------------------------------
.text$mn:000069E3
.text$mn:000069E3 loc_69E3:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::push_back(TreeStateNode &&)+23j
.text$mn:000069E3                 mov     edx, [ebp+var_8]
.text$mn:000069E6                 mov     eax, [ebp+var_8]
.text$mn:000069E9                 mov     ecx, [edx+8]
.text$mn:000069EC                 cmp     ecx, [eax+0Ch]
.text$mn:000069EF                 jnz     short loc_69FB
.text$mn:000069F1                 push    1
.text$mn:000069F3                 mov     ecx, [ebp+var_8]
.text$mn:000069F6                 call    ?_Reserve@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Reserve(uint)
.text$mn:000069FB
.text$mn:000069FB loc_69FB:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::push_back(TreeStateNode &&)+BFj
.text$mn:000069FB                 mov     edx, [ebp+var_8]
.text$mn:000069FE                 mov     eax, [edx+8]
.text$mn:00006A01                 push    eax
.text$mn:00006A02                 mov     ecx, [ebp+var_8]
.text$mn:00006A05                 mov     edx, [ecx+8]
.text$mn:00006A08                 push    edx
.text$mn:00006A09                 mov     ecx, [ebp+var_8]
.text$mn:00006A0C                 call    ?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Orphan_range(TreeStateNode *,TreeStateNode *)
.text$mn:00006A11                 mov     eax, [ebp+arg_0]
.text$mn:00006A14                 push    eax
.text$mn:00006A15                 call    ??$forward@UTreeStateNode@@@std@@YA$$QAUTreeStateNode@@AAU1@@Z ; std::forward<TreeStateNode>(TreeStateNode &)
.text$mn:00006A1A                 add     esp, 4
.text$mn:00006A1D                 push    eax
.text$mn:00006A1E                 mov     ecx, [ebp+var_8]
.text$mn:00006A21                 mov     edx, [ecx+8]
.text$mn:00006A24                 push    edx
.text$mn:00006A25                 lea     eax, [ebp+var_2]
.text$mn:00006A28                 push    eax
.text$mn:00006A29                 mov     ecx, [ebp+var_8]
.text$mn:00006A2C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TreeStateNode,std::allocator<TreeStateNode>>>::_Getal(void)
.text$mn:00006A31                 mov     ecx, eax
.text$mn:00006A33                 call    ??$construct@UTreeStateNode@@U1@@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::construct<TreeStateNode,TreeStateNode>(TreeStateNode *,TreeStateNode &&)
.text$mn:00006A38                 mov     ecx, [ebp+var_8]
.text$mn:00006A3B                 mov     edx, [ecx+8]
.text$mn:00006A3E                 add     edx, 4Ch ; 'L'
.text$mn:00006A41                 mov     eax, [ebp+var_8]
.text$mn:00006A44                 mov     [eax+8], edx
.text$mn:00006A47
.text$mn:00006A47 loc_6A47:                               ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::push_back(TreeStateNode &&)+B1j
.text$mn:00006A47                 mov     esp, ebp
.text$mn:00006A49                 pop     ebp
.text$mn:00006A4A                 retn    4
.text$mn:00006A4A ?push_back@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAEX$$QAUTreeStateNode@@@Z endp
.text$mn:00006A4A
.text$mn:00006A4A ; ---------------------------------------------------------------------------
.text$mn:00006A4D                 align 10h
.text$mn:00006A4D _text$mn        ends
.text$mn:00006A4D
.text$mn:00006A50 ; ===========================================================================
.text$mn:00006A50
.text$mn:00006A50 ; Segment type: Pure code
.text$mn:00006A50 ; Segment permissions: Read/Execute
.text$mn:00006A50 _text$mn        segment para public 'CODE' use32
.text$mn:00006A50                 assume cs:_text$mn
.text$mn:00006A50                 ;org 6A50h
.text$mn:00006A50 ; COMDAT (pick any)
.text$mn:00006A50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A50
.text$mn:00006A50 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A50
.text$mn:00006A50 ; Attributes: bp-based frame
.text$mn:00006A50
.text$mn:00006A50 ; bool __thiscall TreeView::selectItem(TreeView *this, struct _TREEITEM *)
.text$mn:00006A50                 public ?selectItem@TreeView@@QBE_NPAU_TREEITEM@@@Z
.text$mn:00006A50 ?selectItem@TreeView@@QBE_NPAU_TREEITEM@@@Z proc near
.text$mn:00006A50                                         ; CODE XREF: TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+382p
.text$mn:00006A50                                         ; TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+39Fp ...
.text$mn:00006A50
.text$mn:00006A50 var_8           = dword ptr -8
.text$mn:00006A50 var_4           = dword ptr -4
.text$mn:00006A50 lParam          = dword ptr  8
.text$mn:00006A50
.text$mn:00006A50                 push    ebp
.text$mn:00006A51                 mov     ebp, esp
.text$mn:00006A53                 sub     esp, 8
.text$mn:00006A56                 mov     [ebp+var_8], ecx
.text$mn:00006A59                 mov     eax, [ebp+lParam]
.text$mn:00006A5C                 push    eax             ; lParam
.text$mn:00006A5D                 push    9               ; wParam
.text$mn:00006A5F                 push    110Bh           ; Msg
.text$mn:00006A64                 mov     ecx, [ebp+var_8]
.text$mn:00006A67                 mov     edx, [ecx+0Ch]
.text$mn:00006A6A                 push    edx             ; hWnd
.text$mn:00006A6B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00006A71                 cmp     eax, 1
.text$mn:00006A74                 jnz     short loc_6A7F
.text$mn:00006A76                 mov     [ebp+var_4], 1
.text$mn:00006A7D                 jmp     short loc_6A86
.text$mn:00006A7F ; ---------------------------------------------------------------------------
.text$mn:00006A7F
.text$mn:00006A7F loc_6A7F:                               ; CODE XREF: TreeView::selectItem(_TREEITEM *)+24j
.text$mn:00006A7F                 mov     [ebp+var_4], 0
.text$mn:00006A86
.text$mn:00006A86 loc_6A86:                               ; CODE XREF: TreeView::selectItem(_TREEITEM *)+2Dj
.text$mn:00006A86                 mov     al, byte ptr [ebp+var_4]
.text$mn:00006A89                 mov     esp, ebp
.text$mn:00006A8B                 pop     ebp
.text$mn:00006A8C                 retn    4
.text$mn:00006A8C ?selectItem@TreeView@@QBE_NPAU_TREEITEM@@@Z endp
.text$mn:00006A8C
.text$mn:00006A8C ; ---------------------------------------------------------------------------
.text$mn:00006A8F                 align 10h
.text$mn:00006A8F _text$mn        ends
.text$mn:00006A8F
.text$mn:00006A90 ; ===========================================================================
.text$mn:00006A90
.text$mn:00006A90 ; Segment type: Pure code
.text$mn:00006A90 ; Segment permissions: Read/Execute
.text$mn:00006A90 _text$mn        segment para public 'CODE' use32
.text$mn:00006A90                 assume cs:_text$mn
.text$mn:00006A90                 ;org 6A90h
.text$mn:00006A90 ; COMDAT (pick any)
.text$mn:00006A90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A90
.text$mn:00006A90 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A90
.text$mn:00006A90 ; Attributes: bp-based frame
.text$mn:00006A90
.text$mn:00006A90 ; public: struct std::_Wrap_alloc<class std::allocator<struct TreeStateNode>> __thiscall std::_Wrap_alloc<class std::allocator<struct TreeStateNode>>::select_on_container_copy_construction(void)const
.text$mn:00006A90                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AU12@XZ
.text$mn:00006A90 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AU12@XZ proc near
.text$mn:00006A90                                         ; CODE XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(std::vector<TreeStateNode,std::allocator<TreeStateNode>> const &)+41p
.text$mn:00006A90
.text$mn:00006A90 var_8           = dword ptr -8
.text$mn:00006A90 var_1           = byte ptr -1
.text$mn:00006A90 arg_0           = dword ptr  8
.text$mn:00006A90
.text$mn:00006A90                 push    ebp
.text$mn:00006A91                 mov     ebp, esp
.text$mn:00006A93                 sub     esp, 8
.text$mn:00006A96                 mov     [ebp+var_8], ecx
.text$mn:00006A99                 mov     eax, [ebp+var_8]
.text$mn:00006A9C                 push    eax
.text$mn:00006A9D                 lea     ecx, [ebp+var_1]
.text$mn:00006AA0                 push    ecx
.text$mn:00006AA1                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SA?AV?$allocator@UTreeStateNode@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<TreeStateNode>>::select_on_container_copy_construction(std::allocator<TreeStateNode> const &)
.text$mn:00006AA6                 add     esp, 8
.text$mn:00006AA9                 push    eax
.text$mn:00006AAA                 mov     ecx, [ebp+arg_0]
.text$mn:00006AAD                 call    ??0?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z ; std::_Wrap_alloc<std::allocator<TreeStateNode>>::_Wrap_alloc<std::allocator<TreeStateNode>>(std::allocator<TreeStateNode> const &)
.text$mn:00006AB2                 mov     eax, [ebp+arg_0]
.text$mn:00006AB5                 mov     esp, ebp
.text$mn:00006AB7                 pop     ebp
.text$mn:00006AB8                 retn    4
.text$mn:00006AB8 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AU12@XZ endp
.text$mn:00006AB8
.text$mn:00006AB8 ; ---------------------------------------------------------------------------
.text$mn:00006ABB                 align 4
.text$mn:00006ABB _text$mn        ends
.text$mn:00006ABB
.text$mn:00006ABC ; ===========================================================================
.text$mn:00006ABC
.text$mn:00006ABC ; Segment type: Pure code
.text$mn:00006ABC ; Segment permissions: Read/Execute
.text$mn:00006ABC _text$mn        segment para public 'CODE' use32
.text$mn:00006ABC                 assume cs:_text$mn
.text$mn:00006ABC                 ;org 6ABCh
.text$mn:00006ABC ; COMDAT (pick any)
.text$mn:00006ABC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006ABC
.text$mn:00006ABC ; =============== S U B R O U T I N E =======================================
.text$mn:00006ABC
.text$mn:00006ABC ; Attributes: bp-based frame
.text$mn:00006ABC
.text$mn:00006ABC ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::select_on_container_copy_construction(void)const
.text$mn:00006ABC                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ
.text$mn:00006ABC ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ proc near
.text$mn:00006ABC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Ap
.text$mn:00006ABC
.text$mn:00006ABC var_8           = dword ptr -8
.text$mn:00006ABC var_1           = byte ptr -1
.text$mn:00006ABC arg_0           = dword ptr  8
.text$mn:00006ABC
.text$mn:00006ABC                 push    ebp
.text$mn:00006ABD                 mov     ebp, esp
.text$mn:00006ABF                 sub     esp, 8
.text$mn:00006AC2                 mov     [ebp+var_8], ecx
.text$mn:00006AC5                 mov     eax, [ebp+var_8]
.text$mn:00006AC8                 push    eax
.text$mn:00006AC9                 lea     ecx, [ebp+var_1]
.text$mn:00006ACC                 push    ecx
.text$mn:00006ACD                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ; std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)
.text$mn:00006AD2                 add     esp, 8
.text$mn:00006AD5                 push    eax
.text$mn:00006AD6                 mov     ecx, [ebp+arg_0]
.text$mn:00006AD9                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(std::allocator<wchar_t> const &)
.text$mn:00006ADE                 mov     eax, [ebp+arg_0]
.text$mn:00006AE1                 mov     esp, ebp
.text$mn:00006AE3                 pop     ebp
.text$mn:00006AE4                 retn    4
.text$mn:00006AE4 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ endp
.text$mn:00006AE4
.text$mn:00006AE4 ; ---------------------------------------------------------------------------
.text$mn:00006AE7                 align 4
.text$mn:00006AE7 _text$mn        ends
.text$mn:00006AE7
.text$mn:00006AE8 ; ===========================================================================
.text$mn:00006AE8
.text$mn:00006AE8 ; Segment type: Pure code
.text$mn:00006AE8 ; Segment permissions: Read/Execute
.text$mn:00006AE8 _text$mn        segment para public 'CODE' use32
.text$mn:00006AE8                 assume cs:_text$mn
.text$mn:00006AE8                 ;org 6AE8h
.text$mn:00006AE8 ; COMDAT (pick any)
.text$mn:00006AE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006AE8
.text$mn:00006AE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006AE8
.text$mn:00006AE8 ; Attributes: bp-based frame
.text$mn:00006AE8
.text$mn:00006AE8 ; public: class std::allocator<struct TreeStateNode> __thiscall std::allocator<struct TreeStateNode>::select_on_container_copy_construction(void)const
.text$mn:00006AE8                 public ?select_on_container_copy_construction@?$allocator@UTreeStateNode@@@std@@QBE?AV12@XZ
.text$mn:00006AE8 ?select_on_container_copy_construction@?$allocator@UTreeStateNode@@@std@@QBE?AV12@XZ proc near
.text$mn:00006AE8                                         ; CODE XREF: std::allocator_traits<std::allocator<TreeStateNode>>::select_on_container_copy_construction(std::allocator<TreeStateNode> const &)+Ap
.text$mn:00006AE8
.text$mn:00006AE8 var_4           = dword ptr -4
.text$mn:00006AE8 arg_0           = dword ptr  8
.text$mn:00006AE8
.text$mn:00006AE8                 push    ebp
.text$mn:00006AE9                 mov     ebp, esp
.text$mn:00006AEB                 push    ecx
.text$mn:00006AEC                 mov     [ebp+var_4], ecx
.text$mn:00006AEF                 mov     eax, [ebp+var_4]
.text$mn:00006AF2                 push    eax
.text$mn:00006AF3                 mov     ecx, [ebp+arg_0]
.text$mn:00006AF6                 call    ??0?$allocator@UTreeStateNode@@@std@@QAE@ABV01@@Z ; std::allocator<TreeStateNode>::allocator<TreeStateNode>(std::allocator<TreeStateNode> const &)
.text$mn:00006AFB                 mov     eax, [ebp+arg_0]
.text$mn:00006AFE                 mov     esp, ebp
.text$mn:00006B00                 pop     ebp
.text$mn:00006B01                 retn    4
.text$mn:00006B01 ?select_on_container_copy_construction@?$allocator@UTreeStateNode@@@std@@QBE?AV12@XZ endp
.text$mn:00006B01
.text$mn:00006B01 _text$mn        ends
.text$mn:00006B01
.text$mn:00006B04 ; ===========================================================================
.text$mn:00006B04
.text$mn:00006B04 ; Segment type: Pure code
.text$mn:00006B04 ; Segment permissions: Read/Execute
.text$mn:00006B04 _text$mn        segment para public 'CODE' use32
.text$mn:00006B04                 assume cs:_text$mn
.text$mn:00006B04                 ;org 6B04h
.text$mn:00006B04 ; COMDAT (pick any)
.text$mn:00006B04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B04
.text$mn:00006B04 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B04
.text$mn:00006B04 ; Attributes: bp-based frame
.text$mn:00006B04
.text$mn:00006B04 ; public: class std::allocator<wchar_t> __thiscall std::allocator<wchar_t>::select_on_container_copy_construction(void)const
.text$mn:00006B04                 public ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ
.text$mn:00006B04 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ proc near
.text$mn:00006B04                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)+Ap
.text$mn:00006B04
.text$mn:00006B04 var_4           = dword ptr -4
.text$mn:00006B04 arg_0           = dword ptr  8
.text$mn:00006B04
.text$mn:00006B04                 push    ebp
.text$mn:00006B05                 mov     ebp, esp
.text$mn:00006B07                 push    ecx
.text$mn:00006B08                 mov     [ebp+var_4], ecx
.text$mn:00006B0B                 mov     eax, [ebp+var_4]
.text$mn:00006B0E                 push    eax
.text$mn:00006B0F                 mov     ecx, [ebp+arg_0]
.text$mn:00006B12                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00006B17                 mov     eax, [ebp+arg_0]
.text$mn:00006B1A                 mov     esp, ebp
.text$mn:00006B1C                 pop     ebp
.text$mn:00006B1D                 retn    4
.text$mn:00006B1D ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ endp
.text$mn:00006B1D
.text$mn:00006B1D _text$mn        ends
.text$mn:00006B1D
.text$mn:00006B20 ; ===========================================================================
.text$mn:00006B20
.text$mn:00006B20 ; Segment type: Pure code
.text$mn:00006B20 ; Segment permissions: Read/Execute
.text$mn:00006B20 _text$mn        segment para public 'CODE' use32
.text$mn:00006B20                 assume cs:_text$mn
.text$mn:00006B20                 ;org 6B20h
.text$mn:00006B20 ; COMDAT (pick any)
.text$mn:00006B20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B20
.text$mn:00006B20 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B20
.text$mn:00006B20 ; Attributes: bp-based frame
.text$mn:00006B20
.text$mn:00006B20 ; public: static class std::allocator<struct TreeStateNode> __cdecl std::allocator_traits<class std::allocator<struct TreeStateNode>>::select_on_container_copy_construction(class std::allocator<struct TreeStateNode> const &)
.text$mn:00006B20                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SA?AV?$allocator@UTreeStateNode@@@2@ABV32@@Z
.text$mn:00006B20 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SA?AV?$allocator@UTreeStateNode@@@2@ABV32@@Z proc near
.text$mn:00006B20                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TreeStateNode>>::select_on_container_copy_construction(void)+11p
.text$mn:00006B20
.text$mn:00006B20 arg_0           = dword ptr  8
.text$mn:00006B20 arg_4           = dword ptr  0Ch
.text$mn:00006B20
.text$mn:00006B20                 push    ebp
.text$mn:00006B21                 mov     ebp, esp
.text$mn:00006B23                 mov     eax, [ebp+arg_0]
.text$mn:00006B26                 push    eax
.text$mn:00006B27                 mov     ecx, [ebp+arg_4]
.text$mn:00006B2A                 call    ?select_on_container_copy_construction@?$allocator@UTreeStateNode@@@std@@QBE?AV12@XZ ; std::allocator<TreeStateNode>::select_on_container_copy_construction(void)
.text$mn:00006B2F                 mov     eax, [ebp+arg_0]
.text$mn:00006B32                 pop     ebp
.text$mn:00006B33                 retn
.text$mn:00006B33 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UTreeStateNode@@@std@@@std@@SA?AV?$allocator@UTreeStateNode@@@2@ABV32@@Z endp
.text$mn:00006B33
.text$mn:00006B33 _text$mn        ends
.text$mn:00006B33
.text$mn:00006B34 ; ===========================================================================
.text$mn:00006B34
.text$mn:00006B34 ; Segment type: Pure code
.text$mn:00006B34 ; Segment permissions: Read/Execute
.text$mn:00006B34 _text$mn        segment para public 'CODE' use32
.text$mn:00006B34                 assume cs:_text$mn
.text$mn:00006B34                 ;org 6B34h
.text$mn:00006B34 ; COMDAT (pick any)
.text$mn:00006B34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B34
.text$mn:00006B34 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B34
.text$mn:00006B34 ; Attributes: bp-based frame
.text$mn:00006B34
.text$mn:00006B34 ; public: static class std::allocator<wchar_t> __cdecl std::allocator_traits<class std::allocator<wchar_t>>::select_on_container_copy_construction(class std::allocator<wchar_t> const &)
.text$mn:00006B34                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
.text$mn:00006B34 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z proc near
.text$mn:00006B34                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+11p
.text$mn:00006B34
.text$mn:00006B34 arg_0           = dword ptr  8
.text$mn:00006B34 arg_4           = dword ptr  0Ch
.text$mn:00006B34
.text$mn:00006B34                 push    ebp
.text$mn:00006B35                 mov     ebp, esp
.text$mn:00006B37                 mov     eax, [ebp+arg_0]
.text$mn:00006B3A                 push    eax
.text$mn:00006B3B                 mov     ecx, [ebp+arg_4]
.text$mn:00006B3E                 call    ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ ; std::allocator<wchar_t>::select_on_container_copy_construction(void)
.text$mn:00006B43                 mov     eax, [ebp+arg_0]
.text$mn:00006B46                 pop     ebp
.text$mn:00006B47                 retn
.text$mn:00006B47 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z endp
.text$mn:00006B47
.text$mn:00006B47 _text$mn        ends
.text$mn:00006B47
.text$mn:00006B48 ; ===========================================================================
.text$mn:00006B48
.text$mn:00006B48 ; Segment type: Pure code
.text$mn:00006B48 ; Segment permissions: Read/Execute
.text$mn:00006B48 _text$mn        segment para public 'CODE' use32
.text$mn:00006B48                 assume cs:_text$mn
.text$mn:00006B48                 ;org 6B48h
.text$mn:00006B48 ; COMDAT (pick any)
.text$mn:00006B48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B48
.text$mn:00006B48 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B48
.text$mn:00006B48 ; Attributes: bp-based frame
.text$mn:00006B48
.text$mn:00006B48 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00006B48                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00006B48 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00006B48                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00006B48                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00006B48
.text$mn:00006B48 var_4           = dword ptr -4
.text$mn:00006B48
.text$mn:00006B48                 push    ebp
.text$mn:00006B49                 mov     ebp, esp
.text$mn:00006B4B                 push    ecx
.text$mn:00006B4C                 mov     [ebp+var_4], ecx
.text$mn:00006B4F                 mov     eax, [ebp+var_4]
.text$mn:00006B52                 mov     eax, [eax+14h]
.text$mn:00006B55                 mov     esp, ebp
.text$mn:00006B57                 pop     ebp
.text$mn:00006B58                 retn
.text$mn:00006B58 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00006B58
.text$mn:00006B58 ; ---------------------------------------------------------------------------
.text$mn:00006B59                 align 4
.text$mn:00006B59 _text$mn        ends
.text$mn:00006B59
.text$mn:00006B5C ; ===========================================================================
.text$mn:00006B5C
.text$mn:00006B5C ; Segment type: Pure code
.text$mn:00006B5C ; Segment permissions: Read/Execute
.text$mn:00006B5C _text$mn        segment para public 'CODE' use32
.text$mn:00006B5C                 assume cs:_text$mn
.text$mn:00006B5C                 ;org 6B5Ch
.text$mn:00006B5C ; COMDAT (pick any)
.text$mn:00006B5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B5C
.text$mn:00006B5C ; =============== S U B R O U T I N E =======================================
.text$mn:00006B5C
.text$mn:00006B5C ; Attributes: bp-based frame
.text$mn:00006B5C
.text$mn:00006B5C ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:00006B5C                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00006B5C ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00006B5C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:00006B5C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p ...
.text$mn:00006B5C
.text$mn:00006B5C var_4           = dword ptr -4
.text$mn:00006B5C
.text$mn:00006B5C                 push    ebp
.text$mn:00006B5D                 mov     ebp, esp
.text$mn:00006B5F                 push    ecx
.text$mn:00006B60                 mov     [ebp+var_4], ecx
.text$mn:00006B63                 mov     eax, [ebp+var_4]
.text$mn:00006B66                 mov     eax, [eax+14h]
.text$mn:00006B69                 mov     esp, ebp
.text$mn:00006B6B                 pop     ebp
.text$mn:00006B6C                 retn
.text$mn:00006B6C ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00006B6C
.text$mn:00006B6C ; ---------------------------------------------------------------------------
.text$mn:00006B6D                 align 10h
.text$mn:00006B6D _text$mn        ends
.text$mn:00006B6D
.text$mn:00006B70 ; ===========================================================================
.text$mn:00006B70
.text$mn:00006B70 ; Segment type: Pure code
.text$mn:00006B70 ; Segment permissions: Read/Execute
.text$mn:00006B70 _text$mn        segment para public 'CODE' use32
.text$mn:00006B70                 assume cs:_text$mn
.text$mn:00006B70                 ;org 6B70h
.text$mn:00006B70 ; COMDAT (pick any)
.text$mn:00006B70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B70
.text$mn:00006B70 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B70
.text$mn:00006B70 ; Attributes: bp-based frame
.text$mn:00006B70
.text$mn:00006B70 ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::size(void)const
.text$mn:00006B70                 public ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:00006B70 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:00006B70                                         ; CODE XREF: TreeView::canDragOut(_TREEITEM *)+3Bp
.text$mn:00006B70                                         ; TreeView::canDropIn(_TREEITEM *)+3Bp ...
.text$mn:00006B70
.text$mn:00006B70 var_4           = dword ptr -4
.text$mn:00006B70
.text$mn:00006B70                 push    ebp
.text$mn:00006B71                 mov     ebp, esp
.text$mn:00006B73                 push    ecx
.text$mn:00006B74                 mov     [ebp+var_4], ecx
.text$mn:00006B77                 mov     eax, [ebp+var_4]
.text$mn:00006B7A                 mov     ecx, [ebp+var_4]
.text$mn:00006B7D                 mov     eax, [eax+8]
.text$mn:00006B80                 sub     eax, [ecx+4]
.text$mn:00006B83                 sar     eax, 2
.text$mn:00006B86                 mov     esp, ebp
.text$mn:00006B88                 pop     ebp
.text$mn:00006B89                 retn
.text$mn:00006B89 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:00006B89
.text$mn:00006B89 ; ---------------------------------------------------------------------------
.text$mn:00006B8A                 align 4
.text$mn:00006B8A _text$mn        ends
.text$mn:00006B8A
.text$mn:00006B8C ; ===========================================================================
.text$mn:00006B8C
.text$mn:00006B8C ; Segment type: Pure code
.text$mn:00006B8C ; Segment permissions: Read/Execute
.text$mn:00006B8C _text$mn        segment para public 'CODE' use32
.text$mn:00006B8C                 assume cs:_text$mn
.text$mn:00006B8C                 ;org 6B8Ch
.text$mn:00006B8C ; COMDAT (pick any)
.text$mn:00006B8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B8C
.text$mn:00006B8C ; =============== S U B R O U T I N E =======================================
.text$mn:00006B8C
.text$mn:00006B8C ; Attributes: bp-based frame
.text$mn:00006B8C
.text$mn:00006B8C ; public: unsigned int __thiscall std::vector<struct TreeStateNode, class std::allocator<struct TreeStateNode>>::size(void)const
.text$mn:00006B8C                 public ?size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ
.text$mn:00006B8C ?size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ proc near
.text$mn:00006B8C                                         ; CODE XREF: TreeView::restoreFoldingStateFrom(TreeStateNode const &,_TREEITEM *)+14Fp
.text$mn:00006B8C                                         ; std::vector<TreeStateNode,std::allocator<TreeStateNode>>::vector<TreeStateNode,std::allocator<TreeStateNode>>(std::vector<TreeStateNode,std::allocator<TreeStateNode>> const &)+59p ...
.text$mn:00006B8C
.text$mn:00006B8C var_4           = dword ptr -4
.text$mn:00006B8C
.text$mn:00006B8C                 push    ebp
.text$mn:00006B8D                 mov     ebp, esp
.text$mn:00006B8F                 push    ecx
.text$mn:00006B90                 mov     [ebp+var_4], ecx
.text$mn:00006B93                 mov     eax, [ebp+var_4]
.text$mn:00006B96                 mov     ecx, [ebp+var_4]
.text$mn:00006B99                 mov     eax, [eax+8]
.text$mn:00006B9C                 sub     eax, [ecx+4]
.text$mn:00006B9F                 cdq
.text$mn:00006BA0                 mov     ecx, 4Ch ; 'L'
.text$mn:00006BA5                 idiv    ecx
.text$mn:00006BA7                 mov     esp, ebp
.text$mn:00006BA9                 pop     ebp
.text$mn:00006BAA                 retn
.text$mn:00006BAA ?size@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBEIXZ endp
.text$mn:00006BAA
.text$mn:00006BAA ; ---------------------------------------------------------------------------
.text$mn:00006BAB                 align 4
.text$mn:00006BAB _text$mn        ends
.text$mn:00006BAB
.text$mn:00006BAC ; ===========================================================================
.text$mn:00006BAC
.text$mn:00006BAC ; Segment type: Pure code
.text$mn:00006BAC ; Segment permissions: Read/Execute
.text$mn:00006BAC _text$mn        segment para public 'CODE' use32
.text$mn:00006BAC                 assume cs:_text$mn
.text$mn:00006BAC                 ;org 6BACh
.text$mn:00006BAC ; COMDAT (pick any)
.text$mn:00006BAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006BAC
.text$mn:00006BAC ; =============== S U B R O U T I N E =======================================
.text$mn:00006BAC
.text$mn:00006BAC ; Attributes: bp-based frame
.text$mn:00006BAC
.text$mn:00006BAC ; __int32 __stdcall TreeView::staticProc(HWND hWnd, UINT Msg, WPARAM wParam, __int32)
.text$mn:00006BAC                 public ?staticProc@TreeView@@KGJPAUHWND__@@IIJ@Z
.text$mn:00006BAC ?staticProc@TreeView@@KGJPAUHWND__@@IIJ@Z proc near
.text$mn:00006BAC                                         ; DATA XREF: TreeView::init(HINSTANCE__ *,HWND__ *,int)+8Bo
.text$mn:00006BAC
.text$mn:00006BAC hWnd            = dword ptr  8
.text$mn:00006BAC Msg             = dword ptr  0Ch
.text$mn:00006BAC wParam          = dword ptr  10h
.text$mn:00006BAC arg_C           = dword ptr  14h
.text$mn:00006BAC
.text$mn:00006BAC                 push    ebp
.text$mn:00006BAD                 mov     ebp, esp
.text$mn:00006BAF                 mov     eax, [ebp+arg_C]
.text$mn:00006BB2                 push    eax             ; __int32
.text$mn:00006BB3                 mov     ecx, [ebp+wParam]
.text$mn:00006BB6                 push    ecx             ; wParam
.text$mn:00006BB7                 mov     edx, [ebp+Msg]
.text$mn:00006BBA                 push    edx             ; Msg
.text$mn:00006BBB                 mov     eax, [ebp+hWnd]
.text$mn:00006BBE                 push    eax             ; hWnd
.text$mn:00006BBF                 push    0FFFFFFEBh      ; nIndex
.text$mn:00006BC1                 mov     ecx, [ebp+hWnd]
.text$mn:00006BC4                 push    ecx             ; hWnd
.text$mn:00006BC5                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:00006BCB                 mov     ecx, eax        ; this
.text$mn:00006BCD                 call    ?runProc@TreeView@@IAEJPAUHWND__@@IIJ@Z ; TreeView::runProc(HWND__ *,uint,uint,long)
.text$mn:00006BD2                 pop     ebp
.text$mn:00006BD3                 retn    10h
.text$mn:00006BD3 ?staticProc@TreeView@@KGJPAUHWND__@@IIJ@Z endp
.text$mn:00006BD3
.text$mn:00006BD3 ; ---------------------------------------------------------------------------
.text$mn:00006BD6                 align 4
.text$mn:00006BD6 _text$mn        ends
.text$mn:00006BD6
.text$mn:00006BD8 ; ===========================================================================
.text$mn:00006BD8
.text$mn:00006BD8 ; Segment type: Pure code
.text$mn:00006BD8 ; Segment permissions: Read/Execute
.text$mn:00006BD8 _text$mn        segment para public 'CODE' use32
.text$mn:00006BD8                 assume cs:_text$mn
.text$mn:00006BD8                 ;org 6BD8h
.text$mn:00006BD8 ; COMDAT (pick any)
.text$mn:00006BD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006BD8
.text$mn:00006BD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006BD8
.text$mn:00006BD8 ; Attributes: bp-based frame
.text$mn:00006BD8
.text$mn:00006BD8 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00006BD8                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00006BD8 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00006BD8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_5F40p
.text$mn:00006BD8                 push    ebp
.text$mn:00006BD9                 mov     ebp, esp
.text$mn:00006BDB                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00006BE0                 pop     ebp
.text$mn:00006BE1                 retn
.text$mn:00006BE1 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00006BE1
.text$mn:00006BE1 ; ---------------------------------------------------------------------------
.text$mn:00006BE2                 align 4
.text$mn:00006BE2 _text$mn        ends
.text$mn:00006BE2
.text$mn:00006BE4 ; ===========================================================================
.text$mn:00006BE4
.text$mn:00006BE4 ; Segment type: Pure code
.text$mn:00006BE4 ; Segment permissions: Read/Execute
.text$mn:00006BE4 _text$mn        segment para public 'CODE' use32
.text$mn:00006BE4                 assume cs:_text$mn
.text$mn:00006BE4                 ;org 6BE4h
.text$mn:00006BE4 ; COMDAT (pick any)
.text$mn:00006BE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006BE4
.text$mn:00006BE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006BE4
.text$mn:00006BE4 ; Attributes: bp-based frame
.text$mn:00006BE4
.text$mn:00006BE4 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00006BE4                 public ?value@error_code@std@@QBEHXZ
.text$mn:00006BE4 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00006BE4
.text$mn:00006BE4 var_4           = dword ptr -4
.text$mn:00006BE4
.text$mn:00006BE4                 push    ebp
.text$mn:00006BE5                 mov     ebp, esp
.text$mn:00006BE7                 push    ecx
.text$mn:00006BE8                 mov     [ebp+var_4], ecx
.text$mn:00006BEB                 mov     eax, [ebp+var_4]
.text$mn:00006BEE                 mov     eax, [eax]
.text$mn:00006BF0                 mov     esp, ebp
.text$mn:00006BF2                 pop     ebp
.text$mn:00006BF3                 retn
.text$mn:00006BF3 ?value@error_code@std@@QBEHXZ endp
.text$mn:00006BF3
.text$mn:00006BF3 _text$mn        ends
.text$mn:00006BF3
.text$mn:00006BF4 ; ===========================================================================
.text$mn:00006BF4
.text$mn:00006BF4 ; Segment type: Pure code
.text$mn:00006BF4 ; Segment permissions: Read/Execute
.text$mn:00006BF4 _text$mn        segment para public 'CODE' use32
.text$mn:00006BF4                 assume cs:_text$mn
.text$mn:00006BF4                 ;org 6BF4h
.text$mn:00006BF4 ; COMDAT (pick any)
.text$mn:00006BF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006BF4
.text$mn:00006BF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006BF4
.text$mn:00006BF4 ; Attributes: bp-based frame
.text$mn:00006BF4
.text$mn:00006BF4 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00006BF4                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00006BF4 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00006BF4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00006BF4                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00006BF4
.text$mn:00006BF4 var_4           = dword ptr -4
.text$mn:00006BF4
.text$mn:00006BF4                 push    ebp
.text$mn:00006BF5                 mov     ebp, esp
.text$mn:00006BF7                 push    ecx
.text$mn:00006BF8                 mov     [ebp+var_4], ecx
.text$mn:00006BFB                 mov     eax, [ebp+var_4]
.text$mn:00006BFE                 mov     eax, [eax]
.text$mn:00006C00                 mov     esp, ebp
.text$mn:00006C02                 pop     ebp
.text$mn:00006C03                 retn
.text$mn:00006C03 ?value@error_condition@std@@QBEHXZ endp
.text$mn:00006C03
.text$mn:00006C03 _text$mn        ends
.text$mn:00006C03
.text$mn:00006C04 ; ===========================================================================
.text$mn:00006C04
.text$mn:00006C04 ; Segment type: Pure code
.text$mn:00006C04 ; Segment permissions: Read/Execute
.text$mn:00006C04 _text$mn        segment para public 'CODE' use32
.text$mn:00006C04                 assume cs:_text$mn
.text$mn:00006C04                 ;org 6C04h
.text$mn:00006C04 ; COMDAT (pick any)
.text$mn:00006C04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C04
.text$mn:00006C04 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C04
.text$mn:00006C04 ; Attributes: bp-based frame
.text$mn:00006C04
.text$mn:00006C04                 public _hypot
.text$mn:00006C04 _hypot          proc near
.text$mn:00006C04
.text$mn:00006C04 var_10          = qword ptr -10h
.text$mn:00006C04 var_8           = qword ptr -8
.text$mn:00006C04 arg_0           = qword ptr  8
.text$mn:00006C04 arg_8           = qword ptr  10h
.text$mn:00006C04
.text$mn:00006C04                 push    ebp
.text$mn:00006C05                 mov     ebp, esp
.text$mn:00006C07                 sub     esp, 8
.text$mn:00006C0A                 movsd   xmm0, [ebp+arg_8]
.text$mn:00006C0F                 movsd   [esp+8+var_8], xmm0
.text$mn:00006C14                 sub     esp, 8
.text$mn:00006C17                 movsd   xmm0, [ebp+arg_0]
.text$mn:00006C1C                 movsd   [esp+10h+var_10], xmm0
.text$mn:00006C21                 call    __hypot
.text$mn:00006C26                 add     esp, 10h
.text$mn:00006C29                 pop     ebp
.text$mn:00006C2A                 retn
.text$mn:00006C2A _hypot          endp
.text$mn:00006C2A
.text$mn:00006C2A ; ---------------------------------------------------------------------------
.text$mn:00006C2B                 align 4
.text$mn:00006C2B _text$mn        ends
.text$mn:00006C2B
.text$mn:00006C2C ; ===========================================================================
.text$mn:00006C2C
.text$mn:00006C2C ; Segment type: Pure code
.text$mn:00006C2C ; Segment permissions: Read/Execute
.text$mn:00006C2C _text$mn        segment para public 'CODE' use32
.text$mn:00006C2C                 assume cs:_text$mn
.text$mn:00006C2C                 ;org 6C2Ch
.text$mn:00006C2C ; COMDAT (pick any)
.text$mn:00006C2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C2C
.text$mn:00006C2C ; =============== S U B R O U T I N E =======================================
.text$mn:00006C2C
.text$mn:00006C2C ; Attributes: bp-based frame
.text$mn:00006C2C
.text$mn:00006C2C                 public _wmemchr
.text$mn:00006C2C _wmemchr        proc near               ; CODE XREF: std::char_traits<wchar_t>::find(wchar_t const *,uint,wchar_t const &)+22p
.text$mn:00006C2C
.text$mn:00006C2C arg_0           = dword ptr  8
.text$mn:00006C2C arg_4           = word ptr  0Ch
.text$mn:00006C2C arg_8           = dword ptr  10h
.text$mn:00006C2C
.text$mn:00006C2C                 push    ebp
.text$mn:00006C2D                 mov     ebp, esp
.text$mn:00006C2F                 jmp     short loc_6C43
.text$mn:00006C31 ; ---------------------------------------------------------------------------
.text$mn:00006C31
.text$mn:00006C31 loc_6C31:                               ; CODE XREF: _wmemchr:loc_6C5Cj
.text$mn:00006C31                 mov     eax, [ebp+arg_0]
.text$mn:00006C34                 add     eax, 2
.text$mn:00006C37                 mov     [ebp+arg_0], eax
.text$mn:00006C3A                 mov     ecx, [ebp+arg_8]
.text$mn:00006C3D                 sub     ecx, 1
.text$mn:00006C40                 mov     [ebp+arg_8], ecx
.text$mn:00006C43
.text$mn:00006C43 loc_6C43:                               ; CODE XREF: _wmemchr+3j
.text$mn:00006C43                 cmp     [ebp+arg_8], 0
.text$mn:00006C47                 jbe     short loc_6C5E
.text$mn:00006C49                 mov     edx, [ebp+arg_0]
.text$mn:00006C4C                 movzx   eax, word ptr [edx]
.text$mn:00006C4F                 movzx   ecx, [ebp+arg_4]
.text$mn:00006C53                 cmp     eax, ecx
.text$mn:00006C55                 jnz     short loc_6C5C
.text$mn:00006C57                 mov     eax, [ebp+arg_0]
.text$mn:00006C5A                 jmp     short loc_6C60
.text$mn:00006C5C ; ---------------------------------------------------------------------------
.text$mn:00006C5C
.text$mn:00006C5C loc_6C5C:                               ; CODE XREF: _wmemchr+29j
.text$mn:00006C5C                 jmp     short loc_6C31
.text$mn:00006C5E ; ---------------------------------------------------------------------------
.text$mn:00006C5E
.text$mn:00006C5E loc_6C5E:                               ; CODE XREF: _wmemchr+1Bj
.text$mn:00006C5E                 xor     eax, eax
.text$mn:00006C60
.text$mn:00006C60 loc_6C60:                               ; CODE XREF: _wmemchr+2Ej
.text$mn:00006C60                 pop     ebp
.text$mn:00006C61                 retn
.text$mn:00006C61 _wmemchr        endp
.text$mn:00006C61
.text$mn:00006C61 ; ---------------------------------------------------------------------------
.text$mn:00006C62                 align 4
.text$mn:00006C62 _text$mn        ends
.text$mn:00006C62
.text$mn:00006C64 ; ===========================================================================
.text$mn:00006C64
.text$mn:00006C64 ; Segment type: Pure code
.text$mn:00006C64 ; Segment permissions: Read/Execute
.text$mn:00006C64 _text$mn        segment para public 'CODE' use32
.text$mn:00006C64                 assume cs:_text$mn
.text$mn:00006C64                 ;org 6C64h
.text$mn:00006C64 ; COMDAT (pick any)
.text$mn:00006C64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C64
.text$mn:00006C64 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C64
.text$mn:00006C64 ; Attributes: bp-based frame
.text$mn:00006C64
.text$mn:00006C64                 public _wmemcmp
.text$mn:00006C64 _wmemcmp        proc near               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+1Fp
.text$mn:00006C64
.text$mn:00006C64 var_4           = dword ptr -4
.text$mn:00006C64 arg_0           = dword ptr  8
.text$mn:00006C64 arg_4           = dword ptr  0Ch
.text$mn:00006C64 arg_8           = dword ptr  10h
.text$mn:00006C64
.text$mn:00006C64                 push    ebp
.text$mn:00006C65                 mov     ebp, esp
.text$mn:00006C67                 push    ecx
.text$mn:00006C68                 jmp     short loc_6C85
.text$mn:00006C6A ; ---------------------------------------------------------------------------
.text$mn:00006C6A
.text$mn:00006C6A loc_6C6A:                               ; CODE XREF: _wmemcmp:loc_6CC0j
.text$mn:00006C6A                 mov     eax, [ebp+arg_0]
.text$mn:00006C6D                 add     eax, 2
.text$mn:00006C70                 mov     [ebp+arg_0], eax
.text$mn:00006C73                 mov     ecx, [ebp+arg_4]
.text$mn:00006C76                 add     ecx, 2
.text$mn:00006C79                 mov     [ebp+arg_4], ecx
.text$mn:00006C7C                 mov     edx, [ebp+arg_8]
.text$mn:00006C7F                 sub     edx, 1
.text$mn:00006C82                 mov     [ebp+arg_8], edx
.text$mn:00006C85
.text$mn:00006C85 loc_6C85:                               ; CODE XREF: _wmemcmp+4j
.text$mn:00006C85                 cmp     [ebp+arg_8], 0
.text$mn:00006C89                 jbe     short loc_6CC2
.text$mn:00006C8B                 mov     eax, [ebp+arg_0]
.text$mn:00006C8E                 movzx   ecx, word ptr [eax]
.text$mn:00006C91                 mov     edx, [ebp+arg_4]
.text$mn:00006C94                 movzx   eax, word ptr [edx]
.text$mn:00006C97                 cmp     ecx, eax
.text$mn:00006C99                 jz      short loc_6CC0
.text$mn:00006C9B                 mov     ecx, [ebp+arg_0]
.text$mn:00006C9E                 movzx   edx, word ptr [ecx]
.text$mn:00006CA1                 mov     eax, [ebp+arg_4]
.text$mn:00006CA4                 movzx   ecx, word ptr [eax]
.text$mn:00006CA7                 cmp     edx, ecx
.text$mn:00006CA9                 jge     short loc_6CB4
.text$mn:00006CAB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006CB2                 jmp     short loc_6CBB
.text$mn:00006CB4 ; ---------------------------------------------------------------------------
.text$mn:00006CB4
.text$mn:00006CB4 loc_6CB4:                               ; CODE XREF: _wmemcmp+45j
.text$mn:00006CB4                 mov     [ebp+var_4], 1
.text$mn:00006CBB
.text$mn:00006CBB loc_6CBB:                               ; CODE XREF: _wmemcmp+4Ej
.text$mn:00006CBB                 mov     eax, [ebp+var_4]
.text$mn:00006CBE                 jmp     short loc_6CC4
.text$mn:00006CC0 ; ---------------------------------------------------------------------------
.text$mn:00006CC0
.text$mn:00006CC0 loc_6CC0:                               ; CODE XREF: _wmemcmp+35j
.text$mn:00006CC0                 jmp     short loc_6C6A
.text$mn:00006CC2 ; ---------------------------------------------------------------------------
.text$mn:00006CC2
.text$mn:00006CC2 loc_6CC2:                               ; CODE XREF: _wmemcmp+25j
.text$mn:00006CC2                 xor     eax, eax
.text$mn:00006CC4
.text$mn:00006CC4 loc_6CC4:                               ; CODE XREF: _wmemcmp+5Aj
.text$mn:00006CC4                 mov     esp, ebp
.text$mn:00006CC6                 pop     ebp
.text$mn:00006CC7                 retn
.text$mn:00006CC7 _wmemcmp        endp
.text$mn:00006CC7
.text$mn:00006CC7 _text$mn        ends
.text$mn:00006CC7
.text$mn:00006CC8 ; ===========================================================================
.text$mn:00006CC8
.text$mn:00006CC8 ; Segment type: Pure code
.text$mn:00006CC8 ; Segment permissions: Read/Execute
.text$mn:00006CC8 _text$mn        segment para public 'CODE' use32
.text$mn:00006CC8                 assume cs:_text$mn
.text$mn:00006CC8                 ;org 6CC8h
.text$mn:00006CC8 ; COMDAT (pick any)
.text$mn:00006CC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006CC8
.text$mn:00006CC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006CC8
.text$mn:00006CC8 ; Attributes: bp-based frame
.text$mn:00006CC8
.text$mn:00006CC8 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:00006CC8                 public _wmemcpy
.text$mn:00006CC8 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00006CC8
.text$mn:00006CC8 Dst             = dword ptr  8
.text$mn:00006CC8 Src             = dword ptr  0Ch
.text$mn:00006CC8 arg_8           = dword ptr  10h
.text$mn:00006CC8
.text$mn:00006CC8                 push    ebp
.text$mn:00006CC9                 mov     ebp, esp
.text$mn:00006CCB                 mov     eax, [ebp+arg_8]
.text$mn:00006CCE                 shl     eax, 1
.text$mn:00006CD0                 push    eax             ; Size
.text$mn:00006CD1                 mov     ecx, [ebp+Src]
.text$mn:00006CD4                 push    ecx             ; Src
.text$mn:00006CD5                 mov     edx, [ebp+Dst]
.text$mn:00006CD8                 push    edx             ; Dst
.text$mn:00006CD9                 call    _memcpy
.text$mn:00006CDE                 add     esp, 0Ch
.text$mn:00006CE1                 pop     ebp
.text$mn:00006CE2                 retn
.text$mn:00006CE2 _wmemcpy        endp
.text$mn:00006CE2
.text$mn:00006CE2 ; ---------------------------------------------------------------------------
.text$mn:00006CE3                 align 4
.text$mn:00006CE3 _text$mn        ends
.text$mn:00006CE3
.text$mn:00006CE4 ; ===========================================================================
.text$mn:00006CE4
.text$mn:00006CE4 ; Segment type: Pure code
.text$mn:00006CE4 ; Segment permissions: Read/Execute
.text$mn:00006CE4 _text$mn        segment para public 'CODE' use32
.text$mn:00006CE4                 assume cs:_text$mn
.text$mn:00006CE4                 ;org 6CE4h
.text$mn:00006CE4 ; COMDAT (pick any)
.text$mn:00006CE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006CE4
.text$mn:00006CE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006CE4
.text$mn:00006CE4 ; Attributes: bp-based frame
.text$mn:00006CE4
.text$mn:00006CE4 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:00006CE4                 public _wmemmove
.text$mn:00006CE4 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00006CE4
.text$mn:00006CE4 Dst             = dword ptr  8
.text$mn:00006CE4 Src             = dword ptr  0Ch
.text$mn:00006CE4 arg_8           = dword ptr  10h
.text$mn:00006CE4
.text$mn:00006CE4                 push    ebp
.text$mn:00006CE5                 mov     ebp, esp
.text$mn:00006CE7                 mov     eax, [ebp+arg_8]
.text$mn:00006CEA                 shl     eax, 1
.text$mn:00006CEC                 push    eax             ; Size
.text$mn:00006CED                 mov     ecx, [ebp+Src]
.text$mn:00006CF0                 push    ecx             ; Src
.text$mn:00006CF1                 mov     edx, [ebp+Dst]
.text$mn:00006CF4                 push    edx             ; Dst
.text$mn:00006CF5                 call    _memmove
.text$mn:00006CFA                 add     esp, 0Ch
.text$mn:00006CFD                 pop     ebp
.text$mn:00006CFE                 retn
.text$mn:00006CFE _wmemmove       endp
.text$mn:00006CFE
.text$mn:00006CFE ; ---------------------------------------------------------------------------
.text$mn:00006CFF                 align 10h
.text$mn:00006CFF _text$mn        ends
.text$mn:00006CFF
.xdata$x:00006D00 ; ===========================================================================
.xdata$x:00006D00
.xdata$x:00006D00 ; Segment type: Pure data
.xdata$x:00006D00 ; Segment permissions: Read
.xdata$x:00006D00 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006D00                 assume cs:_xdata$x
.xdata$x:00006D00                 ;org 6D00h
.xdata$x:00006D00 ; COMDAT (pick associative to section at 4FCC)
.xdata$x:00006D00 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00006D00                                         ; DATA XREF: .xdata$x:00006D10o
.xdata$x:00006D01                 db 0FFh
.xdata$x:00006D02                 db 0FFh
.xdata$x:00006D03                 db 0FFh
.xdata$x:00006D04                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00006D08 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00006D08                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00006D09                 db    5
.xdata$x:00006D0A                 db  93h ; 
.xdata$x:00006D0B                 db  19h
.xdata$x:00006D0C                 db    1
.xdata$x:00006D0D                 db    0
.xdata$x:00006D0E                 db    0
.xdata$x:00006D0F                 db    0
.xdata$x:00006D10                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00006D14                 db    0
.xdata$x:00006D15                 db    0
.xdata$x:00006D16                 db    0
.xdata$x:00006D17                 db    0
.xdata$x:00006D18                 db    0
.xdata$x:00006D19                 db    0
.xdata$x:00006D1A                 db    0
.xdata$x:00006D1B                 db    0
.xdata$x:00006D1C                 db    0
.xdata$x:00006D1D                 db    0
.xdata$x:00006D1E                 db    0
.xdata$x:00006D1F                 db    0
.xdata$x:00006D20                 db    0
.xdata$x:00006D21                 db    0
.xdata$x:00006D22                 db    0
.xdata$x:00006D23                 db    0
.xdata$x:00006D24                 db    0
.xdata$x:00006D25                 db    0
.xdata$x:00006D26                 db    0
.xdata$x:00006D27                 db    0
.xdata$x:00006D28                 db    0
.xdata$x:00006D29                 db    0
.xdata$x:00006D2A                 db    0
.xdata$x:00006D2B                 db    0
.xdata$x:00006D2B _xdata$x        ends
.xdata$x:00006D2B
.xdata$x:00006D2C ; ===========================================================================
.xdata$x:00006D2C
.xdata$x:00006D2C ; Segment type: Pure data
.xdata$x:00006D2C ; Segment permissions: Read
.xdata$x:00006D2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006D2C                 assume cs:_xdata$x
.xdata$x:00006D2C                 ;org 6D2Ch
.xdata$x:00006D2C ; COMDAT (pick associative to section at 40E0)
.xdata$x:00006D2C __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:00006D2C                                         ; DATA XREF: .xdata$x:00006D3Co
.xdata$x:00006D2D                 db 0FFh
.xdata$x:00006D2E                 db 0FFh
.xdata$x:00006D2F                 db 0FFh
.xdata$x:00006D30                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:00006D34 __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:00006D34                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:00006D35                 db    5
.xdata$x:00006D36                 db  93h ; 
.xdata$x:00006D37                 db  19h
.xdata$x:00006D38                 db    1
.xdata$x:00006D39                 db    0
.xdata$x:00006D3A                 db    0
.xdata$x:00006D3B                 db    0
.xdata$x:00006D3C                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:00006D40                 db    0
.xdata$x:00006D41                 db    0
.xdata$x:00006D42                 db    0
.xdata$x:00006D43                 db    0
.xdata$x:00006D44                 db    0
.xdata$x:00006D45                 db    0
.xdata$x:00006D46                 db    0
.xdata$x:00006D47                 db    0
.xdata$x:00006D48                 db    0
.xdata$x:00006D49                 db    0
.xdata$x:00006D4A                 db    0
.xdata$x:00006D4B                 db    0
.xdata$x:00006D4C                 db    0
.xdata$x:00006D4D                 db    0
.xdata$x:00006D4E                 db    0
.xdata$x:00006D4F                 db    0
.xdata$x:00006D50                 db    0
.xdata$x:00006D51                 db    0
.xdata$x:00006D52                 db    0
.xdata$x:00006D53                 db    0
.xdata$x:00006D54                 db    0
.xdata$x:00006D55                 db    0
.xdata$x:00006D56                 db    0
.xdata$x:00006D57                 db    0
.xdata$x:00006D57 _xdata$x        ends
.xdata$x:00006D57
.xdata$x:00006D58 ; ===========================================================================
.xdata$x:00006D58
.xdata$x:00006D58 ; Segment type: Pure data
.xdata$x:00006D58 ; Segment permissions: Read
.xdata$x:00006D58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006D58                 assume cs:_xdata$x
.xdata$x:00006D58                 ;org 6D58h
.xdata$x:00006D58 ; COMDAT (pick associative to section at 3F38)
.xdata$x:00006D58 __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:00006D58                                         ; DATA XREF: .xdata$x:00006D68o
.xdata$x:00006D59                 db 0FFh
.xdata$x:00006D5A                 db 0FFh
.xdata$x:00006D5B                 db 0FFh
.xdata$x:00006D5C                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:00006D60 __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:00006D60                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:00006D61                 db    5
.xdata$x:00006D62                 db  93h ; 
.xdata$x:00006D63                 db  19h
.xdata$x:00006D64                 db    1
.xdata$x:00006D65                 db    0
.xdata$x:00006D66                 db    0
.xdata$x:00006D67                 db    0
.xdata$x:00006D68                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:00006D6C                 db    0
.xdata$x:00006D6D                 db    0
.xdata$x:00006D6E                 db    0
.xdata$x:00006D6F                 db    0
.xdata$x:00006D70                 db    0
.xdata$x:00006D71                 db    0
.xdata$x:00006D72                 db    0
.xdata$x:00006D73                 db    0
.xdata$x:00006D74                 db    0
.xdata$x:00006D75                 db    0
.xdata$x:00006D76                 db    0
.xdata$x:00006D77                 db    0
.xdata$x:00006D78                 db    0
.xdata$x:00006D79                 db    0
.xdata$x:00006D7A                 db    0
.xdata$x:00006D7B                 db    0
.xdata$x:00006D7C                 db    0
.xdata$x:00006D7D                 db    0
.xdata$x:00006D7E                 db    0
.xdata$x:00006D7F                 db    0
.xdata$x:00006D80                 db    0
.xdata$x:00006D81                 db    0
.xdata$x:00006D82                 db    0
.xdata$x:00006D83                 db    0
.xdata$x:00006D83 _xdata$x        ends
.xdata$x:00006D83
.xdata$x:00006D84 ; ===========================================================================
.xdata$x:00006D84
.xdata$x:00006D84 ; Segment type: Pure data
.xdata$x:00006D84 ; Segment permissions: Read
.xdata$x:00006D84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006D84                 assume cs:_xdata$x
.xdata$x:00006D84                 ;org 6D84h
.xdata$x:00006D84 ; COMDAT (pick associative to section at 44A4)
.xdata$x:00006D84 __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:00006D84                                         ; DATA XREF: .xdata$x:00006D9Co
.xdata$x:00006D85                 db 0FFh
.xdata$x:00006D86                 db 0FFh
.xdata$x:00006D87                 db 0FFh
.xdata$x:00006D88                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:00006D8C                 db 0FFh
.xdata$x:00006D8D                 db 0FFh
.xdata$x:00006D8E                 db 0FFh
.xdata$x:00006D8F                 db 0FFh
.xdata$x:00006D90                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:00006D94 __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:00006D94                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:00006D95                 db    5
.xdata$x:00006D96                 db  93h ; 
.xdata$x:00006D97                 db  19h
.xdata$x:00006D98                 db    2
.xdata$x:00006D99                 db    0
.xdata$x:00006D9A                 db    0
.xdata$x:00006D9B                 db    0
.xdata$x:00006D9C                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:00006DA0                 db    0
.xdata$x:00006DA1                 db    0
.xdata$x:00006DA2                 db    0
.xdata$x:00006DA3                 db    0
.xdata$x:00006DA4                 db    0
.xdata$x:00006DA5                 db    0
.xdata$x:00006DA6                 db    0
.xdata$x:00006DA7                 db    0
.xdata$x:00006DA8                 db    0
.xdata$x:00006DA9                 db    0
.xdata$x:00006DAA                 db    0
.xdata$x:00006DAB                 db    0
.xdata$x:00006DAC                 db    0
.xdata$x:00006DAD                 db    0
.xdata$x:00006DAE                 db    0
.xdata$x:00006DAF                 db    0
.xdata$x:00006DB0                 db    0
.xdata$x:00006DB1                 db    0
.xdata$x:00006DB2                 db    0
.xdata$x:00006DB3                 db    0
.xdata$x:00006DB4                 db    0
.xdata$x:00006DB5                 db    0
.xdata$x:00006DB6                 db    0
.xdata$x:00006DB7                 db    0
.xdata$x:00006DB7 _xdata$x        ends
.xdata$x:00006DB7
.xdata$x:00006DB8 ; ===========================================================================
.xdata$x:00006DB8
.xdata$x:00006DB8 ; Segment type: Pure data
.xdata$x:00006DB8 ; Segment permissions: Read
.xdata$x:00006DB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006DB8                 assume cs:_xdata$x
.xdata$x:00006DB8                 ;org 6DB8h
.xdata$x:00006DB8 ; COMDAT (pick associative to section at 2C64)
.xdata$x:00006DB8 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00006DB8                                         ; DATA XREF: .xdata$x:00006DC8o
.xdata$x:00006DB9                 db 0FFh
.xdata$x:00006DBA                 db 0FFh
.xdata$x:00006DBB                 db 0FFh
.xdata$x:00006DBC                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00006DC0 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00006DC0                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00006DC1                 db    5
.xdata$x:00006DC2                 db  93h ; 
.xdata$x:00006DC3                 db  19h
.xdata$x:00006DC4                 db    1
.xdata$x:00006DC5                 db    0
.xdata$x:00006DC6                 db    0
.xdata$x:00006DC7                 db    0
.xdata$x:00006DC8                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00006DCC                 db    0
.xdata$x:00006DCD                 db    0
.xdata$x:00006DCE                 db    0
.xdata$x:00006DCF                 db    0
.xdata$x:00006DD0                 db    0
.xdata$x:00006DD1                 db    0
.xdata$x:00006DD2                 db    0
.xdata$x:00006DD3                 db    0
.xdata$x:00006DD4                 db    0
.xdata$x:00006DD5                 db    0
.xdata$x:00006DD6                 db    0
.xdata$x:00006DD7                 db    0
.xdata$x:00006DD8                 db    0
.xdata$x:00006DD9                 db    0
.xdata$x:00006DDA                 db    0
.xdata$x:00006DDB                 db    0
.xdata$x:00006DDC                 db    0
.xdata$x:00006DDD                 db    0
.xdata$x:00006DDE                 db    0
.xdata$x:00006DDF                 db    0
.xdata$x:00006DE0                 db    0
.xdata$x:00006DE1                 db    0
.xdata$x:00006DE2                 db    0
.xdata$x:00006DE3                 db    0
.xdata$x:00006DE3 _xdata$x        ends
.xdata$x:00006DE3
.xdata$x:00006DE4 ; ===========================================================================
.xdata$x:00006DE4
.xdata$x:00006DE4 ; Segment type: Pure data
.xdata$x:00006DE4 ; Segment permissions: Read
.xdata$x:00006DE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006DE4                 assume cs:_xdata$x
.xdata$x:00006DE4                 ;org 6DE4h
.xdata$x:00006DE4 ; COMDAT (pick associative to section at 39F4)
.xdata$x:00006DE4 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00006DE4                                         ; DATA XREF: .xdata$x:00006DF4o
.xdata$x:00006DE5                 db 0FFh
.xdata$x:00006DE6                 db 0FFh
.xdata$x:00006DE7                 db 0FFh
.xdata$x:00006DE8                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00006DEC __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00006DEC                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00006DED                 db    5
.xdata$x:00006DEE                 db  93h ; 
.xdata$x:00006DEF                 db  19h
.xdata$x:00006DF0                 db    1
.xdata$x:00006DF1                 db    0
.xdata$x:00006DF2                 db    0
.xdata$x:00006DF3                 db    0
.xdata$x:00006DF4                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00006DF8                 db    0
.xdata$x:00006DF9                 db    0
.xdata$x:00006DFA                 db    0
.xdata$x:00006DFB                 db    0
.xdata$x:00006DFC                 db    0
.xdata$x:00006DFD                 db    0
.xdata$x:00006DFE                 db    0
.xdata$x:00006DFF                 db    0
.xdata$x:00006E00                 db    0
.xdata$x:00006E01                 db    0
.xdata$x:00006E02                 db    0
.xdata$x:00006E03                 db    0
.xdata$x:00006E04                 db    0
.xdata$x:00006E05                 db    0
.xdata$x:00006E06                 db    0
.xdata$x:00006E07                 db    0
.xdata$x:00006E08                 db    0
.xdata$x:00006E09                 db    0
.xdata$x:00006E0A                 db    0
.xdata$x:00006E0B                 db    0
.xdata$x:00006E0C                 db    0
.xdata$x:00006E0D                 db    0
.xdata$x:00006E0E                 db    0
.xdata$x:00006E0F                 db    0
.xdata$x:00006E0F _xdata$x        ends
.xdata$x:00006E0F
.xdata$x:00006E10 ; ===========================================================================
.xdata$x:00006E10
.xdata$x:00006E10 ; Segment type: Pure data
.xdata$x:00006E10 ; Segment permissions: Read
.xdata$x:00006E10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006E10                 assume cs:_xdata$x
.xdata$x:00006E10                 ;org 6E10h
.xdata$x:00006E10 ; COMDAT (pick associative to section at 2B6C)
.xdata$x:00006E10 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00006E10                                         ; DATA XREF: .xdata$x:00006E20o
.xdata$x:00006E11                 db 0FFh
.xdata$x:00006E12                 db 0FFh
.xdata$x:00006E13                 db 0FFh
.xdata$x:00006E14                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00006E18 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00006E18                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00006E19                 db    5
.xdata$x:00006E1A                 db  93h ; 
.xdata$x:00006E1B                 db  19h
.xdata$x:00006E1C                 db    1
.xdata$x:00006E1D                 db    0
.xdata$x:00006E1E                 db    0
.xdata$x:00006E1F                 db    0
.xdata$x:00006E20                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00006E24                 db    0
.xdata$x:00006E25                 db    0
.xdata$x:00006E26                 db    0
.xdata$x:00006E27                 db    0
.xdata$x:00006E28                 db    0
.xdata$x:00006E29                 db    0
.xdata$x:00006E2A                 db    0
.xdata$x:00006E2B                 db    0
.xdata$x:00006E2C                 db    0
.xdata$x:00006E2D                 db    0
.xdata$x:00006E2E                 db    0
.xdata$x:00006E2F                 db    0
.xdata$x:00006E30                 db    0
.xdata$x:00006E31                 db    0
.xdata$x:00006E32                 db    0
.xdata$x:00006E33                 db    0
.xdata$x:00006E34                 db    0
.xdata$x:00006E35                 db    0
.xdata$x:00006E36                 db    0
.xdata$x:00006E37                 db    0
.xdata$x:00006E38                 db    0
.xdata$x:00006E39                 db    0
.xdata$x:00006E3A                 db    0
.xdata$x:00006E3B                 db    0
.xdata$x:00006E3B _xdata$x        ends
.xdata$x:00006E3B
.xdata$x:00006E3C ; ===========================================================================
.xdata$x:00006E3C
.xdata$x:00006E3C ; Segment type: Pure data
.xdata$x:00006E3C ; Segment permissions: Read
.xdata$x:00006E3C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006E3C                 assume cs:_xdata$x
.xdata$x:00006E3C                 ;org 6E3Ch
.xdata$x:00006E3C ; COMDAT (pick associative to section at 3904)
.xdata$x:00006E3C __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00006E3C                                         ; DATA XREF: .xdata$x:00006E4Co
.xdata$x:00006E3D                 db 0FFh
.xdata$x:00006E3E                 db 0FFh
.xdata$x:00006E3F                 db 0FFh
.xdata$x:00006E40                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00006E44 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00006E44                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00006E45                 db    5
.xdata$x:00006E46                 db  93h ; 
.xdata$x:00006E47                 db  19h
.xdata$x:00006E48                 db    1
.xdata$x:00006E49                 db    0
.xdata$x:00006E4A                 db    0
.xdata$x:00006E4B                 db    0
.xdata$x:00006E4C                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00006E50                 db    0
.xdata$x:00006E51                 db    0
.xdata$x:00006E52                 db    0
.xdata$x:00006E53                 db    0
.xdata$x:00006E54                 db    0
.xdata$x:00006E55                 db    0
.xdata$x:00006E56                 db    0
.xdata$x:00006E57                 db    0
.xdata$x:00006E58                 db    0
.xdata$x:00006E59                 db    0
.xdata$x:00006E5A                 db    0
.xdata$x:00006E5B                 db    0
.xdata$x:00006E5C                 db    0
.xdata$x:00006E5D                 db    0
.xdata$x:00006E5E                 db    0
.xdata$x:00006E5F                 db    0
.xdata$x:00006E60                 db    0
.xdata$x:00006E61                 db    0
.xdata$x:00006E62                 db    0
.xdata$x:00006E63                 db    0
.xdata$x:00006E64                 db    0
.xdata$x:00006E65                 db    0
.xdata$x:00006E66                 db    0
.xdata$x:00006E67                 db    0
.xdata$x:00006E67 _xdata$x        ends
.xdata$x:00006E67
.xdata$x:00006E68 ; ===========================================================================
.xdata$x:00006E68
.xdata$x:00006E68 ; Segment type: Pure data
.xdata$x:00006E68 ; Segment permissions: Read
.xdata$x:00006E68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006E68                 assume cs:_xdata$x
.xdata$x:00006E68                 ;org 6E68h
.xdata$x:00006E68 ; COMDAT (pick associative to section at 3088)
.xdata$x:00006E68 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00006E68                                         ; DATA XREF: .xdata$x:00006E78o
.xdata$x:00006E69                 db 0FFh
.xdata$x:00006E6A                 db 0FFh
.xdata$x:00006E6B                 db 0FFh
.xdata$x:00006E6C                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00006E70 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00006E70                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00006E71                 db    5
.xdata$x:00006E72                 db  93h ; 
.xdata$x:00006E73                 db  19h
.xdata$x:00006E74                 db    1
.xdata$x:00006E75                 db    0
.xdata$x:00006E76                 db    0
.xdata$x:00006E77                 db    0
.xdata$x:00006E78                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00006E7C                 db    0
.xdata$x:00006E7D                 db    0
.xdata$x:00006E7E                 db    0
.xdata$x:00006E7F                 db    0
.xdata$x:00006E80                 db    0
.xdata$x:00006E81                 db    0
.xdata$x:00006E82                 db    0
.xdata$x:00006E83                 db    0
.xdata$x:00006E84                 db    0
.xdata$x:00006E85                 db    0
.xdata$x:00006E86                 db    0
.xdata$x:00006E87                 db    0
.xdata$x:00006E88                 db    0
.xdata$x:00006E89                 db    0
.xdata$x:00006E8A                 db    0
.xdata$x:00006E8B                 db    0
.xdata$x:00006E8C                 db    0
.xdata$x:00006E8D                 db    0
.xdata$x:00006E8E                 db    0
.xdata$x:00006E8F                 db    0
.xdata$x:00006E90                 db    0
.xdata$x:00006E91                 db    0
.xdata$x:00006E92                 db    0
.xdata$x:00006E93                 db    0
.xdata$x:00006E93 _xdata$x        ends
.xdata$x:00006E93
.xdata$x:00006E94 ; ===========================================================================
.xdata$x:00006E94
.xdata$x:00006E94 ; Segment type: Pure data
.xdata$x:00006E94 ; Segment permissions: Read
.xdata$x:00006E94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006E94                 assume cs:_xdata$x
.xdata$x:00006E94                 ;org 6E94h
.xdata$x:00006E94 ; COMDAT (pick associative to section at 3C2C)
.xdata$x:00006E94 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00006E94                                         ; DATA XREF: .xdata$x:00006EA4o
.xdata$x:00006E95                 db 0FFh
.xdata$x:00006E96                 db 0FFh
.xdata$x:00006E97                 db 0FFh
.xdata$x:00006E98                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00006E9C __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00006E9C                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00006E9D                 db    5
.xdata$x:00006E9E                 db  93h ; 
.xdata$x:00006E9F                 db  19h
.xdata$x:00006EA0                 db    1
.xdata$x:00006EA1                 db    0
.xdata$x:00006EA2                 db    0
.xdata$x:00006EA3                 db    0
.xdata$x:00006EA4                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00006EA8                 align 20h
.xdata$x:00006EA8 _xdata$x        ends
.xdata$x:00006EA8
.xdata$x:00006EC0 ; ===========================================================================
.xdata$x:00006EC0
.xdata$x:00006EC0 ; Segment type: Pure data
.xdata$x:00006EC0 ; Segment permissions: Read
.xdata$x:00006EC0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006EC0                 assume cs:_xdata$x
.xdata$x:00006EC0                 ;org 6EC0h
.xdata$x:00006EC0 ; COMDAT (pick associative to section at 4718)
.xdata$x:00006EC0 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00006EC0                                         ; DATA XREF: .xdata$x:00006F48o
.xdata$x:00006EC1                 db    0
.xdata$x:00006EC2                 db    0
.xdata$x:00006EC3                 db    0
.xdata$x:00006EC4                 db    0
.xdata$x:00006EC5                 db    0
.xdata$x:00006EC6                 db    0
.xdata$x:00006EC7                 db    0
.xdata$x:00006EC8                 db    0
.xdata$x:00006EC9                 db    0
.xdata$x:00006ECA                 db    0
.xdata$x:00006ECB                 db    0
.xdata$x:00006ECC                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00006ED0 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00006ED0                                         ; DATA XREF: .xdata$x:00006F34o
.xdata$x:00006ED1                 db    0
.xdata$x:00006ED2                 db    0
.xdata$x:00006ED3                 db    0
.xdata$x:00006ED4                 db    0
.xdata$x:00006ED5                 db    0
.xdata$x:00006ED6                 db    0
.xdata$x:00006ED7                 db    0
.xdata$x:00006ED8                 db    0
.xdata$x:00006ED9                 db    0
.xdata$x:00006EDA                 db    0
.xdata$x:00006EDB                 db    0
.xdata$x:00006EDC                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00006EE0 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00006EE0                                         ; DATA XREF: .xdata$x:00006F08o
.xdata$x:00006EE1                 db 0FFh
.xdata$x:00006EE2                 db 0FFh
.xdata$x:00006EE3                 db 0FFh
.xdata$x:00006EE4                 db    0
.xdata$x:00006EE5                 db    0
.xdata$x:00006EE6                 db    0
.xdata$x:00006EE7                 db    0
.xdata$x:00006EE8                 db 0FFh
.xdata$x:00006EE9                 db 0FFh
.xdata$x:00006EEA                 db 0FFh
.xdata$x:00006EEB                 db 0FFh
.xdata$x:00006EEC                 db    0
.xdata$x:00006EED                 db    0
.xdata$x:00006EEE                 db    0
.xdata$x:00006EEF                 db    0
.xdata$x:00006EF0                 db    1
.xdata$x:00006EF1                 db    0
.xdata$x:00006EF2                 db    0
.xdata$x:00006EF3                 db    0
.xdata$x:00006EF4                 db    0
.xdata$x:00006EF5                 db    0
.xdata$x:00006EF6                 db    0
.xdata$x:00006EF7                 db    0
.xdata$x:00006EF8                 db    1
.xdata$x:00006EF9                 db    0
.xdata$x:00006EFA                 db    0
.xdata$x:00006EFB                 db    0
.xdata$x:00006EFC                 db    0
.xdata$x:00006EFD                 db    0
.xdata$x:00006EFE                 db    0
.xdata$x:00006EFF                 db    0
.xdata$x:00006F00 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00006F00                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00006F01                 db    5
.xdata$x:00006F02                 db  93h ; 
.xdata$x:00006F03                 db  19h
.xdata$x:00006F04                 db    4
.xdata$x:00006F05                 db    0
.xdata$x:00006F06                 db    0
.xdata$x:00006F07                 db    0
.xdata$x:00006F08                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00006F0C                 db    2
.xdata$x:00006F0D                 db    0
.xdata$x:00006F0E                 db    0
.xdata$x:00006F0F                 db    0
.xdata$x:00006F10                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00006F14                 db    0
.xdata$x:00006F15                 db    0
.xdata$x:00006F16                 db    0
.xdata$x:00006F17                 db    0
.xdata$x:00006F18                 db    0
.xdata$x:00006F19                 db    0
.xdata$x:00006F1A                 db    0
.xdata$x:00006F1B                 db    0
.xdata$x:00006F1C                 db    0
.xdata$x:00006F1D                 db    0
.xdata$x:00006F1E                 db    0
.xdata$x:00006F1F                 db    0
.xdata$x:00006F20                 db    0
.xdata$x:00006F21                 db    0
.xdata$x:00006F22                 db    0
.xdata$x:00006F23                 db    0
.xdata$x:00006F24 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00006F24                                         ; DATA XREF: .xdata$x:00006F10o
.xdata$x:00006F25                 db    0
.xdata$x:00006F26                 db    0
.xdata$x:00006F27                 db    0
.xdata$x:00006F28                 db    2
.xdata$x:00006F29                 db    0
.xdata$x:00006F2A                 db    0
.xdata$x:00006F2B                 db    0
.xdata$x:00006F2C                 db    3
.xdata$x:00006F2D                 db    0
.xdata$x:00006F2E                 db    0
.xdata$x:00006F2F                 db    0
.xdata$x:00006F30                 db    1
.xdata$x:00006F31                 db    0
.xdata$x:00006F32                 db    0
.xdata$x:00006F33                 db    0
.xdata$x:00006F34                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00006F38                 align 10h
.xdata$x:00006F40                 db    3
.xdata$x:00006F41                 db    0
.xdata$x:00006F42                 db    0
.xdata$x:00006F43                 db    0
.xdata$x:00006F44                 db    1
.xdata$x:00006F45                 db    0
.xdata$x:00006F46                 db    0
.xdata$x:00006F47                 db    0
.xdata$x:00006F48                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00006F48 _xdata$x        ends
.xdata$x:00006F48
.xdata$x:00006F4C ; ===========================================================================
.xdata$x:00006F4C
.xdata$x:00006F4C ; Segment type: Pure data
.xdata$x:00006F4C ; Segment permissions: Read
.xdata$x:00006F4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006F4C                 assume cs:_xdata$x
.xdata$x:00006F4C                 ;org 6F4Ch
.xdata$x:00006F4C ; COMDAT (pick associative to section at 3678)
.xdata$x:00006F4C __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00006F4C                                         ; DATA XREF: .xdata$x:00006F5Co
.xdata$x:00006F4D                 db 0FFh
.xdata$x:00006F4E                 db 0FFh
.xdata$x:00006F4F                 db 0FFh
.xdata$x:00006F50                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00006F54 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00006F54                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00006F55                 db    5
.xdata$x:00006F56                 db  93h ; 
.xdata$x:00006F57                 db  19h
.xdata$x:00006F58                 db    1
.xdata$x:00006F59                 db    0
.xdata$x:00006F5A                 db    0
.xdata$x:00006F5B                 db    0
.xdata$x:00006F5C                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00006F60                 db    0
.xdata$x:00006F61                 db    0
.xdata$x:00006F62                 db    0
.xdata$x:00006F63                 db    0
.xdata$x:00006F64                 db    0
.xdata$x:00006F65                 db    0
.xdata$x:00006F66                 db    0
.xdata$x:00006F67                 db    0
.xdata$x:00006F68                 db    0
.xdata$x:00006F69                 db    0
.xdata$x:00006F6A                 db    0
.xdata$x:00006F6B                 db    0
.xdata$x:00006F6C                 db    0
.xdata$x:00006F6D                 db    0
.xdata$x:00006F6E                 db    0
.xdata$x:00006F6F                 db    0
.xdata$x:00006F70                 db    0
.xdata$x:00006F71                 db    0
.xdata$x:00006F72                 db    0
.xdata$x:00006F73                 db    0
.xdata$x:00006F74                 db    0
.xdata$x:00006F75                 db    0
.xdata$x:00006F76                 db    0
.xdata$x:00006F77                 db    0
.xdata$x:00006F77 _xdata$x        ends
.xdata$x:00006F77
.xdata$x:00006F78 ; ===========================================================================
.xdata$x:00006F78
.xdata$x:00006F78 ; Segment type: Pure data
.xdata$x:00006F78 ; Segment permissions: Read
.xdata$x:00006F78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006F78                 assume cs:_xdata$x
.xdata$x:00006F78                 ;org 6F78h
.xdata$x:00006F78 ; COMDAT (pick associative to section at 666C)
.xdata$x:00006F78 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00006F78                                         ; DATA XREF: .xdata$x:00006F88o
.xdata$x:00006F79                 db 0FFh
.xdata$x:00006F7A                 db 0FFh
.xdata$x:00006F7B                 db 0FFh
.xdata$x:00006F7C                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00006F80 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00006F80                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00006F81                 db    5
.xdata$x:00006F82                 db  93h ; 
.xdata$x:00006F83                 db  19h
.xdata$x:00006F84                 db    1
.xdata$x:00006F85                 db    0
.xdata$x:00006F86                 db    0
.xdata$x:00006F87                 db    0
.xdata$x:00006F88                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00006F8C                 db    0
.xdata$x:00006F8D                 db    0
.xdata$x:00006F8E                 db    0
.xdata$x:00006F8F                 db    0
.xdata$x:00006F90                 db    0
.xdata$x:00006F91                 db    0
.xdata$x:00006F92                 db    0
.xdata$x:00006F93                 db    0
.xdata$x:00006F94                 db    0
.xdata$x:00006F95                 db    0
.xdata$x:00006F96                 db    0
.xdata$x:00006F97                 db    0
.xdata$x:00006F98                 db    0
.xdata$x:00006F99                 db    0
.xdata$x:00006F9A                 db    0
.xdata$x:00006F9B                 db    0
.xdata$x:00006F9C                 db    0
.xdata$x:00006F9D                 db    0
.xdata$x:00006F9E                 db    0
.xdata$x:00006F9F                 db    0
.xdata$x:00006FA0                 db    0
.xdata$x:00006FA1                 db    0
.xdata$x:00006FA2                 db    0
.xdata$x:00006FA3                 db    0
.xdata$x:00006FA3 _xdata$x        ends
.xdata$x:00006FA3
.xdata$x:00006FA4 ; ===========================================================================
.xdata$x:00006FA4
.xdata$x:00006FA4 ; Segment type: Pure data
.xdata$x:00006FA4 ; Segment permissions: Read
.xdata$x:00006FA4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006FA4                 assume cs:_xdata$x
.xdata$x:00006FA4                 ;org 6FA4h
.xdata$x:00006FA4 ; COMDAT (pick associative to section at 3E58)
.xdata$x:00006FA4 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00006FA4                                         ; DATA XREF: .xdata$x:00006FB4o
.xdata$x:00006FA5                 db 0FFh
.xdata$x:00006FA6                 db 0FFh
.xdata$x:00006FA7                 db 0FFh
.xdata$x:00006FA8                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00006FAC __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00006FAC                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00006FAD                 db    5
.xdata$x:00006FAE                 db  93h ; 
.xdata$x:00006FAF                 db  19h
.xdata$x:00006FB0                 db    1
.xdata$x:00006FB1                 db    0
.xdata$x:00006FB2                 db    0
.xdata$x:00006FB3                 db    0
.xdata$x:00006FB4                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00006FB8                 db    0
.xdata$x:00006FB9                 db    0
.xdata$x:00006FBA                 db    0
.xdata$x:00006FBB                 db    0
.xdata$x:00006FBC                 db    0
.xdata$x:00006FBD                 db    0
.xdata$x:00006FBE                 db    0
.xdata$x:00006FBF                 db    0
.xdata$x:00006FC0                 db    0
.xdata$x:00006FC1                 db    0
.xdata$x:00006FC2                 db    0
.xdata$x:00006FC3                 db    0
.xdata$x:00006FC4                 db    0
.xdata$x:00006FC5                 db    0
.xdata$x:00006FC6                 db    0
.xdata$x:00006FC7                 db    0
.xdata$x:00006FC8                 db    0
.xdata$x:00006FC9                 db    0
.xdata$x:00006FCA                 db    0
.xdata$x:00006FCB                 db    0
.xdata$x:00006FCC                 db    0
.xdata$x:00006FCD                 db    0
.xdata$x:00006FCE                 db    0
.xdata$x:00006FCF                 db    0
.xdata$x:00006FCF _xdata$x        ends
.xdata$x:00006FCF
.xdata$x:00006FD0 ; ===========================================================================
.xdata$x:00006FD0
.xdata$x:00006FD0 ; Segment type: Pure data
.xdata$x:00006FD0 ; Segment permissions: Read
.xdata$x:00006FD0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006FD0                 assume cs:_xdata$x
.xdata$x:00006FD0                 ;org 6FD0h
.xdata$x:00006FD0 ; COMDAT (pick associative to section at 36F4)
.xdata$x:00006FD0 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00006FD0                                         ; DATA XREF: .xdata$x:00006FE0o
.xdata$x:00006FD1                 db 0FFh
.xdata$x:00006FD2                 db 0FFh
.xdata$x:00006FD3                 db 0FFh
.xdata$x:00006FD4                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00006FD8 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00006FD8                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00006FD9                 db    5
.xdata$x:00006FDA                 db  93h ; 
.xdata$x:00006FDB                 db  19h
.xdata$x:00006FDC                 db    1
.xdata$x:00006FDD                 db    0
.xdata$x:00006FDE                 db    0
.xdata$x:00006FDF                 db    0
.xdata$x:00006FE0                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00006FE4                 db    0
.xdata$x:00006FE5                 db    0
.xdata$x:00006FE6                 db    0
.xdata$x:00006FE7                 db    0
.xdata$x:00006FE8                 db    0
.xdata$x:00006FE9                 db    0
.xdata$x:00006FEA                 db    0
.xdata$x:00006FEB                 db    0
.xdata$x:00006FEC                 db    0
.xdata$x:00006FED                 db    0
.xdata$x:00006FEE                 db    0
.xdata$x:00006FEF                 db    0
.xdata$x:00006FF0                 db    0
.xdata$x:00006FF1                 db    0
.xdata$x:00006FF2                 db    0
.xdata$x:00006FF3                 db    0
.xdata$x:00006FF4                 db    0
.xdata$x:00006FF5                 db    0
.xdata$x:00006FF6                 db    0
.xdata$x:00006FF7                 db    0
.xdata$x:00006FF8                 db    0
.xdata$x:00006FF9                 db    0
.xdata$x:00006FFA                 db    0
.xdata$x:00006FFB                 db    0
.xdata$x:00006FFB _xdata$x        ends
.xdata$x:00006FFB
.xdata$x:00006FFC ; ===========================================================================
.xdata$x:00006FFC
.xdata$x:00006FFC ; Segment type: Pure data
.xdata$x:00006FFC ; Segment permissions: Read
.xdata$x:00006FFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006FFC                 assume cs:_xdata$x
.xdata$x:00006FFC                 ;org 6FFCh
.xdata$x:00006FFC ; COMDAT (pick associative to section at 6724)
.xdata$x:00006FFC __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00006FFC                                         ; DATA XREF: .xdata$x:0000700Co
.xdata$x:00006FFD                 db 0FFh
.xdata$x:00006FFE                 db 0FFh
.xdata$x:00006FFF                 db 0FFh
.xdata$x:00007000                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00007004 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00007004                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00007005                 db    5
.xdata$x:00007006                 db  93h ; 
.xdata$x:00007007                 db  19h
.xdata$x:00007008                 db    1
.xdata$x:00007009                 db    0
.xdata$x:0000700A                 db    0
.xdata$x:0000700B                 db    0
.xdata$x:0000700C                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00007010                 db    0
.xdata$x:00007011                 db    0
.xdata$x:00007012                 db    0
.xdata$x:00007013                 db    0
.xdata$x:00007014                 db    0
.xdata$x:00007015                 db    0
.xdata$x:00007016                 db    0
.xdata$x:00007017                 db    0
.xdata$x:00007018                 db    0
.xdata$x:00007019                 db    0
.xdata$x:0000701A                 db    0
.xdata$x:0000701B                 db    0
.xdata$x:0000701C                 db    0
.xdata$x:0000701D                 db    0
.xdata$x:0000701E                 db    0
.xdata$x:0000701F                 db    0
.xdata$x:00007020                 db    0
.xdata$x:00007021                 db    0
.xdata$x:00007022                 db    0
.xdata$x:00007023                 db    0
.xdata$x:00007024                 db    0
.xdata$x:00007025                 db    0
.xdata$x:00007026                 db    0
.xdata$x:00007027                 db    0
.xdata$x:00007027 _xdata$x        ends
.xdata$x:00007027
.xdata$x:00007028 ; ===========================================================================
.xdata$x:00007028
.xdata$x:00007028 ; Segment type: Pure data
.xdata$x:00007028 ; Segment permissions: Read
.xdata$x:00007028 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007028                 assume cs:_xdata$x
.xdata$x:00007028                 ;org 7028h
.xdata$x:00007028 ; COMDAT (pick associative to section at 3EC8)
.xdata$x:00007028 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00007028                                         ; DATA XREF: .xdata$x:00007038o
.xdata$x:00007029                 db 0FFh
.xdata$x:0000702A                 db 0FFh
.xdata$x:0000702B                 db 0FFh
.xdata$x:0000702C                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00007030 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00007030                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00007031                 db    5
.xdata$x:00007032                 db  93h ; 
.xdata$x:00007033                 db  19h
.xdata$x:00007034                 db    1
.xdata$x:00007035                 db    0
.xdata$x:00007036                 db    0
.xdata$x:00007037                 db    0
.xdata$x:00007038                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:0000703C                 db    0
.xdata$x:0000703D                 db    0
.xdata$x:0000703E                 db    0
.xdata$x:0000703F                 db    0
.xdata$x:00007040                 db    0
.xdata$x:00007041                 db    0
.xdata$x:00007042                 db    0
.xdata$x:00007043                 db    0
.xdata$x:00007044                 db    0
.xdata$x:00007045                 db    0
.xdata$x:00007046                 db    0
.xdata$x:00007047                 db    0
.xdata$x:00007048                 db    0
.xdata$x:00007049                 db    0
.xdata$x:0000704A                 db    0
.xdata$x:0000704B                 db    0
.xdata$x:0000704C                 db    0
.xdata$x:0000704D                 db    0
.xdata$x:0000704E                 db    0
.xdata$x:0000704F                 db    0
.xdata$x:00007050                 db    0
.xdata$x:00007051                 db    0
.xdata$x:00007052                 db    0
.xdata$x:00007053                 db    0
.xdata$x:00007053 _xdata$x        ends
.xdata$x:00007053
.xdata$x:00007054 ; ===========================================================================
.xdata$x:00007054
.xdata$x:00007054 ; Segment type: Pure data
.xdata$x:00007054 ; Segment permissions: Read
.xdata$x:00007054 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007054                 assume cs:_xdata$x
.xdata$x:00007054                 ;org 7054h
.xdata$x:00007054 ; COMDAT (pick associative to section at 37C4)
.xdata$x:00007054 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00007054                                         ; DATA XREF: .xdata$x:00007064o
.xdata$x:00007055                 db 0FFh
.xdata$x:00007056                 db 0FFh
.xdata$x:00007057                 db 0FFh
.xdata$x:00007058                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:0000705C __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000705C                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:0000705D                 db    5
.xdata$x:0000705E                 db  93h ; 
.xdata$x:0000705F                 db  19h
.xdata$x:00007060                 db    1
.xdata$x:00007061                 db    0
.xdata$x:00007062                 db    0
.xdata$x:00007063                 db    0
.xdata$x:00007064                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00007068                 align 20h
.xdata$x:00007068 _xdata$x        ends
.xdata$x:00007068
.xdata$x:00007080 ; ===========================================================================
.xdata$x:00007080
.xdata$x:00007080 ; Segment type: Pure data
.xdata$x:00007080 ; Segment permissions: Read
.xdata$x:00007080 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007080                 assume cs:_xdata$x
.xdata$x:00007080                 ;org 7080h
.xdata$x:00007080 ; COMDAT (pick associative to section at 67E8)
.xdata$x:00007080 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00007080                                         ; DATA XREF: .xdata$x:00007090o
.xdata$x:00007081                 db 0FFh
.xdata$x:00007082                 db 0FFh
.xdata$x:00007083                 db 0FFh
.xdata$x:00007084                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00007088 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00007088                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00007089                 db    5
.xdata$x:0000708A                 db  93h ; 
.xdata$x:0000708B                 db  19h
.xdata$x:0000708C                 db    1
.xdata$x:0000708D                 db    0
.xdata$x:0000708E                 db    0
.xdata$x:0000708F                 db    0
.xdata$x:00007090                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00007094                 db    0
.xdata$x:00007095                 db    0
.xdata$x:00007096                 db    0
.xdata$x:00007097                 db    0
.xdata$x:00007098                 db    0
.xdata$x:00007099                 db    0
.xdata$x:0000709A                 db    0
.xdata$x:0000709B                 db    0
.xdata$x:0000709C                 db    0
.xdata$x:0000709D                 db    0
.xdata$x:0000709E                 db    0
.xdata$x:0000709F                 db    0
.xdata$x:000070A0                 db    0
.xdata$x:000070A1                 db    0
.xdata$x:000070A2                 db    0
.xdata$x:000070A3                 db    0
.xdata$x:000070A4                 db    0
.xdata$x:000070A5                 db    0
.xdata$x:000070A6                 db    0
.xdata$x:000070A7                 db    0
.xdata$x:000070A8                 db    0
.xdata$x:000070A9                 db    0
.xdata$x:000070AA                 db    0
.xdata$x:000070AB                 db    0
.xdata$x:000070AB _xdata$x        ends
.xdata$x:000070AB
.xdata$x:000070AC ; ===========================================================================
.xdata$x:000070AC
.xdata$x:000070AC ; Segment type: Pure data
.xdata$x:000070AC ; Segment permissions: Read
.xdata$x:000070AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000070AC                 assume cs:_xdata$x
.xdata$x:000070AC                 ;org 70ACh
.xdata$x:000070AC ; COMDAT (pick associative to section at 3FBC)
.xdata$x:000070AC __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000070AC                                         ; DATA XREF: .xdata$x:000070BCo
.xdata$x:000070AD                 db 0FFh
.xdata$x:000070AE                 db 0FFh
.xdata$x:000070AF                 db 0FFh
.xdata$x:000070B0                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:000070B4 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000070B4                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:000070B5                 db    5
.xdata$x:000070B6                 db  93h ; 
.xdata$x:000070B7                 db  19h
.xdata$x:000070B8                 db    1
.xdata$x:000070B9                 db    0
.xdata$x:000070BA                 db    0
.xdata$x:000070BB                 db    0
.xdata$x:000070BC                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:000070C0                 db    0
.xdata$x:000070C1                 db    0
.xdata$x:000070C2                 db    0
.xdata$x:000070C3                 db    0
.xdata$x:000070C4                 db    0
.xdata$x:000070C5                 db    0
.xdata$x:000070C6                 db    0
.xdata$x:000070C7                 db    0
.xdata$x:000070C8                 db    0
.xdata$x:000070C9                 db    0
.xdata$x:000070CA                 db    0
.xdata$x:000070CB                 db    0
.xdata$x:000070CC                 db    0
.xdata$x:000070CD                 db    0
.xdata$x:000070CE                 db    0
.xdata$x:000070CF                 db    0
.xdata$x:000070D0                 db    0
.xdata$x:000070D1                 db    0
.xdata$x:000070D2                 db    0
.xdata$x:000070D3                 db    0
.xdata$x:000070D4                 db    0
.xdata$x:000070D5                 db    0
.xdata$x:000070D6                 db    0
.xdata$x:000070D7                 db    0
.xdata$x:000070D7 _xdata$x        ends
.xdata$x:000070D7
.xdata$x:000070D8 ; ===========================================================================
.xdata$x:000070D8
.xdata$x:000070D8 ; Segment type: Pure data
.xdata$x:000070D8 ; Segment permissions: Read
.xdata$x:000070D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000070D8                 assume cs:_xdata$x
.xdata$x:000070D8                 ;org 70D8h
.xdata$x:000070D8 ; COMDAT (pick associative to section at 2CEC)
.xdata$x:000070D8 __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000070D8                                         ; DATA XREF: .xdata$x:000070E8o
.xdata$x:000070D9                 db 0FFh
.xdata$x:000070DA                 db 0FFh
.xdata$x:000070DB                 db 0FFh
.xdata$x:000070DC                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:000070E0 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000070E0                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:000070E1                 db    5
.xdata$x:000070E2                 db  93h ; 
.xdata$x:000070E3                 db  19h
.xdata$x:000070E4                 db    1
.xdata$x:000070E5                 db    0
.xdata$x:000070E6                 db    0
.xdata$x:000070E7                 db    0
.xdata$x:000070E8                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:000070EC                 db    0
.xdata$x:000070ED                 db    0
.xdata$x:000070EE                 db    0
.xdata$x:000070EF                 db    0
.xdata$x:000070F0                 db    0
.xdata$x:000070F1                 db    0
.xdata$x:000070F2                 db    0
.xdata$x:000070F3                 db    0
.xdata$x:000070F4                 db    0
.xdata$x:000070F5                 db    0
.xdata$x:000070F6                 db    0
.xdata$x:000070F7                 db    0
.xdata$x:000070F8                 db    0
.xdata$x:000070F9                 db    0
.xdata$x:000070FA                 db    0
.xdata$x:000070FB                 db    0
.xdata$x:000070FC                 db    0
.xdata$x:000070FD                 db    0
.xdata$x:000070FE                 db    0
.xdata$x:000070FF                 db    0
.xdata$x:00007100                 db    0
.xdata$x:00007101                 db    0
.xdata$x:00007102                 db    0
.xdata$x:00007103                 db    0
.xdata$x:00007103 _xdata$x        ends
.xdata$x:00007103
.xdata$x:00007104 ; ===========================================================================
.xdata$x:00007104
.xdata$x:00007104 ; Segment type: Pure data
.xdata$x:00007104 ; Segment permissions: Read
.xdata$x:00007104 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007104                 assume cs:_xdata$x
.xdata$x:00007104                 ;org 7104h
.xdata$x:00007104 ; COMDAT (pick associative to section at 3A64)
.xdata$x:00007104 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00007104                                         ; DATA XREF: .xdata$x:00007114o
.xdata$x:00007105                 db 0FFh
.xdata$x:00007106                 db 0FFh
.xdata$x:00007107                 db 0FFh
.xdata$x:00007108                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000710C __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000710C                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000710D                 db    5
.xdata$x:0000710E                 db  93h ; 
.xdata$x:0000710F                 db  19h
.xdata$x:00007110                 db    1
.xdata$x:00007111                 db    0
.xdata$x:00007112                 db    0
.xdata$x:00007113                 db    0
.xdata$x:00007114                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00007118                 db    0
.xdata$x:00007119                 db    0
.xdata$x:0000711A                 db    0
.xdata$x:0000711B                 db    0
.xdata$x:0000711C                 db    0
.xdata$x:0000711D                 db    0
.xdata$x:0000711E                 db    0
.xdata$x:0000711F                 db    0
.xdata$x:00007120                 db    0
.xdata$x:00007121                 db    0
.xdata$x:00007122                 db    0
.xdata$x:00007123                 db    0
.xdata$x:00007124                 db    0
.xdata$x:00007125                 db    0
.xdata$x:00007126                 db    0
.xdata$x:00007127                 db    0
.xdata$x:00007128                 db    0
.xdata$x:00007129                 db    0
.xdata$x:0000712A                 db    0
.xdata$x:0000712B                 db    0
.xdata$x:0000712C                 db    0
.xdata$x:0000712D                 db    0
.xdata$x:0000712E                 db    0
.xdata$x:0000712F                 db    0
.xdata$x:0000712F _xdata$x        ends
.xdata$x:0000712F
.xdata$x:00007130 ; ===========================================================================
.xdata$x:00007130
.xdata$x:00007130 ; Segment type: Pure data
.xdata$x:00007130 ; Segment permissions: Read
.xdata$x:00007130 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007130                 assume cs:_xdata$x
.xdata$x:00007130                 ;org 7130h
.xdata$x:00007130 ; COMDAT (pick associative to section at 2BE8)
.xdata$x:00007130 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:00007130                                         ; DATA XREF: .xdata$x:00007140o
.xdata$x:00007131                 db 0FFh
.xdata$x:00007132                 db 0FFh
.xdata$x:00007133                 db 0FFh
.xdata$x:00007134                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:00007138 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:00007138                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:00007139                 db    5
.xdata$x:0000713A                 db  93h ; 
.xdata$x:0000713B                 db  19h
.xdata$x:0000713C                 db    1
.xdata$x:0000713D                 db    0
.xdata$x:0000713E                 db    0
.xdata$x:0000713F                 db    0
.xdata$x:00007140                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:00007144                 db    0
.xdata$x:00007145                 db    0
.xdata$x:00007146                 db    0
.xdata$x:00007147                 db    0
.xdata$x:00007148                 db    0
.xdata$x:00007149                 db    0
.xdata$x:0000714A                 db    0
.xdata$x:0000714B                 db    0
.xdata$x:0000714C                 db    0
.xdata$x:0000714D                 db    0
.xdata$x:0000714E                 db    0
.xdata$x:0000714F                 db    0
.xdata$x:00007150                 db    0
.xdata$x:00007151                 db    0
.xdata$x:00007152                 db    0
.xdata$x:00007153                 db    0
.xdata$x:00007154                 db    0
.xdata$x:00007155                 db    0
.xdata$x:00007156                 db    0
.xdata$x:00007157                 db    0
.xdata$x:00007158                 db    0
.xdata$x:00007159                 db    0
.xdata$x:0000715A                 db    0
.xdata$x:0000715B                 db    0
.xdata$x:0000715B _xdata$x        ends
.xdata$x:0000715B
.xdata$x:0000715C ; ===========================================================================
.xdata$x:0000715C
.xdata$x:0000715C ; Segment type: Pure data
.xdata$x:0000715C ; Segment permissions: Read
.xdata$x:0000715C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000715C                 assume cs:_xdata$x
.xdata$x:0000715C                 ;org 715Ch
.xdata$x:0000715C ; COMDAT (pick associative to section at 397C)
.xdata$x:0000715C __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000715C                                         ; DATA XREF: .xdata$x:0000716Co
.xdata$x:0000715D                 db 0FFh
.xdata$x:0000715E                 db 0FFh
.xdata$x:0000715F                 db 0FFh
.xdata$x:00007160                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00007164 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00007164                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00007165                 db    5
.xdata$x:00007166                 db  93h ; 
.xdata$x:00007167                 db  19h
.xdata$x:00007168                 db    1
.xdata$x:00007169                 db    0
.xdata$x:0000716A                 db    0
.xdata$x:0000716B                 db    0
.xdata$x:0000716C                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:00007170                 db    0
.xdata$x:00007171                 db    0
.xdata$x:00007172                 db    0
.xdata$x:00007173                 db    0
.xdata$x:00007174                 db    0
.xdata$x:00007175                 db    0
.xdata$x:00007176                 db    0
.xdata$x:00007177                 db    0
.xdata$x:00007178                 db    0
.xdata$x:00007179                 db    0
.xdata$x:0000717A                 db    0
.xdata$x:0000717B                 db    0
.xdata$x:0000717C                 db    0
.xdata$x:0000717D                 db    0
.xdata$x:0000717E                 db    0
.xdata$x:0000717F                 db    0
.xdata$x:00007180                 db    0
.xdata$x:00007181                 db    0
.xdata$x:00007182                 db    0
.xdata$x:00007183                 db    0
.xdata$x:00007184                 db    0
.xdata$x:00007185                 db    0
.xdata$x:00007186                 db    0
.xdata$x:00007187                 db    0
.xdata$x:00007187 _xdata$x        ends
.xdata$x:00007187
.xdata$x:00007188 ; ===========================================================================
.xdata$x:00007188
.xdata$x:00007188 ; Segment type: Pure data
.xdata$x:00007188 ; Segment permissions: Read
.xdata$x:00007188 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007188                 assume cs:_xdata$x
.xdata$x:00007188                 ;org 7188h
.xdata$x:00007188 ; COMDAT (pick associative to section at 3120)
.xdata$x:00007188 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00007188                                         ; DATA XREF: .xdata$x:00007198o
.xdata$x:00007189                 db 0FFh
.xdata$x:0000718A                 db 0FFh
.xdata$x:0000718B                 db 0FFh
.xdata$x:0000718C                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0
.xdata$x:00007190 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00007190                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z+11o
.xdata$x:00007191                 db    5
.xdata$x:00007192                 db  93h ; 
.xdata$x:00007193                 db  19h
.xdata$x:00007194                 db    1
.xdata$x:00007195                 db    0
.xdata$x:00007196                 db    0
.xdata$x:00007197                 db    0
.xdata$x:00007198                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.xdata$x:0000719C                 db    0
.xdata$x:0000719D                 db    0
.xdata$x:0000719E                 db    0
.xdata$x:0000719F                 db    0
.xdata$x:000071A0                 db    0
.xdata$x:000071A1                 db    0
.xdata$x:000071A2                 db    0
.xdata$x:000071A3                 db    0
.xdata$x:000071A4                 db    0
.xdata$x:000071A5                 db    0
.xdata$x:000071A6                 db    0
.xdata$x:000071A7                 db    0
.xdata$x:000071A8                 db    0
.xdata$x:000071A9                 db    0
.xdata$x:000071AA                 db    0
.xdata$x:000071AB                 db    0
.xdata$x:000071AC                 db    0
.xdata$x:000071AD                 db    0
.xdata$x:000071AE                 db    0
.xdata$x:000071AF                 db    0
.xdata$x:000071B0                 db    0
.xdata$x:000071B1                 db    0
.xdata$x:000071B2                 db    0
.xdata$x:000071B3                 db    0
.xdata$x:000071B3 _xdata$x        ends
.xdata$x:000071B3
.xdata$x:000071B4 ; ===========================================================================
.xdata$x:000071B4
.xdata$x:000071B4 ; Segment type: Pure data
.xdata$x:000071B4 ; Segment permissions: Read
.xdata$x:000071B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000071B4                 assume cs:_xdata$x
.xdata$x:000071B4                 ;org 71B4h
.xdata$x:000071B4 ; COMDAT (pick associative to section at 3268)
.xdata$x:000071B4 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:000071B4                                         ; DATA XREF: .xdata$x:000071C4o
.xdata$x:000071B5                 db 0FFh
.xdata$x:000071B6                 db 0FFh
.xdata$x:000071B7                 db 0FFh
.xdata$x:000071B8                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:000071BC __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000071BC                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:000071BD                 db    5
.xdata$x:000071BE                 db  93h ; 
.xdata$x:000071BF                 db  19h
.xdata$x:000071C0                 db    1
.xdata$x:000071C1                 db    0
.xdata$x:000071C2                 db    0
.xdata$x:000071C3                 db    0
.xdata$x:000071C4                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:000071C8                 align 20h
.xdata$x:000071C8 _xdata$x        ends
.xdata$x:000071C8
.xdata$x:000071E0 ; ===========================================================================
.xdata$x:000071E0
.xdata$x:000071E0 ; Segment type: Pure data
.xdata$x:000071E0 ; Segment permissions: Read
.xdata$x:000071E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000071E0                 assume cs:_xdata$x
.xdata$x:000071E0                 ;org 71E0h
.xdata$x:000071E0 ; COMDAT (pick associative to section at 31D0)
.xdata$x:000071E0 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db 0FFh
.xdata$x:000071E0                                         ; DATA XREF: .xdata$x:000071F0o
.xdata$x:000071E1                 db 0FFh
.xdata$x:000071E2                 db 0FFh
.xdata$x:000071E3                 db 0FFh
.xdata$x:000071E4                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0
.xdata$x:000071E8 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db  22h ; "
.xdata$x:000071E8                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z+11o
.xdata$x:000071E9                 db    5
.xdata$x:000071EA                 db  93h ; 
.xdata$x:000071EB                 db  19h
.xdata$x:000071EC                 db    1
.xdata$x:000071ED                 db    0
.xdata$x:000071EE                 db    0
.xdata$x:000071EF                 db    0
.xdata$x:000071F0                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.xdata$x:000071F4                 db    0
.xdata$x:000071F5                 db    0
.xdata$x:000071F6                 db    0
.xdata$x:000071F7                 db    0
.xdata$x:000071F8                 db    0
.xdata$x:000071F9                 db    0
.xdata$x:000071FA                 db    0
.xdata$x:000071FB                 db    0
.xdata$x:000071FC                 db    0
.xdata$x:000071FD                 db    0
.xdata$x:000071FE                 db    0
.xdata$x:000071FF                 db    0
.xdata$x:00007200                 db    0
.xdata$x:00007201                 db    0
.xdata$x:00007202                 db    0
.xdata$x:00007203                 db    0
.xdata$x:00007204                 db    0
.xdata$x:00007205                 db    0
.xdata$x:00007206                 db    0
.xdata$x:00007207                 db    0
.xdata$x:00007208                 db    0
.xdata$x:00007209                 db    0
.xdata$x:0000720A                 db    0
.xdata$x:0000720B                 db    0
.xdata$x:0000720B _xdata$x        ends
.xdata$x:0000720B
.xdata$x:0000720C ; ===========================================================================
.xdata$x:0000720C
.xdata$x:0000720C ; Segment type: Pure data
.xdata$x:0000720C ; Segment permissions: Read
.xdata$x:0000720C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000720C                 assume cs:_xdata$x
.xdata$x:0000720C                 ;org 720Ch
.xdata$x:0000720C ; COMDAT (pick associative to section at 3CA8)
.xdata$x:0000720C __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000720C                                         ; DATA XREF: .xdata$x:0000721Co
.xdata$x:0000720D                 db 0FFh
.xdata$x:0000720E                 db 0FFh
.xdata$x:0000720F                 db 0FFh
.xdata$x:00007210                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:00007214 __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00007214                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:00007215                 db    5
.xdata$x:00007216                 db  93h ; 
.xdata$x:00007217                 db  19h
.xdata$x:00007218                 db    1
.xdata$x:00007219                 db    0
.xdata$x:0000721A                 db    0
.xdata$x:0000721B                 db    0
.xdata$x:0000721C                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:00007220                 db    0
.xdata$x:00007221                 db    0
.xdata$x:00007222                 db    0
.xdata$x:00007223                 db    0
.xdata$x:00007224                 db    0
.xdata$x:00007225                 db    0
.xdata$x:00007226                 db    0
.xdata$x:00007227                 db    0
.xdata$x:00007228                 db    0
.xdata$x:00007229                 db    0
.xdata$x:0000722A                 db    0
.xdata$x:0000722B                 db    0
.xdata$x:0000722C                 db    0
.xdata$x:0000722D                 db    0
.xdata$x:0000722E                 db    0
.xdata$x:0000722F                 db    0
.xdata$x:00007230                 db    0
.xdata$x:00007231                 db    0
.xdata$x:00007232                 db    0
.xdata$x:00007233                 db    0
.xdata$x:00007234                 db    0
.xdata$x:00007235                 db    0
.xdata$x:00007236                 db    0
.xdata$x:00007237                 db    0
.xdata$x:00007237 _xdata$x        ends
.xdata$x:00007237
.xdata$x:00007238 ; ===========================================================================
.xdata$x:00007238
.xdata$x:00007238 ; Segment type: Pure data
.xdata$x:00007238 ; Segment permissions: Read
.xdata$x:00007238 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007238                 assume cs:_xdata$x
.xdata$x:00007238                 ;org 7238h
.xdata$x:00007238 ; COMDAT (pick associative to section at 48D8)
.xdata$x:00007238 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00007238                                         ; DATA XREF: .xdata$x:000072C0o
.xdata$x:00007239                 db    0
.xdata$x:0000723A                 db    0
.xdata$x:0000723B                 db    0
.xdata$x:0000723C                 db    0
.xdata$x:0000723D                 db    0
.xdata$x:0000723E                 db    0
.xdata$x:0000723F                 db    0
.xdata$x:00007240                 db    0
.xdata$x:00007241                 db    0
.xdata$x:00007242                 db    0
.xdata$x:00007243                 db    0
.xdata$x:00007244                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:00007248 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00007248                                         ; DATA XREF: .xdata$x:000072ACo
.xdata$x:00007249                 db    0
.xdata$x:0000724A                 db    0
.xdata$x:0000724B                 db    0
.xdata$x:0000724C                 db    0
.xdata$x:0000724D                 db    0
.xdata$x:0000724E                 db    0
.xdata$x:0000724F                 db    0
.xdata$x:00007250                 db    0
.xdata$x:00007251                 db    0
.xdata$x:00007252                 db    0
.xdata$x:00007253                 db    0
.xdata$x:00007254                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:00007258 __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00007258                                         ; DATA XREF: .xdata$x:00007280o
.xdata$x:00007259                 db 0FFh
.xdata$x:0000725A                 db 0FFh
.xdata$x:0000725B                 db 0FFh
.xdata$x:0000725C                 db    0
.xdata$x:0000725D                 db    0
.xdata$x:0000725E                 db    0
.xdata$x:0000725F                 db    0
.xdata$x:00007260                 db 0FFh
.xdata$x:00007261                 db 0FFh
.xdata$x:00007262                 db 0FFh
.xdata$x:00007263                 db 0FFh
.xdata$x:00007264                 db    0
.xdata$x:00007265                 db    0
.xdata$x:00007266                 db    0
.xdata$x:00007267                 db    0
.xdata$x:00007268                 db    1
.xdata$x:00007269                 db    0
.xdata$x:0000726A                 db    0
.xdata$x:0000726B                 db    0
.xdata$x:0000726C                 db    0
.xdata$x:0000726D                 db    0
.xdata$x:0000726E                 db    0
.xdata$x:0000726F                 db    0
.xdata$x:00007270                 db    1
.xdata$x:00007271                 db    0
.xdata$x:00007272                 db    0
.xdata$x:00007273                 db    0
.xdata$x:00007274                 db    0
.xdata$x:00007275                 db    0
.xdata$x:00007276                 db    0
.xdata$x:00007277                 db    0
.xdata$x:00007278 __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00007278                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:00007279                 db    5
.xdata$x:0000727A                 db  93h ; 
.xdata$x:0000727B                 db  19h
.xdata$x:0000727C                 db    4
.xdata$x:0000727D                 db    0
.xdata$x:0000727E                 db    0
.xdata$x:0000727F                 db    0
.xdata$x:00007280                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00007284                 db    2
.xdata$x:00007285                 db    0
.xdata$x:00007286                 db    0
.xdata$x:00007287                 db    0
.xdata$x:00007288                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:0000728C                 db    0
.xdata$x:0000728D                 db    0
.xdata$x:0000728E                 db    0
.xdata$x:0000728F                 db    0
.xdata$x:00007290                 db    0
.xdata$x:00007291                 db    0
.xdata$x:00007292                 db    0
.xdata$x:00007293                 db    0
.xdata$x:00007294                 db    0
.xdata$x:00007295                 db    0
.xdata$x:00007296                 db    0
.xdata$x:00007297                 db    0
.xdata$x:00007298                 db    0
.xdata$x:00007299                 db    0
.xdata$x:0000729A                 db    0
.xdata$x:0000729B                 db    0
.xdata$x:0000729C __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:0000729C                                         ; DATA XREF: .xdata$x:00007288o
.xdata$x:0000729D                 db    0
.xdata$x:0000729E                 db    0
.xdata$x:0000729F                 db    0
.xdata$x:000072A0                 db    2
.xdata$x:000072A1                 db    0
.xdata$x:000072A2                 db    0
.xdata$x:000072A3                 db    0
.xdata$x:000072A4                 db    3
.xdata$x:000072A5                 db    0
.xdata$x:000072A6                 db    0
.xdata$x:000072A7                 db    0
.xdata$x:000072A8                 db    1
.xdata$x:000072A9                 db    0
.xdata$x:000072AA                 db    0
.xdata$x:000072AB                 db    0
.xdata$x:000072AC                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:000072B0                 db    0
.xdata$x:000072B1                 db    0
.xdata$x:000072B2                 db    0
.xdata$x:000072B3                 db    0
.xdata$x:000072B4                 db    0
.xdata$x:000072B5                 db    0
.xdata$x:000072B6                 db    0
.xdata$x:000072B7                 db    0
.xdata$x:000072B8                 db    3
.xdata$x:000072B9                 db    0
.xdata$x:000072BA                 db    0
.xdata$x:000072BB                 db    0
.xdata$x:000072BC                 db    1
.xdata$x:000072BD                 db    0
.xdata$x:000072BE                 db    0
.xdata$x:000072BF                 db    0
.xdata$x:000072C0                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:000072C0 _xdata$x        ends
.xdata$x:000072C0
.xdata$x:000072C4 ; ===========================================================================
.xdata$x:000072C4
.xdata$x:000072C4 ; Segment type: Pure data
.xdata$x:000072C4 ; Segment permissions: Read
.xdata$x:000072C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000072C4                 assume cs:_xdata$x
.xdata$x:000072C4                 ;org 72C4h
.xdata$x:000072C4 ; COMDAT (pick associative to section at 5D18)
.xdata$x:000072C4 __unwindtable$?construct@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@ABU3@@Z db 0FFh
.xdata$x:000072C4                                         ; DATA XREF: .xdata$x:000072D4o
.xdata$x:000072C5                 db 0FFh
.xdata$x:000072C6                 db 0FFh
.xdata$x:000072C7                 db 0FFh
.xdata$x:000072C8                 dd offset __unwindfunclet$?construct@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@ABU3@@Z$0
.xdata$x:000072CC __ehfuncinfo$?construct@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@ABU3@@Z db  22h ; "
.xdata$x:000072CC                                         ; DATA XREF: __ehhandler$?construct@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@ABU3@@Z+11o
.xdata$x:000072CD                 db    5
.xdata$x:000072CE                 db  93h ; 
.xdata$x:000072CF                 db  19h
.xdata$x:000072D0                 db    1
.xdata$x:000072D1                 db    0
.xdata$x:000072D2                 db    0
.xdata$x:000072D3                 db    0
.xdata$x:000072D4                 dd offset __unwindtable$?construct@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@ABU3@@Z
.xdata$x:000072D8                 db    0
.xdata$x:000072D9                 db    0
.xdata$x:000072DA                 db    0
.xdata$x:000072DB                 db    0
.xdata$x:000072DC                 db    0
.xdata$x:000072DD                 db    0
.xdata$x:000072DE                 db    0
.xdata$x:000072DF                 db    0
.xdata$x:000072E0                 db    0
.xdata$x:000072E1                 db    0
.xdata$x:000072E2                 db    0
.xdata$x:000072E3                 db    0
.xdata$x:000072E4                 db    0
.xdata$x:000072E5                 db    0
.xdata$x:000072E6                 db    0
.xdata$x:000072E7                 db    0
.xdata$x:000072E8                 db    0
.xdata$x:000072E9                 db    0
.xdata$x:000072EA                 db    0
.xdata$x:000072EB                 db    0
.xdata$x:000072EC                 db    0
.xdata$x:000072ED                 db    0
.xdata$x:000072EE                 db    0
.xdata$x:000072EF                 db    0
.xdata$x:000072EF _xdata$x        ends
.xdata$x:000072EF
.xdata$x:000072F0 ; ===========================================================================
.xdata$x:000072F0
.xdata$x:000072F0 ; Segment type: Pure data
.xdata$x:000072F0 ; Segment permissions: Read
.xdata$x:000072F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000072F0                 assume cs:_xdata$x
.xdata$x:000072F0                 ;org 72F0h
.xdata$x:000072F0 ; COMDAT (pick associative to section at 2F00)
.xdata$x:000072F0 __unwindtable$??0?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000072F0                                         ; DATA XREF: .xdata$x:00007300o
.xdata$x:000072F1                 db 0FFh
.xdata$x:000072F2                 db 0FFh
.xdata$x:000072F3                 db 0FFh
.xdata$x:000072F4                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ$0
.xdata$x:000072F8 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000072F8                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ+11o
.xdata$x:000072F9                 db    5
.xdata$x:000072FA                 db  93h ; 
.xdata$x:000072FB                 db  19h
.xdata$x:000072FC                 db    1
.xdata$x:000072FD                 db    0
.xdata$x:000072FE                 db    0
.xdata$x:000072FF                 db    0
.xdata$x:00007300                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ
.xdata$x:00007304                 db    0
.xdata$x:00007305                 db    0
.xdata$x:00007306                 db    0
.xdata$x:00007307                 db    0
.xdata$x:00007308                 db    0
.xdata$x:00007309                 db    0
.xdata$x:0000730A                 db    0
.xdata$x:0000730B                 db    0
.xdata$x:0000730C                 db    0
.xdata$x:0000730D                 db    0
.xdata$x:0000730E                 db    0
.xdata$x:0000730F                 db    0
.xdata$x:00007310                 db    0
.xdata$x:00007311                 db    0
.xdata$x:00007312                 db    0
.xdata$x:00007313                 db    0
.xdata$x:00007314                 db    0
.xdata$x:00007315                 db    0
.xdata$x:00007316                 db    0
.xdata$x:00007317                 db    0
.xdata$x:00007318                 db    0
.xdata$x:00007319                 db    0
.xdata$x:0000731A                 db    0
.xdata$x:0000731B                 db    0
.xdata$x:0000731B _xdata$x        ends
.xdata$x:0000731B
.xdata$x:0000731C ; ===========================================================================
.xdata$x:0000731C
.xdata$x:0000731C ; Segment type: Pure data
.xdata$x:0000731C ; Segment permissions: Read
.xdata$x:0000731C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000731C                 assume cs:_xdata$x
.xdata$x:0000731C                 ;org 731Ch
.xdata$x:0000731C ; COMDAT (pick associative to section at 3BBC)
.xdata$x:0000731C __unwindtable$??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000731C                                         ; DATA XREF: .xdata$x:0000732Co
.xdata$x:0000731D                 db 0FFh
.xdata$x:0000731E                 db 0FFh
.xdata$x:0000731F                 db 0FFh
.xdata$x:00007320                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ$0
.xdata$x:00007324 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00007324                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ+11o
.xdata$x:00007325                 db    5
.xdata$x:00007326                 db  93h ; 
.xdata$x:00007327                 db  19h
.xdata$x:00007328                 db    1
.xdata$x:00007329                 db    0
.xdata$x:0000732A                 db    0
.xdata$x:0000732B                 db    0
.xdata$x:0000732C                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@QAE@XZ
.xdata$x:00007330                 db    0
.xdata$x:00007331                 db    0
.xdata$x:00007332                 db    0
.xdata$x:00007333                 db    0
.xdata$x:00007334                 db    0
.xdata$x:00007335                 db    0
.xdata$x:00007336                 db    0
.xdata$x:00007337                 db    0
.xdata$x:00007338                 db    0
.xdata$x:00007339                 db    0
.xdata$x:0000733A                 db    0
.xdata$x:0000733B                 db    0
.xdata$x:0000733C                 db    0
.xdata$x:0000733D                 db    0
.xdata$x:0000733E                 db    0
.xdata$x:0000733F                 db    0
.xdata$x:00007340                 db    0
.xdata$x:00007341                 db    0
.xdata$x:00007342                 db    0
.xdata$x:00007343                 db    0
.xdata$x:00007344                 db    0
.xdata$x:00007345                 db    0
.xdata$x:00007346                 db    0
.xdata$x:00007347                 db    0
.xdata$x:00007347 _xdata$x        ends
.xdata$x:00007347
.xdata$x:00007348 ; ===========================================================================
.xdata$x:00007348
.xdata$x:00007348 ; Segment type: Pure data
.xdata$x:00007348 ; Segment permissions: Read
.xdata$x:00007348 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007348                 assume cs:_xdata$x
.xdata$x:00007348                 ;org 7348h
.xdata$x:00007348 ; COMDAT (pick associative to section at 2D74)
.xdata$x:00007348 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z db 0FFh
.xdata$x:00007348                                         ; DATA XREF: .xdata$x:00007358o
.xdata$x:00007349                 db 0FFh
.xdata$x:0000734A                 db 0FFh
.xdata$x:0000734B                 db 0FFh
.xdata$x:0000734C                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z$0
.xdata$x:00007350 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z db  22h ; "
.xdata$x:00007350                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z+11o
.xdata$x:00007351                 db    5
.xdata$x:00007352                 db  93h ; 
.xdata$x:00007353                 db  19h
.xdata$x:00007354                 db    1
.xdata$x:00007355                 db    0
.xdata$x:00007356                 db    0
.xdata$x:00007357                 db    0
.xdata$x:00007358                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV?$allocator@UTreeStateNode@@@1@@Z
.xdata$x:0000735C                 db    0
.xdata$x:0000735D                 db    0
.xdata$x:0000735E                 db    0
.xdata$x:0000735F                 db    0
.xdata$x:00007360                 db    0
.xdata$x:00007361                 db    0
.xdata$x:00007362                 db    0
.xdata$x:00007363                 db    0
.xdata$x:00007364                 db    0
.xdata$x:00007365                 db    0
.xdata$x:00007366                 db    0
.xdata$x:00007367                 db    0
.xdata$x:00007368                 db    0
.xdata$x:00007369                 db    0
.xdata$x:0000736A                 db    0
.xdata$x:0000736B                 db    0
.xdata$x:0000736C                 db    0
.xdata$x:0000736D                 db    0
.xdata$x:0000736E                 db    0
.xdata$x:0000736F                 db    0
.xdata$x:00007370                 db    0
.xdata$x:00007371                 db    0
.xdata$x:00007372                 db    0
.xdata$x:00007373                 db    0
.xdata$x:00007373 _xdata$x        ends
.xdata$x:00007373
.xdata$x:00007374 ; ===========================================================================
.xdata$x:00007374
.xdata$x:00007374 ; Segment type: Pure data
.xdata$x:00007374 ; Segment permissions: Read
.xdata$x:00007374 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007374                 assume cs:_xdata$x
.xdata$x:00007374                 ;org 7374h
.xdata$x:00007374 ; COMDAT (pick associative to section at 3AD4)
.xdata$x:00007374 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00007374                                         ; DATA XREF: .xdata$x:00007384o
.xdata$x:00007375                 db 0FFh
.xdata$x:00007376                 db 0FFh
.xdata$x:00007377                 db 0FFh
.xdata$x:00007378                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000737C __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000737C                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000737D                 db    5
.xdata$x:0000737E                 db  93h ; 
.xdata$x:0000737F                 db  19h
.xdata$x:00007380                 db    1
.xdata$x:00007381                 db    0
.xdata$x:00007382                 db    0
.xdata$x:00007383                 db    0
.xdata$x:00007384                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00007388                 align 20h
.xdata$x:00007388 _xdata$x        ends
.xdata$x:00007388
.xdata$x:000073A0 ; ===========================================================================
.xdata$x:000073A0
.xdata$x:000073A0 ; Segment type: Pure data
.xdata$x:000073A0 ; Segment permissions: Read
.xdata$x:000073A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000073A0                 assume cs:_xdata$x
.xdata$x:000073A0                 ;org 73A0h
.xdata$x:000073A0 ; COMDAT (pick associative to section at 3440)
.xdata$x:000073A0 __unwindtable$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000073A0                                         ; DATA XREF: .xdata$x:000073B0o
.xdata$x:000073A1                 db 0FFh
.xdata$x:000073A2                 db 0FFh
.xdata$x:000073A3                 db 0FFh
.xdata$x:000073A4                 dd offset __unwindfunclet$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ$0
.xdata$x:000073A8 __ehfuncinfo$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000073A8                                         ; DATA XREF: __ehhandler$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ+11o
.xdata$x:000073A9                 db    5
.xdata$x:000073AA                 db  93h ; 
.xdata$x:000073AB                 db  19h
.xdata$x:000073AC                 db    1
.xdata$x:000073AD                 db    0
.xdata$x:000073AE                 db    0
.xdata$x:000073AF                 db    0
.xdata$x:000073B0                 dd offset __unwindtable$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ
.xdata$x:000073B4                 db    0
.xdata$x:000073B5                 db    0
.xdata$x:000073B6                 db    0
.xdata$x:000073B7                 db    0
.xdata$x:000073B8                 db    0
.xdata$x:000073B9                 db    0
.xdata$x:000073BA                 db    0
.xdata$x:000073BB                 db    0
.xdata$x:000073BC                 db    0
.xdata$x:000073BD                 db    0
.xdata$x:000073BE                 db    0
.xdata$x:000073BF                 db    0
.xdata$x:000073C0                 db    0
.xdata$x:000073C1                 db    0
.xdata$x:000073C2                 db    0
.xdata$x:000073C3                 db    0
.xdata$x:000073C4                 db    0
.xdata$x:000073C5                 db    0
.xdata$x:000073C6                 db    0
.xdata$x:000073C7                 db    0
.xdata$x:000073C8                 db    0
.xdata$x:000073C9                 db    0
.xdata$x:000073CA                 db    0
.xdata$x:000073CB                 db    0
.xdata$x:000073CB _xdata$x        ends
.xdata$x:000073CB
.xdata$x:000073CC ; ===========================================================================
.xdata$x:000073CC
.xdata$x:000073CC ; Segment type: Pure data
.xdata$x:000073CC ; Segment permissions: Read
.xdata$x:000073CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000073CC                 assume cs:_xdata$x
.xdata$x:000073CC                 ;org 73CCh
.xdata$x:000073CC ; COMDAT (pick associative to section at 32F4)
.xdata$x:000073CC __catchsym$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$5 db    0
.xdata$x:000073CC                                         ; DATA XREF: .xdata$x:000073ECo
.xdata$x:000073CD                 db    0
.xdata$x:000073CE                 db    0
.xdata$x:000073CF                 db    0
.xdata$x:000073D0                 db    0
.xdata$x:000073D1                 db    0
.xdata$x:000073D2                 db    0
.xdata$x:000073D3                 db    0
.xdata$x:000073D4                 db    0
.xdata$x:000073D5                 db    0
.xdata$x:000073D6                 db    0
.xdata$x:000073D7                 db    0
.xdata$x:000073D8                 dd offset __catch$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:000073DC __tryblocktable$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z db    1
.xdata$x:000073DC                                         ; DATA XREF: .xdata$x:00007400o
.xdata$x:000073DD                 db    0
.xdata$x:000073DE                 db    0
.xdata$x:000073DF                 db    0
.xdata$x:000073E0                 db    3
.xdata$x:000073E1                 db    0
.xdata$x:000073E2                 db    0
.xdata$x:000073E3                 db    0
.xdata$x:000073E4                 db    4
.xdata$x:000073E5                 db    0
.xdata$x:000073E6                 db    0
.xdata$x:000073E7                 db    0
.xdata$x:000073E8                 db    1
.xdata$x:000073E9                 db    0
.xdata$x:000073EA                 db    0
.xdata$x:000073EB                 db    0
.xdata$x:000073EC                 dd offset __catchsym$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$5
.xdata$x:000073F0 __ehfuncinfo$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:000073F0                                         ; DATA XREF: __ehhandler$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:000073F1                 db    5
.xdata$x:000073F2                 db  93h ; 
.xdata$x:000073F3                 db  19h
.xdata$x:000073F4                 db    5
.xdata$x:000073F5                 db    0
.xdata$x:000073F6                 db    0
.xdata$x:000073F7                 db    0
.xdata$x:000073F8                 dd offset __unwindtable$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:000073FC                 db    1
.xdata$x:000073FD                 db    0
.xdata$x:000073FE                 db    0
.xdata$x:000073FF                 db    0
.xdata$x:00007400                 dd offset __tryblocktable$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00007404                 db    0
.xdata$x:00007405                 db    0
.xdata$x:00007406                 db    0
.xdata$x:00007407                 db    0
.xdata$x:00007408                 db    0
.xdata$x:00007409                 db    0
.xdata$x:0000740A                 db    0
.xdata$x:0000740B                 db    0
.xdata$x:0000740C                 db    0
.xdata$x:0000740D                 db    0
.xdata$x:0000740E                 db    0
.xdata$x:0000740F                 db    0
.xdata$x:00007410                 db    0
.xdata$x:00007411                 db    0
.xdata$x:00007412                 db    0
.xdata$x:00007413                 db    0
.xdata$x:00007414 __unwindtable$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00007414                                         ; DATA XREF: .xdata$x:000073F8o
.xdata$x:00007415                 db 0FFh
.xdata$x:00007416                 db 0FFh
.xdata$x:00007417                 db 0FFh
.xdata$x:00007418                 dd offset __unwindfunclet$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$2
.xdata$x:0000741C                 db    0
.xdata$x:0000741D                 db    0
.xdata$x:0000741E                 db    0
.xdata$x:0000741F                 db    0
.xdata$x:00007420                 db    0
.xdata$x:00007421                 db    0
.xdata$x:00007422                 db    0
.xdata$x:00007423                 db    0
.xdata$x:00007424                 db    1
.xdata$x:00007425                 db    0
.xdata$x:00007426                 db    0
.xdata$x:00007427                 db    0
.xdata$x:00007428                 dd offset __unwindfunclet$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$3
.xdata$x:0000742C                 db    2
.xdata$x:0000742D                 db    0
.xdata$x:0000742E                 db    0
.xdata$x:0000742F                 db    0
.xdata$x:00007430                 dd offset __unwindfunclet$??0?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@ABV01@@Z$4
.xdata$x:00007434                 db    0
.xdata$x:00007435                 db    0
.xdata$x:00007436                 db    0
.xdata$x:00007437                 db    0
.xdata$x:00007438                 db    0
.xdata$x:00007439                 db    0
.xdata$x:0000743A                 db    0
.xdata$x:0000743B                 db    0
.xdata$x:0000743B _xdata$x        ends
.xdata$x:0000743B
.xdata$x:0000743C ; ===========================================================================
.xdata$x:0000743C
.xdata$x:0000743C ; Segment type: Pure data
.xdata$x:0000743C ; Segment permissions: Read
.xdata$x:0000743C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000743C                 assume cs:_xdata$x
.xdata$x:0000743C                 ;org 743Ch
.xdata$x:0000743C ; COMDAT (pick associative to section at 3D24)
.xdata$x:0000743C __unwindtable$??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000743C                                         ; DATA XREF: .xdata$x:0000744Co
.xdata$x:0000743D                 db 0FFh
.xdata$x:0000743E                 db 0FFh
.xdata$x:0000743F                 db 0FFh
.xdata$x:00007440                 dd offset __unwindfunclet$??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ$0
.xdata$x:00007444 __ehfuncinfo$??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00007444                                         ; DATA XREF: __ehhandler$??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ+11o
.xdata$x:00007445                 db    5
.xdata$x:00007446                 db  93h ; 
.xdata$x:00007447                 db  19h
.xdata$x:00007448                 db    1
.xdata$x:00007449                 db    0
.xdata$x:0000744A                 db    0
.xdata$x:0000744B                 db    0
.xdata$x:0000744C                 dd offset __unwindtable$??1?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QAE@XZ
.xdata$x:00007450                 db    0
.xdata$x:00007451                 db    0
.xdata$x:00007452                 db    0
.xdata$x:00007453                 db    0
.xdata$x:00007454                 db    0
.xdata$x:00007455                 db    0
.xdata$x:00007456                 db    0
.xdata$x:00007457                 db    0
.xdata$x:00007458                 db    0
.xdata$x:00007459                 db    0
.xdata$x:0000745A                 db    0
.xdata$x:0000745B                 db    0
.xdata$x:0000745C                 db    0
.xdata$x:0000745D                 db    0
.xdata$x:0000745E                 db    0
.xdata$x:0000745F                 db    0
.xdata$x:00007460                 db    0
.xdata$x:00007461                 db    0
.xdata$x:00007462                 db    0
.xdata$x:00007463                 db    0
.xdata$x:00007464                 db    0
.xdata$x:00007465                 db    0
.xdata$x:00007466                 db    0
.xdata$x:00007467                 db    0
.xdata$x:00007467 _xdata$x        ends
.xdata$x:00007467
.xdata$x:00007468 ; ===========================================================================
.xdata$x:00007468
.xdata$x:00007468 ; Segment type: Pure data
.xdata$x:00007468 ; Segment permissions: Read
.xdata$x:00007468 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007468                 assume cs:_xdata$x
.xdata$x:00007468                 ;org 7468h
.xdata$x:00007468 ; COMDAT (pick associative to section at 5AB0)
.xdata$x:00007468 __unwindtable$?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:00007468                                         ; DATA XREF: .xdata$x:00007478o
.xdata$x:00007469                 db 0FFh
.xdata$x:0000746A                 db 0FFh
.xdata$x:0000746B                 db 0FFh
.xdata$x:0000746C                 dd offset __unwindfunclet$?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ$0
.xdata$x:00007470 __ehfuncinfo$?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00007470                                         ; DATA XREF: __ehhandler$?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ+11o
.xdata$x:00007471                 db    5
.xdata$x:00007472                 db  93h ; 
.xdata$x:00007473                 db  19h
.xdata$x:00007474                 db    1
.xdata$x:00007475                 db    0
.xdata$x:00007476                 db    0
.xdata$x:00007477                 db    0
.xdata$x:00007478                 dd offset __unwindtable$?begin@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ
.xdata$x:0000747C                 db    0
.xdata$x:0000747D                 db    0
.xdata$x:0000747E                 db    0
.xdata$x:0000747F                 db    0
.xdata$x:00007480                 db    0
.xdata$x:00007481                 db    0
.xdata$x:00007482                 db    0
.xdata$x:00007483                 db    0
.xdata$x:00007484                 db    0
.xdata$x:00007485                 db    0
.xdata$x:00007486                 db    0
.xdata$x:00007487                 db    0
.xdata$x:00007488                 db    0
.xdata$x:00007489                 db    0
.xdata$x:0000748A                 db    0
.xdata$x:0000748B                 db    0
.xdata$x:0000748C                 db    0
.xdata$x:0000748D                 db    0
.xdata$x:0000748E                 db    0
.xdata$x:0000748F                 db    0
.xdata$x:00007490                 db    0
.xdata$x:00007491                 db    0
.xdata$x:00007492                 db    0
.xdata$x:00007493                 db    0
.xdata$x:00007493 _xdata$x        ends
.xdata$x:00007493
.xdata$x:00007494 ; ===========================================================================
.xdata$x:00007494
.xdata$x:00007494 ; Segment type: Pure data
.xdata$x:00007494 ; Segment permissions: Read
.xdata$x:00007494 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007494                 assume cs:_xdata$x
.xdata$x:00007494                 ;org 7494h
.xdata$x:00007494 ; COMDAT (pick associative to section at 5F7C)
.xdata$x:00007494 __unwindtable$?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:00007494                                         ; DATA XREF: .xdata$x:000074A4o
.xdata$x:00007495                 db 0FFh
.xdata$x:00007496                 db 0FFh
.xdata$x:00007497                 db 0FFh
.xdata$x:00007498                 dd offset __unwindfunclet$?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ$0
.xdata$x:0000749C __ehfuncinfo$?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000749C                                         ; DATA XREF: __ehhandler$?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ+11o
.xdata$x:0000749D                 db    5
.xdata$x:0000749E                 db  93h ; 
.xdata$x:0000749F                 db  19h
.xdata$x:000074A0                 db    1
.xdata$x:000074A1                 db    0
.xdata$x:000074A2                 db    0
.xdata$x:000074A3                 db    0
.xdata$x:000074A4                 dd offset __unwindtable$?end@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@2@XZ
.xdata$x:000074A8                 align 20h
.xdata$x:000074A8 _xdata$x        ends
.xdata$x:000074A8
.xdata$x:000074C0 ; ===========================================================================
.xdata$x:000074C0
.xdata$x:000074C0 ; Segment type: Pure data
.xdata$x:000074C0 ; Segment permissions: Read
.xdata$x:000074C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000074C0                 assume cs:_xdata$x
.xdata$x:000074C0                 ;org 74C0h
.xdata$x:000074C0 ; COMDAT (pick associative to section at 51DC)
.xdata$x:000074C0 __catchsym$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:000074C0                                         ; DATA XREF: .xdata$x:000074F0o
.xdata$x:000074C1                 db    0
.xdata$x:000074C2                 db    0
.xdata$x:000074C3                 db    0
.xdata$x:000074C4                 db    0
.xdata$x:000074C5                 db    0
.xdata$x:000074C6                 db    0
.xdata$x:000074C7                 db    0
.xdata$x:000074C8                 db    0
.xdata$x:000074C9                 db    0
.xdata$x:000074CA                 db    0
.xdata$x:000074CB                 db    0
.xdata$x:000074CC                 dd offset __catch$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z$0
.xdata$x:000074D0 __unwindtable$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:000074D0                                         ; DATA XREF: .xdata$x:000074FCo
.xdata$x:000074D1                 db 0FFh
.xdata$x:000074D2                 db 0FFh
.xdata$x:000074D3                 db 0FFh
.xdata$x:000074D4                 db    0
.xdata$x:000074D5                 db    0
.xdata$x:000074D6                 db    0
.xdata$x:000074D7                 db    0
.xdata$x:000074D8                 db 0FFh
.xdata$x:000074D9                 db 0FFh
.xdata$x:000074DA                 db 0FFh
.xdata$x:000074DB                 db 0FFh
.xdata$x:000074DC                 db    0
.xdata$x:000074DD                 db    0
.xdata$x:000074DE                 db    0
.xdata$x:000074DF                 db    0
.xdata$x:000074E0 __tryblocktable$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z db    0
.xdata$x:000074E0                                         ; DATA XREF: .xdata$x:00007504o
.xdata$x:000074E1                 db    0
.xdata$x:000074E2                 db    0
.xdata$x:000074E3                 db    0
.xdata$x:000074E4                 db    0
.xdata$x:000074E5                 db    0
.xdata$x:000074E6                 db    0
.xdata$x:000074E7                 db    0
.xdata$x:000074E8                 db    1
.xdata$x:000074E9                 db    0
.xdata$x:000074EA                 db    0
.xdata$x:000074EB                 db    0
.xdata$x:000074EC                 db    1
.xdata$x:000074ED                 db    0
.xdata$x:000074EE                 db    0
.xdata$x:000074EF                 db    0
.xdata$x:000074F0                 dd offset __catchsym$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z$2
.xdata$x:000074F4 __ehfuncinfo$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:000074F4                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z+11o
.xdata$x:000074F5                 db    5
.xdata$x:000074F6                 db  93h ; 
.xdata$x:000074F7                 db  19h
.xdata$x:000074F8                 db    2
.xdata$x:000074F9                 db    0
.xdata$x:000074FA                 db    0
.xdata$x:000074FB                 db    0
.xdata$x:000074FC                 dd offset __unwindtable$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z
.xdata$x:00007500                 db    1
.xdata$x:00007501                 db    0
.xdata$x:00007502                 db    0
.xdata$x:00007503                 db    0
.xdata$x:00007504                 dd offset __tryblocktable$?_Reallocate@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEXI@Z
.xdata$x:00007508                 db    0
.xdata$x:00007509                 db    0
.xdata$x:0000750A                 db    0
.xdata$x:0000750B                 db    0
.xdata$x:0000750C                 db    0
.xdata$x:0000750D                 db    0
.xdata$x:0000750E                 db    0
.xdata$x:0000750F                 db    0
.xdata$x:00007510                 db    0
.xdata$x:00007511                 db    0
.xdata$x:00007512                 db    0
.xdata$x:00007513                 db    0
.xdata$x:00007514                 db    0
.xdata$x:00007515                 db    0
.xdata$x:00007516                 db    0
.xdata$x:00007517                 db    0
.xdata$x:00007517 _xdata$x        ends
.xdata$x:00007517
.xdata$x:00007518 ; ===========================================================================
.xdata$x:00007518
.xdata$x:00007518 ; Segment type: Pure data
.xdata$x:00007518 ; Segment permissions: Read
.xdata$x:00007518 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007518                 assume cs:_xdata$x
.xdata$x:00007518                 ;org 7518h
.xdata$x:00007518 ; COMDAT (pick associative to section at 5100)
.xdata$x:00007518 __unwindtable$?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z db 0FFh
.xdata$x:00007518                                         ; DATA XREF: .xdata$x:00007528o
.xdata$x:00007519                 db 0FFh
.xdata$x:0000751A                 db 0FFh
.xdata$x:0000751B                 db 0FFh
.xdata$x:0000751C                 dd offset __unwindfunclet$?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z$0
.xdata$x:00007520 __ehfuncinfo$?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z db  22h ; "
.xdata$x:00007520                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z+11o
.xdata$x:00007521                 db    5
.xdata$x:00007522                 db  93h ; 
.xdata$x:00007523                 db  19h
.xdata$x:00007524                 db    1
.xdata$x:00007525                 db    0
.xdata$x:00007526                 db    0
.xdata$x:00007527                 db    0
.xdata$x:00007528                 dd offset __unwindtable$?_Orphan_range@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IBEXPAUTreeStateNode@@0@Z
.xdata$x:0000752C                 db    0
.xdata$x:0000752D                 db    0
.xdata$x:0000752E                 db    0
.xdata$x:0000752F                 db    0
.xdata$x:00007530                 db    0
.xdata$x:00007531                 db    0
.xdata$x:00007532                 db    0
.xdata$x:00007533                 db    0
.xdata$x:00007534                 db    0
.xdata$x:00007535                 db    0
.xdata$x:00007536                 db    0
.xdata$x:00007537                 db    0
.xdata$x:00007538                 db    0
.xdata$x:00007539                 db    0
.xdata$x:0000753A                 db    0
.xdata$x:0000753B                 db    0
.xdata$x:0000753C                 db    0
.xdata$x:0000753D                 db    0
.xdata$x:0000753E                 db    0
.xdata$x:0000753F                 db    0
.xdata$x:00007540                 db    0
.xdata$x:00007541                 db    0
.xdata$x:00007542                 db    0
.xdata$x:00007543                 db    0
.xdata$x:00007543 _xdata$x        ends
.xdata$x:00007543
.xdata$x:00007544 ; ===========================================================================
.xdata$x:00007544
.xdata$x:00007544 ; Segment type: Pure data
.xdata$x:00007544 ; Segment permissions: Read
.xdata$x:00007544 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007544                 assume cs:_xdata$x
.xdata$x:00007544                 ;org 7544h
.xdata$x:00007544 ; COMDAT (pick associative to section at 3594)
.xdata$x:00007544 __unwindtable$??0TreeStateNode@@QAE@XZ db 0FFh
.xdata$x:00007544                                         ; DATA XREF: .xdata$x:00007564o
.xdata$x:00007545                 db 0FFh
.xdata$x:00007546                 db 0FFh
.xdata$x:00007547                 db 0FFh
.xdata$x:00007548                 dd offset __unwindfunclet$??0TreeStateNode@@QAE@XZ$0
.xdata$x:0000754C                 align 10h
.xdata$x:00007550                 dd offset __unwindfunclet$??0TreeStateNode@@QAE@XZ$1
.xdata$x:00007554                 db    1
.xdata$x:00007555                 db    0
.xdata$x:00007556                 db    0
.xdata$x:00007557                 db    0
.xdata$x:00007558                 dd offset __unwindfunclet$??0TreeStateNode@@QAE@XZ$2
.xdata$x:0000755C __ehfuncinfo$??0TreeStateNode@@QAE@XZ db  22h ; "
.xdata$x:0000755C                                         ; DATA XREF: __ehhandler$??0TreeStateNode@@QAE@XZ+11o
.xdata$x:0000755D                 db    5
.xdata$x:0000755E                 db  93h ; 
.xdata$x:0000755F                 db  19h
.xdata$x:00007560                 db    3
.xdata$x:00007561                 db    0
.xdata$x:00007562                 db    0
.xdata$x:00007563                 db    0
.xdata$x:00007564                 dd offset __unwindtable$??0TreeStateNode@@QAE@XZ
.xdata$x:00007568                 align 20h
.xdata$x:00007568 _xdata$x        ends
.xdata$x:00007568
.xdata$x:00007580 ; ===========================================================================
.xdata$x:00007580
.xdata$x:00007580 ; Segment type: Pure data
.xdata$x:00007580 ; Segment permissions: Read
.xdata$x:00007580 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007580                 assume cs:_xdata$x
.xdata$x:00007580                 ;org 7580h
.xdata$x:00007580 ; COMDAT (pick associative to section at 3D9C)
.xdata$x:00007580 __unwindtable$??1TreeStateNode@@QAE@XZ db 0FFh
.xdata$x:00007580                                         ; DATA XREF: .xdata$x:000075A0o
.xdata$x:00007581                 db 0FFh
.xdata$x:00007582                 db 0FFh
.xdata$x:00007583                 db 0FFh
.xdata$x:00007584                 dd offset __unwindfunclet$??1TreeStateNode@@QAE@XZ$0
.xdata$x:00007588                 db    0
.xdata$x:00007589                 db    0
.xdata$x:0000758A                 db    0
.xdata$x:0000758B                 db    0
.xdata$x:0000758C                 dd offset __unwindfunclet$??1TreeStateNode@@QAE@XZ$1
.xdata$x:00007590                 db    1
.xdata$x:00007591                 db    0
.xdata$x:00007592                 db    0
.xdata$x:00007593                 db    0
.xdata$x:00007594                 dd offset __unwindfunclet$??1TreeStateNode@@QAE@XZ$2
.xdata$x:00007598 __ehfuncinfo$??1TreeStateNode@@QAE@XZ db  22h ; "
.xdata$x:00007598                                         ; DATA XREF: __ehhandler$??1TreeStateNode@@QAE@XZ+11o
.xdata$x:00007599                 db    5
.xdata$x:0000759A                 db  93h ; 
.xdata$x:0000759B                 db  19h
.xdata$x:0000759C                 db    3
.xdata$x:0000759D                 db    0
.xdata$x:0000759E                 db    0
.xdata$x:0000759F                 db    0
.xdata$x:000075A0                 dd offset __unwindtable$??1TreeStateNode@@QAE@XZ
.xdata$x:000075A4                 db    0
.xdata$x:000075A5                 db    0
.xdata$x:000075A6                 db    0
.xdata$x:000075A7                 db    0
.xdata$x:000075A8                 db    0
.xdata$x:000075A9                 db    0
.xdata$x:000075AA                 db    0
.xdata$x:000075AB                 db    0
.xdata$x:000075AC                 db    0
.xdata$x:000075AD                 db    0
.xdata$x:000075AE                 db    0
.xdata$x:000075AF                 db    0
.xdata$x:000075B0                 db    0
.xdata$x:000075B1                 db    0
.xdata$x:000075B2                 db    0
.xdata$x:000075B3                 db    0
.xdata$x:000075B4                 db    0
.xdata$x:000075B5                 db    0
.xdata$x:000075B6                 db    0
.xdata$x:000075B7                 db    0
.xdata$x:000075B8                 db    0
.xdata$x:000075B9                 db    0
.xdata$x:000075BA                 db    0
.xdata$x:000075BB                 db    0
.xdata$x:000075BB _xdata$x        ends
.xdata$x:000075BB
.xdata$x:000075BC ; ===========================================================================
.xdata$x:000075BC
.xdata$x:000075BC ; Segment type: Pure data
.xdata$x:000075BC ; Segment permissions: Read
.xdata$x:000075BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000075BC                 assume cs:_xdata$x
.xdata$x:000075BC                 ;org 75BCh
.xdata$x:000075BC ; COMDAT (pick associative to section at 34C0)
.xdata$x:000075BC __unwindtable$??0TreeStateNode@@QAE@ABU0@@Z db 0FFh
.xdata$x:000075BC                                         ; DATA XREF: .xdata$x:000075DCo
.xdata$x:000075BD                 db 0FFh
.xdata$x:000075BE                 db 0FFh
.xdata$x:000075BF                 db 0FFh
.xdata$x:000075C0                 dd offset __unwindfunclet$??0TreeStateNode@@QAE@ABU0@@Z$0
.xdata$x:000075C4                 align 8
.xdata$x:000075C8                 dd offset __unwindfunclet$??0TreeStateNode@@QAE@ABU0@@Z$1
.xdata$x:000075CC                 db    1
.xdata$x:000075CD                 db    0
.xdata$x:000075CE                 db    0
.xdata$x:000075CF                 db    0
.xdata$x:000075D0                 dd offset __unwindfunclet$??0TreeStateNode@@QAE@ABU0@@Z$2
.xdata$x:000075D4 __ehfuncinfo$??0TreeStateNode@@QAE@ABU0@@Z db  22h ; "
.xdata$x:000075D4                                         ; DATA XREF: __ehhandler$??0TreeStateNode@@QAE@ABU0@@Z+11o
.xdata$x:000075D5                 db    5
.xdata$x:000075D6                 db  93h ; 
.xdata$x:000075D7                 db  19h
.xdata$x:000075D8                 db    3
.xdata$x:000075D9                 db    0
.xdata$x:000075DA                 db    0
.xdata$x:000075DB                 db    0
.xdata$x:000075DC                 dd offset __unwindtable$??0TreeStateNode@@QAE@ABU0@@Z
.xdata$x:000075E0                 db    0
.xdata$x:000075E1                 db    0
.xdata$x:000075E2                 db    0
.xdata$x:000075E3                 db    0
.xdata$x:000075E4                 db    0
.xdata$x:000075E5                 db    0
.xdata$x:000075E6                 db    0
.xdata$x:000075E7                 db    0
.xdata$x:000075E8                 db    0
.xdata$x:000075E9                 db    0
.xdata$x:000075EA                 db    0
.xdata$x:000075EB                 db    0
.xdata$x:000075EC                 db    0
.xdata$x:000075ED                 db    0
.xdata$x:000075EE                 db    0
.xdata$x:000075EF                 db    0
.xdata$x:000075F0                 db    0
.xdata$x:000075F1                 db    0
.xdata$x:000075F2                 db    0
.xdata$x:000075F3                 db    0
.xdata$x:000075F4                 db    0
.xdata$x:000075F5                 db    0
.xdata$x:000075F6                 db    0
.xdata$x:000075F7                 db    0
.xdata$x:000075F7 _xdata$x        ends
.xdata$x:000075F7
.xdata$x:000075F8 ; ===========================================================================
.xdata$x:000075F8
.xdata$x:000075F8 ; Segment type: Pure data
.xdata$x:000075F8 ; Segment permissions: Read
.xdata$x:000075F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000075F8                 assume cs:_xdata$x
.xdata$x:000075F8                 ;org 75F8h
.xdata$x:000075F8 __unwindtable$?moveTreeViewItem@TreeView@@IAEXPAU_TREEITEM@@0@Z db 0FFh
.xdata$x:000075F8                                         ; DATA XREF: .xdata$x:00007638o
.xdata$x:000075F9                 db 0FFh
.xdata$x:000075FA                 db 0FFh
.xdata$x:000075FB                 db 0FFh
.xdata$x:000075FC                 dd offset __unwindfunclet$?moveTreeViewItem@TreeView@@IAEXPAU_TREEITEM@@0@Z$0
.xdata$x:00007600 __unwindtable$?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z db 0FFh
.xdata$x:00007600                                         ; DATA XREF: .xdata$x:00007680o
.xdata$x:00007601                 db 0FFh
.xdata$x:00007602                 db 0FFh
.xdata$x:00007603                 db 0FFh
.xdata$x:00007604                 dd offset __unwindfunclet$?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z$0
.xdata$x:00007608 __unwindtable$?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z db 0FFh
.xdata$x:00007608                                         ; DATA XREF: .xdata$x:000076A4o
.xdata$x:00007609                 db 0FFh
.xdata$x:0000760A                 db 0FFh
.xdata$x:0000760B                 db 0FFh
.xdata$x:0000760C                 dd offset __unwindfunclet$?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z$0
.xdata$x:00007610 __unwindtable$?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z db 0FFh
.xdata$x:00007610                                         ; DATA XREF: .xdata$x:000076ECo
.xdata$x:00007611                 db 0FFh
.xdata$x:00007612                 db 0FFh
.xdata$x:00007613                 db 0FFh
.xdata$x:00007614                 dd offset __unwindfunclet$?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z$0
.xdata$x:00007618 __unwindtable$?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z db 0FFh
.xdata$x:00007618                                         ; DATA XREF: .xdata$x:00007710o
.xdata$x:00007619                 db 0FFh
.xdata$x:0000761A                 db 0FFh
.xdata$x:0000761B                 db 0FFh
.xdata$x:0000761C                 dd offset __unwindfunclet$?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z$0
.xdata$x:00007620 __unwindtable$?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z db 0FFh
.xdata$x:00007620                                         ; DATA XREF: .xdata$x:000076C8o
.xdata$x:00007621                 db 0FFh
.xdata$x:00007622                 db 0FFh
.xdata$x:00007623                 db 0FFh
.xdata$x:00007624                 dd offset __unwindfunclet$?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z$0
.xdata$x:00007628                 db 0FFh
.xdata$x:00007629                 db 0FFh
.xdata$x:0000762A                 db 0FFh
.xdata$x:0000762B                 db 0FFh
.xdata$x:0000762C                 dd offset __unwindfunclet$?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z$1
.xdata$x:00007630 __ehfuncinfo$?moveTreeViewItem@TreeView@@IAEXPAU_TREEITEM@@0@Z db  22h ; "
.xdata$x:00007630                                         ; DATA XREF: __ehhandler$?moveTreeViewItem@TreeView@@IAEXPAU_TREEITEM@@0@Z+1Eo
.xdata$x:00007631                 db    5
.xdata$x:00007632                 db  93h ; 
.xdata$x:00007633                 db  19h
.xdata$x:00007634                 db    1
.xdata$x:00007635                 db    0
.xdata$x:00007636                 db    0
.xdata$x:00007637                 db    0
.xdata$x:00007638                 dd offset __unwindtable$?moveTreeViewItem@TreeView@@IAEXPAU_TREEITEM@@0@Z
.xdata$x:0000763C                 db    0
.xdata$x:0000763D                 db    0
.xdata$x:0000763E                 db    0
.xdata$x:0000763F                 db    0
.xdata$x:00007640                 db    0
.xdata$x:00007641                 db    0
.xdata$x:00007642                 db    0
.xdata$x:00007643                 db    0
.xdata$x:00007644                 db    0
.xdata$x:00007645                 db    0
.xdata$x:00007646                 db    0
.xdata$x:00007647                 db    0
.xdata$x:00007648                 db    0
.xdata$x:00007649                 db    0
.xdata$x:0000764A                 db    0
.xdata$x:0000764B                 db    0
.xdata$x:0000764C                 db    0
.xdata$x:0000764D                 db    0
.xdata$x:0000764E                 db    0
.xdata$x:0000764F                 db    0
.xdata$x:00007650                 db    0
.xdata$x:00007651                 db    0
.xdata$x:00007652                 db    0
.xdata$x:00007653                 db    0
.xdata$x:00007654 __ehfuncinfo$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z db  22h ; "
.xdata$x:00007654                                         ; DATA XREF: __ehhandler$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z+1Eo
.xdata$x:00007655                 db    5
.xdata$x:00007656                 db  93h ; 
.xdata$x:00007657                 db  19h
.xdata$x:00007658                 db    5
.xdata$x:00007659                 db    0
.xdata$x:0000765A                 db    0
.xdata$x:0000765B                 db    0
.xdata$x:0000765C                 dd offset __unwindtable$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z
.xdata$x:00007660                 db    0
.xdata$x:00007661                 db    0
.xdata$x:00007662                 db    0
.xdata$x:00007663                 db    0
.xdata$x:00007664                 db    0
.xdata$x:00007665                 db    0
.xdata$x:00007666                 db    0
.xdata$x:00007667                 db    0
.xdata$x:00007668                 db    0
.xdata$x:00007669                 db    0
.xdata$x:0000766A                 db    0
.xdata$x:0000766B                 db    0
.xdata$x:0000766C                 db    0
.xdata$x:0000766D                 db    0
.xdata$x:0000766E                 db    0
.xdata$x:0000766F                 db    0
.xdata$x:00007670                 db    0
.xdata$x:00007671                 db    0
.xdata$x:00007672                 db    0
.xdata$x:00007673                 db    0
.xdata$x:00007674                 db    0
.xdata$x:00007675                 db    0
.xdata$x:00007676                 db    0
.xdata$x:00007677                 db    0
.xdata$x:00007678 __ehfuncinfo$?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z db  22h ; "
.xdata$x:00007678                                         ; DATA XREF: __ehhandler$?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z+1Eo
.xdata$x:00007679                 db    5
.xdata$x:0000767A                 db  93h ; 
.xdata$x:0000767B                 db  19h
.xdata$x:0000767C                 db    1
.xdata$x:0000767D                 db    0
.xdata$x:0000767E                 db    0
.xdata$x:0000767F                 db    0
.xdata$x:00007680                 dd offset __unwindtable$?dupTree@TreeView@@IAEXPAU_TREEITEM@@0@Z
.xdata$x:00007684                 db    0
.xdata$x:00007685                 db    0
.xdata$x:00007686                 db    0
.xdata$x:00007687                 db    0
.xdata$x:00007688                 db    0
.xdata$x:00007689                 db    0
.xdata$x:0000768A                 db    0
.xdata$x:0000768B                 db    0
.xdata$x:0000768C                 db    0
.xdata$x:0000768D                 db    0
.xdata$x:0000768E                 db    0
.xdata$x:0000768F                 db    0
.xdata$x:00007690                 db    0
.xdata$x:00007691                 db    0
.xdata$x:00007692                 db    0
.xdata$x:00007693                 db    0
.xdata$x:00007694                 db    0
.xdata$x:00007695                 db    0
.xdata$x:00007696                 db    0
.xdata$x:00007697                 db    0
.xdata$x:00007698                 db    0
.xdata$x:00007699                 db    0
.xdata$x:0000769A                 db    0
.xdata$x:0000769B                 db    0
.xdata$x:0000769C __ehfuncinfo$?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z db  22h ; "
.xdata$x:0000769C                                         ; DATA XREF: __ehhandler$?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z+1Eo
.xdata$x:0000769D                 db    5
.xdata$x:0000769E                 db  93h ; 
.xdata$x:0000769F                 db  19h
.xdata$x:000076A0                 db    1
.xdata$x:000076A1                 db    0
.xdata$x:000076A2                 db    0
.xdata$x:000076A3                 db    0
.xdata$x:000076A4                 dd offset __unwindtable$?retrieveFoldingStateTo@TreeView@@QAE_NAAUTreeStateNode@@PAU_TREEITEM@@@Z
.xdata$x:000076A8                 align 20h
.xdata$x:000076C0 __ehfuncinfo$?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z db  22h ; "
.xdata$x:000076C0                                         ; DATA XREF: __ehhandler$?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z+1Eo
.xdata$x:000076C1                 db    5
.xdata$x:000076C2                 db  93h ; 
.xdata$x:000076C3                 db  19h
.xdata$x:000076C4                 db    2
.xdata$x:000076C5                 db    0
.xdata$x:000076C6                 db    0
.xdata$x:000076C7                 db    0
.xdata$x:000076C8                 dd offset __unwindtable$?swapTreeViewItem@TreeView@@QAE_NPAU_TREEITEM@@0@Z
.xdata$x:000076CC                 db    0
.xdata$x:000076CD                 db    0
.xdata$x:000076CE                 db    0
.xdata$x:000076CF                 db    0
.xdata$x:000076D0                 db    0
.xdata$x:000076D1                 db    0
.xdata$x:000076D2                 db    0
.xdata$x:000076D3                 db    0
.xdata$x:000076D4                 db    0
.xdata$x:000076D5                 db    0
.xdata$x:000076D6                 db    0
.xdata$x:000076D7                 db    0
.xdata$x:000076D8                 db    0
.xdata$x:000076D9                 db    0
.xdata$x:000076DA                 db    0
.xdata$x:000076DB                 db    0
.xdata$x:000076DC                 db    0
.xdata$x:000076DD                 db    0
.xdata$x:000076DE                 db    0
.xdata$x:000076DF                 db    0
.xdata$x:000076E0                 db    0
.xdata$x:000076E1                 db    0
.xdata$x:000076E2                 db    0
.xdata$x:000076E3                 db    0
.xdata$x:000076E4 __ehfuncinfo$?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z db  22h ; "
.xdata$x:000076E4                                         ; DATA XREF: __ehhandler$?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z+11o
.xdata$x:000076E5                 db    5
.xdata$x:000076E6                 db  93h ; 
.xdata$x:000076E7                 db  19h
.xdata$x:000076E8                 db    1
.xdata$x:000076E9                 db    0
.xdata$x:000076EA                 db    0
.xdata$x:000076EB                 db    0
.xdata$x:000076EC                 dd offset __unwindtable$?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z
.xdata$x:000076F0                 db    0
.xdata$x:000076F1                 db    0
.xdata$x:000076F2                 db    0
.xdata$x:000076F3                 db    0
.xdata$x:000076F4                 db    0
.xdata$x:000076F5                 db    0
.xdata$x:000076F6                 db    0
.xdata$x:000076F7                 db    0
.xdata$x:000076F8                 db    0
.xdata$x:000076F9                 db    0
.xdata$x:000076FA                 db    0
.xdata$x:000076FB                 db    0
.xdata$x:000076FC                 db    0
.xdata$x:000076FD                 db    0
.xdata$x:000076FE                 db    0
.xdata$x:000076FF                 db    0
.xdata$x:00007700                 db    0
.xdata$x:00007701                 db    0
.xdata$x:00007702                 db    0
.xdata$x:00007703                 db    0
.xdata$x:00007704                 db    0
.xdata$x:00007705                 db    0
.xdata$x:00007706                 db    0
.xdata$x:00007707                 db    0
.xdata$x:00007708 __ehfuncinfo$?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z db  22h ; "
.xdata$x:00007708                                         ; DATA XREF: __ehhandler$?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z+14o
.xdata$x:00007709                 db    5
.xdata$x:0000770A                 db  93h ; 
.xdata$x:0000770B                 db  19h
.xdata$x:0000770C                 db    1
.xdata$x:0000770D                 db    0
.xdata$x:0000770E                 db    0
.xdata$x:0000770F                 db    0
.xdata$x:00007710                 dd offset __unwindtable$?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z
.xdata$x:00007714                 db    0
.xdata$x:00007715                 db    0
.xdata$x:00007716                 db    0
.xdata$x:00007717                 db    0
.xdata$x:00007718                 db    0
.xdata$x:00007719                 db    0
.xdata$x:0000771A                 db    0
.xdata$x:0000771B                 db    0
.xdata$x:0000771C                 db    0
.xdata$x:0000771D                 db    0
.xdata$x:0000771E                 db    0
.xdata$x:0000771F                 db    0
.xdata$x:00007720                 db    0
.xdata$x:00007721                 db    0
.xdata$x:00007722                 db    0
.xdata$x:00007723                 db    0
.xdata$x:00007724                 db    0
.xdata$x:00007725                 db    0
.xdata$x:00007726                 db    0
.xdata$x:00007727                 db    0
.xdata$x:00007728                 db    0
.xdata$x:00007729                 db    0
.xdata$x:0000772A                 db    0
.xdata$x:0000772B                 db    0
.xdata$x:0000772C __unwindtable$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z db 0FFh
.xdata$x:0000772C                                         ; DATA XREF: .xdata$x:0000765Co
.xdata$x:0000772D                 db 0FFh
.xdata$x:0000772E                 db 0FFh
.xdata$x:0000772F                 db 0FFh
.xdata$x:00007730                 dd offset __unwindfunclet$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z$0
.xdata$x:00007734                 db 0FFh
.xdata$x:00007735                 db 0FFh
.xdata$x:00007736                 db 0FFh
.xdata$x:00007737                 db 0FFh
.xdata$x:00007738                 dd offset __unwindfunclet$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z$1
.xdata$x:0000773C                 db    1
.xdata$x:0000773D                 db    0
.xdata$x:0000773E                 db    0
.xdata$x:0000773F                 db    0
.xdata$x:00007740                 dd offset __unwindfunclet$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z$2
.xdata$x:00007744                 db    1
.xdata$x:00007745                 db    0
.xdata$x:00007746                 db    0
.xdata$x:00007747                 db    0
.xdata$x:00007748                 dd offset __unwindfunclet$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z$3
.xdata$x:0000774C                 db    3
.xdata$x:0000774D                 db    0
.xdata$x:0000774E                 db    0
.xdata$x:0000774F                 db    0
.xdata$x:00007750                 dd offset __unwindfunclet$?searchLeafRecusivelyAndBuildTree@TreeView@@IAE_NPAU_TREEITEM@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H0@Z$4
.xdata$x:00007750 _xdata$x        ends
.xdata$x:00007750
.xdata$x:00007754 ; ===========================================================================
.xdata$x:00007754
.xdata$x:00007754 ; Segment type: Pure data
.xdata$x:00007754 ; Segment permissions: Read
.xdata$x:00007754 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007754                 assume cs:_xdata$x
.xdata$x:00007754                 ;org 7754h
.xdata$x:00007754 ; COMDAT (pick associative to section at 2AF8)
.xdata$x:00007754 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00007754                                         ; DATA XREF: .xdata$x:00007764o
.xdata$x:00007755                 db 0FFh
.xdata$x:00007756                 db 0FFh
.xdata$x:00007757                 db 0FFh
.xdata$x:00007758                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000775C __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000775C                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000775D                 db    5
.xdata$x:0000775E                 db  93h ; 
.xdata$x:0000775F                 db  19h
.xdata$x:00007760                 db    1
.xdata$x:00007761                 db    0
.xdata$x:00007762                 db    0
.xdata$x:00007763                 db    0
.xdata$x:00007764                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00007768                 align 20h
.xdata$x:00007768 _xdata$x        ends
.xdata$x:00007768
.xdata$x:00007780 ; ===========================================================================
.xdata$x:00007780
.xdata$x:00007780 ; Segment type: Pure data
.xdata$x:00007780 ; Segment permissions: Read
.xdata$x:00007780 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007780                 assume cs:_xdata$x
.xdata$x:00007780                 ;org 7780h
.xdata$x:00007780 ; COMDAT (pick associative to section at 3894)
.xdata$x:00007780 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00007780                                         ; DATA XREF: .xdata$x:00007790o
.xdata$x:00007781                 db 0FFh
.xdata$x:00007782                 db 0FFh
.xdata$x:00007783                 db 0FFh
.xdata$x:00007784                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00007788 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00007788                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00007789                 db    5
.xdata$x:0000778A                 db  93h ; 
.xdata$x:0000778B                 db  19h
.xdata$x:0000778C                 db    1
.xdata$x:0000778D                 db    0
.xdata$x:0000778E                 db    0
.xdata$x:0000778F                 db    0
.xdata$x:00007790                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00007794                 db    0
.xdata$x:00007795                 db    0
.xdata$x:00007796                 db    0
.xdata$x:00007797                 db    0
.xdata$x:00007798                 db    0
.xdata$x:00007799                 db    0
.xdata$x:0000779A                 db    0
.xdata$x:0000779B                 db    0
.xdata$x:0000779C                 db    0
.xdata$x:0000779D                 db    0
.xdata$x:0000779E                 db    0
.xdata$x:0000779F                 db    0
.xdata$x:000077A0                 db    0
.xdata$x:000077A1                 db    0
.xdata$x:000077A2                 db    0
.xdata$x:000077A3                 db    0
.xdata$x:000077A4                 db    0
.xdata$x:000077A5                 db    0
.xdata$x:000077A6                 db    0
.xdata$x:000077A7                 db    0
.xdata$x:000077A8                 db    0
.xdata$x:000077A9                 db    0
.xdata$x:000077AA                 db    0
.xdata$x:000077AB                 db    0
.xdata$x:000077AB _xdata$x        ends
.xdata$x:000077AB
.xdata$x:000077AC ; ===========================================================================
.xdata$x:000077AC
.xdata$x:000077AC ; Segment type: Pure data
.xdata$x:000077AC ; Segment permissions: Read
.xdata$x:000077AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000077AC                 assume cs:_xdata$x
.xdata$x:000077AC                 ;org 77ACh
.xdata$x:000077AC ; COMDAT (pick associative to section at 2A80)
.xdata$x:000077AC __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:000077AC                                         ; DATA XREF: .xdata$x:000077BCo
.xdata$x:000077AD                 db 0FFh
.xdata$x:000077AE                 db 0FFh
.xdata$x:000077AF                 db 0FFh
.xdata$x:000077B0                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:000077B4 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:000077B4                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:000077B5                 db    5
.xdata$x:000077B6                 db  93h ; 
.xdata$x:000077B7                 db  19h
.xdata$x:000077B8                 db    1
.xdata$x:000077B9                 db    0
.xdata$x:000077BA                 db    0
.xdata$x:000077BB                 db    0
.xdata$x:000077BC                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTreeStateNode@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:000077C0                 db    0
.xdata$x:000077C1                 db    0
.xdata$x:000077C2                 db    0
.xdata$x:000077C3                 db    0
.xdata$x:000077C4                 db    0
.xdata$x:000077C5                 db    0
.xdata$x:000077C6                 db    0
.xdata$x:000077C7                 db    0
.xdata$x:000077C8                 db    0
.xdata$x:000077C9                 db    0
.xdata$x:000077CA                 db    0
.xdata$x:000077CB                 db    0
.xdata$x:000077CC                 db    0
.xdata$x:000077CD                 db    0
.xdata$x:000077CE                 db    0
.xdata$x:000077CF                 db    0
.xdata$x:000077D0                 db    0
.xdata$x:000077D1                 db    0
.xdata$x:000077D2                 db    0
.xdata$x:000077D3                 db    0
.xdata$x:000077D4                 db    0
.xdata$x:000077D5                 db    0
.xdata$x:000077D6                 db    0
.xdata$x:000077D7                 db    0
.xdata$x:000077D7 _xdata$x        ends
.xdata$x:000077D7
.xdata$x:000077D8 ; ===========================================================================
.xdata$x:000077D8
.xdata$x:000077D8 ; Segment type: Pure data
.xdata$x:000077D8 ; Segment permissions: Read
.xdata$x:000077D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000077D8                 assume cs:_xdata$x
.xdata$x:000077D8                 ;org 77D8h
.xdata$x:000077D8 ; COMDAT (pick associative to section at 2E74)
.xdata$x:000077D8 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:000077D8                                         ; DATA XREF: .xdata$x:000077E8o
.xdata$x:000077D9                 db 0FFh
.xdata$x:000077DA                 db 0FFh
.xdata$x:000077DB                 db 0FFh
.xdata$x:000077DC                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z$0
.xdata$x:000077E0 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:000077E0                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z+11o
.xdata$x:000077E1                 db    5
.xdata$x:000077E2                 db  93h ; 
.xdata$x:000077E3                 db  19h
.xdata$x:000077E4                 db    1
.xdata$x:000077E5                 db    0
.xdata$x:000077E6                 db    0
.xdata$x:000077E7                 db    0
.xdata$x:000077E8                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@PAUTreeStateNode@@PBU_Container_base12@1@@Z
.xdata$x:000077EC                 db    0
.xdata$x:000077ED                 db    0
.xdata$x:000077EE                 db    0
.xdata$x:000077EF                 db    0
.xdata$x:000077F0                 db    0
.xdata$x:000077F1                 db    0
.xdata$x:000077F2                 db    0
.xdata$x:000077F3                 db    0
.xdata$x:000077F4                 db    0
.xdata$x:000077F5                 db    0
.xdata$x:000077F6                 db    0
.xdata$x:000077F7                 db    0
.xdata$x:000077F8                 db    0
.xdata$x:000077F9                 db    0
.xdata$x:000077FA                 db    0
.xdata$x:000077FB                 db    0
.xdata$x:000077FC                 db    0
.xdata$x:000077FD                 db    0
.xdata$x:000077FE                 db    0
.xdata$x:000077FF                 db    0
.xdata$x:00007800                 db    0
.xdata$x:00007801                 db    0
.xdata$x:00007802                 db    0
.xdata$x:00007803                 db    0
.xdata$x:00007803 _xdata$x        ends
.xdata$x:00007803
.xdata$x:00007804 ; ===========================================================================
.xdata$x:00007804
.xdata$x:00007804 ; Segment type: Pure data
.xdata$x:00007804 ; Segment permissions: Read
.xdata$x:00007804 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007804                 assume cs:_xdata$x
.xdata$x:00007804                 ;org 7804h
.xdata$x:00007804 ; COMDAT (pick associative to section at 3B4C)
.xdata$x:00007804 __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00007804                                         ; DATA XREF: .xdata$x:00007814o
.xdata$x:00007805                 db 0FFh
.xdata$x:00007806                 db 0FFh
.xdata$x:00007807                 db 0FFh
.xdata$x:00007808                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000780C __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000780C                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000780D                 db    5
.xdata$x:0000780E                 db  93h ; 
.xdata$x:0000780F                 db  19h
.xdata$x:00007810                 db    1
.xdata$x:00007811                 db    0
.xdata$x:00007812                 db    0
.xdata$x:00007813                 db    0
.xdata$x:00007814                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00007818                 db    0
.xdata$x:00007819                 db    0
.xdata$x:0000781A                 db    0
.xdata$x:0000781B                 db    0
.xdata$x:0000781C                 db    0
.xdata$x:0000781D                 db    0
.xdata$x:0000781E                 db    0
.xdata$x:0000781F                 db    0
.xdata$x:00007820                 db    0
.xdata$x:00007821                 db    0
.xdata$x:00007822                 db    0
.xdata$x:00007823                 db    0
.xdata$x:00007824                 db    0
.xdata$x:00007825                 db    0
.xdata$x:00007826                 db    0
.xdata$x:00007827                 db    0
.xdata$x:00007828                 db    0
.xdata$x:00007829                 db    0
.xdata$x:0000782A                 db    0
.xdata$x:0000782B                 db    0
.xdata$x:0000782C                 db    0
.xdata$x:0000782D                 db    0
.xdata$x:0000782E                 db    0
.xdata$x:0000782F                 db    0
.xdata$x:0000782F _xdata$x        ends
.xdata$x:0000782F
.xdata$x:00007830 ; ===========================================================================
.xdata$x:00007830
.xdata$x:00007830 ; Segment type: Pure data
.xdata$x:00007830 ; Segment permissions: Read
.xdata$x:00007830 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007830                 assume cs:_xdata$x
.xdata$x:00007830                 ;org 7830h
.xdata$x:00007830 ; COMDAT (pick associative to section at 2DF0)
.xdata$x:00007830 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00007830                                         ; DATA XREF: .xdata$x:00007840o
.xdata$x:00007831                 db 0FFh
.xdata$x:00007832                 db 0FFh
.xdata$x:00007833                 db 0FFh
.xdata$x:00007834                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00007838 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00007838                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00007839                 db    5
.xdata$x:0000783A                 db  93h ; 
.xdata$x:0000783B                 db  19h
.xdata$x:0000783C                 db    1
.xdata$x:0000783D                 db    0
.xdata$x:0000783E                 db    0
.xdata$x:0000783F                 db    0
.xdata$x:00007840                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00007844                 db    0
.xdata$x:00007845                 db    0
.xdata$x:00007846                 db    0
.xdata$x:00007847                 db    0
.xdata$x:00007848                 db    0
.xdata$x:00007849                 db    0
.xdata$x:0000784A                 db    0
.xdata$x:0000784B                 db    0
.xdata$x:0000784C                 db    0
.xdata$x:0000784D                 db    0
.xdata$x:0000784E                 db    0
.xdata$x:0000784F                 db    0
.xdata$x:00007850                 db    0
.xdata$x:00007851                 db    0
.xdata$x:00007852                 db    0
.xdata$x:00007853                 db    0
.xdata$x:00007854                 db    0
.xdata$x:00007855                 db    0
.xdata$x:00007856                 db    0
.xdata$x:00007857                 db    0
.xdata$x:00007858                 db    0
.xdata$x:00007859                 db    0
.xdata$x:0000785A                 db    0
.xdata$x:0000785B                 db    0
.xdata$x:0000785B _xdata$x        ends
.xdata$x:0000785B
.xdata$x:0000785C ; ===========================================================================
.xdata$x:0000785C
.xdata$x:0000785C ; Segment type: Pure data
.xdata$x:0000785C ; Segment permissions: Read
.xdata$x:0000785C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000785C                 assume cs:_xdata$x
.xdata$x:0000785C                 ;org 785Ch
.xdata$x:0000785C ; COMDAT (pick associative to section at 2868)
.xdata$x:0000785C __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:0000785C                                         ; DATA XREF: .xdata$x:0000786Co
.xdata$x:0000785D                 db 0FFh
.xdata$x:0000785E                 db 0FFh
.xdata$x:0000785F                 db 0FFh
.xdata$x:00007860                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00007864 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00007864                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00007865                 db    5
.xdata$x:00007866                 db  93h ; 
.xdata$x:00007867                 db  19h
.xdata$x:00007868                 db    1
.xdata$x:00007869                 db    0
.xdata$x:0000786A                 db    0
.xdata$x:0000786B                 db    0
.xdata$x:0000786C                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00007870                 db    0
.xdata$x:00007871                 db    0
.xdata$x:00007872                 db    0
.xdata$x:00007873                 db    0
.xdata$x:00007874                 db    0
.xdata$x:00007875                 db    0
.xdata$x:00007876                 db    0
.xdata$x:00007877                 db    0
.xdata$x:00007878                 db    0
.xdata$x:00007879                 db    0
.xdata$x:0000787A                 db    0
.xdata$x:0000787B                 db    0
.xdata$x:0000787C                 db    0
.xdata$x:0000787D                 db    0
.xdata$x:0000787E                 db    0
.xdata$x:0000787F                 db    0
.xdata$x:00007880                 db    0
.xdata$x:00007881                 db    0
.xdata$x:00007882                 db    0
.xdata$x:00007883                 db    0
.xdata$x:00007884                 db    0
.xdata$x:00007885                 db    0
.xdata$x:00007886                 db    0
.xdata$x:00007887                 db    0
.xdata$x:00007887 _xdata$x        ends
.xdata$x:00007887
.xdata$x:00007888 ; ===========================================================================
.xdata$x:00007888
.xdata$x:00007888 ; Segment type: Pure data
.xdata$x:00007888 ; Segment permissions: Read
.xdata$x:00007888 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007888                 assume cs:_xdata$x
.xdata$x:00007888                 ;org 7888h
.xdata$x:00007888 ; COMDAT (pick associative to section at 2768)
.xdata$x:00007888 __unwindtable$??$construct@UTreeStateNode@@U1@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z db 0FFh
.xdata$x:00007888                                         ; DATA XREF: .xdata$x:00007898o
.xdata$x:00007889                 db 0FFh
.xdata$x:0000788A                 db 0FFh
.xdata$x:0000788B                 db 0FFh
.xdata$x:0000788C                 dd offset __unwindfunclet$??$construct@UTreeStateNode@@U1@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z$0
.xdata$x:00007890 __ehfuncinfo$??$construct@UTreeStateNode@@U1@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z db  22h ; "
.xdata$x:00007890                                         ; DATA XREF: __ehhandler$??$construct@UTreeStateNode@@U1@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z+11o
.xdata$x:00007891                 db    5
.xdata$x:00007892                 db  93h ; 
.xdata$x:00007893                 db  19h
.xdata$x:00007894                 db    1
.xdata$x:00007895                 db    0
.xdata$x:00007896                 db    0
.xdata$x:00007897                 db    0
.xdata$x:00007898                 dd offset __unwindtable$??$construct@UTreeStateNode@@U1@@?$allocator@UTreeStateNode@@@std@@QAEXPAUTreeStateNode@@$$QAU2@@Z
.xdata$x:0000789C                 db    0
.xdata$x:0000789D                 db    0
.xdata$x:0000789E                 db    0
.xdata$x:0000789F                 db    0
.xdata$x:000078A0                 db    0
.xdata$x:000078A1                 db    0
.xdata$x:000078A2                 db    0
.xdata$x:000078A3                 db    0
.xdata$x:000078A4                 db    0
.xdata$x:000078A5                 db    0
.xdata$x:000078A6                 db    0
.xdata$x:000078A7                 db    0
.xdata$x:000078A8                 db    0
.xdata$x:000078A9                 db    0
.xdata$x:000078AA                 db    0
.xdata$x:000078AB                 db    0
.xdata$x:000078AC                 db    0
.xdata$x:000078AD                 db    0
.xdata$x:000078AE                 db    0
.xdata$x:000078AF                 db    0
.xdata$x:000078B0                 db    0
.xdata$x:000078B1                 db    0
.xdata$x:000078B2                 db    0
.xdata$x:000078B3                 db    0
.xdata$x:000078B3 _xdata$x        ends
.xdata$x:000078B3
.xdata$x:000078B4 ; ===========================================================================
.xdata$x:000078B4
.xdata$x:000078B4 ; Segment type: Pure data
.xdata$x:000078B4 ; Segment permissions: Read
.xdata$x:000078B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000078B4                 assume cs:_xdata$x
.xdata$x:000078B4                 ;org 78B4h
.xdata$x:000078B4 ; COMDAT (pick associative to section at 251C)
.xdata$x:000078B4 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:000078B4                                         ; DATA XREF: .xdata$x:000078C4o
.xdata$x:000078B5                 db 0FFh
.xdata$x:000078B6                 db 0FFh
.xdata$x:000078B7                 db 0FFh
.xdata$x:000078B8                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:000078BC __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:000078BC                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:000078BD                 db    5
.xdata$x:000078BE                 db  93h ; 
.xdata$x:000078BF                 db  19h
.xdata$x:000078C0                 db    1
.xdata$x:000078C1                 db    0
.xdata$x:000078C2                 db    0
.xdata$x:000078C3                 db    0
.xdata$x:000078C4                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:000078C8                 align 20h
.xdata$x:000078C8 _xdata$x        ends
.xdata$x:000078C8
.xdata$x:000078E0 ; ===========================================================================
.xdata$x:000078E0
.xdata$x:000078E0 ; Segment type: Pure data
.xdata$x:000078E0 ; Segment permissions: Read
.xdata$x:000078E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000078E0                 assume cs:_xdata$x
.xdata$x:000078E0                 ;org 78E0h
.xdata$x:000078E0 ; COMDAT (pick associative to section at 261C)
.xdata$x:000078E0 __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:000078E0                                         ; DATA XREF: .xdata$x:000078F0o
.xdata$x:000078E1                 db 0FFh
.xdata$x:000078E2                 db 0FFh
.xdata$x:000078E3                 db 0FFh
.xdata$x:000078E4                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:000078E8 __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:000078E8                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:000078E9                 db    5
.xdata$x:000078EA                 db  93h ; 
.xdata$x:000078EB                 db  19h
.xdata$x:000078EC                 db    1
.xdata$x:000078ED                 db    0
.xdata$x:000078EE                 db    0
.xdata$x:000078EF                 db    0
.xdata$x:000078F0                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:000078F4                 db    0
.xdata$x:000078F5                 db    0
.xdata$x:000078F6                 db    0
.xdata$x:000078F7                 db    0
.xdata$x:000078F8                 db    0
.xdata$x:000078F9                 db    0
.xdata$x:000078FA                 db    0
.xdata$x:000078FB                 db    0
.xdata$x:000078FC                 db    0
.xdata$x:000078FD                 db    0
.xdata$x:000078FE                 db    0
.xdata$x:000078FF                 db    0
.xdata$x:00007900                 db    0
.xdata$x:00007901                 db    0
.xdata$x:00007902                 db    0
.xdata$x:00007903                 db    0
.xdata$x:00007904                 db    0
.xdata$x:00007905                 db    0
.xdata$x:00007906                 db    0
.xdata$x:00007907                 db    0
.xdata$x:00007908                 db    0
.xdata$x:00007909                 db    0
.xdata$x:0000790A                 db    0
.xdata$x:0000790B                 db    0
.xdata$x:0000790B _xdata$x        ends
.xdata$x:0000790B
.xdata$x:0000790C ; ===========================================================================
.xdata$x:0000790C
.xdata$x:0000790C ; Segment type: Pure data
.xdata$x:0000790C ; Segment permissions: Read
.xdata$x:0000790C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000790C                 assume cs:_xdata$x
.xdata$x:0000790C                 ;org 790Ch
.xdata$x:0000790C ; COMDAT (pick associative to section at 2258)
.xdata$x:0000790C __catchsym$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000790C                                         ; DATA XREF: .xdata$x:0000793Co
.xdata$x:0000790D                 db    0
.xdata$x:0000790E                 db    0
.xdata$x:0000790F                 db    0
.xdata$x:00007910                 db    0
.xdata$x:00007911                 db    0
.xdata$x:00007912                 db    0
.xdata$x:00007913                 db    0
.xdata$x:00007914                 db    0
.xdata$x:00007915                 db    0
.xdata$x:00007916                 db    0
.xdata$x:00007917                 db    0
.xdata$x:00007918                 dd offset __catch$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000791C __unwindtable$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000791C                                         ; DATA XREF: .xdata$x:00007948o
.xdata$x:0000791D                 db 0FFh
.xdata$x:0000791E                 db 0FFh
.xdata$x:0000791F                 db 0FFh
.xdata$x:00007920                 db    0
.xdata$x:00007921                 db    0
.xdata$x:00007922                 db    0
.xdata$x:00007923                 db    0
.xdata$x:00007924                 db 0FFh
.xdata$x:00007925                 db 0FFh
.xdata$x:00007926                 db 0FFh
.xdata$x:00007927                 db 0FFh
.xdata$x:00007928                 db    0
.xdata$x:00007929                 db    0
.xdata$x:0000792A                 db    0
.xdata$x:0000792B                 db    0
.xdata$x:0000792C __tryblocktable$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000792C                                         ; DATA XREF: .xdata$x:00007950o
.xdata$x:0000792D                 db    0
.xdata$x:0000792E                 db    0
.xdata$x:0000792F                 db    0
.xdata$x:00007930                 db    0
.xdata$x:00007931                 db    0
.xdata$x:00007932                 db    0
.xdata$x:00007933                 db    0
.xdata$x:00007934                 db    1
.xdata$x:00007935                 db    0
.xdata$x:00007936                 db    0
.xdata$x:00007937                 db    0
.xdata$x:00007938                 db    1
.xdata$x:00007939                 db    0
.xdata$x:0000793A                 db    0
.xdata$x:0000793B                 db    0
.xdata$x:0000793C                 dd offset __catchsym$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:00007940 __ehfuncinfo$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:00007940                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:00007941                 db    5
.xdata$x:00007942                 db  93h ; 
.xdata$x:00007943                 db  19h
.xdata$x:00007944                 db    2
.xdata$x:00007945                 db    0
.xdata$x:00007946                 db    0
.xdata$x:00007947                 db    0
.xdata$x:00007948                 dd offset __unwindtable$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000794C                 db    1
.xdata$x:0000794D                 db    0
.xdata$x:0000794E                 db    0
.xdata$x:0000794F                 db    0
.xdata$x:00007950                 dd offset __tryblocktable$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00007954                 db    0
.xdata$x:00007955                 db    0
.xdata$x:00007956                 db    0
.xdata$x:00007957                 db    0
.xdata$x:00007958                 db    0
.xdata$x:00007959                 db    0
.xdata$x:0000795A                 db    0
.xdata$x:0000795B                 db    0
.xdata$x:0000795C                 db    0
.xdata$x:0000795D                 db    0
.xdata$x:0000795E                 db    0
.xdata$x:0000795F                 db    0
.xdata$x:00007960                 db    0
.xdata$x:00007961                 db    0
.xdata$x:00007962                 db    0
.xdata$x:00007963                 db    0
.xdata$x:00007963 _xdata$x        ends
.xdata$x:00007963
.xdata$x:00007964 ; ===========================================================================
.xdata$x:00007964
.xdata$x:00007964 ; Segment type: Pure data
.xdata$x:00007964 ; Segment permissions: Read
.xdata$x:00007964 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007964                 assume cs:_xdata$x
.xdata$x:00007964                 ;org 7964h
.xdata$x:00007964 ; COMDAT (pick associative to section at 1F18)
.xdata$x:00007964 __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z db 0FFh
.xdata$x:00007964                                         ; DATA XREF: .xdata$x:0000798Co
.xdata$x:00007965                 db 0FFh
.xdata$x:00007966                 db 0FFh
.xdata$x:00007967                 db 0FFh
.xdata$x:00007968                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z$0
.xdata$x:0000796C                 align 10h
.xdata$x:00007970                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z$1
.xdata$x:00007974                 db    1
.xdata$x:00007975                 db    0
.xdata$x:00007976                 db    0
.xdata$x:00007977                 db    0
.xdata$x:00007978                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z$2
.xdata$x:0000797C                 db    2
.xdata$x:0000797D                 db    0
.xdata$x:0000797E                 db    0
.xdata$x:0000797F                 db    0
.xdata$x:00007980                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z$3
.xdata$x:00007984 __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z db  22h ; "
.xdata$x:00007984                                         ; DATA XREF: __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z+11o
.xdata$x:00007985                 db    5
.xdata$x:00007986                 db  93h ; 
.xdata$x:00007987                 db  19h
.xdata$x:00007988                 db    4
.xdata$x:00007989                 db    0
.xdata$x:0000798A                 db    0
.xdata$x:0000798B                 db    0
.xdata$x:0000798C                 dd offset __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@@?$vector@UTreeStateNode@@V?$allocator@UTreeStateNode@@@std@@@std@@IAEPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@1@0PAU2@@Z
.xdata$x:00007990                 db    0
.xdata$x:00007991                 db    0
.xdata$x:00007992                 db    0
.xdata$x:00007993                 db    0
.xdata$x:00007994                 db    0
.xdata$x:00007995                 db    0
.xdata$x:00007996                 db    0
.xdata$x:00007997                 db    0
.xdata$x:00007998                 db    0
.xdata$x:00007999                 db    0
.xdata$x:0000799A                 db    0
.xdata$x:0000799B                 db    0
.xdata$x:0000799C                 db    0
.xdata$x:0000799D                 db    0
.xdata$x:0000799E                 db    0
.xdata$x:0000799F                 db    0
.xdata$x:000079A0                 db    0
.xdata$x:000079A1                 db    0
.xdata$x:000079A2                 db    0
.xdata$x:000079A3                 db    0
.xdata$x:000079A4                 db    0
.xdata$x:000079A5                 db    0
.xdata$x:000079A6                 db    0
.xdata$x:000079A7                 db    0
.xdata$x:000079A7 _xdata$x        ends
.xdata$x:000079A7
.xdata$x:000079A8 ; ===========================================================================
.xdata$x:000079A8
.xdata$x:000079A8 ; Segment type: Pure data
.xdata$x:000079A8 ; Segment permissions: Read
.xdata$x:000079A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000079A8                 assume cs:_xdata$x
.xdata$x:000079A8                 ;org 79A8h
.xdata$x:000079A8 ; COMDAT (pick associative to section at 2360)
.xdata$x:000079A8 __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z db 0FFh
.xdata$x:000079A8                                         ; DATA XREF: .xdata$x:000079D0o
.xdata$x:000079A9                 db 0FFh
.xdata$x:000079AA                 db 0FFh
.xdata$x:000079AB                 db 0FFh
.xdata$x:000079AC                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z$0
.xdata$x:000079B0                 db    0
.xdata$x:000079B1                 db    0
.xdata$x:000079B2                 db    0
.xdata$x:000079B3                 db    0
.xdata$x:000079B4                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z$1
.xdata$x:000079B8                 db    1
.xdata$x:000079B9                 db    0
.xdata$x:000079BA                 db    0
.xdata$x:000079BB                 db    0
.xdata$x:000079BC                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z$2
.xdata$x:000079C0                 db    1
.xdata$x:000079C1                 db    0
.xdata$x:000079C2                 db    0
.xdata$x:000079C3                 db    0
.xdata$x:000079C4                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z$3
.xdata$x:000079C8 __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z db  22h ; "
.xdata$x:000079C8                                         ; DATA XREF: __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z+11o
.xdata$x:000079C9                 db    5
.xdata$x:000079CA                 db  93h ; 
.xdata$x:000079CB                 db  19h
.xdata$x:000079CC                 db    4
.xdata$x:000079CD                 db    0
.xdata$x:000079CE                 db    0
.xdata$x:000079CF                 db    0
.xdata$x:000079D0                 dd offset __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@PAUTreeStateNode@@U?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@2@@std@@YAPAUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@@Z
.xdata$x:000079D4                 db    0
.xdata$x:000079D5                 db    0
.xdata$x:000079D6                 db    0
.xdata$x:000079D7                 db    0
.xdata$x:000079D8                 db    0
.xdata$x:000079D9                 db    0
.xdata$x:000079DA                 db    0
.xdata$x:000079DB                 db    0
.xdata$x:000079DC                 db    0
.xdata$x:000079DD                 db    0
.xdata$x:000079DE                 db    0
.xdata$x:000079DF                 db    0
.xdata$x:000079E0                 db    0
.xdata$x:000079E1                 db    0
.xdata$x:000079E2                 db    0
.xdata$x:000079E3                 db    0
.xdata$x:000079E4                 db    0
.xdata$x:000079E5                 db    0
.xdata$x:000079E6                 db    0
.xdata$x:000079E7                 db    0
.xdata$x:000079E8                 db    0
.xdata$x:000079E9                 db    0
.xdata$x:000079EA                 db    0
.xdata$x:000079EB                 db    0
.xdata$x:000079EB _xdata$x        ends
.xdata$x:000079EB
.xdata$x:000079EC ; ===========================================================================
.xdata$x:000079EC
.xdata$x:000079EC ; Segment type: Pure data
.xdata$x:000079EC ; Segment permissions: Read
.xdata$x:000079EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000079EC                 assume cs:_xdata$x
.xdata$x:000079EC                 ;org 79ECh
.xdata$x:000079EC ; COMDAT (pick associative to section at 2054)
.xdata$x:000079EC __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z db 0FFh
.xdata$x:000079EC                                         ; DATA XREF: .xdata$x:000079FCo
.xdata$x:000079ED                 db 0FFh
.xdata$x:000079EE                 db 0FFh
.xdata$x:000079EF                 db 0FFh
.xdata$x:000079F0                 dd offset __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z$0
.xdata$x:000079F4 __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z db  22h ; "
.xdata$x:000079F4                                         ; DATA XREF: __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z+11o
.xdata$x:000079F5                 db    5
.xdata$x:000079F6                 db  93h ; 
.xdata$x:000079F7                 db  19h
.xdata$x:000079F8                 db    1
.xdata$x:000079F9                 db    0
.xdata$x:000079FA                 db    0
.xdata$x:000079FB                 db    0
.xdata$x:000079FC                 dd offset __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@std@@YAPBUTreeStateNode@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTreeStateNode@@@std@@@std@@@0@@Z
.xdata$x:00007A00                 db    0
.xdata$x:00007A01                 db    0
.xdata$x:00007A02                 db    0
.xdata$x:00007A03                 db    0
.xdata$x:00007A04                 db    0
.xdata$x:00007A05                 db    0
.xdata$x:00007A06                 db    0
.xdata$x:00007A07                 db    0
.xdata$x:00007A08                 db    0
.xdata$x:00007A09                 db    0
.xdata$x:00007A0A                 db    0
.xdata$x:00007A0B                 db    0
.xdata$x:00007A0C                 db    0
.xdata$x:00007A0D                 db    0
.xdata$x:00007A0E                 db    0
.xdata$x:00007A0F                 db    0
.xdata$x:00007A10                 db    0
.xdata$x:00007A11                 db    0
.xdata$x:00007A12                 db    0
.xdata$x:00007A13                 db    0
.xdata$x:00007A14                 db    0
.xdata$x:00007A15                 db    0
.xdata$x:00007A16                 db    0
.xdata$x:00007A17                 db    0
.xdata$x:00007A17 _xdata$x        ends
.xdata$x:00007A17
.xdata$x:00007A18 ; ===========================================================================
.xdata$x:00007A18
.xdata$x:00007A18 ; Segment type: Pure data
.xdata$x:00007A18 ; Segment permissions: Read
.xdata$x:00007A18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007A18                 assume cs:_xdata$x
.xdata$x:00007A18                 ;org 7A18h
.xdata$x:00007A18 ; COMDAT (pick associative to section at 2108)
.xdata$x:00007A18 __catchsym$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:00007A18                                         ; DATA XREF: .xdata$x:00007A48o
.xdata$x:00007A19                 db    0
.xdata$x:00007A1A                 db    0
.xdata$x:00007A1B                 db    0
.xdata$x:00007A1C                 db    0
.xdata$x:00007A1D                 db    0
.xdata$x:00007A1E                 db    0
.xdata$x:00007A1F                 db    0
.xdata$x:00007A20                 db    0
.xdata$x:00007A21                 db    0
.xdata$x:00007A22                 db    0
.xdata$x:00007A23                 db    0
.xdata$x:00007A24                 dd offset __catch$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:00007A28 __unwindtable$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:00007A28                                         ; DATA XREF: .xdata$x:00007A54o
.xdata$x:00007A29                 db 0FFh
.xdata$x:00007A2A                 db 0FFh
.xdata$x:00007A2B                 db 0FFh
.xdata$x:00007A2C                 db    0
.xdata$x:00007A2D                 db    0
.xdata$x:00007A2E                 db    0
.xdata$x:00007A2F                 db    0
.xdata$x:00007A30                 db 0FFh
.xdata$x:00007A31                 db 0FFh
.xdata$x:00007A32                 db 0FFh
.xdata$x:00007A33                 db 0FFh
.xdata$x:00007A34                 db    0
.xdata$x:00007A35                 db    0
.xdata$x:00007A36                 db    0
.xdata$x:00007A37                 db    0
.xdata$x:00007A38 __tryblocktable$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:00007A38                                         ; DATA XREF: .xdata$x:00007A5Co
.xdata$x:00007A39                 db    0
.xdata$x:00007A3A                 db    0
.xdata$x:00007A3B                 db    0
.xdata$x:00007A3C                 db    0
.xdata$x:00007A3D                 db    0
.xdata$x:00007A3E                 db    0
.xdata$x:00007A3F                 db    0
.xdata$x:00007A40                 db    1
.xdata$x:00007A41                 db    0
.xdata$x:00007A42                 db    0
.xdata$x:00007A43                 db    0
.xdata$x:00007A44                 db    1
.xdata$x:00007A45                 db    0
.xdata$x:00007A46                 db    0
.xdata$x:00007A47                 db    0
.xdata$x:00007A48                 dd offset __catchsym$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:00007A4C __ehfuncinfo$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:00007A4C                                         ; DATA XREF: __ehhandler$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:00007A4D                 db    5
.xdata$x:00007A4E                 db  93h ; 
.xdata$x:00007A4F                 db  19h
.xdata$x:00007A50                 db    2
.xdata$x:00007A51                 db    0
.xdata$x:00007A52                 db    0
.xdata$x:00007A53                 db    0
.xdata$x:00007A54                 dd offset __unwindtable$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00007A58                 db    1
.xdata$x:00007A59                 db    0
.xdata$x:00007A5A                 db    0
.xdata$x:00007A5B                 db    0
.xdata$x:00007A5C                 dd offset __tryblocktable$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00007A60                 db    0
.xdata$x:00007A61                 db    0
.xdata$x:00007A62                 db    0
.xdata$x:00007A63                 db    0
.xdata$x:00007A64                 db    0
.xdata$x:00007A65                 db    0
.xdata$x:00007A66                 db    0
.xdata$x:00007A67                 db    0
.xdata$x:00007A68                 db    0
.xdata$x:00007A69                 db    0
.xdata$x:00007A6A                 db    0
.xdata$x:00007A6B                 db    0
.xdata$x:00007A6C                 db    0
.xdata$x:00007A6D                 db    0
.xdata$x:00007A6E                 db    0
.xdata$x:00007A6F                 db    0
.xdata$x:00007A6F _xdata$x        ends
.xdata$x:00007A6F
.bss:00007A70 ; ===========================================================================
.bss:00007A70
.bss:00007A70 ; Segment type: Uninitialized
.bss:00007A70 ; Segment permissions: Read/Write
.bss:00007A70 _bss            segment byte public 'BSS' use32
.bss:00007A70                 assume cs:_bss
.bss:00007A70                 ;org 7A70h
.bss:00007A70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00007A70 _allocator_arg  db    ? ;
.bss:00007A71 _piecewise_construct db    ? ;
.bss:00007A72                 align 4
.bss:00007A72 _bss            ends
.bss:00007A72
.rdata:00007A74 ; ===========================================================================
.rdata:00007A74
.rdata:00007A74 ; Segment type: Pure data
.rdata:00007A74 ; Segment permissions: Read
.rdata:00007A74 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007A74 _rdata          segment para public 'DATA' use32
.rdata:00007A74                 assume cs:_rdata
.rdata:00007A74                 ;org 7A74h
.rdata:00007A74 ; COMDAT (pick any)
.rdata:00007A74                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00007A74 ; wchar_t `string'
.rdata:00007A74 ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00007A74                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+48o
.rdata:00007A74                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00007A74                 unicode 0, <clude\xutility>,0
.rdata:00007A74 _rdata          ends
.rdata:00007A74
.rdata:00007B04 ; ===========================================================================
.rdata:00007B04
.rdata:00007B04 ; Segment type: Pure data
.rdata:00007B04 ; Segment permissions: Read
.rdata:00007B04 _rdata          segment dword public 'DATA' use32
.rdata:00007B04                 assume cs:_rdata
.rdata:00007B04                 ;org 7B04h
.rdata:00007B04 ; COMDAT (pick any)
.rdata:00007B04                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:00007B04 ; wchar_t `string'
.rdata:00007B04 ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:00007B04                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:00007B04                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:00007B36                 align 4
.rdata:00007B36 _rdata          ends
.rdata:00007B36
.rdata:00007B38 ; ===========================================================================
.rdata:00007B38
.rdata:00007B38 ; Segment type: Pure data
.rdata:00007B38 ; Segment permissions: Read
.rdata:00007B38 _rdata          segment dword public 'DATA' use32
.rdata:00007B38                 assume cs:_rdata
.rdata:00007B38                 ;org 7B38h
.rdata:00007B38 ; COMDAT (pick largest)
.rdata:00007B38                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00007B3C                 public ??_7error_category@std@@6B@
.rdata:00007B3C ; const std::error_category::`vftable'
.rdata:00007B3C ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00007B3C                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00007B3C                                         ; std::error_category::~error_category(void)+Ao
.rdata:00007B3C                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00007B40                 dd offset __purecall
.rdata:00007B44                 dd offset __purecall
.rdata:00007B48                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00007B4C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00007B50                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00007B50 _rdata          ends
.rdata:00007B50
.rdata:00007B54 ; ===========================================================================
.rdata:00007B54
.rdata:00007B54 ; Segment type: Pure data
.rdata:00007B54 ; Segment permissions: Read
.rdata:00007B54 _rdata          segment dword public 'DATA' use32
.rdata:00007B54                 assume cs:_rdata
.rdata:00007B54                 ;org 7B54h
.rdata:00007B54 ; COMDAT (pick largest)
.rdata:00007B54                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00007B58                 public ??_7_Generic_error_category@std@@6B@
.rdata:00007B58 ; const std::_Generic_error_category::`vftable'
.rdata:00007B58 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00007B58                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00007B58                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00007B5C                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00007B60                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00007B64                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00007B68                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00007B6C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00007B6C _rdata          ends
.rdata:00007B6C
.rdata:00007B70 ; ===========================================================================
.rdata:00007B70
.rdata:00007B70 ; Segment type: Pure data
.rdata:00007B70 ; Segment permissions: Read
.rdata:00007B70 _rdata          segment dword public 'DATA' use32
.rdata:00007B70                 assume cs:_rdata
.rdata:00007B70                 ;org 7B70h
.rdata:00007B70 ; COMDAT (pick any)
.rdata:00007B70                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00007B70 ; `string'
.rdata:00007B70 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00007B70                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00007B70 _rdata          ends
.rdata:00007B70
.rdata:00007B78 ; ===========================================================================
.rdata:00007B78
.rdata:00007B78 ; Segment type: Pure data
.rdata:00007B78 ; Segment permissions: Read
.rdata:00007B78 _rdata          segment dword public 'DATA' use32
.rdata:00007B78                 assume cs:_rdata
.rdata:00007B78                 ;org 7B78h
.rdata:00007B78 ; COMDAT (pick any)
.rdata:00007B78                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00007B78 ; `string'
.rdata:00007B78 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00007B78                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_66B8o
.rdata:00007B78                                         ; std::_System_error_category::message(int):loc_6834o
.rdata:00007B86                 align 4
.rdata:00007B86 _rdata          ends
.rdata:00007B86
.rdata:00007B88 ; ===========================================================================
.rdata:00007B88
.rdata:00007B88 ; Segment type: Pure data
.rdata:00007B88 ; Segment permissions: Read
.rdata:00007B88 _rdata          segment dword public 'DATA' use32
.rdata:00007B88                 assume cs:_rdata
.rdata:00007B88                 ;org 7B88h
.rdata:00007B88 ; COMDAT (pick largest)
.rdata:00007B88                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00007B8C                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00007B8C ; const std::_Iostream_error_category::`vftable'
.rdata:00007B8C ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00007B8C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00007B8C                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00007B90                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00007B94                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00007B98                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00007B9C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00007BA0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00007BA0 _rdata          ends
.rdata:00007BA0
.rdata:00007BA4 ; ===========================================================================
.rdata:00007BA4
.rdata:00007BA4 ; Segment type: Pure data
.rdata:00007BA4 ; Segment permissions: Read
.rdata:00007BA4 _rdata          segment dword public 'DATA' use32
.rdata:00007BA4                 assume cs:_rdata
.rdata:00007BA4                 ;org 7BA4h
.rdata:00007BA4 ; COMDAT (pick any)
.rdata:00007BA4                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00007BA4 ; `string'
.rdata:00007BA4 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00007BA4                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00007BAD                 align 10h
.rdata:00007BAD _rdata          ends
.rdata:00007BAD
.rdata:00007BB0 ; ===========================================================================
.rdata:00007BB0
.rdata:00007BB0 ; Segment type: Pure data
.rdata:00007BB0 ; Segment permissions: Read
.rdata:00007BB0 _rdata          segment dword public 'DATA' use32
.rdata:00007BB0                 assume cs:_rdata
.rdata:00007BB0                 ;org 7BB0h
.rdata:00007BB0 ; COMDAT (pick any)
.rdata:00007BB0                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00007BB0 ; char `string'[]
.rdata:00007BB0 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00007BB0                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00007BC6                 align 4
.rdata:00007BC6 _rdata          ends
.rdata:00007BC6
.rdata:00007BC8 ; ===========================================================================
.rdata:00007BC8
.rdata:00007BC8 ; Segment type: Pure data
.rdata:00007BC8 ; Segment permissions: Read
.rdata:00007BC8 _rdata          segment dword public 'DATA' use32
.rdata:00007BC8                 assume cs:_rdata
.rdata:00007BC8                 ;org 7BC8h
.rdata:00007BC8 ; COMDAT (pick largest)
.rdata:00007BC8                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00007BCC                 public ??_7_System_error_category@std@@6B@
.rdata:00007BCC ; const std::_System_error_category::`vftable'
.rdata:00007BCC ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00007BCC                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00007BCC                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00007BD0                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00007BD4                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00007BD8                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00007BDC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00007BE0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00007BE0 _rdata          ends
.rdata:00007BE0
.rdata:00007BE4 ; ===========================================================================
.rdata:00007BE4
.rdata:00007BE4 ; Segment type: Pure data
.rdata:00007BE4 ; Segment permissions: Read
.rdata:00007BE4 _rdata          segment dword public 'DATA' use32
.rdata:00007BE4                 assume cs:_rdata
.rdata:00007BE4                 ;org 7BE4h
.rdata:00007BE4 ; COMDAT (pick any)
.rdata:00007BE4                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00007BE4 ; `string'
.rdata:00007BE4 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00007BE4                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00007BEB                 align 4
.rdata:00007BEB _rdata          ends
.rdata:00007BEB
.bss:00007BEC ; ===========================================================================
.bss:00007BEC
.bss:00007BEC ; Segment type: Uninitialized
.bss:00007BEC ; Segment permissions: Read/Write
.bss:00007BEC _bss            segment dword public 'BSS' use32
.bss:00007BEC                 assume cs:_bss
.bss:00007BEC                 ;org 7BECh
.bss:00007BEC ; COMDAT (pick any)
.bss:00007BEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00007BEC                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00007BEC ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00007BEC ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00007BEC                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00007BEC                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00007BED                 db    ? ;
.bss:00007BEE                 db    ? ;
.bss:00007BEF                 db    ? ;
.bss:00007BEF _bss            ends
.bss:00007BEF
.bss:00007BF0 ; ===========================================================================
.bss:00007BF0
.bss:00007BF0 ; Segment type: Uninitialized
.bss:00007BF0 ; Segment permissions: Read/Write
.bss:00007BF0 _bss            segment dword public 'BSS' use32
.bss:00007BF0                 assume cs:_bss
.bss:00007BF0                 ;org 7BF0h
.bss:00007BF0 ; COMDAT (pick any)
.bss:00007BF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00007BF0                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00007BF0 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00007BF0 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00007BF0                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00007BF0                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00007BF1                 db    ? ;
.bss:00007BF2                 db    ? ;
.bss:00007BF3                 db    ? ;
.bss:00007BF3 _bss            ends
.bss:00007BF3
.bss:00007BF4 ; ===========================================================================
.bss:00007BF4
.bss:00007BF4 ; Segment type: Uninitialized
.bss:00007BF4 ; Segment permissions: Read/Write
.bss:00007BF4 _bss            segment dword public 'BSS' use32
.bss:00007BF4                 assume cs:_bss
.bss:00007BF4                 ;org 7BF4h
.bss:00007BF4 ; COMDAT (pick any)
.bss:00007BF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00007BF4                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00007BF4 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00007BF4 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00007BF4                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00007BF4                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00007BF5                 db    ? ;
.bss:00007BF6                 db    ? ;
.bss:00007BF7                 db    ? ;
.bss:00007BF7 _bss            ends
.bss:00007BF7
.rdata:00007BF8 ; ===========================================================================
.rdata:00007BF8
.rdata:00007BF8 ; Segment type: Pure data
.rdata:00007BF8 ; Segment permissions: Read
.rdata:00007BF8 _rdata          segment dword public 'DATA' use32
.rdata:00007BF8                 assume cs:_rdata
.rdata:00007BF8                 ;org 7BF8h
.rdata:00007BF8 ; COMDAT (pick any)
.rdata:00007BF8                 public ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
.rdata:00007BF8 ; public: static unsigned int const std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::npos
.rdata:00007BF8 ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB dd 0FFFFFFFFh
.rdata:00007BF8                                         ; DATA XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+150r
.rdata:00007BF8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Br ...
.rdata:00007BF8 _rdata          ends
.rdata:00007BF8
.bss:00007BFC ; ===========================================================================
.bss:00007BFC
.bss:00007BFC ; Segment type: Uninitialized
.bss:00007BFC ; Segment permissions: Read/Write
.bss:00007BFC _bss            segment dword public 'BSS' use32
.bss:00007BFC                 assume cs:_bss
.bss:00007BFC                 ;org 7BFCh
.bss:00007BFC ; COMDAT (pick any)
.bss:00007BFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00007BFC                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00007BFC ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00007BFC ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00007BFC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00007BFD                 db    ? ;
.bss:00007BFE                 db    ? ;
.bss:00007BFF                 db    ? ;
.bss:00007BFF _bss            ends
.bss:00007BFF
.bss:00007C00 ; ===========================================================================
.bss:00007C00
.bss:00007C00 ; Segment type: Uninitialized
.bss:00007C00 ; Segment permissions: Read/Write
.bss:00007C00 _bss            segment dword public 'BSS' use32
.bss:00007C00                 assume cs:_bss
.bss:00007C00                 ;org 7C00h
.bss:00007C00 ; COMDAT (pick any)
.bss:00007C00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00007C00                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00007C00 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00007C00 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00007C00                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00007C01                 db    ? ;
.bss:00007C02                 db    ? ;
.bss:00007C03                 db    ? ;
.bss:00007C03 _bss            ends
.bss:00007C03
.rdata:00007C04 ; ===========================================================================
.rdata:00007C04
.rdata:00007C04 ; Segment type: Pure data
.rdata:00007C04 ; Segment permissions: Read
.rdata:00007C04 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007C04 _rdata          segment para public 'DATA' use32
.rdata:00007C04                 assume cs:_rdata
.rdata:00007C04                 ;org 7C04h
.rdata:00007C04 ; COMDAT (pick any)
.rdata:00007C04                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00007C04 ; wchar_t `string'
.rdata:00007C04 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00007C04                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00007C04                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o ...
.rdata:00007C04                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00007C04                 unicode 0, <clude\xstring>,0
.rdata:00007C92                 align 4
.rdata:00007C92 _rdata          ends
.rdata:00007C92
.bss:00007C94 ; ===========================================================================
.bss:00007C94
.bss:00007C94 ; Segment type: Uninitialized
.bss:00007C94 ; Segment permissions: Read/Write
.bss:00007C94 _bss            segment dword public 'BSS' use32
.bss:00007C94                 assume cs:_bss
.bss:00007C94                 ;org 7C94h
.bss:00007C94 ; COMDAT (pick any)
.bss:00007C94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00007C94                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00007C94 ; std::locale::id std::numpunct<char>::id
.bss:00007C94 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00007C94                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00007C95                 db    ? ;
.bss:00007C96                 db    ? ;
.bss:00007C97                 db    ? ;
.bss:00007C97 _bss            ends
.bss:00007C97
.bss:00007C98 ; ===========================================================================
.bss:00007C98
.bss:00007C98 ; Segment type: Uninitialized
.bss:00007C98 ; Segment permissions: Read/Write
.bss:00007C98 _bss            segment dword public 'BSS' use32
.bss:00007C98                 assume cs:_bss
.bss:00007C98                 ;org 7C98h
.bss:00007C98 ; COMDAT (pick any)
.bss:00007C98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00007C98                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00007C98 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00007C98 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00007C98                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00007C99                 db    ? ;
.bss:00007C9A                 db    ? ;
.bss:00007C9B                 db    ? ;
.bss:00007C9B _bss            ends
.bss:00007C9B
.rdata:00007C9C ; ===========================================================================
.rdata:00007C9C
.rdata:00007C9C ; Segment type: Pure data
.rdata:00007C9C ; Segment permissions: Read
.rdata:00007C9C ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007C9C _rdata          segment para public 'DATA' use32
.rdata:00007C9C                 assume cs:_rdata
.rdata:00007C9C                 ;org 7C9Ch
.rdata:00007C9C ; COMDAT (pick any)
.rdata:00007C9C                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00007C9C ; wchar_t `string'
.rdata:00007C9C ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00007C9C                                         ; DATA XREF: std::vector<int,std::allocator<int>>::operator[](uint)+19o
.rdata:00007C9C                                         ; std::vector<int,std::allocator<int>>::operator[](uint)+49o ...
.rdata:00007C9C                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00007C9C                 unicode 0, <clude\vector>,0
.rdata:00007C9C _rdata          ends
.rdata:00007C9C
.rdata:00007D28 ; ===========================================================================
.rdata:00007D28
.rdata:00007D28 ; Segment type: Pure data
.rdata:00007D28 ; Segment permissions: Read
.rdata:00007D28 _rdata          segment dword public 'DATA' use32
.rdata:00007D28                 assume cs:_rdata
.rdata:00007D28                 ;org 7D28h
.rdata:00007D28 ; COMDAT (pick any)
.rdata:00007D28                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:00007D28 ; wchar_t `string'
.rdata:00007D28 ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:00007D28                                         ; DATA XREF: std::vector<int,std::allocator<int>>::operator[](uint)+1Eo
.rdata:00007D28                 unicode 0, <vector subscript out of range>,0
.rdata:00007D28 _rdata          ends
.rdata:00007D28
.rdata:00007D64 ; ===========================================================================
.rdata:00007D64
.rdata:00007D64 ; Segment type: Pure data
.rdata:00007D64 ; Segment permissions: Read
.rdata:00007D64 _rdata          segment dword public 'DATA' use32
.rdata:00007D64                 assume cs:_rdata
.rdata:00007D64                 ;org 7D64h
.rdata:00007D64 ; COMDAT (pick any)
.rdata:00007D64                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:00007D64 ; `string'
.rdata:00007D64 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:00007D64                                         ; DATA XREF: std::vector<int,std::allocator<int>>::operator[](uint)+2Bo
.rdata:00007D64 _rdata          ends
.rdata:00007D64
.rdata:00007D88 ; ===========================================================================
.rdata:00007D88
.rdata:00007D88 ; Segment type: Pure data
.rdata:00007D88 ; Segment permissions: Read
.rdata:00007D88 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007D88 _rdata          segment para public 'DATA' use32
.rdata:00007D88                 assume cs:_rdata
.rdata:00007D88                 ;org 7D88h
.rdata:00007D88 ; COMDAT (pick any)
.rdata:00007D88                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:00007D88 ; `string'
.rdata:00007D88 ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:00007D88                                         ; DATA XREF: std::vector<int,std::allocator<int>>::operator[](uint):loc_4250o
.rdata:00007D88                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:00007DDE                 align 10h
.rdata:00007DDE _rdata          ends
.rdata:00007DDE
.rdata:00007DE0 ; ===========================================================================
.rdata:00007DE0
.rdata:00007DE0 ; Segment type: Pure data
.rdata:00007DE0 ; Segment permissions: Read
.rdata:00007DE0 _rdata          segment dword public 'DATA' use32
.rdata:00007DE0                 assume cs:_rdata
.rdata:00007DE0                 ;org 7DE0h
.rdata:00007DE0 ; COMDAT (pick any)
.rdata:00007DE0                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:00007DE0 ; `string'
.rdata:00007DE0 ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:00007DE0                                         ; DATA XREF: std::vector<int,std::allocator<int>>::operator[](uint)+3Do
.rdata:00007DE0                 unicode 0, <%s>,0
.rdata:00007DE6                 align 4
.rdata:00007DE6 _rdata          ends
.rdata:00007DE6
.rdata:00007DE8 ; ===========================================================================
.rdata:00007DE8
.rdata:00007DE8 ; Segment type: Pure data
.rdata:00007DE8 ; Segment permissions: Read
.rdata:00007DE8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007DE8 _rdata          segment para public 'DATA' use32
.rdata:00007DE8                 assume cs:_rdata
.rdata:00007DE8                 ;org 7DE8h
.rdata:00007DE8 ; COMDAT (pick any)
.rdata:00007DE8                 public ??_C@_1HC@HBCEAHKD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAi?$AAn?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAa?$AAl?$AAl?$AAo?$AAc@
.rdata:00007DE8 ; `string'
.rdata:00007DE8 ??_C@_1HC@HBCEAHKD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAi?$AAn?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAa?$AAl?$AAl?$AAo?$AAc@:
.rdata:00007DE8                                         ; DATA XREF: std::vector<int,std::allocator<int>>::operator[](uint)+6Ao
.rdata:00007DE8                 unicode 0, <std::vector>
.rdata:00007DE8                 dw 3Ch
.rdata:00007DE8                 unicode 0, <int,class std::allocator>
.rdata:00007DE8                 dw 3Ch
.rdata:00007DE8                 unicode 0, <int>
.rdata:00007DE8                 dw 3Eh
.rdata:00007DE8                 unicode 0, < >
.rdata:00007DE8                 dw 3Eh
.rdata:00007DE8                 unicode 0, <::operator []>,0
.rdata:00007E5A                 align 4
.rdata:00007E5A _rdata          ends
.rdata:00007E5A
.rdata:00007E5C ; ===========================================================================
.rdata:00007E5C
.rdata:00007E5C ; Segment type: Pure data
.rdata:00007E5C ; Segment permissions: Read
.rdata:00007E5C _rdata          segment dword public 'DATA' use32
.rdata:00007E5C                 assume cs:_rdata
.rdata:00007E5C                 ;org 7E5Ch
.rdata:00007E5C ; COMDAT (pick any)
.rdata:00007E5C                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:00007E5C ; `string'
.rdata:00007E5C ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:00007E5C                                         ; DATA XREF: std::vector<int,std::allocator<int>>::operator[](uint)+6Fo
.rdata:00007E5C                 unicode 0, <"out of range">,0
.rdata:00007E7A                 align 4
.rdata:00007E7A _rdata          ends
.rdata:00007E7A
.rdata:00007E7C ; ===========================================================================
.rdata:00007E7C
.rdata:00007E7C ; Segment type: Pure data
.rdata:00007E7C ; Segment permissions: Read
.rdata:00007E7C _rdata          segment dword public 'DATA' use32
.rdata:00007E7C                 assume cs:_rdata
.rdata:00007E7C                 ;org 7E7Ch
.rdata:00007E7C ; COMDAT (pick any)
.rdata:00007E7C                 public ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
.rdata:00007E7C ; char `string'[]
.rdata:00007E7C ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ db 'invalid vector<T> subscript',0
.rdata:00007E7C                                         ; DATA XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Xran(void)+7o
.rdata:00007E7C _rdata          ends
.rdata:00007E7C
.rdata:00007E98 ; ===========================================================================
.rdata:00007E98
.rdata:00007E98 ; Segment type: Pure data
.rdata:00007E98 ; Segment permissions: Read
.rdata:00007E98 _rdata          segment dword public 'DATA' use32
.rdata:00007E98                 assume cs:_rdata
.rdata:00007E98                 ;org 7E98h
.rdata:00007E98 ; COMDAT (pick any)
.rdata:00007E98                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00007E98 ; char `string'[]
.rdata:00007E98 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00007E98                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00007E98                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:00007E98 _rdata          ends
.rdata:00007E98
.rdata:00007EA8 ; ===========================================================================
.rdata:00007EA8
.rdata:00007EA8 ; Segment type: Pure data
.rdata:00007EA8 ; Segment permissions: Read
.rdata:00007EA8 _rdata          segment dword public 'DATA' use32
.rdata:00007EA8                 assume cs:_rdata
.rdata:00007EA8                 ;org 7EA8h
.rdata:00007EA8 ; COMDAT (pick any)
.rdata:00007EA8                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00007EA8 ; char `string'[]
.rdata:00007EA8 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00007EA8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00007EA8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:00007EA8 _rdata          ends
.rdata:00007EA8
.rdata:00007EC0 ; ===========================================================================
.rdata:00007EC0
.rdata:00007EC0 ; Segment type: Pure data
.rdata:00007EC0 ; Segment permissions: Read
.rdata:00007EC0 _rdata          segment dword public 'DATA' use32
.rdata:00007EC0                 assume cs:_rdata
.rdata:00007EC0                 ;org 7EC0h
.rdata:00007EC0 ; COMDAT (pick any)
.rdata:00007EC0                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:00007EC0 ; char `string'[]
.rdata:00007EC0 ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:00007EC0                                         ; DATA XREF: std::vector<TreeStateNode,std::allocator<TreeStateNode>>::_Xlen(void)+7o
.rdata:00007ED3                 align 4
.rdata:00007ED3 _rdata          ends
.rdata:00007ED3
.rdata:00007ED4 ; ===========================================================================
.rdata:00007ED4
.rdata:00007ED4 ; Segment type: Pure data
.rdata:00007ED4 ; Segment permissions: Read
.rdata:00007ED4 _rdata          segment dword public 'DATA' use32
.rdata:00007ED4                 assume cs:_rdata
.rdata:00007ED4                 ;org 7ED4h
.rdata:00007ED4 ; COMDAT (pick any)
.rdata:00007ED4                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00007ED4 ; wchar_t `string'
.rdata:00007ED4 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00007ED4                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00007ED4                                         ; std::_Debug_pointer<TreeStateNode>(TreeStateNode *,wchar_t const *,uint)+11o ...
.rdata:00007ED4                 unicode 0, <invalid null pointer>,0
.rdata:00007EFE                 align 10h
.rdata:00007EFE _rdata          ends
.rdata:00007EFE
.rdata:00007F00 ; ===========================================================================
.rdata:00007F00
.rdata:00007F00 ; Segment type: Pure data
.rdata:00007F00 ; Segment permissions: Read
.rdata:00007F00 _rdata          segment dword public 'DATA' use32
.rdata:00007F00                 assume cs:_rdata
.rdata:00007F00                 ;org 7F00h
.rdata:00007F00 ; COMDAT (pick any)
.rdata:00007F00                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:00007F00 ; wchar_t `string'
.rdata:00007F00 ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:00007F00                                         ; DATA XREF: std::_Debug_range2<TreeStateNode *>(TreeStateNode *,TreeStateNode *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:00007F00                                         ; std::_Debug_range2<TreeStateNode const *>(TreeStateNode const *,TreeStateNode const *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:00007F00                 unicode 0, <invalid iterator range>,0
.rdata:00007F2E                 align 10h
.rdata:00007F2E _rdata          ends
.rdata:00007F2E
.rdata:00007F30 ; ===========================================================================
.rdata:00007F30
.rdata:00007F30 ; Segment type: Pure data
.rdata:00007F30 ; Segment permissions: Read
.rdata:00007F30 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007F30 _rdata          segment para public 'DATA' use32
.rdata:00007F30                 assume cs:_rdata
.rdata:00007F30                 ;org 7F30h
.rdata:00007F30 ; COMDAT (pick any)
.rdata:00007F30                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00007F30 ; wchar_t `string'
.rdata:00007F30 ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00007F30                                         ; DATA XREF: std::_Uninit_copy<TreeStateNode const *,TreeStateNode *,std::allocator<TreeStateNode>>(TreeStateNode const *,TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag)+2Fo
.rdata:00007F30                                         ; std::_Uninit_copy<TreeStateNode const *,TreeStateNode *,std::allocator<TreeStateNode>>(TreeStateNode const *,TreeStateNode const *,TreeStateNode *,std::_Wrap_alloc<std::allocator<TreeStateNode>> &,std::_Nonscalar_ptr_iterator_tag)+49o ...
.rdata:00007F30                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00007F30                 unicode 0, <clude\xmemory>,0
.rdata:00007FBE                 align 10h
.rdata:00007FBE _rdata          ends
.rdata:00007FBE
.rdata$r:00007FC0 ; ===========================================================================
.rdata$r:00007FC0
.rdata$r:00007FC0 ; Segment type: Pure data
.rdata$r:00007FC0 ; Segment permissions: Read
.rdata$r:00007FC0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007FC0                 assume cs:_rdata$r
.rdata$r:00007FC0                 ;org 7FC0h
.rdata$r:00007FC0 ; COMDAT (pick any)
.rdata$r:00007FC0                 public ??_R4error_category@std@@6B@
.rdata$r:00007FC0 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00007FC0 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00007B38o
.rdata$r:00007FC1                 db    0
.rdata$r:00007FC2                 db    0
.rdata$r:00007FC3                 db    0
.rdata$r:00007FC4                 db    0
.rdata$r:00007FC5                 db    0
.rdata$r:00007FC6                 db    0
.rdata$r:00007FC7                 db    0
.rdata$r:00007FC8                 db    0
.rdata$r:00007FC9                 db    0
.rdata$r:00007FCA                 db    0
.rdata$r:00007FCB                 db    0
.rdata$r:00007FCC                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00007FD0                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007FD0 _rdata$r        ends
.rdata$r:00007FD0
.data$r:00007FD4 ; ===========================================================================
.data$r:00007FD4
.data$r:00007FD4 ; Segment type: Pure data
.data$r:00007FD4 ; Segment permissions: Read/Write
.data$r:00007FD4 _data$r         segment dword public 'DATA' use32
.data$r:00007FD4                 assume cs:_data$r
.data$r:00007FD4                 ;org 7FD4h
.data$r:00007FD4 ; COMDAT (pick any)
.data$r:00007FD4                 public ??_R0?AVerror_category@std@@@8
.data$r:00007FD4 ; class std::error_category `RTTI Type Descriptor'
.data$r:00007FD4 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00007FD4                                         ; DATA XREF: .rdata$r:00007FCCo
.data$r:00007FD4                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00007FD4                                         ; const type_info::`vftable'
.data$r:00007FD8                 db    0
.data$r:00007FD9                 db    0
.data$r:00007FDA                 db    0
.data$r:00007FDB                 db    0
.data$r:00007FDC                 db  2Eh ; .
.data$r:00007FDD                 db  3Fh ; ?
.data$r:00007FDE                 db  41h ; A
.data$r:00007FDF                 db  56h ; V
.data$r:00007FE0                 db  65h ; e
.data$r:00007FE1                 db  72h ; r
.data$r:00007FE2                 db  72h ; r
.data$r:00007FE3                 db  6Fh ; o
.data$r:00007FE4                 db  72h ; r
.data$r:00007FE5                 db  5Fh ; _
.data$r:00007FE6                 db  63h ; c
.data$r:00007FE7                 db  61h ; a
.data$r:00007FE8                 db  74h ; t
.data$r:00007FE9                 db  65h ; e
.data$r:00007FEA                 db  67h ; g
.data$r:00007FEB                 db  6Fh ; o
.data$r:00007FEC                 db  72h ; r
.data$r:00007FED                 db  79h ; y
.data$r:00007FEE                 db  40h ; @
.data$r:00007FEF                 db  73h ; s
.data$r:00007FF0                 db  74h ; t
.data$r:00007FF1                 db  64h ; d
.data$r:00007FF2                 db  40h ; @
.data$r:00007FF3                 db  40h ; @
.data$r:00007FF4                 db    0
.data$r:00007FF5                 align 4
.data$r:00007FF5 _data$r         ends
.data$r:00007FF5
.rdata$r:00007FF8 ; ===========================================================================
.rdata$r:00007FF8
.rdata$r:00007FF8 ; Segment type: Pure data
.rdata$r:00007FF8 ; Segment permissions: Read
.rdata$r:00007FF8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007FF8                 assume cs:_rdata$r
.rdata$r:00007FF8                 ;org 7FF8h
.rdata$r:00007FF8 ; COMDAT (pick any)
.rdata$r:00007FF8                 public ??_R3error_category@std@@8
.rdata$r:00007FF8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007FF8 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00007FD0o
.rdata$r:00007FF8                                         ; .rdata$r:00008028o
.rdata$r:00007FF9                 db    0
.rdata$r:00007FFA                 db    0
.rdata$r:00007FFB                 db    0
.rdata$r:00007FFC                 db    0
.rdata$r:00007FFD                 db    0
.rdata$r:00007FFE                 db    0
.rdata$r:00007FFF                 db    0
.rdata$r:00008000                 db    1
.rdata$r:00008001                 db    0
.rdata$r:00008002                 db    0
.rdata$r:00008003                 db    0
.rdata$r:00008004                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00008004 _rdata$r        ends
.rdata$r:00008004
.rdata$r:00008008 ; ===========================================================================
.rdata$r:00008008
.rdata$r:00008008 ; Segment type: Pure data
.rdata$r:00008008 ; Segment permissions: Read
.rdata$r:00008008 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008008                 assume cs:_rdata$r
.rdata$r:00008008                 ;org 8008h
.rdata$r:00008008 ; COMDAT (pick any)
.rdata$r:00008008                 public ??_R2error_category@std@@8
.rdata$r:00008008 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00008008 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00008008                                         ; DATA XREF: .rdata$r:00008004o
.rdata$r:00008008                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000800C                 db    0
.rdata$r:0000800D                 align 10h
.rdata$r:0000800D _rdata$r        ends
.rdata$r:0000800D
.rdata$r:00008010 ; ===========================================================================
.rdata$r:00008010
.rdata$r:00008010 ; Segment type: Pure data
.rdata$r:00008010 ; Segment permissions: Read
.rdata$r:00008010 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008010                 assume cs:_rdata$r
.rdata$r:00008010                 ;org 8010h
.rdata$r:00008010 ; COMDAT (pick any)
.rdata$r:00008010                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00008010 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00008010 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00008010                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00008010                                         ; .rdata$r:00008080o ...
.rdata$r:00008010                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00008014                 db    0
.rdata$r:00008015                 db    0
.rdata$r:00008016                 db    0
.rdata$r:00008017                 db    0
.rdata$r:00008018                 db    0
.rdata$r:00008019                 db    0
.rdata$r:0000801A                 db    0
.rdata$r:0000801B                 db    0
.rdata$r:0000801C                 db 0FFh
.rdata$r:0000801D                 db 0FFh
.rdata$r:0000801E                 db 0FFh
.rdata$r:0000801F                 db 0FFh
.rdata$r:00008020                 db    0
.rdata$r:00008021                 db    0
.rdata$r:00008022                 db    0
.rdata$r:00008023                 db    0
.rdata$r:00008024                 db  40h ; @
.rdata$r:00008025                 db    0
.rdata$r:00008026                 db    0
.rdata$r:00008027                 db    0
.rdata$r:00008028                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008028 _rdata$r        ends
.rdata$r:00008028
.rdata$r:0000802C ; ===========================================================================
.rdata$r:0000802C
.rdata$r:0000802C ; Segment type: Pure data
.rdata$r:0000802C ; Segment permissions: Read
.rdata$r:0000802C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000802C                 assume cs:_rdata$r
.rdata$r:0000802C                 ;org 802Ch
.rdata$r:0000802C ; COMDAT (pick any)
.rdata$r:0000802C                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:0000802C ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:0000802C ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:0000802C                                         ; DATA XREF: .rdata:00007B54o
.rdata$r:0000802D                 db    0
.rdata$r:0000802E                 db    0
.rdata$r:0000802F                 db    0
.rdata$r:00008030                 db    0
.rdata$r:00008031                 db    0
.rdata$r:00008032                 db    0
.rdata$r:00008033                 db    0
.rdata$r:00008034                 db    0
.rdata$r:00008035                 db    0
.rdata$r:00008036                 db    0
.rdata$r:00008037                 db    0
.rdata$r:00008038                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000803C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000803C _rdata$r        ends
.rdata$r:0000803C
.data$r:00008040 ; ===========================================================================
.data$r:00008040
.data$r:00008040 ; Segment type: Pure data
.data$r:00008040 ; Segment permissions: Read/Write
.data$r:00008040 _data$r         segment dword public 'DATA' use32
.data$r:00008040                 assume cs:_data$r
.data$r:00008040                 ;org 8040h
.data$r:00008040 ; COMDAT (pick any)
.data$r:00008040                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00008040 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00008040 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00008040                                         ; DATA XREF: .rdata$r:00008038o
.data$r:00008040                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00008040                                         ; const type_info::`vftable'
.data$r:00008044                 align 8
.data$r:00008048 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:0000806A                 align 4
.data$r:0000806A _data$r         ends
.data$r:0000806A
.rdata$r:0000806C ; ===========================================================================
.rdata$r:0000806C
.rdata$r:0000806C ; Segment type: Pure data
.rdata$r:0000806C ; Segment permissions: Read
.rdata$r:0000806C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000806C                 assume cs:_rdata$r
.rdata$r:0000806C                 ;org 806Ch
.rdata$r:0000806C ; COMDAT (pick any)
.rdata$r:0000806C                 public ??_R3_Generic_error_category@std@@8
.rdata$r:0000806C ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000806C ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:0000806C                                         ; DATA XREF: .rdata$r:0000803Co
.rdata$r:0000806C                                         ; .rdata$r:000080A0o
.rdata$r:0000806D                 db    0
.rdata$r:0000806E                 db    0
.rdata$r:0000806F                 db    0
.rdata$r:00008070                 db    0
.rdata$r:00008071                 db    0
.rdata$r:00008072                 db    0
.rdata$r:00008073                 db    0
.rdata$r:00008074                 db    2
.rdata$r:00008075                 db    0
.rdata$r:00008076                 db    0
.rdata$r:00008077                 db    0
.rdata$r:00008078                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00008078 _rdata$r        ends
.rdata$r:00008078
.rdata$r:0000807C ; ===========================================================================
.rdata$r:0000807C
.rdata$r:0000807C ; Segment type: Pure data
.rdata$r:0000807C ; Segment permissions: Read
.rdata$r:0000807C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000807C                 assume cs:_rdata$r
.rdata$r:0000807C                 ;org 807Ch
.rdata$r:0000807C ; COMDAT (pick any)
.rdata$r:0000807C                 public ??_R2_Generic_error_category@std@@8
.rdata$r:0000807C ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000807C ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000807C                                         ; DATA XREF: .rdata$r:00008078o
.rdata$r:0000807C                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008080                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008084                 db    0
.rdata$r:00008085                 align 4
.rdata$r:00008085 _rdata$r        ends
.rdata$r:00008085
.rdata$r:00008088 ; ===========================================================================
.rdata$r:00008088
.rdata$r:00008088 ; Segment type: Pure data
.rdata$r:00008088 ; Segment permissions: Read
.rdata$r:00008088 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008088                 assume cs:_rdata$r
.rdata$r:00008088                 ;org 8088h
.rdata$r:00008088 ; COMDAT (pick any)
.rdata$r:00008088                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00008088 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00008088 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00008088                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00008088                                         ; .rdata$r:000080F8o ...
.rdata$r:00008088                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000808C                 db    1
.rdata$r:0000808D                 db    0
.rdata$r:0000808E                 db    0
.rdata$r:0000808F                 db    0
.rdata$r:00008090                 db    0
.rdata$r:00008091                 db    0
.rdata$r:00008092                 db    0
.rdata$r:00008093                 db    0
.rdata$r:00008094                 db 0FFh
.rdata$r:00008095                 db 0FFh
.rdata$r:00008096                 db 0FFh
.rdata$r:00008097                 db 0FFh
.rdata$r:00008098                 db    0
.rdata$r:00008099                 db    0
.rdata$r:0000809A                 db    0
.rdata$r:0000809B                 db    0
.rdata$r:0000809C                 db  40h ; @
.rdata$r:0000809D                 db    0
.rdata$r:0000809E                 db    0
.rdata$r:0000809F                 db    0
.rdata$r:000080A0                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000080A0 _rdata$r        ends
.rdata$r:000080A0
.rdata$r:000080A4 ; ===========================================================================
.rdata$r:000080A4
.rdata$r:000080A4 ; Segment type: Pure data
.rdata$r:000080A4 ; Segment permissions: Read
.rdata$r:000080A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000080A4                 assume cs:_rdata$r
.rdata$r:000080A4                 ;org 80A4h
.rdata$r:000080A4 ; COMDAT (pick any)
.rdata$r:000080A4                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:000080A4 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:000080A4 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:000080A4                                         ; DATA XREF: .rdata:00007B88o
.rdata$r:000080A5                 db    0
.rdata$r:000080A6                 db    0
.rdata$r:000080A7                 db    0
.rdata$r:000080A8                 db    0
.rdata$r:000080A9                 db    0
.rdata$r:000080AA                 db    0
.rdata$r:000080AB                 db    0
.rdata$r:000080AC                 db    0
.rdata$r:000080AD                 db    0
.rdata$r:000080AE                 db    0
.rdata$r:000080AF                 db    0
.rdata$r:000080B0                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000080B4                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000080B4 _rdata$r        ends
.rdata$r:000080B4
.data$r:000080B8 ; ===========================================================================
.data$r:000080B8
.data$r:000080B8 ; Segment type: Pure data
.data$r:000080B8 ; Segment permissions: Read/Write
.data$r:000080B8 _data$r         segment dword public 'DATA' use32
.data$r:000080B8                 assume cs:_data$r
.data$r:000080B8                 ;org 80B8h
.data$r:000080B8 ; COMDAT (pick any)
.data$r:000080B8                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:000080B8 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:000080B8 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000080B8                                         ; DATA XREF: .rdata$r:000080B0o
.data$r:000080B8                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000080B8                                         ; const type_info::`vftable'
.data$r:000080BC                 align 10h
.data$r:000080C0 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:000080E3                 align 4
.data$r:000080E3 _data$r         ends
.data$r:000080E3
.rdata$r:000080E4 ; ===========================================================================
.rdata$r:000080E4
.rdata$r:000080E4 ; Segment type: Pure data
.rdata$r:000080E4 ; Segment permissions: Read
.rdata$r:000080E4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000080E4                 assume cs:_rdata$r
.rdata$r:000080E4                 ;org 80E4h
.rdata$r:000080E4 ; COMDAT (pick any)
.rdata$r:000080E4                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:000080E4 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000080E4 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:000080E4                                         ; DATA XREF: .rdata$r:000080B4o
.rdata$r:000080E4                                         ; .rdata$r:0000811Co
.rdata$r:000080E5                 db    0
.rdata$r:000080E6                 db    0
.rdata$r:000080E7                 db    0
.rdata$r:000080E8                 db    0
.rdata$r:000080E9                 db    0
.rdata$r:000080EA                 db    0
.rdata$r:000080EB                 db    0
.rdata$r:000080EC                 db    3
.rdata$r:000080ED                 db    0
.rdata$r:000080EE                 db    0
.rdata$r:000080EF                 db    0
.rdata$r:000080F0                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000080F0 _rdata$r        ends
.rdata$r:000080F0
.rdata$r:000080F4 ; ===========================================================================
.rdata$r:000080F4
.rdata$r:000080F4 ; Segment type: Pure data
.rdata$r:000080F4 ; Segment permissions: Read
.rdata$r:000080F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000080F4                 assume cs:_rdata$r
.rdata$r:000080F4                 ;org 80F4h
.rdata$r:000080F4 ; COMDAT (pick any)
.rdata$r:000080F4                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:000080F4 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000080F4 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000080F4                                         ; DATA XREF: .rdata$r:000080F0o
.rdata$r:000080F4                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000080F8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000080FC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008100                 db    0
.rdata$r:00008101                 align 4
.rdata$r:00008101 _rdata$r        ends
.rdata$r:00008101
.rdata$r:00008104 ; ===========================================================================
.rdata$r:00008104
.rdata$r:00008104 ; Segment type: Pure data
.rdata$r:00008104 ; Segment permissions: Read
.rdata$r:00008104 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008104                 assume cs:_rdata$r
.rdata$r:00008104                 ;org 8104h
.rdata$r:00008104 ; COMDAT (pick any)
.rdata$r:00008104                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00008104 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00008104 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00008104                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00008104                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00008108                 db    2
.rdata$r:00008109                 db    0
.rdata$r:0000810A                 db    0
.rdata$r:0000810B                 db    0
.rdata$r:0000810C                 db    0
.rdata$r:0000810D                 db    0
.rdata$r:0000810E                 db    0
.rdata$r:0000810F                 db    0
.rdata$r:00008110                 db 0FFh
.rdata$r:00008111                 db 0FFh
.rdata$r:00008112                 db 0FFh
.rdata$r:00008113                 db 0FFh
.rdata$r:00008114                 db    0
.rdata$r:00008115                 db    0
.rdata$r:00008116                 db    0
.rdata$r:00008117                 db    0
.rdata$r:00008118                 db  40h ; @
.rdata$r:00008119                 db    0
.rdata$r:0000811A                 db    0
.rdata$r:0000811B                 db    0
.rdata$r:0000811C                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000811C _rdata$r        ends
.rdata$r:0000811C
.rdata$r:00008120 ; ===========================================================================
.rdata$r:00008120
.rdata$r:00008120 ; Segment type: Pure data
.rdata$r:00008120 ; Segment permissions: Read
.rdata$r:00008120 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008120                 assume cs:_rdata$r
.rdata$r:00008120                 ;org 8120h
.rdata$r:00008120 ; COMDAT (pick any)
.rdata$r:00008120                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00008120 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00008120 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00007BC8o
.rdata$r:00008121                 db    0
.rdata$r:00008122                 db    0
.rdata$r:00008123                 db    0
.rdata$r:00008124                 db    0
.rdata$r:00008125                 db    0
.rdata$r:00008126                 db    0
.rdata$r:00008127                 db    0
.rdata$r:00008128                 db    0
.rdata$r:00008129                 db    0
.rdata$r:0000812A                 db    0
.rdata$r:0000812B                 db    0
.rdata$r:0000812C                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00008130                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008130 _rdata$r        ends
.rdata$r:00008130
.data$r:00008134 ; ===========================================================================
.data$r:00008134
.data$r:00008134 ; Segment type: Pure data
.data$r:00008134 ; Segment permissions: Read/Write
.data$r:00008134 _data$r         segment dword public 'DATA' use32
.data$r:00008134                 assume cs:_data$r
.data$r:00008134                 ;org 8134h
.data$r:00008134 ; COMDAT (pick any)
.data$r:00008134                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00008134 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00008134 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00008134                                         ; DATA XREF: .rdata$r:0000812Co
.data$r:00008134                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00008134                                         ; const type_info::`vftable'
.data$r:00008138                 db    0
.data$r:00008139                 db    0
.data$r:0000813A                 db    0
.data$r:0000813B                 db    0
.data$r:0000813C                 db  2Eh ; .
.data$r:0000813D                 db  3Fh ; ?
.data$r:0000813E                 db  41h ; A
.data$r:0000813F                 db  56h ; V
.data$r:00008140                 db  5Fh ; _
.data$r:00008141                 db  53h ; S
.data$r:00008142                 db  79h ; y
.data$r:00008143                 db  73h ; s
.data$r:00008144                 db  74h ; t
.data$r:00008145                 db  65h ; e
.data$r:00008146                 db  6Dh ; m
.data$r:00008147                 db  5Fh ; _
.data$r:00008148                 db  65h ; e
.data$r:00008149                 db  72h ; r
.data$r:0000814A                 db  72h ; r
.data$r:0000814B                 db  6Fh ; o
.data$r:0000814C                 db  72h ; r
.data$r:0000814D                 db  5Fh ; _
.data$r:0000814E                 db  63h ; c
.data$r:0000814F                 db  61h ; a
.data$r:00008150                 db  74h ; t
.data$r:00008151                 db  65h ; e
.data$r:00008152                 db  67h ; g
.data$r:00008153                 db  6Fh ; o
.data$r:00008154                 db  72h ; r
.data$r:00008155                 db  79h ; y
.data$r:00008156                 db  40h ; @
.data$r:00008157                 db  73h ; s
.data$r:00008158                 db  74h ; t
.data$r:00008159                 db  64h ; d
.data$r:0000815A                 db  40h ; @
.data$r:0000815B                 db  40h ; @
.data$r:0000815C                 db    0
.data$r:0000815D                 align 10h
.data$r:0000815D _data$r         ends
.data$r:0000815D
.rdata$r:00008160 ; ===========================================================================
.rdata$r:00008160
.rdata$r:00008160 ; Segment type: Pure data
.rdata$r:00008160 ; Segment permissions: Read
.rdata$r:00008160 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008160                 assume cs:_rdata$r
.rdata$r:00008160                 ;org 8160h
.rdata$r:00008160 ; COMDAT (pick any)
.rdata$r:00008160                 public ??_R3_System_error_category@std@@8
.rdata$r:00008160 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008160 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00008130o
.rdata$r:00008160                                         ; .rdata$r:00008198o
.rdata$r:00008161                 db    0
.rdata$r:00008162                 db    0
.rdata$r:00008163                 db    0
.rdata$r:00008164                 db    0
.rdata$r:00008165                 db    0
.rdata$r:00008166                 db    0
.rdata$r:00008167                 db    0
.rdata$r:00008168                 db    3
.rdata$r:00008169                 db    0
.rdata$r:0000816A                 db    0
.rdata$r:0000816B                 db    0
.rdata$r:0000816C                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000816C _rdata$r        ends
.rdata$r:0000816C
.rdata$r:00008170 ; ===========================================================================
.rdata$r:00008170
.rdata$r:00008170 ; Segment type: Pure data
.rdata$r:00008170 ; Segment permissions: Read
.rdata$r:00008170 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008170                 assume cs:_rdata$r
.rdata$r:00008170                 ;org 8170h
.rdata$r:00008170 ; COMDAT (pick any)
.rdata$r:00008170                 public ??_R2_System_error_category@std@@8
.rdata$r:00008170 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00008170 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00008170                                         ; DATA XREF: .rdata$r:0000816Co
.rdata$r:00008170                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008174                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008178                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000817C                 db    0
.rdata$r:0000817D                 align 10h
.rdata$r:0000817D _rdata$r        ends
.rdata$r:0000817D
.rdata$r:00008180 ; ===========================================================================
.rdata$r:00008180
.rdata$r:00008180 ; Segment type: Pure data
.rdata$r:00008180 ; Segment permissions: Read
.rdata$r:00008180 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008180                 assume cs:_rdata$r
.rdata$r:00008180                 ;org 8180h
.rdata$r:00008180 ; COMDAT (pick any)
.rdata$r:00008180                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00008180 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00008180 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00008180                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00008180                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00008184                 db    2
.rdata$r:00008185                 db    0
.rdata$r:00008186                 db    0
.rdata$r:00008187                 db    0
.rdata$r:00008188                 db    0
.rdata$r:00008189                 db    0
.rdata$r:0000818A                 db    0
.rdata$r:0000818B                 db    0
.rdata$r:0000818C                 db 0FFh
.rdata$r:0000818D                 db 0FFh
.rdata$r:0000818E                 db 0FFh
.rdata$r:0000818F                 db 0FFh
.rdata$r:00008190                 db    0
.rdata$r:00008191                 db    0
.rdata$r:00008192                 db    0
.rdata$r:00008193                 db    0
.rdata$r:00008194                 db  40h ; @
.rdata$r:00008195                 db    0
.rdata$r:00008196                 db    0
.rdata$r:00008197                 db    0
.rdata$r:00008198                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008198 _rdata$r        ends
.rdata$r:00008198
.CRT$XCU:0000819C ; ===========================================================================
.CRT$XCU:0000819C
.CRT$XCU:0000819C ; Segment type: Pure data
.CRT$XCU:0000819C ; Segment permissions: Read
.CRT$XCU:0000819C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000819C                 assume cs:_CRT$XCU
.CRT$XCU:0000819C                 ;org 819Ch
.CRT$XCU:0000819C _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:000081A0 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:000081A0 _CRT$XCU        ends
.CRT$XCU:000081A0
.CRT$XCU:000081A4 ; ===========================================================================
.CRT$XCU:000081A4
.CRT$XCU:000081A4 ; Segment type: Pure data
.CRT$XCU:000081A4 ; Segment permissions: Read
.CRT$XCU:000081A4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000081A4                 assume cs:_CRT$XCU
.CRT$XCU:000081A4                 ;org 81A4h
.CRT$XCU:000081A4 ; COMDAT (pick associative to section at 7BEC)
.CRT$XCU:000081A4 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:000081A4 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:000081A4 _CRT$XCU        ends
.CRT$XCU:000081A4
.CRT$XCU:000081A8 ; ===========================================================================
.CRT$XCU:000081A8
.CRT$XCU:000081A8 ; Segment type: Pure data
.CRT$XCU:000081A8 ; Segment permissions: Read
.CRT$XCU:000081A8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000081A8                 assume cs:_CRT$XCU
.CRT$XCU:000081A8                 ;org 81A8h
.CRT$XCU:000081A8 ; COMDAT (pick associative to section at 7BF0)
.CRT$XCU:000081A8 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:000081A8 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:000081A8 _CRT$XCU        ends
.CRT$XCU:000081A8
.CRT$XCU:000081AC ; ===========================================================================
.CRT$XCU:000081AC
.CRT$XCU:000081AC ; Segment type: Pure data
.CRT$XCU:000081AC ; Segment permissions: Read
.CRT$XCU:000081AC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000081AC                 assume cs:_CRT$XCU
.CRT$XCU:000081AC                 ;org 81ACh
.CRT$XCU:000081AC ; COMDAT (pick associative to section at 7BF4)
.CRT$XCU:000081AC ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:000081AC ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:000081AC _CRT$XCU        ends
.CRT$XCU:000081AC
.CRT$XCU:000081B0 ; ===========================================================================
.CRT$XCU:000081B0
.CRT$XCU:000081B0 ; Segment type: Pure data
.CRT$XCU:000081B0 ; Segment permissions: Read
.CRT$XCU:000081B0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000081B0                 assume cs:_CRT$XCU
.CRT$XCU:000081B0                 ;org 81B0h
.CRT$XCU:000081B0 ; COMDAT (pick associative to section at 7BFC)
.CRT$XCU:000081B0 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:000081B0 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:000081B0 _CRT$XCU        ends
.CRT$XCU:000081B0
.CRT$XCU:000081B4 ; ===========================================================================
.CRT$XCU:000081B4
.CRT$XCU:000081B4 ; Segment type: Pure data
.CRT$XCU:000081B4 ; Segment permissions: Read
.CRT$XCU:000081B4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000081B4                 assume cs:_CRT$XCU
.CRT$XCU:000081B4                 ;org 81B4h
.CRT$XCU:000081B4 ; COMDAT (pick associative to section at 7C00)
.CRT$XCU:000081B4 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:000081B4 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:000081B4 _CRT$XCU        ends
.CRT$XCU:000081B4
.CRT$XCU:000081B8 ; ===========================================================================
.CRT$XCU:000081B8
.CRT$XCU:000081B8 ; Segment type: Pure data
.CRT$XCU:000081B8 ; Segment permissions: Read
.CRT$XCU:000081B8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000081B8                 assume cs:_CRT$XCU
.CRT$XCU:000081B8                 ;org 81B8h
.CRT$XCU:000081B8 ; COMDAT (pick associative to section at 7C94)
.CRT$XCU:000081B8 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:000081B8 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:000081B8 _CRT$XCU        ends
.CRT$XCU:000081B8
.CRT$XCU:000081BC ; ===========================================================================
.CRT$XCU:000081BC
.CRT$XCU:000081BC ; Segment type: Pure data
.CRT$XCU:000081BC ; Segment permissions: Read
.CRT$XCU:000081BC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000081BC                 assume cs:_CRT$XCU
.CRT$XCU:000081BC                 ;org 81BCh
.CRT$XCU:000081BC ; COMDAT (pick associative to section at 7C98)
.CRT$XCU:000081BC ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:000081BC ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:000081BC _CRT$XCU        ends
.CRT$XCU:000081BC
UNDEF:000081C0 ; ===========================================================================
UNDEF:000081C0
UNDEF:000081C0 ; Segment type: Externs
UNDEF:000081C0 ; UNDEF
UNDEF:000081C0                 extrn __purecall:near   ; DATA XREF: .rdata:00007B40o
UNDEF:000081C0                                         ; .rdata:00007B44o
UNDEF:000081C4 ; void *__cdecl operator new(unsigned int)
UNDEF:000081C4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: TreeView::addItem(wchar_t const *,_TREEITEM *,int,wchar_t const *)+5Bp
UNDEF:000081C4                                         ; TreeView::setItemParam(_TREEITEM *,wchar_t const *)+62p ...
UNDEF:000081C8 ; void __cdecl operator delete(void *)
UNDEF:000081C8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z$0+4p
UNDEF:000081C8                                         ; __unwindfunclet$?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z$0+4p ...
UNDEF:000081CC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:000081CC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:000081CC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:000081D0                 extrn __invalid_parameter:near
UNDEF:000081D0                                         ; CODE XREF: std::vector<int,std::allocator<int>>::operator[](uint)+74p
UNDEF:000081D4 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:000081D4                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:000081D4                                         ; _wmemcpy+11p
UNDEF:000081D8 ; size_t __cdecl strlen(const char *Str)
UNDEF:000081D8                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:000081DC ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:000081DC                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:000081DC                                         ; _wmemmove+11p
UNDEF:000081E0 ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:000081E0                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:000081E4 ; int __stdcall lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
UNDEF:000081E4                 extrn __imp__lstrcmpW@8:near
UNDEF:000081E4                                         ; CODE XREF: TreeView::searchSubItemByName(wchar_t const *,_TREEITEM *)+C9p
UNDEF:000081E4                                         ; DATA XREF: TreeView::searchSubItemByName(wchar_t const *,_TREEITEM *)+C9r
UNDEF:000081E8 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000081E8                 extrn __imp__SendMessageW@16:near
UNDEF:000081E8                                         ; CODE XREF: TreeView::init(HINSTANCE__ *,HWND__ *,int)+72p
UNDEF:000081E8                                         ; TreeView::destroy(void)+19p ...
UNDEF:000081EC ; LRESULT __stdcall CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000081EC                 extrn __imp__CallWindowProcW@20:near
UNDEF:000081EC                                         ; CODE XREF: TreeView::runProc(HWND__ *,uint,uint,long)+1Ep
UNDEF:000081EC                                         ; DATA XREF: TreeView::runProc(HWND__ *,uint,uint,long)+1Er
UNDEF:000081F0 ; HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
UNDEF:000081F0                 extrn __imp__CreateWindowExW@48:near
UNDEF:000081F0                                         ; CODE XREF: TreeView::init(HINSTANCE__ *,HWND__ *,int)+56p
UNDEF:000081F0                                         ; DATA XREF: TreeView::init(HINSTANCE__ *,HWND__ *,int)+56r
UNDEF:000081F4 ; BOOL __stdcall DestroyWindow(HWND hWnd)
UNDEF:000081F4                 extrn __imp__DestroyWindow@4:near
UNDEF:000081F4                                         ; CODE XREF: TreeView::destroy(void)+35p
UNDEF:000081F4                                         ; DATA XREF: TreeView::destroy(void)+35r
UNDEF:000081F8 ; HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem)
UNDEF:000081F8                 extrn __imp__GetDlgItem@8:near
UNDEF:000081F8                                         ; CODE XREF: TreeView::init(HINSTANCE__ *,HWND__ *,int)+1Fp
UNDEF:000081F8                                         ; DATA XREF: TreeView::init(HINSTANCE__ *,HWND__ *,int)+1Fr
UNDEF:000081FC ; HWND __stdcall SetCapture(HWND hWnd)
UNDEF:000081FC                 extrn __imp__SetCapture@4:near
UNDEF:000081FC                                         ; CODE XREF: TreeView::beginDrag(tagNMTREEVIEWW *)+88p
UNDEF:000081FC                                         ; DATA XREF: TreeView::beginDrag(tagNMTREEVIEWW *)+88r
UNDEF:00008200 ; BOOL __stdcall ReleaseCapture()
UNDEF:00008200                 extrn __imp__ReleaseCapture@0:near
UNDEF:00008200                                         ; CODE XREF: TreeView::dropItem(void)+6Ap
UNDEF:00008200                                         ; DATA XREF: TreeView::dropItem(void)+6Ar
UNDEF:00008204 ; int __stdcall ShowCursor(BOOL bShow)
UNDEF:00008204                 extrn __imp__ShowCursor@4:near
UNDEF:00008204                                         ; CODE XREF: TreeView::beginDrag(tagNMTREEVIEWW *)+90p
UNDEF:00008204                                         ; TreeView::dropItem(void)+72p
UNDEF:00008204                                         ; DATA XREF: ...
UNDEF:00008208 ; BOOL __stdcall ClientToScreen(HWND hWnd, LPPOINT lpPoint)
UNDEF:00008208                 extrn __imp__ClientToScreen@8:near
UNDEF:00008208                                         ; CODE XREF: TreeView::dragItem(HWND__ *,int,int)+1Fp
UNDEF:00008208                                         ; DATA XREF: TreeView::dragItem(HWND__ *,int,int)+1Fr
UNDEF:0000820C ; BOOL __stdcall ScreenToClient(HWND hWnd, LPPOINT lpPoint)
UNDEF:0000820C                 extrn __imp__ScreenToClient@8:near
UNDEF:0000820C                                         ; CODE XREF: TreeView::dragItem(HWND__ *,int,int)+30p
UNDEF:0000820C                                         ; DATA XREF: TreeView::dragItem(HWND__ *,int,int)+30r
UNDEF:00008210 ; LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex)
UNDEF:00008210                 extrn __imp__GetWindowLongW@8:near
UNDEF:00008210                                         ; CODE XREF: TreeView::staticProc(HWND__ *,uint,uint,long)+19p
UNDEF:00008210                                         ; DATA XREF: TreeView::staticProc(HWND__ *,uint,uint,long)+19r
UNDEF:00008214 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:00008214                 extrn __imp__SetWindowLongW@12:near
UNDEF:00008214                                         ; CODE XREF: TreeView::init(HINSTANCE__ *,HWND__ *,int)+85p
UNDEF:00008214                                         ; TreeView::init(HINSTANCE__ *,HWND__ *,int)+99p
UNDEF:00008214                                         ; DATA XREF: ...
UNDEF:00008218 ; HWND __stdcall GetParent(HWND hWnd)
UNDEF:00008218                 extrn __imp__GetParent@4:near
UNDEF:00008218                                         ; CODE XREF: TreeView::beginDrag(tagNMTREEVIEWW *)+81p
UNDEF:00008218                                         ; DATA XREF: TreeView::beginDrag(tagNMTREEVIEWW *)+81r
UNDEF:0000821C ; BOOL __stdcall ImageList_Destroy(HIMAGELIST himl)
UNDEF:0000821C                 extrn __imp__ImageList_Destroy@4:near
UNDEF:0000821C                                         ; CODE XREF: TreeView::dropItem(void)+64p
UNDEF:0000821C                                         ; DATA XREF: TreeView::dropItem(void)+64r
UNDEF:00008220 ; BOOL __stdcall ImageList_BeginDrag(HIMAGELIST himlTrack, int iTrack, int dxHotspot, int dyHotspot)
UNDEF:00008220                 extrn __imp__ImageList_BeginDrag@16:near
UNDEF:00008220                                         ; CODE XREF: TreeView::beginDrag(tagNMTREEVIEWW *)+59p
UNDEF:00008220                                         ; DATA XREF: TreeView::beginDrag(tagNMTREEVIEWW *)+59r
UNDEF:00008224 ; void __stdcall ImageList_EndDrag()
UNDEF:00008224                 extrn __imp__ImageList_EndDrag@0:near
UNDEF:00008224                                         ; CODE XREF: TreeView::dropItem(void):loc_6E7p
UNDEF:00008224                                         ; DATA XREF: TreeView::dropItem(void):loc_6E7r
UNDEF:00008228 ; BOOL __stdcall ImageList_DragEnter(HWND hwndLock, int x, int y)
UNDEF:00008228                 extrn __imp__ImageList_DragEnter@12:near
UNDEF:00008228                                         ; CODE XREF: TreeView::beginDrag(tagNMTREEVIEWW *)+74p
UNDEF:00008228                                         ; DATA XREF: TreeView::beginDrag(tagNMTREEVIEWW *)+74r
UNDEF:0000822C ; BOOL __stdcall ImageList_DragMove(int x, int y)
UNDEF:0000822C                 extrn __imp__ImageList_DragMove@8:near
UNDEF:0000822C                                         ; CODE XREF: TreeView::dragItem(HWND__ *,int,int)+3Ep
UNDEF:0000822C                                         ; DATA XREF: TreeView::dragItem(HWND__ *,int,int)+3Er
UNDEF:00008230 ; BOOL __stdcall ImageList_DragShowNolock(BOOL fShow)
UNDEF:00008230                 extrn __imp__ImageList_DragShowNolock@4:near
UNDEF:00008230                                         ; CODE XREF: TreeView::dragItem(HWND__ *,int,int)+46p
UNDEF:00008230                                         ; TreeView::dragItem(HWND__ *,int,int)+93p
UNDEF:00008230                                         ; DATA XREF: ...
UNDEF:00008234 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00008234                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00008234                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:00008234                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:00008238 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00008238                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00008238                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:00008238                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:0000823C                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00008240                 extrn __CrtDbgReportW:near
UNDEF:00008240                                         ; CODE XREF: std::vector<int,std::allocator<int>>::operator[](uint)+50p
UNDEF:00008244 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00008244                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00008244                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00008244                                         ; std::_Debug_pointer<TreeStateNode>(TreeStateNode *,wchar_t const *,uint)+16p ...
UNDEF:00008248 ; void __cdecl std::_Xbad_alloc()
UNDEF:00008248                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00008248                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_1C06p
UNDEF:00008248                                         ; std::_Allocate<TreeStateNode>(uint,TreeStateNode *):loc_1C46p ...
UNDEF:0000824C ; void __cdecl std::_Xlength_error(const char *)
UNDEF:0000824C                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:0000824C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:0000824C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp ...
UNDEF:00008250 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00008250                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00008250                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00008250                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp ...
UNDEF:00008254 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00008254                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00008254                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00008258 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00008258                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00008258                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00008258                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:0000825C ; const char *__cdecl std::_Winerror_map(int)
UNDEF:0000825C                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:0000825C                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00008260 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00008260                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00008260                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00008264 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00008264                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00008264                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00008268 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00008268                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00008268                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:0000826C ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl stringToUpper(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>)
UNDEF:0000826C                 extrn ?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z:near
UNDEF:0000826C                                         ; CODE XREF: TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+D4p
UNDEF:0000826C                                         ; TreeView::searchLeafRecusivelyAndBuildTree(_TREEITEM *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,int,_TREEITEM *)+11Ep
UNDEF:00008270 ; __fastcall __security_check_cookie(x)
UNDEF:00008270                 extrn @__security_check_cookie@4:near
UNDEF:00008270                                         ; CODE XREF: TreeView::searchSubItemByName(wchar_t const *,_TREEITEM *)+E7p
UNDEF:00008270                                         ; TreeView::swapTreeViewItem(_TREEITEM *,_TREEITEM *)+3B8p ...
UNDEF:00008274 ; __stdcall _CxxThrowException(x, x)
UNDEF:00008274                 extrn __CxxThrowException@8:near
UNDEF:00008274                                         ; CODE XREF: __catch$??$_Uninit_copy@PBUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@@std@@YAPAUTreeStateNode@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+25p
UNDEF:00008274                                         ; __catch$??$_Uninit_move@PAUTreeStateNode@@PAU1@V?$allocator@UTreeStateNode@@@std@@U1@@std@@YAPAUTreeStateNode@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTreeStateNode@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+25p ...
UNDEF:00008278                 extrn ___CxxFrameHandler3:near
UNDEF:00008278                                         ; CODE XREF: __ehhandler$?addItem@TreeView@@QAEPAU_TREEITEM@@PB_WPAU2@H0@Z+19j
UNDEF:00008278                                         ; __ehhandler$?setItemParam@TreeView@@QAE_NPAU_TREEITEM@@PB_W@Z+16j ...
UNDEF:0000827C ; const type_info::`vftable'
UNDEF:0000827C                 extrn ??_7type_info@@6B@:near
UNDEF:0000827C                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:0000827C                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00008280                 extrn ___security_cookie:near
UNDEF:00008280                                         ; DATA XREF: TreeView::addItem(wchar_t const *,_TREEITEM *,int,wchar_t const *)+16r
UNDEF:00008280                                         ; TreeView::setItemParam(_TREEITEM *,wchar_t const *)+14r ...
UNDEF:00008284                 extrn __fltused:near
UNDEF:00008284
UNDEF:00008284
UNDEF:00008284                 end