.bss:00000000 ;
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.bss:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.bss:00000000 ; |                      License info: 48-3677-7074-51                      |
.bss:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ;
.bss:00000000 ; Input MD5   : 9F525313BC8596E0E75EA62927F0E00A
.bss:00000000 ; Input CRC32 : 0260F609
.bss:00000000
.bss:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\SplitterContainer.obj
.bss:00000000 ; Format      : COFF (X386MAGIC)
.bss:00000000 ; includelib "libcpmtd"
.bss:00000000 ; includelib "uuid.lib"
.bss:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00000000 ; includelib "LIBCMTD"
.bss:00000000 ; includelib "OLDNAMES"
.bss:00000000
.bss:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.bss:00000000
.bss:00000000                 .686p
.bss:00000000                 .mmx
.bss:00000000                 .model flat
.bss:00000000
.bss:00000000 ; ===========================================================================
.bss:00000000
.bss:00000000 ; Segment type: Uninitialized
.bss:00000000 ; Segment permissions: Read/Write
.bss:00000000 _bss            segment byte public 'BSS' use32
.bss:00000000                 assume cs:_bss
.bss:00000000                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00000000                 public ?_isRegistered@SplitterContainer@@0_NA
.bss:00000000 ; private: static bool SplitterContainer::_isRegistered
.bss:00000000 ?_isRegistered@SplitterContainer@@0_NA db ?
.bss:00000000                                         ; DATA XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool):loc_1C4r
.bss:00000000                                         ; SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool):loc_250w
.bss:00000001 _allocator_arg  db    ? ;
.bss:00000002 _piecewise_construct db    ? ;
.bss:00000003                 align 4
.bss:00000003 _bss            ends
.bss:00000003
.rdata:00000004 ; ===========================================================================
.rdata:00000004
.rdata:00000004 ; Segment type: Pure data
.rdata:00000004 ; Segment permissions: Read
.rdata:00000004 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000004 _rdata          segment para public 'DATA' use32
.rdata:00000004                 assume cs:_rdata
.rdata:00000004                 ;org 4
.rdata:00000004 $SG91554:                               ; DATA XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+F5o
.rdata:00000004                 unicode 0, <splitterContainer>,0
.rdata:00000028 ; char _SG91558[]
.rdata:00000028 $SG91558        db ' SplitterContainer::create : RegisterClass() function failed',0
.rdata:00000028                                         ; DATA XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+10Do
.rdata:00000065                 align 4
.rdata:00000068 ; const WCHAR _SG91564
.rdata:00000068 $SG91564:                               ; DATA XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+15Co
.rdata:00000068                 unicode 0, <a koi sert?>,0
.rdata:00000080 ; const WCHAR _SG91565
.rdata:00000080 $SG91565:                               ; DATA XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+161o
.rdata:00000080                 unicode 0, <splitterContainer>,0
.rdata:000000A4 ; char _SG91569[]
.rdata:000000A4 $SG91569        db ' SplitterContainer::create : CreateWindowEx() function return nul'
.rdata:000000A4                                         ; DATA XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+17Do
.rdata:000000A4                 db 'l',0
.rdata:000000E7                 align 4
.rdata:000000E8 ; const WCHAR _SG91629
.rdata:000000E8 $SG91629:                               ; DATA XREF: SplitterContainer::runProc(uint,uint,long)+25Do
.rdata:000000E8                 unicode 0, <Rotate to left>,0
.rdata:00000106                 align 4
.rdata:00000108 ; const WCHAR _SG91630
.rdata:00000108 $SG91630:                               ; DATA XREF: SplitterContainer::runProc(uint,uint,long)+27Bo
.rdata:00000108                 unicode 0, <Rotate to right>,0
.rdata:00000108 _rdata          ends
.rdata:00000108
.text$mn:00000128 ; ===========================================================================
.text$mn:00000128
.text$mn:00000128 ; Segment type: Pure code
.text$mn:00000128 ; Segment permissions: Read/Execute
.text$mn:00000128 _text$mn        segment para public 'CODE' use32
.text$mn:00000128                 assume cs:_text$mn
.text$mn:00000128                 ;org 128h
.text$mn:00000128                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000128
.text$mn:00000128 ; =============== S U B R O U T I N E =======================================
.text$mn:00000128
.text$mn:00000128 ; Attributes: bp-based frame
.text$mn:00000128
.text$mn:00000128 ; public: void __thiscall SplitterContainer::create(class Window *, class Window *, int, enum  SplitterMode, int, bool)
.text$mn:00000128                 public ?create@SplitterContainer@@QAEXPAVWindow@@0HW4SplitterMode@@H_N@Z
.text$mn:00000128 ?create@SplitterContainer@@QAEXPAVWindow@@0HW4SplitterMode@@H_N@Z proc near
.text$mn:00000128
.text$mn:00000128 WndClass        = WNDCLASSW ptr -48h
.text$mn:00000128 var_20          = byte ptr -20h
.text$mn:00000128 var_14          = byte ptr -14h
.text$mn:00000128 var_8           = dword ptr -8
.text$mn:00000128 lpParam         = dword ptr -4
.text$mn:00000128 arg_0           = dword ptr  8
.text$mn:00000128 arg_4           = dword ptr  0Ch
.text$mn:00000128 arg_8           = dword ptr  10h
.text$mn:00000128 arg_C           = dword ptr  14h
.text$mn:00000128 arg_10          = dword ptr  18h
.text$mn:00000128 arg_14          = byte ptr  1Ch
.text$mn:00000128
.text$mn:00000128                 push    ebp
.text$mn:00000129                 mov     ebp, esp
.text$mn:0000012B                 sub     esp, 48h
.text$mn:0000012E                 mov     [ebp+lpParam], ecx
.text$mn:00000131                 mov     eax, [ebp+lpParam]
.text$mn:00000134                 mov     ecx, [ebp+arg_0]
.text$mn:00000137                 mov     [eax+10h], ecx
.text$mn:0000013A                 mov     edx, [ebp+lpParam]
.text$mn:0000013D                 mov     eax, [ebp+arg_4]
.text$mn:00000140                 mov     [edx+14h], eax
.text$mn:00000143                 mov     ecx, [ebp+lpParam]
.text$mn:00000146                 mov     edx, [ebp+arg_8]
.text$mn:00000149                 mov     [ecx+6Ch], edx
.text$mn:0000014C                 mov     eax, [ebp+lpParam]
.text$mn:0000014F                 mov     ecx, [ebp+arg_C]
.text$mn:00000152                 mov     [eax+84h], ecx
.text$mn:00000158                 mov     edx, [ebp+lpParam]
.text$mn:0000015B                 mov     eax, [ebp+arg_10]
.text$mn:0000015E                 mov     [edx+70h], eax
.text$mn:00000161                 movzx   ecx, [ebp+arg_14]
.text$mn:00000165                 test    ecx, ecx
.text$mn:00000167                 jz      short loc_172
.text$mn:00000169                 mov     [ebp+var_8], 2
.text$mn:00000170                 jmp     short loc_179
.text$mn:00000172 ; ---------------------------------------------------------------------------
.text$mn:00000172
.text$mn:00000172 loc_172:                                ; CODE XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+3Fj
.text$mn:00000172                 mov     [ebp+var_8], 1
.text$mn:00000179
.text$mn:00000179 loc_179:                                ; CODE XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+48j
.text$mn:00000179                 mov     edx, [ebp+lpParam]
.text$mn:0000017C                 mov     eax, [edx+80h]
.text$mn:00000182                 or      eax, [ebp+var_8]
.text$mn:00000185                 mov     ecx, [ebp+lpParam]
.text$mn:00000188                 mov     [ecx+80h], eax
.text$mn:0000018E                 mov     edx, [ebp+lpParam]
.text$mn:00000191                 cmp     dword ptr [edx+84h], 0
.text$mn:00000198                 jz      short loc_1C4
.text$mn:0000019A                 mov     eax, [ebp+lpParam]
.text$mn:0000019D                 mov     ecx, [eax+80h]
.text$mn:000001A3                 or      ecx, 4
.text$mn:000001A6                 mov     edx, [ebp+lpParam]
.text$mn:000001A9                 mov     [edx+80h], ecx
.text$mn:000001AF                 mov     eax, [ebp+lpParam]
.text$mn:000001B2                 mov     ecx, [eax+80h]
.text$mn:000001B8                 and     ecx, 0FFFFFFDFh
.text$mn:000001BB                 mov     edx, [ebp+lpParam]
.text$mn:000001BE                 mov     [edx+80h], ecx
.text$mn:000001C4
.text$mn:000001C4 loc_1C4:                                ; CODE XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+70j
.text$mn:000001C4                 movzx   eax, ds:?_isRegistered@SplitterContainer@@0_NA ; bool SplitterContainer::_isRegistered
.text$mn:000001CB                 test    eax, eax
.text$mn:000001CD                 jnz     loc_257
.text$mn:000001D3                 mov     [ebp+WndClass.style], 8
.text$mn:000001DA                 mov     [ebp+WndClass.lpfnWndProc], offset ?staticWinProc@SplitterContainer@@CGJPAUHWND__@@IIJ@Z ; SplitterContainer::staticWinProc(HWND__ *,uint,uint,long)
.text$mn:000001E1                 mov     [ebp+WndClass.cbClsExtra], 0
.text$mn:000001E8                 mov     [ebp+WndClass.cbWndExtra], 0
.text$mn:000001EF                 mov     ecx, [ebp+lpParam]
.text$mn:000001F2                 mov     edx, [ecx+4]
.text$mn:000001F5                 mov     [ebp+WndClass.hInstance], edx
.text$mn:000001F8                 mov     [ebp+WndClass.hIcon], 0
.text$mn:000001FF                 push    7F00h           ; lpCursorName
.text$mn:00000204                 push    0               ; hInstance
.text$mn:00000206                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:0000020C                 mov     [ebp+WndClass.hCursor], eax
.text$mn:0000020F                 mov     [ebp+WndClass.hbrBackground], 0
.text$mn:00000216                 mov     [ebp+WndClass.lpszMenuName], 0
.text$mn:0000021D                 mov     [ebp+WndClass.lpszClassName], offset $SG91554 ; "splitterContainer"
.text$mn:00000224                 lea     eax, [ebp+WndClass]
.text$mn:00000227                 push    eax             ; lpWndClass
.text$mn:00000228                 call    dword ptr ds:__imp__RegisterClassW@4 ; RegisterClassW(x)
.text$mn:0000022E                 movzx   ecx, ax
.text$mn:00000231                 test    ecx, ecx
.text$mn:00000233                 jnz     short loc_250
.text$mn:00000235                 push    offset $SG91558 ; " SplitterContainer::create : RegisterCl"...
.text$mn:0000023A                 lea     ecx, [ebp+var_14] ; this
.text$mn:0000023D                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:00000242                 push    offset __TI2?AVruntime_error@std@@
.text$mn:00000247                 lea     edx, [ebp+var_14]
.text$mn:0000024A                 push    edx
.text$mn:0000024B                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000250 ; ---------------------------------------------------------------------------
.text$mn:00000250
.text$mn:00000250 loc_250:                                ; CODE XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+10Bj
.text$mn:00000250                 mov     ds:?_isRegistered@SplitterContainer@@0_NA, 1 ; bool SplitterContainer::_isRegistered
.text$mn:00000257
.text$mn:00000257 loc_257:                                ; CODE XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+A5j
.text$mn:00000257                 mov     eax, [ebp+lpParam]
.text$mn:0000025A                 push    eax             ; lpParam
.text$mn:0000025B                 mov     ecx, [ebp+lpParam]
.text$mn:0000025E                 mov     edx, [ecx+4]
.text$mn:00000261                 push    edx             ; hInstance
.text$mn:00000262                 push    0               ; hMenu
.text$mn:00000264                 mov     eax, [ebp+lpParam]
.text$mn:00000267                 mov     ecx, [eax+8]
.text$mn:0000026A                 push    ecx             ; hWndParent
.text$mn:0000026B                 push    80000000h       ; nHeight
.text$mn:00000270                 push    80000000h       ; nWidth
.text$mn:00000275                 push    80000000h       ; Y
.text$mn:0000027A                 push    80000000h       ; X
.text$mn:0000027F                 push    42000000h       ; dwStyle
.text$mn:00000284                 push    offset $SG91564 ; "a koi sert?"
.text$mn:00000289                 push    offset $SG91565 ; "splitterContainer"
.text$mn:0000028E                 push    0               ; dwExStyle
.text$mn:00000290                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:00000296                 mov     edx, [ebp+lpParam]
.text$mn:00000299                 mov     [edx+0Ch], eax
.text$mn:0000029C                 mov     eax, [ebp+lpParam]
.text$mn:0000029F                 cmp     dword ptr [eax+0Ch], 0
.text$mn:000002A3                 jnz     short loc_2C0
.text$mn:000002A5                 push    offset $SG91569 ; " SplitterContainer::create : CreateWind"...
.text$mn:000002AA                 lea     ecx, [ebp+var_20] ; this
.text$mn:000002AD                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:000002B2                 push    offset __TI2?AVruntime_error@std@@
.text$mn:000002B7                 lea     ecx, [ebp+var_20]
.text$mn:000002BA                 push    ecx
.text$mn:000002BB                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000002C0 ; ---------------------------------------------------------------------------
.text$mn:000002C0
.text$mn:000002C0 loc_2C0:                                ; CODE XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+17Bj
.text$mn:000002C0                 mov     esp, ebp
.text$mn:000002C2                 pop     ebp
.text$mn:000002C3                 retn    18h
.text$mn:000002C3 ?create@SplitterContainer@@QAEXPAVWindow@@0HW4SplitterMode@@H_N@Z endp
.text$mn:000002C3
.text$mn:000002C3 ; ---------------------------------------------------------------------------
.text$mn:000002C6                 align 4
.text$mn:000002C8
.text$mn:000002C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000002C8
.text$mn:000002C8 ; Attributes: bp-based frame
.text$mn:000002C8
.text$mn:000002C8 ; __int32 __stdcall SplitterContainer::staticWinProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
.text$mn:000002C8                 public ?staticWinProc@SplitterContainer@@CGJPAUHWND__@@IIJ@Z
.text$mn:000002C8 ?staticWinProc@SplitterContainer@@CGJPAUHWND__@@IIJ@Z proc near
.text$mn:000002C8                                         ; DATA XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+B2o
.text$mn:000002C8
.text$mn:000002C8 var_8           = dword ptr -8
.text$mn:000002C8 dwNewLong       = dword ptr -4
.text$mn:000002C8 hWnd            = dword ptr  8
.text$mn:000002C8 Msg             = dword ptr  0Ch
.text$mn:000002C8 wParam          = dword ptr  10h
.text$mn:000002C8 lParam          = dword ptr  14h
.text$mn:000002C8
.text$mn:000002C8                 push    ebp
.text$mn:000002C9                 mov     ebp, esp
.text$mn:000002CB                 sub     esp, 8
.text$mn:000002CE                 mov     [ebp+dwNewLong], 0
.text$mn:000002D5                 mov     eax, [ebp+Msg]
.text$mn:000002D8                 mov     [ebp+var_8], eax
.text$mn:000002DB                 cmp     [ebp+var_8], 81h ; 'ü'
.text$mn:000002E2                 jz      short loc_2E6
.text$mn:000002E4                 jmp     short loc_30E
.text$mn:000002E6 ; ---------------------------------------------------------------------------
.text$mn:000002E6
.text$mn:000002E6 loc_2E6:                                ; CODE XREF: SplitterContainer::staticWinProc(HWND__ *,uint,uint,long)+1Aj
.text$mn:000002E6                 mov     ecx, [ebp+lParam]
.text$mn:000002E9                 mov     edx, [ecx]
.text$mn:000002EB                 mov     [ebp+dwNewLong], edx
.text$mn:000002EE                 mov     eax, [ebp+dwNewLong]
.text$mn:000002F1                 mov     ecx, [ebp+hWnd]
.text$mn:000002F4                 mov     [eax+0Ch], ecx
.text$mn:000002F7                 mov     edx, [ebp+dwNewLong]
.text$mn:000002FA                 push    edx             ; dwNewLong
.text$mn:000002FB                 push    0FFFFFFEBh      ; nIndex
.text$mn:000002FD                 mov     eax, [ebp+hWnd]
.text$mn:00000300                 push    eax             ; hWnd
.text$mn:00000301                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000307                 mov     eax, 1
.text$mn:0000030C                 jmp     short loc_34F
.text$mn:0000030E ; ---------------------------------------------------------------------------
.text$mn:0000030E
.text$mn:0000030E loc_30E:                                ; CODE XREF: SplitterContainer::staticWinProc(HWND__ *,uint,uint,long)+1Cj
.text$mn:0000030E                 push    0FFFFFFEBh      ; nIndex
.text$mn:00000310                 mov     ecx, [ebp+hWnd]
.text$mn:00000313                 push    ecx             ; hWnd
.text$mn:00000314                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:0000031A                 mov     [ebp+dwNewLong], eax
.text$mn:0000031D                 cmp     [ebp+dwNewLong], 0
.text$mn:00000321                 jnz     short loc_33B
.text$mn:00000323                 mov     edx, [ebp+lParam]
.text$mn:00000326                 push    edx             ; lParam
.text$mn:00000327                 mov     eax, [ebp+wParam]
.text$mn:0000032A                 push    eax             ; wParam
.text$mn:0000032B                 mov     ecx, [ebp+Msg]
.text$mn:0000032E                 push    ecx             ; Msg
.text$mn:0000032F                 mov     edx, [ebp+hWnd]
.text$mn:00000332                 push    edx             ; hWnd
.text$mn:00000333                 call    dword ptr ds:__imp__DefWindowProcW@16 ; DefWindowProcW(x,x,x,x)
.text$mn:00000339                 jmp     short loc_34F
.text$mn:0000033B ; ---------------------------------------------------------------------------
.text$mn:0000033B
.text$mn:0000033B loc_33B:                                ; CODE XREF: SplitterContainer::staticWinProc(HWND__ *,uint,uint,long)+59j
.text$mn:0000033B                 mov     eax, [ebp+lParam]
.text$mn:0000033E                 push    eax             ; __int32
.text$mn:0000033F                 mov     ecx, [ebp+wParam]
.text$mn:00000342                 push    ecx             ; wParam
.text$mn:00000343                 mov     edx, [ebp+Msg]
.text$mn:00000346                 push    edx             ; Msg
.text$mn:00000347                 mov     ecx, [ebp+dwNewLong] ; this
.text$mn:0000034A                 call    ?runProc@SplitterContainer@@AAEJIIJ@Z ; SplitterContainer::runProc(uint,uint,long)
.text$mn:0000034F
.text$mn:0000034F loc_34F:                                ; CODE XREF: SplitterContainer::staticWinProc(HWND__ *,uint,uint,long)+44j
.text$mn:0000034F                                         ; SplitterContainer::staticWinProc(HWND__ *,uint,uint,long)+71j
.text$mn:0000034F                 mov     esp, ebp
.text$mn:00000351                 pop     ebp
.text$mn:00000352                 retn    10h
.text$mn:00000352 ?staticWinProc@SplitterContainer@@CGJPAUHWND__@@IIJ@Z endp
.text$mn:00000352
.text$mn:00000352 ; ---------------------------------------------------------------------------
.text$mn:00000355                 align 4
.text$mn:00000358
.text$mn:00000358 ; =============== S U B R O U T I N E =======================================
.text$mn:00000358
.text$mn:00000358 ; Attributes: bp-based frame
.text$mn:00000358
.text$mn:00000358 ; __int32 __thiscall SplitterContainer::runProc(SplitterContainer *this, UINT Msg, WPARAM wParam, __int32)
.text$mn:00000358                 public ?runProc@SplitterContainer@@AAEJIIJ@Z
.text$mn:00000358 ?runProc@SplitterContainer@@AAEJIIJ@Z proc near
.text$mn:00000358                                         ; CODE XREF: SplitterContainer::staticWinProc(HWND__ *,uint,uint,long)+82p
.text$mn:00000358
.text$mn:00000358 var_60          = tagPOINT ptr -60h
.text$mn:00000358 Point           = tagPOINT ptr -58h
.text$mn:00000358 var_50          = tagPOINT ptr -50h
.text$mn:00000358 var_48          = dword ptr -48h
.text$mn:00000358 var_44          = dword ptr -44h
.text$mn:00000358 var_40          = dword ptr -40h
.text$mn:00000358 hWnd            = dword ptr -3Ch
.text$mn:00000358 var_38          = dword ptr -38h
.text$mn:00000358 var_34          = dword ptr -34h
.text$mn:00000358 var_30          = dword ptr -30h
.text$mn:00000358 var_2C          = dword ptr -2Ch
.text$mn:00000358 var_28          = dword ptr -28h
.text$mn:00000358 var_24          = dword ptr -24h
.text$mn:00000358 var_20          = dword ptr -20h
.text$mn:00000358 var_1C          = dword ptr -1Ch
.text$mn:00000358 var_18          = dword ptr -18h
.text$mn:00000358 var_14          = dword ptr -14h
.text$mn:00000358 var_10          = dword ptr -10h
.text$mn:00000358 var_C           = dword ptr -0Ch
.text$mn:00000358 var_8           = dword ptr -8
.text$mn:00000358 var_4           = dword ptr -4
.text$mn:00000358 Msg             = dword ptr  8
.text$mn:00000358 wParam          = dword ptr  0Ch
.text$mn:00000358 lParam          = dword ptr  10h
.text$mn:00000358
.text$mn:00000358                 push    ebp
.text$mn:00000359                 mov     ebp, esp
.text$mn:0000035B                 sub     esp, 60h
.text$mn:0000035E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000363                 xor     eax, ebp
.text$mn:00000365                 mov     [ebp+var_4], eax
.text$mn:00000368                 push    esi
.text$mn:00000369                 mov     [ebp+var_28], ecx
.text$mn:0000036C                 mov     eax, [ebp+Msg]
.text$mn:0000036F                 mov     [ebp+var_2C], eax
.text$mn:00000372                 cmp     [ebp+var_2C], 13A1h
.text$mn:00000379                 ja      short loc_3A9
.text$mn:0000037B                 cmp     [ebp+var_2C], 13A1h
.text$mn:00000382                 jz      loc_61D
.text$mn:00000388                 cmp     [ebp+var_2C], 1
.text$mn:0000038C                 jz      short loc_3D5
.text$mn:0000038E                 cmp     [ebp+var_2C], 111h
.text$mn:00000395                 jz      short loc_410
.text$mn:00000397                 cmp     [ebp+var_2C], 203h
.text$mn:0000039E                 jz      loc_737
.text$mn:000003A4                 jmp     loc_7F1
.text$mn:000003A9 ; ---------------------------------------------------------------------------
.text$mn:000003A9
.text$mn:000003A9 loc_3A9:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+21j
.text$mn:000003A9                 cmp     [ebp+var_2C], 13A2h
.text$mn:000003B0                 jz      loc_6AA
.text$mn:000003B6                 cmp     [ebp+var_2C], 13A3h
.text$mn:000003BD                 jz      loc_56C
.text$mn:000003C3                 cmp     [ebp+var_2C], 13A4h
.text$mn:000003CA                 jz      loc_465
.text$mn:000003D0                 jmp     loc_7F1
.text$mn:000003D5 ; ---------------------------------------------------------------------------
.text$mn:000003D5
.text$mn:000003D5 loc_3D5:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+34j
.text$mn:000003D5                 mov     ecx, [ebp+var_28]
.text$mn:000003D8                 mov     edx, [ecx+80h]
.text$mn:000003DE                 push    edx             ; unsigned __int32
.text$mn:000003DF                 mov     eax, [ebp+var_28]
.text$mn:000003E2                 mov     ecx, [eax+70h]
.text$mn:000003E5                 push    ecx             ; int
.text$mn:000003E6                 mov     edx, [ebp+var_28]
.text$mn:000003E9                 mov     eax, [edx+6Ch]
.text$mn:000003EC                 push    eax             ; int
.text$mn:000003ED                 mov     ecx, [ebp+var_28]
.text$mn:000003F0                 mov     edx, [ecx+0Ch]
.text$mn:000003F3                 push    edx             ; HWND
.text$mn:000003F4                 mov     eax, [ebp+var_28]
.text$mn:000003F7                 mov     ecx, [eax+4]
.text$mn:000003FA                 push    ecx             ; HINSTANCE
.text$mn:000003FB                 mov     ecx, [ebp+var_28]
.text$mn:000003FE                 add     ecx, 18h        ; this
.text$mn:00000401                 call    ?init@Splitter@@QAEXPAUHINSTANCE__@@PAUHWND__@@HHK@Z ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)
.text$mn:00000406                 mov     eax, 1
.text$mn:0000040B                 jmp     loc_80A
.text$mn:00000410 ; ---------------------------------------------------------------------------
.text$mn:00000410
.text$mn:00000410 loc_410:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+3Dj
.text$mn:00000410                 mov     edx, [ebp+wParam]
.text$mn:00000413                 and     edx, 0FFFFh
.text$mn:00000419                 movzx   eax, dx
.text$mn:0000041C                 mov     [ebp+var_40], eax
.text$mn:0000041F                 cmp     [ebp+var_40], 7D0h
.text$mn:00000426                 jz      short loc_433
.text$mn:00000428                 cmp     [ebp+var_40], 7D1h
.text$mn:0000042F                 jz      short loc_447
.text$mn:00000431                 jmp     short loc_45B
.text$mn:00000433 ; ---------------------------------------------------------------------------
.text$mn:00000433
.text$mn:00000433 loc_433:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+CEj
.text$mn:00000433                 push    1               ; bool
.text$mn:00000435                 mov     ecx, [ebp+var_28] ; this
.text$mn:00000438                 call    ?rotateTo@SplitterContainer@@AAEX_N@Z ; SplitterContainer::rotateTo(bool)
.text$mn:0000043D                 mov     eax, 1
.text$mn:00000442                 jmp     loc_80A
.text$mn:00000447 ; ---------------------------------------------------------------------------
.text$mn:00000447
.text$mn:00000447 loc_447:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+D7j
.text$mn:00000447                 push    0               ; bool
.text$mn:00000449                 mov     ecx, [ebp+var_28] ; this
.text$mn:0000044C                 call    ?rotateTo@SplitterContainer@@AAEX_N@Z ; SplitterContainer::rotateTo(bool)
.text$mn:00000451                 mov     eax, 1
.text$mn:00000456                 jmp     loc_80A
.text$mn:0000045B ; ---------------------------------------------------------------------------
.text$mn:0000045B
.text$mn:0000045B loc_45B:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+D9j
.text$mn:0000045B                 mov     eax, 1
.text$mn:00000460                 jmp     loc_80A
.text$mn:00000465 ; ---------------------------------------------------------------------------
.text$mn:00000465
.text$mn:00000465 loc_465:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+72j
.text$mn:00000465                 lea     ecx, [ebp+var_24]
.text$mn:00000468                 push    ecx
.text$mn:00000469                 mov     edx, [ebp+var_28]
.text$mn:0000046C                 mov     eax, [edx]
.text$mn:0000046E                 mov     ecx, [ebp+var_28]
.text$mn:00000471                 mov     edx, [eax+1Ch]
.text$mn:00000474                 call    edx
.text$mn:00000476                 mov     eax, [ebp+var_28]
.text$mn:00000479                 mov     ecx, [ebp+var_20]
.text$mn:0000047C                 add     ecx, [eax+78h]
.text$mn:0000047F                 mov     [ebp+var_20], ecx
.text$mn:00000482                 mov     edx, [ebp+var_20]
.text$mn:00000485                 mov     [ebp+var_10], edx
.text$mn:00000488                 mov     eax, [ebp+var_18]
.text$mn:0000048B                 mov     [ebp+var_8], eax
.text$mn:0000048E                 mov     ecx, [ebp+var_28]
.text$mn:00000491                 mov     edx, [ebp+var_24]
.text$mn:00000494                 add     edx, [ecx+74h]
.text$mn:00000497                 mov     [ebp+var_24], edx
.text$mn:0000049A                 mov     eax, [ebp+var_24]
.text$mn:0000049D                 mov     [ebp+var_14], eax
.text$mn:000004A0                 mov     ecx, [ebp+var_1C]
.text$mn:000004A3                 mov     [ebp+var_C], ecx
.text$mn:000004A6                 mov     edx, [ebp+var_28]
.text$mn:000004A9                 mov     eax, [edx+80h]
.text$mn:000004AF                 and     eax, 2
.text$mn:000004B2                 jz      short loc_4EA
.text$mn:000004B4                 cmp     [ebp+wParam], 0
.text$mn:000004B8                 jz      short loc_4E8
.text$mn:000004BA                 mov     ecx, [ebp+wParam]
.text$mn:000004BD                 mov     [ebp+var_1C], ecx
.text$mn:000004C0                 mov     edx, [ebp+var_28]
.text$mn:000004C3                 mov     esi, [ebp+wParam]
.text$mn:000004C6                 add     esi, [edx+74h]
.text$mn:000004C9                 mov     ecx, [ebp+var_28]
.text$mn:000004CC                 add     ecx, 18h        ; this
.text$mn:000004CF                 call    ?getPhisicalSize@Splitter@@QBEHXZ ; Splitter::getPhisicalSize(void)
.text$mn:000004D4                 add     esi, eax
.text$mn:000004D6                 mov     [ebp+var_14], esi
.text$mn:000004D9                 mov     eax, [ebp+var_C]
.text$mn:000004DC                 sub     eax, [ebp+var_14]
.text$mn:000004DF                 mov     ecx, [ebp+var_28]
.text$mn:000004E2                 add     eax, [ecx+74h]
.text$mn:000004E5                 mov     [ebp+var_C], eax
.text$mn:000004E8
.text$mn:000004E8 loc_4E8:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+160j
.text$mn:000004E8                 jmp     short loc_51E
.text$mn:000004EA ; ---------------------------------------------------------------------------
.text$mn:000004EA
.text$mn:000004EA loc_4EA:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+15Aj
.text$mn:000004EA                 cmp     [ebp+lParam], 0
.text$mn:000004EE                 jz      short loc_51E
.text$mn:000004F0                 mov     edx, [ebp+lParam]
.text$mn:000004F3                 mov     [ebp+var_18], edx
.text$mn:000004F6                 mov     eax, [ebp+var_28]
.text$mn:000004F9                 mov     esi, [ebp+lParam]
.text$mn:000004FC                 add     esi, [eax+78h]
.text$mn:000004FF                 mov     ecx, [ebp+var_28]
.text$mn:00000502                 add     ecx, 18h        ; this
.text$mn:00000505                 call    ?getPhisicalSize@Splitter@@QBEHXZ ; Splitter::getPhisicalSize(void)
.text$mn:0000050A                 add     esi, eax
.text$mn:0000050C                 mov     [ebp+var_10], esi
.text$mn:0000050F                 mov     ecx, [ebp+var_8]
.text$mn:00000512                 sub     ecx, [ebp+var_10]
.text$mn:00000515                 mov     edx, [ebp+var_28]
.text$mn:00000518                 add     ecx, [edx+78h]
.text$mn:0000051B                 mov     [ebp+var_8], ecx
.text$mn:0000051E
.text$mn:0000051E loc_51E:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long):loc_4E8j
.text$mn:0000051E                                         ; SplitterContainer::runProc(uint,uint,long)+196j
.text$mn:0000051E                 lea     eax, [ebp+var_24]
.text$mn:00000521                 push    eax
.text$mn:00000522                 mov     ecx, [ebp+var_28]
.text$mn:00000525                 mov     edx, [ecx+10h]
.text$mn:00000528                 mov     eax, [ebp+var_28]
.text$mn:0000052B                 mov     edx, [edx]
.text$mn:0000052D                 mov     ecx, [eax+10h]
.text$mn:00000530                 mov     eax, [edx+10h]
.text$mn:00000533                 call    eax
.text$mn:00000535                 lea     ecx, [ebp+var_14]
.text$mn:00000538                 push    ecx
.text$mn:00000539                 mov     edx, [ebp+var_28]
.text$mn:0000053C                 mov     eax, [edx+14h]
.text$mn:0000053F                 mov     ecx, [ebp+var_28]
.text$mn:00000542                 mov     edx, [eax]
.text$mn:00000544                 mov     ecx, [ecx+14h]
.text$mn:00000547                 mov     eax, [edx+10h]
.text$mn:0000054A                 call    eax
.text$mn:0000054C                 push    1               ; bErase
.text$mn:0000054E                 push    0               ; lpRect
.text$mn:00000550                 mov     ecx, [ebp+var_28]
.text$mn:00000553                 add     ecx, 18h        ; this
.text$mn:00000556                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:0000055B                 push    eax             ; hWnd
.text$mn:0000055C                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:00000562                 mov     eax, 1
.text$mn:00000567                 jmp     loc_80A
.text$mn:0000056C ; ---------------------------------------------------------------------------
.text$mn:0000056C
.text$mn:0000056C loc_56C:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+65j
.text$mn:0000056C                 mov     ecx, [ebp+var_28]
.text$mn:0000056F                 cmp     dword ptr [ecx+84h], 1
.text$mn:00000576                 jz      loc_613
.text$mn:0000057C                 mov     edx, [ebp+var_28]
.text$mn:0000057F                 cmp     dword ptr [edx+84h], 2
.text$mn:00000586                 jz      loc_613
.text$mn:0000058C                 lea     eax, [ebp+Point]
.text$mn:0000058F                 push    eax             ; lpPoint
.text$mn:00000590                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:00000596                 mov     ecx, [ebp+var_28]
.text$mn:00000599                 cmp     dword ptr [ecx+7Ch], 0
.text$mn:0000059D                 jnz     short loc_5F1
.text$mn:0000059F                 lea     edx, [ebp+var_60]
.text$mn:000005A2                 push    edx             ; lpPoint
.text$mn:000005A3                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:000005A9                 call    dword ptr ds:__imp__CreatePopupMenu@0 ; CreatePopupMenu()
.text$mn:000005AF                 mov     ecx, [ebp+var_28]
.text$mn:000005B2                 mov     [ecx+7Ch], eax
.text$mn:000005B5                 push    offset $SG91629 ; "Rotate to left"
.text$mn:000005BA                 push    7D0h            ; uIDNewItem
.text$mn:000005BF                 push    400h            ; uFlags
.text$mn:000005C4                 push    1               ; uPosition
.text$mn:000005C6                 mov     edx, [ebp+var_28]
.text$mn:000005C9                 mov     eax, [edx+7Ch]
.text$mn:000005CC                 push    eax             ; hMenu
.text$mn:000005CD                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:000005D3                 push    offset $SG91630 ; "Rotate to right"
.text$mn:000005D8                 push    7D1h            ; uIDNewItem
.text$mn:000005DD                 push    400h            ; uFlags
.text$mn:000005E2                 push    0               ; uPosition
.text$mn:000005E4                 mov     ecx, [ebp+var_28]
.text$mn:000005E7                 mov     edx, [ecx+7Ch]
.text$mn:000005EA                 push    edx             ; hMenu
.text$mn:000005EB                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:000005F1
.text$mn:000005F1 loc_5F1:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+245j
.text$mn:000005F1                 push    0               ; prcRect
.text$mn:000005F3                 mov     eax, [ebp+var_28]
.text$mn:000005F6                 mov     ecx, [eax+0Ch]
.text$mn:000005F9                 push    ecx             ; hWnd
.text$mn:000005FA                 push    0               ; nReserved
.text$mn:000005FC                 mov     edx, [ebp+Point.y]
.text$mn:000005FF                 push    edx             ; y
.text$mn:00000600                 mov     eax, [ebp+Point.x]
.text$mn:00000603                 push    eax             ; x
.text$mn:00000604                 push    0               ; uFlags
.text$mn:00000606                 mov     ecx, [ebp+var_28]
.text$mn:00000609                 mov     edx, [ecx+7Ch]
.text$mn:0000060C                 push    edx             ; hMenu
.text$mn:0000060D                 call    dword ptr ds:__imp__TrackPopupMenu@28 ; TrackPopupMenu(x,x,x,x,x,x,x)
.text$mn:00000613
.text$mn:00000613 loc_613:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+21Ej
.text$mn:00000613                                         ; SplitterContainer::runProc(uint,uint,long)+22Ej
.text$mn:00000613                 mov     eax, 1
.text$mn:00000618                 jmp     loc_80A
.text$mn:0000061D ; ---------------------------------------------------------------------------
.text$mn:0000061D
.text$mn:0000061D loc_61D:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+2Aj
.text$mn:0000061D                 mov     eax, [ebp+var_28]
.text$mn:00000620                 cmp     dword ptr [eax+84h], 1
.text$mn:00000627                 jnz     short loc_650
.text$mn:00000629                 mov     ecx, [ebp+var_28]
.text$mn:0000062C                 mov     edx, [ecx+10h]
.text$mn:0000062F                 mov     eax, [ebp+var_28]
.text$mn:00000632                 mov     edx, [edx]
.text$mn:00000634                 mov     ecx, [eax+10h]
.text$mn:00000637                 mov     eax, [edx+24h]
.text$mn:0000063A                 call    eax
.text$mn:0000063C                 and     eax, 0FFFFh
.text$mn:00000641                 movzx   eax, ax
.text$mn:00000644                 or      eax, 10000h
.text$mn:00000649                 jmp     loc_80A
.text$mn:0000064E ; ---------------------------------------------------------------------------
.text$mn:0000064E                 jmp     short loc_6AA
.text$mn:00000650 ; ---------------------------------------------------------------------------
.text$mn:00000650
.text$mn:00000650 loc_650:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+2CFj
.text$mn:00000650                 mov     ecx, [ebp+var_28]
.text$mn:00000653                 cmp     dword ptr [ecx+84h], 2
.text$mn:0000065A                 jnz     short loc_6A3
.text$mn:0000065C                 mov     edx, [ebp+var_28]
.text$mn:0000065F                 mov     eax, [edx]
.text$mn:00000661                 mov     ecx, [ebp+var_28]
.text$mn:00000664                 mov     edx, [eax+24h]
.text$mn:00000667                 call    edx
.text$mn:00000669                 mov     esi, eax
.text$mn:0000066B                 mov     eax, [ebp+var_28]
.text$mn:0000066E                 mov     ecx, [eax+14h]
.text$mn:00000671                 mov     edx, [ebp+var_28]
.text$mn:00000674                 mov     eax, [ecx]
.text$mn:00000676                 mov     ecx, [edx+14h]
.text$mn:00000679                 mov     edx, [eax+24h]
.text$mn:0000067C                 call    edx
.text$mn:0000067E                 sub     esi, eax
.text$mn:00000680                 mov     [ebp+var_30], esi
.text$mn:00000683                 jns     short loc_68C
.text$mn:00000685                 mov     [ebp+var_30], 0
.text$mn:0000068C
.text$mn:0000068C loc_68C:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+32Bj
.text$mn:0000068C                 mov     eax, [ebp+var_30]
.text$mn:0000068F                 and     eax, 0FFFFh
.text$mn:00000694                 movzx   eax, ax
.text$mn:00000697                 or      eax, 20000h
.text$mn:0000069C                 jmp     loc_80A
.text$mn:000006A1 ; ---------------------------------------------------------------------------
.text$mn:000006A1                 jmp     short loc_6AA
.text$mn:000006A3 ; ---------------------------------------------------------------------------
.text$mn:000006A3
.text$mn:000006A3 loc_6A3:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+302j
.text$mn:000006A3                 xor     eax, eax
.text$mn:000006A5                 jmp     loc_80A
.text$mn:000006AA ; ---------------------------------------------------------------------------
.text$mn:000006AA
.text$mn:000006AA loc_6AA:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+58j
.text$mn:000006AA                                         ; SplitterContainer::runProc(uint,uint,long)+2F6j ...
.text$mn:000006AA                 mov     ecx, [ebp+var_28]
.text$mn:000006AD                 cmp     dword ptr [ecx+84h], 1
.text$mn:000006B4                 jnz     short loc_6DD
.text$mn:000006B6                 mov     edx, [ebp+var_28]
.text$mn:000006B9                 mov     eax, [edx+10h]
.text$mn:000006BC                 mov     ecx, [ebp+var_28]
.text$mn:000006BF                 mov     edx, [eax]
.text$mn:000006C1                 mov     ecx, [ecx+10h]
.text$mn:000006C4                 mov     eax, [edx+28h]
.text$mn:000006C7                 call    eax
.text$mn:000006C9                 and     eax, 0FFFFh
.text$mn:000006CE                 movzx   eax, ax
.text$mn:000006D1                 or      eax, 10000h
.text$mn:000006D6                 jmp     loc_80A
.text$mn:000006DB ; ---------------------------------------------------------------------------
.text$mn:000006DB                 jmp     short loc_737
.text$mn:000006DD ; ---------------------------------------------------------------------------
.text$mn:000006DD
.text$mn:000006DD loc_6DD:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+35Cj
.text$mn:000006DD                 mov     ecx, [ebp+var_28]
.text$mn:000006E0                 cmp     dword ptr [ecx+84h], 2
.text$mn:000006E7                 jnz     short loc_730
.text$mn:000006E9                 mov     edx, [ebp+var_28]
.text$mn:000006EC                 mov     eax, [edx]
.text$mn:000006EE                 mov     ecx, [ebp+var_28]
.text$mn:000006F1                 mov     edx, [eax+28h]
.text$mn:000006F4                 call    edx
.text$mn:000006F6                 mov     esi, eax
.text$mn:000006F8                 mov     eax, [ebp+var_28]
.text$mn:000006FB                 mov     ecx, [eax+14h]
.text$mn:000006FE                 mov     edx, [ebp+var_28]
.text$mn:00000701                 mov     eax, [ecx]
.text$mn:00000703                 mov     ecx, [edx+14h]
.text$mn:00000706                 mov     edx, [eax+28h]
.text$mn:00000709                 call    edx
.text$mn:0000070B                 sub     esi, eax
.text$mn:0000070D                 mov     [ebp+var_34], esi
.text$mn:00000710                 jns     short loc_719
.text$mn:00000712                 mov     [ebp+var_34], 0
.text$mn:00000719
.text$mn:00000719 loc_719:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+3B8j
.text$mn:00000719                 mov     eax, [ebp+var_34]
.text$mn:0000071C                 and     eax, 0FFFFh
.text$mn:00000721                 movzx   eax, ax
.text$mn:00000724                 or      eax, 20000h
.text$mn:00000729                 jmp     loc_80A
.text$mn:0000072E ; ---------------------------------------------------------------------------
.text$mn:0000072E                 jmp     short loc_737
.text$mn:00000730 ; ---------------------------------------------------------------------------
.text$mn:00000730
.text$mn:00000730 loc_730:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+38Fj
.text$mn:00000730                 xor     eax, eax
.text$mn:00000732                 jmp     loc_80A
.text$mn:00000737 ; ---------------------------------------------------------------------------
.text$mn:00000737
.text$mn:00000737 loc_737:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+46j
.text$mn:00000737                                         ; SplitterContainer::runProc(uint,uint,long)+383j ...
.text$mn:00000737                 lea     ecx, [ebp+var_50]
.text$mn:0000073A                 push    ecx             ; lpPoint
.text$mn:0000073B                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:00000741                 lea     edx, [ebp+var_50]
.text$mn:00000744                 push    edx             ; lpPoint
.text$mn:00000745                 mov     ecx, [ebp+var_28]
.text$mn:00000748                 add     ecx, 18h        ; this
.text$mn:0000074B                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00000750                 push    eax             ; hWnd
.text$mn:00000751                 call    dword ptr ds:__imp__ScreenToClient@8 ; ScreenToClient(x,x)
.text$mn:00000757                 mov     ecx, [ebp+var_28] ; this
.text$mn:0000075A                 call    ?isVertical@SplitterContainer@@QBE_NXZ ; SplitterContainer::isVertical(void)
.text$mn:0000075F                 movzx   eax, al
.text$mn:00000762                 test    eax, eax
.text$mn:00000764                 jz      short loc_788
.text$mn:00000766                 cmp     [ebp+var_50.x], 0
.text$mn:0000076A                 jge     short loc_777
.text$mn:0000076C                 mov     ecx, [ebp+var_28]
.text$mn:0000076F                 mov     edx, [ecx+10h]
.text$mn:00000772                 mov     [ebp+var_44], edx
.text$mn:00000775                 jmp     short loc_780
.text$mn:00000777 ; ---------------------------------------------------------------------------
.text$mn:00000777
.text$mn:00000777 loc_777:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+412j
.text$mn:00000777                 mov     eax, [ebp+var_28]
.text$mn:0000077A                 mov     ecx, [eax+14h]
.text$mn:0000077D                 mov     [ebp+var_44], ecx
.text$mn:00000780
.text$mn:00000780 loc_780:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+41Dj
.text$mn:00000780                 mov     edx, [ebp+var_44]
.text$mn:00000783                 mov     [ebp+var_48], edx
.text$mn:00000786                 jmp     short loc_7A8
.text$mn:00000788 ; ---------------------------------------------------------------------------
.text$mn:00000788
.text$mn:00000788 loc_788:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+40Cj
.text$mn:00000788                 cmp     [ebp+var_50.y], 0
.text$mn:0000078C                 jge     short loc_799
.text$mn:0000078E                 mov     eax, [ebp+var_28]
.text$mn:00000791                 mov     ecx, [eax+10h]
.text$mn:00000794                 mov     [ebp+var_38], ecx
.text$mn:00000797                 jmp     short loc_7A2
.text$mn:00000799 ; ---------------------------------------------------------------------------
.text$mn:00000799
.text$mn:00000799 loc_799:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+434j
.text$mn:00000799                 mov     edx, [ebp+var_28]
.text$mn:0000079C                 mov     eax, [edx+14h]
.text$mn:0000079F                 mov     [ebp+var_38], eax
.text$mn:000007A2
.text$mn:000007A2 loc_7A2:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+43Fj
.text$mn:000007A2                 mov     ecx, [ebp+var_38]
.text$mn:000007A5                 mov     [ebp+var_48], ecx
.text$mn:000007A8
.text$mn:000007A8 loc_7A8:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+42Ej
.text$mn:000007A8                 mov     ecx, [ebp+var_28] ; this
.text$mn:000007AB                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000007B0                 push    eax             ; hWnd
.text$mn:000007B1                 call    dword ptr ds:__imp__GetParent@4 ; GetParent(x)
.text$mn:000007B7                 mov     [ebp+hWnd], eax
.text$mn:000007BA                 mov     ecx, [ebp+var_48] ; this
.text$mn:000007BD                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000007C2                 push    eax             ; lParam
.text$mn:000007C3                 push    0               ; wParam
.text$mn:000007C5                 push    416h            ; Msg
.text$mn:000007CA                 mov     edx, [ebp+hWnd]
.text$mn:000007CD                 push    edx             ; hWnd
.text$mn:000007CE                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000007D4                 push    0               ; lParam
.text$mn:000007D6                 push    0A029h          ; wParam
.text$mn:000007DB                 push    111h            ; Msg
.text$mn:000007E0                 mov     eax, [ebp+hWnd]
.text$mn:000007E3                 push    eax             ; hWnd
.text$mn:000007E4                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000007EA                 mov     eax, 1
.text$mn:000007EF                 jmp     short loc_80A
.text$mn:000007F1 ; ---------------------------------------------------------------------------
.text$mn:000007F1
.text$mn:000007F1 loc_7F1:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+4Cj
.text$mn:000007F1                                         ; SplitterContainer::runProc(uint,uint,long)+78j
.text$mn:000007F1                 mov     ecx, [ebp+lParam]
.text$mn:000007F4                 push    ecx             ; lParam
.text$mn:000007F5                 mov     edx, [ebp+wParam]
.text$mn:000007F8                 push    edx             ; wParam
.text$mn:000007F9                 mov     eax, [ebp+Msg]
.text$mn:000007FC                 push    eax             ; Msg
.text$mn:000007FD                 mov     ecx, [ebp+var_28]
.text$mn:00000800                 mov     edx, [ecx+0Ch]
.text$mn:00000803                 push    edx             ; hWnd
.text$mn:00000804                 call    dword ptr ds:__imp__DefWindowProcW@16 ; DefWindowProcW(x,x,x,x)
.text$mn:0000080A
.text$mn:0000080A loc_80A:                                ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+B3j
.text$mn:0000080A                                         ; SplitterContainer::runProc(uint,uint,long)+EAj ...
.text$mn:0000080A                 pop     esi
.text$mn:0000080B                 mov     ecx, [ebp+var_4]
.text$mn:0000080E                 xor     ecx, ebp
.text$mn:00000810                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000815                 mov     esp, ebp
.text$mn:00000817                 pop     ebp
.text$mn:00000818                 retn    0Ch
.text$mn:00000818 ?runProc@SplitterContainer@@AAEJIIJ@Z endp
.text$mn:00000818
.text$mn:00000818 ; ---------------------------------------------------------------------------
.text$mn:0000081B                 db 0Dh dup(0CCh)
.text$mn:00000828
.text$mn:00000828 ; =============== S U B R O U T I N E =======================================
.text$mn:00000828
.text$mn:00000828 ; Attributes: bp-based frame
.text$mn:00000828
.text$mn:00000828 ; void __thiscall SplitterContainer::rotateTo(SplitterContainer *this, bool)
.text$mn:00000828                 public ?rotateTo@SplitterContainer@@AAEX_N@Z
.text$mn:00000828 ?rotateTo@SplitterContainer@@AAEX_N@Z proc near
.text$mn:00000828                                         ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+E0p
.text$mn:00000828                                         ; SplitterContainer::runProc(uint,uint,long)+F4p
.text$mn:00000828
.text$mn:00000828 var_14          = dword ptr -14h
.text$mn:00000828 var_10          = dword ptr -10h
.text$mn:00000828 var_C           = dword ptr -0Ch
.text$mn:00000828 var_8           = dword ptr -8
.text$mn:00000828 var_1           = byte ptr -1
.text$mn:00000828 arg_0           = byte ptr  8
.text$mn:00000828
.text$mn:00000828                 push    ebp
.text$mn:00000829                 mov     ebp, esp
.text$mn:0000082B                 sub     esp, 14h
.text$mn:0000082E                 mov     [ebp+var_8], ecx
.text$mn:00000831                 mov     [ebp+var_1], 0
.text$mn:00000835                 mov     eax, [ebp+var_8]
.text$mn:00000838                 mov     ecx, [eax+80h]
.text$mn:0000083E                 and     ecx, 2
.text$mn:00000841                 jz      short loc_88E
.text$mn:00000843                 mov     edx, [ebp+var_8]
.text$mn:00000846                 mov     eax, [edx+80h]
.text$mn:0000084C                 xor     eax, 2
.text$mn:0000084F                 mov     ecx, [ebp+var_8]
.text$mn:00000852                 mov     [ecx+80h], eax
.text$mn:00000858                 mov     edx, [ebp+var_8]
.text$mn:0000085B                 mov     eax, [edx+80h]
.text$mn:00000861                 or      eax, 1
.text$mn:00000864                 mov     ecx, [ebp+var_8]
.text$mn:00000867                 mov     [ecx+80h], eax
.text$mn:0000086D                 movzx   edx, [ebp+arg_0]
.text$mn:00000871                 cmp     edx, 1
.text$mn:00000874                 jnz     short loc_87F
.text$mn:00000876                 mov     [ebp+var_C], 1
.text$mn:0000087D                 jmp     short loc_886
.text$mn:0000087F ; ---------------------------------------------------------------------------
.text$mn:0000087F
.text$mn:0000087F loc_87F:                                ; CODE XREF: SplitterContainer::rotateTo(bool)+4Cj
.text$mn:0000087F                 mov     [ebp+var_C], 0
.text$mn:00000886
.text$mn:00000886 loc_886:                                ; CODE XREF: SplitterContainer::rotateTo(bool)+55j
.text$mn:00000886                 mov     al, byte ptr [ebp+var_C]
.text$mn:00000889                 mov     [ebp+var_1], al
.text$mn:0000088C                 jmp     short loc_8D6
.text$mn:0000088E ; ---------------------------------------------------------------------------
.text$mn:0000088E
.text$mn:0000088E loc_88E:                                ; CODE XREF: SplitterContainer::rotateTo(bool)+19j
.text$mn:0000088E                 mov     ecx, [ebp+var_8]
.text$mn:00000891                 mov     edx, [ecx+80h]
.text$mn:00000897                 xor     edx, 1
.text$mn:0000089A                 mov     eax, [ebp+var_8]
.text$mn:0000089D                 mov     [eax+80h], edx
.text$mn:000008A3                 mov     ecx, [ebp+var_8]
.text$mn:000008A6                 mov     edx, [ecx+80h]
.text$mn:000008AC                 or      edx, 2
.text$mn:000008AF                 mov     eax, [ebp+var_8]
.text$mn:000008B2                 mov     [eax+80h], edx
.text$mn:000008B8                 movzx   ecx, [ebp+arg_0]
.text$mn:000008BC                 test    ecx, ecx
.text$mn:000008BE                 jnz     short loc_8C9
.text$mn:000008C0                 mov     [ebp+var_10], 1
.text$mn:000008C7                 jmp     short loc_8D0
.text$mn:000008C9 ; ---------------------------------------------------------------------------
.text$mn:000008C9
.text$mn:000008C9 loc_8C9:                                ; CODE XREF: SplitterContainer::rotateTo(bool)+96j
.text$mn:000008C9                 mov     [ebp+var_10], 0
.text$mn:000008D0
.text$mn:000008D0 loc_8D0:                                ; CODE XREF: SplitterContainer::rotateTo(bool)+9Fj
.text$mn:000008D0                 mov     dl, byte ptr [ebp+var_10]
.text$mn:000008D3                 mov     [ebp+var_1], dl
.text$mn:000008D6
.text$mn:000008D6 loc_8D6:                                ; CODE XREF: SplitterContainer::rotateTo(bool)+64j
.text$mn:000008D6                 movzx   eax, [ebp+var_1]
.text$mn:000008DA                 test    eax, eax
.text$mn:000008DC                 jz      short loc_8FC
.text$mn:000008DE                 mov     ecx, [ebp+var_8]
.text$mn:000008E1                 mov     edx, [ecx+10h]
.text$mn:000008E4                 mov     [ebp+var_14], edx
.text$mn:000008E7                 mov     eax, [ebp+var_8]
.text$mn:000008EA                 mov     ecx, [ebp+var_8]
.text$mn:000008ED                 mov     edx, [ecx+14h]
.text$mn:000008F0                 mov     [eax+10h], edx
.text$mn:000008F3                 mov     eax, [ebp+var_8]
.text$mn:000008F6                 mov     ecx, [ebp+var_14]
.text$mn:000008F9                 mov     [eax+14h], ecx
.text$mn:000008FC
.text$mn:000008FC loc_8FC:                                ; CODE XREF: SplitterContainer::rotateTo(bool)+B4j
.text$mn:000008FC                 mov     ecx, [ebp+var_8]
.text$mn:000008FF                 add     ecx, 18h        ; this
.text$mn:00000902                 call    ?rotate@Splitter@@QAEXXZ ; Splitter::rotate(void)
.text$mn:00000907                 mov     esp, ebp
.text$mn:00000909                 pop     ebp
.text$mn:0000090A                 retn    4
.text$mn:0000090A ?rotateTo@SplitterContainer@@AAEX_N@Z endp
.text$mn:0000090A
.text$mn:0000090A ; ---------------------------------------------------------------------------
.text$mn:0000090D                 align 10h
.text$mn:0000090D _text$mn        ends
.text$mn:0000090D
.text$mn:00000910 ; ===========================================================================
.text$mn:00000910
.text$mn:00000910 ; Segment type: Pure code
.text$mn:00000910 ; Segment permissions: Read/Execute
.text$mn:00000910 _text$mn        segment para public 'CODE' use32
.text$mn:00000910                 assume cs:_text$mn
.text$mn:00000910                 ;org 910h
.text$mn:00000910 ; COMDAT (pick any)
.text$mn:00000910                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000910
.text$mn:00000910 ; =============== S U B R O U T I N E =======================================
.text$mn:00000910
.text$mn:00000910 ; Attributes: bp-based frame
.text$mn:00000910
.text$mn:00000910 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00000910                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00000910 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00000910                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00000910
.text$mn:00000910 var_4           = dword ptr -4
.text$mn:00000910 arg_0           = dword ptr  8
.text$mn:00000910
.text$mn:00000910                 push    ebp
.text$mn:00000911                 mov     ebp, esp
.text$mn:00000913                 push    ecx
.text$mn:00000914                 mov     [ebp+var_4], 0
.text$mn:0000091B                 cmp     [ebp+arg_0], 0
.text$mn:0000091F                 jnz     short loc_923
.text$mn:00000921                 jmp     short loc_943
.text$mn:00000923 ; ---------------------------------------------------------------------------
.text$mn:00000923
.text$mn:00000923 loc_923:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00000923                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00000927                 ja      short loc_93E
.text$mn:00000929                 mov     eax, [ebp+arg_0]
.text$mn:0000092C                 push    eax             ; unsigned int
.text$mn:0000092D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000932                 add     esp, 4
.text$mn:00000935                 mov     [ebp+var_4], eax
.text$mn:00000938                 cmp     [ebp+var_4], 0
.text$mn:0000093C                 jnz     short loc_943
.text$mn:0000093E
.text$mn:0000093E loc_93E:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:0000093E                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000943
.text$mn:00000943 loc_943:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00000943                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00000943                 mov     eax, [ebp+var_4]
.text$mn:00000946                 mov     esp, ebp
.text$mn:00000948                 pop     ebp
.text$mn:00000949                 retn
.text$mn:00000949 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00000949
.text$mn:00000949 ; ---------------------------------------------------------------------------
.text$mn:0000094A                 align 4
.text$mn:0000094A _text$mn        ends
.text$mn:0000094A
.text$mn:0000094C ; ===========================================================================
.text$mn:0000094C
.text$mn:0000094C ; Segment type: Pure code
.text$mn:0000094C ; Segment permissions: Read/Execute
.text$mn:0000094C _text$mn        segment para public 'CODE' use32
.text$mn:0000094C                 assume cs:_text$mn
.text$mn:0000094C                 ;org 94Ch
.text$mn:0000094C ; COMDAT (pick any)
.text$mn:0000094C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000094C
.text$mn:0000094C ; =============== S U B R O U T I N E =======================================
.text$mn:0000094C
.text$mn:0000094C ; Attributes: bp-based frame
.text$mn:0000094C
.text$mn:0000094C ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:0000094C                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:0000094C ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:0000094C                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:0000094C
.text$mn:0000094C var_4           = dword ptr -4
.text$mn:0000094C arg_0           = dword ptr  8
.text$mn:0000094C
.text$mn:0000094C                 push    ebp
.text$mn:0000094D                 mov     ebp, esp
.text$mn:0000094F                 push    ecx
.text$mn:00000950                 mov     [ebp+var_4], 0
.text$mn:00000957                 cmp     [ebp+arg_0], 0
.text$mn:0000095B                 jnz     short loc_95F
.text$mn:0000095D                 jmp     short loc_985
.text$mn:0000095F ; ---------------------------------------------------------------------------
.text$mn:0000095F
.text$mn:0000095F loc_95F:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:0000095F                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00000966                 ja      short loc_980
.text$mn:00000968                 mov     eax, [ebp+arg_0]
.text$mn:0000096B                 shl     eax, 3
.text$mn:0000096E                 push    eax             ; unsigned int
.text$mn:0000096F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000974                 add     esp, 4
.text$mn:00000977                 mov     [ebp+var_4], eax
.text$mn:0000097A                 cmp     [ebp+var_4], 0
.text$mn:0000097E                 jnz     short loc_985
.text$mn:00000980
.text$mn:00000980 loc_980:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00000980                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000985
.text$mn:00000985 loc_985:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00000985                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00000985                 mov     eax, [ebp+var_4]
.text$mn:00000988                 mov     esp, ebp
.text$mn:0000098A                 pop     ebp
.text$mn:0000098B                 retn
.text$mn:0000098B ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:0000098B
.text$mn:0000098B _text$mn        ends
.text$mn:0000098B
.text$mn:0000098C ; ===========================================================================
.text$mn:0000098C
.text$mn:0000098C ; Segment type: Pure code
.text$mn:0000098C ; Segment permissions: Read/Execute
.text$mn:0000098C _text$mn        segment para public 'CODE' use32
.text$mn:0000098C                 assume cs:_text$mn
.text$mn:0000098C                 ;org 98Ch
.text$mn:0000098C ; COMDAT (pick any)
.text$mn:0000098C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000098C
.text$mn:0000098C ; =============== S U B R O U T I N E =======================================
.text$mn:0000098C
.text$mn:0000098C ; Attributes: bp-based frame
.text$mn:0000098C
.text$mn:0000098C ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:0000098C                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:0000098C ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:0000098C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:0000098C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:0000098C
.text$mn:0000098C arg_0           = dword ptr  8
.text$mn:0000098C arg_4           = dword ptr  0Ch
.text$mn:0000098C arg_8           = dword ptr  10h
.text$mn:0000098C
.text$mn:0000098C                 push    ebp
.text$mn:0000098D                 mov     ebp, esp
.text$mn:0000098F                 cmp     [ebp+arg_0], 0
.text$mn:00000993                 jnz     short loc_9AA
.text$mn:00000995                 mov     eax, [ebp+arg_8]
.text$mn:00000998                 push    eax             ; unsigned int
.text$mn:00000999                 mov     ecx, [ebp+arg_4]
.text$mn:0000099C                 push    ecx             ; wchar_t *
.text$mn:0000099D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000009A2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000009A7                 add     esp, 0Ch
.text$mn:000009AA
.text$mn:000009AA loc_9AA:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:000009AA                 pop     ebp
.text$mn:000009AB                 retn
.text$mn:000009AB ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:000009AB
.text$mn:000009AB _text$mn        ends
.text$mn:000009AB
.text$mn:000009AC ; ===========================================================================
.text$mn:000009AC
.text$mn:000009AC ; Segment type: Pure code
.text$mn:000009AC ; Segment permissions: Read/Execute
.text$mn:000009AC _text$mn        segment para public 'CODE' use32
.text$mn:000009AC                 assume cs:_text$mn
.text$mn:000009AC                 ;org 9ACh
.text$mn:000009AC ; COMDAT (pick any)
.text$mn:000009AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009AC
.text$mn:000009AC ; =============== S U B R O U T I N E =======================================
.text$mn:000009AC
.text$mn:000009AC ; Attributes: bp-based frame
.text$mn:000009AC
.text$mn:000009AC ; char * __cdecl std::addressof<char>(char &)
.text$mn:000009AC                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000009AC ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000009AC                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000009AC                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000009AC
.text$mn:000009AC arg_0           = dword ptr  8
.text$mn:000009AC
.text$mn:000009AC                 push    ebp
.text$mn:000009AD                 mov     ebp, esp
.text$mn:000009AF                 mov     eax, [ebp+arg_0]
.text$mn:000009B2                 pop     ebp
.text$mn:000009B3                 retn
.text$mn:000009B3 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000009B3
.text$mn:000009B3 _text$mn        ends
.text$mn:000009B3
.text$mn:000009B4 ; ===========================================================================
.text$mn:000009B4
.text$mn:000009B4 ; Segment type: Pure code
.text$mn:000009B4 ; Segment permissions: Read/Execute
.text$mn:000009B4 _text$mn        segment para public 'CODE' use32
.text$mn:000009B4                 assume cs:_text$mn
.text$mn:000009B4                 ;org 9B4h
.text$mn:000009B4 ; COMDAT (pick any)
.text$mn:000009B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009B4
.text$mn:000009B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000009B4
.text$mn:000009B4 ; Attributes: bp-based frame
.text$mn:000009B4
.text$mn:000009B4 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000009B4                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000009B4 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000009B4                                         ; CODE XREF: $LN19+4Bp
.text$mn:000009B4
.text$mn:000009B4 var_4           = dword ptr -4
.text$mn:000009B4 arg_0           = dword ptr  8
.text$mn:000009B4 arg_4           = dword ptr  0Ch
.text$mn:000009B4
.text$mn:000009B4                 push    ebp
.text$mn:000009B5                 mov     ebp, esp
.text$mn:000009B7                 push    ecx
.text$mn:000009B8                 mov     [ebp+var_4], ecx
.text$mn:000009BB                 mov     eax, [ebp+arg_4]
.text$mn:000009BE                 push    eax
.text$mn:000009BF                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000009C4                 add     esp, 4
.text$mn:000009C7                 push    eax             ; int
.text$mn:000009C8                 mov     ecx, [ebp+arg_0]
.text$mn:000009CB                 push    ecx             ; void *
.text$mn:000009CC                 mov     edx, [ebp+var_4]
.text$mn:000009CF                 push    edx             ; int
.text$mn:000009D0                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:000009D5                 add     esp, 0Ch
.text$mn:000009D8                 mov     esp, ebp
.text$mn:000009DA                 pop     ebp
.text$mn:000009DB                 retn    8
.text$mn:000009DB ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000009DB
.text$mn:000009DB ; ---------------------------------------------------------------------------
.text$mn:000009DE                 align 10h
.text$mn:000009DE _text$mn        ends
.text$mn:000009DE
.text$mn:000009E0 ; ===========================================================================
.text$mn:000009E0
.text$mn:000009E0 ; Segment type: Pure code
.text$mn:000009E0 ; Segment permissions: Read/Execute
.text$mn:000009E0 _text$mn        segment para public 'CODE' use32
.text$mn:000009E0                 assume cs:_text$mn
.text$mn:000009E0                 ;org 9E0h
.text$mn:000009E0 ; COMDAT (pick any)
.text$mn:000009E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009E0
.text$mn:000009E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000009E0
.text$mn:000009E0 ; Attributes: bp-based frame
.text$mn:000009E0
.text$mn:000009E0 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:000009E0                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000009E0 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000009E0                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:000009E0
.text$mn:000009E0 var_1C          = dword ptr -1Ch
.text$mn:000009E0 var_18          = dword ptr -18h
.text$mn:000009E0 var_14          = dword ptr -14h
.text$mn:000009E0 var_10          = dword ptr -10h
.text$mn:000009E0 var_C           = dword ptr -0Ch
.text$mn:000009E0 var_4           = dword ptr -4
.text$mn:000009E0 arg_0           = dword ptr  8
.text$mn:000009E0 arg_4           = dword ptr  0Ch
.text$mn:000009E0
.text$mn:000009E0                 push    ebp
.text$mn:000009E1                 mov     ebp, esp
.text$mn:000009E3                 push    0FFFFFFFFh
.text$mn:000009E5                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000009EA                 mov     eax, large fs:0
.text$mn:000009F0                 push    eax
.text$mn:000009F1                 sub     esp, 10h
.text$mn:000009F4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000009F9                 xor     eax, ebp
.text$mn:000009FB                 push    eax
.text$mn:000009FC                 lea     eax, [ebp+var_C]
.text$mn:000009FF                 mov     large fs:0, eax
.text$mn:00000A05                 mov     [ebp+var_18], ecx
.text$mn:00000A08                 mov     eax, [ebp+arg_0]
.text$mn:00000A0B                 push    eax             ; void *
.text$mn:00000A0C                 push    4               ; unsigned int
.text$mn:00000A0E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000A13                 add     esp, 8
.text$mn:00000A16                 mov     [ebp+var_10], eax
.text$mn:00000A19                 mov     [ebp+var_4], 0
.text$mn:00000A20                 cmp     [ebp+var_10], 0
.text$mn:00000A24                 jz      short loc_A41
.text$mn:00000A26                 mov     ecx, [ebp+arg_4]
.text$mn:00000A29                 push    ecx
.text$mn:00000A2A                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000A2F                 add     esp, 4
.text$mn:00000A32                 mov     edx, [ebp+var_10]
.text$mn:00000A35                 mov     eax, [eax]
.text$mn:00000A37                 mov     [edx], eax
.text$mn:00000A39                 mov     ecx, [ebp+var_10]
.text$mn:00000A3C                 mov     [ebp+var_14], ecx
.text$mn:00000A3F                 jmp     short loc_A48
.text$mn:00000A41 ; ---------------------------------------------------------------------------
.text$mn:00000A41
.text$mn:00000A41 loc_A41:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00000A41                 mov     [ebp+var_14], 0
.text$mn:00000A48
.text$mn:00000A48 loc_A48:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00000A48                 mov     edx, [ebp+var_14]
.text$mn:00000A4B                 mov     [ebp+var_1C], edx
.text$mn:00000A4E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A55                 mov     ecx, [ebp+var_C]
.text$mn:00000A58                 mov     large fs:0, ecx
.text$mn:00000A5F                 pop     ecx
.text$mn:00000A60                 mov     esp, ebp
.text$mn:00000A62                 pop     ebp
.text$mn:00000A63                 retn    8
.text$mn:00000A63 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000A63
.text$mn:00000A63 ; ---------------------------------------------------------------------------
.text$mn:00000A66                 align 4
.text$mn:00000A66 _text$mn        ends
.text$mn:00000A66
.text$x:00000A68 ; ===========================================================================
.text$x:00000A68
.text$x:00000A68 ; Segment type: Pure code
.text$x:00000A68 ; Segment permissions: Read/Execute
.text$x:00000A68 _text$x         segment para public 'CODE' use32
.text$x:00000A68                 assume cs:_text$x
.text$x:00000A68                 ;org 0A68h
.text$x:00000A68 ; COMDAT (pick associative to section at 9E0)
.text$x:00000A68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000A68
.text$x:00000A68 ; =============== S U B R O U T I N E =======================================
.text$x:00000A68
.text$x:00000A68
.text$x:00000A68 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00000A68                                         ; DATA XREF: .xdata$x:000027B8o
.text$x:00000A68                 mov     eax, [ebp+8]
.text$x:00000A6B                 push    eax
.text$x:00000A6C                 mov     eax, [ebp-10h]
.text$x:00000A6F                 push    eax             ; void *
.text$x:00000A70                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000A75                 add     esp, 8
.text$x:00000A78                 retn
.text$x:00000A78 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00000A78
.text$x:00000A79
.text$x:00000A79 ; =============== S U B R O U T I N E =======================================
.text$x:00000A79
.text$x:00000A79
.text$x:00000A79 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00000A79                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00000A79
.text$x:00000A79 arg_4           = dword ptr  8
.text$x:00000A79
.text$x:00000A79                 mov     edx, [esp+arg_4]
.text$x:00000A7D                 lea     eax, [edx+0Ch]
.text$x:00000A80                 mov     ecx, [edx-14h]
.text$x:00000A83                 xor     ecx, eax
.text$x:00000A85                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A8A                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00000A8F                 jmp     ___CxxFrameHandler3
.text$x:00000A8F __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00000A8F
.text$x:00000A8F _text$x         ends
.text$x:00000A8F
.text$mn:00000A94 ; ===========================================================================
.text$mn:00000A94
.text$mn:00000A94 ; Segment type: Pure code
.text$mn:00000A94 ; Segment permissions: Read/Execute
.text$mn:00000A94 _text$mn        segment para public 'CODE' use32
.text$mn:00000A94                 assume cs:_text$mn
.text$mn:00000A94                 ;org 0A94h
.text$mn:00000A94 ; COMDAT (pick any)
.text$mn:00000A94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A94
.text$mn:00000A94 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A94
.text$mn:00000A94 ; Attributes: bp-based frame
.text$mn:00000A94
.text$mn:00000A94 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00000A94                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00000A94 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00000A94                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00000A94
.text$mn:00000A94 arg_0           = dword ptr  8
.text$mn:00000A94 arg_4           = dword ptr  0Ch
.text$mn:00000A94 arg_8           = dword ptr  10h
.text$mn:00000A94
.text$mn:00000A94                 push    ebp
.text$mn:00000A95                 mov     ebp, esp
.text$mn:00000A97                 mov     eax, [ebp+arg_8]
.text$mn:00000A9A                 push    eax
.text$mn:00000A9B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000AA0                 add     esp, 4
.text$mn:00000AA3                 push    eax             ; int
.text$mn:00000AA4                 mov     ecx, [ebp+arg_4]
.text$mn:00000AA7                 push    ecx             ; void *
.text$mn:00000AA8                 mov     ecx, [ebp+arg_0]
.text$mn:00000AAB                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00000AB0                 pop     ebp
.text$mn:00000AB1                 retn
.text$mn:00000AB1 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00000AB1
.text$mn:00000AB1 ; ---------------------------------------------------------------------------
.text$mn:00000AB2                 align 4
.text$mn:00000AB2 _text$mn        ends
.text$mn:00000AB2
.text$mn:00000AB4 ; ===========================================================================
.text$mn:00000AB4
.text$mn:00000AB4 ; Segment type: Pure code
.text$mn:00000AB4 ; Segment permissions: Read/Execute
.text$mn:00000AB4 _text$mn        segment para public 'CODE' use32
.text$mn:00000AB4                 assume cs:_text$mn
.text$mn:00000AB4                 ;org 0AB4h
.text$mn:00000AB4 ; COMDAT (pick any)
.text$mn:00000AB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000AB4
.text$mn:00000AB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AB4
.text$mn:00000AB4 ; Attributes: bp-based frame
.text$mn:00000AB4
.text$mn:00000AB4 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00000AB4                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000AB4 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00000AB4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00000AB4
.text$mn:00000AB4 var_1C          = dword ptr -1Ch
.text$mn:00000AB4 var_18          = dword ptr -18h
.text$mn:00000AB4 var_14          = dword ptr -14h
.text$mn:00000AB4 var_10          = dword ptr -10h
.text$mn:00000AB4 var_C           = dword ptr -0Ch
.text$mn:00000AB4 var_4           = dword ptr -4
.text$mn:00000AB4 arg_0           = dword ptr  8
.text$mn:00000AB4 arg_4           = dword ptr  0Ch
.text$mn:00000AB4
.text$mn:00000AB4                 push    ebp
.text$mn:00000AB5                 mov     ebp, esp
.text$mn:00000AB7                 push    0FFFFFFFFh
.text$mn:00000AB9                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000ABE                 mov     eax, large fs:0
.text$mn:00000AC4                 push    eax
.text$mn:00000AC5                 sub     esp, 10h
.text$mn:00000AC8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000ACD                 xor     eax, ebp
.text$mn:00000ACF                 push    eax
.text$mn:00000AD0                 lea     eax, [ebp+var_C]
.text$mn:00000AD3                 mov     large fs:0, eax
.text$mn:00000AD9                 mov     [ebp+var_18], ecx
.text$mn:00000ADC                 mov     eax, [ebp+arg_0]
.text$mn:00000ADF                 push    eax             ; void *
.text$mn:00000AE0                 push    8               ; unsigned int
.text$mn:00000AE2                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000AE7                 add     esp, 8
.text$mn:00000AEA                 mov     [ebp+var_10], eax
.text$mn:00000AED                 mov     [ebp+var_4], 0
.text$mn:00000AF4                 cmp     [ebp+var_10], 0
.text$mn:00000AF8                 jz      short loc_B1B
.text$mn:00000AFA                 mov     ecx, [ebp+arg_4]
.text$mn:00000AFD                 push    ecx
.text$mn:00000AFE                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00000B03                 add     esp, 4
.text$mn:00000B06                 mov     edx, [eax]
.text$mn:00000B08                 mov     eax, [eax+4]
.text$mn:00000B0B                 mov     ecx, [ebp+var_10]
.text$mn:00000B0E                 mov     [ecx], edx
.text$mn:00000B10                 mov     [ecx+4], eax
.text$mn:00000B13                 mov     edx, [ebp+var_10]
.text$mn:00000B16                 mov     [ebp+var_14], edx
.text$mn:00000B19                 jmp     short loc_B22
.text$mn:00000B1B ; ---------------------------------------------------------------------------
.text$mn:00000B1B
.text$mn:00000B1B loc_B1B:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00000B1B                 mov     [ebp+var_14], 0
.text$mn:00000B22
.text$mn:00000B22 loc_B22:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00000B22                 mov     eax, [ebp+var_14]
.text$mn:00000B25                 mov     [ebp+var_1C], eax
.text$mn:00000B28                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000B2F                 mov     ecx, [ebp+var_C]
.text$mn:00000B32                 mov     large fs:0, ecx
.text$mn:00000B39                 pop     ecx
.text$mn:00000B3A                 mov     esp, ebp
.text$mn:00000B3C                 pop     ebp
.text$mn:00000B3D                 retn    8
.text$mn:00000B3D ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00000B3D
.text$mn:00000B3D _text$mn        ends
.text$mn:00000B3D
.text$x:00000B40 ; ===========================================================================
.text$x:00000B40
.text$x:00000B40 ; Segment type: Pure code
.text$x:00000B40 ; Segment permissions: Read/Execute
.text$x:00000B40 _text$x         segment para public 'CODE' use32
.text$x:00000B40                 assume cs:_text$x
.text$x:00000B40                 ;org 0B40h
.text$x:00000B40 ; COMDAT (pick associative to section at AB4)
.text$x:00000B40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000B40
.text$x:00000B40 ; =============== S U B R O U T I N E =======================================
.text$x:00000B40
.text$x:00000B40
.text$x:00000B40 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00000B40                                         ; DATA XREF: .xdata$x:0000278Co
.text$x:00000B40                 mov     eax, [ebp+8]
.text$x:00000B43                 push    eax
.text$x:00000B44                 mov     eax, [ebp-10h]
.text$x:00000B47                 push    eax             ; void *
.text$x:00000B48                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000B4D                 add     esp, 8
.text$x:00000B50                 retn
.text$x:00000B50 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00000B50
.text$x:00000B51
.text$x:00000B51 ; =============== S U B R O U T I N E =======================================
.text$x:00000B51
.text$x:00000B51
.text$x:00000B51 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00000B51                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00000B51
.text$x:00000B51 arg_4           = dword ptr  8
.text$x:00000B51
.text$x:00000B51                 mov     edx, [esp+arg_4]
.text$x:00000B55                 lea     eax, [edx+0Ch]
.text$x:00000B58                 mov     ecx, [edx-14h]
.text$x:00000B5B                 xor     ecx, eax
.text$x:00000B5D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B62                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00000B67                 jmp     ___CxxFrameHandler3
.text$x:00000B67 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00000B67
.text$x:00000B67 _text$x         ends
.text$x:00000B67
.text$mn:00000B6C ; ===========================================================================
.text$mn:00000B6C
.text$mn:00000B6C ; Segment type: Pure code
.text$mn:00000B6C ; Segment permissions: Read/Execute
.text$mn:00000B6C _text$mn        segment para public 'CODE' use32
.text$mn:00000B6C                 assume cs:_text$mn
.text$mn:00000B6C                 ;org 0B6Ch
.text$mn:00000B6C ; COMDAT (pick any)
.text$mn:00000B6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B6C
.text$mn:00000B6C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B6C
.text$mn:00000B6C ; Attributes: bp-based frame
.text$mn:00000B6C
.text$mn:00000B6C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00000B6C                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00000B6C ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00000B6C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00000B6C
.text$mn:00000B6C var_4           = dword ptr -4
.text$mn:00000B6C arg_0           = dword ptr  8
.text$mn:00000B6C
.text$mn:00000B6C                 push    ebp
.text$mn:00000B6D                 mov     ebp, esp
.text$mn:00000B6F                 push    ecx
.text$mn:00000B70                 mov     [ebp+var_4], ecx
.text$mn:00000B73                 mov     eax, [ebp+arg_0]
.text$mn:00000B76                 push    eax
.text$mn:00000B77                 mov     ecx, [ebp+var_4]
.text$mn:00000B7A                 push    ecx
.text$mn:00000B7B                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00000B80                 add     esp, 8
.text$mn:00000B83                 mov     esp, ebp
.text$mn:00000B85                 pop     ebp
.text$mn:00000B86                 retn    4
.text$mn:00000B86 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00000B86
.text$mn:00000B86 ; ---------------------------------------------------------------------------
.text$mn:00000B89                 align 4
.text$mn:00000B89 _text$mn        ends
.text$mn:00000B89
.text$mn:00000B8C ; ===========================================================================
.text$mn:00000B8C
.text$mn:00000B8C ; Segment type: Pure code
.text$mn:00000B8C ; Segment permissions: Read/Execute
.text$mn:00000B8C _text$mn        segment para public 'CODE' use32
.text$mn:00000B8C                 assume cs:_text$mn
.text$mn:00000B8C                 ;org 0B8Ch
.text$mn:00000B8C ; COMDAT (pick any)
.text$mn:00000B8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B8C
.text$mn:00000B8C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B8C
.text$mn:00000B8C ; Attributes: bp-based frame
.text$mn:00000B8C
.text$mn:00000B8C ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000B8C                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00000B8C ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00000B8C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00000B8C
.text$mn:00000B8C var_4           = dword ptr -4
.text$mn:00000B8C
.text$mn:00000B8C                 push    ebp
.text$mn:00000B8D                 mov     ebp, esp
.text$mn:00000B8F                 push    ecx
.text$mn:00000B90                 mov     [ebp+var_4], ecx
.text$mn:00000B93                 mov     esp, ebp
.text$mn:00000B95                 pop     ebp
.text$mn:00000B96                 retn    4
.text$mn:00000B96 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00000B96
.text$mn:00000B96 ; ---------------------------------------------------------------------------
.text$mn:00000B99                 align 4
.text$mn:00000B99 _text$mn        ends
.text$mn:00000B99
.text$mn:00000B9C ; ===========================================================================
.text$mn:00000B9C
.text$mn:00000B9C ; Segment type: Pure code
.text$mn:00000B9C ; Segment permissions: Read/Execute
.text$mn:00000B9C _text$mn        segment para public 'CODE' use32
.text$mn:00000B9C                 assume cs:_text$mn
.text$mn:00000B9C                 ;org 0B9Ch
.text$mn:00000B9C ; COMDAT (pick any)
.text$mn:00000B9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B9C
.text$mn:00000B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B9C
.text$mn:00000B9C ; Attributes: bp-based frame
.text$mn:00000B9C
.text$mn:00000B9C ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00000B9C                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00000B9C ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00000B9C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00000B9C
.text$mn:00000B9C arg_0           = dword ptr  8
.text$mn:00000B9C arg_4           = dword ptr  0Ch
.text$mn:00000B9C
.text$mn:00000B9C                 push    ebp
.text$mn:00000B9D                 mov     ebp, esp
.text$mn:00000B9F                 mov     eax, [ebp+arg_4]
.text$mn:00000BA2                 push    eax
.text$mn:00000BA3                 mov     ecx, [ebp+arg_0]
.text$mn:00000BA6                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000BAB                 pop     ebp
.text$mn:00000BAC                 retn
.text$mn:00000BAC ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00000BAC
.text$mn:00000BAC ; ---------------------------------------------------------------------------
.text$mn:00000BAD                 align 10h
.text$mn:00000BAD _text$mn        ends
.text$mn:00000BAD
.text$mn:00000BB0 ; ===========================================================================
.text$mn:00000BB0
.text$mn:00000BB0 ; Segment type: Pure code
.text$mn:00000BB0 ; Segment permissions: Read/Execute
.text$mn:00000BB0 _text$mn        segment para public 'CODE' use32
.text$mn:00000BB0                 assume cs:_text$mn
.text$mn:00000BB0                 ;org 0BB0h
.text$mn:00000BB0 ; COMDAT (pick any)
.text$mn:00000BB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000BB0
.text$mn:00000BB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BB0
.text$mn:00000BB0 ; Attributes: bp-based frame
.text$mn:00000BB0
.text$mn:00000BB0 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00000BB0                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00000BB0 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00000BB0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00000BB0
.text$mn:00000BB0 var_4           = dword ptr -4
.text$mn:00000BB0
.text$mn:00000BB0                 push    ebp
.text$mn:00000BB1                 mov     ebp, esp
.text$mn:00000BB3                 push    ecx
.text$mn:00000BB4                 mov     [ebp+var_4], ecx
.text$mn:00000BB7                 mov     esp, ebp
.text$mn:00000BB9                 pop     ebp
.text$mn:00000BBA                 retn    4
.text$mn:00000BBA ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00000BBA
.text$mn:00000BBA ; ---------------------------------------------------------------------------
.text$mn:00000BBD                 align 10h
.text$mn:00000BBD _text$mn        ends
.text$mn:00000BBD
.text$mn:00000BC0 ; ===========================================================================
.text$mn:00000BC0
.text$mn:00000BC0 ; Segment type: Pure code
.text$mn:00000BC0 ; Segment permissions: Read/Execute
.text$mn:00000BC0 _text$mn        segment para public 'CODE' use32
.text$mn:00000BC0                 assume cs:_text$mn
.text$mn:00000BC0                 ;org 0BC0h
.text$mn:00000BC0 ; COMDAT (pick any)
.text$mn:00000BC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000BC0
.text$mn:00000BC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BC0
.text$mn:00000BC0 ; Attributes: bp-based frame
.text$mn:00000BC0
.text$mn:00000BC0 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00000BC0                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00000BC0 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00000BC0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00000BC0                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00000BC0
.text$mn:00000BC0 arg_0           = dword ptr  8
.text$mn:00000BC0
.text$mn:00000BC0                 push    ebp
.text$mn:00000BC1                 mov     ebp, esp
.text$mn:00000BC3                 mov     eax, [ebp+arg_0]
.text$mn:00000BC6                 pop     ebp
.text$mn:00000BC7                 retn
.text$mn:00000BC7 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00000BC7
.text$mn:00000BC7 _text$mn        ends
.text$mn:00000BC7
.text$mn:00000BC8 ; ===========================================================================
.text$mn:00000BC8
.text$mn:00000BC8 ; Segment type: Pure code
.text$mn:00000BC8 ; Segment permissions: Read/Execute
.text$mn:00000BC8 _text$mn        segment para public 'CODE' use32
.text$mn:00000BC8                 assume cs:_text$mn
.text$mn:00000BC8                 ;org 0BC8h
.text$mn:00000BC8 ; COMDAT (pick any)
.text$mn:00000BC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000BC8
.text$mn:00000BC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BC8
.text$mn:00000BC8 ; Attributes: bp-based frame
.text$mn:00000BC8
.text$mn:00000BC8 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00000BC8                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00000BC8 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00000BC8                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00000BC8
.text$mn:00000BC8 arg_0           = dword ptr  8
.text$mn:00000BC8
.text$mn:00000BC8                 push    ebp
.text$mn:00000BC9                 mov     ebp, esp
.text$mn:00000BCB                 mov     eax, [ebp+arg_0]
.text$mn:00000BCE                 pop     ebp
.text$mn:00000BCF                 retn
.text$mn:00000BCF ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00000BCF
.text$mn:00000BCF _text$mn        ends
.text$mn:00000BCF
.text$mn:00000BD0 ; ===========================================================================
.text$mn:00000BD0
.text$mn:00000BD0 ; Segment type: Pure code
.text$mn:00000BD0 ; Segment permissions: Read/Execute
.text$mn:00000BD0 _text$mn        segment para public 'CODE' use32
.text$mn:00000BD0                 assume cs:_text$mn
.text$mn:00000BD0                 ;org 0BD0h
.text$mn:00000BD0 ; COMDAT (pick any)
.text$mn:00000BD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000BD0
.text$mn:00000BD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BD0
.text$mn:00000BD0 ; Attributes: bp-based frame
.text$mn:00000BD0
.text$mn:00000BD0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00000BD0                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000BD0 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00000BD0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00000BD0
.text$mn:00000BD0 var_10          = dword ptr -10h
.text$mn:00000BD0 var_C           = dword ptr -0Ch
.text$mn:00000BD0 var_4           = dword ptr -4
.text$mn:00000BD0
.text$mn:00000BD0                 push    ebp
.text$mn:00000BD1                 mov     ebp, esp
.text$mn:00000BD3                 push    0FFFFFFFFh
.text$mn:00000BD5                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000BDA                 mov     eax, large fs:0
.text$mn:00000BE0                 push    eax
.text$mn:00000BE1                 push    ecx
.text$mn:00000BE2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000BE7                 xor     eax, ebp
.text$mn:00000BE9                 push    eax
.text$mn:00000BEA                 lea     eax, [ebp+var_C]
.text$mn:00000BED                 mov     large fs:0, eax
.text$mn:00000BF3                 mov     [ebp+var_10], ecx
.text$mn:00000BF6                 mov     ecx, [ebp+var_10]
.text$mn:00000BF9                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00000BFE                 mov     [ebp+var_4], 0
.text$mn:00000C05                 mov     ecx, [ebp+var_10]
.text$mn:00000C08                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000C0D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C14                 mov     eax, [ebp+var_10]
.text$mn:00000C17                 mov     ecx, [ebp+var_C]
.text$mn:00000C1A                 mov     large fs:0, ecx
.text$mn:00000C21                 pop     ecx
.text$mn:00000C22                 mov     esp, ebp
.text$mn:00000C24                 pop     ebp
.text$mn:00000C25                 retn    4
.text$mn:00000C25 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00000C25
.text$mn:00000C25 _text$mn        ends
.text$mn:00000C25
.text$x:00000C28 ; ===========================================================================
.text$x:00000C28
.text$x:00000C28 ; Segment type: Pure code
.text$x:00000C28 ; Segment permissions: Read/Execute
.text$x:00000C28 _text$x         segment para public 'CODE' use32
.text$x:00000C28                 assume cs:_text$x
.text$x:00000C28                 ;org 0C28h
.text$x:00000C28 ; COMDAT (pick associative to section at BD0)
.text$x:00000C28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000C28
.text$x:00000C28 ; =============== S U B R O U T I N E =======================================
.text$x:00000C28
.text$x:00000C28
.text$x:00000C28 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00000C28                                         ; DATA XREF: .xdata$x:00002440o
.text$x:00000C28                 mov     ecx, [ebp-10h]
.text$x:00000C2B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000C2B __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00000C2B
.text$x:00000C30
.text$x:00000C30 ; =============== S U B R O U T I N E =======================================
.text$x:00000C30
.text$x:00000C30
.text$x:00000C30 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00000C30                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00000C30
.text$x:00000C30 arg_4           = dword ptr  8
.text$x:00000C30
.text$x:00000C30                 mov     edx, [esp+arg_4]
.text$x:00000C34                 lea     eax, [edx+0Ch]
.text$x:00000C37                 mov     ecx, [edx-8]
.text$x:00000C3A                 xor     ecx, eax
.text$x:00000C3C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C41                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00000C46                 jmp     ___CxxFrameHandler3
.text$x:00000C46 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00000C46
.text$x:00000C46 ; ---------------------------------------------------------------------------
.text$x:00000C4B                 align 4
.text$x:00000C4B _text$x         ends
.text$x:00000C4B
.text$mn:00000C4C ; ===========================================================================
.text$mn:00000C4C
.text$mn:00000C4C ; Segment type: Pure code
.text$mn:00000C4C ; Segment permissions: Read/Execute
.text$mn:00000C4C _text$mn        segment para public 'CODE' use32
.text$mn:00000C4C                 assume cs:_text$mn
.text$mn:00000C4C                 ;org 0C4Ch
.text$mn:00000C4C ; COMDAT (pick any)
.text$mn:00000C4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C4C
.text$mn:00000C4C ; =============== S U B R O U T I N E =======================================
.text$mn:00000C4C
.text$mn:00000C4C ; Attributes: bp-based frame
.text$mn:00000C4C
.text$mn:00000C4C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000C4C                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000C4C ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000C4C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00000C4C
.text$mn:00000C4C var_10          = dword ptr -10h
.text$mn:00000C4C var_C           = dword ptr -0Ch
.text$mn:00000C4C var_4           = dword ptr -4
.text$mn:00000C4C
.text$mn:00000C4C                 push    ebp
.text$mn:00000C4D                 mov     ebp, esp
.text$mn:00000C4F                 push    0FFFFFFFFh
.text$mn:00000C51                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000C56                 mov     eax, large fs:0
.text$mn:00000C5C                 push    eax
.text$mn:00000C5D                 push    ecx
.text$mn:00000C5E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C63                 xor     eax, ebp
.text$mn:00000C65                 push    eax
.text$mn:00000C66                 lea     eax, [ebp+var_C]
.text$mn:00000C69                 mov     large fs:0, eax
.text$mn:00000C6F                 mov     [ebp+var_10], ecx
.text$mn:00000C72                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000C75                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00000C7A                 mov     [ebp+var_4], 0
.text$mn:00000C81                 mov     eax, [ebp+var_10]
.text$mn:00000C84                 mov     dword ptr [eax+14h], 0
.text$mn:00000C8B                 mov     ecx, [ebp+var_10]
.text$mn:00000C8E                 mov     dword ptr [ecx+18h], 0
.text$mn:00000C95                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C9C                 mov     eax, [ebp+var_10]
.text$mn:00000C9F                 mov     ecx, [ebp+var_C]
.text$mn:00000CA2                 mov     large fs:0, ecx
.text$mn:00000CA9                 pop     ecx
.text$mn:00000CAA                 mov     esp, ebp
.text$mn:00000CAC                 pop     ebp
.text$mn:00000CAD                 retn
.text$mn:00000CAD ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000CAD
.text$mn:00000CAD ; ---------------------------------------------------------------------------
.text$mn:00000CAE                 align 10h
.text$mn:00000CAE _text$mn        ends
.text$mn:00000CAE
.text$x:00000CB0 ; ===========================================================================
.text$x:00000CB0
.text$x:00000CB0 ; Segment type: Pure code
.text$x:00000CB0 ; Segment permissions: Read/Execute
.text$x:00000CB0 _text$x         segment para public 'CODE' use32
.text$x:00000CB0                 assume cs:_text$x
.text$x:00000CB0                 ;org 0CB0h
.text$x:00000CB0 ; COMDAT (pick associative to section at C4C)
.text$x:00000CB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000CB0
.text$x:00000CB0 ; =============== S U B R O U T I N E =======================================
.text$x:00000CB0
.text$x:00000CB0
.text$x:00000CB0 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000CB0                                         ; DATA XREF: .xdata$x:000023E8o
.text$x:00000CB0                 mov     ecx, [ebp-10h]  ; this
.text$x:00000CB3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000CB3 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000CB3
.text$x:00000CB8
.text$x:00000CB8 ; =============== S U B R O U T I N E =======================================
.text$x:00000CB8
.text$x:00000CB8
.text$x:00000CB8 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000CB8                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000CB8
.text$x:00000CB8 arg_4           = dword ptr  8
.text$x:00000CB8
.text$x:00000CB8                 mov     edx, [esp+arg_4]
.text$x:00000CBC                 lea     eax, [edx+0Ch]
.text$x:00000CBF                 mov     ecx, [edx-8]
.text$x:00000CC2                 xor     ecx, eax
.text$x:00000CC4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000CC9                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000CCE                 jmp     ___CxxFrameHandler3
.text$x:00000CCE __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000CCE
.text$x:00000CCE ; ---------------------------------------------------------------------------
.text$x:00000CD3                 align 4
.text$x:00000CD3 _text$x         ends
.text$x:00000CD3
.text$mn:00000CD4 ; ===========================================================================
.text$mn:00000CD4
.text$mn:00000CD4 ; Segment type: Pure code
.text$mn:00000CD4 ; Segment permissions: Read/Execute
.text$mn:00000CD4 _text$mn        segment para public 'CODE' use32
.text$mn:00000CD4                 assume cs:_text$mn
.text$mn:00000CD4                 ;org 0CD4h
.text$mn:00000CD4 ; COMDAT (pick any)
.text$mn:00000CD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CD4
.text$mn:00000CD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CD4
.text$mn:00000CD4 ; Attributes: bp-based frame
.text$mn:00000CD4
.text$mn:00000CD4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00000CD4                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00000CD4 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00000CD4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00000CD4
.text$mn:00000CD4 var_4           = dword ptr -4
.text$mn:00000CD4
.text$mn:00000CD4                 push    ebp
.text$mn:00000CD5                 mov     ebp, esp
.text$mn:00000CD7                 push    ecx
.text$mn:00000CD8                 mov     [ebp+var_4], ecx
.text$mn:00000CDB                 mov     ecx, [ebp+var_4]
.text$mn:00000CDE                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000CE3                 mov     eax, [ebp+var_4]
.text$mn:00000CE6                 mov     esp, ebp
.text$mn:00000CE8                 pop     ebp
.text$mn:00000CE9                 retn
.text$mn:00000CE9 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00000CE9
.text$mn:00000CE9 ; ---------------------------------------------------------------------------
.text$mn:00000CEA                 align 4
.text$mn:00000CEA _text$mn        ends
.text$mn:00000CEA
.text$mn:00000CEC ; ===========================================================================
.text$mn:00000CEC
.text$mn:00000CEC ; Segment type: Pure code
.text$mn:00000CEC ; Segment permissions: Read/Execute
.text$mn:00000CEC _text$mn        segment para public 'CODE' use32
.text$mn:00000CEC                 assume cs:_text$mn
.text$mn:00000CEC                 ;org 0CECh
.text$mn:00000CEC ; COMDAT (pick any)
.text$mn:00000CEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CEC
.text$mn:00000CEC ; =============== S U B R O U T I N E =======================================
.text$mn:00000CEC
.text$mn:00000CEC ; Attributes: bp-based frame
.text$mn:00000CEC
.text$mn:00000CEC ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00000CEC                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00000CEC ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00000CEC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00000CEC
.text$mn:00000CEC var_4           = dword ptr -4
.text$mn:00000CEC
.text$mn:00000CEC                 push    ebp
.text$mn:00000CED                 mov     ebp, esp
.text$mn:00000CEF                 push    ecx
.text$mn:00000CF0                 mov     [ebp+var_4], ecx
.text$mn:00000CF3                 mov     eax, [ebp+var_4]
.text$mn:00000CF6                 mov     esp, ebp
.text$mn:00000CF8                 pop     ebp
.text$mn:00000CF9                 retn
.text$mn:00000CF9 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00000CF9
.text$mn:00000CF9 ; ---------------------------------------------------------------------------
.text$mn:00000CFA                 align 4
.text$mn:00000CFA _text$mn        ends
.text$mn:00000CFA
.text$mn:00000CFC ; ===========================================================================
.text$mn:00000CFC
.text$mn:00000CFC ; Segment type: Pure code
.text$mn:00000CFC ; Segment permissions: Read/Execute
.text$mn:00000CFC _text$mn        segment para public 'CODE' use32
.text$mn:00000CFC                 assume cs:_text$mn
.text$mn:00000CFC                 ;org 0CFCh
.text$mn:00000CFC ; COMDAT (pick any)
.text$mn:00000CFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CFC
.text$mn:00000CFC ; =============== S U B R O U T I N E =======================================
.text$mn:00000CFC
.text$mn:00000CFC ; Attributes: bp-based frame
.text$mn:00000CFC
.text$mn:00000CFC ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00000CFC                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00000CFC ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00000CFC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00000CFC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:00000CFC
.text$mn:00000CFC var_4           = dword ptr -4
.text$mn:00000CFC
.text$mn:00000CFC                 push    ebp
.text$mn:00000CFD                 mov     ebp, esp
.text$mn:00000CFF                 push    ecx
.text$mn:00000D00                 mov     [ebp+var_4], ecx
.text$mn:00000D03                 mov     eax, [ebp+var_4]
.text$mn:00000D06                 mov     esp, ebp
.text$mn:00000D08                 pop     ebp
.text$mn:00000D09                 retn
.text$mn:00000D09 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00000D09
.text$mn:00000D09 ; ---------------------------------------------------------------------------
.text$mn:00000D0A                 align 4
.text$mn:00000D0A _text$mn        ends
.text$mn:00000D0A
.text$mn:00000D0C ; ===========================================================================
.text$mn:00000D0C
.text$mn:00000D0C ; Segment type: Pure code
.text$mn:00000D0C ; Segment permissions: Read/Execute
.text$mn:00000D0C _text$mn        segment para public 'CODE' use32
.text$mn:00000D0C                 assume cs:_text$mn
.text$mn:00000D0C                 ;org 0D0Ch
.text$mn:00000D0C ; COMDAT (pick any)
.text$mn:00000D0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D0C
.text$mn:00000D0C ; =============== S U B R O U T I N E =======================================
.text$mn:00000D0C
.text$mn:00000D0C ; Attributes: bp-based frame
.text$mn:00000D0C
.text$mn:00000D0C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00000D0C                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000D0C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00000D0C                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00000D0C                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00000D0C
.text$mn:00000D0C var_14          = dword ptr -14h
.text$mn:00000D0C var_D           = byte ptr -0Dh
.text$mn:00000D0C var_C           = dword ptr -0Ch
.text$mn:00000D0C var_4           = dword ptr -4
.text$mn:00000D0C Str             = dword ptr  8
.text$mn:00000D0C
.text$mn:00000D0C                 push    ebp
.text$mn:00000D0D                 mov     ebp, esp
.text$mn:00000D0F                 push    0FFFFFFFFh
.text$mn:00000D11                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000D16                 mov     eax, large fs:0
.text$mn:00000D1C                 push    eax
.text$mn:00000D1D                 sub     esp, 8
.text$mn:00000D20                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D25                 xor     eax, ebp
.text$mn:00000D27                 push    eax
.text$mn:00000D28                 lea     eax, [ebp+var_C]
.text$mn:00000D2B                 mov     large fs:0, eax
.text$mn:00000D31                 mov     [ebp+var_14], ecx
.text$mn:00000D34                 lea     ecx, [ebp+var_D]
.text$mn:00000D37                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000D3C                 push    eax
.text$mn:00000D3D                 mov     ecx, [ebp+var_14]
.text$mn:00000D40                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00000D45                 mov     [ebp+var_4], 0
.text$mn:00000D4C                 push    0               ; Size
.text$mn:00000D4E                 push    0               ; char
.text$mn:00000D50                 mov     ecx, [ebp+var_14]
.text$mn:00000D53                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000D58                 mov     eax, [ebp+Str]
.text$mn:00000D5B                 push    eax             ; Str
.text$mn:00000D5C                 mov     ecx, [ebp+var_14]
.text$mn:00000D5F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00000D64                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000D6B                 mov     eax, [ebp+var_14]
.text$mn:00000D6E                 mov     ecx, [ebp+var_C]
.text$mn:00000D71                 mov     large fs:0, ecx
.text$mn:00000D78                 pop     ecx
.text$mn:00000D79                 mov     esp, ebp
.text$mn:00000D7B                 pop     ebp
.text$mn:00000D7C                 retn    4
.text$mn:00000D7C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00000D7C
.text$mn:00000D7C ; ---------------------------------------------------------------------------
.text$mn:00000D7F                 align 10h
.text$mn:00000D7F _text$mn        ends
.text$mn:00000D7F
.text$x:00000D80 ; ===========================================================================
.text$x:00000D80
.text$x:00000D80 ; Segment type: Pure code
.text$x:00000D80 ; Segment permissions: Read/Execute
.text$x:00000D80 _text$x         segment para public 'CODE' use32
.text$x:00000D80                 assume cs:_text$x
.text$x:00000D80                 ;org 0D80h
.text$x:00000D80 ; COMDAT (pick associative to section at D0C)
.text$x:00000D80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000D80
.text$x:00000D80 ; =============== S U B R O U T I N E =======================================
.text$x:00000D80
.text$x:00000D80
.text$x:00000D80 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00000D80                                         ; DATA XREF: .xdata$x:00002498o
.text$x:00000D80                 mov     ecx, [ebp-14h]
.text$x:00000D83                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000D83 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00000D83
.text$x:00000D88
.text$x:00000D88 ; =============== S U B R O U T I N E =======================================
.text$x:00000D88
.text$x:00000D88
.text$x:00000D88 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00000D88                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00000D88
.text$x:00000D88 arg_4           = dword ptr  8
.text$x:00000D88
.text$x:00000D88                 mov     edx, [esp+arg_4]
.text$x:00000D8C                 lea     eax, [edx+0Ch]
.text$x:00000D8F                 mov     ecx, [edx-0Ch]
.text$x:00000D92                 xor     ecx, eax
.text$x:00000D94                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000D99                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00000D9E                 jmp     ___CxxFrameHandler3
.text$x:00000D9E __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00000D9E
.text$x:00000D9E ; ---------------------------------------------------------------------------
.text$x:00000DA3                 align 4
.text$x:00000DA3 _text$x         ends
.text$x:00000DA3
.text$mn:00000DA4 ; ===========================================================================
.text$mn:00000DA4
.text$mn:00000DA4 ; Segment type: Pure code
.text$mn:00000DA4 ; Segment permissions: Read/Execute
.text$mn:00000DA4 _text$mn        segment para public 'CODE' use32
.text$mn:00000DA4                 assume cs:_text$mn
.text$mn:00000DA4                 ;org 0DA4h
.text$mn:00000DA4 ; COMDAT (pick any)
.text$mn:00000DA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DA4
.text$mn:00000DA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000DA4
.text$mn:00000DA4 ; Attributes: bp-based frame
.text$mn:00000DA4
.text$mn:00000DA4 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000DA4                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00000DA4 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00000DA4                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00000DA4
.text$mn:00000DA4 var_4           = dword ptr -4
.text$mn:00000DA4
.text$mn:00000DA4                 push    ebp
.text$mn:00000DA5                 mov     ebp, esp
.text$mn:00000DA7                 push    ecx
.text$mn:00000DA8                 mov     [ebp+var_4], ecx
.text$mn:00000DAB                 mov     eax, [ebp+var_4]
.text$mn:00000DAE                 mov     dword ptr [eax], 0
.text$mn:00000DB4                 mov     eax, [ebp+var_4]
.text$mn:00000DB7                 mov     esp, ebp
.text$mn:00000DB9                 pop     ebp
.text$mn:00000DBA                 retn
.text$mn:00000DBA ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00000DBA
.text$mn:00000DBA ; ---------------------------------------------------------------------------
.text$mn:00000DBB                 align 4
.text$mn:00000DBB _text$mn        ends
.text$mn:00000DBB
.text$mn:00000DBC ; ===========================================================================
.text$mn:00000DBC
.text$mn:00000DBC ; Segment type: Pure code
.text$mn:00000DBC ; Segment permissions: Read/Execute
.text$mn:00000DBC _text$mn        segment para public 'CODE' use32
.text$mn:00000DBC                 assume cs:_text$mn
.text$mn:00000DBC                 ;org 0DBCh
.text$mn:00000DBC ; COMDAT (pick any)
.text$mn:00000DBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DBC
.text$mn:00000DBC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DBC
.text$mn:00000DBC ; Attributes: bp-based frame
.text$mn:00000DBC
.text$mn:00000DBC ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00000DBC                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00000DBC ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00000DBC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00000DBC
.text$mn:00000DBC var_4           = dword ptr -4
.text$mn:00000DBC
.text$mn:00000DBC                 push    ebp
.text$mn:00000DBD                 mov     ebp, esp
.text$mn:00000DBF                 push    ecx
.text$mn:00000DC0                 mov     [ebp+var_4], ecx
.text$mn:00000DC3                 mov     eax, [ebp+var_4]
.text$mn:00000DC6                 mov     dword ptr [eax], 0
.text$mn:00000DCC                 mov     ecx, [ebp+var_4]
.text$mn:00000DCF                 mov     dword ptr [ecx+4], 0
.text$mn:00000DD6                 mov     eax, [ebp+var_4]
.text$mn:00000DD9                 mov     esp, ebp
.text$mn:00000DDB                 pop     ebp
.text$mn:00000DDC                 retn
.text$mn:00000DDC ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00000DDC
.text$mn:00000DDC ; ---------------------------------------------------------------------------
.text$mn:00000DDD                 align 10h
.text$mn:00000DDD _text$mn        ends
.text$mn:00000DDD
.text$mn:00000DE0 ; ===========================================================================
.text$mn:00000DE0
.text$mn:00000DE0 ; Segment type: Pure code
.text$mn:00000DE0 ; Segment permissions: Read/Execute
.text$mn:00000DE0 _text$mn        segment para public 'CODE' use32
.text$mn:00000DE0                 assume cs:_text$mn
.text$mn:00000DE0                 ;org 0DE0h
.text$mn:00000DE0 ; COMDAT (pick any)
.text$mn:00000DE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DE0
.text$mn:00000DE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000DE0
.text$mn:00000DE0 ; Attributes: bp-based frame
.text$mn:00000DE0
.text$mn:00000DE0 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000DE0                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000DE0 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00000DE0                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00000DE0                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00000DE0
.text$mn:00000DE0 var_10          = dword ptr -10h
.text$mn:00000DE0 var_C           = dword ptr -0Ch
.text$mn:00000DE0 var_4           = dword ptr -4
.text$mn:00000DE0
.text$mn:00000DE0                 push    ebp
.text$mn:00000DE1                 mov     ebp, esp
.text$mn:00000DE3                 push    0FFFFFFFFh
.text$mn:00000DE5                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000DEA                 mov     eax, large fs:0
.text$mn:00000DF0                 push    eax
.text$mn:00000DF1                 push    ecx
.text$mn:00000DF2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000DF7                 xor     eax, ebp
.text$mn:00000DF9                 push    eax
.text$mn:00000DFA                 lea     eax, [ebp+var_C]
.text$mn:00000DFD                 mov     large fs:0, eax
.text$mn:00000E03                 mov     [ebp+var_10], ecx
.text$mn:00000E06                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000E09                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00000E0E                 mov     [ebp+var_4], 0
.text$mn:00000E15                 mov     eax, [ebp+var_10]
.text$mn:00000E18                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00000E1E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E25                 mov     eax, [ebp+var_10]
.text$mn:00000E28                 mov     ecx, [ebp+var_C]
.text$mn:00000E2B                 mov     large fs:0, ecx
.text$mn:00000E32                 pop     ecx
.text$mn:00000E33                 mov     esp, ebp
.text$mn:00000E35                 pop     ebp
.text$mn:00000E36                 retn
.text$mn:00000E36 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00000E36
.text$mn:00000E36 ; ---------------------------------------------------------------------------
.text$mn:00000E37                 align 4
.text$mn:00000E37 _text$mn        ends
.text$mn:00000E37
.text$x:00000E38 ; ===========================================================================
.text$x:00000E38
.text$x:00000E38 ; Segment type: Pure code
.text$x:00000E38 ; Segment permissions: Read/Execute
.text$x:00000E38 _text$x         segment para public 'CODE' use32
.text$x:00000E38                 assume cs:_text$x
.text$x:00000E38                 ;org 0E38h
.text$x:00000E38 ; COMDAT (pick associative to section at DE0)
.text$x:00000E38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000E38
.text$x:00000E38 ; =============== S U B R O U T I N E =======================================
.text$x:00000E38
.text$x:00000E38
.text$x:00000E38 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00000E38                                         ; DATA XREF: .xdata$x:00002600o
.text$x:00000E38                 mov     ecx, [ebp-10h]  ; this
.text$x:00000E3B                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000E3B __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00000E3B
.text$x:00000E40
.text$x:00000E40 ; =============== S U B R O U T I N E =======================================
.text$x:00000E40
.text$x:00000E40
.text$x:00000E40 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00000E40                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00000E40
.text$x:00000E40 arg_4           = dword ptr  8
.text$x:00000E40
.text$x:00000E40                 mov     edx, [esp+arg_4]
.text$x:00000E44                 lea     eax, [edx+0Ch]
.text$x:00000E47                 mov     ecx, [edx-8]
.text$x:00000E4A                 xor     ecx, eax
.text$x:00000E4C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E51                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00000E56                 jmp     ___CxxFrameHandler3
.text$x:00000E56 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00000E56
.text$x:00000E56 ; ---------------------------------------------------------------------------
.text$x:00000E5B                 align 4
.text$x:00000E5B _text$x         ends
.text$x:00000E5B
.text$mn:00000E5C ; ===========================================================================
.text$mn:00000E5C
.text$mn:00000E5C ; Segment type: Pure code
.text$mn:00000E5C ; Segment permissions: Read/Execute
.text$mn:00000E5C _text$mn        segment para public 'CODE' use32
.text$mn:00000E5C                 assume cs:_text$mn
.text$mn:00000E5C                 ;org 0E5Ch
.text$mn:00000E5C ; COMDAT (pick any)
.text$mn:00000E5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E5C
.text$mn:00000E5C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E5C
.text$mn:00000E5C ; Attributes: bp-based frame
.text$mn:00000E5C
.text$mn:00000E5C ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000E5C                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000E5C ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00000E5C                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000E5C
.text$mn:00000E5C var_10          = dword ptr -10h
.text$mn:00000E5C var_C           = dword ptr -0Ch
.text$mn:00000E5C var_4           = dword ptr -4
.text$mn:00000E5C
.text$mn:00000E5C                 push    ebp
.text$mn:00000E5D                 mov     ebp, esp
.text$mn:00000E5F                 push    0FFFFFFFFh
.text$mn:00000E61                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000E66                 mov     eax, large fs:0
.text$mn:00000E6C                 push    eax
.text$mn:00000E6D                 push    ecx
.text$mn:00000E6E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000E73                 xor     eax, ebp
.text$mn:00000E75                 push    eax
.text$mn:00000E76                 lea     eax, [ebp+var_C]
.text$mn:00000E79                 mov     large fs:0, eax
.text$mn:00000E7F                 mov     [ebp+var_10], ecx
.text$mn:00000E82                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000E85                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000E8A                 mov     [ebp+var_4], 0
.text$mn:00000E91                 mov     eax, [ebp+var_10]
.text$mn:00000E94                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00000E9A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000EA1                 mov     eax, [ebp+var_10]
.text$mn:00000EA4                 mov     ecx, [ebp+var_C]
.text$mn:00000EA7                 mov     large fs:0, ecx
.text$mn:00000EAE                 pop     ecx
.text$mn:00000EAF                 mov     esp, ebp
.text$mn:00000EB1                 pop     ebp
.text$mn:00000EB2                 retn
.text$mn:00000EB2 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00000EB2
.text$mn:00000EB2 ; ---------------------------------------------------------------------------
.text$mn:00000EB3                 align 4
.text$mn:00000EB3 _text$mn        ends
.text$mn:00000EB3
.text$x:00000EB4 ; ===========================================================================
.text$x:00000EB4
.text$x:00000EB4 ; Segment type: Pure code
.text$x:00000EB4 ; Segment permissions: Read/Execute
.text$x:00000EB4 _text$x         segment para public 'CODE' use32
.text$x:00000EB4                 assume cs:_text$x
.text$x:00000EB4                 ;org 0EB4h
.text$x:00000EB4 ; COMDAT (pick associative to section at E5C)
.text$x:00000EB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000EB4
.text$x:00000EB4 ; =============== S U B R O U T I N E =======================================
.text$x:00000EB4
.text$x:00000EB4
.text$x:00000EB4 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00000EB4                                         ; DATA XREF: .xdata$x:00002684o
.text$x:00000EB4                 mov     ecx, [ebp-10h]  ; this
.text$x:00000EB7                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000EB7 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00000EB7
.text$x:00000EBC
.text$x:00000EBC ; =============== S U B R O U T I N E =======================================
.text$x:00000EBC
.text$x:00000EBC
.text$x:00000EBC __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00000EBC                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00000EBC
.text$x:00000EBC arg_4           = dword ptr  8
.text$x:00000EBC
.text$x:00000EBC                 mov     edx, [esp+arg_4]
.text$x:00000EC0                 lea     eax, [edx+0Ch]
.text$x:00000EC3                 mov     ecx, [edx-8]
.text$x:00000EC6                 xor     ecx, eax
.text$x:00000EC8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000ECD                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00000ED2                 jmp     ___CxxFrameHandler3
.text$x:00000ED2 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00000ED2
.text$x:00000ED2 ; ---------------------------------------------------------------------------
.text$x:00000ED7                 align 4
.text$x:00000ED7 _text$x         ends
.text$x:00000ED7
.text$mn:00000ED8 ; ===========================================================================
.text$mn:00000ED8
.text$mn:00000ED8 ; Segment type: Pure code
.text$mn:00000ED8 ; Segment permissions: Read/Execute
.text$mn:00000ED8 _text$mn        segment para public 'CODE' use32
.text$mn:00000ED8                 assume cs:_text$mn
.text$mn:00000ED8                 ;org 0ED8h
.text$mn:00000ED8 ; COMDAT (pick any)
.text$mn:00000ED8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000ED8
.text$mn:00000ED8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000ED8
.text$mn:00000ED8 ; Attributes: bp-based frame
.text$mn:00000ED8
.text$mn:00000ED8 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000ED8                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00000ED8 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00000ED8                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000ED8
.text$mn:00000ED8 var_10          = dword ptr -10h
.text$mn:00000ED8 var_C           = dword ptr -0Ch
.text$mn:00000ED8 var_4           = dword ptr -4
.text$mn:00000ED8
.text$mn:00000ED8                 push    ebp
.text$mn:00000ED9                 mov     ebp, esp
.text$mn:00000EDB                 push    0FFFFFFFFh
.text$mn:00000EDD                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00000EE2                 mov     eax, large fs:0
.text$mn:00000EE8                 push    eax
.text$mn:00000EE9                 push    ecx
.text$mn:00000EEA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000EEF                 xor     eax, ebp
.text$mn:00000EF1                 push    eax
.text$mn:00000EF2                 lea     eax, [ebp+var_C]
.text$mn:00000EF5                 mov     large fs:0, eax
.text$mn:00000EFB                 mov     [ebp+var_10], ecx
.text$mn:00000EFE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000F01                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000F06                 mov     [ebp+var_4], 0
.text$mn:00000F0D                 mov     eax, [ebp+var_10]
.text$mn:00000F10                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00000F16                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F1D                 mov     eax, [ebp+var_10]
.text$mn:00000F20                 mov     ecx, [ebp+var_C]
.text$mn:00000F23                 mov     large fs:0, ecx
.text$mn:00000F2A                 pop     ecx
.text$mn:00000F2B                 mov     esp, ebp
.text$mn:00000F2D                 pop     ebp
.text$mn:00000F2E                 retn
.text$mn:00000F2E ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00000F2E
.text$mn:00000F2E ; ---------------------------------------------------------------------------
.text$mn:00000F2F                 align 10h
.text$mn:00000F2F _text$mn        ends
.text$mn:00000F2F
.text$x:00000F30 ; ===========================================================================
.text$x:00000F30
.text$x:00000F30 ; Segment type: Pure code
.text$x:00000F30 ; Segment permissions: Read/Execute
.text$x:00000F30 _text$x         segment para public 'CODE' use32
.text$x:00000F30                 assume cs:_text$x
.text$x:00000F30                 ;org 0F30h
.text$x:00000F30 ; COMDAT (pick associative to section at ED8)
.text$x:00000F30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000F30
.text$x:00000F30 ; =============== S U B R O U T I N E =======================================
.text$x:00000F30
.text$x:00000F30
.text$x:00000F30 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00000F30                                         ; DATA XREF: .xdata$x:00002708o
.text$x:00000F30                 mov     ecx, [ebp-10h]  ; this
.text$x:00000F33                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000F33 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00000F33
.text$x:00000F38
.text$x:00000F38 ; =============== S U B R O U T I N E =======================================
.text$x:00000F38
.text$x:00000F38
.text$x:00000F38 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00000F38                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00000F38
.text$x:00000F38 arg_4           = dword ptr  8
.text$x:00000F38
.text$x:00000F38                 mov     edx, [esp+arg_4]
.text$x:00000F3C                 lea     eax, [edx+0Ch]
.text$x:00000F3F                 mov     ecx, [edx-8]
.text$x:00000F42                 xor     ecx, eax
.text$x:00000F44                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000F49                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00000F4E                 jmp     ___CxxFrameHandler3
.text$x:00000F4E __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00000F4E
.text$x:00000F4E ; ---------------------------------------------------------------------------
.text$x:00000F53                 align 4
.text$x:00000F53 _text$x         ends
.text$x:00000F53
.text$mn:00000F54 ; ===========================================================================
.text$mn:00000F54
.text$mn:00000F54 ; Segment type: Pure code
.text$mn:00000F54 ; Segment permissions: Read/Execute
.text$mn:00000F54 _text$mn        segment para public 'CODE' use32
.text$mn:00000F54                 assume cs:_text$mn
.text$mn:00000F54                 ;org 0F54h
.text$mn:00000F54 ; COMDAT (pick any)
.text$mn:00000F54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F54
.text$mn:00000F54 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F54
.text$mn:00000F54 ; Attributes: bp-based frame
.text$mn:00000F54
.text$mn:00000F54 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00000F54                 public ??0error_category@std@@QAE@XZ
.text$mn:00000F54 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00000F54
.text$mn:00000F54 var_4           = dword ptr -4
.text$mn:00000F54
.text$mn:00000F54                 push    ebp
.text$mn:00000F55                 mov     ebp, esp
.text$mn:00000F57                 push    ecx
.text$mn:00000F58                 mov     [ebp+var_4], ecx
.text$mn:00000F5B                 mov     eax, [ebp+var_4]
.text$mn:00000F5E                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000F64                 mov     eax, [ebp+var_4]
.text$mn:00000F67                 mov     esp, ebp
.text$mn:00000F69                 pop     ebp
.text$mn:00000F6A                 retn
.text$mn:00000F6A ??0error_category@std@@QAE@XZ endp
.text$mn:00000F6A
.text$mn:00000F6A ; ---------------------------------------------------------------------------
.text$mn:00000F6B                 align 4
.text$mn:00000F6B _text$mn        ends
.text$mn:00000F6B
.text$mn:00000F6C ; ===========================================================================
.text$mn:00000F6C
.text$mn:00000F6C ; Segment type: Pure code
.text$mn:00000F6C ; Segment permissions: Read/Execute
.text$mn:00000F6C _text$mn        segment para public 'CODE' use32
.text$mn:00000F6C                 assume cs:_text$mn
.text$mn:00000F6C                 ;org 0F6Ch
.text$mn:00000F6C ; COMDAT (pick any)
.text$mn:00000F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F6C
.text$mn:00000F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F6C
.text$mn:00000F6C ; Attributes: bp-based frame
.text$mn:00000F6C
.text$mn:00000F6C ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00000F6C                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00000F6C ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00000F6C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00000F6C                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00000F6C
.text$mn:00000F6C var_4           = dword ptr -4
.text$mn:00000F6C arg_0           = dword ptr  8
.text$mn:00000F6C arg_4           = dword ptr  0Ch
.text$mn:00000F6C
.text$mn:00000F6C                 push    ebp
.text$mn:00000F6D                 mov     ebp, esp
.text$mn:00000F6F                 push    ecx
.text$mn:00000F70                 mov     [ebp+var_4], ecx
.text$mn:00000F73                 mov     eax, [ebp+var_4]
.text$mn:00000F76                 mov     ecx, [ebp+arg_0]
.text$mn:00000F79                 mov     [eax], ecx
.text$mn:00000F7B                 mov     edx, [ebp+var_4]
.text$mn:00000F7E                 mov     eax, [ebp+arg_4]
.text$mn:00000F81                 mov     [edx+4], eax
.text$mn:00000F84                 mov     eax, [ebp+var_4]
.text$mn:00000F87                 mov     esp, ebp
.text$mn:00000F89                 pop     ebp
.text$mn:00000F8A                 retn    8
.text$mn:00000F8A ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00000F8A
.text$mn:00000F8A ; ---------------------------------------------------------------------------
.text$mn:00000F8D                 align 10h
.text$mn:00000F8D _text$mn        ends
.text$mn:00000F8D
.text$mn:00000F90 ; ===========================================================================
.text$mn:00000F90
.text$mn:00000F90 ; Segment type: Pure code
.text$mn:00000F90 ; Segment permissions: Read/Execute
.text$mn:00000F90 _text$mn        segment para public 'CODE' use32
.text$mn:00000F90                 assume cs:_text$mn
.text$mn:00000F90                 ;org 0F90h
.text$mn:00000F90 ; COMDAT (pick any)
.text$mn:00000F90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F90
.text$mn:00000F90 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F90
.text$mn:00000F90 ; Attributes: bp-based frame
.text$mn:00000F90
.text$mn:00000F90 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const struct std::runtime_error *)
.text$mn:00000F90                 public ??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00000F90 ??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$mn:00000F90                                         ; DATA XREF: .xdata$x:00002840o
.text$mn:00000F90
.text$mn:00000F90 var_10          = dword ptr -10h
.text$mn:00000F90 var_C           = dword ptr -0Ch
.text$mn:00000F90 var_4           = dword ptr -4
.text$mn:00000F90 arg_0           = dword ptr  8
.text$mn:00000F90
.text$mn:00000F90                 push    ebp
.text$mn:00000F91                 mov     ebp, esp
.text$mn:00000F93                 push    0FFFFFFFFh
.text$mn:00000F95                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00000F9A                 mov     eax, large fs:0
.text$mn:00000FA0                 push    eax
.text$mn:00000FA1                 push    ecx
.text$mn:00000FA2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000FA7                 xor     eax, ebp
.text$mn:00000FA9                 push    eax
.text$mn:00000FAA                 lea     eax, [ebp+var_C]
.text$mn:00000FAD                 mov     large fs:0, eax
.text$mn:00000FB3                 mov     [ebp+var_10], ecx
.text$mn:00000FB6                 mov     eax, [ebp+arg_0]
.text$mn:00000FB9                 push    eax             ; struct std::exception *
.text$mn:00000FBA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000FBD                 call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.text$mn:00000FC2                 mov     [ebp+var_4], 0
.text$mn:00000FC9                 mov     ecx, [ebp+var_10]
.text$mn:00000FCC                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00000FD2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000FD9                 mov     eax, [ebp+var_10]
.text$mn:00000FDC                 mov     ecx, [ebp+var_C]
.text$mn:00000FDF                 mov     large fs:0, ecx
.text$mn:00000FE6                 pop     ecx
.text$mn:00000FE7                 mov     esp, ebp
.text$mn:00000FE9                 pop     ebp
.text$mn:00000FEA                 retn    4
.text$mn:00000FEA ??0runtime_error@std@@QAE@ABV01@@Z endp
.text$mn:00000FEA
.text$mn:00000FEA ; ---------------------------------------------------------------------------
.text$mn:00000FED                 align 10h
.text$mn:00000FED _text$mn        ends
.text$mn:00000FED
.text$x:00000FF0 ; ===========================================================================
.text$x:00000FF0
.text$x:00000FF0 ; Segment type: Pure code
.text$x:00000FF0 ; Segment permissions: Read/Execute
.text$x:00000FF0 _text$x         segment para public 'CODE' use32
.text$x:00000FF0                 assume cs:_text$x
.text$x:00000FF0                 ;org 0FF0h
.text$x:00000FF0 ; COMDAT (pick associative to section at F90)
.text$x:00000FF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000FF0
.text$x:00000FF0 ; =============== S U B R O U T I N E =======================================
.text$x:00000FF0
.text$x:00000FF0
.text$x:00000FF0 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:00000FF0                                         ; DATA XREF: .xdata$x:000025D4o
.text$x:00000FF0                 mov     ecx, [ebp-10h]  ; this
.text$x:00000FF3                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00000FF3 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 endp
.text$x:00000FF3
.text$x:00000FF8
.text$x:00000FF8 ; =============== S U B R O U T I N E =======================================
.text$x:00000FF8
.text$x:00000FF8
.text$x:00000FF8 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$x:00000FF8                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+5o
.text$x:00000FF8
.text$x:00000FF8 arg_4           = dword ptr  8
.text$x:00000FF8
.text$x:00000FF8                 mov     edx, [esp+arg_4]
.text$x:00000FFC                 lea     eax, [edx+0Ch]
.text$x:00000FFF                 mov     ecx, [edx-8]
.text$x:00001002                 xor     ecx, eax
.text$x:00001004                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001009                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
.text$x:0000100E                 jmp     ___CxxFrameHandler3
.text$x:0000100E __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z endp
.text$x:0000100E
.text$x:0000100E ; ---------------------------------------------------------------------------
.text$x:00001013                 align 4
.text$x:00001013 _text$x         ends
.text$x:00001013
.text$mn:00001014 ; ===========================================================================
.text$mn:00001014
.text$mn:00001014 ; Segment type: Pure code
.text$mn:00001014 ; Segment permissions: Read/Execute
.text$mn:00001014 _text$mn        segment para public 'CODE' use32
.text$mn:00001014                 assume cs:_text$mn
.text$mn:00001014                 ;org 1014h
.text$mn:00001014 ; COMDAT (pick any)
.text$mn:00001014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001014
.text$mn:00001014 ; =============== S U B R O U T I N E =======================================
.text$mn:00001014
.text$mn:00001014 ; Attributes: bp-based frame
.text$mn:00001014
.text$mn:00001014 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const char *)
.text$mn:00001014                 public ??0runtime_error@std@@QAE@PBD@Z
.text$mn:00001014 ??0runtime_error@std@@QAE@PBD@Z proc near
.text$mn:00001014                                         ; CODE XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+115p
.text$mn:00001014                                         ; SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+185p
.text$mn:00001014
.text$mn:00001014 var_10          = dword ptr -10h
.text$mn:00001014 var_C           = dword ptr -0Ch
.text$mn:00001014 var_4           = dword ptr -4
.text$mn:00001014 arg_0           = dword ptr  8
.text$mn:00001014
.text$mn:00001014                 push    ebp
.text$mn:00001015                 mov     ebp, esp
.text$mn:00001017                 push    0FFFFFFFFh
.text$mn:00001019                 push    offset __ehhandler$??0runtime_error@std@@QAE@PBD@Z
.text$mn:0000101E                 mov     eax, large fs:0
.text$mn:00001024                 push    eax
.text$mn:00001025                 push    ecx
.text$mn:00001026                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000102B                 xor     eax, ebp
.text$mn:0000102D                 push    eax
.text$mn:0000102E                 lea     eax, [ebp+var_C]
.text$mn:00001031                 mov     large fs:0, eax
.text$mn:00001037                 mov     [ebp+var_10], ecx
.text$mn:0000103A                 lea     eax, [ebp+arg_0]
.text$mn:0000103D                 push    eax             ; char **
.text$mn:0000103E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001041                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:00001046                 mov     [ebp+var_4], 0
.text$mn:0000104D                 mov     ecx, [ebp+var_10]
.text$mn:00001050                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00001056                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000105D                 mov     eax, [ebp+var_10]
.text$mn:00001060                 mov     ecx, [ebp+var_C]
.text$mn:00001063                 mov     large fs:0, ecx
.text$mn:0000106A                 pop     ecx
.text$mn:0000106B                 mov     esp, ebp
.text$mn:0000106D                 pop     ebp
.text$mn:0000106E                 retn    4
.text$mn:0000106E ??0runtime_error@std@@QAE@PBD@Z endp
.text$mn:0000106E
.text$mn:0000106E ; ---------------------------------------------------------------------------
.text$mn:00001071                 align 4
.text$mn:00001071 _text$mn        ends
.text$mn:00001071
.text$x:00001074 ; ===========================================================================
.text$x:00001074
.text$x:00001074 ; Segment type: Pure code
.text$x:00001074 ; Segment permissions: Read/Execute
.text$x:00001074 _text$x         segment para public 'CODE' use32
.text$x:00001074                 assume cs:_text$x
.text$x:00001074                 ;org 1074h
.text$x:00001074 ; COMDAT (pick associative to section at 1014)
.text$x:00001074                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001074
.text$x:00001074 ; =============== S U B R O U T I N E =======================================
.text$x:00001074
.text$x:00001074
.text$x:00001074 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 proc near
.text$x:00001074                                         ; DATA XREF: .xdata$x:0000257Co
.text$x:00001074                 mov     ecx, [ebp-10h]  ; this
.text$x:00001077                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00001077 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 endp
.text$x:00001077
.text$x:0000107C
.text$x:0000107C ; =============== S U B R O U T I N E =======================================
.text$x:0000107C
.text$x:0000107C
.text$x:0000107C __ehhandler$??0runtime_error@std@@QAE@PBD@Z proc near
.text$x:0000107C                                         ; DATA XREF: std::runtime_error::runtime_error(char const *)+5o
.text$x:0000107C
.text$x:0000107C arg_4           = dword ptr  8
.text$x:0000107C
.text$x:0000107C                 mov     edx, [esp+arg_4]
.text$x:00001080                 lea     eax, [edx+0Ch]
.text$x:00001083                 mov     ecx, [edx-8]
.text$x:00001086                 xor     ecx, eax
.text$x:00001088                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000108D                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z
.text$x:00001092                 jmp     ___CxxFrameHandler3
.text$x:00001092 __ehhandler$??0runtime_error@std@@QAE@PBD@Z endp
.text$x:00001092
.text$x:00001092 ; ---------------------------------------------------------------------------
.text$x:00001097                 align 4
.text$x:00001097 _text$x         ends
.text$x:00001097
.text$mn:00001098 ; ===========================================================================
.text$mn:00001098
.text$mn:00001098 ; Segment type: Pure code
.text$mn:00001098 ; Segment permissions: Read/Execute
.text$mn:00001098 _text$mn        segment para public 'CODE' use32
.text$mn:00001098                 assume cs:_text$mn
.text$mn:00001098                 ;org 1098h
.text$mn:00001098 ; COMDAT (pick any)
.text$mn:00001098                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001098
.text$mn:00001098 ; =============== S U B R O U T I N E =======================================
.text$mn:00001098
.text$mn:00001098 ; Attributes: bp-based frame
.text$mn:00001098
.text$mn:00001098 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00001098                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001098 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00001098                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00001098                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00001098
.text$mn:00001098 var_10          = dword ptr -10h
.text$mn:00001098 var_C           = dword ptr -0Ch
.text$mn:00001098 var_4           = dword ptr -4
.text$mn:00001098
.text$mn:00001098                 push    ebp
.text$mn:00001099                 mov     ebp, esp
.text$mn:0000109B                 push    0FFFFFFFFh
.text$mn:0000109D                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000010A2                 mov     eax, large fs:0
.text$mn:000010A8                 push    eax
.text$mn:000010A9                 push    ecx
.text$mn:000010AA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000010AF                 xor     eax, ebp
.text$mn:000010B1                 push    eax
.text$mn:000010B2                 lea     eax, [ebp+var_C]
.text$mn:000010B5                 mov     large fs:0, eax
.text$mn:000010BB                 mov     [ebp+var_10], ecx
.text$mn:000010BE                 mov     [ebp+var_4], 0
.text$mn:000010C5                 mov     ecx, [ebp+var_10]
.text$mn:000010C8                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:000010CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000010D4                 mov     ecx, [ebp+var_10]
.text$mn:000010D7                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:000010DC                 mov     ecx, [ebp+var_C]
.text$mn:000010DF                 mov     large fs:0, ecx
.text$mn:000010E6                 pop     ecx
.text$mn:000010E7                 mov     esp, ebp
.text$mn:000010E9                 pop     ebp
.text$mn:000010EA                 retn
.text$mn:000010EA ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:000010EA
.text$mn:000010EA ; ---------------------------------------------------------------------------
.text$mn:000010EB                 align 4
.text$mn:000010EB _text$mn        ends
.text$mn:000010EB
.text$x:000010EC ; ===========================================================================
.text$x:000010EC
.text$x:000010EC ; Segment type: Pure code
.text$x:000010EC ; Segment permissions: Read/Execute
.text$x:000010EC _text$x         segment para public 'CODE' use32
.text$x:000010EC                 assume cs:_text$x
.text$x:000010EC                 ;org 10ECh
.text$x:000010EC ; COMDAT (pick associative to section at 1098)
.text$x:000010EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000010EC
.text$x:000010EC ; =============== S U B R O U T I N E =======================================
.text$x:000010EC
.text$x:000010EC
.text$x:000010EC __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000010EC                                         ; DATA XREF: .xdata$x:0000246Co
.text$x:000010EC                 mov     ecx, [ebp-10h]
.text$x:000010EF                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000010EF __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000010EF
.text$x:000010F4
.text$x:000010F4 ; =============== S U B R O U T I N E =======================================
.text$x:000010F4
.text$x:000010F4
.text$x:000010F4 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:000010F4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:000010F4
.text$x:000010F4 arg_4           = dword ptr  8
.text$x:000010F4
.text$x:000010F4                 mov     edx, [esp+arg_4]
.text$x:000010F8                 lea     eax, [edx+0Ch]
.text$x:000010FB                 mov     ecx, [edx-8]
.text$x:000010FE                 xor     ecx, eax
.text$x:00001100                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001105                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:0000110A                 jmp     ___CxxFrameHandler3
.text$x:0000110A __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:0000110A
.text$x:0000110A ; ---------------------------------------------------------------------------
.text$x:0000110F                 align 10h
.text$x:0000110F _text$x         ends
.text$x:0000110F
.text$mn:00001110 ; ===========================================================================
.text$mn:00001110
.text$mn:00001110 ; Segment type: Pure code
.text$mn:00001110 ; Segment permissions: Read/Execute
.text$mn:00001110 _text$mn        segment para public 'CODE' use32
.text$mn:00001110                 assume cs:_text$mn
.text$mn:00001110                 ;org 1110h
.text$mn:00001110 ; COMDAT (pick any)
.text$mn:00001110                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001110
.text$mn:00001110 ; =============== S U B R O U T I N E =======================================
.text$mn:00001110
.text$mn:00001110 ; Attributes: bp-based frame
.text$mn:00001110
.text$mn:00001110 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001110                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001110 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001110                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00001110                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00001110
.text$mn:00001110 var_10          = dword ptr -10h
.text$mn:00001110 var_C           = dword ptr -0Ch
.text$mn:00001110 var_4           = dword ptr -4
.text$mn:00001110
.text$mn:00001110                 push    ebp
.text$mn:00001111                 mov     ebp, esp
.text$mn:00001113                 push    0FFFFFFFFh
.text$mn:00001115                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000111A                 mov     eax, large fs:0
.text$mn:00001120                 push    eax
.text$mn:00001121                 push    ecx
.text$mn:00001122                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001127                 xor     eax, ebp
.text$mn:00001129                 push    eax
.text$mn:0000112A                 lea     eax, [ebp+var_C]
.text$mn:0000112D                 mov     large fs:0, eax
.text$mn:00001133                 mov     [ebp+var_10], ecx
.text$mn:00001136                 mov     [ebp+var_4], 0
.text$mn:0000113D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001144                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001147                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000114C                 mov     ecx, [ebp+var_C]
.text$mn:0000114F                 mov     large fs:0, ecx
.text$mn:00001156                 pop     ecx
.text$mn:00001157                 mov     esp, ebp
.text$mn:00001159                 pop     ebp
.text$mn:0000115A                 retn
.text$mn:0000115A ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000115A
.text$mn:0000115A ; ---------------------------------------------------------------------------
.text$mn:0000115B                 align 4
.text$mn:0000115B _text$mn        ends
.text$mn:0000115B
.text$x:0000115C ; ===========================================================================
.text$x:0000115C
.text$x:0000115C ; Segment type: Pure code
.text$x:0000115C ; Segment permissions: Read/Execute
.text$x:0000115C _text$x         segment para public 'CODE' use32
.text$x:0000115C                 assume cs:_text$x
.text$x:0000115C                 ;org 115Ch
.text$x:0000115C ; COMDAT (pick associative to section at 1110)
.text$x:0000115C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000115C
.text$x:0000115C ; =============== S U B R O U T I N E =======================================
.text$x:0000115C
.text$x:0000115C
.text$x:0000115C __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:0000115C                                         ; DATA XREF: .xdata$x:00002414o
.text$x:0000115C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000115F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000115F __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000115F
.text$x:00001164
.text$x:00001164 ; =============== S U B R O U T I N E =======================================
.text$x:00001164
.text$x:00001164
.text$x:00001164 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001164                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001164
.text$x:00001164 arg_4           = dword ptr  8
.text$x:00001164
.text$x:00001164                 mov     edx, [esp+arg_4]
.text$x:00001168                 lea     eax, [edx+0Ch]
.text$x:0000116B                 mov     ecx, [edx-8]
.text$x:0000116E                 xor     ecx, eax
.text$x:00001170                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001175                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000117A                 jmp     ___CxxFrameHandler3
.text$x:0000117A __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000117A
.text$x:0000117A ; ---------------------------------------------------------------------------
.text$x:0000117F                 align 10h
.text$x:0000117F _text$x         ends
.text$x:0000117F
.text$mn:00001180 ; ===========================================================================
.text$mn:00001180
.text$mn:00001180 ; Segment type: Pure code
.text$mn:00001180 ; Segment permissions: Read/Execute
.text$mn:00001180 _text$mn        segment para public 'CODE' use32
.text$mn:00001180                 assume cs:_text$mn
.text$mn:00001180                 ;org 1180h
.text$mn:00001180 ; COMDAT (pick any)
.text$mn:00001180                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001180
.text$mn:00001180 ; =============== S U B R O U T I N E =======================================
.text$mn:00001180
.text$mn:00001180 ; Attributes: bp-based frame
.text$mn:00001180
.text$mn:00001180 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00001180                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00001180 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00001180                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00001180                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00001180
.text$mn:00001180 var_10          = dword ptr -10h
.text$mn:00001180 var_C           = dword ptr -0Ch
.text$mn:00001180 var_4           = dword ptr -4
.text$mn:00001180
.text$mn:00001180                 push    ebp
.text$mn:00001181                 mov     ebp, esp
.text$mn:00001183                 push    0FFFFFFFFh
.text$mn:00001185                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000118A                 mov     eax, large fs:0
.text$mn:00001190                 push    eax
.text$mn:00001191                 push    ecx
.text$mn:00001192                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001197                 xor     eax, ebp
.text$mn:00001199                 push    eax
.text$mn:0000119A                 lea     eax, [ebp+var_C]
.text$mn:0000119D                 mov     large fs:0, eax
.text$mn:000011A3                 mov     [ebp+var_10], ecx
.text$mn:000011A6                 mov     [ebp+var_4], 0
.text$mn:000011AD                 push    0               ; Size
.text$mn:000011AF                 push    1               ; char
.text$mn:000011B1                 mov     ecx, [ebp+var_10]
.text$mn:000011B4                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000011B9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000011C0                 mov     ecx, [ebp+var_10]
.text$mn:000011C3                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:000011C8                 mov     ecx, [ebp+var_C]
.text$mn:000011CB                 mov     large fs:0, ecx
.text$mn:000011D2                 pop     ecx
.text$mn:000011D3                 mov     esp, ebp
.text$mn:000011D5                 pop     ebp
.text$mn:000011D6                 retn
.text$mn:000011D6 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:000011D6
.text$mn:000011D6 ; ---------------------------------------------------------------------------
.text$mn:000011D7                 align 4
.text$mn:000011D7 _text$mn        ends
.text$mn:000011D7
.text$x:000011D8 ; ===========================================================================
.text$x:000011D8
.text$x:000011D8 ; Segment type: Pure code
.text$x:000011D8 ; Segment permissions: Read/Execute
.text$x:000011D8 _text$x         segment para public 'CODE' use32
.text$x:000011D8                 assume cs:_text$x
.text$x:000011D8                 ;org 11D8h
.text$x:000011D8 ; COMDAT (pick associative to section at 1180)
.text$x:000011D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000011D8
.text$x:000011D8 ; =============== S U B R O U T I N E =======================================
.text$x:000011D8
.text$x:000011D8
.text$x:000011D8 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:000011D8                                         ; DATA XREF: .xdata$x:000024C4o
.text$x:000011D8                 mov     ecx, [ebp-10h]
.text$x:000011DB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000011DB __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:000011DB
.text$x:000011E0
.text$x:000011E0 ; =============== S U B R O U T I N E =======================================
.text$x:000011E0
.text$x:000011E0
.text$x:000011E0 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:000011E0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:000011E0
.text$x:000011E0 arg_4           = dword ptr  8
.text$x:000011E0
.text$x:000011E0                 mov     edx, [esp+arg_4]
.text$x:000011E4                 lea     eax, [edx+0Ch]
.text$x:000011E7                 mov     ecx, [edx-8]
.text$x:000011EA                 xor     ecx, eax
.text$x:000011EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000011F1                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:000011F6                 jmp     ___CxxFrameHandler3
.text$x:000011F6 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:000011F6
.text$x:000011F6 ; ---------------------------------------------------------------------------
.text$x:000011FB                 align 4
.text$x:000011FB _text$x         ends
.text$x:000011FB
.text$mn:000011FC ; ===========================================================================
.text$mn:000011FC
.text$mn:000011FC ; Segment type: Pure code
.text$mn:000011FC ; Segment permissions: Read/Execute
.text$mn:000011FC _text$mn        segment para public 'CODE' use32
.text$mn:000011FC                 assume cs:_text$mn
.text$mn:000011FC                 ;org 11FCh
.text$mn:000011FC ; COMDAT (pick any)
.text$mn:000011FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011FC
.text$mn:000011FC ; =============== S U B R O U T I N E =======================================
.text$mn:000011FC
.text$mn:000011FC ; Attributes: bp-based frame
.text$mn:000011FC
.text$mn:000011FC ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000011FC                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:000011FC ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:000011FC                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:000011FC                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:000011FC
.text$mn:000011FC var_4           = dword ptr -4
.text$mn:000011FC
.text$mn:000011FC                 push    ebp
.text$mn:000011FD                 mov     ebp, esp
.text$mn:000011FF                 push    ecx
.text$mn:00001200                 mov     [ebp+var_4], ecx
.text$mn:00001203                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001206                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000120B                 mov     esp, ebp
.text$mn:0000120D                 pop     ebp
.text$mn:0000120E                 retn
.text$mn:0000120E ??1_Container_base12@std@@QAE@XZ endp
.text$mn:0000120E
.text$mn:0000120E ; ---------------------------------------------------------------------------
.text$mn:0000120F                 align 10h
.text$mn:0000120F _text$mn        ends
.text$mn:0000120F
.text$mn:00001210 ; ===========================================================================
.text$mn:00001210
.text$mn:00001210 ; Segment type: Pure code
.text$mn:00001210 ; Segment permissions: Read/Execute
.text$mn:00001210 _text$mn        segment para public 'CODE' use32
.text$mn:00001210                 assume cs:_text$mn
.text$mn:00001210                 ;org 1210h
.text$mn:00001210 ; COMDAT (pick any)
.text$mn:00001210                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001210
.text$mn:00001210 ; =============== S U B R O U T I N E =======================================
.text$mn:00001210
.text$mn:00001210 ; Attributes: bp-based frame
.text$mn:00001210
.text$mn:00001210 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001210                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001210 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00001210                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00001210                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00001210
.text$mn:00001210 var_10          = dword ptr -10h
.text$mn:00001210 var_C           = dword ptr -0Ch
.text$mn:00001210 var_4           = dword ptr -4
.text$mn:00001210
.text$mn:00001210                 push    ebp
.text$mn:00001211                 mov     ebp, esp
.text$mn:00001213                 push    0FFFFFFFFh
.text$mn:00001215                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:0000121A                 mov     eax, large fs:0
.text$mn:00001220                 push    eax
.text$mn:00001221                 push    ecx
.text$mn:00001222                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001227                 xor     eax, ebp
.text$mn:00001229                 push    eax
.text$mn:0000122A                 lea     eax, [ebp+var_C]
.text$mn:0000122D                 mov     large fs:0, eax
.text$mn:00001233                 mov     [ebp+var_10], ecx
.text$mn:00001236                 mov     [ebp+var_4], 0
.text$mn:0000123D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001244                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001247                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000124C                 mov     ecx, [ebp+var_C]
.text$mn:0000124F                 mov     large fs:0, ecx
.text$mn:00001256                 pop     ecx
.text$mn:00001257                 mov     esp, ebp
.text$mn:00001259                 pop     ebp
.text$mn:0000125A                 retn
.text$mn:0000125A ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:0000125A
.text$mn:0000125A ; ---------------------------------------------------------------------------
.text$mn:0000125B                 align 4
.text$mn:0000125B _text$mn        ends
.text$mn:0000125B
.text$x:0000125C ; ===========================================================================
.text$x:0000125C
.text$x:0000125C ; Segment type: Pure code
.text$x:0000125C ; Segment permissions: Read/Execute
.text$x:0000125C _text$x         segment para public 'CODE' use32
.text$x:0000125C                 assume cs:_text$x
.text$x:0000125C                 ;org 125Ch
.text$x:0000125C ; COMDAT (pick associative to section at 1210)
.text$x:0000125C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000125C
.text$x:0000125C ; =============== S U B R O U T I N E =======================================
.text$x:0000125C
.text$x:0000125C
.text$x:0000125C __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:0000125C                                         ; DATA XREF: .xdata$x:00002658o
.text$x:0000125C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000125F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000125F __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:0000125F
.text$x:00001264
.text$x:00001264 ; =============== S U B R O U T I N E =======================================
.text$x:00001264
.text$x:00001264
.text$x:00001264 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00001264                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00001264
.text$x:00001264 arg_4           = dword ptr  8
.text$x:00001264
.text$x:00001264                 mov     edx, [esp+arg_4]
.text$x:00001268                 lea     eax, [edx+0Ch]
.text$x:0000126B                 mov     ecx, [edx-8]
.text$x:0000126E                 xor     ecx, eax
.text$x:00001270                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001275                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:0000127A                 jmp     ___CxxFrameHandler3
.text$x:0000127A __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:0000127A
.text$x:0000127A ; ---------------------------------------------------------------------------
.text$x:0000127F                 align 10h
.text$x:0000127F _text$x         ends
.text$x:0000127F
.text$mn:00001280 ; ===========================================================================
.text$mn:00001280
.text$mn:00001280 ; Segment type: Pure code
.text$mn:00001280 ; Segment permissions: Read/Execute
.text$mn:00001280 _text$mn        segment para public 'CODE' use32
.text$mn:00001280                 assume cs:_text$mn
.text$mn:00001280                 ;org 1280h
.text$mn:00001280 ; COMDAT (pick any)
.text$mn:00001280                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001280
.text$mn:00001280 ; =============== S U B R O U T I N E =======================================
.text$mn:00001280
.text$mn:00001280 ; Attributes: bp-based frame
.text$mn:00001280
.text$mn:00001280 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00001280                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00001280 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00001280                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001280                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00001280
.text$mn:00001280 var_10          = dword ptr -10h
.text$mn:00001280 var_C           = dword ptr -0Ch
.text$mn:00001280 var_4           = dword ptr -4
.text$mn:00001280
.text$mn:00001280                 push    ebp
.text$mn:00001281                 mov     ebp, esp
.text$mn:00001283                 push    0FFFFFFFFh
.text$mn:00001285                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:0000128A                 mov     eax, large fs:0
.text$mn:00001290                 push    eax
.text$mn:00001291                 push    ecx
.text$mn:00001292                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001297                 xor     eax, ebp
.text$mn:00001299                 push    eax
.text$mn:0000129A                 lea     eax, [ebp+var_C]
.text$mn:0000129D                 mov     large fs:0, eax
.text$mn:000012A3                 mov     [ebp+var_10], ecx
.text$mn:000012A6                 mov     [ebp+var_4], 0
.text$mn:000012AD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000012B4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000012B7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000012BC                 mov     ecx, [ebp+var_C]
.text$mn:000012BF                 mov     large fs:0, ecx
.text$mn:000012C6                 pop     ecx
.text$mn:000012C7                 mov     esp, ebp
.text$mn:000012C9                 pop     ebp
.text$mn:000012CA                 retn
.text$mn:000012CA ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:000012CA
.text$mn:000012CA ; ---------------------------------------------------------------------------
.text$mn:000012CB                 align 4
.text$mn:000012CB _text$mn        ends
.text$mn:000012CB
.text$x:000012CC ; ===========================================================================
.text$x:000012CC
.text$x:000012CC ; Segment type: Pure code
.text$x:000012CC ; Segment permissions: Read/Execute
.text$x:000012CC _text$x         segment para public 'CODE' use32
.text$x:000012CC                 assume cs:_text$x
.text$x:000012CC                 ;org 12CCh
.text$x:000012CC ; COMDAT (pick associative to section at 1280)
.text$x:000012CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000012CC
.text$x:000012CC ; =============== S U B R O U T I N E =======================================
.text$x:000012CC
.text$x:000012CC
.text$x:000012CC __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:000012CC                                         ; DATA XREF: .xdata$x:000026DCo
.text$x:000012CC                 mov     ecx, [ebp-10h]  ; this
.text$x:000012CF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000012CF __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:000012CF
.text$x:000012D4
.text$x:000012D4 ; =============== S U B R O U T I N E =======================================
.text$x:000012D4
.text$x:000012D4
.text$x:000012D4 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:000012D4                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:000012D4
.text$x:000012D4 arg_4           = dword ptr  8
.text$x:000012D4
.text$x:000012D4                 mov     edx, [esp+arg_4]
.text$x:000012D8                 lea     eax, [edx+0Ch]
.text$x:000012DB                 mov     ecx, [edx-8]
.text$x:000012DE                 xor     ecx, eax
.text$x:000012E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000012E5                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:000012EA                 jmp     ___CxxFrameHandler3
.text$x:000012EA __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:000012EA
.text$x:000012EA ; ---------------------------------------------------------------------------
.text$x:000012EF                 align 10h
.text$x:000012EF _text$x         ends
.text$x:000012EF
.text$mn:000012F0 ; ===========================================================================
.text$mn:000012F0
.text$mn:000012F0 ; Segment type: Pure code
.text$mn:000012F0 ; Segment permissions: Read/Execute
.text$mn:000012F0 _text$mn        segment para public 'CODE' use32
.text$mn:000012F0                 assume cs:_text$mn
.text$mn:000012F0                 ;org 12F0h
.text$mn:000012F0 ; COMDAT (pick any)
.text$mn:000012F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000012F0
.text$mn:000012F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000012F0
.text$mn:000012F0 ; Attributes: bp-based frame
.text$mn:000012F0
.text$mn:000012F0 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000012F0                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:000012F0 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:000012F0                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000012F0                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000012F0
.text$mn:000012F0 var_10          = dword ptr -10h
.text$mn:000012F0 var_C           = dword ptr -0Ch
.text$mn:000012F0 var_4           = dword ptr -4
.text$mn:000012F0
.text$mn:000012F0                 push    ebp
.text$mn:000012F1                 mov     ebp, esp
.text$mn:000012F3                 push    0FFFFFFFFh
.text$mn:000012F5                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:000012FA                 mov     eax, large fs:0
.text$mn:00001300                 push    eax
.text$mn:00001301                 push    ecx
.text$mn:00001302                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001307                 xor     eax, ebp
.text$mn:00001309                 push    eax
.text$mn:0000130A                 lea     eax, [ebp+var_C]
.text$mn:0000130D                 mov     large fs:0, eax
.text$mn:00001313                 mov     [ebp+var_10], ecx
.text$mn:00001316                 mov     [ebp+var_4], 0
.text$mn:0000131D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001324                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001327                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000132C                 mov     ecx, [ebp+var_C]
.text$mn:0000132F                 mov     large fs:0, ecx
.text$mn:00001336                 pop     ecx
.text$mn:00001337                 mov     esp, ebp
.text$mn:00001339                 pop     ebp
.text$mn:0000133A                 retn
.text$mn:0000133A ??1_System_error_category@std@@UAE@XZ endp
.text$mn:0000133A
.text$mn:0000133A ; ---------------------------------------------------------------------------
.text$mn:0000133B                 align 4
.text$mn:0000133B _text$mn        ends
.text$mn:0000133B
.text$x:0000133C ; ===========================================================================
.text$x:0000133C
.text$x:0000133C ; Segment type: Pure code
.text$x:0000133C ; Segment permissions: Read/Execute
.text$x:0000133C _text$x         segment para public 'CODE' use32
.text$x:0000133C                 assume cs:_text$x
.text$x:0000133C                 ;org 133Ch
.text$x:0000133C ; COMDAT (pick associative to section at 12F0)
.text$x:0000133C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000133C
.text$x:0000133C ; =============== S U B R O U T I N E =======================================
.text$x:0000133C
.text$x:0000133C
.text$x:0000133C __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:0000133C                                         ; DATA XREF: .xdata$x:00002760o
.text$x:0000133C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000133F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000133F __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:0000133F
.text$x:00001344
.text$x:00001344 ; =============== S U B R O U T I N E =======================================
.text$x:00001344
.text$x:00001344
.text$x:00001344 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00001344                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00001344
.text$x:00001344 arg_4           = dword ptr  8
.text$x:00001344
.text$x:00001344                 mov     edx, [esp+arg_4]
.text$x:00001348                 lea     eax, [edx+0Ch]
.text$x:0000134B                 mov     ecx, [edx-8]
.text$x:0000134E                 xor     ecx, eax
.text$x:00001350                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001355                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:0000135A                 jmp     ___CxxFrameHandler3
.text$x:0000135A __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:0000135A
.text$x:0000135A ; ---------------------------------------------------------------------------
.text$x:0000135F                 align 10h
.text$x:0000135F _text$x         ends
.text$x:0000135F
.text$mn:00001360 ; ===========================================================================
.text$mn:00001360
.text$mn:00001360 ; Segment type: Pure code
.text$mn:00001360 ; Segment permissions: Read/Execute
.text$mn:00001360 _text$mn        segment para public 'CODE' use32
.text$mn:00001360                 assume cs:_text$mn
.text$mn:00001360                 ;org 1360h
.text$mn:00001360 ; COMDAT (pick any)
.text$mn:00001360                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001360
.text$mn:00001360 ; =============== S U B R O U T I N E =======================================
.text$mn:00001360
.text$mn:00001360 ; Attributes: bp-based frame
.text$mn:00001360
.text$mn:00001360 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00001360                 public ??1error_category@std@@UAE@XZ
.text$mn:00001360 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00001360                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00001360
.text$mn:00001360 var_4           = dword ptr -4
.text$mn:00001360
.text$mn:00001360                 push    ebp
.text$mn:00001361                 mov     ebp, esp
.text$mn:00001363                 push    ecx
.text$mn:00001364                 mov     [ebp+var_4], ecx
.text$mn:00001367                 mov     eax, [ebp+var_4]
.text$mn:0000136A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001370                 mov     esp, ebp
.text$mn:00001372                 pop     ebp
.text$mn:00001373                 retn
.text$mn:00001373 ??1error_category@std@@UAE@XZ endp
.text$mn:00001373
.text$mn:00001373 _text$mn        ends
.text$mn:00001373
.text$mn:00001374 ; ===========================================================================
.text$mn:00001374
.text$mn:00001374 ; Segment type: Pure code
.text$mn:00001374 ; Segment permissions: Read/Execute
.text$mn:00001374 _text$mn        segment para public 'CODE' use32
.text$mn:00001374                 assume cs:_text$mn
.text$mn:00001374                 ;org 1374h
.text$mn:00001374 ; COMDAT (pick any)
.text$mn:00001374                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001374
.text$mn:00001374 ; =============== S U B R O U T I N E =======================================
.text$mn:00001374
.text$mn:00001374 ; Attributes: bp-based frame
.text$mn:00001374
.text$mn:00001374 ; _DWORD __thiscall std::runtime_error::~runtime_error(std::runtime_error *__hidden this)
.text$mn:00001374                 public ??1runtime_error@std@@UAE@XZ
.text$mn:00001374 ??1runtime_error@std@@UAE@XZ proc near  ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+Ap
.text$mn:00001374                                         ; DATA XREF: .xdata$x:000027F0o
.text$mn:00001374
.text$mn:00001374 var_10          = dword ptr -10h
.text$mn:00001374 var_C           = dword ptr -0Ch
.text$mn:00001374 var_4           = dword ptr -4
.text$mn:00001374
.text$mn:00001374                 push    ebp
.text$mn:00001375                 mov     ebp, esp
.text$mn:00001377                 push    0FFFFFFFFh
.text$mn:00001379                 push    offset __ehhandler$??1runtime_error@std@@UAE@XZ
.text$mn:0000137E                 mov     eax, large fs:0
.text$mn:00001384                 push    eax
.text$mn:00001385                 push    ecx
.text$mn:00001386                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000138B                 xor     eax, ebp
.text$mn:0000138D                 push    eax
.text$mn:0000138E                 lea     eax, [ebp+var_C]
.text$mn:00001391                 mov     large fs:0, eax
.text$mn:00001397                 mov     [ebp+var_10], ecx
.text$mn:0000139A                 mov     [ebp+var_4], 0
.text$mn:000013A1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000013A8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000013AB                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:000013B0                 mov     ecx, [ebp+var_C]
.text$mn:000013B3                 mov     large fs:0, ecx
.text$mn:000013BA                 pop     ecx
.text$mn:000013BB                 mov     esp, ebp
.text$mn:000013BD                 pop     ebp
.text$mn:000013BE                 retn
.text$mn:000013BE ??1runtime_error@std@@UAE@XZ endp
.text$mn:000013BE
.text$mn:000013BE ; ---------------------------------------------------------------------------
.text$mn:000013BF                 align 10h
.text$mn:000013BF _text$mn        ends
.text$mn:000013BF
.text$x:000013C0 ; ===========================================================================
.text$x:000013C0
.text$x:000013C0 ; Segment type: Pure code
.text$x:000013C0 ; Segment permissions: Read/Execute
.text$x:000013C0 _text$x         segment para public 'CODE' use32
.text$x:000013C0                 assume cs:_text$x
.text$x:000013C0                 ;org 13C0h
.text$x:000013C0 ; COMDAT (pick associative to section at 1374)
.text$x:000013C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000013C0
.text$x:000013C0 ; =============== S U B R O U T I N E =======================================
.text$x:000013C0
.text$x:000013C0
.text$x:000013C0 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 proc near
.text$x:000013C0                                         ; DATA XREF: .xdata$x:000025A8o
.text$x:000013C0                 mov     ecx, [ebp-10h]  ; this
.text$x:000013C3                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:000013C3 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 endp
.text$x:000013C3
.text$x:000013C8
.text$x:000013C8 ; =============== S U B R O U T I N E =======================================
.text$x:000013C8
.text$x:000013C8
.text$x:000013C8 __ehhandler$??1runtime_error@std@@UAE@XZ proc near
.text$x:000013C8                                         ; DATA XREF: std::runtime_error::~runtime_error(void)+5o
.text$x:000013C8
.text$x:000013C8 arg_4           = dword ptr  8
.text$x:000013C8
.text$x:000013C8                 mov     edx, [esp+arg_4]
.text$x:000013CC                 lea     eax, [edx+0Ch]
.text$x:000013CF                 mov     ecx, [edx-8]
.text$x:000013D2                 xor     ecx, eax
.text$x:000013D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000013D9                 mov     eax, offset __ehfuncinfo$??1runtime_error@std@@UAE@XZ
.text$x:000013DE                 jmp     ___CxxFrameHandler3
.text$x:000013DE __ehhandler$??1runtime_error@std@@UAE@XZ endp
.text$x:000013DE
.text$x:000013DE ; ---------------------------------------------------------------------------
.text$x:000013E3                 align 4
.text$x:000013E3 _text$x         ends
.text$x:000013E3
.text$mn:000013E4 ; ===========================================================================
.text$mn:000013E4
.text$mn:000013E4 ; Segment type: Pure code
.text$mn:000013E4 ; Segment permissions: Read/Execute
.text$mn:000013E4 _text$mn        segment para public 'CODE' use32
.text$mn:000013E4                 assume cs:_text$mn
.text$mn:000013E4                 ;org 13E4h
.text$mn:000013E4 ; COMDAT (pick any)
.text$mn:000013E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013E4
.text$mn:000013E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000013E4
.text$mn:000013E4 ; Attributes: bp-based frame
.text$mn:000013E4
.text$mn:000013E4 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:000013E4                 public ??2@YAPAXIPAX@Z
.text$mn:000013E4 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:000013E4                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:000013E4
.text$mn:000013E4 arg_4           = dword ptr  0Ch
.text$mn:000013E4
.text$mn:000013E4                 push    ebp
.text$mn:000013E5                 mov     ebp, esp
.text$mn:000013E7                 mov     eax, [ebp+arg_4]
.text$mn:000013EA                 pop     ebp
.text$mn:000013EB                 retn
.text$mn:000013EB ??2@YAPAXIPAX@Z endp
.text$mn:000013EB
.text$mn:000013EB _text$mn        ends
.text$mn:000013EB
.text$mn:000013EC ; ===========================================================================
.text$mn:000013EC
.text$mn:000013EC ; Segment type: Pure code
.text$mn:000013EC ; Segment permissions: Read/Execute
.text$mn:000013EC _text$mn        segment para public 'CODE' use32
.text$mn:000013EC                 assume cs:_text$mn
.text$mn:000013EC                 ;org 13ECh
.text$mn:000013EC ; COMDAT (pick any)
.text$mn:000013EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013EC
.text$mn:000013EC ; =============== S U B R O U T I N E =======================================
.text$mn:000013EC
.text$mn:000013EC ; Attributes: bp-based frame
.text$mn:000013EC
.text$mn:000013EC ; void __cdecl operator delete(void *)
.text$mn:000013EC                 public ??3@YAXPAX0@Z
.text$mn:000013EC ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:000013EC                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:000013EC                 push    ebp
.text$mn:000013ED                 mov     ebp, esp
.text$mn:000013EF                 pop     ebp
.text$mn:000013F0                 retn
.text$mn:000013F0 ??3@YAXPAX0@Z   endp
.text$mn:000013F0
.text$mn:000013F0 ; ---------------------------------------------------------------------------
.text$mn:000013F1                 align 4
.text$mn:000013F1 _text$mn        ends
.text$mn:000013F1
.text$mn:000013F4 ; ===========================================================================
.text$mn:000013F4
.text$mn:000013F4 ; Segment type: Pure code
.text$mn:000013F4 ; Segment permissions: Read/Execute
.text$mn:000013F4 _text$mn        segment para public 'CODE' use32
.text$mn:000013F4                 assume cs:_text$mn
.text$mn:000013F4                 ;org 13F4h
.text$mn:000013F4 ; COMDAT (pick any)
.text$mn:000013F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013F4
.text$mn:000013F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000013F4
.text$mn:000013F4 ; Attributes: bp-based frame
.text$mn:000013F4
.text$mn:000013F4 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:000013F4                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:000013F4 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:000013F4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:000013F4                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:000013F4
.text$mn:000013F4 var_8           = dword ptr -8
.text$mn:000013F4 var_4           = dword ptr -4
.text$mn:000013F4 arg_0           = dword ptr  8
.text$mn:000013F4
.text$mn:000013F4                 push    ebp
.text$mn:000013F5                 mov     ebp, esp
.text$mn:000013F7                 sub     esp, 8
.text$mn:000013FA                 mov     [ebp+var_8], ecx
.text$mn:000013FD                 mov     eax, [ebp+var_8]
.text$mn:00001400                 cmp     eax, [ebp+arg_0]
.text$mn:00001403                 jnz     short loc_140E
.text$mn:00001405                 mov     [ebp+var_4], 1
.text$mn:0000140C                 jmp     short loc_1415
.text$mn:0000140E ; ---------------------------------------------------------------------------
.text$mn:0000140E
.text$mn:0000140E loc_140E:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:0000140E                 mov     [ebp+var_4], 0
.text$mn:00001415
.text$mn:00001415 loc_1415:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00001415                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001418                 mov     esp, ebp
.text$mn:0000141A                 pop     ebp
.text$mn:0000141B                 retn    4
.text$mn:0000141B ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:0000141B
.text$mn:0000141B ; ---------------------------------------------------------------------------
.text$mn:0000141E                 align 10h
.text$mn:0000141E _text$mn        ends
.text$mn:0000141E
.text$mn:00001420 ; ===========================================================================
.text$mn:00001420
.text$mn:00001420 ; Segment type: Pure code
.text$mn:00001420 ; Segment permissions: Read/Execute
.text$mn:00001420 _text$mn        segment para public 'CODE' use32
.text$mn:00001420                 assume cs:_text$mn
.text$mn:00001420                 ;org 1420h
.text$mn:00001420 ; COMDAT (pick any)
.text$mn:00001420                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001420
.text$mn:00001420 ; =============== S U B R O U T I N E =======================================
.text$mn:00001420
.text$mn:00001420 ; Attributes: bp-based frame
.text$mn:00001420
.text$mn:00001420 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00001420                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00001420 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00001420                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00001420
.text$mn:00001420 var_8           = dword ptr -8
.text$mn:00001420 var_4           = dword ptr -4
.text$mn:00001420 arg_0           = dword ptr  8
.text$mn:00001420
.text$mn:00001420                 push    ebp
.text$mn:00001421                 mov     ebp, esp
.text$mn:00001423                 sub     esp, 8
.text$mn:00001426                 push    esi
.text$mn:00001427                 mov     [ebp+var_4], ecx
.text$mn:0000142A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000142D                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001432                 push    eax
.text$mn:00001433                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001436                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000143B                 mov     ecx, eax
.text$mn:0000143D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001442                 movzx   eax, al
.text$mn:00001445                 test    eax, eax
.text$mn:00001447                 jz      short loc_1468
.text$mn:00001449                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000144C                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001451                 mov     esi, eax
.text$mn:00001453                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001456                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:0000145B                 cmp     esi, eax
.text$mn:0000145D                 jnz     short loc_1468
.text$mn:0000145F                 mov     [ebp+var_8], 1
.text$mn:00001466                 jmp     short loc_146F
.text$mn:00001468 ; ---------------------------------------------------------------------------
.text$mn:00001468
.text$mn:00001468 loc_1468:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00001468                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00001468                 mov     [ebp+var_8], 0
.text$mn:0000146F
.text$mn:0000146F loc_146F:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:0000146F                 mov     al, byte ptr [ebp+var_8]
.text$mn:00001472                 pop     esi
.text$mn:00001473                 mov     esp, ebp
.text$mn:00001475                 pop     ebp
.text$mn:00001476                 retn    4
.text$mn:00001476 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00001476
.text$mn:00001476 ; ---------------------------------------------------------------------------
.text$mn:00001479                 align 4
.text$mn:00001479 _text$mn        ends
.text$mn:00001479
.text$mn:0000147C ; ===========================================================================
.text$mn:0000147C
.text$mn:0000147C ; Segment type: Pure code
.text$mn:0000147C ; Segment permissions: Read/Execute
.text$mn:0000147C _text$mn        segment para public 'CODE' use32
.text$mn:0000147C                 assume cs:_text$mn
.text$mn:0000147C                 ;org 147Ch
.text$mn:0000147C ; COMDAT (pick any)
.text$mn:0000147C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000147C
.text$mn:0000147C ; =============== S U B R O U T I N E =======================================
.text$mn:0000147C
.text$mn:0000147C ; Attributes: bp-based frame
.text$mn:0000147C
.text$mn:0000147C ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000147C                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:0000147C ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000147C
.text$mn:0000147C var_4           = dword ptr -4
.text$mn:0000147C arg_0           = dword ptr  8
.text$mn:0000147C
.text$mn:0000147C                 push    ebp
.text$mn:0000147D                 mov     ebp, esp
.text$mn:0000147F                 push    ecx
.text$mn:00001480                 mov     [ebp+var_4], ecx
.text$mn:00001483                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001486                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000148B                 mov     eax, [ebp+arg_0]
.text$mn:0000148E                 and     eax, 1
.text$mn:00001491                 jz      short loc_149F
.text$mn:00001493                 mov     ecx, [ebp+var_4]
.text$mn:00001496                 push    ecx             ; void *
.text$mn:00001497                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000149C                 add     esp, 4
.text$mn:0000149F
.text$mn:0000149F loc_149F:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000149F                 mov     eax, [ebp+var_4]
.text$mn:000014A2                 mov     esp, ebp
.text$mn:000014A4                 pop     ebp
.text$mn:000014A5                 retn    4
.text$mn:000014A5 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:000014A5
.text$mn:000014A5 _text$mn        ends
.text$mn:000014A5
.text$mn:000014A8 ; ===========================================================================
.text$mn:000014A8
.text$mn:000014A8 ; Segment type: Pure code
.text$mn:000014A8 ; Segment permissions: Read/Execute
.text$mn:000014A8 _text$mn        segment para public 'CODE' use32
.text$mn:000014A8                 assume cs:_text$mn
.text$mn:000014A8                 ;org 14A8h
.text$mn:000014A8 ; COMDAT (pick any)
.text$mn:000014A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014A8
.text$mn:000014A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014A8
.text$mn:000014A8 ; Attributes: bp-based frame
.text$mn:000014A8
.text$mn:000014A8 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000014A8                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:000014A8 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:000014A8
.text$mn:000014A8 var_4           = dword ptr -4
.text$mn:000014A8 arg_0           = dword ptr  8
.text$mn:000014A8
.text$mn:000014A8                 push    ebp
.text$mn:000014A9                 mov     ebp, esp
.text$mn:000014AB                 push    ecx
.text$mn:000014AC                 mov     [ebp+var_4], ecx
.text$mn:000014AF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000014B2                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:000014B7                 mov     eax, [ebp+arg_0]
.text$mn:000014BA                 and     eax, 1
.text$mn:000014BD                 jz      short loc_14CB
.text$mn:000014BF                 mov     ecx, [ebp+var_4]
.text$mn:000014C2                 push    ecx             ; void *
.text$mn:000014C3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000014C8                 add     esp, 4
.text$mn:000014CB
.text$mn:000014CB loc_14CB:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000014CB                 mov     eax, [ebp+var_4]
.text$mn:000014CE                 mov     esp, ebp
.text$mn:000014D0                 pop     ebp
.text$mn:000014D1                 retn    4
.text$mn:000014D1 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:000014D1
.text$mn:000014D1 _text$mn        ends
.text$mn:000014D1
.text$mn:000014D4 ; ===========================================================================
.text$mn:000014D4
.text$mn:000014D4 ; Segment type: Pure code
.text$mn:000014D4 ; Segment permissions: Read/Execute
.text$mn:000014D4 _text$mn        segment para public 'CODE' use32
.text$mn:000014D4                 assume cs:_text$mn
.text$mn:000014D4                 ;org 14D4h
.text$mn:000014D4 ; COMDAT (pick any)
.text$mn:000014D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014D4
.text$mn:000014D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000014D4
.text$mn:000014D4 ; Attributes: bp-based frame
.text$mn:000014D4
.text$mn:000014D4 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000014D4                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:000014D4 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:000014D4
.text$mn:000014D4 var_4           = dword ptr -4
.text$mn:000014D4 arg_0           = dword ptr  8
.text$mn:000014D4
.text$mn:000014D4                 push    ebp
.text$mn:000014D5                 mov     ebp, esp
.text$mn:000014D7                 push    ecx
.text$mn:000014D8                 mov     [ebp+var_4], ecx
.text$mn:000014DB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000014DE                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:000014E3                 mov     eax, [ebp+arg_0]
.text$mn:000014E6                 and     eax, 1
.text$mn:000014E9                 jz      short loc_14F7
.text$mn:000014EB                 mov     ecx, [ebp+var_4]
.text$mn:000014EE                 push    ecx             ; void *
.text$mn:000014EF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000014F4                 add     esp, 4
.text$mn:000014F7
.text$mn:000014F7 loc_14F7:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000014F7                 mov     eax, [ebp+var_4]
.text$mn:000014FA                 mov     esp, ebp
.text$mn:000014FC                 pop     ebp
.text$mn:000014FD                 retn    4
.text$mn:000014FD ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:000014FD
.text$mn:000014FD _text$mn        ends
.text$mn:000014FD
.text$mn:00001500 ; ===========================================================================
.text$mn:00001500
.text$mn:00001500 ; Segment type: Pure code
.text$mn:00001500 ; Segment permissions: Read/Execute
.text$mn:00001500 _text$mn        segment para public 'CODE' use32
.text$mn:00001500                 assume cs:_text$mn
.text$mn:00001500                 ;org 1500h
.text$mn:00001500 ; COMDAT (pick any)
.text$mn:00001500                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001500
.text$mn:00001500 ; =============== S U B R O U T I N E =======================================
.text$mn:00001500
.text$mn:00001500 ; Attributes: bp-based frame
.text$mn:00001500
.text$mn:00001500 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001500                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00001500 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00001500
.text$mn:00001500 var_4           = dword ptr -4
.text$mn:00001500 arg_0           = dword ptr  8
.text$mn:00001500
.text$mn:00001500                 push    ebp
.text$mn:00001501                 mov     ebp, esp
.text$mn:00001503                 push    ecx
.text$mn:00001504                 mov     [ebp+var_4], ecx
.text$mn:00001507                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000150A                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000150F                 mov     eax, [ebp+arg_0]
.text$mn:00001512                 and     eax, 1
.text$mn:00001515                 jz      short loc_1523
.text$mn:00001517                 mov     ecx, [ebp+var_4]
.text$mn:0000151A                 push    ecx             ; void *
.text$mn:0000151B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001520                 add     esp, 4
.text$mn:00001523
.text$mn:00001523 loc_1523:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001523                 mov     eax, [ebp+var_4]
.text$mn:00001526                 mov     esp, ebp
.text$mn:00001528                 pop     ebp
.text$mn:00001529                 retn    4
.text$mn:00001529 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00001529
.text$mn:00001529 _text$mn        ends
.text$mn:00001529
.text$mn:0000152C ; ===========================================================================
.text$mn:0000152C
.text$mn:0000152C ; Segment type: Pure code
.text$mn:0000152C ; Segment permissions: Read/Execute
.text$mn:0000152C _text$mn        segment para public 'CODE' use32
.text$mn:0000152C                 assume cs:_text$mn
.text$mn:0000152C                 ;org 152Ch
.text$mn:0000152C ; COMDAT (pick any)
.text$mn:0000152C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000152C
.text$mn:0000152C ; =============== S U B R O U T I N E =======================================
.text$mn:0000152C
.text$mn:0000152C ; Attributes: bp-based frame
.text$mn:0000152C
.text$mn:0000152C ; public: virtual void * __thiscall std::runtime_error::`scalar deleting destructor'(unsigned int)
.text$mn:0000152C                 public ??_Gruntime_error@std@@UAEPAXI@Z
.text$mn:0000152C ??_Gruntime_error@std@@UAEPAXI@Z proc near
.text$mn:0000152C
.text$mn:0000152C var_4           = dword ptr -4
.text$mn:0000152C arg_0           = dword ptr  8
.text$mn:0000152C
.text$mn:0000152C                 push    ebp
.text$mn:0000152D                 mov     ebp, esp
.text$mn:0000152F                 push    ecx
.text$mn:00001530                 mov     [ebp+var_4], ecx
.text$mn:00001533                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001536                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:0000153B                 mov     eax, [ebp+arg_0]
.text$mn:0000153E                 and     eax, 1
.text$mn:00001541                 jz      short loc_154F
.text$mn:00001543                 mov     ecx, [ebp+var_4]
.text$mn:00001546                 push    ecx             ; void *
.text$mn:00001547                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000154C                 add     esp, 4
.text$mn:0000154F
.text$mn:0000154F loc_154F:                               ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+15j
.text$mn:0000154F                 mov     eax, [ebp+var_4]
.text$mn:00001552                 mov     esp, ebp
.text$mn:00001554                 pop     ebp
.text$mn:00001555                 retn    4
.text$mn:00001555 ??_Gruntime_error@std@@UAEPAXI@Z endp
.text$mn:00001555
.text$mn:00001555 _text$mn        ends
.text$mn:00001555
.text$di:00001558 ; ===========================================================================
.text$di:00001558
.text$di:00001558 ; Segment type: Pure code
.text$di:00001558 ; Segment permissions: Read/Execute
.text$di:00001558 _text$di        segment para public 'CODE' use32
.text$di:00001558                 assume cs:_text$di
.text$di:00001558                 ;org 1558h
.text$di:00001558 ; COMDAT (pick any)
.text$di:00001558                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001558
.text$di:00001558 ; =============== S U B R O U T I N E =======================================
.text$di:00001558
.text$di:00001558 ; Attributes: bp-based frame
.text$di:00001558
.text$di:00001558 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00001558 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00001558                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00001558                 push    ebp
.text$di:00001559                 mov     ebp, esp
.text$di:0000155B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00001560                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00001565                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000156A                 call    _atexit
.text$di:0000156F                 add     esp, 4
.text$di:00001572                 pop     ebp
.text$di:00001573                 retn
.text$di:00001573 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00001573
.text$di:00001573 _text$di        ends
.text$di:00001573
.text$di:00001574 ; ===========================================================================
.text$di:00001574
.text$di:00001574 ; Segment type: Pure code
.text$di:00001574 ; Segment permissions: Read/Execute
.text$di:00001574 _text$di        segment para public 'CODE' use32
.text$di:00001574                 assume cs:_text$di
.text$di:00001574                 ;org 1574h
.text$di:00001574 ; COMDAT (pick any)
.text$di:00001574                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001574
.text$di:00001574 ; =============== S U B R O U T I N E =======================================
.text$di:00001574
.text$di:00001574 ; Attributes: bp-based frame
.text$di:00001574
.text$di:00001574 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00001574 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00001574                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00001574                 push    ebp
.text$di:00001575                 mov     ebp, esp
.text$di:00001577                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:0000157C                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00001581                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001586                 call    _atexit
.text$di:0000158B                 add     esp, 4
.text$di:0000158E                 pop     ebp
.text$di:0000158F                 retn
.text$di:0000158F ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:0000158F
.text$di:0000158F _text$di        ends
.text$di:0000158F
.text$di:00001590 ; ===========================================================================
.text$di:00001590
.text$di:00001590 ; Segment type: Pure code
.text$di:00001590 ; Segment permissions: Read/Execute
.text$di:00001590 _text$di        segment para public 'CODE' use32
.text$di:00001590                 assume cs:_text$di
.text$di:00001590                 ;org 1590h
.text$di:00001590 ; COMDAT (pick any)
.text$di:00001590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001590
.text$di:00001590 ; =============== S U B R O U T I N E =======================================
.text$di:00001590
.text$di:00001590 ; Attributes: bp-based frame
.text$di:00001590
.text$di:00001590 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00001590 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00001590                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00001590                 push    ebp
.text$di:00001591                 mov     ebp, esp
.text$di:00001593                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00001598                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:0000159D                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000015A2                 call    _atexit
.text$di:000015A7                 add     esp, 4
.text$di:000015AA                 pop     ebp
.text$di:000015AB                 retn
.text$di:000015AB ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:000015AB
.text$di:000015AB _text$di        ends
.text$di:000015AB
.text$di:000015AC ; ===========================================================================
.text$di:000015AC
.text$di:000015AC ; Segment type: Pure code
.text$di:000015AC ; Segment permissions: Read/Execute
.text$di:000015AC _text$di        segment para public 'CODE' use32
.text$di:000015AC                 assume cs:_text$di
.text$di:000015AC                 ;org 15ACh
.text$di:000015AC ; COMDAT (pick any)
.text$di:000015AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000015AC
.text$di:000015AC ; =============== S U B R O U T I N E =======================================
.text$di:000015AC
.text$di:000015AC ; Attributes: bp-based frame
.text$di:000015AC
.text$di:000015AC ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:000015AC ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:000015AC
.text$di:000015AC var_1           = byte ptr -1
.text$di:000015AC
.text$di:000015AC                 push    ebp
.text$di:000015AD                 mov     ebp, esp
.text$di:000015AF                 push    ecx
.text$di:000015B0                 xor     eax, eax
.text$di:000015B2                 mov     [ebp+var_1], al
.text$di:000015B5                 mov     esp, ebp
.text$di:000015B7                 pop     ebp
.text$di:000015B8                 retn
.text$di:000015B8 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:000015B8
.text$di:000015B8 ; ---------------------------------------------------------------------------
.text$di:000015B9                 align 4
.text$di:000015B9 _text$di        ends
.text$di:000015B9
.text$di:000015BC ; ===========================================================================
.text$di:000015BC
.text$di:000015BC ; Segment type: Pure code
.text$di:000015BC ; Segment permissions: Read/Execute
.text$di:000015BC _text$di        segment para public 'CODE' use32
.text$di:000015BC                 assume cs:_text$di
.text$di:000015BC                 ;org 15BCh
.text$di:000015BC ; COMDAT (pick any)
.text$di:000015BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000015BC
.text$di:000015BC ; =============== S U B R O U T I N E =======================================
.text$di:000015BC
.text$di:000015BC ; Attributes: bp-based frame
.text$di:000015BC
.text$di:000015BC ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:000015BC ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:000015BC                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:000015BC
.text$di:000015BC var_1           = byte ptr -1
.text$di:000015BC
.text$di:000015BC                 push    ebp
.text$di:000015BD                 mov     ebp, esp
.text$di:000015BF                 push    ecx
.text$di:000015C0                 xor     eax, eax
.text$di:000015C2                 mov     [ebp+var_1], al
.text$di:000015C5                 mov     esp, ebp
.text$di:000015C7                 pop     ebp
.text$di:000015C8                 retn
.text$di:000015C8 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:000015C8
.text$di:000015C8 ; ---------------------------------------------------------------------------
.text$di:000015C9                 align 4
.text$di:000015C9 _text$di        ends
.text$di:000015C9
.text$yd:000015CC ; ===========================================================================
.text$yd:000015CC
.text$yd:000015CC ; Segment type: Pure code
.text$yd:000015CC ; Segment permissions: Read/Execute
.text$yd:000015CC _text$yd        segment para public 'CODE' use32
.text$yd:000015CC                 assume cs:_text$yd
.text$yd:000015CC                 ;org 15CCh
.text$yd:000015CC ; COMDAT (pick any)
.text$yd:000015CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000015CC
.text$yd:000015CC ; =============== S U B R O U T I N E =======================================
.text$yd:000015CC
.text$yd:000015CC ; Attributes: bp-based frame
.text$yd:000015CC
.text$yd:000015CC ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:000015CC ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:000015CC                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:000015CC                 push    ebp
.text$yd:000015CD                 mov     ebp, esp
.text$yd:000015CF                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:000015D4                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:000015D9                 pop     ebp
.text$yd:000015DA                 retn
.text$yd:000015DA ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:000015DA
.text$yd:000015DA ; ---------------------------------------------------------------------------
.text$yd:000015DB                 align 4
.text$yd:000015DB _text$yd        ends
.text$yd:000015DB
.text$yd:000015DC ; ===========================================================================
.text$yd:000015DC
.text$yd:000015DC ; Segment type: Pure code
.text$yd:000015DC ; Segment permissions: Read/Execute
.text$yd:000015DC _text$yd        segment para public 'CODE' use32
.text$yd:000015DC                 assume cs:_text$yd
.text$yd:000015DC                 ;org 15DCh
.text$yd:000015DC ; COMDAT (pick any)
.text$yd:000015DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000015DC
.text$yd:000015DC ; =============== S U B R O U T I N E =======================================
.text$yd:000015DC
.text$yd:000015DC ; Attributes: bp-based frame
.text$yd:000015DC
.text$yd:000015DC ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:000015DC ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:000015DC                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:000015DC                 push    ebp
.text$yd:000015DD                 mov     ebp, esp
.text$yd:000015DF                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:000015E4                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:000015E9                 pop     ebp
.text$yd:000015EA                 retn
.text$yd:000015EA ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:000015EA
.text$yd:000015EA ; ---------------------------------------------------------------------------
.text$yd:000015EB                 align 4
.text$yd:000015EB _text$yd        ends
.text$yd:000015EB
.text$yd:000015EC ; ===========================================================================
.text$yd:000015EC
.text$yd:000015EC ; Segment type: Pure code
.text$yd:000015EC ; Segment permissions: Read/Execute
.text$yd:000015EC _text$yd        segment para public 'CODE' use32
.text$yd:000015EC                 assume cs:_text$yd
.text$yd:000015EC                 ;org 15ECh
.text$yd:000015EC ; COMDAT (pick any)
.text$yd:000015EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000015EC
.text$yd:000015EC ; =============== S U B R O U T I N E =======================================
.text$yd:000015EC
.text$yd:000015EC ; Attributes: bp-based frame
.text$yd:000015EC
.text$yd:000015EC ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:000015EC ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:000015EC                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:000015EC                 push    ebp
.text$yd:000015ED                 mov     ebp, esp
.text$yd:000015EF                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:000015F4                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:000015F9                 pop     ebp
.text$yd:000015FA                 retn
.text$yd:000015FA ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:000015FA
.text$yd:000015FA ; ---------------------------------------------------------------------------
.text$yd:000015FB                 align 4
.text$yd:000015FB _text$yd        ends
.text$yd:000015FB
.text$mn:000015FC ; ===========================================================================
.text$mn:000015FC
.text$mn:000015FC ; Segment type: Pure code
.text$mn:000015FC ; Segment permissions: Read/Execute
.text$mn:000015FC _text$mn        segment para public 'CODE' use32
.text$mn:000015FC                 assume cs:_text$mn
.text$mn:000015FC                 ;org 15FCh
.text$mn:000015FC ; COMDAT (pick any)
.text$mn:000015FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015FC
.text$mn:000015FC ; =============== S U B R O U T I N E =======================================
.text$mn:000015FC
.text$mn:000015FC ; Attributes: bp-based frame
.text$mn:000015FC
.text$mn:000015FC ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000015FC                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000015FC ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000015FC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:000015FC
.text$mn:000015FC var_10          = byte ptr -10h
.text$mn:000015FC var_8           = dword ptr -8
.text$mn:000015FC var_1           = byte ptr -1
.text$mn:000015FC
.text$mn:000015FC                 push    ebp
.text$mn:000015FD                 mov     ebp, esp
.text$mn:000015FF                 sub     esp, 10h
.text$mn:00001602                 mov     [ebp+var_8], ecx
.text$mn:00001605                 lea     ecx, [ebp+var_1]
.text$mn:00001608                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000160D                 push    1
.text$mn:0000160F                 lea     ecx, [ebp+var_1]
.text$mn:00001612                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00001617                 mov     ecx, [ebp+var_8]
.text$mn:0000161A                 mov     [ecx], eax
.text$mn:0000161C                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000161F                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001624                 push    eax             ; int
.text$mn:00001625                 mov     edx, [ebp+var_8]
.text$mn:00001628                 mov     eax, [edx]
.text$mn:0000162A                 push    eax             ; void *
.text$mn:0000162B                 lea     ecx, [ebp+var_1]
.text$mn:0000162E                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001633                 mov     ecx, [ebp+var_8]
.text$mn:00001636                 mov     edx, [ecx]
.text$mn:00001638                 mov     eax, [ebp+var_8]
.text$mn:0000163B                 mov     [edx], eax
.text$mn:0000163D                 mov     esp, ebp
.text$mn:0000163F                 pop     ebp
.text$mn:00001640                 retn
.text$mn:00001640 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001640
.text$mn:00001640 ; ---------------------------------------------------------------------------
.text$mn:00001641                 align 4
.text$mn:00001641 _text$mn        ends
.text$mn:00001641
.text$mn:00001644 ; ===========================================================================
.text$mn:00001644
.text$mn:00001644 ; Segment type: Pure code
.text$mn:00001644 ; Segment permissions: Read/Execute
.text$mn:00001644 _text$mn        segment para public 'CODE' use32
.text$mn:00001644                 assume cs:_text$mn
.text$mn:00001644                 ;org 1644h
.text$mn:00001644 ; COMDAT (pick any)
.text$mn:00001644                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001644
.text$mn:00001644 ; =============== S U B R O U T I N E =======================================
.text$mn:00001644
.text$mn:00001644 ; Attributes: bp-based frame
.text$mn:00001644
.text$mn:00001644 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00001644                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001644 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00001644                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00001644
.text$mn:00001644 var_20          = dword ptr -20h
.text$mn:00001644 var_1C          = dword ptr -1Ch
.text$mn:00001644 var_18          = dword ptr -18h
.text$mn:00001644 var_11          = byte ptr -11h
.text$mn:00001644 var_10          = dword ptr -10h
.text$mn:00001644 var_C           = byte ptr -0Ch
.text$mn:00001644 var_4           = dword ptr -4
.text$mn:00001644 arg_0           = dword ptr  8
.text$mn:00001644
.text$mn:00001644 ; FUNCTION CHUNK AT .text$mn:00001766 SIZE 00000009 BYTES
.text$mn:00001644
.text$mn:00001644                 push    ebp
.text$mn:00001645                 mov     ebp, esp
.text$mn:00001647                 push    0FFFFFFFFh
.text$mn:00001649                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000164E                 mov     eax, large fs:0
.text$mn:00001654                 push    eax
.text$mn:00001655                 push    ecx
.text$mn:00001656                 sub     esp, 10h
.text$mn:00001659                 push    ebx
.text$mn:0000165A                 push    esi
.text$mn:0000165B                 push    edi
.text$mn:0000165C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001661                 xor     eax, ebp
.text$mn:00001663                 push    eax
.text$mn:00001664                 lea     eax, [ebp+var_C]
.text$mn:00001667                 mov     large fs:0, eax
.text$mn:0000166D                 mov     [ebp+var_10], esp
.text$mn:00001670                 mov     [ebp+var_18], ecx
.text$mn:00001673                 mov     eax, [ebp+arg_0]
.text$mn:00001676                 or      eax, 0Fh
.text$mn:00001679                 mov     [ebp+var_1C], eax
.text$mn:0000167C                 mov     ecx, [ebp+var_18]
.text$mn:0000167F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001684                 cmp     eax, [ebp+var_1C]
.text$mn:00001687                 jnb     short loc_1691
.text$mn:00001689                 mov     ecx, [ebp+arg_0]
.text$mn:0000168C                 mov     [ebp+var_1C], ecx
.text$mn:0000168F                 jmp     short loc_16E3
.text$mn:00001691 ; ---------------------------------------------------------------------------
.text$mn:00001691
.text$mn:00001691 loc_1691:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00001691                 mov     edx, [ebp+var_18]
.text$mn:00001694                 mov     ecx, [edx+18h]
.text$mn:00001697                 shr     ecx, 1
.text$mn:00001699                 mov     eax, [ebp+var_1C]
.text$mn:0000169C                 xor     edx, edx
.text$mn:0000169E                 mov     esi, 3
.text$mn:000016A3                 div     esi
.text$mn:000016A5                 cmp     ecx, eax
.text$mn:000016A7                 ja      short loc_16AB
.text$mn:000016A9                 jmp     short loc_16E3
.text$mn:000016AB ; ---------------------------------------------------------------------------
.text$mn:000016AB
.text$mn:000016AB loc_16AB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:000016AB                 mov     ecx, [ebp+var_18]
.text$mn:000016AE                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000016B3                 mov     edx, [ebp+var_18]
.text$mn:000016B6                 mov     ecx, [edx+18h]
.text$mn:000016B9                 shr     ecx, 1
.text$mn:000016BB                 sub     eax, ecx
.text$mn:000016BD                 mov     edx, [ebp+var_18]
.text$mn:000016C0                 cmp     [edx+18h], eax
.text$mn:000016C3                 ja      short loc_16D8
.text$mn:000016C5                 mov     eax, [ebp+var_18]
.text$mn:000016C8                 mov     ecx, [eax+18h]
.text$mn:000016CB                 shr     ecx, 1
.text$mn:000016CD                 mov     edx, [ebp+var_18]
.text$mn:000016D0                 add     ecx, [edx+18h]
.text$mn:000016D3                 mov     [ebp+var_1C], ecx
.text$mn:000016D6                 jmp     short loc_16E3
.text$mn:000016D8 ; ---------------------------------------------------------------------------
.text$mn:000016D8
.text$mn:000016D8 loc_16D8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:000016D8                 mov     ecx, [ebp+var_18]
.text$mn:000016DB                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000016E0                 mov     [ebp+var_1C], eax
.text$mn:000016E3
.text$mn:000016E3 loc_16E3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:000016E3                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:000016E3                 mov     [ebp+var_4], 0
.text$mn:000016EA                 mov     eax, [ebp+var_1C]
.text$mn:000016ED                 add     eax, 1
.text$mn:000016F0                 push    eax
.text$mn:000016F1                 lea     ecx, [ebp+var_11]
.text$mn:000016F4                 push    ecx
.text$mn:000016F5                 mov     ecx, [ebp+var_18]
.text$mn:000016F8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000016FD                 mov     ecx, eax
.text$mn:000016FF                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001704                 mov     [ebp+var_20], eax
.text$mn:00001707                 jmp     short loc_1766
.text$mn:00001707 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00001707
.text$mn:00001709
.text$mn:00001709 ; =============== S U B R O U T I N E =======================================
.text$mn:00001709
.text$mn:00001709
.text$mn:00001709 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00001709                                         ; DATA XREF: .xdata$x:000024F8o
.text$mn:00001709
.text$mn:00001709 ; FUNCTION CHUNK AT .text$mn:00001750 SIZE 00000009 BYTES
.text$mn:00001709 ; FUNCTION CHUNK AT .text$mn:00001760 SIZE 00000006 BYTES
.text$mn:00001709
.text$mn:00001709                 mov     [ebp-10h], esp
.text$mn:0000170C                 mov     edx, [ebp+8]
.text$mn:0000170F                 mov     [ebp-1Ch], edx
.text$mn:00001712                 mov     byte ptr [ebp-4], 2
.text$mn:00001716                 mov     eax, [ebp-1Ch]
.text$mn:00001719                 add     eax, 1
.text$mn:0000171C                 push    eax
.text$mn:0000171D                 lea     ecx, [ebp-12h]
.text$mn:00001720                 push    ecx
.text$mn:00001721                 mov     ecx, [ebp-18h]
.text$mn:00001724                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001729                 mov     ecx, eax
.text$mn:0000172B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001730                 mov     [ebp-20h], eax
.text$mn:00001733                 jmp     short loc_1750
.text$mn:00001733 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00001733
.text$mn:00001735
.text$mn:00001735 ; =============== S U B R O U T I N E =======================================
.text$mn:00001735
.text$mn:00001735 ; Attributes: noreturn
.text$mn:00001735
.text$mn:00001735 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00001735                                         ; DATA XREF: .xdata$x:00002508o
.text$mn:00001735                 push    0               ; Size
.text$mn:00001737                 push    1               ; char
.text$mn:00001739                 mov     ecx, [ebp-18h]
.text$mn:0000173C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001741                 push    0
.text$mn:00001743                 push    0
.text$mn:00001745                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001745 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00001745
.text$mn:0000174A ; ---------------------------------------------------------------------------
.text$mn:0000174A                 mov     eax, offset $LN17
.text$mn:0000174F                 retn
.text$mn:00001750 ; ---------------------------------------------------------------------------
.text$mn:00001750 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001750
.text$mn:00001750 loc_1750:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00001750                 mov     dword ptr [ebp-4], 1
.text$mn:00001757                 jmp     short loc_1760
.text$mn:00001757 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001759
.text$mn:00001759 ; =============== S U B R O U T I N E =======================================
.text$mn:00001759
.text$mn:00001759
.text$mn:00001759 $LN17           proc near               ; DATA XREF: .text$mn:0000174Ao
.text$mn:00001759                 mov     dword ptr [ebp-4], 1
.text$mn:00001759 $LN17           endp ; sp-analysis failed
.text$mn:00001759
.text$mn:00001760 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001760
.text$mn:00001760 loc_1760:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00001760                 mov     eax, offset $LN19
.text$mn:00001765                 retn
.text$mn:00001765 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001766 ; ---------------------------------------------------------------------------
.text$mn:00001766 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001766
.text$mn:00001766 loc_1766:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00001766                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000176D                 jmp     short loc_1776
.text$mn:0000176D ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000176F
.text$mn:0000176F ; =============== S U B R O U T I N E =======================================
.text$mn:0000176F
.text$mn:0000176F
.text$mn:0000176F $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_1760o
.text$mn:0000176F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001776
.text$mn:00001776 loc_1776:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00001776                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000177A                 jbe     short loc_1795
.text$mn:0000177C                 mov     edx, [ebp+0Ch]
.text$mn:0000177F                 push    edx             ; Size
.text$mn:00001780                 mov     ecx, [ebp-18h]
.text$mn:00001783                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001788                 push    eax             ; Src
.text$mn:00001789                 mov     eax, [ebp-20h]
.text$mn:0000178C                 push    eax             ; Dst
.text$mn:0000178D                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001792                 add     esp, 0Ch
.text$mn:00001795
.text$mn:00001795 loc_1795:                               ; CODE XREF: $LN19+Bj
.text$mn:00001795                 push    0               ; Size
.text$mn:00001797                 push    1               ; char
.text$mn:00001799                 mov     ecx, [ebp-18h]
.text$mn:0000179C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000017A1                 lea     ecx, [ebp-20h]
.text$mn:000017A4                 push    ecx             ; int
.text$mn:000017A5                 mov     edx, [ebp-18h]
.text$mn:000017A8                 add     edx, 4
.text$mn:000017AB                 push    edx             ; void *
.text$mn:000017AC                 lea     eax, [ebp-13h]
.text$mn:000017AF                 push    eax
.text$mn:000017B0                 mov     ecx, [ebp-18h]
.text$mn:000017B3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000017B8                 mov     ecx, eax
.text$mn:000017BA                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000017BF                 mov     ecx, [ebp-18h]
.text$mn:000017C2                 mov     edx, [ebp-1Ch]
.text$mn:000017C5                 mov     [ecx+18h], edx
.text$mn:000017C8                 mov     eax, [ebp+0Ch]
.text$mn:000017CB                 push    eax
.text$mn:000017CC                 mov     ecx, [ebp-18h]
.text$mn:000017CF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000017D4                 mov     ecx, [ebp-0Ch]
.text$mn:000017D7                 mov     large fs:0, ecx
.text$mn:000017DE                 pop     ecx
.text$mn:000017DF                 pop     edi
.text$mn:000017E0                 pop     esi
.text$mn:000017E1                 pop     ebx
.text$mn:000017E2                 mov     esp, ebp
.text$mn:000017E4                 pop     ebp
.text$mn:000017E5                 retn    8
.text$mn:000017E5 $LN19           endp ; sp-analysis failed
.text$mn:000017E5
.text$mn:000017E5 _text$mn        ends
.text$mn:000017E5
.text$x:000017E8 ; ===========================================================================
.text$x:000017E8
.text$x:000017E8 ; Segment type: Pure code
.text$x:000017E8 ; Segment permissions: Read/Execute
.text$x:000017E8 _text$x         segment para public 'CODE' use32
.text$x:000017E8                 assume cs:_text$x
.text$x:000017E8                 ;org 17E8h
.text$x:000017E8 ; COMDAT (pick associative to section at 1644)
.text$x:000017E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000017E8
.text$x:000017E8 ; =============== S U B R O U T I N E =======================================
.text$x:000017E8
.text$x:000017E8
.text$x:000017E8 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:000017E8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:000017E8
.text$x:000017E8 arg_4           = dword ptr  8
.text$x:000017E8
.text$x:000017E8                 mov     edx, [esp+arg_4]
.text$x:000017EC                 lea     eax, [edx+0Ch]
.text$x:000017EF                 mov     ecx, [edx-24h]
.text$x:000017F2                 xor     ecx, eax
.text$x:000017F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000017F9                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:000017FE                 jmp     ___CxxFrameHandler3
.text$x:000017FE __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:000017FE
.text$x:000017FE ; ---------------------------------------------------------------------------
.text$x:00001803                 align 4
.text$x:00001803 _text$x         ends
.text$x:00001803
.text$mn:00001804 ; ===========================================================================
.text$mn:00001804
.text$mn:00001804 ; Segment type: Pure code
.text$mn:00001804 ; Segment permissions: Read/Execute
.text$mn:00001804 _text$mn        segment para public 'CODE' use32
.text$mn:00001804                 assume cs:_text$mn
.text$mn:00001804                 ;org 1804h
.text$mn:00001804 ; COMDAT (pick any)
.text$mn:00001804                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001804
.text$mn:00001804 ; =============== S U B R O U T I N E =======================================
.text$mn:00001804
.text$mn:00001804 ; Attributes: bp-based frame
.text$mn:00001804
.text$mn:00001804 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00001804                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00001804 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00001804                                         ; CODE XREF: $LN19+60p
.text$mn:00001804                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00001804
.text$mn:00001804 var_8           = dword ptr -8
.text$mn:00001804 var_1           = byte ptr -1
.text$mn:00001804 arg_0           = dword ptr  8
.text$mn:00001804
.text$mn:00001804                 push    ebp
.text$mn:00001805                 mov     ebp, esp
.text$mn:00001807                 sub     esp, 8
.text$mn:0000180A                 mov     [ebp+var_8], ecx
.text$mn:0000180D                 mov     [ebp+var_1], 0
.text$mn:00001811                 mov     eax, [ebp+var_8]
.text$mn:00001814                 mov     ecx, [ebp+arg_0]
.text$mn:00001817                 mov     [eax+14h], ecx
.text$mn:0000181A                 lea     edx, [ebp+var_1]
.text$mn:0000181D                 push    edx
.text$mn:0000181E                 mov     ecx, [ebp+var_8]
.text$mn:00001821                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001826                 add     eax, [ebp+arg_0]
.text$mn:00001829                 push    eax
.text$mn:0000182A                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:0000182F                 add     esp, 8
.text$mn:00001832                 mov     esp, ebp
.text$mn:00001834                 pop     ebp
.text$mn:00001835                 retn    4
.text$mn:00001835 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00001835
.text$mn:00001835 _text$mn        ends
.text$mn:00001835
.text$mn:00001838 ; ===========================================================================
.text$mn:00001838
.text$mn:00001838 ; Segment type: Pure code
.text$mn:00001838 ; Segment permissions: Read/Execute
.text$mn:00001838 _text$mn        segment para public 'CODE' use32
.text$mn:00001838                 assume cs:_text$mn
.text$mn:00001838                 ;org 1838h
.text$mn:00001838 ; COMDAT (pick any)
.text$mn:00001838                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001838
.text$mn:00001838 ; =============== S U B R O U T I N E =======================================
.text$mn:00001838
.text$mn:00001838 ; Attributes: bp-based frame
.text$mn:00001838
.text$mn:00001838 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001838                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001838 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001838                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00001838
.text$mn:00001838 var_8           = dword ptr -8
.text$mn:00001838 var_1           = byte ptr -1
.text$mn:00001838
.text$mn:00001838                 push    ebp
.text$mn:00001839                 mov     ebp, esp
.text$mn:0000183B                 sub     esp, 8
.text$mn:0000183E                 mov     [ebp+var_8], ecx
.text$mn:00001841                 lea     ecx, [ebp+var_1]
.text$mn:00001844                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001849                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000184C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001851                 mov     eax, [ebp+var_8]
.text$mn:00001854                 mov     ecx, [eax]
.text$mn:00001856                 push    ecx
.text$mn:00001857                 lea     ecx, [ebp+var_1]
.text$mn:0000185A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000185F                 push    1               ; int
.text$mn:00001861                 mov     edx, [ebp+var_8]
.text$mn:00001864                 mov     eax, [edx]
.text$mn:00001866                 push    eax             ; void *
.text$mn:00001867                 lea     ecx, [ebp+var_1]
.text$mn:0000186A                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000186F                 mov     ecx, [ebp+var_8]
.text$mn:00001872                 mov     dword ptr [ecx], 0
.text$mn:00001878                 mov     esp, ebp
.text$mn:0000187A                 pop     ebp
.text$mn:0000187B                 retn
.text$mn:0000187B ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000187B
.text$mn:0000187B _text$mn        ends
.text$mn:0000187B
.text$mn:0000187C ; ===========================================================================
.text$mn:0000187C
.text$mn:0000187C ; Segment type: Pure code
.text$mn:0000187C ; Segment permissions: Read/Execute
.text$mn:0000187C _text$mn        segment para public 'CODE' use32
.text$mn:0000187C                 assume cs:_text$mn
.text$mn:0000187C                 ;org 187Ch
.text$mn:0000187C ; COMDAT (pick any)
.text$mn:0000187C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000187C
.text$mn:0000187C ; =============== S U B R O U T I N E =======================================
.text$mn:0000187C
.text$mn:0000187C ; Attributes: bp-based frame
.text$mn:0000187C
.text$mn:0000187C ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:0000187C                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:0000187C ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:0000187C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:0000187C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:0000187C
.text$mn:0000187C var_4           = dword ptr -4
.text$mn:0000187C arg_0           = dword ptr  8
.text$mn:0000187C
.text$mn:0000187C                 push    ebp
.text$mn:0000187D                 mov     ebp, esp
.text$mn:0000187F                 push    ecx
.text$mn:00001880                 mov     [ebp+var_4], ecx
.text$mn:00001883                 mov     ecx, [ebp+arg_0]
.text$mn:00001886                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:0000188B                 mov     eax, [ebp+arg_0]
.text$mn:0000188E                 mov     esp, ebp
.text$mn:00001890                 pop     ebp
.text$mn:00001891                 retn    4
.text$mn:00001891 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00001891
.text$mn:00001891 _text$mn        ends
.text$mn:00001891
.text$mn:00001894 ; ===========================================================================
.text$mn:00001894
.text$mn:00001894 ; Segment type: Pure code
.text$mn:00001894 ; Segment permissions: Read/Execute
.text$mn:00001894 _text$mn        segment para public 'CODE' use32
.text$mn:00001894                 assume cs:_text$mn
.text$mn:00001894                 ;org 1894h
.text$mn:00001894 ; COMDAT (pick any)
.text$mn:00001894                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001894
.text$mn:00001894 ; =============== S U B R O U T I N E =======================================
.text$mn:00001894
.text$mn:00001894 ; Attributes: bp-based frame
.text$mn:00001894
.text$mn:00001894 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00001894                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00001894 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00001894                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00001894                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00001894
.text$mn:00001894 var_C           = dword ptr -0Ch
.text$mn:00001894 Size            = dword ptr -8
.text$mn:00001894 var_4           = dword ptr -4
.text$mn:00001894 arg_0           = dword ptr  8
.text$mn:00001894 arg_4           = byte ptr  0Ch
.text$mn:00001894
.text$mn:00001894                 push    ebp
.text$mn:00001895                 mov     ebp, esp
.text$mn:00001897                 sub     esp, 0Ch
.text$mn:0000189A                 mov     [ebp+var_4], ecx
.text$mn:0000189D                 mov     ecx, [ebp+var_4]
.text$mn:000018A0                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000018A5                 cmp     eax, [ebp+arg_0]
.text$mn:000018A8                 jnb     short loc_18B2
.text$mn:000018AA                 mov     ecx, [ebp+var_4]
.text$mn:000018AD                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:000018B2
.text$mn:000018B2 loc_18B2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:000018B2                 mov     eax, [ebp+var_4]
.text$mn:000018B5                 mov     ecx, [eax+18h]
.text$mn:000018B8                 cmp     ecx, [ebp+arg_0]
.text$mn:000018BB                 jnb     short loc_18D2
.text$mn:000018BD                 mov     edx, [ebp+var_4]
.text$mn:000018C0                 mov     eax, [edx+14h]
.text$mn:000018C3                 push    eax
.text$mn:000018C4                 mov     ecx, [ebp+arg_0]
.text$mn:000018C7                 push    ecx
.text$mn:000018C8                 mov     ecx, [ebp+var_4]
.text$mn:000018CB                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:000018D0                 jmp     short loc_191C
.text$mn:000018D2 ; ---------------------------------------------------------------------------
.text$mn:000018D2
.text$mn:000018D2 loc_18D2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:000018D2                 movzx   edx, [ebp+arg_4]
.text$mn:000018D6                 test    edx, edx
.text$mn:000018D8                 jz      short loc_190C
.text$mn:000018DA                 cmp     [ebp+arg_0], 10h
.text$mn:000018DE                 jnb     short loc_190C
.text$mn:000018E0                 mov     eax, [ebp+var_4]
.text$mn:000018E3                 mov     ecx, [ebp+arg_0]
.text$mn:000018E6                 cmp     ecx, [eax+14h]
.text$mn:000018E9                 jnb     short loc_18F3
.text$mn:000018EB                 mov     edx, [ebp+arg_0]
.text$mn:000018EE                 mov     [ebp+Size], edx
.text$mn:000018F1                 jmp     short loc_18FC
.text$mn:000018F3 ; ---------------------------------------------------------------------------
.text$mn:000018F3
.text$mn:000018F3 loc_18F3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:000018F3                 mov     eax, [ebp+var_4]
.text$mn:000018F6                 mov     ecx, [eax+14h]
.text$mn:000018F9                 mov     [ebp+Size], ecx
.text$mn:000018FC
.text$mn:000018FC loc_18FC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:000018FC                 mov     edx, [ebp+Size]
.text$mn:000018FF                 push    edx             ; Size
.text$mn:00001900                 push    1               ; char
.text$mn:00001902                 mov     ecx, [ebp+var_4]
.text$mn:00001905                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000190A                 jmp     short loc_191C
.text$mn:0000190C ; ---------------------------------------------------------------------------
.text$mn:0000190C
.text$mn:0000190C loc_190C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:0000190C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:0000190C                 cmp     [ebp+arg_0], 0
.text$mn:00001910                 jnz     short loc_191C
.text$mn:00001912                 push    0
.text$mn:00001914                 mov     ecx, [ebp+var_4]
.text$mn:00001917                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000191C
.text$mn:0000191C loc_191C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:0000191C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:0000191C                 cmp     [ebp+arg_0], 0
.text$mn:00001920                 jbe     short loc_192B
.text$mn:00001922                 mov     [ebp+var_C], 1
.text$mn:00001929                 jmp     short loc_1932
.text$mn:0000192B ; ---------------------------------------------------------------------------
.text$mn:0000192B
.text$mn:0000192B loc_192B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000192B                 mov     [ebp+var_C], 0
.text$mn:00001932
.text$mn:00001932 loc_1932:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00001932                 mov     al, byte ptr [ebp+var_C]
.text$mn:00001935                 mov     esp, ebp
.text$mn:00001937                 pop     ebp
.text$mn:00001938                 retn    8
.text$mn:00001938 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00001938
.text$mn:00001938 ; ---------------------------------------------------------------------------
.text$mn:0000193B                 align 4
.text$mn:0000193B _text$mn        ends
.text$mn:0000193B
.text$mn:0000193C ; ===========================================================================
.text$mn:0000193C
.text$mn:0000193C ; Segment type: Pure code
.text$mn:0000193C ; Segment permissions: Read/Execute
.text$mn:0000193C _text$mn        segment para public 'CODE' use32
.text$mn:0000193C                 assume cs:_text$mn
.text$mn:0000193C                 ;org 193Ch
.text$mn:0000193C ; COMDAT (pick any)
.text$mn:0000193C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000193C
.text$mn:0000193C ; =============== S U B R O U T I N E =======================================
.text$mn:0000193C
.text$mn:0000193C ; Attributes: bp-based frame
.text$mn:0000193C
.text$mn:0000193C ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:0000193C                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:0000193C ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:0000193C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:0000193C
.text$mn:0000193C var_4           = dword ptr -4
.text$mn:0000193C arg_0           = dword ptr  8
.text$mn:0000193C
.text$mn:0000193C                 push    ebp
.text$mn:0000193D                 mov     ebp, esp
.text$mn:0000193F                 push    ecx
.text$mn:00001940                 mov     [ebp+var_4], ecx
.text$mn:00001943                 cmp     [ebp+arg_0], 0
.text$mn:00001947                 jz      short loc_1969
.text$mn:00001949                 mov     ecx, [ebp+var_4]
.text$mn:0000194C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001951                 cmp     [ebp+arg_0], eax
.text$mn:00001954                 jb      short loc_1969
.text$mn:00001956                 mov     ecx, [ebp+var_4]
.text$mn:00001959                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000195E                 mov     ecx, [ebp+var_4]
.text$mn:00001961                 add     eax, [ecx+14h]
.text$mn:00001964                 cmp     eax, [ebp+arg_0]
.text$mn:00001967                 ja      short loc_196F
.text$mn:00001969
.text$mn:00001969 loc_1969:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00001969                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00001969                 xor     al, al
.text$mn:0000196B                 jmp     short loc_1971
.text$mn:0000196D ; ---------------------------------------------------------------------------
.text$mn:0000196D                 jmp     short loc_1971
.text$mn:0000196F ; ---------------------------------------------------------------------------
.text$mn:0000196F
.text$mn:0000196F loc_196F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000196F                 mov     al, 1
.text$mn:00001971
.text$mn:00001971 loc_1971:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00001971                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00001971                 mov     esp, ebp
.text$mn:00001973                 pop     ebp
.text$mn:00001974                 retn    4
.text$mn:00001974 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00001974
.text$mn:00001974 ; ---------------------------------------------------------------------------
.text$mn:00001977                 align 4
.text$mn:00001977 _text$mn        ends
.text$mn:00001977
.text$mn:00001978 ; ===========================================================================
.text$mn:00001978
.text$mn:00001978 ; Segment type: Pure code
.text$mn:00001978 ; Segment permissions: Read/Execute
.text$mn:00001978 _text$mn        segment para public 'CODE' use32
.text$mn:00001978                 assume cs:_text$mn
.text$mn:00001978                 ;org 1978h
.text$mn:00001978 ; COMDAT (pick any)
.text$mn:00001978                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001978
.text$mn:00001978 ; =============== S U B R O U T I N E =======================================
.text$mn:00001978
.text$mn:00001978 ; Attributes: bp-based frame
.text$mn:00001978
.text$mn:00001978 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001978                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00001978 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00001978                                         ; CODE XREF: $LN19+14p
.text$mn:00001978                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00001978
.text$mn:00001978 var_8           = dword ptr -8
.text$mn:00001978 var_4           = dword ptr -4
.text$mn:00001978
.text$mn:00001978                 push    ebp
.text$mn:00001979                 mov     ebp, esp
.text$mn:0000197B                 sub     esp, 8
.text$mn:0000197E                 mov     [ebp+var_4], ecx
.text$mn:00001981                 mov     eax, [ebp+var_4]
.text$mn:00001984                 cmp     dword ptr [eax+18h], 10h
.text$mn:00001988                 jb      short loc_199E
.text$mn:0000198A                 mov     ecx, [ebp+var_4]
.text$mn:0000198D                 mov     edx, [ecx+4]
.text$mn:00001990                 push    edx
.text$mn:00001991                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001996                 add     esp, 4
.text$mn:00001999                 mov     [ebp+var_8], eax
.text$mn:0000199C                 jmp     short loc_19A7
.text$mn:0000199E ; ---------------------------------------------------------------------------
.text$mn:0000199E
.text$mn:0000199E loc_199E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000199E                 mov     eax, [ebp+var_4]
.text$mn:000019A1                 add     eax, 4
.text$mn:000019A4                 mov     [ebp+var_8], eax
.text$mn:000019A7
.text$mn:000019A7 loc_19A7:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000019A7                 mov     eax, [ebp+var_8]
.text$mn:000019AA                 mov     esp, ebp
.text$mn:000019AC                 pop     ebp
.text$mn:000019AD                 retn
.text$mn:000019AD ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:000019AD
.text$mn:000019AD ; ---------------------------------------------------------------------------
.text$mn:000019AE                 align 10h
.text$mn:000019AE _text$mn        ends
.text$mn:000019AE
.text$mn:000019B0 ; ===========================================================================
.text$mn:000019B0
.text$mn:000019B0 ; Segment type: Pure code
.text$mn:000019B0 ; Segment permissions: Read/Execute
.text$mn:000019B0 _text$mn        segment para public 'CODE' use32
.text$mn:000019B0                 assume cs:_text$mn
.text$mn:000019B0                 ;org 19B0h
.text$mn:000019B0 ; COMDAT (pick any)
.text$mn:000019B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019B0
.text$mn:000019B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000019B0
.text$mn:000019B0 ; Attributes: bp-based frame
.text$mn:000019B0
.text$mn:000019B0 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:000019B0                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:000019B0 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:000019B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:000019B0
.text$mn:000019B0 var_8           = dword ptr -8
.text$mn:000019B0 var_4           = dword ptr -4
.text$mn:000019B0
.text$mn:000019B0                 push    ebp
.text$mn:000019B1                 mov     ebp, esp
.text$mn:000019B3                 sub     esp, 8
.text$mn:000019B6                 mov     [ebp+var_4], ecx
.text$mn:000019B9                 mov     eax, [ebp+var_4]
.text$mn:000019BC                 cmp     dword ptr [eax+18h], 10h
.text$mn:000019C0                 jb      short loc_19D6
.text$mn:000019C2                 mov     ecx, [ebp+var_4]
.text$mn:000019C5                 mov     edx, [ecx+4]
.text$mn:000019C8                 push    edx
.text$mn:000019C9                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000019CE                 add     esp, 4
.text$mn:000019D1                 mov     [ebp+var_8], eax
.text$mn:000019D4                 jmp     short loc_19DF
.text$mn:000019D6 ; ---------------------------------------------------------------------------
.text$mn:000019D6
.text$mn:000019D6 loc_19D6:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000019D6                 mov     eax, [ebp+var_4]
.text$mn:000019D9                 add     eax, 4
.text$mn:000019DC                 mov     [ebp+var_8], eax
.text$mn:000019DF
.text$mn:000019DF loc_19DF:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000019DF                 mov     eax, [ebp+var_8]
.text$mn:000019E2                 mov     esp, ebp
.text$mn:000019E4                 pop     ebp
.text$mn:000019E5                 retn
.text$mn:000019E5 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:000019E5
.text$mn:000019E5 ; ---------------------------------------------------------------------------
.text$mn:000019E6                 align 4
.text$mn:000019E6 _text$mn        ends
.text$mn:000019E6
.text$mn:000019E8 ; ===========================================================================
.text$mn:000019E8
.text$mn:000019E8 ; Segment type: Pure code
.text$mn:000019E8 ; Segment permissions: Read/Execute
.text$mn:000019E8 _text$mn        segment para public 'CODE' use32
.text$mn:000019E8                 assume cs:_text$mn
.text$mn:000019E8                 ;org 19E8h
.text$mn:000019E8 ; COMDAT (pick any)
.text$mn:000019E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019E8
.text$mn:000019E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000019E8
.text$mn:000019E8 ; Attributes: bp-based frame
.text$mn:000019E8
.text$mn:000019E8 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:000019E8                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000019E8 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:000019E8                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:000019E8                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:000019E8
.text$mn:000019E8 var_18          = byte ptr -18h
.text$mn:000019E8 var_14          = dword ptr -14h
.text$mn:000019E8 var_10          = dword ptr -10h
.text$mn:000019E8 var_C           = dword ptr -0Ch
.text$mn:000019E8 var_4           = dword ptr -4
.text$mn:000019E8
.text$mn:000019E8                 push    ebp
.text$mn:000019E9                 mov     ebp, esp
.text$mn:000019EB                 push    0FFFFFFFFh
.text$mn:000019ED                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000019F2                 mov     eax, large fs:0
.text$mn:000019F8                 push    eax
.text$mn:000019F9                 sub     esp, 0Ch
.text$mn:000019FC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A01                 xor     eax, ebp
.text$mn:00001A03                 push    eax
.text$mn:00001A04                 lea     eax, [ebp+var_C]
.text$mn:00001A07                 mov     large fs:0, eax
.text$mn:00001A0D                 mov     [ebp+var_14], ecx
.text$mn:00001A10                 mov     eax, [ebp+var_14]
.text$mn:00001A13                 cmp     dword ptr [eax], 0
.text$mn:00001A16                 jz      short loc_1A73
.text$mn:00001A18                 push    3               ; int
.text$mn:00001A1A                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001A1D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00001A22                 mov     [ebp+var_4], 0
.text$mn:00001A29                 mov     ecx, [ebp+var_14]
.text$mn:00001A2C                 mov     edx, [ecx]
.text$mn:00001A2E                 add     edx, 4
.text$mn:00001A31                 mov     [ebp+var_10], edx
.text$mn:00001A34                 jmp     short loc_1A43
.text$mn:00001A36 ; ---------------------------------------------------------------------------
.text$mn:00001A36
.text$mn:00001A36 loc_1A36:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00001A36                 mov     eax, [ebp+var_10]
.text$mn:00001A39                 mov     ecx, [eax]
.text$mn:00001A3B                 mov     edx, [ebp+var_10]
.text$mn:00001A3E                 mov     eax, [ecx+4]
.text$mn:00001A41                 mov     [edx], eax
.text$mn:00001A43
.text$mn:00001A43 loc_1A43:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00001A43                 mov     ecx, [ebp+var_10]
.text$mn:00001A46                 cmp     dword ptr [ecx], 0
.text$mn:00001A49                 jz      short loc_1A58
.text$mn:00001A4B                 mov     edx, [ebp+var_10]
.text$mn:00001A4E                 mov     eax, [edx]
.text$mn:00001A50                 mov     dword ptr [eax], 0
.text$mn:00001A56                 jmp     short loc_1A36
.text$mn:00001A58 ; ---------------------------------------------------------------------------
.text$mn:00001A58
.text$mn:00001A58 loc_1A58:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00001A58                 mov     ecx, [ebp+var_14]
.text$mn:00001A5B                 mov     edx, [ecx]
.text$mn:00001A5D                 mov     dword ptr [edx+4], 0
.text$mn:00001A64                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A6B                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001A6E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00001A73
.text$mn:00001A73 loc_1A73:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00001A73                 mov     ecx, [ebp+var_C]
.text$mn:00001A76                 mov     large fs:0, ecx
.text$mn:00001A7D                 pop     ecx
.text$mn:00001A7E                 mov     esp, ebp
.text$mn:00001A80                 pop     ebp
.text$mn:00001A81                 retn
.text$mn:00001A81 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00001A81
.text$mn:00001A81 ; ---------------------------------------------------------------------------
.text$mn:00001A82                 align 4
.text$mn:00001A82 _text$mn        ends
.text$mn:00001A82
.text$x:00001A84 ; ===========================================================================
.text$x:00001A84
.text$x:00001A84 ; Segment type: Pure code
.text$x:00001A84 ; Segment permissions: Read/Execute
.text$x:00001A84 _text$x         segment para public 'CODE' use32
.text$x:00001A84                 assume cs:_text$x
.text$x:00001A84                 ;org 1A84h
.text$x:00001A84 ; COMDAT (pick associative to section at 19E8)
.text$x:00001A84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001A84
.text$x:00001A84 ; =============== S U B R O U T I N E =======================================
.text$x:00001A84
.text$x:00001A84
.text$x:00001A84 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00001A84                                         ; DATA XREF: .xdata$x:000023BCo
.text$x:00001A84                 lea     ecx, [ebp-18h]  ; this
.text$x:00001A87                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00001A87 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00001A87
.text$x:00001A8C
.text$x:00001A8C ; =============== S U B R O U T I N E =======================================
.text$x:00001A8C
.text$x:00001A8C
.text$x:00001A8C __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00001A8C                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00001A8C
.text$x:00001A8C arg_4           = dword ptr  8
.text$x:00001A8C
.text$x:00001A8C                 mov     edx, [esp+arg_4]
.text$x:00001A90                 lea     eax, [edx+0Ch]
.text$x:00001A93                 mov     ecx, [edx-10h]
.text$x:00001A96                 xor     ecx, eax
.text$x:00001A98                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A9D                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00001AA2                 jmp     ___CxxFrameHandler3
.text$x:00001AA2 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00001AA2
.text$x:00001AA2 ; ---------------------------------------------------------------------------
.text$x:00001AA7                 align 4
.text$x:00001AA7 _text$x         ends
.text$x:00001AA7
.text$mn:00001AA8 ; ===========================================================================
.text$mn:00001AA8
.text$mn:00001AA8 ; Segment type: Pure code
.text$mn:00001AA8 ; Segment permissions: Read/Execute
.text$mn:00001AA8 _text$mn        segment para public 'CODE' use32
.text$mn:00001AA8                 assume cs:_text$mn
.text$mn:00001AA8                 ;org 1AA8h
.text$mn:00001AA8 ; COMDAT (pick any)
.text$mn:00001AA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AA8
.text$mn:00001AA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AA8
.text$mn:00001AA8 ; Attributes: bp-based frame
.text$mn:00001AA8
.text$mn:00001AA8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00001AA8                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00001AA8 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00001AA8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00001AA8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00001AA8
.text$mn:00001AA8 var_C           = dword ptr -0Ch
.text$mn:00001AA8 var_8           = dword ptr -8
.text$mn:00001AA8 var_2           = byte ptr -2
.text$mn:00001AA8 var_1           = byte ptr -1
.text$mn:00001AA8 arg_0           = byte ptr  8
.text$mn:00001AA8 Size            = dword ptr  0Ch
.text$mn:00001AA8
.text$mn:00001AA8                 push    ebp
.text$mn:00001AA9                 mov     ebp, esp
.text$mn:00001AAB                 sub     esp, 0Ch
.text$mn:00001AAE                 mov     [ebp+var_8], ecx
.text$mn:00001AB1                 movzx   eax, [ebp+arg_0]
.text$mn:00001AB5                 test    eax, eax
.text$mn:00001AB7                 jnz     short loc_1ABB
.text$mn:00001AB9                 jmp     short loc_1B2E
.text$mn:00001ABB ; ---------------------------------------------------------------------------
.text$mn:00001ABB
.text$mn:00001ABB loc_1ABB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00001ABB                 mov     ecx, [ebp+var_8]
.text$mn:00001ABE                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00001AC2                 jb      short loc_1B2E
.text$mn:00001AC4                 mov     edx, [ebp+var_8]
.text$mn:00001AC7                 mov     eax, [edx+4]
.text$mn:00001ACA                 mov     [ebp+var_C], eax
.text$mn:00001ACD                 mov     ecx, [ebp+var_8]
.text$mn:00001AD0                 add     ecx, 4
.text$mn:00001AD3                 push    ecx
.text$mn:00001AD4                 lea     edx, [ebp+var_1]
.text$mn:00001AD7                 push    edx
.text$mn:00001AD8                 mov     ecx, [ebp+var_8]
.text$mn:00001ADB                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001AE0                 mov     ecx, eax
.text$mn:00001AE2                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001AE7                 cmp     [ebp+Size], 0
.text$mn:00001AEB                 jbe     short loc_1B0D
.text$mn:00001AED                 mov     eax, [ebp+Size]
.text$mn:00001AF0                 push    eax             ; Size
.text$mn:00001AF1                 mov     ecx, [ebp+var_C]
.text$mn:00001AF4                 push    ecx
.text$mn:00001AF5                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001AFA                 add     esp, 4
.text$mn:00001AFD                 push    eax             ; Src
.text$mn:00001AFE                 mov     edx, [ebp+var_8]
.text$mn:00001B01                 add     edx, 4
.text$mn:00001B04                 push    edx             ; Dst
.text$mn:00001B05                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001B0A                 add     esp, 0Ch
.text$mn:00001B0D
.text$mn:00001B0D loc_1B0D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00001B0D                 mov     eax, [ebp+var_8]
.text$mn:00001B10                 mov     ecx, [eax+18h]
.text$mn:00001B13                 add     ecx, 1
.text$mn:00001B16                 push    ecx             ; int
.text$mn:00001B17                 mov     edx, [ebp+var_C]
.text$mn:00001B1A                 push    edx             ; void *
.text$mn:00001B1B                 lea     eax, [ebp+var_2]
.text$mn:00001B1E                 push    eax
.text$mn:00001B1F                 mov     ecx, [ebp+var_8]
.text$mn:00001B22                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001B27                 mov     ecx, eax
.text$mn:00001B29                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00001B2E
.text$mn:00001B2E loc_1B2E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00001B2E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00001B2E                 mov     ecx, [ebp+var_8]
.text$mn:00001B31                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00001B38                 mov     edx, [ebp+Size]
.text$mn:00001B3B                 push    edx
.text$mn:00001B3C                 mov     ecx, [ebp+var_8]
.text$mn:00001B3F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001B44                 mov     esp, ebp
.text$mn:00001B46                 pop     ebp
.text$mn:00001B47                 retn    8
.text$mn:00001B47 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00001B47
.text$mn:00001B47 ; ---------------------------------------------------------------------------
.text$mn:00001B4A                 align 4
.text$mn:00001B4A _text$mn        ends
.text$mn:00001B4A
.text$mn:00001B4C ; ===========================================================================
.text$mn:00001B4C
.text$mn:00001B4C ; Segment type: Pure code
.text$mn:00001B4C ; Segment permissions: Read/Execute
.text$mn:00001B4C _text$mn        segment para public 'CODE' use32
.text$mn:00001B4C                 assume cs:_text$mn
.text$mn:00001B4C                 ;org 1B4Ch
.text$mn:00001B4C ; COMDAT (pick any)
.text$mn:00001B4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B4C
.text$mn:00001B4C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B4C
.text$mn:00001B4C ; Attributes: bp-based frame
.text$mn:00001B4C
.text$mn:00001B4C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00001B4C                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001B4C ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001B4C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00001B4C
.text$mn:00001B4C var_4           = dword ptr -4
.text$mn:00001B4C
.text$mn:00001B4C                 push    ebp
.text$mn:00001B4D                 mov     ebp, esp
.text$mn:00001B4F                 push    ecx
.text$mn:00001B50                 mov     [ebp+var_4], ecx
.text$mn:00001B53                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00001B58                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00001B5D                 mov     esp, ebp
.text$mn:00001B5F                 pop     ebp
.text$mn:00001B60                 retn
.text$mn:00001B60 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001B60
.text$mn:00001B60 ; ---------------------------------------------------------------------------
.text$mn:00001B61                 align 4
.text$mn:00001B61 _text$mn        ends
.text$mn:00001B61
.text$mn:00001B64 ; ===========================================================================
.text$mn:00001B64
.text$mn:00001B64 ; Segment type: Pure code
.text$mn:00001B64 ; Segment permissions: Read/Execute
.text$mn:00001B64 _text$mn        segment para public 'CODE' use32
.text$mn:00001B64                 assume cs:_text$mn
.text$mn:00001B64                 ;org 1B64h
.text$mn:00001B64 ; COMDAT (pick any)
.text$mn:00001B64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B64
.text$mn:00001B64 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B64
.text$mn:00001B64 ; Attributes: bp-based frame
.text$mn:00001B64
.text$mn:00001B64 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00001B64                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001B64 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001B64                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00001B64                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00001B64
.text$mn:00001B64 var_4           = dword ptr -4
.text$mn:00001B64
.text$mn:00001B64                 push    ebp
.text$mn:00001B65                 mov     ebp, esp
.text$mn:00001B67                 push    ecx
.text$mn:00001B68                 mov     [ebp+var_4], ecx
.text$mn:00001B6B                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00001B70                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00001B75                 mov     esp, ebp
.text$mn:00001B77                 pop     ebp
.text$mn:00001B78                 retn
.text$mn:00001B78 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001B78
.text$mn:00001B78 ; ---------------------------------------------------------------------------
.text$mn:00001B79                 align 4
.text$mn:00001B79 _text$mn        ends
.text$mn:00001B79
.text$mn:00001B7C ; ===========================================================================
.text$mn:00001B7C
.text$mn:00001B7C ; Segment type: Pure code
.text$mn:00001B7C ; Segment permissions: Read/Execute
.text$mn:00001B7C _text$mn        segment para public 'CODE' use32
.text$mn:00001B7C                 assume cs:_text$mn
.text$mn:00001B7C                 ;org 1B7Ch
.text$mn:00001B7C ; COMDAT (pick any)
.text$mn:00001B7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B7C
.text$mn:00001B7C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B7C
.text$mn:00001B7C ; Attributes: bp-based frame
.text$mn:00001B7C
.text$mn:00001B7C ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00001B7C                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00001B7C ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00001B7C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00001B7C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00001B7C
.text$mn:00001B7C var_4           = dword ptr -4
.text$mn:00001B7C arg_0           = dword ptr  8
.text$mn:00001B7C
.text$mn:00001B7C                 push    ebp
.text$mn:00001B7D                 mov     ebp, esp
.text$mn:00001B7F                 push    ecx
.text$mn:00001B80                 mov     [ebp+var_4], ecx
.text$mn:00001B83                 mov     eax, [ebp+arg_0]
.text$mn:00001B86                 push    eax
.text$mn:00001B87                 mov     ecx, [ebp+var_4]
.text$mn:00001B8A                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00001B8F                 mov     esp, ebp
.text$mn:00001B91                 pop     ebp
.text$mn:00001B92                 retn    4
.text$mn:00001B92 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00001B92
.text$mn:00001B92 ; ---------------------------------------------------------------------------
.text$mn:00001B95                 align 4
.text$mn:00001B95 _text$mn        ends
.text$mn:00001B95
.text$mn:00001B98 ; ===========================================================================
.text$mn:00001B98
.text$mn:00001B98 ; Segment type: Pure code
.text$mn:00001B98 ; Segment permissions: Read/Execute
.text$mn:00001B98 _text$mn        segment para public 'CODE' use32
.text$mn:00001B98                 assume cs:_text$mn
.text$mn:00001B98                 ;org 1B98h
.text$mn:00001B98 ; COMDAT (pick any)
.text$mn:00001B98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B98
.text$mn:00001B98 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B98
.text$mn:00001B98 ; Attributes: bp-based frame
.text$mn:00001B98
.text$mn:00001B98 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00001B98                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00001B98 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00001B98                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00001B98
.text$mn:00001B98 var_4           = dword ptr -4
.text$mn:00001B98 arg_0           = dword ptr  8
.text$mn:00001B98
.text$mn:00001B98                 push    ebp
.text$mn:00001B99                 mov     ebp, esp
.text$mn:00001B9B                 push    ecx
.text$mn:00001B9C                 mov     [ebp+var_4], ecx
.text$mn:00001B9F                 push    0
.text$mn:00001BA1                 mov     eax, [ebp+arg_0]
.text$mn:00001BA4                 push    eax
.text$mn:00001BA5                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00001BAA                 add     esp, 8
.text$mn:00001BAD                 mov     esp, ebp
.text$mn:00001BAF                 pop     ebp
.text$mn:00001BB0                 retn    4
.text$mn:00001BB0 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00001BB0
.text$mn:00001BB0 ; ---------------------------------------------------------------------------
.text$mn:00001BB3                 align 4
.text$mn:00001BB3 _text$mn        ends
.text$mn:00001BB3
.text$mn:00001BB4 ; ===========================================================================
.text$mn:00001BB4
.text$mn:00001BB4 ; Segment type: Pure code
.text$mn:00001BB4 ; Segment permissions: Read/Execute
.text$mn:00001BB4 _text$mn        segment para public 'CODE' use32
.text$mn:00001BB4                 assume cs:_text$mn
.text$mn:00001BB4                 ;org 1BB4h
.text$mn:00001BB4 ; COMDAT (pick any)
.text$mn:00001BB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BB4
.text$mn:00001BB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BB4
.text$mn:00001BB4 ; Attributes: bp-based frame
.text$mn:00001BB4
.text$mn:00001BB4 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00001BB4                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00001BB4 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00001BB4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00001BB4
.text$mn:00001BB4 var_4           = dword ptr -4
.text$mn:00001BB4 arg_0           = dword ptr  8
.text$mn:00001BB4
.text$mn:00001BB4                 push    ebp
.text$mn:00001BB5                 mov     ebp, esp
.text$mn:00001BB7                 push    ecx
.text$mn:00001BB8                 mov     [ebp+var_4], ecx
.text$mn:00001BBB                 push    0
.text$mn:00001BBD                 mov     eax, [ebp+arg_0]
.text$mn:00001BC0                 push    eax
.text$mn:00001BC1                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00001BC6                 add     esp, 8
.text$mn:00001BC9                 mov     esp, ebp
.text$mn:00001BCB                 pop     ebp
.text$mn:00001BCC                 retn    4
.text$mn:00001BCC ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00001BCC
.text$mn:00001BCC ; ---------------------------------------------------------------------------
.text$mn:00001BCF                 align 10h
.text$mn:00001BCF _text$mn        ends
.text$mn:00001BCF
.text$mn:00001BD0 ; ===========================================================================
.text$mn:00001BD0
.text$mn:00001BD0 ; Segment type: Pure code
.text$mn:00001BD0 ; Segment permissions: Read/Execute
.text$mn:00001BD0 _text$mn        segment para public 'CODE' use32
.text$mn:00001BD0                 assume cs:_text$mn
.text$mn:00001BD0                 ;org 1BD0h
.text$mn:00001BD0 ; COMDAT (pick any)
.text$mn:00001BD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BD0
.text$mn:00001BD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BD0
.text$mn:00001BD0 ; Attributes: bp-based frame
.text$mn:00001BD0
.text$mn:00001BD0 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00001BD0                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00001BD0 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00001BD0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00001BD0
.text$mn:00001BD0 Size            = dword ptr -8
.text$mn:00001BD0 var_4           = dword ptr -4
.text$mn:00001BD0 arg_0           = dword ptr  8
.text$mn:00001BD0 arg_4           = dword ptr  0Ch
.text$mn:00001BD0 arg_8           = dword ptr  10h
.text$mn:00001BD0
.text$mn:00001BD0                 push    ebp
.text$mn:00001BD1                 mov     ebp, esp
.text$mn:00001BD3                 sub     esp, 8
.text$mn:00001BD6                 mov     [ebp+var_4], ecx
.text$mn:00001BD9                 mov     ecx, [ebp+arg_0]
.text$mn:00001BDC                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001BE1                 cmp     eax, [ebp+arg_4]
.text$mn:00001BE4                 jnb     short loc_1BEE
.text$mn:00001BE6                 mov     ecx, [ebp+var_4]
.text$mn:00001BE9                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001BEE
.text$mn:00001BEE loc_1BEE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00001BEE                 mov     ecx, [ebp+arg_0]
.text$mn:00001BF1                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001BF6                 sub     eax, [ebp+arg_4]
.text$mn:00001BF9                 mov     [ebp+Size], eax
.text$mn:00001BFC                 mov     eax, [ebp+arg_8]
.text$mn:00001BFF                 cmp     eax, [ebp+Size]
.text$mn:00001C02                 jnb     short loc_1C0A
.text$mn:00001C04                 mov     ecx, [ebp+arg_8]
.text$mn:00001C07                 mov     [ebp+Size], ecx
.text$mn:00001C0A
.text$mn:00001C0A loc_1C0A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00001C0A                 mov     edx, [ebp+var_4]
.text$mn:00001C0D                 cmp     edx, [ebp+arg_0]
.text$mn:00001C10                 jnz     short loc_1C31
.text$mn:00001C12                 mov     eax, [ebp+arg_4]
.text$mn:00001C15                 add     eax, [ebp+Size]
.text$mn:00001C18                 push    eax
.text$mn:00001C19                 mov     ecx, [ebp+var_4]
.text$mn:00001C1C                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00001C21                 mov     ecx, [ebp+arg_4]
.text$mn:00001C24                 push    ecx
.text$mn:00001C25                 push    0
.text$mn:00001C27                 mov     ecx, [ebp+var_4]
.text$mn:00001C2A                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00001C2F                 jmp     short loc_1C73
.text$mn:00001C31 ; ---------------------------------------------------------------------------
.text$mn:00001C31
.text$mn:00001C31 loc_1C31:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00001C31                 push    0
.text$mn:00001C33                 mov     edx, [ebp+Size]
.text$mn:00001C36                 push    edx
.text$mn:00001C37                 mov     ecx, [ebp+var_4]
.text$mn:00001C3A                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001C3F                 movzx   eax, al
.text$mn:00001C42                 test    eax, eax
.text$mn:00001C44                 jz      short loc_1C73
.text$mn:00001C46                 mov     ecx, [ebp+Size]
.text$mn:00001C49                 push    ecx             ; Size
.text$mn:00001C4A                 mov     ecx, [ebp+arg_0]
.text$mn:00001C4D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001C52                 add     eax, [ebp+arg_4]
.text$mn:00001C55                 push    eax             ; Src
.text$mn:00001C56                 mov     ecx, [ebp+var_4]
.text$mn:00001C59                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001C5E                 push    eax             ; Dst
.text$mn:00001C5F                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001C64                 add     esp, 0Ch
.text$mn:00001C67                 mov     edx, [ebp+Size]
.text$mn:00001C6A                 push    edx
.text$mn:00001C6B                 mov     ecx, [ebp+var_4]
.text$mn:00001C6E                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001C73
.text$mn:00001C73 loc_1C73:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00001C73                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00001C73                 mov     eax, [ebp+var_4]
.text$mn:00001C76                 mov     esp, ebp
.text$mn:00001C78                 pop     ebp
.text$mn:00001C79                 retn    0Ch
.text$mn:00001C79 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00001C79
.text$mn:00001C79 _text$mn        ends
.text$mn:00001C79
.text$mn:00001C7C ; ===========================================================================
.text$mn:00001C7C
.text$mn:00001C7C ; Segment type: Pure code
.text$mn:00001C7C ; Segment permissions: Read/Execute
.text$mn:00001C7C _text$mn        segment para public 'CODE' use32
.text$mn:00001C7C                 assume cs:_text$mn
.text$mn:00001C7C                 ;org 1C7Ch
.text$mn:00001C7C ; COMDAT (pick any)
.text$mn:00001C7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C7C
.text$mn:00001C7C ; =============== S U B R O U T I N E =======================================
.text$mn:00001C7C
.text$mn:00001C7C ; Attributes: bp-based frame
.text$mn:00001C7C
.text$mn:00001C7C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00001C7C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00001C7C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00001C7C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00001C7C
.text$mn:00001C7C var_4           = dword ptr -4
.text$mn:00001C7C Str             = dword ptr  8
.text$mn:00001C7C
.text$mn:00001C7C                 push    ebp
.text$mn:00001C7D                 mov     ebp, esp
.text$mn:00001C7F                 push    ecx
.text$mn:00001C80                 mov     [ebp+var_4], ecx
.text$mn:00001C83                 push    490h            ; unsigned int
.text$mn:00001C88                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001C8D                 mov     eax, [ebp+Str]
.text$mn:00001C90                 push    eax             ; int
.text$mn:00001C91                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001C96                 add     esp, 0Ch
.text$mn:00001C99                 mov     ecx, [ebp+Str]
.text$mn:00001C9C                 push    ecx             ; Str
.text$mn:00001C9D                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00001CA2                 add     esp, 4
.text$mn:00001CA5                 push    eax             ; Size
.text$mn:00001CA6                 mov     edx, [ebp+Str]
.text$mn:00001CA9                 push    edx             ; Src
.text$mn:00001CAA                 mov     ecx, [ebp+var_4]
.text$mn:00001CAD                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00001CB2                 mov     esp, ebp
.text$mn:00001CB4                 pop     ebp
.text$mn:00001CB5                 retn    4
.text$mn:00001CB5 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00001CB5
.text$mn:00001CB5 _text$mn        ends
.text$mn:00001CB5
.text$mn:00001CB8 ; ===========================================================================
.text$mn:00001CB8
.text$mn:00001CB8 ; Segment type: Pure code
.text$mn:00001CB8 ; Segment permissions: Read/Execute
.text$mn:00001CB8 _text$mn        segment para public 'CODE' use32
.text$mn:00001CB8                 assume cs:_text$mn
.text$mn:00001CB8                 ;org 1CB8h
.text$mn:00001CB8 ; COMDAT (pick any)
.text$mn:00001CB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CB8
.text$mn:00001CB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CB8
.text$mn:00001CB8 ; Attributes: bp-based frame
.text$mn:00001CB8
.text$mn:00001CB8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00001CB8                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00001CB8 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00001CB8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00001CB8
.text$mn:00001CB8 var_4           = dword ptr -4
.text$mn:00001CB8 Src             = dword ptr  8
.text$mn:00001CB8 Size            = dword ptr  0Ch
.text$mn:00001CB8
.text$mn:00001CB8                 push    ebp
.text$mn:00001CB9                 mov     ebp, esp
.text$mn:00001CBB                 push    ecx
.text$mn:00001CBC                 mov     [ebp+var_4], ecx
.text$mn:00001CBF                 cmp     [ebp+Size], 0
.text$mn:00001CC3                 jz      short loc_1CDB
.text$mn:00001CC5                 push    47Fh            ; unsigned int
.text$mn:00001CCA                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001CCF                 mov     eax, [ebp+Src]
.text$mn:00001CD2                 push    eax             ; int
.text$mn:00001CD3                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001CD8                 add     esp, 0Ch
.text$mn:00001CDB
.text$mn:00001CDB loc_1CDB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00001CDB                 mov     ecx, [ebp+Src]
.text$mn:00001CDE                 push    ecx
.text$mn:00001CDF                 mov     ecx, [ebp+var_4]
.text$mn:00001CE2                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00001CE7                 movzx   edx, al
.text$mn:00001CEA                 test    edx, edx
.text$mn:00001CEC                 jz      short loc_1D0E
.text$mn:00001CEE                 mov     eax, [ebp+Size]
.text$mn:00001CF1                 push    eax
.text$mn:00001CF2                 mov     ecx, [ebp+var_4]
.text$mn:00001CF5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001CFA                 mov     ecx, [ebp+Src]
.text$mn:00001CFD                 sub     ecx, eax
.text$mn:00001CFF                 push    ecx
.text$mn:00001D00                 mov     edx, [ebp+var_4]
.text$mn:00001D03                 push    edx
.text$mn:00001D04                 mov     ecx, [ebp+var_4]
.text$mn:00001D07                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00001D0C                 jmp     short loc_1D4B
.text$mn:00001D0E ; ---------------------------------------------------------------------------
.text$mn:00001D0E
.text$mn:00001D0E loc_1D0E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00001D0E                 push    0
.text$mn:00001D10                 mov     eax, [ebp+Size]
.text$mn:00001D13                 push    eax
.text$mn:00001D14                 mov     ecx, [ebp+var_4]
.text$mn:00001D17                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001D1C                 movzx   ecx, al
.text$mn:00001D1F                 test    ecx, ecx
.text$mn:00001D21                 jz      short loc_1D48
.text$mn:00001D23                 mov     edx, [ebp+Size]
.text$mn:00001D26                 push    edx             ; Size
.text$mn:00001D27                 mov     eax, [ebp+Src]
.text$mn:00001D2A                 push    eax             ; Src
.text$mn:00001D2B                 mov     ecx, [ebp+var_4]
.text$mn:00001D2E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001D33                 push    eax             ; Dst
.text$mn:00001D34                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001D39                 add     esp, 0Ch
.text$mn:00001D3C                 mov     ecx, [ebp+Size]
.text$mn:00001D3F                 push    ecx
.text$mn:00001D40                 mov     ecx, [ebp+var_4]
.text$mn:00001D43                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001D48
.text$mn:00001D48 loc_1D48:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00001D48                 mov     eax, [ebp+var_4]
.text$mn:00001D4B
.text$mn:00001D4B loc_1D4B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00001D4B                 mov     esp, ebp
.text$mn:00001D4D                 pop     ebp
.text$mn:00001D4E                 retn    8
.text$mn:00001D4E ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00001D4E
.text$mn:00001D4E ; ---------------------------------------------------------------------------
.text$mn:00001D51                 align 4
.text$mn:00001D51 _text$mn        ends
.text$mn:00001D51
.text$mn:00001D54 ; ===========================================================================
.text$mn:00001D54
.text$mn:00001D54 ; Segment type: Pure code
.text$mn:00001D54 ; Segment permissions: Read/Execute
.text$mn:00001D54 _text$mn        segment para public 'CODE' use32
.text$mn:00001D54                 assume cs:_text$mn
.text$mn:00001D54                 ;org 1D54h
.text$mn:00001D54 ; COMDAT (pick any)
.text$mn:00001D54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D54
.text$mn:00001D54 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D54
.text$mn:00001D54 ; Attributes: bp-based frame
.text$mn:00001D54
.text$mn:00001D54 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00001D54                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00001D54 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00001D54                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00001D54
.text$mn:00001D54 arg_0           = dword ptr  8
.text$mn:00001D54 arg_4           = dword ptr  0Ch
.text$mn:00001D54
.text$mn:00001D54                 push    ebp
.text$mn:00001D55                 mov     ebp, esp
.text$mn:00001D57                 mov     eax, [ebp+arg_0]
.text$mn:00001D5A                 mov     ecx, [ebp+arg_4]
.text$mn:00001D5D                 mov     dl, [ecx]
.text$mn:00001D5F                 mov     [eax], dl
.text$mn:00001D61                 pop     ebp
.text$mn:00001D62                 retn
.text$mn:00001D62 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00001D62
.text$mn:00001D62 ; ---------------------------------------------------------------------------
.text$mn:00001D63                 align 4
.text$mn:00001D63 _text$mn        ends
.text$mn:00001D63
.text$mn:00001D64 ; ===========================================================================
.text$mn:00001D64
.text$mn:00001D64 ; Segment type: Pure code
.text$mn:00001D64 ; Segment permissions: Read/Execute
.text$mn:00001D64 _text$mn        segment para public 'CODE' use32
.text$mn:00001D64                 assume cs:_text$mn
.text$mn:00001D64                 ;org 1D64h
.text$mn:00001D64 ; COMDAT (pick any)
.text$mn:00001D64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D64
.text$mn:00001D64 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D64
.text$mn:00001D64 ; Attributes: bp-based frame
.text$mn:00001D64
.text$mn:00001D64 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00001D64                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00001D64 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001D64                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00001D64
.text$mn:00001D64 var_4           = dword ptr -4
.text$mn:00001D64
.text$mn:00001D64                 push    ebp
.text$mn:00001D65                 mov     ebp, esp
.text$mn:00001D67                 push    ecx
.text$mn:00001D68                 mov     [ebp+var_4], ecx
.text$mn:00001D6B                 mov     eax, [ebp+var_4]
.text$mn:00001D6E                 mov     eax, [eax+4]
.text$mn:00001D71                 mov     esp, ebp
.text$mn:00001D73                 pop     ebp
.text$mn:00001D74                 retn
.text$mn:00001D74 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001D74
.text$mn:00001D74 ; ---------------------------------------------------------------------------
.text$mn:00001D75                 align 4
.text$mn:00001D75 _text$mn        ends
.text$mn:00001D75
.text$mn:00001D78 ; ===========================================================================
.text$mn:00001D78
.text$mn:00001D78 ; Segment type: Pure code
.text$mn:00001D78 ; Segment permissions: Read/Execute
.text$mn:00001D78 _text$mn        segment para public 'CODE' use32
.text$mn:00001D78                 assume cs:_text$mn
.text$mn:00001D78                 ;org 1D78h
.text$mn:00001D78 ; COMDAT (pick any)
.text$mn:00001D78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D78
.text$mn:00001D78 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D78
.text$mn:00001D78 ; Attributes: bp-based frame
.text$mn:00001D78
.text$mn:00001D78 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00001D78                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00001D78 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001D78                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00001D78                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00001D78
.text$mn:00001D78 var_4           = dword ptr -4
.text$mn:00001D78
.text$mn:00001D78                 push    ebp
.text$mn:00001D79                 mov     ebp, esp
.text$mn:00001D7B                 push    ecx
.text$mn:00001D7C                 mov     [ebp+var_4], ecx
.text$mn:00001D7F                 mov     eax, [ebp+var_4]
.text$mn:00001D82                 mov     eax, [eax+4]
.text$mn:00001D85                 mov     esp, ebp
.text$mn:00001D87                 pop     ebp
.text$mn:00001D88                 retn
.text$mn:00001D88 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001D88
.text$mn:00001D88 ; ---------------------------------------------------------------------------
.text$mn:00001D89                 align 4
.text$mn:00001D89 _text$mn        ends
.text$mn:00001D89
.text$mn:00001D8C ; ===========================================================================
.text$mn:00001D8C
.text$mn:00001D8C ; Segment type: Pure code
.text$mn:00001D8C ; Segment permissions: Read/Execute
.text$mn:00001D8C _text$mn        segment para public 'CODE' use32
.text$mn:00001D8C                 assume cs:_text$mn
.text$mn:00001D8C                 ;org 1D8Ch
.text$mn:00001D8C ; COMDAT (pick any)
.text$mn:00001D8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D8C
.text$mn:00001D8C ; =============== S U B R O U T I N E =======================================
.text$mn:00001D8C
.text$mn:00001D8C ; Attributes: bp-based frame
.text$mn:00001D8C
.text$mn:00001D8C ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00001D8C                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001D8C ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00001D8C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00001D8C
.text$mn:00001D8C var_4           = dword ptr -4
.text$mn:00001D8C Dst             = dword ptr  8
.text$mn:00001D8C Src             = dword ptr  0Ch
.text$mn:00001D8C Size            = dword ptr  10h
.text$mn:00001D8C
.text$mn:00001D8C                 push    ebp
.text$mn:00001D8D                 mov     ebp, esp
.text$mn:00001D8F                 push    ecx
.text$mn:00001D90                 cmp     [ebp+Size], 0
.text$mn:00001D94                 jnz     short loc_1D9E
.text$mn:00001D96                 mov     eax, [ebp+Dst]
.text$mn:00001D99                 mov     [ebp+var_4], eax
.text$mn:00001D9C                 jmp     short loc_1DB5
.text$mn:00001D9E ; ---------------------------------------------------------------------------
.text$mn:00001D9E
.text$mn:00001D9E loc_1D9E:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00001D9E                 mov     ecx, [ebp+Size]
.text$mn:00001DA1                 push    ecx             ; Size
.text$mn:00001DA2                 mov     edx, [ebp+Src]
.text$mn:00001DA5                 push    edx             ; Src
.text$mn:00001DA6                 mov     eax, [ebp+Dst]
.text$mn:00001DA9                 push    eax             ; Dst
.text$mn:00001DAA                 call    _memcpy
.text$mn:00001DAF                 add     esp, 0Ch
.text$mn:00001DB2                 mov     [ebp+var_4], eax
.text$mn:00001DB5
.text$mn:00001DB5 loc_1DB5:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00001DB5                 mov     eax, [ebp+var_4]
.text$mn:00001DB8                 mov     esp, ebp
.text$mn:00001DBA                 pop     ebp
.text$mn:00001DBB                 retn
.text$mn:00001DBB ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00001DBB
.text$mn:00001DBB _text$mn        ends
.text$mn:00001DBB
.text$mn:00001DBC ; ===========================================================================
.text$mn:00001DBC
.text$mn:00001DBC ; Segment type: Pure code
.text$mn:00001DBC ; Segment permissions: Read/Execute
.text$mn:00001DBC _text$mn        segment para public 'CODE' use32
.text$mn:00001DBC                 assume cs:_text$mn
.text$mn:00001DBC                 ;org 1DBCh
.text$mn:00001DBC ; COMDAT (pick any)
.text$mn:00001DBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DBC
.text$mn:00001DBC ; =============== S U B R O U T I N E =======================================
.text$mn:00001DBC
.text$mn:00001DBC ; Attributes: bp-based frame
.text$mn:00001DBC
.text$mn:00001DBC ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00001DBC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00001DBC ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00001DBC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00001DBC
.text$mn:00001DBC var_4           = dword ptr -4
.text$mn:00001DBC arg_0           = dword ptr  8
.text$mn:00001DBC arg_4           = dword ptr  0Ch
.text$mn:00001DBC
.text$mn:00001DBC                 push    ebp
.text$mn:00001DBD                 mov     ebp, esp
.text$mn:00001DBF                 push    ecx
.text$mn:00001DC0                 mov     [ebp+var_4], ecx
.text$mn:00001DC3                 mov     eax, [ebp+arg_4]
.text$mn:00001DC6                 push    eax             ; int
.text$mn:00001DC7                 mov     ecx, [ebp+arg_0]
.text$mn:00001DCA                 push    ecx             ; void *
.text$mn:00001DCB                 mov     ecx, [ebp+var_4]
.text$mn:00001DCE                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00001DD3                 mov     esp, ebp
.text$mn:00001DD5                 pop     ebp
.text$mn:00001DD6                 retn    8
.text$mn:00001DD6 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00001DD6
.text$mn:00001DD6 ; ---------------------------------------------------------------------------
.text$mn:00001DD9                 align 4
.text$mn:00001DD9 _text$mn        ends
.text$mn:00001DD9
.text$mn:00001DDC ; ===========================================================================
.text$mn:00001DDC
.text$mn:00001DDC ; Segment type: Pure code
.text$mn:00001DDC ; Segment permissions: Read/Execute
.text$mn:00001DDC _text$mn        segment para public 'CODE' use32
.text$mn:00001DDC                 assume cs:_text$mn
.text$mn:00001DDC                 ;org 1DDCh
.text$mn:00001DDC ; COMDAT (pick any)
.text$mn:00001DDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DDC
.text$mn:00001DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00001DDC
.text$mn:00001DDC ; Attributes: bp-based frame
.text$mn:00001DDC
.text$mn:00001DDC ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00001DDC                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00001DDC ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00001DDC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00001DDC
.text$mn:00001DDC var_4           = dword ptr -4
.text$mn:00001DDC arg_0           = dword ptr  8
.text$mn:00001DDC
.text$mn:00001DDC                 push    ebp
.text$mn:00001DDD                 mov     ebp, esp
.text$mn:00001DDF                 push    ecx
.text$mn:00001DE0                 mov     [ebp+var_4], ecx
.text$mn:00001DE3                 mov     eax, [ebp+arg_0]
.text$mn:00001DE6                 push    eax             ; void *
.text$mn:00001DE7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001DEC                 add     esp, 4
.text$mn:00001DEF                 mov     esp, ebp
.text$mn:00001DF1                 pop     ebp
.text$mn:00001DF2                 retn    8
.text$mn:00001DF2 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00001DF2
.text$mn:00001DF2 ; ---------------------------------------------------------------------------
.text$mn:00001DF5                 align 4
.text$mn:00001DF5 _text$mn        ends
.text$mn:00001DF5
.text$mn:00001DF8 ; ===========================================================================
.text$mn:00001DF8
.text$mn:00001DF8 ; Segment type: Pure code
.text$mn:00001DF8 ; Segment permissions: Read/Execute
.text$mn:00001DF8 _text$mn        segment para public 'CODE' use32
.text$mn:00001DF8                 assume cs:_text$mn
.text$mn:00001DF8                 ;org 1DF8h
.text$mn:00001DF8 ; COMDAT (pick any)
.text$mn:00001DF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DF8
.text$mn:00001DF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DF8
.text$mn:00001DF8 ; Attributes: bp-based frame
.text$mn:00001DF8
.text$mn:00001DF8 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00001DF8                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00001DF8 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00001DF8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00001DF8
.text$mn:00001DF8 var_4           = dword ptr -4
.text$mn:00001DF8 arg_0           = dword ptr  8
.text$mn:00001DF8
.text$mn:00001DF8                 push    ebp
.text$mn:00001DF9                 mov     ebp, esp
.text$mn:00001DFB                 push    ecx
.text$mn:00001DFC                 mov     [ebp+var_4], ecx
.text$mn:00001DFF                 mov     eax, [ebp+arg_0]
.text$mn:00001E02                 push    eax             ; void *
.text$mn:00001E03                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001E08                 add     esp, 4
.text$mn:00001E0B                 mov     esp, ebp
.text$mn:00001E0D                 pop     ebp
.text$mn:00001E0E                 retn    8
.text$mn:00001E0E ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00001E0E
.text$mn:00001E0E ; ---------------------------------------------------------------------------
.text$mn:00001E11                 align 4
.text$mn:00001E11 _text$mn        ends
.text$mn:00001E11
.text$mn:00001E14 ; ===========================================================================
.text$mn:00001E14
.text$mn:00001E14 ; Segment type: Pure code
.text$mn:00001E14 ; Segment permissions: Read/Execute
.text$mn:00001E14 _text$mn        segment para public 'CODE' use32
.text$mn:00001E14                 assume cs:_text$mn
.text$mn:00001E14                 ;org 1E14h
.text$mn:00001E14 ; COMDAT (pick any)
.text$mn:00001E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E14
.text$mn:00001E14 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E14
.text$mn:00001E14 ; Attributes: bp-based frame
.text$mn:00001E14
.text$mn:00001E14 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00001E14                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00001E14 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00001E14                                         ; DATA XREF: .rdata:0000291Co
.text$mn:00001E14
.text$mn:00001E14 var_4           = dword ptr -4
.text$mn:00001E14 arg_0           = dword ptr  8
.text$mn:00001E14 arg_4           = dword ptr  0Ch
.text$mn:00001E14
.text$mn:00001E14                 push    ebp
.text$mn:00001E15                 mov     ebp, esp
.text$mn:00001E17                 push    ecx
.text$mn:00001E18                 mov     [ebp+var_4], ecx
.text$mn:00001E1B                 mov     eax, [ebp+arg_4]
.text$mn:00001E1E                 push    eax             ; int
.text$mn:00001E1F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00001E24                 add     esp, 4
.text$mn:00001E27                 test    eax, eax
.text$mn:00001E29                 jz      short loc_1E44
.text$mn:00001E2B                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00001E30                 push    eax             ; struct std::error_category *
.text$mn:00001E31                 mov     ecx, [ebp+arg_4]
.text$mn:00001E34                 push    ecx             ; int
.text$mn:00001E35                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001E38                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001E3D                 mov     eax, [ebp+arg_0]
.text$mn:00001E40                 jmp     short loc_1E59
.text$mn:00001E42 ; ---------------------------------------------------------------------------
.text$mn:00001E42                 jmp     short loc_1E59
.text$mn:00001E44 ; ---------------------------------------------------------------------------
.text$mn:00001E44
.text$mn:00001E44 loc_1E44:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00001E44                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00001E49                 push    eax             ; struct std::error_category *
.text$mn:00001E4A                 mov     edx, [ebp+arg_4]
.text$mn:00001E4D                 push    edx             ; int
.text$mn:00001E4E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001E51                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001E56                 mov     eax, [ebp+arg_0]
.text$mn:00001E59
.text$mn:00001E59 loc_1E59:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00001E59                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00001E59                 mov     esp, ebp
.text$mn:00001E5B                 pop     ebp
.text$mn:00001E5C                 retn    8
.text$mn:00001E5C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001E5C
.text$mn:00001E5C ; ---------------------------------------------------------------------------
.text$mn:00001E5F                 align 10h
.text$mn:00001E5F _text$mn        ends
.text$mn:00001E5F
.text$mn:00001E60 ; ===========================================================================
.text$mn:00001E60
.text$mn:00001E60 ; Segment type: Pure code
.text$mn:00001E60 ; Segment permissions: Read/Execute
.text$mn:00001E60 _text$mn        segment para public 'CODE' use32
.text$mn:00001E60                 assume cs:_text$mn
.text$mn:00001E60                 ;org 1E60h
.text$mn:00001E60 ; COMDAT (pick any)
.text$mn:00001E60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E60
.text$mn:00001E60 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E60
.text$mn:00001E60 ; Attributes: bp-based frame
.text$mn:00001E60
.text$mn:00001E60 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00001E60                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00001E60 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00001E60                                         ; DATA XREF: .rdata:0000288Co
.text$mn:00001E60                                         ; .rdata:000028A8o ...
.text$mn:00001E60
.text$mn:00001E60 var_4           = dword ptr -4
.text$mn:00001E60 arg_0           = dword ptr  8
.text$mn:00001E60 arg_4           = dword ptr  0Ch
.text$mn:00001E60
.text$mn:00001E60                 push    ebp
.text$mn:00001E61                 mov     ebp, esp
.text$mn:00001E63                 push    ecx
.text$mn:00001E64                 mov     [ebp+var_4], ecx
.text$mn:00001E67                 mov     eax, [ebp+var_4]
.text$mn:00001E6A                 push    eax             ; struct std::error_category *
.text$mn:00001E6B                 mov     ecx, [ebp+arg_4]
.text$mn:00001E6E                 push    ecx             ; int
.text$mn:00001E6F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001E72                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001E77                 mov     eax, [ebp+arg_0]
.text$mn:00001E7A                 mov     esp, ebp
.text$mn:00001E7C                 pop     ebp
.text$mn:00001E7D                 retn    8
.text$mn:00001E7D ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001E7D
.text$mn:00001E7D _text$mn        ends
.text$mn:00001E7D
.text$mn:00001E80 ; ===========================================================================
.text$mn:00001E80
.text$mn:00001E80 ; Segment type: Pure code
.text$mn:00001E80 ; Segment permissions: Read/Execute
.text$mn:00001E80 _text$mn        segment para public 'CODE' use32
.text$mn:00001E80                 assume cs:_text$mn
.text$mn:00001E80                 ;org 1E80h
.text$mn:00001E80 ; COMDAT (pick any)
.text$mn:00001E80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E80
.text$mn:00001E80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E80
.text$mn:00001E80 ; Attributes: bp-based frame
.text$mn:00001E80
.text$mn:00001E80 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00001E80                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00001E80 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00001E80                                         ; DATA XREF: .rdata:00002890o
.text$mn:00001E80                                         ; .rdata:000028ACo ...
.text$mn:00001E80
.text$mn:00001E80 var_8           = dword ptr -8
.text$mn:00001E80 var_4           = dword ptr -4
.text$mn:00001E80 arg_0           = dword ptr  8
.text$mn:00001E80 arg_4           = dword ptr  0Ch
.text$mn:00001E80
.text$mn:00001E80                 push    ebp
.text$mn:00001E81                 mov     ebp, esp
.text$mn:00001E83                 sub     esp, 8
.text$mn:00001E86                 mov     [ebp+var_8], ecx
.text$mn:00001E89                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001E8C                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00001E91                 push    eax
.text$mn:00001E92                 mov     ecx, [ebp+var_8]
.text$mn:00001E95                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001E9A                 movzx   eax, al
.text$mn:00001E9D                 test    eax, eax
.text$mn:00001E9F                 jz      short loc_1EB7
.text$mn:00001EA1                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001EA4                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00001EA9                 cmp     eax, [ebp+arg_4]
.text$mn:00001EAC                 jnz     short loc_1EB7
.text$mn:00001EAE                 mov     [ebp+var_4], 1
.text$mn:00001EB5                 jmp     short loc_1EBE
.text$mn:00001EB7 ; ---------------------------------------------------------------------------
.text$mn:00001EB7
.text$mn:00001EB7 loc_1EB7:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00001EB7                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00001EB7                 mov     [ebp+var_4], 0
.text$mn:00001EBE
.text$mn:00001EBE loc_1EBE:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00001EBE                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001EC1                 mov     esp, ebp
.text$mn:00001EC3                 pop     ebp
.text$mn:00001EC4                 retn    8
.text$mn:00001EC4 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00001EC4
.text$mn:00001EC4 ; ---------------------------------------------------------------------------
.text$mn:00001EC7                 align 4
.text$mn:00001EC7 _text$mn        ends
.text$mn:00001EC7
.text$mn:00001EC8 ; ===========================================================================
.text$mn:00001EC8
.text$mn:00001EC8 ; Segment type: Pure code
.text$mn:00001EC8 ; Segment permissions: Read/Execute
.text$mn:00001EC8 _text$mn        segment para public 'CODE' use32
.text$mn:00001EC8                 assume cs:_text$mn
.text$mn:00001EC8                 ;org 1EC8h
.text$mn:00001EC8 ; COMDAT (pick any)
.text$mn:00001EC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EC8
.text$mn:00001EC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EC8
.text$mn:00001EC8 ; Attributes: bp-based frame
.text$mn:00001EC8
.text$mn:00001EC8 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00001EC8                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00001EC8 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00001EC8                                         ; DATA XREF: .rdata:00002894o
.text$mn:00001EC8                                         ; .rdata:000028B0o ...
.text$mn:00001EC8
.text$mn:00001EC8 var_C           = byte ptr -0Ch
.text$mn:00001EC8 var_4           = dword ptr -4
.text$mn:00001EC8 arg_0           = dword ptr  8
.text$mn:00001EC8 arg_4           = dword ptr  0Ch
.text$mn:00001EC8
.text$mn:00001EC8                 push    ebp
.text$mn:00001EC9                 mov     ebp, esp
.text$mn:00001ECB                 sub     esp, 0Ch
.text$mn:00001ECE                 mov     [ebp+var_4], ecx
.text$mn:00001ED1                 mov     eax, [ebp+arg_4]
.text$mn:00001ED4                 push    eax             ; std::error_condition *
.text$mn:00001ED5                 mov     ecx, [ebp+arg_0]
.text$mn:00001ED8                 push    ecx
.text$mn:00001ED9                 lea     edx, [ebp+var_C]
.text$mn:00001EDC                 push    edx
.text$mn:00001EDD                 mov     eax, [ebp+var_4]
.text$mn:00001EE0                 mov     edx, [eax]
.text$mn:00001EE2                 mov     ecx, [ebp+var_4]
.text$mn:00001EE5                 mov     eax, [edx+0Ch]
.text$mn:00001EE8                 call    eax
.text$mn:00001EEA                 mov     ecx, eax
.text$mn:00001EEC                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00001EF1                 mov     esp, ebp
.text$mn:00001EF3                 pop     ebp
.text$mn:00001EF4                 retn    8
.text$mn:00001EF4 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00001EF4
.text$mn:00001EF4 ; ---------------------------------------------------------------------------
.text$mn:00001EF7                 align 4
.text$mn:00001EF7 _text$mn        ends
.text$mn:00001EF7
.text$mn:00001EF8 ; ===========================================================================
.text$mn:00001EF8
.text$mn:00001EF8 ; Segment type: Pure code
.text$mn:00001EF8 ; Segment permissions: Read/Execute
.text$mn:00001EF8 _text$mn        segment para public 'CODE' use32
.text$mn:00001EF8                 assume cs:_text$mn
.text$mn:00001EF8                 ;org 1EF8h
.text$mn:00001EF8 ; COMDAT (pick any)
.text$mn:00001EF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EF8
.text$mn:00001EF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EF8
.text$mn:00001EF8 ; Attributes: bp-based frame
.text$mn:00001EF8
.text$mn:00001EF8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00001EF8                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00001EF8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00001EF8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00001EF8
.text$mn:00001EF8 var_4           = dword ptr -4
.text$mn:00001EF8 arg_0           = dword ptr  8
.text$mn:00001EF8
.text$mn:00001EF8                 push    ebp
.text$mn:00001EF9                 mov     ebp, esp
.text$mn:00001EFB                 push    ecx
.text$mn:00001EFC                 mov     [ebp+var_4], ecx
.text$mn:00001EFF                 mov     eax, [ebp+var_4]
.text$mn:00001F02                 mov     ecx, [eax+14h]
.text$mn:00001F05                 cmp     ecx, [ebp+arg_0]
.text$mn:00001F08                 jnb     short loc_1F12
.text$mn:00001F0A                 mov     ecx, [ebp+var_4]
.text$mn:00001F0D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001F12
.text$mn:00001F12 loc_1F12:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00001F12                 mov     edx, [ebp+arg_0]
.text$mn:00001F15                 push    edx
.text$mn:00001F16                 mov     ecx, [ebp+var_4]
.text$mn:00001F19                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001F1E                 mov     eax, [ebp+var_4]
.text$mn:00001F21                 mov     esp, ebp
.text$mn:00001F23                 pop     ebp
.text$mn:00001F24                 retn    4
.text$mn:00001F24 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00001F24
.text$mn:00001F24 ; ---------------------------------------------------------------------------
.text$mn:00001F27                 align 4
.text$mn:00001F27 _text$mn        ends
.text$mn:00001F27
.text$mn:00001F28 ; ===========================================================================
.text$mn:00001F28
.text$mn:00001F28 ; Segment type: Pure code
.text$mn:00001F28 ; Segment permissions: Read/Execute
.text$mn:00001F28 _text$mn        segment para public 'CODE' use32
.text$mn:00001F28                 assume cs:_text$mn
.text$mn:00001F28                 ;org 1F28h
.text$mn:00001F28 ; COMDAT (pick any)
.text$mn:00001F28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F28
.text$mn:00001F28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F28
.text$mn:00001F28 ; Attributes: bp-based frame
.text$mn:00001F28
.text$mn:00001F28 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00001F28                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00001F28 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00001F28                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00001F28
.text$mn:00001F28 var_C           = dword ptr -0Ch
.text$mn:00001F28 Dst             = dword ptr -8
.text$mn:00001F28 var_4           = dword ptr -4
.text$mn:00001F28 arg_0           = dword ptr  8
.text$mn:00001F28 arg_4           = dword ptr  0Ch
.text$mn:00001F28
.text$mn:00001F28                 push    ebp
.text$mn:00001F29                 mov     ebp, esp
.text$mn:00001F2B                 sub     esp, 0Ch
.text$mn:00001F2E                 mov     [ebp+var_4], ecx
.text$mn:00001F31                 mov     eax, [ebp+var_4]
.text$mn:00001F34                 mov     ecx, [eax+14h]
.text$mn:00001F37                 cmp     ecx, [ebp+arg_0]
.text$mn:00001F3A                 jnb     short loc_1F44
.text$mn:00001F3C                 mov     ecx, [ebp+var_4]
.text$mn:00001F3F                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001F44
.text$mn:00001F44 loc_1F44:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00001F44                 mov     edx, [ebp+var_4]
.text$mn:00001F47                 mov     eax, [edx+14h]
.text$mn:00001F4A                 sub     eax, [ebp+arg_0]
.text$mn:00001F4D                 cmp     eax, [ebp+arg_4]
.text$mn:00001F50                 ja      short loc_1F60
.text$mn:00001F52                 mov     ecx, [ebp+arg_0]
.text$mn:00001F55                 push    ecx
.text$mn:00001F56                 mov     ecx, [ebp+var_4]
.text$mn:00001F59                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001F5E                 jmp     short loc_1FA6
.text$mn:00001F60 ; ---------------------------------------------------------------------------
.text$mn:00001F60
.text$mn:00001F60 loc_1F60:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00001F60                 cmp     [ebp+arg_4], 0
.text$mn:00001F64                 jbe     short loc_1FA6
.text$mn:00001F66                 mov     ecx, [ebp+var_4]
.text$mn:00001F69                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001F6E                 add     eax, [ebp+arg_0]
.text$mn:00001F71                 mov     [ebp+Dst], eax
.text$mn:00001F74                 mov     edx, [ebp+var_4]
.text$mn:00001F77                 mov     eax, [edx+14h]
.text$mn:00001F7A                 sub     eax, [ebp+arg_4]
.text$mn:00001F7D                 mov     [ebp+var_C], eax
.text$mn:00001F80                 mov     ecx, [ebp+var_C]
.text$mn:00001F83                 sub     ecx, [ebp+arg_0]
.text$mn:00001F86                 push    ecx             ; Size
.text$mn:00001F87                 mov     edx, [ebp+Dst]
.text$mn:00001F8A                 add     edx, [ebp+arg_4]
.text$mn:00001F8D                 push    edx             ; Src
.text$mn:00001F8E                 mov     eax, [ebp+Dst]
.text$mn:00001F91                 push    eax             ; Dst
.text$mn:00001F92                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00001F97                 add     esp, 0Ch
.text$mn:00001F9A                 mov     ecx, [ebp+var_C]
.text$mn:00001F9D                 push    ecx
.text$mn:00001F9E                 mov     ecx, [ebp+var_4]
.text$mn:00001FA1                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001FA6
.text$mn:00001FA6 loc_1FA6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00001FA6                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00001FA6                 mov     eax, [ebp+var_4]
.text$mn:00001FA9                 mov     esp, ebp
.text$mn:00001FAB                 pop     ebp
.text$mn:00001FAC                 retn    8
.text$mn:00001FAC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00001FAC
.text$mn:00001FAC ; ---------------------------------------------------------------------------
.text$mn:00001FAF                 align 10h
.text$mn:00001FAF _text$mn        ends
.text$mn:00001FAF
.text$mn:00001FB0 ; ===========================================================================
.text$mn:00001FB0
.text$mn:00001FB0 ; Segment type: Pure code
.text$mn:00001FB0 ; Segment permissions: Read/Execute
.text$mn:00001FB0 _text$mn        segment para public 'CODE' use32
.text$mn:00001FB0                 assume cs:_text$mn
.text$mn:00001FB0                 ;org 1FB0h
.text$mn:00001FB0 ; COMDAT (pick any)
.text$mn:00001FB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FB0
.text$mn:00001FB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FB0
.text$mn:00001FB0 ; Attributes: bp-based frame
.text$mn:00001FB0
.text$mn:00001FB0 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00001FB0                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00001FB0 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001FB0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00001FB0                 push    ebp
.text$mn:00001FB1                 mov     ebp, esp
.text$mn:00001FB3                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00001FB8                 pop     ebp
.text$mn:00001FB9                 retn
.text$mn:00001FB9 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001FB9
.text$mn:00001FB9 ; ---------------------------------------------------------------------------
.text$mn:00001FBA                 align 4
.text$mn:00001FBA _text$mn        ends
.text$mn:00001FBA
.text$mn:00001FBC ; ===========================================================================
.text$mn:00001FBC
.text$mn:00001FBC ; Segment type: Pure code
.text$mn:00001FBC ; Segment permissions: Read/Execute
.text$mn:00001FBC _text$mn        segment para public 'CODE' use32
.text$mn:00001FBC                 assume cs:_text$mn
.text$mn:00001FBC                 ;org 1FBCh
.text$mn:00001FBC ; COMDAT (pick any)
.text$mn:00001FBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FBC
.text$mn:00001FBC ; =============== S U B R O U T I N E =======================================
.text$mn:00001FBC
.text$mn:00001FBC ; Attributes: bp-based frame
.text$mn:00001FBC
.text$mn:00001FBC ; HWND __thiscall Window::getHSelf(Window *__hidden this)
.text$mn:00001FBC                 public ?getHSelf@Window@@QBEPAUHWND__@@XZ
.text$mn:00001FBC ?getHSelf@Window@@QBEPAUHWND__@@XZ proc near
.text$mn:00001FBC                                         ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+1FEp
.text$mn:00001FBC                                         ; SplitterContainer::runProc(uint,uint,long)+3F3p ...
.text$mn:00001FBC
.text$mn:00001FBC var_4           = dword ptr -4
.text$mn:00001FBC
.text$mn:00001FBC                 push    ebp
.text$mn:00001FBD                 mov     ebp, esp
.text$mn:00001FBF                 push    ecx
.text$mn:00001FC0                 mov     [ebp+var_4], ecx
.text$mn:00001FC3                 mov     eax, [ebp+var_4]
.text$mn:00001FC6                 mov     eax, [eax+0Ch]
.text$mn:00001FC9                 mov     esp, ebp
.text$mn:00001FCB                 pop     ebp
.text$mn:00001FCC                 retn
.text$mn:00001FCC ?getHSelf@Window@@QBEPAUHWND__@@XZ endp
.text$mn:00001FCC
.text$mn:00001FCC ; ---------------------------------------------------------------------------
.text$mn:00001FCD                 align 10h
.text$mn:00001FCD _text$mn        ends
.text$mn:00001FCD
.text$mn:00001FD0 ; ===========================================================================
.text$mn:00001FD0
.text$mn:00001FD0 ; Segment type: Pure code
.text$mn:00001FD0 ; Segment permissions: Read/Execute
.text$mn:00001FD0 _text$mn        segment para public 'CODE' use32
.text$mn:00001FD0                 assume cs:_text$mn
.text$mn:00001FD0                 ;org 1FD0h
.text$mn:00001FD0 ; COMDAT (pick any)
.text$mn:00001FD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FD0
.text$mn:00001FD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FD0
.text$mn:00001FD0 ; Attributes: bp-based frame
.text$mn:00001FD0
.text$mn:00001FD0 ; int __thiscall Splitter::getPhisicalSize(Splitter *__hidden this)
.text$mn:00001FD0                 public ?getPhisicalSize@Splitter@@QBEHXZ
.text$mn:00001FD0 ?getPhisicalSize@Splitter@@QBEHXZ proc near
.text$mn:00001FD0                                         ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+177p
.text$mn:00001FD0                                         ; SplitterContainer::runProc(uint,uint,long)+1ADp
.text$mn:00001FD0
.text$mn:00001FD0 var_4           = dword ptr -4
.text$mn:00001FD0
.text$mn:00001FD0                 push    ebp
.text$mn:00001FD1                 mov     ebp, esp
.text$mn:00001FD3                 push    ecx
.text$mn:00001FD4                 mov     [ebp+var_4], ecx
.text$mn:00001FD7                 mov     eax, [ebp+var_4]
.text$mn:00001FDA                 mov     eax, [eax+24h]
.text$mn:00001FDD                 mov     esp, ebp
.text$mn:00001FDF                 pop     ebp
.text$mn:00001FE0                 retn
.text$mn:00001FE0 ?getPhisicalSize@Splitter@@QBEHXZ endp
.text$mn:00001FE0
.text$mn:00001FE0 ; ---------------------------------------------------------------------------
.text$mn:00001FE1                 align 4
.text$mn:00001FE1 _text$mn        ends
.text$mn:00001FE1
.text$mn:00001FE4 ; ===========================================================================
.text$mn:00001FE4
.text$mn:00001FE4 ; Segment type: Pure code
.text$mn:00001FE4 ; Segment permissions: Read/Execute
.text$mn:00001FE4 _text$mn        segment para public 'CODE' use32
.text$mn:00001FE4                 assume cs:_text$mn
.text$mn:00001FE4                 ;org 1FE4h
.text$mn:00001FE4 ; COMDAT (pick any)
.text$mn:00001FE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FE4
.text$mn:00001FE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FE4
.text$mn:00001FE4 ; Attributes: bp-based frame
.text$mn:00001FE4
.text$mn:00001FE4 ; bool __thiscall SplitterContainer::isVertical(SplitterContainer *__hidden this)
.text$mn:00001FE4                 public ?isVertical@SplitterContainer@@QBE_NXZ
.text$mn:00001FE4 ?isVertical@SplitterContainer@@QBE_NXZ proc near
.text$mn:00001FE4                                         ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+402p
.text$mn:00001FE4
.text$mn:00001FE4 var_8           = dword ptr -8
.text$mn:00001FE4 var_4           = dword ptr -4
.text$mn:00001FE4
.text$mn:00001FE4                 push    ebp
.text$mn:00001FE5                 mov     ebp, esp
.text$mn:00001FE7                 sub     esp, 8
.text$mn:00001FEA                 mov     [ebp+var_8], ecx
.text$mn:00001FED                 mov     eax, [ebp+var_8]
.text$mn:00001FF0                 mov     ecx, [eax+80h]
.text$mn:00001FF6                 and     ecx, 2
.text$mn:00001FF9                 jz      short loc_2004
.text$mn:00001FFB                 mov     [ebp+var_4], 1
.text$mn:00002002                 jmp     short loc_200B
.text$mn:00002004 ; ---------------------------------------------------------------------------
.text$mn:00002004
.text$mn:00002004 loc_2004:                               ; CODE XREF: SplitterContainer::isVertical(void)+15j
.text$mn:00002004                 mov     [ebp+var_4], 0
.text$mn:0000200B
.text$mn:0000200B loc_200B:                               ; CODE XREF: SplitterContainer::isVertical(void)+1Ej
.text$mn:0000200B                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000200E                 mov     esp, ebp
.text$mn:00002010                 pop     ebp
.text$mn:00002011                 retn
.text$mn:00002011 ?isVertical@SplitterContainer@@QBE_NXZ endp
.text$mn:00002011
.text$mn:00002011 ; ---------------------------------------------------------------------------
.text$mn:00002012                 align 4
.text$mn:00002012 _text$mn        ends
.text$mn:00002012
.text$mn:00002014 ; ===========================================================================
.text$mn:00002014
.text$mn:00002014 ; Segment type: Pure code
.text$mn:00002014 ; Segment permissions: Read/Execute
.text$mn:00002014 _text$mn        segment para public 'CODE' use32
.text$mn:00002014                 assume cs:_text$mn
.text$mn:00002014                 ;org 2014h
.text$mn:00002014 ; COMDAT (pick any)
.text$mn:00002014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002014
.text$mn:00002014 ; =============== S U B R O U T I N E =======================================
.text$mn:00002014
.text$mn:00002014 ; Attributes: bp-based frame
.text$mn:00002014
.text$mn:00002014 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00002014                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00002014 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00002014                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00002014
.text$mn:00002014 var_4           = dword ptr -4
.text$mn:00002014 Str             = dword ptr  8
.text$mn:00002014
.text$mn:00002014                 push    ebp
.text$mn:00002015                 mov     ebp, esp
.text$mn:00002017                 push    ecx
.text$mn:00002018                 mov     eax, [ebp+Str]
.text$mn:0000201B                 movsx   ecx, byte ptr [eax]
.text$mn:0000201E                 test    ecx, ecx
.text$mn:00002020                 jnz     short loc_202B
.text$mn:00002022                 mov     [ebp+var_4], 0
.text$mn:00002029                 jmp     short loc_203A
.text$mn:0000202B ; ---------------------------------------------------------------------------
.text$mn:0000202B
.text$mn:0000202B loc_202B:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000202B                 mov     edx, [ebp+Str]
.text$mn:0000202E                 push    edx             ; Str
.text$mn:0000202F                 call    _strlen
.text$mn:00002034                 add     esp, 4
.text$mn:00002037                 mov     [ebp+var_4], eax
.text$mn:0000203A
.text$mn:0000203A loc_203A:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000203A                 mov     eax, [ebp+var_4]
.text$mn:0000203D                 mov     esp, ebp
.text$mn:0000203F                 pop     ebp
.text$mn:00002040                 retn
.text$mn:00002040 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00002040
.text$mn:00002040 ; ---------------------------------------------------------------------------
.text$mn:00002041                 align 4
.text$mn:00002041 _text$mn        ends
.text$mn:00002041
.text$mn:00002044 ; ===========================================================================
.text$mn:00002044
.text$mn:00002044 ; Segment type: Pure code
.text$mn:00002044 ; Segment permissions: Read/Execute
.text$mn:00002044 _text$mn        segment para public 'CODE' use32
.text$mn:00002044                 assume cs:_text$mn
.text$mn:00002044                 ;org 2044h
.text$mn:00002044 ; COMDAT (pick any)
.text$mn:00002044                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002044
.text$mn:00002044 ; =============== S U B R O U T I N E =======================================
.text$mn:00002044
.text$mn:00002044 ; Attributes: bp-based frame
.text$mn:00002044
.text$mn:00002044 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00002044                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00002044 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00002044                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00002044
.text$mn:00002044 var_4           = dword ptr -4
.text$mn:00002044
.text$mn:00002044                 push    ebp
.text$mn:00002045                 mov     ebp, esp
.text$mn:00002047                 push    ecx
.text$mn:00002048                 mov     [ebp+var_4], ecx
.text$mn:0000204B                 mov     eax, [ebp+var_4]
.text$mn:0000204E                 push    eax
.text$mn:0000204F                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00002054                 add     esp, 4
.text$mn:00002057                 mov     esp, ebp
.text$mn:00002059                 pop     ebp
.text$mn:0000205A                 retn
.text$mn:0000205A ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000205A
.text$mn:0000205A ; ---------------------------------------------------------------------------
.text$mn:0000205B                 align 4
.text$mn:0000205B _text$mn        ends
.text$mn:0000205B
.text$mn:0000205C ; ===========================================================================
.text$mn:0000205C
.text$mn:0000205C ; Segment type: Pure code
.text$mn:0000205C ; Segment permissions: Read/Execute
.text$mn:0000205C _text$mn        segment para public 'CODE' use32
.text$mn:0000205C                 assume cs:_text$mn
.text$mn:0000205C                 ;org 205Ch
.text$mn:0000205C ; COMDAT (pick any)
.text$mn:0000205C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000205C
.text$mn:0000205C ; =============== S U B R O U T I N E =======================================
.text$mn:0000205C
.text$mn:0000205C ; Attributes: bp-based frame
.text$mn:0000205C
.text$mn:0000205C ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:0000205C                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:0000205C ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:0000205C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:0000205C
.text$mn:0000205C var_4           = dword ptr -4
.text$mn:0000205C
.text$mn:0000205C                 push    ebp
.text$mn:0000205D                 mov     ebp, esp
.text$mn:0000205F                 push    ecx
.text$mn:00002060                 mov     [ebp+var_4], ecx
.text$mn:00002063                 or      eax, 0FFFFFFFFh
.text$mn:00002066                 mov     esp, ebp
.text$mn:00002068                 pop     ebp
.text$mn:00002069                 retn
.text$mn:00002069 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00002069
.text$mn:00002069 ; ---------------------------------------------------------------------------
.text$mn:0000206A                 align 4
.text$mn:0000206A _text$mn        ends
.text$mn:0000206A
.text$mn:0000206C ; ===========================================================================
.text$mn:0000206C
.text$mn:0000206C ; Segment type: Pure code
.text$mn:0000206C ; Segment permissions: Read/Execute
.text$mn:0000206C _text$mn        segment para public 'CODE' use32
.text$mn:0000206C                 assume cs:_text$mn
.text$mn:0000206C                 ;org 206Ch
.text$mn:0000206C ; COMDAT (pick any)
.text$mn:0000206C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000206C
.text$mn:0000206C ; =============== S U B R O U T I N E =======================================
.text$mn:0000206C
.text$mn:0000206C ; Attributes: bp-based frame
.text$mn:0000206C
.text$mn:0000206C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:0000206C                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:0000206C ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:0000206C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:0000206C
.text$mn:0000206C arg_0           = dword ptr  8
.text$mn:0000206C
.text$mn:0000206C                 push    ebp
.text$mn:0000206D                 mov     ebp, esp
.text$mn:0000206F                 mov     ecx, [ebp+arg_0]
.text$mn:00002072                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00002077                 pop     ebp
.text$mn:00002078                 retn
.text$mn:00002078 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00002078
.text$mn:00002078 ; ---------------------------------------------------------------------------
.text$mn:00002079                 align 4
.text$mn:00002079 _text$mn        ends
.text$mn:00002079
.text$mn:0000207C ; ===========================================================================
.text$mn:0000207C
.text$mn:0000207C ; Segment type: Pure code
.text$mn:0000207C ; Segment permissions: Read/Execute
.text$mn:0000207C _text$mn        segment para public 'CODE' use32
.text$mn:0000207C                 assume cs:_text$mn
.text$mn:0000207C                 ;org 207Ch
.text$mn:0000207C ; COMDAT (pick any)
.text$mn:0000207C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000207C
.text$mn:0000207C ; =============== S U B R O U T I N E =======================================
.text$mn:0000207C
.text$mn:0000207C ; Attributes: bp-based frame
.text$mn:0000207C
.text$mn:0000207C ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:0000207C                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000207C ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000207C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:0000207C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000207C
.text$mn:0000207C var_10          = dword ptr -10h
.text$mn:0000207C var_C           = dword ptr -0Ch
.text$mn:0000207C var_8           = dword ptr -8
.text$mn:0000207C var_1           = byte ptr -1
.text$mn:0000207C
.text$mn:0000207C                 push    ebp
.text$mn:0000207D                 mov     ebp, esp
.text$mn:0000207F                 sub     esp, 10h
.text$mn:00002082                 mov     [ebp+var_10], ecx
.text$mn:00002085                 lea     eax, [ebp+var_1]
.text$mn:00002088                 push    eax
.text$mn:00002089                 mov     ecx, [ebp+var_10]
.text$mn:0000208C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002091                 mov     ecx, eax
.text$mn:00002093                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00002098                 mov     [ebp+var_8], eax
.text$mn:0000209B                 cmp     [ebp+var_8], 1
.text$mn:0000209F                 ja      short loc_20AA
.text$mn:000020A1                 mov     [ebp+var_C], 1
.text$mn:000020A8                 jmp     short loc_20B3
.text$mn:000020AA ; ---------------------------------------------------------------------------
.text$mn:000020AA
.text$mn:000020AA loc_20AA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:000020AA                 mov     ecx, [ebp+var_8]
.text$mn:000020AD                 sub     ecx, 1
.text$mn:000020B0                 mov     [ebp+var_C], ecx
.text$mn:000020B3
.text$mn:000020B3 loc_20B3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:000020B3                 mov     eax, [ebp+var_C]
.text$mn:000020B6                 mov     esp, ebp
.text$mn:000020B8                 pop     ebp
.text$mn:000020B9                 retn
.text$mn:000020B9 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:000020B9
.text$mn:000020B9 ; ---------------------------------------------------------------------------
.text$mn:000020BA                 align 4
.text$mn:000020BA _text$mn        ends
.text$mn:000020BA
.text$mn:000020BC ; ===========================================================================
.text$mn:000020BC
.text$mn:000020BC ; Segment type: Pure code
.text$mn:000020BC ; Segment permissions: Read/Execute
.text$mn:000020BC _text$mn        segment para public 'CODE' use32
.text$mn:000020BC                 assume cs:_text$mn
.text$mn:000020BC                 ;org 20BCh
.text$mn:000020BC ; COMDAT (pick any)
.text$mn:000020BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020BC
.text$mn:000020BC ; =============== S U B R O U T I N E =======================================
.text$mn:000020BC
.text$mn:000020BC ; Attributes: bp-based frame
.text$mn:000020BC
.text$mn:000020BC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:000020BC                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000020BC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000020BC                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:000020BC                                         ; DATA XREF: .rdata:000028A4o
.text$mn:000020BC
.text$mn:000020BC var_1C          = dword ptr -1Ch
.text$mn:000020BC var_18          = dword ptr -18h
.text$mn:000020BC Str             = dword ptr -14h
.text$mn:000020BC var_10          = dword ptr -10h
.text$mn:000020BC var_C           = dword ptr -0Ch
.text$mn:000020BC var_4           = dword ptr -4
.text$mn:000020BC arg_0           = dword ptr  8
.text$mn:000020BC arg_4           = dword ptr  0Ch
.text$mn:000020BC
.text$mn:000020BC                 push    ebp
.text$mn:000020BD                 mov     ebp, esp
.text$mn:000020BF                 push    0FFFFFFFFh
.text$mn:000020C1                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000020C6                 mov     eax, large fs:0
.text$mn:000020CC                 push    eax
.text$mn:000020CD                 sub     esp, 10h
.text$mn:000020D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000020D5                 xor     eax, ebp
.text$mn:000020D7                 push    eax
.text$mn:000020D8                 lea     eax, [ebp+var_C]
.text$mn:000020DB                 mov     large fs:0, eax
.text$mn:000020E1                 mov     [ebp+var_1C], ecx
.text$mn:000020E4                 mov     [ebp+var_18], 0
.text$mn:000020EB                 mov     eax, [ebp+arg_4]
.text$mn:000020EE                 push    eax             ; int
.text$mn:000020EF                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000020F4                 add     esp, 4
.text$mn:000020F7                 mov     [ebp+var_10], eax
.text$mn:000020FA                 cmp     [ebp+var_10], 0
.text$mn:000020FE                 jz      short loc_2108
.text$mn:00002100                 mov     ecx, [ebp+var_10]
.text$mn:00002103                 mov     [ebp+Str], ecx
.text$mn:00002106                 jmp     short loc_210F
.text$mn:00002108 ; ---------------------------------------------------------------------------
.text$mn:00002108
.text$mn:00002108 loc_2108:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00002108                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000210F
.text$mn:0000210F loc_210F:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0000210F                 mov     edx, [ebp+Str]
.text$mn:00002112                 push    edx             ; Str
.text$mn:00002113                 mov     ecx, [ebp+arg_0]
.text$mn:00002116                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000211B                 mov     [ebp+var_4], 0
.text$mn:00002122                 mov     eax, [ebp+var_18]
.text$mn:00002125                 or      eax, 1
.text$mn:00002128                 mov     [ebp+var_18], eax
.text$mn:0000212B                 mov     eax, [ebp+arg_0]
.text$mn:0000212E                 mov     ecx, [ebp+var_C]
.text$mn:00002131                 mov     large fs:0, ecx
.text$mn:00002138                 pop     ecx
.text$mn:00002139                 mov     esp, ebp
.text$mn:0000213B                 pop     ebp
.text$mn:0000213C                 retn    8
.text$mn:0000213C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000213C
.text$mn:0000213C ; ---------------------------------------------------------------------------
.text$mn:0000213F                 align 10h
.text$mn:0000213F _text$mn        ends
.text$mn:0000213F
.text$x:00002140 ; ===========================================================================
.text$x:00002140
.text$x:00002140 ; Segment type: Pure code
.text$x:00002140 ; Segment permissions: Read/Execute
.text$x:00002140 _text$x         segment para public 'CODE' use32
.text$x:00002140                 assume cs:_text$x
.text$x:00002140                 ;org 2140h
.text$x:00002140 ; COMDAT (pick associative to section at 20BC)
.text$x:00002140                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002140
.text$x:00002140 ; =============== S U B R O U T I N E =======================================
.text$x:00002140
.text$x:00002140
.text$x:00002140 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002140                                         ; DATA XREF: .xdata$x:0000262Co
.text$x:00002140                 mov     eax, [ebp-18h]
.text$x:00002143                 and     eax, 1
.text$x:00002146                 jz      $LN6
.text$x:0000214C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002150                 mov     ecx, [ebp+8]
.text$x:00002153                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002158 ; ---------------------------------------------------------------------------
.text$x:00002158
.text$x:00002158 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002158                 retn
.text$x:00002158 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002158
.text$x:00002159
.text$x:00002159 ; =============== S U B R O U T I N E =======================================
.text$x:00002159
.text$x:00002159
.text$x:00002159 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002159                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00002159
.text$x:00002159 arg_4           = dword ptr  8
.text$x:00002159
.text$x:00002159                 mov     edx, [esp+arg_4]
.text$x:0000215D                 lea     eax, [edx+0Ch]
.text$x:00002160                 mov     ecx, [edx-14h]
.text$x:00002163                 xor     ecx, eax
.text$x:00002165                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000216A                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000216F                 jmp     ___CxxFrameHandler3
.text$x:0000216F __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000216F
.text$x:0000216F _text$x         ends
.text$x:0000216F
.text$mn:00002174 ; ===========================================================================
.text$mn:00002174
.text$mn:00002174 ; Segment type: Pure code
.text$mn:00002174 ; Segment permissions: Read/Execute
.text$mn:00002174 _text$mn        segment para public 'CODE' use32
.text$mn:00002174                 assume cs:_text$mn
.text$mn:00002174                 ;org 2174h
.text$mn:00002174 ; COMDAT (pick any)
.text$mn:00002174                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002174
.text$mn:00002174 ; =============== S U B R O U T I N E =======================================
.text$mn:00002174
.text$mn:00002174 ; Attributes: bp-based frame
.text$mn:00002174
.text$mn:00002174 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00002174                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002174 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002174                                         ; DATA XREF: .rdata:000028D8o
.text$mn:00002174
.text$mn:00002174 var_14          = dword ptr -14h
.text$mn:00002174 var_10          = dword ptr -10h
.text$mn:00002174 var_C           = dword ptr -0Ch
.text$mn:00002174 var_4           = dword ptr -4
.text$mn:00002174 arg_0           = dword ptr  8
.text$mn:00002174 arg_4           = dword ptr  0Ch
.text$mn:00002174
.text$mn:00002174                 push    ebp
.text$mn:00002175                 mov     ebp, esp
.text$mn:00002177                 push    0FFFFFFFFh
.text$mn:00002179                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000217E                 mov     eax, large fs:0
.text$mn:00002184                 push    eax
.text$mn:00002185                 sub     esp, 8
.text$mn:00002188                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000218D                 xor     eax, ebp
.text$mn:0000218F                 push    eax
.text$mn:00002190                 lea     eax, [ebp+var_C]
.text$mn:00002193                 mov     large fs:0, eax
.text$mn:00002199                 mov     [ebp+var_14], ecx
.text$mn:0000219C                 mov     [ebp+var_10], 0
.text$mn:000021A3                 cmp     [ebp+arg_4], 1
.text$mn:000021A7                 jnz     short loc_21CD
.text$mn:000021A9                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:000021AE                 mov     ecx, [ebp+arg_0]
.text$mn:000021B1                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000021B6                 mov     [ebp+var_4], 0
.text$mn:000021BD                 mov     eax, [ebp+var_10]
.text$mn:000021C0                 or      eax, 1
.text$mn:000021C3                 mov     [ebp+var_10], eax
.text$mn:000021C6                 mov     eax, [ebp+arg_0]
.text$mn:000021C9                 jmp     short loc_21F0
.text$mn:000021CB ; ---------------------------------------------------------------------------
.text$mn:000021CB                 jmp     short loc_21F0
.text$mn:000021CD ; ---------------------------------------------------------------------------
.text$mn:000021CD
.text$mn:000021CD loc_21CD:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:000021CD                 mov     ecx, [ebp+arg_4]
.text$mn:000021D0                 push    ecx
.text$mn:000021D1                 mov     edx, [ebp+arg_0]
.text$mn:000021D4                 push    edx
.text$mn:000021D5                 mov     ecx, [ebp+var_14]
.text$mn:000021D8                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:000021DD                 mov     [ebp+var_4], 0
.text$mn:000021E4                 mov     eax, [ebp+var_10]
.text$mn:000021E7                 or      eax, 1
.text$mn:000021EA                 mov     [ebp+var_10], eax
.text$mn:000021ED                 mov     eax, [ebp+arg_0]
.text$mn:000021F0
.text$mn:000021F0 loc_21F0:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:000021F0                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:000021F0                 mov     ecx, [ebp+var_C]
.text$mn:000021F3                 mov     large fs:0, ecx
.text$mn:000021FA                 pop     ecx
.text$mn:000021FB                 mov     esp, ebp
.text$mn:000021FD                 pop     ebp
.text$mn:000021FE                 retn    8
.text$mn:000021FE ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000021FE
.text$mn:000021FE ; ---------------------------------------------------------------------------
.text$mn:00002201                 align 4
.text$mn:00002201 _text$mn        ends
.text$mn:00002201
.text$x:00002204 ; ===========================================================================
.text$x:00002204
.text$x:00002204 ; Segment type: Pure code
.text$x:00002204 ; Segment permissions: Read/Execute
.text$x:00002204 _text$x         segment para public 'CODE' use32
.text$x:00002204                 assume cs:_text$x
.text$x:00002204                 ;org 2204h
.text$x:00002204 ; COMDAT (pick associative to section at 2174)
.text$x:00002204                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002204
.text$x:00002204 ; =============== S U B R O U T I N E =======================================
.text$x:00002204
.text$x:00002204
.text$x:00002204 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002204                                         ; DATA XREF: .xdata$x:000026B0o
.text$x:00002204                 mov     eax, [ebp-10h]
.text$x:00002207                 and     eax, 1
.text$x:0000220A                 jz      $LN6_0
.text$x:00002210                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002214                 mov     ecx, [ebp+8]
.text$x:00002217                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000221C ; ---------------------------------------------------------------------------
.text$x:0000221C
.text$x:0000221C $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000221C                 retn
.text$x:0000221C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000221C
.text$x:0000221D
.text$x:0000221D ; =============== S U B R O U T I N E =======================================
.text$x:0000221D
.text$x:0000221D
.text$x:0000221D __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000221D                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:0000221D
.text$x:0000221D arg_4           = dword ptr  8
.text$x:0000221D
.text$x:0000221D                 mov     edx, [esp+arg_4]
.text$x:00002221                 lea     eax, [edx+0Ch]
.text$x:00002224                 mov     ecx, [edx-0Ch]
.text$x:00002227                 xor     ecx, eax
.text$x:00002229                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000222E                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002233                 jmp     ___CxxFrameHandler3
.text$x:00002233 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002233
.text$x:00002233 _text$x         ends
.text$x:00002233
.text$mn:00002238 ; ===========================================================================
.text$mn:00002238
.text$mn:00002238 ; Segment type: Pure code
.text$mn:00002238 ; Segment permissions: Read/Execute
.text$mn:00002238 _text$mn        segment para public 'CODE' use32
.text$mn:00002238                 assume cs:_text$mn
.text$mn:00002238                 ;org 2238h
.text$mn:00002238 ; COMDAT (pick any)
.text$mn:00002238                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002238
.text$mn:00002238 ; =============== S U B R O U T I N E =======================================
.text$mn:00002238
.text$mn:00002238 ; Attributes: bp-based frame
.text$mn:00002238
.text$mn:00002238 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00002238                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002238 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002238                                         ; DATA XREF: .rdata:00002918o
.text$mn:00002238
.text$mn:00002238 var_1C          = dword ptr -1Ch
.text$mn:00002238 var_18          = dword ptr -18h
.text$mn:00002238 Str             = dword ptr -14h
.text$mn:00002238 var_10          = dword ptr -10h
.text$mn:00002238 var_C           = dword ptr -0Ch
.text$mn:00002238 var_4           = dword ptr -4
.text$mn:00002238 arg_0           = dword ptr  8
.text$mn:00002238 arg_4           = dword ptr  0Ch
.text$mn:00002238
.text$mn:00002238                 push    ebp
.text$mn:00002239                 mov     ebp, esp
.text$mn:0000223B                 push    0FFFFFFFFh
.text$mn:0000223D                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002242                 mov     eax, large fs:0
.text$mn:00002248                 push    eax
.text$mn:00002249                 sub     esp, 10h
.text$mn:0000224C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002251                 xor     eax, ebp
.text$mn:00002253                 push    eax
.text$mn:00002254                 lea     eax, [ebp+var_C]
.text$mn:00002257                 mov     large fs:0, eax
.text$mn:0000225D                 mov     [ebp+var_1C], ecx
.text$mn:00002260                 mov     [ebp+var_18], 0
.text$mn:00002267                 mov     eax, [ebp+arg_4]
.text$mn:0000226A                 push    eax             ; int
.text$mn:0000226B                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00002270                 add     esp, 4
.text$mn:00002273                 mov     [ebp+var_10], eax
.text$mn:00002276                 cmp     [ebp+var_10], 0
.text$mn:0000227A                 jz      short loc_2284
.text$mn:0000227C                 mov     ecx, [ebp+var_10]
.text$mn:0000227F                 mov     [ebp+Str], ecx
.text$mn:00002282                 jmp     short loc_228B
.text$mn:00002284 ; ---------------------------------------------------------------------------
.text$mn:00002284
.text$mn:00002284 loc_2284:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00002284                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000228B
.text$mn:0000228B loc_228B:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:0000228B                 mov     edx, [ebp+Str]
.text$mn:0000228E                 push    edx             ; Str
.text$mn:0000228F                 mov     ecx, [ebp+arg_0]
.text$mn:00002292                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002297                 mov     [ebp+var_4], 0
.text$mn:0000229E                 mov     eax, [ebp+var_18]
.text$mn:000022A1                 or      eax, 1
.text$mn:000022A4                 mov     [ebp+var_18], eax
.text$mn:000022A7                 mov     eax, [ebp+arg_0]
.text$mn:000022AA                 mov     ecx, [ebp+var_C]
.text$mn:000022AD                 mov     large fs:0, ecx
.text$mn:000022B4                 pop     ecx
.text$mn:000022B5                 mov     esp, ebp
.text$mn:000022B7                 pop     ebp
.text$mn:000022B8                 retn    8
.text$mn:000022B8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000022B8
.text$mn:000022B8 ; ---------------------------------------------------------------------------
.text$mn:000022BB                 align 4
.text$mn:000022BB _text$mn        ends
.text$mn:000022BB
.text$x:000022BC ; ===========================================================================
.text$x:000022BC
.text$x:000022BC ; Segment type: Pure code
.text$x:000022BC ; Segment permissions: Read/Execute
.text$x:000022BC _text$x         segment para public 'CODE' use32
.text$x:000022BC                 assume cs:_text$x
.text$x:000022BC                 ;org 22BCh
.text$x:000022BC ; COMDAT (pick associative to section at 2238)
.text$x:000022BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000022BC
.text$x:000022BC ; =============== S U B R O U T I N E =======================================
.text$x:000022BC
.text$x:000022BC
.text$x:000022BC __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000022BC                                         ; DATA XREF: .xdata$x:00002734o
.text$x:000022BC                 mov     eax, [ebp-18h]
.text$x:000022BF                 and     eax, 1
.text$x:000022C2                 jz      $LN6_1
.text$x:000022C8                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000022CC                 mov     ecx, [ebp+8]
.text$x:000022CF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000022D4 ; ---------------------------------------------------------------------------
.text$x:000022D4
.text$x:000022D4 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000022D4                 retn
.text$x:000022D4 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000022D4
.text$x:000022D5
.text$x:000022D5 ; =============== S U B R O U T I N E =======================================
.text$x:000022D5
.text$x:000022D5
.text$x:000022D5 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000022D5                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:000022D5
.text$x:000022D5 arg_4           = dword ptr  8
.text$x:000022D5
.text$x:000022D5                 mov     edx, [esp+arg_4]
.text$x:000022D9                 lea     eax, [edx+0Ch]
.text$x:000022DC                 mov     ecx, [edx-14h]
.text$x:000022DF                 xor     ecx, eax
.text$x:000022E1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000022E6                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000022EB                 jmp     ___CxxFrameHandler3
.text$x:000022EB __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000022EB
.text$x:000022EB _text$x         ends
.text$x:000022EB
.text$mn:000022F0 ; ===========================================================================
.text$mn:000022F0
.text$mn:000022F0 ; Segment type: Pure code
.text$mn:000022F0 ; Segment permissions: Read/Execute
.text$mn:000022F0 _text$mn        segment para public 'CODE' use32
.text$mn:000022F0                 assume cs:_text$mn
.text$mn:000022F0                 ;org 22F0h
.text$mn:000022F0 ; COMDAT (pick any)
.text$mn:000022F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022F0
.text$mn:000022F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022F0
.text$mn:000022F0 ; Attributes: bp-based frame
.text$mn:000022F0
.text$mn:000022F0 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:000022F0                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000022F0 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:000022F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:000022F0
.text$mn:000022F0 var_4           = dword ptr -4
.text$mn:000022F0 Dst             = dword ptr  8
.text$mn:000022F0 Src             = dword ptr  0Ch
.text$mn:000022F0 Size            = dword ptr  10h
.text$mn:000022F0
.text$mn:000022F0                 push    ebp
.text$mn:000022F1                 mov     ebp, esp
.text$mn:000022F3                 push    ecx
.text$mn:000022F4                 cmp     [ebp+Size], 0
.text$mn:000022F8                 jnz     short loc_2302
.text$mn:000022FA                 mov     eax, [ebp+Dst]
.text$mn:000022FD                 mov     [ebp+var_4], eax
.text$mn:00002300                 jmp     short loc_2319
.text$mn:00002302 ; ---------------------------------------------------------------------------
.text$mn:00002302
.text$mn:00002302 loc_2302:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00002302                 mov     ecx, [ebp+Size]
.text$mn:00002305                 push    ecx             ; Size
.text$mn:00002306                 mov     edx, [ebp+Src]
.text$mn:00002309                 push    edx             ; Src
.text$mn:0000230A                 mov     eax, [ebp+Dst]
.text$mn:0000230D                 push    eax             ; Dst
.text$mn:0000230E                 call    _memmove
.text$mn:00002313                 add     esp, 0Ch
.text$mn:00002316                 mov     [ebp+var_4], eax
.text$mn:00002319
.text$mn:00002319 loc_2319:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00002319                 mov     eax, [ebp+var_4]
.text$mn:0000231C                 mov     esp, ebp
.text$mn:0000231E                 pop     ebp
.text$mn:0000231F                 retn
.text$mn:0000231F ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000231F
.text$mn:0000231F _text$mn        ends
.text$mn:0000231F
.text$mn:00002320 ; ===========================================================================
.text$mn:00002320
.text$mn:00002320 ; Segment type: Pure code
.text$mn:00002320 ; Segment permissions: Read/Execute
.text$mn:00002320 _text$mn        segment para public 'CODE' use32
.text$mn:00002320                 assume cs:_text$mn
.text$mn:00002320                 ;org 2320h
.text$mn:00002320 ; COMDAT (pick any)
.text$mn:00002320                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002320
.text$mn:00002320 ; =============== S U B R O U T I N E =======================================
.text$mn:00002320
.text$mn:00002320 ; Attributes: bp-based frame
.text$mn:00002320
.text$mn:00002320 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00002320                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00002320 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00002320                                         ; DATA XREF: .rdata:000028A0o
.text$mn:00002320
.text$mn:00002320 var_4           = dword ptr -4
.text$mn:00002320
.text$mn:00002320                 push    ebp
.text$mn:00002321                 mov     ebp, esp
.text$mn:00002323                 push    ecx
.text$mn:00002324                 mov     [ebp+var_4], ecx
.text$mn:00002327                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:0000232C                 mov     esp, ebp
.text$mn:0000232E                 pop     ebp
.text$mn:0000232F                 retn
.text$mn:0000232F ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000232F
.text$mn:0000232F _text$mn        ends
.text$mn:0000232F
.text$mn:00002330 ; ===========================================================================
.text$mn:00002330
.text$mn:00002330 ; Segment type: Pure code
.text$mn:00002330 ; Segment permissions: Read/Execute
.text$mn:00002330 _text$mn        segment para public 'CODE' use32
.text$mn:00002330                 assume cs:_text$mn
.text$mn:00002330                 ;org 2330h
.text$mn:00002330 ; COMDAT (pick any)
.text$mn:00002330                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002330
.text$mn:00002330 ; =============== S U B R O U T I N E =======================================
.text$mn:00002330
.text$mn:00002330 ; Attributes: bp-based frame
.text$mn:00002330
.text$mn:00002330 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00002330                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00002330 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00002330                                         ; DATA XREF: .rdata:000028D4o
.text$mn:00002330
.text$mn:00002330 var_4           = dword ptr -4
.text$mn:00002330
.text$mn:00002330                 push    ebp
.text$mn:00002331                 mov     ebp, esp
.text$mn:00002333                 push    ecx
.text$mn:00002334                 mov     [ebp+var_4], ecx
.text$mn:00002337                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:0000233C                 mov     esp, ebp
.text$mn:0000233E                 pop     ebp
.text$mn:0000233F                 retn
.text$mn:0000233F ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000233F
.text$mn:0000233F _text$mn        ends
.text$mn:0000233F
.text$mn:00002340 ; ===========================================================================
.text$mn:00002340
.text$mn:00002340 ; Segment type: Pure code
.text$mn:00002340 ; Segment permissions: Read/Execute
.text$mn:00002340 _text$mn        segment para public 'CODE' use32
.text$mn:00002340                 assume cs:_text$mn
.text$mn:00002340                 ;org 2340h
.text$mn:00002340 ; COMDAT (pick any)
.text$mn:00002340                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002340
.text$mn:00002340 ; =============== S U B R O U T I N E =======================================
.text$mn:00002340
.text$mn:00002340 ; Attributes: bp-based frame
.text$mn:00002340
.text$mn:00002340 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00002340                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00002340 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00002340                                         ; DATA XREF: .rdata:00002914o
.text$mn:00002340
.text$mn:00002340 var_4           = dword ptr -4
.text$mn:00002340
.text$mn:00002340                 push    ebp
.text$mn:00002341                 mov     ebp, esp
.text$mn:00002343                 push    ecx
.text$mn:00002344                 mov     [ebp+var_4], ecx
.text$mn:00002347                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:0000234C                 mov     esp, ebp
.text$mn:0000234E                 pop     ebp
.text$mn:0000234F                 retn
.text$mn:0000234F ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000234F
.text$mn:0000234F _text$mn        ends
.text$mn:0000234F
.text$mn:00002350 ; ===========================================================================
.text$mn:00002350
.text$mn:00002350 ; Segment type: Pure code
.text$mn:00002350 ; Segment permissions: Read/Execute
.text$mn:00002350 _text$mn        segment para public 'CODE' use32
.text$mn:00002350                 assume cs:_text$mn
.text$mn:00002350                 ;org 2350h
.text$mn:00002350 ; COMDAT (pick any)
.text$mn:00002350                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002350
.text$mn:00002350 ; =============== S U B R O U T I N E =======================================
.text$mn:00002350
.text$mn:00002350 ; Attributes: bp-based frame
.text$mn:00002350
.text$mn:00002350 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00002350                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002350 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002350                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00002350                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00002350
.text$mn:00002350 var_4           = dword ptr -4
.text$mn:00002350
.text$mn:00002350                 push    ebp
.text$mn:00002351                 mov     ebp, esp
.text$mn:00002353                 push    ecx
.text$mn:00002354                 mov     [ebp+var_4], ecx
.text$mn:00002357                 mov     eax, [ebp+var_4]
.text$mn:0000235A                 mov     eax, [eax+14h]
.text$mn:0000235D                 mov     esp, ebp
.text$mn:0000235F                 pop     ebp
.text$mn:00002360                 retn
.text$mn:00002360 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002360
.text$mn:00002360 ; ---------------------------------------------------------------------------
.text$mn:00002361                 align 4
.text$mn:00002361 _text$mn        ends
.text$mn:00002361
.text$mn:00002364 ; ===========================================================================
.text$mn:00002364
.text$mn:00002364 ; Segment type: Pure code
.text$mn:00002364 ; Segment permissions: Read/Execute
.text$mn:00002364 _text$mn        segment para public 'CODE' use32
.text$mn:00002364                 assume cs:_text$mn
.text$mn:00002364                 ;org 2364h
.text$mn:00002364 ; COMDAT (pick any)
.text$mn:00002364                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002364
.text$mn:00002364 ; =============== S U B R O U T I N E =======================================
.text$mn:00002364
.text$mn:00002364 ; Attributes: bp-based frame
.text$mn:00002364
.text$mn:00002364 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00002364                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00002364 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002364                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_1E44p
.text$mn:00002364                 push    ebp
.text$mn:00002365                 mov     ebp, esp
.text$mn:00002367                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:0000236C                 pop     ebp
.text$mn:0000236D                 retn
.text$mn:0000236D ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000236D
.text$mn:0000236D ; ---------------------------------------------------------------------------
.text$mn:0000236E                 align 10h
.text$mn:0000236E _text$mn        ends
.text$mn:0000236E
.text$mn:00002370 ; ===========================================================================
.text$mn:00002370
.text$mn:00002370 ; Segment type: Pure code
.text$mn:00002370 ; Segment permissions: Read/Execute
.text$mn:00002370 _text$mn        segment para public 'CODE' use32
.text$mn:00002370                 assume cs:_text$mn
.text$mn:00002370                 ;org 2370h
.text$mn:00002370 ; COMDAT (pick any)
.text$mn:00002370                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002370
.text$mn:00002370 ; =============== S U B R O U T I N E =======================================
.text$mn:00002370
.text$mn:00002370 ; Attributes: bp-based frame
.text$mn:00002370
.text$mn:00002370 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00002370                 public ?value@error_code@std@@QBEHXZ
.text$mn:00002370 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00002370
.text$mn:00002370 var_4           = dword ptr -4
.text$mn:00002370
.text$mn:00002370                 push    ebp
.text$mn:00002371                 mov     ebp, esp
.text$mn:00002373                 push    ecx
.text$mn:00002374                 mov     [ebp+var_4], ecx
.text$mn:00002377                 mov     eax, [ebp+var_4]
.text$mn:0000237A                 mov     eax, [eax]
.text$mn:0000237C                 mov     esp, ebp
.text$mn:0000237E                 pop     ebp
.text$mn:0000237F                 retn
.text$mn:0000237F ?value@error_code@std@@QBEHXZ endp
.text$mn:0000237F
.text$mn:0000237F _text$mn        ends
.text$mn:0000237F
.text$mn:00002380 ; ===========================================================================
.text$mn:00002380
.text$mn:00002380 ; Segment type: Pure code
.text$mn:00002380 ; Segment permissions: Read/Execute
.text$mn:00002380 _text$mn        segment para public 'CODE' use32
.text$mn:00002380                 assume cs:_text$mn
.text$mn:00002380                 ;org 2380h
.text$mn:00002380 ; COMDAT (pick any)
.text$mn:00002380                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002380
.text$mn:00002380 ; =============== S U B R O U T I N E =======================================
.text$mn:00002380
.text$mn:00002380 ; Attributes: bp-based frame
.text$mn:00002380
.text$mn:00002380 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00002380                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00002380 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00002380                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00002380                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00002380
.text$mn:00002380 var_4           = dword ptr -4
.text$mn:00002380
.text$mn:00002380                 push    ebp
.text$mn:00002381                 mov     ebp, esp
.text$mn:00002383                 push    ecx
.text$mn:00002384                 mov     [ebp+var_4], ecx
.text$mn:00002387                 mov     eax, [ebp+var_4]
.text$mn:0000238A                 mov     eax, [eax]
.text$mn:0000238C                 mov     esp, ebp
.text$mn:0000238E                 pop     ebp
.text$mn:0000238F                 retn
.text$mn:0000238F ?value@error_condition@std@@QBEHXZ endp
.text$mn:0000238F
.text$mn:0000238F _text$mn        ends
.text$mn:0000238F
.text$mn:00002390 ; ===========================================================================
.text$mn:00002390
.text$mn:00002390 ; Segment type: Pure code
.text$mn:00002390 ; Segment permissions: Read/Execute
.text$mn:00002390 _text$mn        segment para public 'CODE' use32
.text$mn:00002390                 assume cs:_text$mn
.text$mn:00002390                 ;org 2390h
.text$mn:00002390 ; COMDAT (pick any)
.text$mn:00002390                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002390
.text$mn:00002390 ; =============== S U B R O U T I N E =======================================
.text$mn:00002390
.text$mn:00002390 ; Attributes: bp-based frame
.text$mn:00002390
.text$mn:00002390                 public _hypot
.text$mn:00002390 _hypot          proc near
.text$mn:00002390
.text$mn:00002390 var_10          = qword ptr -10h
.text$mn:00002390 var_8           = qword ptr -8
.text$mn:00002390 arg_0           = qword ptr  8
.text$mn:00002390 arg_8           = qword ptr  10h
.text$mn:00002390
.text$mn:00002390                 push    ebp
.text$mn:00002391                 mov     ebp, esp
.text$mn:00002393                 sub     esp, 8
.text$mn:00002396                 movsd   xmm0, [ebp+arg_8]
.text$mn:0000239B                 movsd   [esp+8+var_8], xmm0
.text$mn:000023A0                 sub     esp, 8
.text$mn:000023A3                 movsd   xmm0, [ebp+arg_0]
.text$mn:000023A8                 movsd   [esp+10h+var_10], xmm0
.text$mn:000023AD                 call    __hypot
.text$mn:000023B2                 add     esp, 10h
.text$mn:000023B5                 pop     ebp
.text$mn:000023B6                 retn
.text$mn:000023B6 _hypot          endp
.text$mn:000023B6
.text$mn:000023B6 ; ---------------------------------------------------------------------------
.text$mn:000023B7                 align 4
.text$mn:000023B7 _text$mn        ends
.text$mn:000023B7
.xdata$x:000023B8 ; ===========================================================================
.xdata$x:000023B8
.xdata$x:000023B8 ; Segment type: Pure data
.xdata$x:000023B8 ; Segment permissions: Read
.xdata$x:000023B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000023B8                 assume cs:_xdata$x
.xdata$x:000023B8                 ;org 23B8h
.xdata$x:000023B8 ; COMDAT (pick associative to section at 19E8)
.xdata$x:000023B8 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:000023B8                                         ; DATA XREF: .xdata$x:000023C8o
.xdata$x:000023B9                 db 0FFh
.xdata$x:000023BA                 db 0FFh
.xdata$x:000023BB                 db 0FFh
.xdata$x:000023BC                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:000023C0 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:000023C0                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:000023C1                 db    5
.xdata$x:000023C2                 db  93h ; ô
.xdata$x:000023C3                 db  19h
.xdata$x:000023C4                 db    1
.xdata$x:000023C5                 db    0
.xdata$x:000023C6                 db    0
.xdata$x:000023C7                 db    0
.xdata$x:000023C8                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:000023CC                 db    0
.xdata$x:000023CD                 db    0
.xdata$x:000023CE                 db    0
.xdata$x:000023CF                 db    0
.xdata$x:000023D0                 db    0
.xdata$x:000023D1                 db    0
.xdata$x:000023D2                 db    0
.xdata$x:000023D3                 db    0
.xdata$x:000023D4                 db    0
.xdata$x:000023D5                 db    0
.xdata$x:000023D6                 db    0
.xdata$x:000023D7                 db    0
.xdata$x:000023D8                 db    0
.xdata$x:000023D9                 db    0
.xdata$x:000023DA                 db    0
.xdata$x:000023DB                 db    0
.xdata$x:000023DC                 db    0
.xdata$x:000023DD                 db    0
.xdata$x:000023DE                 db    0
.xdata$x:000023DF                 db    0
.xdata$x:000023E0                 db    0
.xdata$x:000023E1                 db    0
.xdata$x:000023E2                 db    0
.xdata$x:000023E3                 db    0
.xdata$x:000023E3 _xdata$x        ends
.xdata$x:000023E3
.xdata$x:000023E4 ; ===========================================================================
.xdata$x:000023E4
.xdata$x:000023E4 ; Segment type: Pure data
.xdata$x:000023E4 ; Segment permissions: Read
.xdata$x:000023E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000023E4                 assume cs:_xdata$x
.xdata$x:000023E4                 ;org 23E4h
.xdata$x:000023E4 ; COMDAT (pick associative to section at C4C)
.xdata$x:000023E4 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000023E4                                         ; DATA XREF: .xdata$x:000023F4o
.xdata$x:000023E5                 db 0FFh
.xdata$x:000023E6                 db 0FFh
.xdata$x:000023E7                 db 0FFh
.xdata$x:000023E8                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000023EC __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000023EC                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000023ED                 db    5
.xdata$x:000023EE                 db  93h ; ô
.xdata$x:000023EF                 db  19h
.xdata$x:000023F0                 db    1
.xdata$x:000023F1                 db    0
.xdata$x:000023F2                 db    0
.xdata$x:000023F3                 db    0
.xdata$x:000023F4                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:000023F8                 db    0
.xdata$x:000023F9                 db    0
.xdata$x:000023FA                 db    0
.xdata$x:000023FB                 db    0
.xdata$x:000023FC                 db    0
.xdata$x:000023FD                 db    0
.xdata$x:000023FE                 db    0
.xdata$x:000023FF                 db    0
.xdata$x:00002400                 db    0
.xdata$x:00002401                 db    0
.xdata$x:00002402                 db    0
.xdata$x:00002403                 db    0
.xdata$x:00002404                 db    0
.xdata$x:00002405                 db    0
.xdata$x:00002406                 db    0
.xdata$x:00002407                 db    0
.xdata$x:00002408                 db    0
.xdata$x:00002409                 db    0
.xdata$x:0000240A                 db    0
.xdata$x:0000240B                 db    0
.xdata$x:0000240C                 db    0
.xdata$x:0000240D                 db    0
.xdata$x:0000240E                 db    0
.xdata$x:0000240F                 db    0
.xdata$x:0000240F _xdata$x        ends
.xdata$x:0000240F
.xdata$x:00002410 ; ===========================================================================
.xdata$x:00002410
.xdata$x:00002410 ; Segment type: Pure data
.xdata$x:00002410 ; Segment permissions: Read
.xdata$x:00002410 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002410                 assume cs:_xdata$x
.xdata$x:00002410                 ;org 2410h
.xdata$x:00002410 ; COMDAT (pick associative to section at 1110)
.xdata$x:00002410 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002410                                         ; DATA XREF: .xdata$x:00002420o
.xdata$x:00002411                 db 0FFh
.xdata$x:00002412                 db 0FFh
.xdata$x:00002413                 db 0FFh
.xdata$x:00002414                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002418 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002418                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002419                 db    5
.xdata$x:0000241A                 db  93h ; ô
.xdata$x:0000241B                 db  19h
.xdata$x:0000241C                 db    1
.xdata$x:0000241D                 db    0
.xdata$x:0000241E                 db    0
.xdata$x:0000241F                 db    0
.xdata$x:00002420                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002424                 db    0
.xdata$x:00002425                 db    0
.xdata$x:00002426                 db    0
.xdata$x:00002427                 db    0
.xdata$x:00002428                 db    0
.xdata$x:00002429                 db    0
.xdata$x:0000242A                 db    0
.xdata$x:0000242B                 db    0
.xdata$x:0000242C                 db    0
.xdata$x:0000242D                 db    0
.xdata$x:0000242E                 db    0
.xdata$x:0000242F                 db    0
.xdata$x:00002430                 db    0
.xdata$x:00002431                 db    0
.xdata$x:00002432                 db    0
.xdata$x:00002433                 db    0
.xdata$x:00002434                 db    0
.xdata$x:00002435                 db    0
.xdata$x:00002436                 db    0
.xdata$x:00002437                 db    0
.xdata$x:00002438                 db    0
.xdata$x:00002439                 db    0
.xdata$x:0000243A                 db    0
.xdata$x:0000243B                 db    0
.xdata$x:0000243B _xdata$x        ends
.xdata$x:0000243B
.xdata$x:0000243C ; ===========================================================================
.xdata$x:0000243C
.xdata$x:0000243C ; Segment type: Pure data
.xdata$x:0000243C ; Segment permissions: Read
.xdata$x:0000243C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000243C                 assume cs:_xdata$x
.xdata$x:0000243C                 ;org 243Ch
.xdata$x:0000243C ; COMDAT (pick associative to section at BD0)
.xdata$x:0000243C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:0000243C                                         ; DATA XREF: .xdata$x:0000244Co
.xdata$x:0000243D                 db 0FFh
.xdata$x:0000243E                 db 0FFh
.xdata$x:0000243F                 db 0FFh
.xdata$x:00002440                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00002444 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00002444                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00002445                 db    5
.xdata$x:00002446                 db  93h ; ô
.xdata$x:00002447                 db  19h
.xdata$x:00002448                 db    1
.xdata$x:00002449                 db    0
.xdata$x:0000244A                 db    0
.xdata$x:0000244B                 db    0
.xdata$x:0000244C                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00002450                 db    0
.xdata$x:00002451                 db    0
.xdata$x:00002452                 db    0
.xdata$x:00002453                 db    0
.xdata$x:00002454                 db    0
.xdata$x:00002455                 db    0
.xdata$x:00002456                 db    0
.xdata$x:00002457                 db    0
.xdata$x:00002458                 db    0
.xdata$x:00002459                 db    0
.xdata$x:0000245A                 db    0
.xdata$x:0000245B                 db    0
.xdata$x:0000245C                 db    0
.xdata$x:0000245D                 db    0
.xdata$x:0000245E                 db    0
.xdata$x:0000245F                 db    0
.xdata$x:00002460                 db    0
.xdata$x:00002461                 db    0
.xdata$x:00002462                 db    0
.xdata$x:00002463                 db    0
.xdata$x:00002464                 db    0
.xdata$x:00002465                 db    0
.xdata$x:00002466                 db    0
.xdata$x:00002467                 db    0
.xdata$x:00002467 _xdata$x        ends
.xdata$x:00002467
.xdata$x:00002468 ; ===========================================================================
.xdata$x:00002468
.xdata$x:00002468 ; Segment type: Pure data
.xdata$x:00002468 ; Segment permissions: Read
.xdata$x:00002468 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002468                 assume cs:_xdata$x
.xdata$x:00002468                 ;org 2468h
.xdata$x:00002468 ; COMDAT (pick associative to section at 1098)
.xdata$x:00002468 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002468                                         ; DATA XREF: .xdata$x:00002478o
.xdata$x:00002469                 db 0FFh
.xdata$x:0000246A                 db 0FFh
.xdata$x:0000246B                 db 0FFh
.xdata$x:0000246C                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00002470 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002470                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00002471                 db    5
.xdata$x:00002472                 db  93h ; ô
.xdata$x:00002473                 db  19h
.xdata$x:00002474                 db    1
.xdata$x:00002475                 db    0
.xdata$x:00002476                 db    0
.xdata$x:00002477                 db    0
.xdata$x:00002478                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:0000247C                 db    0
.xdata$x:0000247D                 db    0
.xdata$x:0000247E                 db    0
.xdata$x:0000247F                 db    0
.xdata$x:00002480                 db    0
.xdata$x:00002481                 db    0
.xdata$x:00002482                 db    0
.xdata$x:00002483                 db    0
.xdata$x:00002484                 db    0
.xdata$x:00002485                 db    0
.xdata$x:00002486                 db    0
.xdata$x:00002487                 db    0
.xdata$x:00002488                 db    0
.xdata$x:00002489                 db    0
.xdata$x:0000248A                 db    0
.xdata$x:0000248B                 db    0
.xdata$x:0000248C                 db    0
.xdata$x:0000248D                 db    0
.xdata$x:0000248E                 db    0
.xdata$x:0000248F                 db    0
.xdata$x:00002490                 db    0
.xdata$x:00002491                 db    0
.xdata$x:00002492                 db    0
.xdata$x:00002493                 db    0
.xdata$x:00002493 _xdata$x        ends
.xdata$x:00002493
.xdata$x:00002494 ; ===========================================================================
.xdata$x:00002494
.xdata$x:00002494 ; Segment type: Pure data
.xdata$x:00002494 ; Segment permissions: Read
.xdata$x:00002494 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002494                 assume cs:_xdata$x
.xdata$x:00002494                 ;org 2494h
.xdata$x:00002494 ; COMDAT (pick associative to section at D0C)
.xdata$x:00002494 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002494                                         ; DATA XREF: .xdata$x:000024A4o
.xdata$x:00002495                 db 0FFh
.xdata$x:00002496                 db 0FFh
.xdata$x:00002497                 db 0FFh
.xdata$x:00002498                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:0000249C __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000249C                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:0000249D                 db    5
.xdata$x:0000249E                 db  93h ; ô
.xdata$x:0000249F                 db  19h
.xdata$x:000024A0                 db    1
.xdata$x:000024A1                 db    0
.xdata$x:000024A2                 db    0
.xdata$x:000024A3                 db    0
.xdata$x:000024A4                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:000024A8                 align 20h
.xdata$x:000024A8 _xdata$x        ends
.xdata$x:000024A8
.xdata$x:000024C0 ; ===========================================================================
.xdata$x:000024C0
.xdata$x:000024C0 ; Segment type: Pure data
.xdata$x:000024C0 ; Segment permissions: Read
.xdata$x:000024C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000024C0                 assume cs:_xdata$x
.xdata$x:000024C0                 ;org 24C0h
.xdata$x:000024C0 ; COMDAT (pick associative to section at 1180)
.xdata$x:000024C0 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:000024C0                                         ; DATA XREF: .xdata$x:000024D0o
.xdata$x:000024C1                 db 0FFh
.xdata$x:000024C2                 db 0FFh
.xdata$x:000024C3                 db 0FFh
.xdata$x:000024C4                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:000024C8 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000024C8                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:000024C9                 db    5
.xdata$x:000024CA                 db  93h ; ô
.xdata$x:000024CB                 db  19h
.xdata$x:000024CC                 db    1
.xdata$x:000024CD                 db    0
.xdata$x:000024CE                 db    0
.xdata$x:000024CF                 db    0
.xdata$x:000024D0                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:000024D4                 db    0
.xdata$x:000024D5                 db    0
.xdata$x:000024D6                 db    0
.xdata$x:000024D7                 db    0
.xdata$x:000024D8                 db    0
.xdata$x:000024D9                 db    0
.xdata$x:000024DA                 db    0
.xdata$x:000024DB                 db    0
.xdata$x:000024DC                 db    0
.xdata$x:000024DD                 db    0
.xdata$x:000024DE                 db    0
.xdata$x:000024DF                 db    0
.xdata$x:000024E0                 db    0
.xdata$x:000024E1                 db    0
.xdata$x:000024E2                 db    0
.xdata$x:000024E3                 db    0
.xdata$x:000024E4                 db    0
.xdata$x:000024E5                 db    0
.xdata$x:000024E6                 db    0
.xdata$x:000024E7                 db    0
.xdata$x:000024E8                 db    0
.xdata$x:000024E9                 db    0
.xdata$x:000024EA                 db    0
.xdata$x:000024EB                 db    0
.xdata$x:000024EB _xdata$x        ends
.xdata$x:000024EB
.xdata$x:000024EC ; ===========================================================================
.xdata$x:000024EC
.xdata$x:000024EC ; Segment type: Pure data
.xdata$x:000024EC ; Segment permissions: Read
.xdata$x:000024EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000024EC                 assume cs:_xdata$x
.xdata$x:000024EC                 ;org 24ECh
.xdata$x:000024EC ; COMDAT (pick associative to section at 1644)
.xdata$x:000024EC __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:000024EC                                         ; DATA XREF: .xdata$x:00002574o
.xdata$x:000024ED                 db    0
.xdata$x:000024EE                 db    0
.xdata$x:000024EF                 db    0
.xdata$x:000024F0                 db    0
.xdata$x:000024F1                 db    0
.xdata$x:000024F2                 db    0
.xdata$x:000024F3                 db    0
.xdata$x:000024F4                 db    0
.xdata$x:000024F5                 db    0
.xdata$x:000024F6                 db    0
.xdata$x:000024F7                 db    0
.xdata$x:000024F8                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:000024FC __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:000024FC                                         ; DATA XREF: .xdata$x:00002560o
.xdata$x:000024FD                 db    0
.xdata$x:000024FE                 db    0
.xdata$x:000024FF                 db    0
.xdata$x:00002500                 db    0
.xdata$x:00002501                 db    0
.xdata$x:00002502                 db    0
.xdata$x:00002503                 db    0
.xdata$x:00002504                 db    0
.xdata$x:00002505                 db    0
.xdata$x:00002506                 db    0
.xdata$x:00002507                 db    0
.xdata$x:00002508                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:0000250C __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000250C                                         ; DATA XREF: .xdata$x:00002534o
.xdata$x:0000250D                 db 0FFh
.xdata$x:0000250E                 db 0FFh
.xdata$x:0000250F                 db 0FFh
.xdata$x:00002510                 db    0
.xdata$x:00002511                 db    0
.xdata$x:00002512                 db    0
.xdata$x:00002513                 db    0
.xdata$x:00002514                 db 0FFh
.xdata$x:00002515                 db 0FFh
.xdata$x:00002516                 db 0FFh
.xdata$x:00002517                 db 0FFh
.xdata$x:00002518                 db    0
.xdata$x:00002519                 db    0
.xdata$x:0000251A                 db    0
.xdata$x:0000251B                 db    0
.xdata$x:0000251C                 db    1
.xdata$x:0000251D                 db    0
.xdata$x:0000251E                 db    0
.xdata$x:0000251F                 db    0
.xdata$x:00002520                 db    0
.xdata$x:00002521                 db    0
.xdata$x:00002522                 db    0
.xdata$x:00002523                 db    0
.xdata$x:00002524                 db    1
.xdata$x:00002525                 db    0
.xdata$x:00002526                 db    0
.xdata$x:00002527                 db    0
.xdata$x:00002528                 db    0
.xdata$x:00002529                 db    0
.xdata$x:0000252A                 db    0
.xdata$x:0000252B                 db    0
.xdata$x:0000252C __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000252C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:0000252D                 db    5
.xdata$x:0000252E                 db  93h ; ô
.xdata$x:0000252F                 db  19h
.xdata$x:00002530                 db    4
.xdata$x:00002531                 db    0
.xdata$x:00002532                 db    0
.xdata$x:00002533                 db    0
.xdata$x:00002534                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002538                 db    2
.xdata$x:00002539                 db    0
.xdata$x:0000253A                 db    0
.xdata$x:0000253B                 db    0
.xdata$x:0000253C                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002540                 db    0
.xdata$x:00002541                 db    0
.xdata$x:00002542                 db    0
.xdata$x:00002543                 db    0
.xdata$x:00002544                 db    0
.xdata$x:00002545                 db    0
.xdata$x:00002546                 db    0
.xdata$x:00002547                 db    0
.xdata$x:00002548                 db    0
.xdata$x:00002549                 db    0
.xdata$x:0000254A                 db    0
.xdata$x:0000254B                 db    0
.xdata$x:0000254C                 db    0
.xdata$x:0000254D                 db    0
.xdata$x:0000254E                 db    0
.xdata$x:0000254F                 db    0
.xdata$x:00002550 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00002550                                         ; DATA XREF: .xdata$x:0000253Co
.xdata$x:00002551                 db    0
.xdata$x:00002552                 db    0
.xdata$x:00002553                 db    0
.xdata$x:00002554                 db    2
.xdata$x:00002555                 db    0
.xdata$x:00002556                 db    0
.xdata$x:00002557                 db    0
.xdata$x:00002558                 db    3
.xdata$x:00002559                 db    0
.xdata$x:0000255A                 db    0
.xdata$x:0000255B                 db    0
.xdata$x:0000255C                 db    1
.xdata$x:0000255D                 db    0
.xdata$x:0000255E                 db    0
.xdata$x:0000255F                 db    0
.xdata$x:00002560                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00002564                 db    0
.xdata$x:00002565                 db    0
.xdata$x:00002566                 db    0
.xdata$x:00002567                 db    0
.xdata$x:00002568                 db    0
.xdata$x:00002569                 db    0
.xdata$x:0000256A                 db    0
.xdata$x:0000256B                 db    0
.xdata$x:0000256C                 db    3
.xdata$x:0000256D                 db    0
.xdata$x:0000256E                 db    0
.xdata$x:0000256F                 db    0
.xdata$x:00002570                 db    1
.xdata$x:00002571                 db    0
.xdata$x:00002572                 db    0
.xdata$x:00002573                 db    0
.xdata$x:00002574                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00002574 _xdata$x        ends
.xdata$x:00002574
.xdata$x:00002578 ; ===========================================================================
.xdata$x:00002578
.xdata$x:00002578 ; Segment type: Pure data
.xdata$x:00002578 ; Segment permissions: Read
.xdata$x:00002578 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002578                 assume cs:_xdata$x
.xdata$x:00002578                 ;org 2578h
.xdata$x:00002578 ; COMDAT (pick associative to section at 1014)
.xdata$x:00002578 __unwindtable$??0runtime_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002578                                         ; DATA XREF: .xdata$x:00002588o
.xdata$x:00002579                 db 0FFh
.xdata$x:0000257A                 db 0FFh
.xdata$x:0000257B                 db 0FFh
.xdata$x:0000257C                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0
.xdata$x:00002580 __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00002580                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@PBD@Z+11o
.xdata$x:00002581                 db    5
.xdata$x:00002582                 db  93h ; ô
.xdata$x:00002583                 db  19h
.xdata$x:00002584                 db    1
.xdata$x:00002585                 db    0
.xdata$x:00002586                 db    0
.xdata$x:00002587                 db    0
.xdata$x:00002588                 dd offset __unwindtable$??0runtime_error@std@@QAE@PBD@Z
.xdata$x:0000258C                 db    0
.xdata$x:0000258D                 db    0
.xdata$x:0000258E                 db    0
.xdata$x:0000258F                 db    0
.xdata$x:00002590                 db    0
.xdata$x:00002591                 db    0
.xdata$x:00002592                 db    0
.xdata$x:00002593                 db    0
.xdata$x:00002594                 db    0
.xdata$x:00002595                 db    0
.xdata$x:00002596                 db    0
.xdata$x:00002597                 db    0
.xdata$x:00002598                 db    0
.xdata$x:00002599                 db    0
.xdata$x:0000259A                 db    0
.xdata$x:0000259B                 db    0
.xdata$x:0000259C                 db    0
.xdata$x:0000259D                 db    0
.xdata$x:0000259E                 db    0
.xdata$x:0000259F                 db    0
.xdata$x:000025A0                 db    0
.xdata$x:000025A1                 db    0
.xdata$x:000025A2                 db    0
.xdata$x:000025A3                 db    0
.xdata$x:000025A3 _xdata$x        ends
.xdata$x:000025A3
.xdata$x:000025A4 ; ===========================================================================
.xdata$x:000025A4
.xdata$x:000025A4 ; Segment type: Pure data
.xdata$x:000025A4 ; Segment permissions: Read
.xdata$x:000025A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000025A4                 assume cs:_xdata$x
.xdata$x:000025A4                 ;org 25A4h
.xdata$x:000025A4 ; COMDAT (pick associative to section at 1374)
.xdata$x:000025A4 __unwindtable$??1runtime_error@std@@UAE@XZ db 0FFh
.xdata$x:000025A4                                         ; DATA XREF: .xdata$x:000025B4o
.xdata$x:000025A5                 db 0FFh
.xdata$x:000025A6                 db 0FFh
.xdata$x:000025A7                 db 0FFh
.xdata$x:000025A8                 dd offset __unwindfunclet$??1runtime_error@std@@UAE@XZ$0
.xdata$x:000025AC __ehfuncinfo$??1runtime_error@std@@UAE@XZ db  22h ; "
.xdata$x:000025AC                                         ; DATA XREF: __ehhandler$??1runtime_error@std@@UAE@XZ+11o
.xdata$x:000025AD                 db    5
.xdata$x:000025AE                 db  93h ; ô
.xdata$x:000025AF                 db  19h
.xdata$x:000025B0                 db    1
.xdata$x:000025B1                 db    0
.xdata$x:000025B2                 db    0
.xdata$x:000025B3                 db    0
.xdata$x:000025B4                 dd offset __unwindtable$??1runtime_error@std@@UAE@XZ
.xdata$x:000025B8                 db    0
.xdata$x:000025B9                 db    0
.xdata$x:000025BA                 db    0
.xdata$x:000025BB                 db    0
.xdata$x:000025BC                 db    0
.xdata$x:000025BD                 db    0
.xdata$x:000025BE                 db    0
.xdata$x:000025BF                 db    0
.xdata$x:000025C0                 db    0
.xdata$x:000025C1                 db    0
.xdata$x:000025C2                 db    0
.xdata$x:000025C3                 db    0
.xdata$x:000025C4                 db    0
.xdata$x:000025C5                 db    0
.xdata$x:000025C6                 db    0
.xdata$x:000025C7                 db    0
.xdata$x:000025C8                 db    0
.xdata$x:000025C9                 db    0
.xdata$x:000025CA                 db    0
.xdata$x:000025CB                 db    0
.xdata$x:000025CC                 db    0
.xdata$x:000025CD                 db    0
.xdata$x:000025CE                 db    0
.xdata$x:000025CF                 db    0
.xdata$x:000025CF _xdata$x        ends
.xdata$x:000025CF
.xdata$x:000025D0 ; ===========================================================================
.xdata$x:000025D0
.xdata$x:000025D0 ; Segment type: Pure data
.xdata$x:000025D0 ; Segment permissions: Read
.xdata$x:000025D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000025D0                 assume cs:_xdata$x
.xdata$x:000025D0                 ;org 25D0h
.xdata$x:000025D0 ; COMDAT (pick associative to section at F90)
.xdata$x:000025D0 __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:000025D0                                         ; DATA XREF: .xdata$x:000025E0o
.xdata$x:000025D1                 db 0FFh
.xdata$x:000025D2                 db 0FFh
.xdata$x:000025D3                 db 0FFh
.xdata$x:000025D4                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
.xdata$x:000025D8 __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:000025D8                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z+11o
.xdata$x:000025D9                 db    5
.xdata$x:000025DA                 db  93h ; ô
.xdata$x:000025DB                 db  19h
.xdata$x:000025DC                 db    1
.xdata$x:000025DD                 db    0
.xdata$x:000025DE                 db    0
.xdata$x:000025DF                 db    0
.xdata$x:000025E0                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
.xdata$x:000025E4                 db    0
.xdata$x:000025E5                 db    0
.xdata$x:000025E6                 db    0
.xdata$x:000025E7                 db    0
.xdata$x:000025E8                 db    0
.xdata$x:000025E9                 db    0
.xdata$x:000025EA                 db    0
.xdata$x:000025EB                 db    0
.xdata$x:000025EC                 db    0
.xdata$x:000025ED                 db    0
.xdata$x:000025EE                 db    0
.xdata$x:000025EF                 db    0
.xdata$x:000025F0                 db    0
.xdata$x:000025F1                 db    0
.xdata$x:000025F2                 db    0
.xdata$x:000025F3                 db    0
.xdata$x:000025F4                 db    0
.xdata$x:000025F5                 db    0
.xdata$x:000025F6                 db    0
.xdata$x:000025F7                 db    0
.xdata$x:000025F8                 db    0
.xdata$x:000025F9                 db    0
.xdata$x:000025FA                 db    0
.xdata$x:000025FB                 db    0
.xdata$x:000025FB _xdata$x        ends
.xdata$x:000025FB
.xdata$x:000025FC ; ===========================================================================
.xdata$x:000025FC
.xdata$x:000025FC ; Segment type: Pure data
.xdata$x:000025FC ; Segment permissions: Read
.xdata$x:000025FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000025FC                 assume cs:_xdata$x
.xdata$x:000025FC                 ;org 25FCh
.xdata$x:000025FC ; COMDAT (pick associative to section at DE0)
.xdata$x:000025FC __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000025FC                                         ; DATA XREF: .xdata$x:0000260Co
.xdata$x:000025FD                 db 0FFh
.xdata$x:000025FE                 db 0FFh
.xdata$x:000025FF                 db 0FFh
.xdata$x:00002600                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00002604 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002604                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00002605                 db    5
.xdata$x:00002606                 db  93h ; ô
.xdata$x:00002607                 db  19h
.xdata$x:00002608                 db    1
.xdata$x:00002609                 db    0
.xdata$x:0000260A                 db    0
.xdata$x:0000260B                 db    0
.xdata$x:0000260C                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00002610                 db    0
.xdata$x:00002611                 db    0
.xdata$x:00002612                 db    0
.xdata$x:00002613                 db    0
.xdata$x:00002614                 db    0
.xdata$x:00002615                 db    0
.xdata$x:00002616                 db    0
.xdata$x:00002617                 db    0
.xdata$x:00002618                 db    0
.xdata$x:00002619                 db    0
.xdata$x:0000261A                 db    0
.xdata$x:0000261B                 db    0
.xdata$x:0000261C                 db    0
.xdata$x:0000261D                 db    0
.xdata$x:0000261E                 db    0
.xdata$x:0000261F                 db    0
.xdata$x:00002620                 db    0
.xdata$x:00002621                 db    0
.xdata$x:00002622                 db    0
.xdata$x:00002623                 db    0
.xdata$x:00002624                 db    0
.xdata$x:00002625                 db    0
.xdata$x:00002626                 db    0
.xdata$x:00002627                 db    0
.xdata$x:00002627 _xdata$x        ends
.xdata$x:00002627
.xdata$x:00002628 ; ===========================================================================
.xdata$x:00002628
.xdata$x:00002628 ; Segment type: Pure data
.xdata$x:00002628 ; Segment permissions: Read
.xdata$x:00002628 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002628                 assume cs:_xdata$x
.xdata$x:00002628                 ;org 2628h
.xdata$x:00002628 ; COMDAT (pick associative to section at 20BC)
.xdata$x:00002628 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002628                                         ; DATA XREF: .xdata$x:00002638o
.xdata$x:00002629                 db 0FFh
.xdata$x:0000262A                 db 0FFh
.xdata$x:0000262B                 db 0FFh
.xdata$x:0000262C                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002630 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002630                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002631                 db    5
.xdata$x:00002632                 db  93h ; ô
.xdata$x:00002633                 db  19h
.xdata$x:00002634                 db    1
.xdata$x:00002635                 db    0
.xdata$x:00002636                 db    0
.xdata$x:00002637                 db    0
.xdata$x:00002638                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000263C                 db    0
.xdata$x:0000263D                 db    0
.xdata$x:0000263E                 db    0
.xdata$x:0000263F                 db    0
.xdata$x:00002640                 db    0
.xdata$x:00002641                 db    0
.xdata$x:00002642                 db    0
.xdata$x:00002643                 db    0
.xdata$x:00002644                 db    0
.xdata$x:00002645                 db    0
.xdata$x:00002646                 db    0
.xdata$x:00002647                 db    0
.xdata$x:00002648                 db    0
.xdata$x:00002649                 db    0
.xdata$x:0000264A                 db    0
.xdata$x:0000264B                 db    0
.xdata$x:0000264C                 db    0
.xdata$x:0000264D                 db    0
.xdata$x:0000264E                 db    0
.xdata$x:0000264F                 db    0
.xdata$x:00002650                 db    0
.xdata$x:00002651                 db    0
.xdata$x:00002652                 db    0
.xdata$x:00002653                 db    0
.xdata$x:00002653 _xdata$x        ends
.xdata$x:00002653
.xdata$x:00002654 ; ===========================================================================
.xdata$x:00002654
.xdata$x:00002654 ; Segment type: Pure data
.xdata$x:00002654 ; Segment permissions: Read
.xdata$x:00002654 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002654                 assume cs:_xdata$x
.xdata$x:00002654                 ;org 2654h
.xdata$x:00002654 ; COMDAT (pick associative to section at 1210)
.xdata$x:00002654 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002654                                         ; DATA XREF: .xdata$x:00002664o
.xdata$x:00002655                 db 0FFh
.xdata$x:00002656                 db 0FFh
.xdata$x:00002657                 db 0FFh
.xdata$x:00002658                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:0000265C __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000265C                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:0000265D                 db    5
.xdata$x:0000265E                 db  93h ; ô
.xdata$x:0000265F                 db  19h
.xdata$x:00002660                 db    1
.xdata$x:00002661                 db    0
.xdata$x:00002662                 db    0
.xdata$x:00002663                 db    0
.xdata$x:00002664                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00002668                 align 20h
.xdata$x:00002668 _xdata$x        ends
.xdata$x:00002668
.xdata$x:00002680 ; ===========================================================================
.xdata$x:00002680
.xdata$x:00002680 ; Segment type: Pure data
.xdata$x:00002680 ; Segment permissions: Read
.xdata$x:00002680 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002680                 assume cs:_xdata$x
.xdata$x:00002680                 ;org 2680h
.xdata$x:00002680 ; COMDAT (pick associative to section at E5C)
.xdata$x:00002680 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002680                                         ; DATA XREF: .xdata$x:00002690o
.xdata$x:00002681                 db 0FFh
.xdata$x:00002682                 db 0FFh
.xdata$x:00002683                 db 0FFh
.xdata$x:00002684                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002688 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002688                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002689                 db    5
.xdata$x:0000268A                 db  93h ; ô
.xdata$x:0000268B                 db  19h
.xdata$x:0000268C                 db    1
.xdata$x:0000268D                 db    0
.xdata$x:0000268E                 db    0
.xdata$x:0000268F                 db    0
.xdata$x:00002690                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00002694                 db    0
.xdata$x:00002695                 db    0
.xdata$x:00002696                 db    0
.xdata$x:00002697                 db    0
.xdata$x:00002698                 db    0
.xdata$x:00002699                 db    0
.xdata$x:0000269A                 db    0
.xdata$x:0000269B                 db    0
.xdata$x:0000269C                 db    0
.xdata$x:0000269D                 db    0
.xdata$x:0000269E                 db    0
.xdata$x:0000269F                 db    0
.xdata$x:000026A0                 db    0
.xdata$x:000026A1                 db    0
.xdata$x:000026A2                 db    0
.xdata$x:000026A3                 db    0
.xdata$x:000026A4                 db    0
.xdata$x:000026A5                 db    0
.xdata$x:000026A6                 db    0
.xdata$x:000026A7                 db    0
.xdata$x:000026A8                 db    0
.xdata$x:000026A9                 db    0
.xdata$x:000026AA                 db    0
.xdata$x:000026AB                 db    0
.xdata$x:000026AB _xdata$x        ends
.xdata$x:000026AB
.xdata$x:000026AC ; ===========================================================================
.xdata$x:000026AC
.xdata$x:000026AC ; Segment type: Pure data
.xdata$x:000026AC ; Segment permissions: Read
.xdata$x:000026AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000026AC                 assume cs:_xdata$x
.xdata$x:000026AC                 ;org 26ACh
.xdata$x:000026AC ; COMDAT (pick associative to section at 2174)
.xdata$x:000026AC __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000026AC                                         ; DATA XREF: .xdata$x:000026BCo
.xdata$x:000026AD                 db 0FFh
.xdata$x:000026AE                 db 0FFh
.xdata$x:000026AF                 db 0FFh
.xdata$x:000026B0                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000026B4 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000026B4                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000026B5                 db    5
.xdata$x:000026B6                 db  93h ; ô
.xdata$x:000026B7                 db  19h
.xdata$x:000026B8                 db    1
.xdata$x:000026B9                 db    0
.xdata$x:000026BA                 db    0
.xdata$x:000026BB                 db    0
.xdata$x:000026BC                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000026C0                 db    0
.xdata$x:000026C1                 db    0
.xdata$x:000026C2                 db    0
.xdata$x:000026C3                 db    0
.xdata$x:000026C4                 db    0
.xdata$x:000026C5                 db    0
.xdata$x:000026C6                 db    0
.xdata$x:000026C7                 db    0
.xdata$x:000026C8                 db    0
.xdata$x:000026C9                 db    0
.xdata$x:000026CA                 db    0
.xdata$x:000026CB                 db    0
.xdata$x:000026CC                 db    0
.xdata$x:000026CD                 db    0
.xdata$x:000026CE                 db    0
.xdata$x:000026CF                 db    0
.xdata$x:000026D0                 db    0
.xdata$x:000026D1                 db    0
.xdata$x:000026D2                 db    0
.xdata$x:000026D3                 db    0
.xdata$x:000026D4                 db    0
.xdata$x:000026D5                 db    0
.xdata$x:000026D6                 db    0
.xdata$x:000026D7                 db    0
.xdata$x:000026D7 _xdata$x        ends
.xdata$x:000026D7
.xdata$x:000026D8 ; ===========================================================================
.xdata$x:000026D8
.xdata$x:000026D8 ; Segment type: Pure data
.xdata$x:000026D8 ; Segment permissions: Read
.xdata$x:000026D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000026D8                 assume cs:_xdata$x
.xdata$x:000026D8                 ;org 26D8h
.xdata$x:000026D8 ; COMDAT (pick associative to section at 1280)
.xdata$x:000026D8 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000026D8                                         ; DATA XREF: .xdata$x:000026E8o
.xdata$x:000026D9                 db 0FFh
.xdata$x:000026DA                 db 0FFh
.xdata$x:000026DB                 db 0FFh
.xdata$x:000026DC                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:000026E0 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000026E0                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:000026E1                 db    5
.xdata$x:000026E2                 db  93h ; ô
.xdata$x:000026E3                 db  19h
.xdata$x:000026E4                 db    1
.xdata$x:000026E5                 db    0
.xdata$x:000026E6                 db    0
.xdata$x:000026E7                 db    0
.xdata$x:000026E8                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:000026EC                 db    0
.xdata$x:000026ED                 db    0
.xdata$x:000026EE                 db    0
.xdata$x:000026EF                 db    0
.xdata$x:000026F0                 db    0
.xdata$x:000026F1                 db    0
.xdata$x:000026F2                 db    0
.xdata$x:000026F3                 db    0
.xdata$x:000026F4                 db    0
.xdata$x:000026F5                 db    0
.xdata$x:000026F6                 db    0
.xdata$x:000026F7                 db    0
.xdata$x:000026F8                 db    0
.xdata$x:000026F9                 db    0
.xdata$x:000026FA                 db    0
.xdata$x:000026FB                 db    0
.xdata$x:000026FC                 db    0
.xdata$x:000026FD                 db    0
.xdata$x:000026FE                 db    0
.xdata$x:000026FF                 db    0
.xdata$x:00002700                 db    0
.xdata$x:00002701                 db    0
.xdata$x:00002702                 db    0
.xdata$x:00002703                 db    0
.xdata$x:00002703 _xdata$x        ends
.xdata$x:00002703
.xdata$x:00002704 ; ===========================================================================
.xdata$x:00002704
.xdata$x:00002704 ; Segment type: Pure data
.xdata$x:00002704 ; Segment permissions: Read
.xdata$x:00002704 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002704                 assume cs:_xdata$x
.xdata$x:00002704                 ;org 2704h
.xdata$x:00002704 ; COMDAT (pick associative to section at ED8)
.xdata$x:00002704 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002704                                         ; DATA XREF: .xdata$x:00002714o
.xdata$x:00002705                 db 0FFh
.xdata$x:00002706                 db 0FFh
.xdata$x:00002707                 db 0FFh
.xdata$x:00002708                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:0000270C __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000270C                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:0000270D                 db    5
.xdata$x:0000270E                 db  93h ; ô
.xdata$x:0000270F                 db  19h
.xdata$x:00002710                 db    1
.xdata$x:00002711                 db    0
.xdata$x:00002712                 db    0
.xdata$x:00002713                 db    0
.xdata$x:00002714                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00002718                 db    0
.xdata$x:00002719                 db    0
.xdata$x:0000271A                 db    0
.xdata$x:0000271B                 db    0
.xdata$x:0000271C                 db    0
.xdata$x:0000271D                 db    0
.xdata$x:0000271E                 db    0
.xdata$x:0000271F                 db    0
.xdata$x:00002720                 db    0
.xdata$x:00002721                 db    0
.xdata$x:00002722                 db    0
.xdata$x:00002723                 db    0
.xdata$x:00002724                 db    0
.xdata$x:00002725                 db    0
.xdata$x:00002726                 db    0
.xdata$x:00002727                 db    0
.xdata$x:00002728                 db    0
.xdata$x:00002729                 db    0
.xdata$x:0000272A                 db    0
.xdata$x:0000272B                 db    0
.xdata$x:0000272C                 db    0
.xdata$x:0000272D                 db    0
.xdata$x:0000272E                 db    0
.xdata$x:0000272F                 db    0
.xdata$x:0000272F _xdata$x        ends
.xdata$x:0000272F
.xdata$x:00002730 ; ===========================================================================
.xdata$x:00002730
.xdata$x:00002730 ; Segment type: Pure data
.xdata$x:00002730 ; Segment permissions: Read
.xdata$x:00002730 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002730                 assume cs:_xdata$x
.xdata$x:00002730                 ;org 2730h
.xdata$x:00002730 ; COMDAT (pick associative to section at 2238)
.xdata$x:00002730 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002730                                         ; DATA XREF: .xdata$x:00002740o
.xdata$x:00002731                 db 0FFh
.xdata$x:00002732                 db 0FFh
.xdata$x:00002733                 db 0FFh
.xdata$x:00002734                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002738 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002738                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002739                 db    5
.xdata$x:0000273A                 db  93h ; ô
.xdata$x:0000273B                 db  19h
.xdata$x:0000273C                 db    1
.xdata$x:0000273D                 db    0
.xdata$x:0000273E                 db    0
.xdata$x:0000273F                 db    0
.xdata$x:00002740                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002744                 db    0
.xdata$x:00002745                 db    0
.xdata$x:00002746                 db    0
.xdata$x:00002747                 db    0
.xdata$x:00002748                 db    0
.xdata$x:00002749                 db    0
.xdata$x:0000274A                 db    0
.xdata$x:0000274B                 db    0
.xdata$x:0000274C                 db    0
.xdata$x:0000274D                 db    0
.xdata$x:0000274E                 db    0
.xdata$x:0000274F                 db    0
.xdata$x:00002750                 db    0
.xdata$x:00002751                 db    0
.xdata$x:00002752                 db    0
.xdata$x:00002753                 db    0
.xdata$x:00002754                 db    0
.xdata$x:00002755                 db    0
.xdata$x:00002756                 db    0
.xdata$x:00002757                 db    0
.xdata$x:00002758                 db    0
.xdata$x:00002759                 db    0
.xdata$x:0000275A                 db    0
.xdata$x:0000275B                 db    0
.xdata$x:0000275B _xdata$x        ends
.xdata$x:0000275B
.xdata$x:0000275C ; ===========================================================================
.xdata$x:0000275C
.xdata$x:0000275C ; Segment type: Pure data
.xdata$x:0000275C ; Segment permissions: Read
.xdata$x:0000275C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000275C                 assume cs:_xdata$x
.xdata$x:0000275C                 ;org 275Ch
.xdata$x:0000275C ; COMDAT (pick associative to section at 12F0)
.xdata$x:0000275C __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000275C                                         ; DATA XREF: .xdata$x:0000276Co
.xdata$x:0000275D                 db 0FFh
.xdata$x:0000275E                 db 0FFh
.xdata$x:0000275F                 db 0FFh
.xdata$x:00002760                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00002764 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002764                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00002765                 db    5
.xdata$x:00002766                 db  93h ; ô
.xdata$x:00002767                 db  19h
.xdata$x:00002768                 db    1
.xdata$x:00002769                 db    0
.xdata$x:0000276A                 db    0
.xdata$x:0000276B                 db    0
.xdata$x:0000276C                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00002770                 db    0
.xdata$x:00002771                 db    0
.xdata$x:00002772                 db    0
.xdata$x:00002773                 db    0
.xdata$x:00002774                 db    0
.xdata$x:00002775                 db    0
.xdata$x:00002776                 db    0
.xdata$x:00002777                 db    0
.xdata$x:00002778                 db    0
.xdata$x:00002779                 db    0
.xdata$x:0000277A                 db    0
.xdata$x:0000277B                 db    0
.xdata$x:0000277C                 db    0
.xdata$x:0000277D                 db    0
.xdata$x:0000277E                 db    0
.xdata$x:0000277F                 db    0
.xdata$x:00002780                 db    0
.xdata$x:00002781                 db    0
.xdata$x:00002782                 db    0
.xdata$x:00002783                 db    0
.xdata$x:00002784                 db    0
.xdata$x:00002785                 db    0
.xdata$x:00002786                 db    0
.xdata$x:00002787                 db    0
.xdata$x:00002787 _xdata$x        ends
.xdata$x:00002787
.xdata$x:00002788 ; ===========================================================================
.xdata$x:00002788
.xdata$x:00002788 ; Segment type: Pure data
.xdata$x:00002788 ; Segment permissions: Read
.xdata$x:00002788 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002788                 assume cs:_xdata$x
.xdata$x:00002788                 ;org 2788h
.xdata$x:00002788 ; COMDAT (pick associative to section at AB4)
.xdata$x:00002788 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002788                                         ; DATA XREF: .xdata$x:00002798o
.xdata$x:00002789                 db 0FFh
.xdata$x:0000278A                 db 0FFh
.xdata$x:0000278B                 db 0FFh
.xdata$x:0000278C                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00002790 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00002790                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00002791                 db    5
.xdata$x:00002792                 db  93h ; ô
.xdata$x:00002793                 db  19h
.xdata$x:00002794                 db    1
.xdata$x:00002795                 db    0
.xdata$x:00002796                 db    0
.xdata$x:00002797                 db    0
.xdata$x:00002798                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:0000279C                 db    0
.xdata$x:0000279D                 db    0
.xdata$x:0000279E                 db    0
.xdata$x:0000279F                 db    0
.xdata$x:000027A0                 db    0
.xdata$x:000027A1                 db    0
.xdata$x:000027A2                 db    0
.xdata$x:000027A3                 db    0
.xdata$x:000027A4                 db    0
.xdata$x:000027A5                 db    0
.xdata$x:000027A6                 db    0
.xdata$x:000027A7                 db    0
.xdata$x:000027A8                 db    0
.xdata$x:000027A9                 db    0
.xdata$x:000027AA                 db    0
.xdata$x:000027AB                 db    0
.xdata$x:000027AC                 db    0
.xdata$x:000027AD                 db    0
.xdata$x:000027AE                 db    0
.xdata$x:000027AF                 db    0
.xdata$x:000027B0                 db    0
.xdata$x:000027B1                 db    0
.xdata$x:000027B2                 db    0
.xdata$x:000027B3                 db    0
.xdata$x:000027B3 _xdata$x        ends
.xdata$x:000027B3
.xdata$x:000027B4 ; ===========================================================================
.xdata$x:000027B4
.xdata$x:000027B4 ; Segment type: Pure data
.xdata$x:000027B4 ; Segment permissions: Read
.xdata$x:000027B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000027B4                 assume cs:_xdata$x
.xdata$x:000027B4                 ;org 27B4h
.xdata$x:000027B4 ; COMDAT (pick associative to section at 9E0)
.xdata$x:000027B4 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:000027B4                                         ; DATA XREF: .xdata$x:000027C4o
.xdata$x:000027B5                 db 0FFh
.xdata$x:000027B6                 db 0FFh
.xdata$x:000027B7                 db 0FFh
.xdata$x:000027B8                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:000027BC __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:000027BC                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:000027BD                 db    5
.xdata$x:000027BE                 db  93h ; ô
.xdata$x:000027BF                 db  19h
.xdata$x:000027C0                 db    1
.xdata$x:000027C1                 db    0
.xdata$x:000027C2                 db    0
.xdata$x:000027C3                 db    0
.xdata$x:000027C4                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:000027C8                 align 20h
.xdata$x:000027C8 _xdata$x        ends
.xdata$x:000027C8
.rdata:000027E0 ; ===========================================================================
.rdata:000027E0
.rdata:000027E0 ; Segment type: Pure data
.rdata:000027E0 ; Segment permissions: Read
.rdata:000027E0 _rdata          segment dword public 'DATA' use32
.rdata:000027E0                 assume cs:_rdata
.rdata:000027E0                 ;org 27E0h
.rdata:000027E0 ; COMDAT (pick largest)
.rdata:000027E0                 dd offset ??_R4runtime_error@std@@6B@ ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata:000027E4                 public ??_7runtime_error@std@@6B@
.rdata:000027E4 ; const std::runtime_error::`vftable'
.rdata:000027E4 ??_7runtime_error@std@@6B@ dd offset ??_Eruntime_error@std@@UAEPAXI@Z
.rdata:000027E4                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+3Co
.rdata:000027E4                                         ; std::runtime_error::runtime_error(char const *)+3Co
.rdata:000027E4                                         ; std::runtime_error::`vector deleting destructor'(uint)
.rdata:000027E8                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:000027E8 _rdata          ends
.rdata:000027E8
.xdata$x:000027EC ; ===========================================================================
.xdata$x:000027EC
.xdata$x:000027EC ; Segment type: Pure data
.xdata$x:000027EC ; Segment permissions: Read
.xdata$x:000027EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000027EC                 assume cs:_xdata$x
.xdata$x:000027EC                 ;org 27ECh
.xdata$x:000027EC ; COMDAT (pick any)
.xdata$x:000027EC                 public __TI2?AVruntime_error@std@@
.xdata$x:000027EC __TI2?AVruntime_error@std@@ db    0     ; DATA XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+11Ao
.xdata$x:000027EC                                         ; SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+18Ao
.xdata$x:000027ED                 db    0
.xdata$x:000027EE                 db    0
.xdata$x:000027EF                 db    0
.xdata$x:000027F0                 dd offset ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.xdata$x:000027F4                 align 8
.xdata$x:000027F8                 dd offset __CTA2?AVruntime_error@std@@
.xdata$x:000027F8 _xdata$x        ends
.xdata$x:000027F8
.xdata$x:000027FC ; ===========================================================================
.xdata$x:000027FC
.xdata$x:000027FC ; Segment type: Pure data
.xdata$x:000027FC ; Segment permissions: Read
.xdata$x:000027FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000027FC                 assume cs:_xdata$x
.xdata$x:000027FC                 ;org 27FCh
.xdata$x:000027FC ; COMDAT (pick any)
.xdata$x:000027FC                 public __CTA2?AVruntime_error@std@@
.xdata$x:000027FC __CTA2?AVruntime_error@std@@ db    2    ; DATA XREF: .xdata$x:000027F8o
.xdata$x:000027FD                 db    0
.xdata$x:000027FE                 db    0
.xdata$x:000027FF                 db    0
.xdata$x:00002800                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00002804                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00002804 _xdata$x        ends
.xdata$x:00002804
.data$r:00002808 ; ===========================================================================
.data$r:00002808
.data$r:00002808 ; Segment type: Pure data
.data$r:00002808 ; Segment permissions: Read/Write
.data$r:00002808 _data$r         segment dword public 'DATA' use32
.data$r:00002808                 assume cs:_data$r
.data$r:00002808                 ;org 2808h
.data$r:00002808 ; COMDAT (pick any)
.data$r:00002808                 public ??_R0?AVruntime_error@std@@@8
.data$r:00002808 ; class std::runtime_error `RTTI Type Descriptor'
.data$r:00002808 ??_R0?AVruntime_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002808                                         ; DATA XREF: .xdata$x:0000282Co
.data$r:00002808                                         ; .rdata$r:00002A60o ...
.data$r:00002808                                         ; const type_info::`vftable'
.data$r:0000280C                 align 10h
.data$r:00002810 a_?avruntime_er db '.?AVruntime_error@std@@',0
.data$r:00002810 _data$r         ends
.data$r:00002810
.xdata$x:00002828 ; ===========================================================================
.xdata$x:00002828
.xdata$x:00002828 ; Segment type: Pure data
.xdata$x:00002828 ; Segment permissions: Read
.xdata$x:00002828 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002828                 assume cs:_xdata$x
.xdata$x:00002828                 ;org 2828h
.xdata$x:00002828 ; COMDAT (pick any)
.xdata$x:00002828                 public __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00002828 __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00002828                                         ; DATA XREF: .xdata$x:00002800o
.xdata$x:00002829                 db    0
.xdata$x:0000282A                 db    0
.xdata$x:0000282B                 db    0
.xdata$x:0000282C                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.xdata$x:00002830                 db    0
.xdata$x:00002831                 db    0
.xdata$x:00002832                 db    0
.xdata$x:00002833                 db    0
.xdata$x:00002834                 db 0FFh
.xdata$x:00002835                 db 0FFh
.xdata$x:00002836                 db 0FFh
.xdata$x:00002837                 db 0FFh
.xdata$x:00002838                 db    0
.xdata$x:00002839                 db    0
.xdata$x:0000283A                 db    0
.xdata$x:0000283B                 db    0
.xdata$x:0000283C                 db  0Ch
.xdata$x:0000283D                 db    0
.xdata$x:0000283E                 db    0
.xdata$x:0000283F                 db    0
.xdata$x:00002840                 dd offset ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.xdata$x:00002840 _xdata$x        ends
.xdata$x:00002840
.data$r:00002844 ; ===========================================================================
.data$r:00002844
.data$r:00002844 ; Segment type: Pure data
.data$r:00002844 ; Segment permissions: Read/Write
.data$r:00002844 _data$r         segment dword public 'DATA' use32
.data$r:00002844                 assume cs:_data$r
.data$r:00002844                 ;org 2844h
.data$r:00002844 ; COMDAT (pick any)
.data$r:00002844                 public ??_R0?AVexception@std@@@8
.data$r:00002844 ; class std::exception `RTTI Type Descriptor'
.data$r:00002844 ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002844                                         ; DATA XREF: .xdata$x:00002864o
.data$r:00002844                                         ; .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002844                                         ; const type_info::`vftable'
.data$r:00002848                 db    0
.data$r:00002849                 db    0
.data$r:0000284A                 db    0
.data$r:0000284B                 db    0
.data$r:0000284C                 db  2Eh ; .
.data$r:0000284D                 db  3Fh ; ?
.data$r:0000284E                 db  41h ; A
.data$r:0000284F                 db  56h ; V
.data$r:00002850                 db  65h ; e
.data$r:00002851                 db  78h ; x
.data$r:00002852                 db  63h ; c
.data$r:00002853                 db  65h ; e
.data$r:00002854                 db  70h ; p
.data$r:00002855                 db  74h ; t
.data$r:00002856                 db  69h ; i
.data$r:00002857                 db  6Fh ; o
.data$r:00002858                 db  6Eh ; n
.data$r:00002859                 db  40h ; @
.data$r:0000285A                 db  73h ; s
.data$r:0000285B                 db  74h ; t
.data$r:0000285C                 db  64h ; d
.data$r:0000285D                 db  40h ; @
.data$r:0000285E                 db  40h ; @
.data$r:0000285F                 db    0
.data$r:0000285F _data$r         ends
.data$r:0000285F
.xdata$x:00002860 ; ===========================================================================
.xdata$x:00002860
.xdata$x:00002860 ; Segment type: Pure data
.xdata$x:00002860 ; Segment permissions: Read
.xdata$x:00002860 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002860                 assume cs:_xdata$x
.xdata$x:00002860                 ;org 2860h
.xdata$x:00002860 ; COMDAT (pick any)
.xdata$x:00002860                 public __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00002860 __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00002860                                         ; DATA XREF: .xdata$x:00002804o
.xdata$x:00002861                 db    0
.xdata$x:00002862                 db    0
.xdata$x:00002863                 db    0
.xdata$x:00002864                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:00002868                 db    0
.xdata$x:00002869                 db    0
.xdata$x:0000286A                 db    0
.xdata$x:0000286B                 db    0
.xdata$x:0000286C                 db 0FFh
.xdata$x:0000286D                 db 0FFh
.xdata$x:0000286E                 db 0FFh
.xdata$x:0000286F                 db 0FFh
.xdata$x:00002870                 db    0
.xdata$x:00002871                 db    0
.xdata$x:00002872                 db    0
.xdata$x:00002873                 db    0
.xdata$x:00002874                 db  0Ch
.xdata$x:00002875                 db    0
.xdata$x:00002876                 db    0
.xdata$x:00002877                 db    0
.xdata$x:00002878                 dd offset ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.xdata$x:00002878 _xdata$x        ends
.xdata$x:00002878
.rdata:0000287C ; ===========================================================================
.rdata:0000287C
.rdata:0000287C ; Segment type: Pure data
.rdata:0000287C ; Segment permissions: Read
.rdata:0000287C _rdata          segment dword public 'DATA' use32
.rdata:0000287C                 assume cs:_rdata
.rdata:0000287C                 ;org 287Ch
.rdata:0000287C ; COMDAT (pick largest)
.rdata:0000287C                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00002880                 public ??_7error_category@std@@6B@
.rdata:00002880 ; const std::error_category::`vftable'
.rdata:00002880 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00002880                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00002880                                         ; std::error_category::~error_category(void)+Ao
.rdata:00002880                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00002884                 dd offset __purecall
.rdata:00002888                 dd offset __purecall
.rdata:0000288C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002890                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002894                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002894 _rdata          ends
.rdata:00002894
.rdata:00002898 ; ===========================================================================
.rdata:00002898
.rdata:00002898 ; Segment type: Pure data
.rdata:00002898 ; Segment permissions: Read
.rdata:00002898 _rdata          segment dword public 'DATA' use32
.rdata:00002898                 assume cs:_rdata
.rdata:00002898                 ;org 2898h
.rdata:00002898 ; COMDAT (pick largest)
.rdata:00002898                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000289C                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000289C ; const std::_Generic_error_category::`vftable'
.rdata:0000289C ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000289C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000289C                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:000028A0                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:000028A4                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:000028A8                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000028AC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000028B0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000028B0 _rdata          ends
.rdata:000028B0
.rdata:000028B4 ; ===========================================================================
.rdata:000028B4
.rdata:000028B4 ; Segment type: Pure data
.rdata:000028B4 ; Segment permissions: Read
.rdata:000028B4 _rdata          segment dword public 'DATA' use32
.rdata:000028B4                 assume cs:_rdata
.rdata:000028B4                 ;org 28B4h
.rdata:000028B4 ; COMDAT (pick any)
.rdata:000028B4                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:000028B4 ; `string'
.rdata:000028B4 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:000028B4                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:000028B4 _rdata          ends
.rdata:000028B4
.rdata:000028BC ; ===========================================================================
.rdata:000028BC
.rdata:000028BC ; Segment type: Pure data
.rdata:000028BC ; Segment permissions: Read
.rdata:000028BC _rdata          segment dword public 'DATA' use32
.rdata:000028BC                 assume cs:_rdata
.rdata:000028BC                 ;org 28BCh
.rdata:000028BC ; COMDAT (pick any)
.rdata:000028BC                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:000028BC ; `string'
.rdata:000028BC ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:000028BC                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_2108o
.rdata:000028BC                                         ; std::_System_error_category::message(int):loc_2284o
.rdata:000028CA                 align 4
.rdata:000028CA _rdata          ends
.rdata:000028CA
.rdata:000028CC ; ===========================================================================
.rdata:000028CC
.rdata:000028CC ; Segment type: Pure data
.rdata:000028CC ; Segment permissions: Read
.rdata:000028CC _rdata          segment dword public 'DATA' use32
.rdata:000028CC                 assume cs:_rdata
.rdata:000028CC                 ;org 28CCh
.rdata:000028CC ; COMDAT (pick largest)
.rdata:000028CC                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:000028D0                 public ??_7_Iostream_error_category@std@@6B@
.rdata:000028D0 ; const std::_Iostream_error_category::`vftable'
.rdata:000028D0 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:000028D0                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:000028D0                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:000028D4                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:000028D8                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:000028DC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000028E0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000028E4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000028E4 _rdata          ends
.rdata:000028E4
.rdata:000028E8 ; ===========================================================================
.rdata:000028E8
.rdata:000028E8 ; Segment type: Pure data
.rdata:000028E8 ; Segment permissions: Read
.rdata:000028E8 _rdata          segment dword public 'DATA' use32
.rdata:000028E8                 assume cs:_rdata
.rdata:000028E8                 ;org 28E8h
.rdata:000028E8 ; COMDAT (pick any)
.rdata:000028E8                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:000028E8 ; `string'
.rdata:000028E8 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:000028E8                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:000028F1                 align 4
.rdata:000028F1 _rdata          ends
.rdata:000028F1
.rdata:000028F4 ; ===========================================================================
.rdata:000028F4
.rdata:000028F4 ; Segment type: Pure data
.rdata:000028F4 ; Segment permissions: Read
.rdata:000028F4 _rdata          segment dword public 'DATA' use32
.rdata:000028F4                 assume cs:_rdata
.rdata:000028F4                 ;org 28F4h
.rdata:000028F4 ; COMDAT (pick any)
.rdata:000028F4                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:000028F4 ; char `string'[]
.rdata:000028F4 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:000028F4                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000290A                 align 4
.rdata:0000290A _rdata          ends
.rdata:0000290A
.rdata:0000290C ; ===========================================================================
.rdata:0000290C
.rdata:0000290C ; Segment type: Pure data
.rdata:0000290C ; Segment permissions: Read
.rdata:0000290C _rdata          segment dword public 'DATA' use32
.rdata:0000290C                 assume cs:_rdata
.rdata:0000290C                 ;org 290Ch
.rdata:0000290C ; COMDAT (pick largest)
.rdata:0000290C                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00002910                 public ??_7_System_error_category@std@@6B@
.rdata:00002910 ; const std::_System_error_category::`vftable'
.rdata:00002910 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00002910                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00002910                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00002914                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00002918                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:0000291C                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00002920                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002924                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002924 _rdata          ends
.rdata:00002924
.rdata:00002928 ; ===========================================================================
.rdata:00002928
.rdata:00002928 ; Segment type: Pure data
.rdata:00002928 ; Segment permissions: Read
.rdata:00002928 _rdata          segment dword public 'DATA' use32
.rdata:00002928                 assume cs:_rdata
.rdata:00002928                 ;org 2928h
.rdata:00002928 ; COMDAT (pick any)
.rdata:00002928                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00002928 ; `string'
.rdata:00002928 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00002928                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000292F                 align 10h
.rdata:0000292F _rdata          ends
.rdata:0000292F
.bss:00002930 ; ===========================================================================
.bss:00002930
.bss:00002930 ; Segment type: Uninitialized
.bss:00002930 ; Segment permissions: Read/Write
.bss:00002930 _bss            segment dword public 'BSS' use32
.bss:00002930                 assume cs:_bss
.bss:00002930                 ;org 2930h
.bss:00002930 ; COMDAT (pick any)
.bss:00002930                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002930                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00002930 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00002930 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00002930                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00002930                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00002931                 db    ? ;
.bss:00002932                 db    ? ;
.bss:00002933                 db    ? ;
.bss:00002933 _bss            ends
.bss:00002933
.bss:00002934 ; ===========================================================================
.bss:00002934
.bss:00002934 ; Segment type: Uninitialized
.bss:00002934 ; Segment permissions: Read/Write
.bss:00002934 _bss            segment dword public 'BSS' use32
.bss:00002934                 assume cs:_bss
.bss:00002934                 ;org 2934h
.bss:00002934 ; COMDAT (pick any)
.bss:00002934                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002934                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00002934 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00002934 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00002934                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002934                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002935                 db    ? ;
.bss:00002936                 db    ? ;
.bss:00002937                 db    ? ;
.bss:00002937 _bss            ends
.bss:00002937
.bss:00002938 ; ===========================================================================
.bss:00002938
.bss:00002938 ; Segment type: Uninitialized
.bss:00002938 ; Segment permissions: Read/Write
.bss:00002938 _bss            segment dword public 'BSS' use32
.bss:00002938                 assume cs:_bss
.bss:00002938                 ;org 2938h
.bss:00002938 ; COMDAT (pick any)
.bss:00002938                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002938                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00002938 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00002938 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00002938                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00002938                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00002939                 db    ? ;
.bss:0000293A                 db    ? ;
.bss:0000293B                 db    ? ;
.bss:0000293B _bss            ends
.bss:0000293B
.rdata:0000293C ; ===========================================================================
.rdata:0000293C
.rdata:0000293C ; Segment type: Pure data
.rdata:0000293C ; Segment permissions: Read
.rdata:0000293C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000293C _rdata          segment para public 'DATA' use32
.rdata:0000293C                 assume cs:_rdata
.rdata:0000293C                 ;org 293Ch
.rdata:0000293C ; COMDAT (pick any)
.rdata:0000293C                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000293C ; wchar_t `string'
.rdata:0000293C ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000293C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:0000293C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:0000293C                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000293C                 unicode 0, <clude\xstring>,0
.rdata:000029CA                 align 4
.rdata:000029CA _rdata          ends
.rdata:000029CA
.rdata:000029CC ; ===========================================================================
.rdata:000029CC
.rdata:000029CC ; Segment type: Pure data
.rdata:000029CC ; Segment permissions: Read
.rdata:000029CC _rdata          segment dword public 'DATA' use32
.rdata:000029CC                 assume cs:_rdata
.rdata:000029CC                 ;org 29CCh
.rdata:000029CC ; COMDAT (pick any)
.rdata:000029CC                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:000029CC ; char `string'[]
.rdata:000029CC ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:000029CC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:000029CC _rdata          ends
.rdata:000029CC
.rdata:000029DC ; ===========================================================================
.rdata:000029DC
.rdata:000029DC ; Segment type: Pure data
.rdata:000029DC ; Segment permissions: Read
.rdata:000029DC _rdata          segment dword public 'DATA' use32
.rdata:000029DC                 assume cs:_rdata
.rdata:000029DC                 ;org 29DCh
.rdata:000029DC ; COMDAT (pick any)
.rdata:000029DC                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:000029DC ; char `string'[]
.rdata:000029DC ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:000029DC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:000029DC _rdata          ends
.rdata:000029DC
.rdata:000029F4 ; ===========================================================================
.rdata:000029F4
.rdata:000029F4 ; Segment type: Pure data
.rdata:000029F4 ; Segment permissions: Read
.rdata:000029F4 _rdata          segment dword public 'DATA' use32
.rdata:000029F4                 assume cs:_rdata
.rdata:000029F4                 ;org 29F4h
.rdata:000029F4 ; COMDAT (pick any)
.rdata:000029F4                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:000029F4 ; wchar_t `string'
.rdata:000029F4 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:000029F4                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:000029F4                 unicode 0, <invalid null pointer>,0
.rdata:00002A1E                 align 10h
.rdata:00002A1E _rdata          ends
.rdata:00002A1E
.rdata$r:00002A20 ; ===========================================================================
.rdata$r:00002A20
.rdata$r:00002A20 ; Segment type: Pure data
.rdata$r:00002A20 ; Segment permissions: Read
.rdata$r:00002A20 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A20                 assume cs:_rdata$r
.rdata$r:00002A20                 ;org 2A20h
.rdata$r:00002A20 ; COMDAT (pick any)
.rdata$r:00002A20                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00002A20 ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002A20 ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:00002A20                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:00002A20                                         ; .rdata$r:00002A7Co
.rdata$r:00002A20                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:00002A24                 db    0
.rdata$r:00002A25                 db    0
.rdata$r:00002A26                 db    0
.rdata$r:00002A27                 db    0
.rdata$r:00002A28                 db    0
.rdata$r:00002A29                 db    0
.rdata$r:00002A2A                 db    0
.rdata$r:00002A2B                 db    0
.rdata$r:00002A2C                 db 0FFh
.rdata$r:00002A2D                 db 0FFh
.rdata$r:00002A2E                 db 0FFh
.rdata$r:00002A2F                 db 0FFh
.rdata$r:00002A30                 db    0
.rdata$r:00002A31                 db    0
.rdata$r:00002A32                 db    0
.rdata$r:00002A33                 db    0
.rdata$r:00002A34                 db  40h ; @
.rdata$r:00002A35                 db    0
.rdata$r:00002A36                 db    0
.rdata$r:00002A37                 db    0
.rdata$r:00002A38                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002A38 _rdata$r        ends
.rdata$r:00002A38
.rdata$r:00002A3C ; ===========================================================================
.rdata$r:00002A3C
.rdata$r:00002A3C ; Segment type: Pure data
.rdata$r:00002A3C ; Segment permissions: Read
.rdata$r:00002A3C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A3C                 assume cs:_rdata$r
.rdata$r:00002A3C                 ;org 2A3Ch
.rdata$r:00002A3C ; COMDAT (pick any)
.rdata$r:00002A3C                 public ??_R3exception@std@@8
.rdata$r:00002A3C ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002A3C ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:00002A38o
.rdata$r:00002A3D                 db    0
.rdata$r:00002A3E                 db    0
.rdata$r:00002A3F                 db    0
.rdata$r:00002A40                 db    0
.rdata$r:00002A41                 db    0
.rdata$r:00002A42                 db    0
.rdata$r:00002A43                 db    0
.rdata$r:00002A44                 db    1
.rdata$r:00002A45                 db    0
.rdata$r:00002A46                 db    0
.rdata$r:00002A47                 db    0
.rdata$r:00002A48                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:00002A48 _rdata$r        ends
.rdata$r:00002A48
.rdata$r:00002A4C ; ===========================================================================
.rdata$r:00002A4C
.rdata$r:00002A4C ; Segment type: Pure data
.rdata$r:00002A4C ; Segment permissions: Read
.rdata$r:00002A4C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A4C                 assume cs:_rdata$r
.rdata$r:00002A4C                 ;org 2A4Ch
.rdata$r:00002A4C ; COMDAT (pick any)
.rdata$r:00002A4C                 public ??_R2exception@std@@8
.rdata$r:00002A4C ; std::exception::`RTTI Base Class Array'
.rdata$r:00002A4C ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00002A4C                                         ; DATA XREF: .rdata$r:00002A48o
.rdata$r:00002A4C                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002A50                 db    0
.rdata$r:00002A51                 align 4
.rdata$r:00002A51 _rdata$r        ends
.rdata$r:00002A51
.rdata$r:00002A54 ; ===========================================================================
.rdata$r:00002A54
.rdata$r:00002A54 ; Segment type: Pure data
.rdata$r:00002A54 ; Segment permissions: Read
.rdata$r:00002A54 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A54                 assume cs:_rdata$r
.rdata$r:00002A54                 ;org 2A54h
.rdata$r:00002A54 ; COMDAT (pick any)
.rdata$r:00002A54                 public ??_R4runtime_error@std@@6B@
.rdata$r:00002A54 ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata$r:00002A54 ??_R4runtime_error@std@@6B@ db    0     ; DATA XREF: .rdata:000027E0o
.rdata$r:00002A55                 db    0
.rdata$r:00002A56                 db    0
.rdata$r:00002A57                 db    0
.rdata$r:00002A58                 db    0
.rdata$r:00002A59                 db    0
.rdata$r:00002A5A                 db    0
.rdata$r:00002A5B                 db    0
.rdata$r:00002A5C                 db    0
.rdata$r:00002A5D                 db    0
.rdata$r:00002A5E                 db    0
.rdata$r:00002A5F                 db    0
.rdata$r:00002A60                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00002A64                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002A64 _rdata$r        ends
.rdata$r:00002A64
.rdata$r:00002A68 ; ===========================================================================
.rdata$r:00002A68
.rdata$r:00002A68 ; Segment type: Pure data
.rdata$r:00002A68 ; Segment permissions: Read
.rdata$r:00002A68 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A68                 assume cs:_rdata$r
.rdata$r:00002A68                 ;org 2A68h
.rdata$r:00002A68 ; COMDAT (pick any)
.rdata$r:00002A68                 public ??_R3runtime_error@std@@8
.rdata$r:00002A68 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002A68 ??_R3runtime_error@std@@8 db    0       ; DATA XREF: .rdata$r:00002A64o
.rdata$r:00002A68                                         ; .rdata$r:00002A9Co
.rdata$r:00002A69                 db    0
.rdata$r:00002A6A                 db    0
.rdata$r:00002A6B                 db    0
.rdata$r:00002A6C                 db    0
.rdata$r:00002A6D                 db    0
.rdata$r:00002A6E                 db    0
.rdata$r:00002A6F                 db    0
.rdata$r:00002A70                 db    2
.rdata$r:00002A71                 db    0
.rdata$r:00002A72                 db    0
.rdata$r:00002A73                 db    0
.rdata$r:00002A74                 dd offset ??_R2runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00002A74 _rdata$r        ends
.rdata$r:00002A74
.rdata$r:00002A78 ; ===========================================================================
.rdata$r:00002A78
.rdata$r:00002A78 ; Segment type: Pure data
.rdata$r:00002A78 ; Segment permissions: Read
.rdata$r:00002A78 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A78                 assume cs:_rdata$r
.rdata$r:00002A78                 ;org 2A78h
.rdata$r:00002A78 ; COMDAT (pick any)
.rdata$r:00002A78                 public ??_R2runtime_error@std@@8
.rdata$r:00002A78 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00002A78 ??_R2runtime_error@std@@8 dd offset ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00002A78                                         ; DATA XREF: .rdata$r:00002A74o
.rdata$r:00002A78                                         ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002A7C                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002A80                 db    0
.rdata$r:00002A81                 align 4
.rdata$r:00002A81 _rdata$r        ends
.rdata$r:00002A81
.rdata$r:00002A84 ; ===========================================================================
.rdata$r:00002A84
.rdata$r:00002A84 ; Segment type: Pure data
.rdata$r:00002A84 ; Segment permissions: Read
.rdata$r:00002A84 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A84                 assume cs:_rdata$r
.rdata$r:00002A84                 ;org 2A84h
.rdata$r:00002A84 ; COMDAT (pick any)
.rdata$r:00002A84                 public ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00002A84 ; std::runtime_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002A84 ??_R1A@?0A@EA@runtime_error@std@@8 dd offset ??_R0?AVruntime_error@std@@@8
.rdata$r:00002A84                                         ; DATA XREF: .rdata$r:std::runtime_error::`RTTI Base Class Array'o
.rdata$r:00002A84                                         ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00002A88                 db    1
.rdata$r:00002A89                 db    0
.rdata$r:00002A8A                 db    0
.rdata$r:00002A8B                 db    0
.rdata$r:00002A8C                 db    0
.rdata$r:00002A8D                 db    0
.rdata$r:00002A8E                 db    0
.rdata$r:00002A8F                 db    0
.rdata$r:00002A90                 db 0FFh
.rdata$r:00002A91                 db 0FFh
.rdata$r:00002A92                 db 0FFh
.rdata$r:00002A93                 db 0FFh
.rdata$r:00002A94                 db    0
.rdata$r:00002A95                 db    0
.rdata$r:00002A96                 db    0
.rdata$r:00002A97                 db    0
.rdata$r:00002A98                 db  40h ; @
.rdata$r:00002A99                 db    0
.rdata$r:00002A9A                 db    0
.rdata$r:00002A9B                 db    0
.rdata$r:00002A9C                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002A9C _rdata$r        ends
.rdata$r:00002A9C
.rdata$r:00002AA0 ; ===========================================================================
.rdata$r:00002AA0
.rdata$r:00002AA0 ; Segment type: Pure data
.rdata$r:00002AA0 ; Segment permissions: Read
.rdata$r:00002AA0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002AA0                 assume cs:_rdata$r
.rdata$r:00002AA0                 ;org 2AA0h
.rdata$r:00002AA0 ; COMDAT (pick any)
.rdata$r:00002AA0                 public ??_R4error_category@std@@6B@
.rdata$r:00002AA0 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00002AA0 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:0000287Co
.rdata$r:00002AA1                 db    0
.rdata$r:00002AA2                 db    0
.rdata$r:00002AA3                 db    0
.rdata$r:00002AA4                 db    0
.rdata$r:00002AA5                 db    0
.rdata$r:00002AA6                 db    0
.rdata$r:00002AA7                 db    0
.rdata$r:00002AA8                 db    0
.rdata$r:00002AA9                 db    0
.rdata$r:00002AAA                 db    0
.rdata$r:00002AAB                 db    0
.rdata$r:00002AAC                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002AB0                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002AB0 _rdata$r        ends
.rdata$r:00002AB0
.data$r:00002AB4 ; ===========================================================================
.data$r:00002AB4
.data$r:00002AB4 ; Segment type: Pure data
.data$r:00002AB4 ; Segment permissions: Read/Write
.data$r:00002AB4 _data$r         segment dword public 'DATA' use32
.data$r:00002AB4                 assume cs:_data$r
.data$r:00002AB4                 ;org 2AB4h
.data$r:00002AB4 ; COMDAT (pick any)
.data$r:00002AB4                 public ??_R0?AVerror_category@std@@@8
.data$r:00002AB4 ; class std::error_category `RTTI Type Descriptor'
.data$r:00002AB4 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002AB4                                         ; DATA XREF: .rdata$r:00002AACo
.data$r:00002AB4                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002AB4                                         ; const type_info::`vftable'
.data$r:00002AB8                 db    0
.data$r:00002AB9                 db    0
.data$r:00002ABA                 db    0
.data$r:00002ABB                 db    0
.data$r:00002ABC                 db  2Eh ; .
.data$r:00002ABD                 db  3Fh ; ?
.data$r:00002ABE                 db  41h ; A
.data$r:00002ABF                 db  56h ; V
.data$r:00002AC0                 db  65h ; e
.data$r:00002AC1                 db  72h ; r
.data$r:00002AC2                 db  72h ; r
.data$r:00002AC3                 db  6Fh ; o
.data$r:00002AC4                 db  72h ; r
.data$r:00002AC5                 db  5Fh ; _
.data$r:00002AC6                 db  63h ; c
.data$r:00002AC7                 db  61h ; a
.data$r:00002AC8                 db  74h ; t
.data$r:00002AC9                 db  65h ; e
.data$r:00002ACA                 db  67h ; g
.data$r:00002ACB                 db  6Fh ; o
.data$r:00002ACC                 db  72h ; r
.data$r:00002ACD                 db  79h ; y
.data$r:00002ACE                 db  40h ; @
.data$r:00002ACF                 db  73h ; s
.data$r:00002AD0                 db  74h ; t
.data$r:00002AD1                 db  64h ; d
.data$r:00002AD2                 db  40h ; @
.data$r:00002AD3                 db  40h ; @
.data$r:00002AD4                 db    0
.data$r:00002AD5                 align 4
.data$r:00002AD5 _data$r         ends
.data$r:00002AD5
.rdata$r:00002AD8 ; ===========================================================================
.rdata$r:00002AD8
.rdata$r:00002AD8 ; Segment type: Pure data
.rdata$r:00002AD8 ; Segment permissions: Read
.rdata$r:00002AD8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002AD8                 assume cs:_rdata$r
.rdata$r:00002AD8                 ;org 2AD8h
.rdata$r:00002AD8 ; COMDAT (pick any)
.rdata$r:00002AD8                 public ??_R3error_category@std@@8
.rdata$r:00002AD8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002AD8 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00002AB0o
.rdata$r:00002AD8                                         ; .rdata$r:00002B08o
.rdata$r:00002AD9                 db    0
.rdata$r:00002ADA                 db    0
.rdata$r:00002ADB                 db    0
.rdata$r:00002ADC                 db    0
.rdata$r:00002ADD                 db    0
.rdata$r:00002ADE                 db    0
.rdata$r:00002ADF                 db    0
.rdata$r:00002AE0                 db    1
.rdata$r:00002AE1                 db    0
.rdata$r:00002AE2                 db    0
.rdata$r:00002AE3                 db    0
.rdata$r:00002AE4                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002AE4 _rdata$r        ends
.rdata$r:00002AE4
.rdata$r:00002AE8 ; ===========================================================================
.rdata$r:00002AE8
.rdata$r:00002AE8 ; Segment type: Pure data
.rdata$r:00002AE8 ; Segment permissions: Read
.rdata$r:00002AE8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002AE8                 assume cs:_rdata$r
.rdata$r:00002AE8                 ;org 2AE8h
.rdata$r:00002AE8 ; COMDAT (pick any)
.rdata$r:00002AE8                 public ??_R2error_category@std@@8
.rdata$r:00002AE8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002AE8 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002AE8                                         ; DATA XREF: .rdata$r:00002AE4o
.rdata$r:00002AE8                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002AEC                 db    0
.rdata$r:00002AED                 align 10h
.rdata$r:00002AED _rdata$r        ends
.rdata$r:00002AED
.rdata$r:00002AF0 ; ===========================================================================
.rdata$r:00002AF0
.rdata$r:00002AF0 ; Segment type: Pure data
.rdata$r:00002AF0 ; Segment permissions: Read
.rdata$r:00002AF0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002AF0                 assume cs:_rdata$r
.rdata$r:00002AF0                 ;org 2AF0h
.rdata$r:00002AF0 ; COMDAT (pick any)
.rdata$r:00002AF0                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002AF0 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002AF0 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00002AF0                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00002AF0                                         ; .rdata$r:00002B60o ...
.rdata$r:00002AF0                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002AF4                 db    0
.rdata$r:00002AF5                 db    0
.rdata$r:00002AF6                 db    0
.rdata$r:00002AF7                 db    0
.rdata$r:00002AF8                 db    0
.rdata$r:00002AF9                 db    0
.rdata$r:00002AFA                 db    0
.rdata$r:00002AFB                 db    0
.rdata$r:00002AFC                 db 0FFh
.rdata$r:00002AFD                 db 0FFh
.rdata$r:00002AFE                 db 0FFh
.rdata$r:00002AFF                 db 0FFh
.rdata$r:00002B00                 db    0
.rdata$r:00002B01                 db    0
.rdata$r:00002B02                 db    0
.rdata$r:00002B03                 db    0
.rdata$r:00002B04                 db  40h ; @
.rdata$r:00002B05                 db    0
.rdata$r:00002B06                 db    0
.rdata$r:00002B07                 db    0
.rdata$r:00002B08                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002B08 _rdata$r        ends
.rdata$r:00002B08
.rdata$r:00002B0C ; ===========================================================================
.rdata$r:00002B0C
.rdata$r:00002B0C ; Segment type: Pure data
.rdata$r:00002B0C ; Segment permissions: Read
.rdata$r:00002B0C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002B0C                 assume cs:_rdata$r
.rdata$r:00002B0C                 ;org 2B0Ch
.rdata$r:00002B0C ; COMDAT (pick any)
.rdata$r:00002B0C                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00002B0C ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00002B0C ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00002B0C                                         ; DATA XREF: .rdata:00002898o
.rdata$r:00002B0D                 db    0
.rdata$r:00002B0E                 db    0
.rdata$r:00002B0F                 db    0
.rdata$r:00002B10                 db    0
.rdata$r:00002B11                 db    0
.rdata$r:00002B12                 db    0
.rdata$r:00002B13                 db    0
.rdata$r:00002B14                 db    0
.rdata$r:00002B15                 db    0
.rdata$r:00002B16                 db    0
.rdata$r:00002B17                 db    0
.rdata$r:00002B18                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002B1C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002B1C _rdata$r        ends
.rdata$r:00002B1C
.data$r:00002B20 ; ===========================================================================
.data$r:00002B20
.data$r:00002B20 ; Segment type: Pure data
.data$r:00002B20 ; Segment permissions: Read/Write
.data$r:00002B20 _data$r         segment dword public 'DATA' use32
.data$r:00002B20                 assume cs:_data$r
.data$r:00002B20                 ;org 2B20h
.data$r:00002B20 ; COMDAT (pick any)
.data$r:00002B20                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00002B20 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00002B20 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002B20                                         ; DATA XREF: .rdata$r:00002B18o
.data$r:00002B20                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002B20                                         ; const type_info::`vftable'
.data$r:00002B24                 align 8
.data$r:00002B28 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:00002B4A                 align 4
.data$r:00002B4A _data$r         ends
.data$r:00002B4A
.rdata$r:00002B4C ; ===========================================================================
.rdata$r:00002B4C
.rdata$r:00002B4C ; Segment type: Pure data
.rdata$r:00002B4C ; Segment permissions: Read
.rdata$r:00002B4C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002B4C                 assume cs:_rdata$r
.rdata$r:00002B4C                 ;org 2B4Ch
.rdata$r:00002B4C ; COMDAT (pick any)
.rdata$r:00002B4C                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00002B4C ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002B4C ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00002B4C                                         ; DATA XREF: .rdata$r:00002B1Co
.rdata$r:00002B4C                                         ; .rdata$r:00002B80o
.rdata$r:00002B4D                 db    0
.rdata$r:00002B4E                 db    0
.rdata$r:00002B4F                 db    0
.rdata$r:00002B50                 db    0
.rdata$r:00002B51                 db    0
.rdata$r:00002B52                 db    0
.rdata$r:00002B53                 db    0
.rdata$r:00002B54                 db    2
.rdata$r:00002B55                 db    0
.rdata$r:00002B56                 db    0
.rdata$r:00002B57                 db    0
.rdata$r:00002B58                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00002B58 _rdata$r        ends
.rdata$r:00002B58
.rdata$r:00002B5C ; ===========================================================================
.rdata$r:00002B5C
.rdata$r:00002B5C ; Segment type: Pure data
.rdata$r:00002B5C ; Segment permissions: Read
.rdata$r:00002B5C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002B5C                 assume cs:_rdata$r
.rdata$r:00002B5C                 ;org 2B5Ch
.rdata$r:00002B5C ; COMDAT (pick any)
.rdata$r:00002B5C                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00002B5C ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00002B5C ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002B5C                                         ; DATA XREF: .rdata$r:00002B58o
.rdata$r:00002B5C                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002B60                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002B64                 db    0
.rdata$r:00002B65                 align 4
.rdata$r:00002B65 _rdata$r        ends
.rdata$r:00002B65
.rdata$r:00002B68 ; ===========================================================================
.rdata$r:00002B68
.rdata$r:00002B68 ; Segment type: Pure data
.rdata$r:00002B68 ; Segment permissions: Read
.rdata$r:00002B68 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002B68                 assume cs:_rdata$r
.rdata$r:00002B68                 ;org 2B68h
.rdata$r:00002B68 ; COMDAT (pick any)
.rdata$r:00002B68                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002B68 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002B68 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00002B68                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00002B68                                         ; .rdata$r:00002BD8o ...
.rdata$r:00002B68                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002B6C                 db    1
.rdata$r:00002B6D                 db    0
.rdata$r:00002B6E                 db    0
.rdata$r:00002B6F                 db    0
.rdata$r:00002B70                 db    0
.rdata$r:00002B71                 db    0
.rdata$r:00002B72                 db    0
.rdata$r:00002B73                 db    0
.rdata$r:00002B74                 db 0FFh
.rdata$r:00002B75                 db 0FFh
.rdata$r:00002B76                 db 0FFh
.rdata$r:00002B77                 db 0FFh
.rdata$r:00002B78                 db    0
.rdata$r:00002B79                 db    0
.rdata$r:00002B7A                 db    0
.rdata$r:00002B7B                 db    0
.rdata$r:00002B7C                 db  40h ; @
.rdata$r:00002B7D                 db    0
.rdata$r:00002B7E                 db    0
.rdata$r:00002B7F                 db    0
.rdata$r:00002B80                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002B80 _rdata$r        ends
.rdata$r:00002B80
.rdata$r:00002B84 ; ===========================================================================
.rdata$r:00002B84
.rdata$r:00002B84 ; Segment type: Pure data
.rdata$r:00002B84 ; Segment permissions: Read
.rdata$r:00002B84 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002B84                 assume cs:_rdata$r
.rdata$r:00002B84                 ;org 2B84h
.rdata$r:00002B84 ; COMDAT (pick any)
.rdata$r:00002B84                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00002B84 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00002B84 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00002B84                                         ; DATA XREF: .rdata:000028CCo
.rdata$r:00002B85                 db    0
.rdata$r:00002B86                 db    0
.rdata$r:00002B87                 db    0
.rdata$r:00002B88                 db    0
.rdata$r:00002B89                 db    0
.rdata$r:00002B8A                 db    0
.rdata$r:00002B8B                 db    0
.rdata$r:00002B8C                 db    0
.rdata$r:00002B8D                 db    0
.rdata$r:00002B8E                 db    0
.rdata$r:00002B8F                 db    0
.rdata$r:00002B90                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002B94                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002B94 _rdata$r        ends
.rdata$r:00002B94
.data$r:00002B98 ; ===========================================================================
.data$r:00002B98
.data$r:00002B98 ; Segment type: Pure data
.data$r:00002B98 ; Segment permissions: Read/Write
.data$r:00002B98 _data$r         segment dword public 'DATA' use32
.data$r:00002B98                 assume cs:_data$r
.data$r:00002B98                 ;org 2B98h
.data$r:00002B98 ; COMDAT (pick any)
.data$r:00002B98                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00002B98 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00002B98 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002B98                                         ; DATA XREF: .rdata$r:00002B90o
.data$r:00002B98                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002B98                                         ; const type_info::`vftable'
.data$r:00002B9C                 align 10h
.data$r:00002BA0 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:00002BC3                 align 4
.data$r:00002BC3 _data$r         ends
.data$r:00002BC3
.rdata$r:00002BC4 ; ===========================================================================
.rdata$r:00002BC4
.rdata$r:00002BC4 ; Segment type: Pure data
.rdata$r:00002BC4 ; Segment permissions: Read
.rdata$r:00002BC4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002BC4                 assume cs:_rdata$r
.rdata$r:00002BC4                 ;org 2BC4h
.rdata$r:00002BC4 ; COMDAT (pick any)
.rdata$r:00002BC4                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00002BC4 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002BC4 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00002BC4                                         ; DATA XREF: .rdata$r:00002B94o
.rdata$r:00002BC4                                         ; .rdata$r:00002BFCo
.rdata$r:00002BC5                 db    0
.rdata$r:00002BC6                 db    0
.rdata$r:00002BC7                 db    0
.rdata$r:00002BC8                 db    0
.rdata$r:00002BC9                 db    0
.rdata$r:00002BCA                 db    0
.rdata$r:00002BCB                 db    0
.rdata$r:00002BCC                 db    3
.rdata$r:00002BCD                 db    0
.rdata$r:00002BCE                 db    0
.rdata$r:00002BCF                 db    0
.rdata$r:00002BD0                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002BD0 _rdata$r        ends
.rdata$r:00002BD0
.rdata$r:00002BD4 ; ===========================================================================
.rdata$r:00002BD4
.rdata$r:00002BD4 ; Segment type: Pure data
.rdata$r:00002BD4 ; Segment permissions: Read
.rdata$r:00002BD4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002BD4                 assume cs:_rdata$r
.rdata$r:00002BD4                 ;org 2BD4h
.rdata$r:00002BD4 ; COMDAT (pick any)
.rdata$r:00002BD4                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00002BD4 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002BD4 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002BD4                                         ; DATA XREF: .rdata$r:00002BD0o
.rdata$r:00002BD4                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002BD8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002BDC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002BE0                 db    0
.rdata$r:00002BE1                 align 4
.rdata$r:00002BE1 _rdata$r        ends
.rdata$r:00002BE1
.rdata$r:00002BE4 ; ===========================================================================
.rdata$r:00002BE4
.rdata$r:00002BE4 ; Segment type: Pure data
.rdata$r:00002BE4 ; Segment permissions: Read
.rdata$r:00002BE4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002BE4                 assume cs:_rdata$r
.rdata$r:00002BE4                 ;org 2BE4h
.rdata$r:00002BE4 ; COMDAT (pick any)
.rdata$r:00002BE4                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002BE4 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002BE4 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00002BE4                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00002BE4                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002BE8                 db    2
.rdata$r:00002BE9                 db    0
.rdata$r:00002BEA                 db    0
.rdata$r:00002BEB                 db    0
.rdata$r:00002BEC                 db    0
.rdata$r:00002BED                 db    0
.rdata$r:00002BEE                 db    0
.rdata$r:00002BEF                 db    0
.rdata$r:00002BF0                 db 0FFh
.rdata$r:00002BF1                 db 0FFh
.rdata$r:00002BF2                 db 0FFh
.rdata$r:00002BF3                 db 0FFh
.rdata$r:00002BF4                 db    0
.rdata$r:00002BF5                 db    0
.rdata$r:00002BF6                 db    0
.rdata$r:00002BF7                 db    0
.rdata$r:00002BF8                 db  40h ; @
.rdata$r:00002BF9                 db    0
.rdata$r:00002BFA                 db    0
.rdata$r:00002BFB                 db    0
.rdata$r:00002BFC                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002BFC _rdata$r        ends
.rdata$r:00002BFC
.rdata$r:00002C00 ; ===========================================================================
.rdata$r:00002C00
.rdata$r:00002C00 ; Segment type: Pure data
.rdata$r:00002C00 ; Segment permissions: Read
.rdata$r:00002C00 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002C00                 assume cs:_rdata$r
.rdata$r:00002C00                 ;org 2C00h
.rdata$r:00002C00 ; COMDAT (pick any)
.rdata$r:00002C00                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00002C00 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00002C00 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000290Co
.rdata$r:00002C01                 db    0
.rdata$r:00002C02                 db    0
.rdata$r:00002C03                 db    0
.rdata$r:00002C04                 db    0
.rdata$r:00002C05                 db    0
.rdata$r:00002C06                 db    0
.rdata$r:00002C07                 db    0
.rdata$r:00002C08                 db    0
.rdata$r:00002C09                 db    0
.rdata$r:00002C0A                 db    0
.rdata$r:00002C0B                 db    0
.rdata$r:00002C0C                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002C10                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002C10 _rdata$r        ends
.rdata$r:00002C10
.data$r:00002C14 ; ===========================================================================
.data$r:00002C14
.data$r:00002C14 ; Segment type: Pure data
.data$r:00002C14 ; Segment permissions: Read/Write
.data$r:00002C14 _data$r         segment dword public 'DATA' use32
.data$r:00002C14                 assume cs:_data$r
.data$r:00002C14                 ;org 2C14h
.data$r:00002C14 ; COMDAT (pick any)
.data$r:00002C14                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00002C14 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00002C14 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002C14                                         ; DATA XREF: .rdata$r:00002C0Co
.data$r:00002C14                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002C14                                         ; const type_info::`vftable'
.data$r:00002C18                 db    0
.data$r:00002C19                 db    0
.data$r:00002C1A                 db    0
.data$r:00002C1B                 db    0
.data$r:00002C1C                 db  2Eh ; .
.data$r:00002C1D                 db  3Fh ; ?
.data$r:00002C1E                 db  41h ; A
.data$r:00002C1F                 db  56h ; V
.data$r:00002C20                 db  5Fh ; _
.data$r:00002C21                 db  53h ; S
.data$r:00002C22                 db  79h ; y
.data$r:00002C23                 db  73h ; s
.data$r:00002C24                 db  74h ; t
.data$r:00002C25                 db  65h ; e
.data$r:00002C26                 db  6Dh ; m
.data$r:00002C27                 db  5Fh ; _
.data$r:00002C28                 db  65h ; e
.data$r:00002C29                 db  72h ; r
.data$r:00002C2A                 db  72h ; r
.data$r:00002C2B                 db  6Fh ; o
.data$r:00002C2C                 db  72h ; r
.data$r:00002C2D                 db  5Fh ; _
.data$r:00002C2E                 db  63h ; c
.data$r:00002C2F                 db  61h ; a
.data$r:00002C30                 db  74h ; t
.data$r:00002C31                 db  65h ; e
.data$r:00002C32                 db  67h ; g
.data$r:00002C33                 db  6Fh ; o
.data$r:00002C34                 db  72h ; r
.data$r:00002C35                 db  79h ; y
.data$r:00002C36                 db  40h ; @
.data$r:00002C37                 db  73h ; s
.data$r:00002C38                 db  74h ; t
.data$r:00002C39                 db  64h ; d
.data$r:00002C3A                 db  40h ; @
.data$r:00002C3B                 db  40h ; @
.data$r:00002C3C                 db    0
.data$r:00002C3D                 align 10h
.data$r:00002C3D _data$r         ends
.data$r:00002C3D
.rdata$r:00002C40 ; ===========================================================================
.rdata$r:00002C40
.rdata$r:00002C40 ; Segment type: Pure data
.rdata$r:00002C40 ; Segment permissions: Read
.rdata$r:00002C40 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002C40                 assume cs:_rdata$r
.rdata$r:00002C40                 ;org 2C40h
.rdata$r:00002C40 ; COMDAT (pick any)
.rdata$r:00002C40                 public ??_R3_System_error_category@std@@8
.rdata$r:00002C40 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002C40 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00002C10o
.rdata$r:00002C40                                         ; .rdata$r:00002C78o
.rdata$r:00002C41                 db    0
.rdata$r:00002C42                 db    0
.rdata$r:00002C43                 db    0
.rdata$r:00002C44                 db    0
.rdata$r:00002C45                 db    0
.rdata$r:00002C46                 db    0
.rdata$r:00002C47                 db    0
.rdata$r:00002C48                 db    3
.rdata$r:00002C49                 db    0
.rdata$r:00002C4A                 db    0
.rdata$r:00002C4B                 db    0
.rdata$r:00002C4C                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002C4C _rdata$r        ends
.rdata$r:00002C4C
.rdata$r:00002C50 ; ===========================================================================
.rdata$r:00002C50
.rdata$r:00002C50 ; Segment type: Pure data
.rdata$r:00002C50 ; Segment permissions: Read
.rdata$r:00002C50 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002C50                 assume cs:_rdata$r
.rdata$r:00002C50                 ;org 2C50h
.rdata$r:00002C50 ; COMDAT (pick any)
.rdata$r:00002C50                 public ??_R2_System_error_category@std@@8
.rdata$r:00002C50 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002C50 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002C50                                         ; DATA XREF: .rdata$r:00002C4Co
.rdata$r:00002C50                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002C54                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002C58                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002C5C                 db    0
.rdata$r:00002C5D                 align 10h
.rdata$r:00002C5D _rdata$r        ends
.rdata$r:00002C5D
.rdata$r:00002C60 ; ===========================================================================
.rdata$r:00002C60
.rdata$r:00002C60 ; Segment type: Pure data
.rdata$r:00002C60 ; Segment permissions: Read
.rdata$r:00002C60 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002C60                 assume cs:_rdata$r
.rdata$r:00002C60                 ;org 2C60h
.rdata$r:00002C60 ; COMDAT (pick any)
.rdata$r:00002C60                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002C60 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002C60 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00002C60                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00002C60                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002C64                 db    2
.rdata$r:00002C65                 db    0
.rdata$r:00002C66                 db    0
.rdata$r:00002C67                 db    0
.rdata$r:00002C68                 db    0
.rdata$r:00002C69                 db    0
.rdata$r:00002C6A                 db    0
.rdata$r:00002C6B                 db    0
.rdata$r:00002C6C                 db 0FFh
.rdata$r:00002C6D                 db 0FFh
.rdata$r:00002C6E                 db 0FFh
.rdata$r:00002C6F                 db 0FFh
.rdata$r:00002C70                 db    0
.rdata$r:00002C71                 db    0
.rdata$r:00002C72                 db    0
.rdata$r:00002C73                 db    0
.rdata$r:00002C74                 db  40h ; @
.rdata$r:00002C75                 db    0
.rdata$r:00002C76                 db    0
.rdata$r:00002C77                 db    0
.rdata$r:00002C78                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002C78 _rdata$r        ends
.rdata$r:00002C78
.CRT$XCU:00002C7C ; ===========================================================================
.CRT$XCU:00002C7C
.CRT$XCU:00002C7C ; Segment type: Pure data
.CRT$XCU:00002C7C ; Segment permissions: Read
.CRT$XCU:00002C7C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002C7C                 assume cs:_CRT$XCU
.CRT$XCU:00002C7C                 ;org 2C7Ch
.CRT$XCU:00002C7C _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00002C80 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00002C80 _CRT$XCU        ends
.CRT$XCU:00002C80
.CRT$XCU:00002C84 ; ===========================================================================
.CRT$XCU:00002C84
.CRT$XCU:00002C84 ; Segment type: Pure data
.CRT$XCU:00002C84 ; Segment permissions: Read
.CRT$XCU:00002C84 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002C84                 assume cs:_CRT$XCU
.CRT$XCU:00002C84                 ;org 2C84h
.CRT$XCU:00002C84 ; COMDAT (pick associative to section at 2930)
.CRT$XCU:00002C84 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00002C84 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00002C84 _CRT$XCU        ends
.CRT$XCU:00002C84
.CRT$XCU:00002C88 ; ===========================================================================
.CRT$XCU:00002C88
.CRT$XCU:00002C88 ; Segment type: Pure data
.CRT$XCU:00002C88 ; Segment permissions: Read
.CRT$XCU:00002C88 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002C88                 assume cs:_CRT$XCU
.CRT$XCU:00002C88                 ;org 2C88h
.CRT$XCU:00002C88 ; COMDAT (pick associative to section at 2934)
.CRT$XCU:00002C88 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00002C88 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00002C88 _CRT$XCU        ends
.CRT$XCU:00002C88
.CRT$XCU:00002C8C ; ===========================================================================
.CRT$XCU:00002C8C
.CRT$XCU:00002C8C ; Segment type: Pure data
.CRT$XCU:00002C8C ; Segment permissions: Read
.CRT$XCU:00002C8C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002C8C                 assume cs:_CRT$XCU
.CRT$XCU:00002C8C                 ;org 2C8Ch
.CRT$XCU:00002C8C ; COMDAT (pick associative to section at 2938)
.CRT$XCU:00002C8C ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00002C8C ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00002C8C _CRT$XCU        ends
.CRT$XCU:00002C8C
UNDEF:00002C90 ; ===========================================================================
UNDEF:00002C90
UNDEF:00002C90 ; Segment type: Externs
UNDEF:00002C90 ; UNDEF
UNDEF:00002C90                 extrn __purecall:near   ; DATA XREF: .rdata:00002884o
UNDEF:00002C90                                         ; .rdata:00002888o
UNDEF:00002C94 ; void *__cdecl operator new(unsigned int)
UNDEF:00002C94                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00002C94                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:00002C98 ; void __cdecl operator delete(void *)
UNDEF:00002C98                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00002C98                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:00002C9C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:00002C9C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:00002C9C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00002CA0 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00002CA0                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00002CA0                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00002CA4 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00002CA4                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00002CA4                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00002CA4                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00002CA8                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00002CAC ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00002CAC                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00002CB0 ; size_t __cdecl strlen(const char *Str)
UNDEF:00002CB0                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00002CB4 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00002CB4                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00002CB8 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:00002CB8                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:00002CB8                                         ; CODE XREF: std::runtime_error::runtime_error(char const *)+2Dp
UNDEF:00002CBC ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *)
UNDEF:00002CBC                 extrn ??0exception@std@@QAE@ABV01@@Z:near
UNDEF:00002CBC                                         ; CODE XREF: std::runtime_error::runtime_error(std::runtime_error const &)+2Dp
UNDEF:00002CBC                                         ; DATA XREF: .xdata$x:00002878o
UNDEF:00002CC0 ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:00002CC0                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:00002CC0                                         ; CODE XREF: __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0+3j
UNDEF:00002CC0                                         ; __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0+3j ...
UNDEF:00002CC4 ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:00002CC4                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:00002CC4                                         ; DATA XREF: .rdata:000027E8o
UNDEF:00002CC8 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00002CC8                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00002CC8                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00002CCC ; void __cdecl std::_Xbad_alloc()
UNDEF:00002CCC                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00002CCC                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_93Ep
UNDEF:00002CCC                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_980p
UNDEF:00002CD0 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00002CD0                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00002CD0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00002CD4 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00002CD4                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00002CD4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00002CD8 ; public: virtual void * __thiscall std::runtime_error::`vector deleting destructor'(unsigned int)
UNDEF:00002CD8                 extrn ??_Eruntime_error@std@@UAEPAXI@Z:near ; weak
UNDEF:00002CD8                                         ; DATA XREF: .rdata:const std::runtime_error::`vftable'o
UNDEF:00002CDC ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002CDC                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002CDC                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00002CE0 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00002CE0                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00002CE0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00002CE0                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00002CE4 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00002CE4                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00002CE4                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00002CE8 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002CE8                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002CE8                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00002CEC ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002CEC                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002CEC                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00002CF0 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002CF0                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002CF0                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00002CF4 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00002CF4                 extrn __imp__SendMessageW@16:near
UNDEF:00002CF4                                         ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+476p
UNDEF:00002CF4                                         ; SplitterContainer::runProc(uint,uint,long)+48Cp
UNDEF:00002CF4                                         ; DATA XREF: ...
UNDEF:00002CF8 ; LRESULT __stdcall DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00002CF8                 extrn __imp__DefWindowProcW@16:near
UNDEF:00002CF8                                         ; CODE XREF: SplitterContainer::staticWinProc(HWND__ *,uint,uint,long)+6Bp
UNDEF:00002CF8                                         ; SplitterContainer::runProc(uint,uint,long)+4ACp
UNDEF:00002CF8                                         ; DATA XREF: ...
UNDEF:00002CFC ; ATOM __stdcall RegisterClassW(const WNDCLASSW *lpWndClass)
UNDEF:00002CFC                 extrn __imp__RegisterClassW@4:near
UNDEF:00002CFC                                         ; CODE XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+100p
UNDEF:00002CFC                                         ; DATA XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+100r
UNDEF:00002D00 ; HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
UNDEF:00002D00                 extrn __imp__CreateWindowExW@48:near
UNDEF:00002D00                                         ; CODE XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+168p
UNDEF:00002D00                                         ; DATA XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+168r
UNDEF:00002D04 ; HMENU __stdcall CreatePopupMenu()
UNDEF:00002D04                 extrn __imp__CreatePopupMenu@0:near
UNDEF:00002D04                                         ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+251p
UNDEF:00002D04                                         ; DATA XREF: SplitterContainer::runProc(uint,uint,long)+251r
UNDEF:00002D08 ; BOOL __stdcall InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
UNDEF:00002D08                 extrn __imp__InsertMenuW@20:near
UNDEF:00002D08                                         ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+275p
UNDEF:00002D08                                         ; SplitterContainer::runProc(uint,uint,long)+293p
UNDEF:00002D08                                         ; DATA XREF: ...
UNDEF:00002D0C ; BOOL __stdcall TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect)
UNDEF:00002D0C                 extrn __imp__TrackPopupMenu@28:near
UNDEF:00002D0C                                         ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+2B5p
UNDEF:00002D0C                                         ; DATA XREF: SplitterContainer::runProc(uint,uint,long)+2B5r
UNDEF:00002D10 ; BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
UNDEF:00002D10                 extrn __imp__InvalidateRect@12:near
UNDEF:00002D10                                         ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+204p
UNDEF:00002D10                                         ; DATA XREF: SplitterContainer::runProc(uint,uint,long)+204r
UNDEF:00002D14 ; BOOL __stdcall GetCursorPos(LPPOINT lpPoint)
UNDEF:00002D14                 extrn __imp__GetCursorPos@4:near
UNDEF:00002D14                                         ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+238p
UNDEF:00002D14                                         ; SplitterContainer::runProc(uint,uint,long)+24Bp ...
UNDEF:00002D18 ; BOOL __stdcall ScreenToClient(HWND hWnd, LPPOINT lpPoint)
UNDEF:00002D18                 extrn __imp__ScreenToClient@8:near
UNDEF:00002D18                                         ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+3F9p
UNDEF:00002D18                                         ; DATA XREF: SplitterContainer::runProc(uint,uint,long)+3F9r
UNDEF:00002D1C ; LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex)
UNDEF:00002D1C                 extrn __imp__GetWindowLongW@8:near
UNDEF:00002D1C                                         ; CODE XREF: SplitterContainer::staticWinProc(HWND__ *,uint,uint,long)+4Cp
UNDEF:00002D1C                                         ; DATA XREF: SplitterContainer::staticWinProc(HWND__ *,uint,uint,long)+4Cr
UNDEF:00002D20 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:00002D20                 extrn __imp__SetWindowLongW@12:near
UNDEF:00002D20                                         ; CODE XREF: SplitterContainer::staticWinProc(HWND__ *,uint,uint,long)+39p
UNDEF:00002D20                                         ; DATA XREF: SplitterContainer::staticWinProc(HWND__ *,uint,uint,long)+39r
UNDEF:00002D24 ; HWND __stdcall GetParent(HWND hWnd)
UNDEF:00002D24                 extrn __imp__GetParent@4:near
UNDEF:00002D24                                         ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+459p
UNDEF:00002D24                                         ; DATA XREF: SplitterContainer::runProc(uint,uint,long)+459r
UNDEF:00002D28 ; HCURSOR __stdcall LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName)
UNDEF:00002D28                 extrn __imp__LoadCursorW@8:near
UNDEF:00002D28                                         ; CODE XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+DEp
UNDEF:00002D28                                         ; DATA XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+DEr
UNDEF:00002D2C ; void __thiscall Splitter::init(Splitter *__hidden this, HINSTANCE, HWND, int, int, unsigned __int32)
UNDEF:00002D2C                 extrn ?init@Splitter@@QAEXPAUHINSTANCE__@@PAUHWND__@@HHK@Z:near
UNDEF:00002D2C                                         ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+A9p
UNDEF:00002D30 ; void __thiscall Splitter::rotate(Splitter *__hidden this)
UNDEF:00002D30                 extrn ?rotate@Splitter@@QAEXXZ:near
UNDEF:00002D30                                         ; CODE XREF: SplitterContainer::rotateTo(bool)+DAp
UNDEF:00002D34 ; __fastcall __security_check_cookie(x)
UNDEF:00002D34                 extrn @__security_check_cookie@4:near
UNDEF:00002D34                                         ; CODE XREF: SplitterContainer::runProc(uint,uint,long)+4B8p
UNDEF:00002D34                                         ; __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp ...
UNDEF:00002D38 ; __stdcall _CxxThrowException(x, x)
UNDEF:00002D38                 extrn __CxxThrowException@8:near
UNDEF:00002D38                                         ; CODE XREF: SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+123p
UNDEF:00002D38                                         ; SplitterContainer::create(Window *,Window *,int,SplitterMode,int,bool)+193p ...
UNDEF:00002D3C                 extrn ___CxxFrameHandler3:near
UNDEF:00002D3C                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:00002D3C                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:00002D40 ; const type_info::`vftable'
UNDEF:00002D40                 extrn ??_7type_info@@6B@:near
UNDEF:00002D40                                         ; DATA XREF: .data$r:std::runtime_error `RTTI Type Descriptor'o
UNDEF:00002D40                                         ; .data$r:std::exception `RTTI Type Descriptor'o ...
UNDEF:00002D44                 extrn ___security_cookie:near
UNDEF:00002D44                                         ; DATA XREF: SplitterContainer::runProc(uint,uint,long)+6r
UNDEF:00002D44                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r ...
UNDEF:00002D48                 extrn __fltused:near
UNDEF:00002D48
UNDEF:00002D48