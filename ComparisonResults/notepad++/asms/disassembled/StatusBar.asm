.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 1392C6D68D971CEF28B982C8D079F0C9
.rdata:00000000 ; Input CRC32 : A6646A86
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\StatusBar.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; const WCHAR _SG97383
.rdata:00000000 $SG97383        dw 0                    ; DATA XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+48o
.rdata:00000002                 align 4
.rdata:00000004 ; const WCHAR _SG97384
.rdata:00000004 $SG97384:                               ; DATA XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+4Do
.rdata:00000004                 unicode 0, <msctls_statusbar32>,0
.rdata:0000002A                 align 4
.rdata:0000002C ; char _SG97388[]
.rdata:0000002C $SG97388        db 'StatusBar::init : CreateWindowEx() function return null',0
.rdata:0000002C                                         ; DATA XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+69o
.rdata:0000002C _rdata          ends
.rdata:0000002C
.text$mn:00000064 ; ===========================================================================
.text$mn:00000064
.text$mn:00000064 ; Segment type: Pure code
.text$mn:00000064 ; Segment permissions: Read/Execute
.text$mn:00000064 _text$mn        segment para public 'CODE' use32
.text$mn:00000064                 assume cs:_text$mn
.text$mn:00000064                 ;org 64h
.text$mn:00000064                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000064
.text$mn:00000064 ; =============== S U B R O U T I N E =======================================
.text$mn:00000064
.text$mn:00000064 ; Attributes: bp-based frame
.text$mn:00000064
.text$mn:00000064 ; void __thiscall StatusBar::init(StatusBar *this, HINSTANCE, HWND, int)
.text$mn:00000064                 public ?init@StatusBar@@UAEXPAUHINSTANCE__@@PAUHWND__@@H@Z
.text$mn:00000064 ?init@StatusBar@@UAEXPAUHINSTANCE__@@PAUHWND__@@H@Z proc near
.text$mn:00000064
.text$mn:00000064 var_2C          = byte ptr -2Ch
.text$mn:00000064 var_20          = dword ptr -20h
.text$mn:00000064 var_1C          = dword ptr -1Ch
.text$mn:00000064 var_18          = dword ptr -18h
.text$mn:00000064 Rect            = tagRECT ptr -14h
.text$mn:00000064 var_4           = dword ptr -4
.text$mn:00000064 arg_0           = dword ptr  8
.text$mn:00000064 arg_4           = dword ptr  0Ch
.text$mn:00000064 arg_8           = dword ptr  10h
.text$mn:00000064
.text$mn:00000064                 push    ebp
.text$mn:00000065                 mov     ebp, esp
.text$mn:00000067                 sub     esp, 2Ch
.text$mn:0000006A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000006F                 xor     eax, ebp
.text$mn:00000071                 mov     [ebp+var_4], eax
.text$mn:00000074                 mov     [ebp+var_18], ecx
.text$mn:00000077                 mov     eax, [ebp+arg_4]
.text$mn:0000007A                 push    eax             ; HWND
.text$mn:0000007B                 mov     ecx, [ebp+arg_0]
.text$mn:0000007E                 push    ecx             ; HINSTANCE
.text$mn:0000007F                 mov     ecx, [ebp+var_18] ; this
.text$mn:00000082                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:00000087                 call    dword ptr ds:__imp__InitCommonControls@0 ; InitCommonControls()
.text$mn:0000008D                 push    0               ; lpParam
.text$mn:0000008F                 mov     edx, [ebp+var_18]
.text$mn:00000092                 mov     eax, [edx+4]
.text$mn:00000095                 push    eax             ; hInstance
.text$mn:00000096                 push    0               ; hMenu
.text$mn:00000098                 mov     ecx, [ebp+var_18]
.text$mn:0000009B                 mov     edx, [ecx+8]
.text$mn:0000009E                 push    edx             ; hWndParent
.text$mn:0000009F                 push    0               ; nHeight
.text$mn:000000A1                 push    0               ; nWidth
.text$mn:000000A3                 push    0               ; Y
.text$mn:000000A5                 push    0               ; X
.text$mn:000000A7                 push    40000100h       ; dwStyle
.text$mn:000000AC                 push    offset $SG97383 ; lpWindowName
.text$mn:000000B1                 push    offset $SG97384 ; "msctls_statusbar32"
.text$mn:000000B6                 push    0               ; dwExStyle
.text$mn:000000B8                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:000000BE                 mov     ecx, [ebp+var_18]
.text$mn:000000C1                 mov     [ecx+0Ch], eax
.text$mn:000000C4                 mov     edx, [ebp+var_18]
.text$mn:000000C7                 cmp     dword ptr [edx+0Ch], 0
.text$mn:000000CB                 jnz     short loc_E8
.text$mn:000000CD                 push    offset $SG97388 ; "StatusBar::init : CreateWindowEx() func"...
.text$mn:000000D2                 lea     ecx, [ebp+var_2C] ; this
.text$mn:000000D5                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:000000DA                 push    offset __TI2?AVruntime_error@std@@
.text$mn:000000DF                 lea     eax, [ebp+var_2C]
.text$mn:000000E2                 push    eax
.text$mn:000000E3                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000000E8 ; ---------------------------------------------------------------------------
.text$mn:000000E8
.text$mn:000000E8 loc_E8:                                 ; CODE XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+67j
.text$mn:000000E8                 mov     ecx, [ebp+var_18]
.text$mn:000000EB                 mov     edx, [ebp+arg_8]
.text$mn:000000EE                 mov     [ecx+10h], edx
.text$mn:000000F1                 xor     ecx, ecx
.text$mn:000000F3                 mov     edx, [ebp+var_18]
.text$mn:000000F6                 mov     eax, [edx+10h]
.text$mn:000000F9                 mov     edx, 4
.text$mn:000000FE                 mul     edx
.text$mn:00000100                 seto    cl
.text$mn:00000103                 neg     ecx
.text$mn:00000105                 or      ecx, eax
.text$mn:00000107                 push    ecx             ; unsigned int
.text$mn:00000108                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:0000010D                 add     esp, 4
.text$mn:00000110                 mov     [ebp+var_20], eax
.text$mn:00000113                 mov     eax, [ebp+var_18]
.text$mn:00000116                 mov     ecx, [ebp+var_20]
.text$mn:00000119                 mov     [eax+14h], ecx
.text$mn:0000011C                 mov     [ebp+var_1C], 0
.text$mn:00000123                 jmp     short loc_12E
.text$mn:00000125 ; ---------------------------------------------------------------------------
.text$mn:00000125
.text$mn:00000125 loc_125:                                ; CODE XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+E5j
.text$mn:00000125                 mov     edx, [ebp+var_1C]
.text$mn:00000128                 add     edx, 1
.text$mn:0000012B                 mov     [ebp+var_1C], edx
.text$mn:0000012E
.text$mn:0000012E loc_12E:                                ; CODE XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+BFj
.text$mn:0000012E                 mov     eax, [ebp+var_18]
.text$mn:00000131                 mov     ecx, [ebp+var_1C]
.text$mn:00000134                 cmp     ecx, [eax+10h]
.text$mn:00000137                 jge     short loc_14B
.text$mn:00000139                 mov     edx, [ebp+var_18]
.text$mn:0000013C                 mov     eax, [edx+14h]
.text$mn:0000013F                 mov     ecx, [ebp+var_1C]
.text$mn:00000142                 mov     dword ptr [eax+ecx*4], 5
.text$mn:00000149                 jmp     short loc_125
.text$mn:0000014B ; ---------------------------------------------------------------------------
.text$mn:0000014B
.text$mn:0000014B loc_14B:                                ; CODE XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+D3j
.text$mn:0000014B                 mov     edx, [ebp+var_18]
.text$mn:0000014E                 mov     eax, [edx+10h]
.text$mn:00000151                 shl     eax, 2
.text$mn:00000154                 push    eax             ; uBytes
.text$mn:00000155                 push    42h ; 'B'       ; uFlags
.text$mn:00000157                 call    dword ptr ds:__imp__LocalAlloc@8 ; LocalAlloc(x,x)
.text$mn:0000015D                 mov     ecx, [ebp+var_18]
.text$mn:00000160                 mov     [ecx+18h], eax
.text$mn:00000163                 mov     edx, [ebp+var_18]
.text$mn:00000166                 mov     eax, [edx+18h]
.text$mn:00000169                 push    eax             ; hMem
.text$mn:0000016A                 call    dword ptr ds:__imp__LocalLock@4 ; LocalLock(x)
.text$mn:00000170                 mov     ecx, [ebp+var_18]
.text$mn:00000173                 mov     [ecx+1Ch], eax
.text$mn:00000176                 lea     edx, [ebp+Rect]
.text$mn:00000179                 push    edx             ; lpRect
.text$mn:0000017A                 mov     eax, [ebp+var_18]
.text$mn:0000017D                 mov     ecx, [eax+8]
.text$mn:00000180                 push    ecx             ; hWnd
.text$mn:00000181                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00000187                 mov     edx, [ebp+Rect.right]
.text$mn:0000018A                 push    edx             ; int
.text$mn:0000018B                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000018E                 call    ?adjustParts@StatusBar@@QAEXH@Z ; StatusBar::adjustParts(int)
.text$mn:00000193                 mov     ecx, [ebp+var_4]
.text$mn:00000196                 xor     ecx, ebp
.text$mn:00000198                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000019D                 mov     esp, ebp
.text$mn:0000019F                 pop     ebp
.text$mn:000001A0                 retn    0Ch
.text$mn:000001A0 ?init@StatusBar@@UAEXPAUHINSTANCE__@@PAUHWND__@@H@Z endp
.text$mn:000001A0
.text$mn:000001A0 ; ---------------------------------------------------------------------------
.text$mn:000001A3                 align 4
.text$mn:000001A4
.text$mn:000001A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000001A4
.text$mn:000001A4 ; Attributes: bp-based frame
.text$mn:000001A4
.text$mn:000001A4 ; bool __thiscall StatusBar::setText(StatusBar *this, const wchar_t *Str, int)
.text$mn:000001A4                 public ?setText@StatusBar@@QAE_NPB_WH@Z
.text$mn:000001A4 ?setText@StatusBar@@QAE_NPB_WH@Z proc near
.text$mn:000001A4
.text$mn:000001A4 var_8           = dword ptr -8
.text$mn:000001A4 var_4           = dword ptr -4
.text$mn:000001A4 Str             = dword ptr  8
.text$mn:000001A4 wParam          = dword ptr  0Ch
.text$mn:000001A4
.text$mn:000001A4                 push    ebp
.text$mn:000001A5                 mov     ebp, esp
.text$mn:000001A7                 sub     esp, 8
.text$mn:000001AA                 mov     [ebp+var_4], ecx
.text$mn:000001AD                 mov     eax, [ebp+var_4]
.text$mn:000001B0                 mov     ecx, [ebp+wParam]
.text$mn:000001B3                 cmp     ecx, [eax+10h]
.text$mn:000001B6                 jle     short loc_1BC
.text$mn:000001B8                 xor     al, al
.text$mn:000001BA                 jmp     short loc_205
.text$mn:000001BC ; ---------------------------------------------------------------------------
.text$mn:000001BC
.text$mn:000001BC loc_1BC:                                ; CODE XREF: StatusBar::setText(wchar_t const *,int)+12j
.text$mn:000001BC                 mov     edx, [ebp+Str]
.text$mn:000001BF                 push    edx             ; Str
.text$mn:000001C0                 mov     ecx, [ebp+var_4]
.text$mn:000001C3                 add     ecx, 20h ; ' '
.text$mn:000001C6                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:000001CB                 mov     ecx, [ebp+var_4]
.text$mn:000001CE                 add     ecx, 20h ; ' '
.text$mn:000001D1                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000001D6                 push    eax             ; lParam
.text$mn:000001D7                 mov     eax, [ebp+wParam]
.text$mn:000001DA                 push    eax             ; wParam
.text$mn:000001DB                 push    40Bh            ; Msg
.text$mn:000001E0                 mov     ecx, [ebp+var_4]
.text$mn:000001E3                 mov     edx, [ecx+0Ch]
.text$mn:000001E6                 push    edx             ; hWnd
.text$mn:000001E7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000001ED                 cmp     eax, 1
.text$mn:000001F0                 jnz     short loc_1FB
.text$mn:000001F2                 mov     [ebp+var_8], 1
.text$mn:000001F9                 jmp     short loc_202
.text$mn:000001FB ; ---------------------------------------------------------------------------
.text$mn:000001FB
.text$mn:000001FB loc_1FB:                                ; CODE XREF: StatusBar::setText(wchar_t const *,int)+4Cj
.text$mn:000001FB                 mov     [ebp+var_8], 0
.text$mn:00000202
.text$mn:00000202 loc_202:                                ; CODE XREF: StatusBar::setText(wchar_t const *,int)+55j
.text$mn:00000202                 mov     al, byte ptr [ebp+var_8]
.text$mn:00000205
.text$mn:00000205 loc_205:                                ; CODE XREF: StatusBar::setText(wchar_t const *,int)+16j
.text$mn:00000205                 mov     esp, ebp
.text$mn:00000207                 pop     ebp
.text$mn:00000208                 retn    8
.text$mn:00000208 ?setText@StatusBar@@QAE_NPB_WH@Z endp
.text$mn:00000208
.text$mn:00000208 ; ---------------------------------------------------------------------------
.text$mn:0000020B                 db 9 dup(0CCh)
.text$mn:00000214
.text$mn:00000214 ; =============== S U B R O U T I N E =======================================
.text$mn:00000214
.text$mn:00000214 ; Attributes: bp-based frame
.text$mn:00000214
.text$mn:00000214 ; bool __thiscall StatusBar::setOwnerDrawText(StatusBar *this, const wchar_t *)
.text$mn:00000214                 public ?setOwnerDrawText@StatusBar@@QAE_NPB_W@Z
.text$mn:00000214 ?setOwnerDrawText@StatusBar@@QAE_NPB_W@Z proc near
.text$mn:00000214
.text$mn:00000214 var_8           = dword ptr -8
.text$mn:00000214 var_4           = dword ptr -4
.text$mn:00000214 Str             = dword ptr  8
.text$mn:00000214
.text$mn:00000214                 push    ebp
.text$mn:00000215                 mov     ebp, esp
.text$mn:00000217                 sub     esp, 8
.text$mn:0000021A                 mov     [ebp+var_4], ecx
.text$mn:0000021D                 mov     eax, [ebp+Str]
.text$mn:00000220                 push    eax             ; Str
.text$mn:00000221                 mov     ecx, [ebp+var_4]
.text$mn:00000224                 add     ecx, 20h ; ' '
.text$mn:00000227                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:0000022C                 mov     ecx, [ebp+var_4]
.text$mn:0000022F                 add     ecx, 20h ; ' '
.text$mn:00000232                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000237                 push    eax             ; lParam
.text$mn:00000238                 push    1000h           ; wParam
.text$mn:0000023D                 push    40Bh            ; Msg
.text$mn:00000242                 mov     ecx, [ebp+var_4]
.text$mn:00000245                 mov     edx, [ecx+0Ch]
.text$mn:00000248                 push    edx             ; hWnd
.text$mn:00000249                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000024F                 cmp     eax, 1
.text$mn:00000252                 jnz     short loc_25D
.text$mn:00000254                 mov     [ebp+var_8], 1
.text$mn:0000025B                 jmp     short loc_264
.text$mn:0000025D ; ---------------------------------------------------------------------------
.text$mn:0000025D
.text$mn:0000025D loc_25D:                                ; CODE XREF: StatusBar::setOwnerDrawText(wchar_t const *)+3Ej
.text$mn:0000025D                 mov     [ebp+var_8], 0
.text$mn:00000264
.text$mn:00000264 loc_264:                                ; CODE XREF: StatusBar::setOwnerDrawText(wchar_t const *)+47j
.text$mn:00000264                 mov     al, byte ptr [ebp+var_8]
.text$mn:00000267                 mov     esp, ebp
.text$mn:00000269                 pop     ebp
.text$mn:0000026A                 retn    4
.text$mn:0000026A ?setOwnerDrawText@StatusBar@@QAE_NPB_W@Z endp
.text$mn:0000026A
.text$mn:0000026A ; ---------------------------------------------------------------------------
.text$mn:0000026D                 db 7 dup(0CCh)
.text$mn:00000274
.text$mn:00000274 ; =============== S U B R O U T I N E =======================================
.text$mn:00000274
.text$mn:00000274 ; Attributes: bp-based frame
.text$mn:00000274
.text$mn:00000274 ; void __thiscall StatusBar::adjustParts(StatusBar *this, int)
.text$mn:00000274                 public ?adjustParts@StatusBar@@QAEXH@Z
.text$mn:00000274 ?adjustParts@StatusBar@@QAEXH@Z proc near
.text$mn:00000274                                         ; CODE XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+12Ap
.text$mn:00000274
.text$mn:00000274 var_C           = dword ptr -0Ch
.text$mn:00000274 var_8           = dword ptr -8
.text$mn:00000274 var_4           = dword ptr -4
.text$mn:00000274 arg_0           = dword ptr  8
.text$mn:00000274
.text$mn:00000274                 push    ebp
.text$mn:00000275                 mov     ebp, esp
.text$mn:00000277                 sub     esp, 0Ch
.text$mn:0000027A                 mov     [ebp+var_4], ecx
.text$mn:0000027D                 mov     eax, [ebp+arg_0]
.text$mn:00000280                 sub     eax, 14h
.text$mn:00000283                 mov     [ebp+var_C], eax
.text$mn:00000286                 mov     ecx, [ebp+var_4]
.text$mn:00000289                 mov     edx, [ecx+10h]
.text$mn:0000028C                 sub     edx, 1
.text$mn:0000028F                 mov     [ebp+var_8], edx
.text$mn:00000292                 jmp     short loc_29D
.text$mn:00000294 ; ---------------------------------------------------------------------------
.text$mn:00000294
.text$mn:00000294 loc_294:                                ; CODE XREF: StatusBar::adjustParts(int)+50j
.text$mn:00000294                 mov     eax, [ebp+var_8]
.text$mn:00000297                 sub     eax, 1
.text$mn:0000029A                 mov     [ebp+var_8], eax
.text$mn:0000029D
.text$mn:0000029D loc_29D:                                ; CODE XREF: StatusBar::adjustParts(int)+1Ej
.text$mn:0000029D                 cmp     [ebp+var_8], 0
.text$mn:000002A1                 jl      short loc_2C6
.text$mn:000002A3                 mov     ecx, [ebp+var_4]
.text$mn:000002A6                 mov     edx, [ecx+1Ch]
.text$mn:000002A9                 mov     eax, [ebp+var_8]
.text$mn:000002AC                 mov     ecx, [ebp+var_C]
.text$mn:000002AF                 mov     [edx+eax*4], ecx
.text$mn:000002B2                 mov     edx, [ebp+var_4]
.text$mn:000002B5                 mov     eax, [edx+14h]
.text$mn:000002B8                 mov     ecx, [ebp+var_8]
.text$mn:000002BB                 mov     edx, [ebp+var_C]
.text$mn:000002BE                 sub     edx, [eax+ecx*4]
.text$mn:000002C1                 mov     [ebp+var_C], edx
.text$mn:000002C4                 jmp     short loc_294
.text$mn:000002C6 ; ---------------------------------------------------------------------------
.text$mn:000002C6
.text$mn:000002C6 loc_2C6:                                ; CODE XREF: StatusBar::adjustParts(int)+2Dj
.text$mn:000002C6                 mov     eax, [ebp+var_4]
.text$mn:000002C9                 mov     ecx, [eax+1Ch]
.text$mn:000002CC                 push    ecx             ; lParam
.text$mn:000002CD                 mov     edx, [ebp+var_4]
.text$mn:000002D0                 mov     eax, [edx+10h]
.text$mn:000002D3                 push    eax             ; wParam
.text$mn:000002D4                 push    404h            ; Msg
.text$mn:000002D9                 mov     ecx, [ebp+var_4]
.text$mn:000002DC                 mov     edx, [ecx+0Ch]
.text$mn:000002DF                 push    edx             ; hWnd
.text$mn:000002E0                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000002E6                 mov     esp, ebp
.text$mn:000002E8                 pop     ebp
.text$mn:000002E9                 retn    4
.text$mn:000002E9 ?adjustParts@StatusBar@@QAEXH@Z endp
.text$mn:000002E9
.text$mn:000002E9 _text$mn        ends
.text$mn:000002E9
.text$mn:000002EC ; ===========================================================================
.text$mn:000002EC
.text$mn:000002EC ; Segment type: Pure code
.text$mn:000002EC ; Segment permissions: Read/Execute
.text$mn:000002EC _text$mn        segment para public 'CODE' use32
.text$mn:000002EC                 assume cs:_text$mn
.text$mn:000002EC                 ;org 2ECh
.text$mn:000002EC ; COMDAT (pick any)
.text$mn:000002EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000002EC
.text$mn:000002EC ; =============== S U B R O U T I N E =======================================
.text$mn:000002EC
.text$mn:000002EC ; Attributes: bp-based frame
.text$mn:000002EC
.text$mn:000002EC ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:000002EC                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:000002EC ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:000002EC                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:000002EC
.text$mn:000002EC var_4           = dword ptr -4
.text$mn:000002EC arg_0           = dword ptr  8
.text$mn:000002EC
.text$mn:000002EC                 push    ebp
.text$mn:000002ED                 mov     ebp, esp
.text$mn:000002EF                 push    ecx
.text$mn:000002F0                 mov     [ebp+var_4], 0
.text$mn:000002F7                 cmp     [ebp+arg_0], 0
.text$mn:000002FB                 jnz     short loc_2FF
.text$mn:000002FD                 jmp     short loc_31F
.text$mn:000002FF ; ---------------------------------------------------------------------------
.text$mn:000002FF
.text$mn:000002FF loc_2FF:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:000002FF                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00000303                 ja      short loc_31A
.text$mn:00000305                 mov     eax, [ebp+arg_0]
.text$mn:00000308                 push    eax             ; unsigned int
.text$mn:00000309                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000030E                 add     esp, 4
.text$mn:00000311                 mov     [ebp+var_4], eax
.text$mn:00000314                 cmp     [ebp+var_4], 0
.text$mn:00000318                 jnz     short loc_31F
.text$mn:0000031A
.text$mn:0000031A loc_31A:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:0000031A                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:0000031F
.text$mn:0000031F loc_31F:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:0000031F                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:0000031F                 mov     eax, [ebp+var_4]
.text$mn:00000322                 mov     esp, ebp
.text$mn:00000324                 pop     ebp
.text$mn:00000325                 retn
.text$mn:00000325 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00000325
.text$mn:00000325 ; ---------------------------------------------------------------------------
.text$mn:00000326                 align 4
.text$mn:00000326 _text$mn        ends
.text$mn:00000326
.text$mn:00000328 ; ===========================================================================
.text$mn:00000328
.text$mn:00000328 ; Segment type: Pure code
.text$mn:00000328 ; Segment permissions: Read/Execute
.text$mn:00000328 _text$mn        segment para public 'CODE' use32
.text$mn:00000328                 assume cs:_text$mn
.text$mn:00000328                 ;org 328h
.text$mn:00000328 ; COMDAT (pick any)
.text$mn:00000328                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000328
.text$mn:00000328 ; =============== S U B R O U T I N E =======================================
.text$mn:00000328
.text$mn:00000328 ; Attributes: bp-based frame
.text$mn:00000328
.text$mn:00000328 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00000328                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00000328 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00000328                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00000328
.text$mn:00000328 var_4           = dword ptr -4
.text$mn:00000328 arg_0           = dword ptr  8
.text$mn:00000328
.text$mn:00000328                 push    ebp
.text$mn:00000329                 mov     ebp, esp
.text$mn:0000032B                 push    ecx
.text$mn:0000032C                 mov     [ebp+var_4], 0
.text$mn:00000333                 cmp     [ebp+arg_0], 0
.text$mn:00000337                 jnz     short loc_33B
.text$mn:00000339                 jmp     short loc_361
.text$mn:0000033B ; ---------------------------------------------------------------------------
.text$mn:0000033B
.text$mn:0000033B loc_33B:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:0000033B                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00000342                 ja      short loc_35C
.text$mn:00000344                 mov     eax, [ebp+arg_0]
.text$mn:00000347                 shl     eax, 3
.text$mn:0000034A                 push    eax             ; unsigned int
.text$mn:0000034B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000350                 add     esp, 4
.text$mn:00000353                 mov     [ebp+var_4], eax
.text$mn:00000356                 cmp     [ebp+var_4], 0
.text$mn:0000035A                 jnz     short loc_361
.text$mn:0000035C
.text$mn:0000035C loc_35C:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:0000035C                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000361
.text$mn:00000361 loc_361:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00000361                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00000361                 mov     eax, [ebp+var_4]
.text$mn:00000364                 mov     esp, ebp
.text$mn:00000366                 pop     ebp
.text$mn:00000367                 retn
.text$mn:00000367 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00000367
.text$mn:00000367 _text$mn        ends
.text$mn:00000367
.text$mn:00000368 ; ===========================================================================
.text$mn:00000368
.text$mn:00000368 ; Segment type: Pure code
.text$mn:00000368 ; Segment permissions: Read/Execute
.text$mn:00000368 _text$mn        segment para public 'CODE' use32
.text$mn:00000368                 assume cs:_text$mn
.text$mn:00000368                 ;org 368h
.text$mn:00000368 ; COMDAT (pick any)
.text$mn:00000368                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000368
.text$mn:00000368 ; =============== S U B R O U T I N E =======================================
.text$mn:00000368
.text$mn:00000368 ; Attributes: bp-based frame
.text$mn:00000368
.text$mn:00000368 ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:00000368                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:00000368 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:00000368                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:00000368
.text$mn:00000368 var_4           = dword ptr -4
.text$mn:00000368 arg_0           = dword ptr  8
.text$mn:00000368
.text$mn:00000368                 push    ebp
.text$mn:00000369                 mov     ebp, esp
.text$mn:0000036B                 push    ecx
.text$mn:0000036C                 mov     [ebp+var_4], 0
.text$mn:00000373                 cmp     [ebp+arg_0], 0
.text$mn:00000377                 jnz     short loc_37B
.text$mn:00000379                 jmp     short loc_3A0
.text$mn:0000037B ; ---------------------------------------------------------------------------
.text$mn:0000037B
.text$mn:0000037B loc_37B:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:0000037B                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:00000382                 ja      short loc_39B
.text$mn:00000384                 mov     eax, [ebp+arg_0]
.text$mn:00000387                 shl     eax, 1
.text$mn:00000389                 push    eax             ; unsigned int
.text$mn:0000038A                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000038F                 add     esp, 4
.text$mn:00000392                 mov     [ebp+var_4], eax
.text$mn:00000395                 cmp     [ebp+var_4], 0
.text$mn:00000399                 jnz     short loc_3A0
.text$mn:0000039B
.text$mn:0000039B loc_39B:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:0000039B                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000003A0
.text$mn:000003A0 loc_3A0:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:000003A0                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:000003A0                 mov     eax, [ebp+var_4]
.text$mn:000003A3                 mov     esp, ebp
.text$mn:000003A5                 pop     ebp
.text$mn:000003A6                 retn
.text$mn:000003A6 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:000003A6
.text$mn:000003A6 ; ---------------------------------------------------------------------------
.text$mn:000003A7                 align 4
.text$mn:000003A7 _text$mn        ends
.text$mn:000003A7
.text$mn:000003A8 ; ===========================================================================
.text$mn:000003A8
.text$mn:000003A8 ; Segment type: Pure code
.text$mn:000003A8 ; Segment permissions: Read/Execute
.text$mn:000003A8 _text$mn        segment para public 'CODE' use32
.text$mn:000003A8                 assume cs:_text$mn
.text$mn:000003A8                 ;org 3A8h
.text$mn:000003A8 ; COMDAT (pick any)
.text$mn:000003A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000003A8
.text$mn:000003A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000003A8
.text$mn:000003A8 ; Attributes: bp-based frame
.text$mn:000003A8
.text$mn:000003A8 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000003A8                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000003A8 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000003A8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000003A8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000003A8
.text$mn:000003A8 arg_0           = dword ptr  8
.text$mn:000003A8 arg_4           = dword ptr  0Ch
.text$mn:000003A8 arg_8           = dword ptr  10h
.text$mn:000003A8
.text$mn:000003A8                 push    ebp
.text$mn:000003A9                 mov     ebp, esp
.text$mn:000003AB                 cmp     [ebp+arg_0], 0
.text$mn:000003AF                 jnz     short loc_3C6
.text$mn:000003B1                 mov     eax, [ebp+arg_8]
.text$mn:000003B4                 push    eax             ; unsigned int
.text$mn:000003B5                 mov     ecx, [ebp+arg_4]
.text$mn:000003B8                 push    ecx             ; wchar_t *
.text$mn:000003B9                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000003BE                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000003C3                 add     esp, 0Ch
.text$mn:000003C6
.text$mn:000003C6 loc_3C6:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:000003C6                 pop     ebp
.text$mn:000003C7                 retn
.text$mn:000003C7 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:000003C7
.text$mn:000003C7 _text$mn        ends
.text$mn:000003C7
.text$mn:000003C8 ; ===========================================================================
.text$mn:000003C8
.text$mn:000003C8 ; Segment type: Pure code
.text$mn:000003C8 ; Segment permissions: Read/Execute
.text$mn:000003C8 _text$mn        segment para public 'CODE' use32
.text$mn:000003C8                 assume cs:_text$mn
.text$mn:000003C8                 ;org 3C8h
.text$mn:000003C8 ; COMDAT (pick any)
.text$mn:000003C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000003C8
.text$mn:000003C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000003C8
.text$mn:000003C8 ; Attributes: bp-based frame
.text$mn:000003C8
.text$mn:000003C8 ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:000003C8                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:000003C8 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:000003C8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+15p
.text$mn:000003C8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+1Bp
.text$mn:000003C8
.text$mn:000003C8 arg_0           = dword ptr  8
.text$mn:000003C8 arg_4           = dword ptr  0Ch
.text$mn:000003C8 arg_8           = dword ptr  10h
.text$mn:000003C8
.text$mn:000003C8                 push    ebp
.text$mn:000003C9                 mov     ebp, esp
.text$mn:000003CB                 cmp     [ebp+arg_0], 0
.text$mn:000003CF                 jnz     short loc_3E6
.text$mn:000003D1                 mov     eax, [ebp+arg_8]
.text$mn:000003D4                 push    eax             ; unsigned int
.text$mn:000003D5                 mov     ecx, [ebp+arg_4]
.text$mn:000003D8                 push    ecx             ; wchar_t *
.text$mn:000003D9                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000003DE                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000003E3                 add     esp, 0Ch
.text$mn:000003E6
.text$mn:000003E6 loc_3E6:                                ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:000003E6                 pop     ebp
.text$mn:000003E7                 retn
.text$mn:000003E7 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:000003E7
.text$mn:000003E7 _text$mn        ends
.text$mn:000003E7
.text$mn:000003E8 ; ===========================================================================
.text$mn:000003E8
.text$mn:000003E8 ; Segment type: Pure code
.text$mn:000003E8 ; Segment permissions: Read/Execute
.text$mn:000003E8 _text$mn        segment para public 'CODE' use32
.text$mn:000003E8                 assume cs:_text$mn
.text$mn:000003E8                 ;org 3E8h
.text$mn:000003E8 ; COMDAT (pick any)
.text$mn:000003E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000003E8
.text$mn:000003E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000003E8
.text$mn:000003E8 ; Attributes: bp-based frame
.text$mn:000003E8
.text$mn:000003E8 ; char * __cdecl std::addressof<char>(char &)
.text$mn:000003E8                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000003E8 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000003E8                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000003E8                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000003E8
.text$mn:000003E8 arg_0           = dword ptr  8
.text$mn:000003E8
.text$mn:000003E8                 push    ebp
.text$mn:000003E9                 mov     ebp, esp
.text$mn:000003EB                 mov     eax, [ebp+arg_0]
.text$mn:000003EE                 pop     ebp
.text$mn:000003EF                 retn
.text$mn:000003EF ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000003EF
.text$mn:000003EF _text$mn        ends
.text$mn:000003EF
.text$mn:000003F0 ; ===========================================================================
.text$mn:000003F0
.text$mn:000003F0 ; Segment type: Pure code
.text$mn:000003F0 ; Segment permissions: Read/Execute
.text$mn:000003F0 _text$mn        segment para public 'CODE' use32
.text$mn:000003F0                 assume cs:_text$mn
.text$mn:000003F0                 ;org 3F0h
.text$mn:000003F0 ; COMDAT (pick any)
.text$mn:000003F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000003F0
.text$mn:000003F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000003F0
.text$mn:000003F0 ; Attributes: bp-based frame
.text$mn:000003F0
.text$mn:000003F0 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:000003F0                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:000003F0 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:000003F0                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:000003F0                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:000003F0
.text$mn:000003F0 arg_0           = dword ptr  8
.text$mn:000003F0
.text$mn:000003F0                 push    ebp
.text$mn:000003F1                 mov     ebp, esp
.text$mn:000003F3                 mov     eax, [ebp+arg_0]
.text$mn:000003F6                 pop     ebp
.text$mn:000003F7                 retn
.text$mn:000003F7 ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:000003F7
.text$mn:000003F7 _text$mn        ends
.text$mn:000003F7
.text$mn:000003F8 ; ===========================================================================
.text$mn:000003F8
.text$mn:000003F8 ; Segment type: Pure code
.text$mn:000003F8 ; Segment permissions: Read/Execute
.text$mn:000003F8 _text$mn        segment para public 'CODE' use32
.text$mn:000003F8                 assume cs:_text$mn
.text$mn:000003F8                 ;org 3F8h
.text$mn:000003F8 ; COMDAT (pick any)
.text$mn:000003F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000003F8
.text$mn:000003F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000003F8
.text$mn:000003F8 ; Attributes: bp-based frame
.text$mn:000003F8
.text$mn:000003F8 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000003F8                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000003F8 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000003F8                                         ; CODE XREF: $LN19+4Bp
.text$mn:000003F8
.text$mn:000003F8 var_4           = dword ptr -4
.text$mn:000003F8 arg_0           = dword ptr  8
.text$mn:000003F8 arg_4           = dword ptr  0Ch
.text$mn:000003F8
.text$mn:000003F8                 push    ebp
.text$mn:000003F9                 mov     ebp, esp
.text$mn:000003FB                 push    ecx
.text$mn:000003FC                 mov     [ebp+var_4], ecx
.text$mn:000003FF                 mov     eax, [ebp+arg_4]
.text$mn:00000402                 push    eax
.text$mn:00000403                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000408                 add     esp, 4
.text$mn:0000040B                 push    eax             ; int
.text$mn:0000040C                 mov     ecx, [ebp+arg_0]
.text$mn:0000040F                 push    ecx             ; void *
.text$mn:00000410                 mov     edx, [ebp+var_4]
.text$mn:00000413                 push    edx             ; int
.text$mn:00000414                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00000419                 add     esp, 0Ch
.text$mn:0000041C                 mov     esp, ebp
.text$mn:0000041E                 pop     ebp
.text$mn:0000041F                 retn    8
.text$mn:0000041F ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000041F
.text$mn:0000041F ; ---------------------------------------------------------------------------
.text$mn:00000422                 align 4
.text$mn:00000422 _text$mn        ends
.text$mn:00000422
.text$mn:00000424 ; ===========================================================================
.text$mn:00000424
.text$mn:00000424 ; Segment type: Pure code
.text$mn:00000424 ; Segment permissions: Read/Execute
.text$mn:00000424 _text$mn        segment para public 'CODE' use32
.text$mn:00000424                 assume cs:_text$mn
.text$mn:00000424                 ;org 424h
.text$mn:00000424 ; COMDAT (pick any)
.text$mn:00000424                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000424
.text$mn:00000424 ; =============== S U B R O U T I N E =======================================
.text$mn:00000424
.text$mn:00000424 ; Attributes: bp-based frame
.text$mn:00000424
.text$mn:00000424 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00000424                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000424 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000424                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00000424
.text$mn:00000424 var_1C          = dword ptr -1Ch
.text$mn:00000424 var_18          = dword ptr -18h
.text$mn:00000424 var_14          = dword ptr -14h
.text$mn:00000424 var_10          = dword ptr -10h
.text$mn:00000424 var_C           = dword ptr -0Ch
.text$mn:00000424 var_4           = dword ptr -4
.text$mn:00000424 arg_0           = dword ptr  8
.text$mn:00000424 arg_4           = dword ptr  0Ch
.text$mn:00000424
.text$mn:00000424                 push    ebp
.text$mn:00000425                 mov     ebp, esp
.text$mn:00000427                 push    0FFFFFFFFh
.text$mn:00000429                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000042E                 mov     eax, large fs:0
.text$mn:00000434                 push    eax
.text$mn:00000435                 sub     esp, 10h
.text$mn:00000438                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000043D                 xor     eax, ebp
.text$mn:0000043F                 push    eax
.text$mn:00000440                 lea     eax, [ebp+var_C]
.text$mn:00000443                 mov     large fs:0, eax
.text$mn:00000449                 mov     [ebp+var_18], ecx
.text$mn:0000044C                 mov     eax, [ebp+arg_0]
.text$mn:0000044F                 push    eax             ; void *
.text$mn:00000450                 push    4               ; unsigned int
.text$mn:00000452                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000457                 add     esp, 8
.text$mn:0000045A                 mov     [ebp+var_10], eax
.text$mn:0000045D                 mov     [ebp+var_4], 0
.text$mn:00000464                 cmp     [ebp+var_10], 0
.text$mn:00000468                 jz      short loc_485
.text$mn:0000046A                 mov     ecx, [ebp+arg_4]
.text$mn:0000046D                 push    ecx
.text$mn:0000046E                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000473                 add     esp, 4
.text$mn:00000476                 mov     edx, [ebp+var_10]
.text$mn:00000479                 mov     eax, [eax]
.text$mn:0000047B                 mov     [edx], eax
.text$mn:0000047D                 mov     ecx, [ebp+var_10]
.text$mn:00000480                 mov     [ebp+var_14], ecx
.text$mn:00000483                 jmp     short loc_48C
.text$mn:00000485 ; ---------------------------------------------------------------------------
.text$mn:00000485
.text$mn:00000485 loc_485:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00000485                 mov     [ebp+var_14], 0
.text$mn:0000048C
.text$mn:0000048C loc_48C:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:0000048C                 mov     edx, [ebp+var_14]
.text$mn:0000048F                 mov     [ebp+var_1C], edx
.text$mn:00000492                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000499                 mov     ecx, [ebp+var_C]
.text$mn:0000049C                 mov     large fs:0, ecx
.text$mn:000004A3                 pop     ecx
.text$mn:000004A4                 mov     esp, ebp
.text$mn:000004A6                 pop     ebp
.text$mn:000004A7                 retn    8
.text$mn:000004A7 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000004A7
.text$mn:000004A7 ; ---------------------------------------------------------------------------
.text$mn:000004AA                 align 4
.text$mn:000004AA _text$mn        ends
.text$mn:000004AA
.text$x:000004AC ; ===========================================================================
.text$x:000004AC
.text$x:000004AC ; Segment type: Pure code
.text$x:000004AC ; Segment permissions: Read/Execute
.text$x:000004AC _text$x         segment para public 'CODE' use32
.text$x:000004AC                 assume cs:_text$x
.text$x:000004AC                 ;org 4ACh
.text$x:000004AC ; COMDAT (pick associative to section at 424)
.text$x:000004AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000004AC
.text$x:000004AC ; =============== S U B R O U T I N E =======================================
.text$x:000004AC
.text$x:000004AC
.text$x:000004AC __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000004AC                                         ; DATA XREF: .xdata$x:00002CC0o
.text$x:000004AC                 mov     eax, [ebp+8]
.text$x:000004AF                 push    eax
.text$x:000004B0                 mov     eax, [ebp-10h]
.text$x:000004B3                 push    eax             ; void *
.text$x:000004B4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000004B9                 add     esp, 8
.text$x:000004BC                 retn
.text$x:000004BC __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000004BC
.text$x:000004BD
.text$x:000004BD ; =============== S U B R O U T I N E =======================================
.text$x:000004BD
.text$x:000004BD
.text$x:000004BD __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000004BD                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000004BD
.text$x:000004BD arg_4           = dword ptr  8
.text$x:000004BD
.text$x:000004BD                 mov     edx, [esp+arg_4]
.text$x:000004C1                 lea     eax, [edx+0Ch]
.text$x:000004C4                 mov     ecx, [edx-14h]
.text$x:000004C7                 xor     ecx, eax
.text$x:000004C9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000004CE                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000004D3                 jmp     ___CxxFrameHandler3
.text$x:000004D3 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000004D3
.text$x:000004D3 _text$x         ends
.text$x:000004D3
.text$mn:000004D8 ; ===========================================================================
.text$mn:000004D8
.text$mn:000004D8 ; Segment type: Pure code
.text$mn:000004D8 ; Segment permissions: Read/Execute
.text$mn:000004D8 _text$mn        segment para public 'CODE' use32
.text$mn:000004D8                 assume cs:_text$mn
.text$mn:000004D8                 ;org 4D8h
.text$mn:000004D8 ; COMDAT (pick any)
.text$mn:000004D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000004D8
.text$mn:000004D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000004D8
.text$mn:000004D8 ; Attributes: bp-based frame
.text$mn:000004D8
.text$mn:000004D8 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000004D8                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000004D8 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000004D8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000004D8
.text$mn:000004D8 arg_0           = dword ptr  8
.text$mn:000004D8 arg_4           = dword ptr  0Ch
.text$mn:000004D8 arg_8           = dword ptr  10h
.text$mn:000004D8
.text$mn:000004D8                 push    ebp
.text$mn:000004D9                 mov     ebp, esp
.text$mn:000004DB                 mov     eax, [ebp+arg_8]
.text$mn:000004DE                 push    eax
.text$mn:000004DF                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000004E4                 add     esp, 4
.text$mn:000004E7                 push    eax             ; int
.text$mn:000004E8                 mov     ecx, [ebp+arg_4]
.text$mn:000004EB                 push    ecx             ; void *
.text$mn:000004EC                 mov     ecx, [ebp+arg_0]
.text$mn:000004EF                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:000004F4                 pop     ebp
.text$mn:000004F5                 retn
.text$mn:000004F5 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:000004F5
.text$mn:000004F5 ; ---------------------------------------------------------------------------
.text$mn:000004F6                 align 4
.text$mn:000004F6 _text$mn        ends
.text$mn:000004F6
.text$mn:000004F8 ; ===========================================================================
.text$mn:000004F8
.text$mn:000004F8 ; Segment type: Pure code
.text$mn:000004F8 ; Segment permissions: Read/Execute
.text$mn:000004F8 _text$mn        segment para public 'CODE' use32
.text$mn:000004F8                 assume cs:_text$mn
.text$mn:000004F8                 ;org 4F8h
.text$mn:000004F8 ; COMDAT (pick any)
.text$mn:000004F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000004F8
.text$mn:000004F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000004F8
.text$mn:000004F8 ; Attributes: bp-based frame
.text$mn:000004F8
.text$mn:000004F8 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:000004F8                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:000004F8 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:000004F8                                         ; CODE XREF: $LN19_0+4Bp
.text$mn:000004F8
.text$mn:000004F8 var_4           = dword ptr -4
.text$mn:000004F8 arg_0           = dword ptr  8
.text$mn:000004F8 arg_4           = dword ptr  0Ch
.text$mn:000004F8
.text$mn:000004F8                 push    ebp
.text$mn:000004F9                 mov     ebp, esp
.text$mn:000004FB                 push    ecx
.text$mn:000004FC                 mov     [ebp+var_4], ecx
.text$mn:000004FF                 mov     eax, [ebp+arg_4]
.text$mn:00000502                 push    eax
.text$mn:00000503                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000508                 add     esp, 4
.text$mn:0000050B                 push    eax             ; int
.text$mn:0000050C                 mov     ecx, [ebp+arg_0]
.text$mn:0000050F                 push    ecx             ; void *
.text$mn:00000510                 mov     edx, [ebp+var_4]
.text$mn:00000513                 push    edx             ; int
.text$mn:00000514                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:00000519                 add     esp, 0Ch
.text$mn:0000051C                 mov     esp, ebp
.text$mn:0000051E                 pop     ebp
.text$mn:0000051F                 retn    8
.text$mn:0000051F ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:0000051F
.text$mn:0000051F ; ---------------------------------------------------------------------------
.text$mn:00000522                 align 4
.text$mn:00000522 _text$mn        ends
.text$mn:00000522
.text$mn:00000524 ; ===========================================================================
.text$mn:00000524
.text$mn:00000524 ; Segment type: Pure code
.text$mn:00000524 ; Segment permissions: Read/Execute
.text$mn:00000524 _text$mn        segment para public 'CODE' use32
.text$mn:00000524                 assume cs:_text$mn
.text$mn:00000524                 ;org 524h
.text$mn:00000524 ; COMDAT (pick any)
.text$mn:00000524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000524
.text$mn:00000524 ; =============== S U B R O U T I N E =======================================
.text$mn:00000524
.text$mn:00000524 ; Attributes: bp-based frame
.text$mn:00000524
.text$mn:00000524 ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00000524                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00000524 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00000524                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:00000524
.text$mn:00000524 var_1C          = dword ptr -1Ch
.text$mn:00000524 var_18          = dword ptr -18h
.text$mn:00000524 var_14          = dword ptr -14h
.text$mn:00000524 var_10          = dword ptr -10h
.text$mn:00000524 var_C           = dword ptr -0Ch
.text$mn:00000524 var_4           = dword ptr -4
.text$mn:00000524 arg_0           = dword ptr  8
.text$mn:00000524 arg_4           = dword ptr  0Ch
.text$mn:00000524
.text$mn:00000524                 push    ebp
.text$mn:00000525                 mov     ebp, esp
.text$mn:00000527                 push    0FFFFFFFFh
.text$mn:00000529                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:0000052E                 mov     eax, large fs:0
.text$mn:00000534                 push    eax
.text$mn:00000535                 sub     esp, 10h
.text$mn:00000538                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000053D                 xor     eax, ebp
.text$mn:0000053F                 push    eax
.text$mn:00000540                 lea     eax, [ebp+var_C]
.text$mn:00000543                 mov     large fs:0, eax
.text$mn:00000549                 mov     [ebp+var_18], ecx
.text$mn:0000054C                 mov     eax, [ebp+arg_0]
.text$mn:0000054F                 push    eax             ; void *
.text$mn:00000550                 push    4               ; unsigned int
.text$mn:00000552                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000557                 add     esp, 8
.text$mn:0000055A                 mov     [ebp+var_10], eax
.text$mn:0000055D                 mov     [ebp+var_4], 0
.text$mn:00000564                 cmp     [ebp+var_10], 0
.text$mn:00000568                 jz      short loc_585
.text$mn:0000056A                 mov     ecx, [ebp+arg_4]
.text$mn:0000056D                 push    ecx
.text$mn:0000056E                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000573                 add     esp, 4
.text$mn:00000576                 mov     edx, [ebp+var_10]
.text$mn:00000579                 mov     eax, [eax]
.text$mn:0000057B                 mov     [edx], eax
.text$mn:0000057D                 mov     ecx, [ebp+var_10]
.text$mn:00000580                 mov     [ebp+var_14], ecx
.text$mn:00000583                 jmp     short loc_58C
.text$mn:00000585 ; ---------------------------------------------------------------------------
.text$mn:00000585
.text$mn:00000585 loc_585:                                ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:00000585                 mov     [ebp+var_14], 0
.text$mn:0000058C
.text$mn:0000058C loc_58C:                                ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:0000058C                 mov     edx, [ebp+var_14]
.text$mn:0000058F                 mov     [ebp+var_1C], edx
.text$mn:00000592                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000599                 mov     ecx, [ebp+var_C]
.text$mn:0000059C                 mov     large fs:0, ecx
.text$mn:000005A3                 pop     ecx
.text$mn:000005A4                 mov     esp, ebp
.text$mn:000005A6                 pop     ebp
.text$mn:000005A7                 retn    8
.text$mn:000005A7 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:000005A7
.text$mn:000005A7 ; ---------------------------------------------------------------------------
.text$mn:000005AA                 align 4
.text$mn:000005AA _text$mn        ends
.text$mn:000005AA
.text$x:000005AC ; ===========================================================================
.text$x:000005AC
.text$x:000005AC ; Segment type: Pure code
.text$x:000005AC ; Segment permissions: Read/Execute
.text$x:000005AC _text$x         segment para public 'CODE' use32
.text$x:000005AC                 assume cs:_text$x
.text$x:000005AC                 ;org 5ACh
.text$x:000005AC ; COMDAT (pick associative to section at 524)
.text$x:000005AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000005AC
.text$x:000005AC ; =============== S U B R O U T I N E =======================================
.text$x:000005AC
.text$x:000005AC
.text$x:000005AC __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:000005AC                                         ; DATA XREF: .xdata$x:00002CECo
.text$x:000005AC                 mov     eax, [ebp+8]
.text$x:000005AF                 push    eax
.text$x:000005B0                 mov     eax, [ebp-10h]
.text$x:000005B3                 push    eax             ; void *
.text$x:000005B4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000005B9                 add     esp, 8
.text$x:000005BC                 retn
.text$x:000005BC __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:000005BC
.text$x:000005BD
.text$x:000005BD ; =============== S U B R O U T I N E =======================================
.text$x:000005BD
.text$x:000005BD
.text$x:000005BD __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:000005BD                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:000005BD
.text$x:000005BD arg_4           = dword ptr  8
.text$x:000005BD
.text$x:000005BD                 mov     edx, [esp+arg_4]
.text$x:000005C1                 lea     eax, [edx+0Ch]
.text$x:000005C4                 mov     ecx, [edx-14h]
.text$x:000005C7                 xor     ecx, eax
.text$x:000005C9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000005CE                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:000005D3                 jmp     ___CxxFrameHandler3
.text$x:000005D3 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:000005D3
.text$x:000005D3 _text$x         ends
.text$x:000005D3
.text$mn:000005D8 ; ===========================================================================
.text$mn:000005D8
.text$mn:000005D8 ; Segment type: Pure code
.text$mn:000005D8 ; Segment permissions: Read/Execute
.text$mn:000005D8 _text$mn        segment para public 'CODE' use32
.text$mn:000005D8                 assume cs:_text$mn
.text$mn:000005D8                 ;org 5D8h
.text$mn:000005D8 ; COMDAT (pick any)
.text$mn:000005D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000005D8
.text$mn:000005D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000005D8
.text$mn:000005D8 ; Attributes: bp-based frame
.text$mn:000005D8
.text$mn:000005D8 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:000005D8                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:000005D8 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:000005D8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:000005D8
.text$mn:000005D8 arg_0           = dword ptr  8
.text$mn:000005D8 arg_4           = dword ptr  0Ch
.text$mn:000005D8 arg_8           = dword ptr  10h
.text$mn:000005D8
.text$mn:000005D8                 push    ebp
.text$mn:000005D9                 mov     ebp, esp
.text$mn:000005DB                 mov     eax, [ebp+arg_8]
.text$mn:000005DE                 push    eax
.text$mn:000005DF                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000005E4                 add     esp, 4
.text$mn:000005E7                 push    eax             ; int
.text$mn:000005E8                 mov     ecx, [ebp+arg_4]
.text$mn:000005EB                 push    ecx             ; void *
.text$mn:000005EC                 mov     ecx, [ebp+arg_0]
.text$mn:000005EF                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:000005F4                 pop     ebp
.text$mn:000005F5                 retn
.text$mn:000005F5 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:000005F5
.text$mn:000005F5 ; ---------------------------------------------------------------------------
.text$mn:000005F6                 align 4
.text$mn:000005F6 _text$mn        ends
.text$mn:000005F6
.text$mn:000005F8 ; ===========================================================================
.text$mn:000005F8
.text$mn:000005F8 ; Segment type: Pure code
.text$mn:000005F8 ; Segment permissions: Read/Execute
.text$mn:000005F8 _text$mn        segment para public 'CODE' use32
.text$mn:000005F8                 assume cs:_text$mn
.text$mn:000005F8                 ;org 5F8h
.text$mn:000005F8 ; COMDAT (pick any)
.text$mn:000005F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000005F8
.text$mn:000005F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000005F8
.text$mn:000005F8 ; Attributes: bp-based frame
.text$mn:000005F8
.text$mn:000005F8 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000005F8                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000005F8 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000005F8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:000005F8
.text$mn:000005F8 var_1C          = dword ptr -1Ch
.text$mn:000005F8 var_18          = dword ptr -18h
.text$mn:000005F8 var_14          = dword ptr -14h
.text$mn:000005F8 var_10          = dword ptr -10h
.text$mn:000005F8 var_C           = dword ptr -0Ch
.text$mn:000005F8 var_4           = dword ptr -4
.text$mn:000005F8 arg_0           = dword ptr  8
.text$mn:000005F8 arg_4           = dword ptr  0Ch
.text$mn:000005F8
.text$mn:000005F8                 push    ebp
.text$mn:000005F9                 mov     ebp, esp
.text$mn:000005FB                 push    0FFFFFFFFh
.text$mn:000005FD                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000602                 mov     eax, large fs:0
.text$mn:00000608                 push    eax
.text$mn:00000609                 sub     esp, 10h
.text$mn:0000060C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000611                 xor     eax, ebp
.text$mn:00000613                 push    eax
.text$mn:00000614                 lea     eax, [ebp+var_C]
.text$mn:00000617                 mov     large fs:0, eax
.text$mn:0000061D                 mov     [ebp+var_18], ecx
.text$mn:00000620                 mov     eax, [ebp+arg_0]
.text$mn:00000623                 push    eax             ; void *
.text$mn:00000624                 push    8               ; unsigned int
.text$mn:00000626                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000062B                 add     esp, 8
.text$mn:0000062E                 mov     [ebp+var_10], eax
.text$mn:00000631                 mov     [ebp+var_4], 0
.text$mn:00000638                 cmp     [ebp+var_10], 0
.text$mn:0000063C                 jz      short loc_65F
.text$mn:0000063E                 mov     ecx, [ebp+arg_4]
.text$mn:00000641                 push    ecx
.text$mn:00000642                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00000647                 add     esp, 4
.text$mn:0000064A                 mov     edx, [eax]
.text$mn:0000064C                 mov     eax, [eax+4]
.text$mn:0000064F                 mov     ecx, [ebp+var_10]
.text$mn:00000652                 mov     [ecx], edx
.text$mn:00000654                 mov     [ecx+4], eax
.text$mn:00000657                 mov     edx, [ebp+var_10]
.text$mn:0000065A                 mov     [ebp+var_14], edx
.text$mn:0000065D                 jmp     short loc_666
.text$mn:0000065F ; ---------------------------------------------------------------------------
.text$mn:0000065F
.text$mn:0000065F loc_65F:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:0000065F                 mov     [ebp+var_14], 0
.text$mn:00000666
.text$mn:00000666 loc_666:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00000666                 mov     eax, [ebp+var_14]
.text$mn:00000669                 mov     [ebp+var_1C], eax
.text$mn:0000066C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000673                 mov     ecx, [ebp+var_C]
.text$mn:00000676                 mov     large fs:0, ecx
.text$mn:0000067D                 pop     ecx
.text$mn:0000067E                 mov     esp, ebp
.text$mn:00000680                 pop     ebp
.text$mn:00000681                 retn    8
.text$mn:00000681 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00000681
.text$mn:00000681 _text$mn        ends
.text$mn:00000681
.text$x:00000684 ; ===========================================================================
.text$x:00000684
.text$x:00000684 ; Segment type: Pure code
.text$x:00000684 ; Segment permissions: Read/Execute
.text$x:00000684 _text$x         segment para public 'CODE' use32
.text$x:00000684                 assume cs:_text$x
.text$x:00000684                 ;org 684h
.text$x:00000684 ; COMDAT (pick associative to section at 5F8)
.text$x:00000684                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000684
.text$x:00000684 ; =============== S U B R O U T I N E =======================================
.text$x:00000684
.text$x:00000684
.text$x:00000684 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00000684                                         ; DATA XREF: .xdata$x:00002C94o
.text$x:00000684                 mov     eax, [ebp+8]
.text$x:00000687                 push    eax
.text$x:00000688                 mov     eax, [ebp-10h]
.text$x:0000068B                 push    eax             ; void *
.text$x:0000068C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000691                 add     esp, 8
.text$x:00000694                 retn
.text$x:00000694 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00000694
.text$x:00000695
.text$x:00000695 ; =============== S U B R O U T I N E =======================================
.text$x:00000695
.text$x:00000695
.text$x:00000695 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00000695                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00000695
.text$x:00000695 arg_4           = dword ptr  8
.text$x:00000695
.text$x:00000695                 mov     edx, [esp+arg_4]
.text$x:00000699                 lea     eax, [edx+0Ch]
.text$x:0000069C                 mov     ecx, [edx-14h]
.text$x:0000069F                 xor     ecx, eax
.text$x:000006A1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000006A6                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000006AB                 jmp     ___CxxFrameHandler3
.text$x:000006AB __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000006AB
.text$x:000006AB _text$x         ends
.text$x:000006AB
.text$mn:000006B0 ; ===========================================================================
.text$mn:000006B0
.text$mn:000006B0 ; Segment type: Pure code
.text$mn:000006B0 ; Segment permissions: Read/Execute
.text$mn:000006B0 _text$mn        segment para public 'CODE' use32
.text$mn:000006B0                 assume cs:_text$mn
.text$mn:000006B0                 ;org 6B0h
.text$mn:000006B0 ; COMDAT (pick any)
.text$mn:000006B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000006B0
.text$mn:000006B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000006B0
.text$mn:000006B0 ; Attributes: bp-based frame
.text$mn:000006B0
.text$mn:000006B0 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000006B0                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:000006B0 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:000006B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:000006B0
.text$mn:000006B0 var_4           = dword ptr -4
.text$mn:000006B0 arg_0           = dword ptr  8
.text$mn:000006B0
.text$mn:000006B0                 push    ebp
.text$mn:000006B1                 mov     ebp, esp
.text$mn:000006B3                 push    ecx
.text$mn:000006B4                 mov     [ebp+var_4], ecx
.text$mn:000006B7                 mov     eax, [ebp+arg_0]
.text$mn:000006BA                 push    eax
.text$mn:000006BB                 mov     ecx, [ebp+var_4]
.text$mn:000006BE                 push    ecx
.text$mn:000006BF                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:000006C4                 add     esp, 8
.text$mn:000006C7                 mov     esp, ebp
.text$mn:000006C9                 pop     ebp
.text$mn:000006CA                 retn    4
.text$mn:000006CA ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:000006CA
.text$mn:000006CA ; ---------------------------------------------------------------------------
.text$mn:000006CD                 align 10h
.text$mn:000006CD _text$mn        ends
.text$mn:000006CD
.text$mn:000006D0 ; ===========================================================================
.text$mn:000006D0
.text$mn:000006D0 ; Segment type: Pure code
.text$mn:000006D0 ; Segment permissions: Read/Execute
.text$mn:000006D0 _text$mn        segment para public 'CODE' use32
.text$mn:000006D0                 assume cs:_text$mn
.text$mn:000006D0                 ;org 6D0h
.text$mn:000006D0 ; COMDAT (pick any)
.text$mn:000006D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000006D0
.text$mn:000006D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000006D0
.text$mn:000006D0 ; Attributes: bp-based frame
.text$mn:000006D0
.text$mn:000006D0 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:000006D0                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:000006D0 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:000006D0                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:000006D0
.text$mn:000006D0 var_4           = dword ptr -4
.text$mn:000006D0
.text$mn:000006D0                 push    ebp
.text$mn:000006D1                 mov     ebp, esp
.text$mn:000006D3                 push    ecx
.text$mn:000006D4                 mov     [ebp+var_4], ecx
.text$mn:000006D7                 mov     esp, ebp
.text$mn:000006D9                 pop     ebp
.text$mn:000006DA                 retn    4
.text$mn:000006DA ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:000006DA
.text$mn:000006DA ; ---------------------------------------------------------------------------
.text$mn:000006DD                 align 10h
.text$mn:000006DD _text$mn        ends
.text$mn:000006DD
.text$mn:000006E0 ; ===========================================================================
.text$mn:000006E0
.text$mn:000006E0 ; Segment type: Pure code
.text$mn:000006E0 ; Segment permissions: Read/Execute
.text$mn:000006E0 _text$mn        segment para public 'CODE' use32
.text$mn:000006E0                 assume cs:_text$mn
.text$mn:000006E0                 ;org 6E0h
.text$mn:000006E0 ; COMDAT (pick any)
.text$mn:000006E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000006E0
.text$mn:000006E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000006E0
.text$mn:000006E0 ; Attributes: bp-based frame
.text$mn:000006E0
.text$mn:000006E0 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:000006E0                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:000006E0 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:000006E0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:000006E0
.text$mn:000006E0 arg_0           = dword ptr  8
.text$mn:000006E0 arg_4           = dword ptr  0Ch
.text$mn:000006E0
.text$mn:000006E0                 push    ebp
.text$mn:000006E1                 mov     ebp, esp
.text$mn:000006E3                 mov     eax, [ebp+arg_4]
.text$mn:000006E6                 push    eax
.text$mn:000006E7                 mov     ecx, [ebp+arg_0]
.text$mn:000006EA                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:000006EF                 pop     ebp
.text$mn:000006F0                 retn
.text$mn:000006F0 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:000006F0
.text$mn:000006F0 ; ---------------------------------------------------------------------------
.text$mn:000006F1                 align 4
.text$mn:000006F1 _text$mn        ends
.text$mn:000006F1
.text$mn:000006F4 ; ===========================================================================
.text$mn:000006F4
.text$mn:000006F4 ; Segment type: Pure code
.text$mn:000006F4 ; Segment permissions: Read/Execute
.text$mn:000006F4 _text$mn        segment para public 'CODE' use32
.text$mn:000006F4                 assume cs:_text$mn
.text$mn:000006F4                 ;org 6F4h
.text$mn:000006F4 ; COMDAT (pick any)
.text$mn:000006F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000006F4
.text$mn:000006F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000006F4
.text$mn:000006F4 ; Attributes: bp-based frame
.text$mn:000006F4
.text$mn:000006F4 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:000006F4                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:000006F4 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:000006F4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:000006F4
.text$mn:000006F4 var_4           = dword ptr -4
.text$mn:000006F4 arg_0           = dword ptr  8
.text$mn:000006F4
.text$mn:000006F4                 push    ebp
.text$mn:000006F5                 mov     ebp, esp
.text$mn:000006F7                 push    ecx
.text$mn:000006F8                 mov     [ebp+var_4], ecx
.text$mn:000006FB                 mov     eax, [ebp+arg_0]
.text$mn:000006FE                 push    eax
.text$mn:000006FF                 mov     ecx, [ebp+var_4]
.text$mn:00000702                 push    ecx
.text$mn:00000703                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00000708                 add     esp, 8
.text$mn:0000070B                 mov     esp, ebp
.text$mn:0000070D                 pop     ebp
.text$mn:0000070E                 retn    4
.text$mn:0000070E ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:0000070E
.text$mn:0000070E ; ---------------------------------------------------------------------------
.text$mn:00000711                 align 4
.text$mn:00000711 _text$mn        ends
.text$mn:00000711
.text$mn:00000714 ; ===========================================================================
.text$mn:00000714
.text$mn:00000714 ; Segment type: Pure code
.text$mn:00000714 ; Segment permissions: Read/Execute
.text$mn:00000714 _text$mn        segment para public 'CODE' use32
.text$mn:00000714                 assume cs:_text$mn
.text$mn:00000714                 ;org 714h
.text$mn:00000714 ; COMDAT (pick any)
.text$mn:00000714                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000714
.text$mn:00000714 ; =============== S U B R O U T I N E =======================================
.text$mn:00000714
.text$mn:00000714 ; Attributes: bp-based frame
.text$mn:00000714
.text$mn:00000714 ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00000714                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:00000714 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:00000714                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:00000714
.text$mn:00000714 var_4           = dword ptr -4
.text$mn:00000714
.text$mn:00000714                 push    ebp
.text$mn:00000715                 mov     ebp, esp
.text$mn:00000717                 push    ecx
.text$mn:00000718                 mov     [ebp+var_4], ecx
.text$mn:0000071B                 mov     esp, ebp
.text$mn:0000071D                 pop     ebp
.text$mn:0000071E                 retn    4
.text$mn:0000071E ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:0000071E
.text$mn:0000071E ; ---------------------------------------------------------------------------
.text$mn:00000721                 align 4
.text$mn:00000721 _text$mn        ends
.text$mn:00000721
.text$mn:00000724 ; ===========================================================================
.text$mn:00000724
.text$mn:00000724 ; Segment type: Pure code
.text$mn:00000724 ; Segment permissions: Read/Execute
.text$mn:00000724 _text$mn        segment para public 'CODE' use32
.text$mn:00000724                 assume cs:_text$mn
.text$mn:00000724                 ;org 724h
.text$mn:00000724 ; COMDAT (pick any)
.text$mn:00000724                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000724
.text$mn:00000724 ; =============== S U B R O U T I N E =======================================
.text$mn:00000724
.text$mn:00000724 ; Attributes: bp-based frame
.text$mn:00000724
.text$mn:00000724 ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00000724                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00000724 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00000724                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00000724
.text$mn:00000724 arg_0           = dword ptr  8
.text$mn:00000724 arg_4           = dword ptr  0Ch
.text$mn:00000724
.text$mn:00000724                 push    ebp
.text$mn:00000725                 mov     ebp, esp
.text$mn:00000727                 mov     eax, [ebp+arg_4]
.text$mn:0000072A                 push    eax
.text$mn:0000072B                 mov     ecx, [ebp+arg_0]
.text$mn:0000072E                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00000733                 pop     ebp
.text$mn:00000734                 retn
.text$mn:00000734 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:00000734
.text$mn:00000734 ; ---------------------------------------------------------------------------
.text$mn:00000735                 align 4
.text$mn:00000735 _text$mn        ends
.text$mn:00000735
.text$mn:00000738 ; ===========================================================================
.text$mn:00000738
.text$mn:00000738 ; Segment type: Pure code
.text$mn:00000738 ; Segment permissions: Read/Execute
.text$mn:00000738 _text$mn        segment para public 'CODE' use32
.text$mn:00000738                 assume cs:_text$mn
.text$mn:00000738                 ;org 738h
.text$mn:00000738 ; COMDAT (pick any)
.text$mn:00000738                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000738
.text$mn:00000738 ; =============== S U B R O U T I N E =======================================
.text$mn:00000738
.text$mn:00000738 ; Attributes: bp-based frame
.text$mn:00000738
.text$mn:00000738 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00000738                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00000738 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00000738                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00000738
.text$mn:00000738 var_4           = dword ptr -4
.text$mn:00000738
.text$mn:00000738                 push    ebp
.text$mn:00000739                 mov     ebp, esp
.text$mn:0000073B                 push    ecx
.text$mn:0000073C                 mov     [ebp+var_4], ecx
.text$mn:0000073F                 mov     esp, ebp
.text$mn:00000741                 pop     ebp
.text$mn:00000742                 retn    4
.text$mn:00000742 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00000742
.text$mn:00000742 ; ---------------------------------------------------------------------------
.text$mn:00000745                 align 4
.text$mn:00000745 _text$mn        ends
.text$mn:00000745
.text$mn:00000748 ; ===========================================================================
.text$mn:00000748
.text$mn:00000748 ; Segment type: Pure code
.text$mn:00000748 ; Segment permissions: Read/Execute
.text$mn:00000748 _text$mn        segment para public 'CODE' use32
.text$mn:00000748                 assume cs:_text$mn
.text$mn:00000748                 ;org 748h
.text$mn:00000748 ; COMDAT (pick any)
.text$mn:00000748                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000748
.text$mn:00000748 ; =============== S U B R O U T I N E =======================================
.text$mn:00000748
.text$mn:00000748 ; Attributes: bp-based frame
.text$mn:00000748
.text$mn:00000748 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00000748                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00000748 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00000748                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00000748                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00000748
.text$mn:00000748 arg_0           = dword ptr  8
.text$mn:00000748
.text$mn:00000748                 push    ebp
.text$mn:00000749                 mov     ebp, esp
.text$mn:0000074B                 mov     eax, [ebp+arg_0]
.text$mn:0000074E                 pop     ebp
.text$mn:0000074F                 retn
.text$mn:0000074F ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:0000074F
.text$mn:0000074F _text$mn        ends
.text$mn:0000074F
.text$mn:00000750 ; ===========================================================================
.text$mn:00000750
.text$mn:00000750 ; Segment type: Pure code
.text$mn:00000750 ; Segment permissions: Read/Execute
.text$mn:00000750 _text$mn        segment para public 'CODE' use32
.text$mn:00000750                 assume cs:_text$mn
.text$mn:00000750                 ;org 750h
.text$mn:00000750 ; COMDAT (pick any)
.text$mn:00000750                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000750
.text$mn:00000750 ; =============== S U B R O U T I N E =======================================
.text$mn:00000750
.text$mn:00000750 ; Attributes: bp-based frame
.text$mn:00000750
.text$mn:00000750 ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000750                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:00000750 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:00000750                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:00000750                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:00000750
.text$mn:00000750 arg_0           = dword ptr  8
.text$mn:00000750
.text$mn:00000750                 push    ebp
.text$mn:00000751                 mov     ebp, esp
.text$mn:00000753                 mov     eax, [ebp+arg_0]
.text$mn:00000756                 pop     ebp
.text$mn:00000757                 retn
.text$mn:00000757 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:00000757
.text$mn:00000757 _text$mn        ends
.text$mn:00000757
.text$mn:00000758 ; ===========================================================================
.text$mn:00000758
.text$mn:00000758 ; Segment type: Pure code
.text$mn:00000758 ; Segment permissions: Read/Execute
.text$mn:00000758 _text$mn        segment para public 'CODE' use32
.text$mn:00000758                 assume cs:_text$mn
.text$mn:00000758                 ;org 758h
.text$mn:00000758 ; COMDAT (pick any)
.text$mn:00000758                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000758
.text$mn:00000758 ; =============== S U B R O U T I N E =======================================
.text$mn:00000758
.text$mn:00000758 ; Attributes: bp-based frame
.text$mn:00000758
.text$mn:00000758 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00000758                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00000758 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00000758                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00000758
.text$mn:00000758 arg_0           = dword ptr  8
.text$mn:00000758
.text$mn:00000758                 push    ebp
.text$mn:00000759                 mov     ebp, esp
.text$mn:0000075B                 mov     eax, [ebp+arg_0]
.text$mn:0000075E                 pop     ebp
.text$mn:0000075F                 retn
.text$mn:0000075F ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:0000075F
.text$mn:0000075F _text$mn        ends
.text$mn:0000075F
.text$mn:00000760 ; ===========================================================================
.text$mn:00000760
.text$mn:00000760 ; Segment type: Pure code
.text$mn:00000760 ; Segment permissions: Read/Execute
.text$mn:00000760 _text$mn        segment para public 'CODE' use32
.text$mn:00000760                 assume cs:_text$mn
.text$mn:00000760                 ;org 760h
.text$mn:00000760 ; COMDAT (pick any)
.text$mn:00000760                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000760
.text$mn:00000760 ; =============== S U B R O U T I N E =======================================
.text$mn:00000760
.text$mn:00000760 ; Attributes: bp-based frame
.text$mn:00000760
.text$mn:00000760 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00000760                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000760 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00000760                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00000760
.text$mn:00000760 var_10          = dword ptr -10h
.text$mn:00000760 var_C           = dword ptr -0Ch
.text$mn:00000760 var_4           = dword ptr -4
.text$mn:00000760
.text$mn:00000760                 push    ebp
.text$mn:00000761                 mov     ebp, esp
.text$mn:00000763                 push    0FFFFFFFFh
.text$mn:00000765                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000076A                 mov     eax, large fs:0
.text$mn:00000770                 push    eax
.text$mn:00000771                 push    ecx
.text$mn:00000772                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000777                 xor     eax, ebp
.text$mn:00000779                 push    eax
.text$mn:0000077A                 lea     eax, [ebp+var_C]
.text$mn:0000077D                 mov     large fs:0, eax
.text$mn:00000783                 mov     [ebp+var_10], ecx
.text$mn:00000786                 mov     ecx, [ebp+var_10]
.text$mn:00000789                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:0000078E                 mov     [ebp+var_4], 0
.text$mn:00000795                 mov     ecx, [ebp+var_10]
.text$mn:00000798                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:0000079D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000007A4                 mov     eax, [ebp+var_10]
.text$mn:000007A7                 mov     ecx, [ebp+var_C]
.text$mn:000007AA                 mov     large fs:0, ecx
.text$mn:000007B1                 pop     ecx
.text$mn:000007B2                 mov     esp, ebp
.text$mn:000007B4                 pop     ebp
.text$mn:000007B5                 retn    4
.text$mn:000007B5 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:000007B5
.text$mn:000007B5 _text$mn        ends
.text$mn:000007B5
.text$x:000007B8 ; ===========================================================================
.text$x:000007B8
.text$x:000007B8 ; Segment type: Pure code
.text$x:000007B8 ; Segment permissions: Read/Execute
.text$x:000007B8 _text$x         segment para public 'CODE' use32
.text$x:000007B8                 assume cs:_text$x
.text$x:000007B8                 ;org 7B8h
.text$x:000007B8 ; COMDAT (pick associative to section at 760)
.text$x:000007B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000007B8
.text$x:000007B8 ; =============== S U B R O U T I N E =======================================
.text$x:000007B8
.text$x:000007B8
.text$x:000007B8 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:000007B8                                         ; DATA XREF: .xdata$x:000028BCo
.text$x:000007B8                 mov     ecx, [ebp-10h]
.text$x:000007BB                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000007BB __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:000007BB
.text$x:000007C0
.text$x:000007C0 ; =============== S U B R O U T I N E =======================================
.text$x:000007C0
.text$x:000007C0
.text$x:000007C0 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:000007C0                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:000007C0
.text$x:000007C0 arg_4           = dword ptr  8
.text$x:000007C0
.text$x:000007C0                 mov     edx, [esp+arg_4]
.text$x:000007C4                 lea     eax, [edx+0Ch]
.text$x:000007C7                 mov     ecx, [edx-8]
.text$x:000007CA                 xor     ecx, eax
.text$x:000007CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000007D1                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000007D6                 jmp     ___CxxFrameHandler3
.text$x:000007D6 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000007D6
.text$x:000007D6 ; ---------------------------------------------------------------------------
.text$x:000007DB                 align 4
.text$x:000007DB _text$x         ends
.text$x:000007DB
.text$mn:000007DC ; ===========================================================================
.text$mn:000007DC
.text$mn:000007DC ; Segment type: Pure code
.text$mn:000007DC ; Segment permissions: Read/Execute
.text$mn:000007DC _text$mn        segment para public 'CODE' use32
.text$mn:000007DC                 assume cs:_text$mn
.text$mn:000007DC                 ;org 7DCh
.text$mn:000007DC ; COMDAT (pick any)
.text$mn:000007DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000007DC
.text$mn:000007DC ; =============== S U B R O U T I N E =======================================
.text$mn:000007DC
.text$mn:000007DC ; Attributes: bp-based frame
.text$mn:000007DC
.text$mn:000007DC ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000007DC                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000007DC ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000007DC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:000007DC
.text$mn:000007DC var_10          = dword ptr -10h
.text$mn:000007DC var_C           = dword ptr -0Ch
.text$mn:000007DC var_4           = dword ptr -4
.text$mn:000007DC
.text$mn:000007DC                 push    ebp
.text$mn:000007DD                 mov     ebp, esp
.text$mn:000007DF                 push    0FFFFFFFFh
.text$mn:000007E1                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000007E6                 mov     eax, large fs:0
.text$mn:000007EC                 push    eax
.text$mn:000007ED                 push    ecx
.text$mn:000007EE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000007F3                 xor     eax, ebp
.text$mn:000007F5                 push    eax
.text$mn:000007F6                 lea     eax, [ebp+var_C]
.text$mn:000007F9                 mov     large fs:0, eax
.text$mn:000007FF                 mov     [ebp+var_10], ecx
.text$mn:00000802                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000805                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000080A                 mov     [ebp+var_4], 0
.text$mn:00000811                 mov     eax, [ebp+var_10]
.text$mn:00000814                 mov     dword ptr [eax+14h], 0
.text$mn:0000081B                 mov     ecx, [ebp+var_10]
.text$mn:0000081E                 mov     dword ptr [ecx+18h], 0
.text$mn:00000825                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000082C                 mov     eax, [ebp+var_10]
.text$mn:0000082F                 mov     ecx, [ebp+var_C]
.text$mn:00000832                 mov     large fs:0, ecx
.text$mn:00000839                 pop     ecx
.text$mn:0000083A                 mov     esp, ebp
.text$mn:0000083C                 pop     ebp
.text$mn:0000083D                 retn
.text$mn:0000083D ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000083D
.text$mn:0000083D ; ---------------------------------------------------------------------------
.text$mn:0000083E                 align 10h
.text$mn:0000083E _text$mn        ends
.text$mn:0000083E
.text$x:00000840 ; ===========================================================================
.text$x:00000840
.text$x:00000840 ; Segment type: Pure code
.text$x:00000840 ; Segment permissions: Read/Execute
.text$x:00000840 _text$x         segment para public 'CODE' use32
.text$x:00000840                 assume cs:_text$x
.text$x:00000840                 ;org 840h
.text$x:00000840 ; COMDAT (pick associative to section at 7DC)
.text$x:00000840                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000840
.text$x:00000840 ; =============== S U B R O U T I N E =======================================
.text$x:00000840
.text$x:00000840
.text$x:00000840 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000840                                         ; DATA XREF: .xdata$x:00002864o
.text$x:00000840                 mov     ecx, [ebp-10h]  ; this
.text$x:00000843                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000843 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000843
.text$x:00000848
.text$x:00000848 ; =============== S U B R O U T I N E =======================================
.text$x:00000848
.text$x:00000848
.text$x:00000848 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000848                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000848
.text$x:00000848 arg_4           = dword ptr  8
.text$x:00000848
.text$x:00000848                 mov     edx, [esp+arg_4]
.text$x:0000084C                 lea     eax, [edx+0Ch]
.text$x:0000084F                 mov     ecx, [edx-8]
.text$x:00000852                 xor     ecx, eax
.text$x:00000854                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000859                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000085E                 jmp     ___CxxFrameHandler3
.text$x:0000085E __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000085E
.text$x:0000085E ; ---------------------------------------------------------------------------
.text$x:00000863                 align 4
.text$x:00000863 _text$x         ends
.text$x:00000863
.text$mn:00000864 ; ===========================================================================
.text$mn:00000864
.text$mn:00000864 ; Segment type: Pure code
.text$mn:00000864 ; Segment permissions: Read/Execute
.text$mn:00000864 _text$mn        segment para public 'CODE' use32
.text$mn:00000864                 assume cs:_text$mn
.text$mn:00000864                 ;org 864h
.text$mn:00000864 ; COMDAT (pick any)
.text$mn:00000864                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000864
.text$mn:00000864 ; =============== S U B R O U T I N E =======================================
.text$mn:00000864
.text$mn:00000864 ; Attributes: bp-based frame
.text$mn:00000864
.text$mn:00000864 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00000864                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00000864 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00000864                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00000864
.text$mn:00000864 var_4           = dword ptr -4
.text$mn:00000864
.text$mn:00000864                 push    ebp
.text$mn:00000865                 mov     ebp, esp
.text$mn:00000867                 push    ecx
.text$mn:00000868                 mov     [ebp+var_4], ecx
.text$mn:0000086B                 mov     ecx, [ebp+var_4]
.text$mn:0000086E                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000873                 mov     eax, [ebp+var_4]
.text$mn:00000876                 mov     esp, ebp
.text$mn:00000878                 pop     ebp
.text$mn:00000879                 retn
.text$mn:00000879 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00000879
.text$mn:00000879 ; ---------------------------------------------------------------------------
.text$mn:0000087A                 align 4
.text$mn:0000087A _text$mn        ends
.text$mn:0000087A
.text$mn:0000087C ; ===========================================================================
.text$mn:0000087C
.text$mn:0000087C ; Segment type: Pure code
.text$mn:0000087C ; Segment permissions: Read/Execute
.text$mn:0000087C _text$mn        segment para public 'CODE' use32
.text$mn:0000087C                 assume cs:_text$mn
.text$mn:0000087C                 ;org 87Ch
.text$mn:0000087C ; COMDAT (pick any)
.text$mn:0000087C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000087C
.text$mn:0000087C ; =============== S U B R O U T I N E =======================================
.text$mn:0000087C
.text$mn:0000087C ; Attributes: bp-based frame
.text$mn:0000087C
.text$mn:0000087C ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:0000087C                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:0000087C ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:0000087C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:0000087C
.text$mn:0000087C var_4           = dword ptr -4
.text$mn:0000087C
.text$mn:0000087C                 push    ebp
.text$mn:0000087D                 mov     ebp, esp
.text$mn:0000087F                 push    ecx
.text$mn:00000880                 mov     [ebp+var_4], ecx
.text$mn:00000883                 mov     ecx, [ebp+var_4]
.text$mn:00000886                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:0000088B                 mov     eax, [ebp+var_4]
.text$mn:0000088E                 mov     esp, ebp
.text$mn:00000890                 pop     ebp
.text$mn:00000891                 retn
.text$mn:00000891 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00000891
.text$mn:00000891 ; ---------------------------------------------------------------------------
.text$mn:00000892                 align 4
.text$mn:00000892 _text$mn        ends
.text$mn:00000892
.text$mn:00000894 ; ===========================================================================
.text$mn:00000894
.text$mn:00000894 ; Segment type: Pure code
.text$mn:00000894 ; Segment permissions: Read/Execute
.text$mn:00000894 _text$mn        segment para public 'CODE' use32
.text$mn:00000894                 assume cs:_text$mn
.text$mn:00000894                 ;org 894h
.text$mn:00000894 ; COMDAT (pick any)
.text$mn:00000894                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000894
.text$mn:00000894 ; =============== S U B R O U T I N E =======================================
.text$mn:00000894
.text$mn:00000894 ; Attributes: bp-based frame
.text$mn:00000894
.text$mn:00000894 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00000894                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00000894 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00000894                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00000894
.text$mn:00000894 var_4           = dword ptr -4
.text$mn:00000894
.text$mn:00000894                 push    ebp
.text$mn:00000895                 mov     ebp, esp
.text$mn:00000897                 push    ecx
.text$mn:00000898                 mov     [ebp+var_4], ecx
.text$mn:0000089B                 mov     eax, [ebp+var_4]
.text$mn:0000089E                 mov     esp, ebp
.text$mn:000008A0                 pop     ebp
.text$mn:000008A1                 retn
.text$mn:000008A1 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:000008A1
.text$mn:000008A1 ; ---------------------------------------------------------------------------
.text$mn:000008A2                 align 4
.text$mn:000008A2 _text$mn        ends
.text$mn:000008A2
.text$mn:000008A4 ; ===========================================================================
.text$mn:000008A4
.text$mn:000008A4 ; Segment type: Pure code
.text$mn:000008A4 ; Segment permissions: Read/Execute
.text$mn:000008A4 _text$mn        segment para public 'CODE' use32
.text$mn:000008A4                 assume cs:_text$mn
.text$mn:000008A4                 ;org 8A4h
.text$mn:000008A4 ; COMDAT (pick any)
.text$mn:000008A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000008A4
.text$mn:000008A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000008A4
.text$mn:000008A4 ; Attributes: bp-based frame
.text$mn:000008A4
.text$mn:000008A4 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:000008A4                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:000008A4 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:000008A4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:000008A4                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:000008A4
.text$mn:000008A4 var_4           = dword ptr -4
.text$mn:000008A4
.text$mn:000008A4                 push    ebp
.text$mn:000008A5                 mov     ebp, esp
.text$mn:000008A7                 push    ecx
.text$mn:000008A8                 mov     [ebp+var_4], ecx
.text$mn:000008AB                 mov     eax, [ebp+var_4]
.text$mn:000008AE                 mov     esp, ebp
.text$mn:000008B0                 pop     ebp
.text$mn:000008B1                 retn
.text$mn:000008B1 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:000008B1
.text$mn:000008B1 ; ---------------------------------------------------------------------------
.text$mn:000008B2                 align 4
.text$mn:000008B2 _text$mn        ends
.text$mn:000008B2
.text$mn:000008B4 ; ===========================================================================
.text$mn:000008B4
.text$mn:000008B4 ; Segment type: Pure code
.text$mn:000008B4 ; Segment permissions: Read/Execute
.text$mn:000008B4 _text$mn        segment para public 'CODE' use32
.text$mn:000008B4                 assume cs:_text$mn
.text$mn:000008B4                 ;org 8B4h
.text$mn:000008B4 ; COMDAT (pick any)
.text$mn:000008B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000008B4
.text$mn:000008B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000008B4
.text$mn:000008B4 ; Attributes: bp-based frame
.text$mn:000008B4
.text$mn:000008B4 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000008B4                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:000008B4 ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:000008B4
.text$mn:000008B4 var_4           = dword ptr -4
.text$mn:000008B4
.text$mn:000008B4                 push    ebp
.text$mn:000008B5                 mov     ebp, esp
.text$mn:000008B7                 push    ecx
.text$mn:000008B8                 mov     [ebp+var_4], ecx
.text$mn:000008BB                 mov     eax, [ebp+var_4]
.text$mn:000008BE                 mov     esp, ebp
.text$mn:000008C0                 pop     ebp
.text$mn:000008C1                 retn
.text$mn:000008C1 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:000008C1
.text$mn:000008C1 ; ---------------------------------------------------------------------------
.text$mn:000008C2                 align 4
.text$mn:000008C2 _text$mn        ends
.text$mn:000008C2
.text$mn:000008C4 ; ===========================================================================
.text$mn:000008C4
.text$mn:000008C4 ; Segment type: Pure code
.text$mn:000008C4 ; Segment permissions: Read/Execute
.text$mn:000008C4 _text$mn        segment para public 'CODE' use32
.text$mn:000008C4                 assume cs:_text$mn
.text$mn:000008C4                 ;org 8C4h
.text$mn:000008C4 ; COMDAT (pick any)
.text$mn:000008C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000008C4
.text$mn:000008C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000008C4
.text$mn:000008C4 ; Attributes: bp-based frame
.text$mn:000008C4
.text$mn:000008C4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:000008C4                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000008C4 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:000008C4                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:000008C4                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:000008C4
.text$mn:000008C4 var_14          = dword ptr -14h
.text$mn:000008C4 var_D           = byte ptr -0Dh
.text$mn:000008C4 var_C           = dword ptr -0Ch
.text$mn:000008C4 var_4           = dword ptr -4
.text$mn:000008C4 Str             = dword ptr  8
.text$mn:000008C4
.text$mn:000008C4                 push    ebp
.text$mn:000008C5                 mov     ebp, esp
.text$mn:000008C7                 push    0FFFFFFFFh
.text$mn:000008C9                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000008CE                 mov     eax, large fs:0
.text$mn:000008D4                 push    eax
.text$mn:000008D5                 sub     esp, 8
.text$mn:000008D8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000008DD                 xor     eax, ebp
.text$mn:000008DF                 push    eax
.text$mn:000008E0                 lea     eax, [ebp+var_C]
.text$mn:000008E3                 mov     large fs:0, eax
.text$mn:000008E9                 mov     [ebp+var_14], ecx
.text$mn:000008EC                 lea     ecx, [ebp+var_D]
.text$mn:000008EF                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000008F4                 push    eax
.text$mn:000008F5                 mov     ecx, [ebp+var_14]
.text$mn:000008F8                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000008FD                 mov     [ebp+var_4], 0
.text$mn:00000904                 push    0               ; Size
.text$mn:00000906                 push    0               ; char
.text$mn:00000908                 mov     ecx, [ebp+var_14]
.text$mn:0000090B                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000910                 mov     eax, [ebp+Str]
.text$mn:00000913                 push    eax             ; Str
.text$mn:00000914                 mov     ecx, [ebp+var_14]
.text$mn:00000917                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:0000091C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000923                 mov     eax, [ebp+var_14]
.text$mn:00000926                 mov     ecx, [ebp+var_C]
.text$mn:00000929                 mov     large fs:0, ecx
.text$mn:00000930                 pop     ecx
.text$mn:00000931                 mov     esp, ebp
.text$mn:00000933                 pop     ebp
.text$mn:00000934                 retn    4
.text$mn:00000934 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00000934
.text$mn:00000934 ; ---------------------------------------------------------------------------
.text$mn:00000937                 align 4
.text$mn:00000937 _text$mn        ends
.text$mn:00000937
.text$x:00000938 ; ===========================================================================
.text$x:00000938
.text$x:00000938 ; Segment type: Pure code
.text$x:00000938 ; Segment permissions: Read/Execute
.text$x:00000938 _text$x         segment para public 'CODE' use32
.text$x:00000938                 assume cs:_text$x
.text$x:00000938                 ;org 938h
.text$x:00000938 ; COMDAT (pick associative to section at 8C4)
.text$x:00000938                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000938
.text$x:00000938 ; =============== S U B R O U T I N E =======================================
.text$x:00000938
.text$x:00000938
.text$x:00000938 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00000938                                         ; DATA XREF: .xdata$x:00002914o
.text$x:00000938                 mov     ecx, [ebp-14h]
.text$x:0000093B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000093B __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:0000093B
.text$x:00000940
.text$x:00000940 ; =============== S U B R O U T I N E =======================================
.text$x:00000940
.text$x:00000940
.text$x:00000940 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00000940                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00000940
.text$x:00000940 arg_4           = dword ptr  8
.text$x:00000940
.text$x:00000940                 mov     edx, [esp+arg_4]
.text$x:00000944                 lea     eax, [edx+0Ch]
.text$x:00000947                 mov     ecx, [edx-0Ch]
.text$x:0000094A                 xor     ecx, eax
.text$x:0000094C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000951                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00000956                 jmp     ___CxxFrameHandler3
.text$x:00000956 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00000956
.text$x:00000956 ; ---------------------------------------------------------------------------
.text$x:0000095B                 align 4
.text$x:0000095B _text$x         ends
.text$x:0000095B
.text$mn:0000095C ; ===========================================================================
.text$mn:0000095C
.text$mn:0000095C ; Segment type: Pure code
.text$mn:0000095C ; Segment permissions: Read/Execute
.text$mn:0000095C _text$mn        segment para public 'CODE' use32
.text$mn:0000095C                 assume cs:_text$mn
.text$mn:0000095C                 ;org 95Ch
.text$mn:0000095C ; COMDAT (pick any)
.text$mn:0000095C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000095C
.text$mn:0000095C ; =============== S U B R O U T I N E =======================================
.text$mn:0000095C
.text$mn:0000095C ; Attributes: bp-based frame
.text$mn:0000095C
.text$mn:0000095C ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:0000095C                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:0000095C ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:0000095C                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:0000095C
.text$mn:0000095C var_4           = dword ptr -4
.text$mn:0000095C
.text$mn:0000095C                 push    ebp
.text$mn:0000095D                 mov     ebp, esp
.text$mn:0000095F                 push    ecx
.text$mn:00000960                 mov     [ebp+var_4], ecx
.text$mn:00000963                 mov     eax, [ebp+var_4]
.text$mn:00000966                 mov     dword ptr [eax], 0
.text$mn:0000096C                 mov     eax, [ebp+var_4]
.text$mn:0000096F                 mov     esp, ebp
.text$mn:00000971                 pop     ebp
.text$mn:00000972                 retn
.text$mn:00000972 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00000972
.text$mn:00000972 ; ---------------------------------------------------------------------------
.text$mn:00000973                 align 4
.text$mn:00000973 _text$mn        ends
.text$mn:00000973
.text$mn:00000974 ; ===========================================================================
.text$mn:00000974
.text$mn:00000974 ; Segment type: Pure code
.text$mn:00000974 ; Segment permissions: Read/Execute
.text$mn:00000974 _text$mn        segment para public 'CODE' use32
.text$mn:00000974                 assume cs:_text$mn
.text$mn:00000974                 ;org 974h
.text$mn:00000974 ; COMDAT (pick any)
.text$mn:00000974                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000974
.text$mn:00000974 ; =============== S U B R O U T I N E =======================================
.text$mn:00000974
.text$mn:00000974 ; Attributes: bp-based frame
.text$mn:00000974
.text$mn:00000974 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00000974                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00000974 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00000974                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00000974
.text$mn:00000974 var_4           = dword ptr -4
.text$mn:00000974
.text$mn:00000974                 push    ebp
.text$mn:00000975                 mov     ebp, esp
.text$mn:00000977                 push    ecx
.text$mn:00000978                 mov     [ebp+var_4], ecx
.text$mn:0000097B                 mov     eax, [ebp+var_4]
.text$mn:0000097E                 mov     dword ptr [eax], 0
.text$mn:00000984                 mov     ecx, [ebp+var_4]
.text$mn:00000987                 mov     dword ptr [ecx+4], 0
.text$mn:0000098E                 mov     eax, [ebp+var_4]
.text$mn:00000991                 mov     esp, ebp
.text$mn:00000993                 pop     ebp
.text$mn:00000994                 retn
.text$mn:00000994 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00000994
.text$mn:00000994 ; ---------------------------------------------------------------------------
.text$mn:00000995                 align 4
.text$mn:00000995 _text$mn        ends
.text$mn:00000995
.text$mn:00000998 ; ===========================================================================
.text$mn:00000998
.text$mn:00000998 ; Segment type: Pure code
.text$mn:00000998 ; Segment permissions: Read/Execute
.text$mn:00000998 _text$mn        segment para public 'CODE' use32
.text$mn:00000998                 assume cs:_text$mn
.text$mn:00000998                 ;org 998h
.text$mn:00000998 ; COMDAT (pick any)
.text$mn:00000998                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000998
.text$mn:00000998 ; =============== S U B R O U T I N E =======================================
.text$mn:00000998
.text$mn:00000998 ; Attributes: bp-based frame
.text$mn:00000998
.text$mn:00000998 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000998                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000998 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00000998                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00000998                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00000998
.text$mn:00000998 var_10          = dword ptr -10h
.text$mn:00000998 var_C           = dword ptr -0Ch
.text$mn:00000998 var_4           = dword ptr -4
.text$mn:00000998
.text$mn:00000998                 push    ebp
.text$mn:00000999                 mov     ebp, esp
.text$mn:0000099B                 push    0FFFFFFFFh
.text$mn:0000099D                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:000009A2                 mov     eax, large fs:0
.text$mn:000009A8                 push    eax
.text$mn:000009A9                 push    ecx
.text$mn:000009AA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000009AF                 xor     eax, ebp
.text$mn:000009B1                 push    eax
.text$mn:000009B2                 lea     eax, [ebp+var_C]
.text$mn:000009B5                 mov     large fs:0, eax
.text$mn:000009BB                 mov     [ebp+var_10], ecx
.text$mn:000009BE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000009C1                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:000009C6                 mov     [ebp+var_4], 0
.text$mn:000009CD                 mov     eax, [ebp+var_10]
.text$mn:000009D0                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:000009D6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000009DD                 mov     eax, [ebp+var_10]
.text$mn:000009E0                 mov     ecx, [ebp+var_C]
.text$mn:000009E3                 mov     large fs:0, ecx
.text$mn:000009EA                 pop     ecx
.text$mn:000009EB                 mov     esp, ebp
.text$mn:000009ED                 pop     ebp
.text$mn:000009EE                 retn
.text$mn:000009EE ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000009EE
.text$mn:000009EE ; ---------------------------------------------------------------------------
.text$mn:000009EF                 align 10h
.text$mn:000009EF _text$mn        ends
.text$mn:000009EF
.text$x:000009F0 ; ===========================================================================
.text$x:000009F0
.text$x:000009F0 ; Segment type: Pure code
.text$x:000009F0 ; Segment permissions: Read/Execute
.text$x:000009F0 _text$x         segment para public 'CODE' use32
.text$x:000009F0                 assume cs:_text$x
.text$x:000009F0                 ;org 9F0h
.text$x:000009F0 ; COMDAT (pick associative to section at 998)
.text$x:000009F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000009F0
.text$x:000009F0 ; =============== S U B R O U T I N E =======================================
.text$x:000009F0
.text$x:000009F0
.text$x:000009F0 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000009F0                                         ; DATA XREF: .xdata$x:00002A7Co
.text$x:000009F0                 mov     ecx, [ebp-10h]  ; this
.text$x:000009F3                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000009F3 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000009F3
.text$x:000009F8
.text$x:000009F8 ; =============== S U B R O U T I N E =======================================
.text$x:000009F8
.text$x:000009F8
.text$x:000009F8 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000009F8                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000009F8
.text$x:000009F8 arg_4           = dword ptr  8
.text$x:000009F8
.text$x:000009F8                 mov     edx, [esp+arg_4]
.text$x:000009FC                 lea     eax, [edx+0Ch]
.text$x:000009FF                 mov     ecx, [edx-8]
.text$x:00000A02                 xor     ecx, eax
.text$x:00000A04                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A09                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00000A0E                 jmp     ___CxxFrameHandler3
.text$x:00000A0E __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00000A0E
.text$x:00000A0E ; ---------------------------------------------------------------------------
.text$x:00000A13                 align 4
.text$x:00000A13 _text$x         ends
.text$x:00000A13
.text$mn:00000A14 ; ===========================================================================
.text$mn:00000A14
.text$mn:00000A14 ; Segment type: Pure code
.text$mn:00000A14 ; Segment permissions: Read/Execute
.text$mn:00000A14 _text$mn        segment para public 'CODE' use32
.text$mn:00000A14                 assume cs:_text$mn
.text$mn:00000A14                 ;org 0A14h
.text$mn:00000A14 ; COMDAT (pick any)
.text$mn:00000A14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A14
.text$mn:00000A14 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A14
.text$mn:00000A14 ; Attributes: bp-based frame
.text$mn:00000A14
.text$mn:00000A14 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000A14                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000A14 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00000A14                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000A14
.text$mn:00000A14 var_10          = dword ptr -10h
.text$mn:00000A14 var_C           = dword ptr -0Ch
.text$mn:00000A14 var_4           = dword ptr -4
.text$mn:00000A14
.text$mn:00000A14                 push    ebp
.text$mn:00000A15                 mov     ebp, esp
.text$mn:00000A17                 push    0FFFFFFFFh
.text$mn:00000A19                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000A1E                 mov     eax, large fs:0
.text$mn:00000A24                 push    eax
.text$mn:00000A25                 push    ecx
.text$mn:00000A26                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A2B                 xor     eax, ebp
.text$mn:00000A2D                 push    eax
.text$mn:00000A2E                 lea     eax, [ebp+var_C]
.text$mn:00000A31                 mov     large fs:0, eax
.text$mn:00000A37                 mov     [ebp+var_10], ecx
.text$mn:00000A3A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000A3D                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000A42                 mov     [ebp+var_4], 0
.text$mn:00000A49                 mov     eax, [ebp+var_10]
.text$mn:00000A4C                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00000A52                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A59                 mov     eax, [ebp+var_10]
.text$mn:00000A5C                 mov     ecx, [ebp+var_C]
.text$mn:00000A5F                 mov     large fs:0, ecx
.text$mn:00000A66                 pop     ecx
.text$mn:00000A67                 mov     esp, ebp
.text$mn:00000A69                 pop     ebp
.text$mn:00000A6A                 retn
.text$mn:00000A6A ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00000A6A
.text$mn:00000A6A ; ---------------------------------------------------------------------------
.text$mn:00000A6B                 align 4
.text$mn:00000A6B _text$mn        ends
.text$mn:00000A6B
.text$x:00000A6C ; ===========================================================================
.text$x:00000A6C
.text$x:00000A6C ; Segment type: Pure code
.text$x:00000A6C ; Segment permissions: Read/Execute
.text$x:00000A6C _text$x         segment para public 'CODE' use32
.text$x:00000A6C                 assume cs:_text$x
.text$x:00000A6C                 ;org 0A6Ch
.text$x:00000A6C ; COMDAT (pick associative to section at A14)
.text$x:00000A6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000A6C
.text$x:00000A6C ; =============== S U B R O U T I N E =======================================
.text$x:00000A6C
.text$x:00000A6C
.text$x:00000A6C __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00000A6C                                         ; DATA XREF: .xdata$x:00002B00o
.text$x:00000A6C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000A6F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000A6F __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00000A6F
.text$x:00000A74
.text$x:00000A74 ; =============== S U B R O U T I N E =======================================
.text$x:00000A74
.text$x:00000A74
.text$x:00000A74 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00000A74                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00000A74
.text$x:00000A74 arg_4           = dword ptr  8
.text$x:00000A74
.text$x:00000A74                 mov     edx, [esp+arg_4]
.text$x:00000A78                 lea     eax, [edx+0Ch]
.text$x:00000A7B                 mov     ecx, [edx-8]
.text$x:00000A7E                 xor     ecx, eax
.text$x:00000A80                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A85                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00000A8A                 jmp     ___CxxFrameHandler3
.text$x:00000A8A __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00000A8A
.text$x:00000A8A ; ---------------------------------------------------------------------------
.text$x:00000A8F                 align 10h
.text$x:00000A8F _text$x         ends
.text$x:00000A8F
.text$mn:00000A90 ; ===========================================================================
.text$mn:00000A90
.text$mn:00000A90 ; Segment type: Pure code
.text$mn:00000A90 ; Segment permissions: Read/Execute
.text$mn:00000A90 _text$mn        segment para public 'CODE' use32
.text$mn:00000A90                 assume cs:_text$mn
.text$mn:00000A90                 ;org 0A90h
.text$mn:00000A90 ; COMDAT (pick any)
.text$mn:00000A90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A90
.text$mn:00000A90 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A90
.text$mn:00000A90 ; Attributes: bp-based frame
.text$mn:00000A90
.text$mn:00000A90 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000A90                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00000A90 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00000A90                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000A90
.text$mn:00000A90 var_10          = dword ptr -10h
.text$mn:00000A90 var_C           = dword ptr -0Ch
.text$mn:00000A90 var_4           = dword ptr -4
.text$mn:00000A90
.text$mn:00000A90                 push    ebp
.text$mn:00000A91                 mov     ebp, esp
.text$mn:00000A93                 push    0FFFFFFFFh
.text$mn:00000A95                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00000A9A                 mov     eax, large fs:0
.text$mn:00000AA0                 push    eax
.text$mn:00000AA1                 push    ecx
.text$mn:00000AA2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000AA7                 xor     eax, ebp
.text$mn:00000AA9                 push    eax
.text$mn:00000AAA                 lea     eax, [ebp+var_C]
.text$mn:00000AAD                 mov     large fs:0, eax
.text$mn:00000AB3                 mov     [ebp+var_10], ecx
.text$mn:00000AB6                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000AB9                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000ABE                 mov     [ebp+var_4], 0
.text$mn:00000AC5                 mov     eax, [ebp+var_10]
.text$mn:00000AC8                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00000ACE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000AD5                 mov     eax, [ebp+var_10]
.text$mn:00000AD8                 mov     ecx, [ebp+var_C]
.text$mn:00000ADB                 mov     large fs:0, ecx
.text$mn:00000AE2                 pop     ecx
.text$mn:00000AE3                 mov     esp, ebp
.text$mn:00000AE5                 pop     ebp
.text$mn:00000AE6                 retn
.text$mn:00000AE6 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00000AE6
.text$mn:00000AE6 ; ---------------------------------------------------------------------------
.text$mn:00000AE7                 align 4
.text$mn:00000AE7 _text$mn        ends
.text$mn:00000AE7
.text$x:00000AE8 ; ===========================================================================
.text$x:00000AE8
.text$x:00000AE8 ; Segment type: Pure code
.text$x:00000AE8 ; Segment permissions: Read/Execute
.text$x:00000AE8 _text$x         segment para public 'CODE' use32
.text$x:00000AE8                 assume cs:_text$x
.text$x:00000AE8                 ;org 0AE8h
.text$x:00000AE8 ; COMDAT (pick associative to section at A90)
.text$x:00000AE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000AE8
.text$x:00000AE8 ; =============== S U B R O U T I N E =======================================
.text$x:00000AE8
.text$x:00000AE8
.text$x:00000AE8 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00000AE8                                         ; DATA XREF: .xdata$x:00002B84o
.text$x:00000AE8                 mov     ecx, [ebp-10h]  ; this
.text$x:00000AEB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000AEB __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00000AEB
.text$x:00000AF0
.text$x:00000AF0 ; =============== S U B R O U T I N E =======================================
.text$x:00000AF0
.text$x:00000AF0
.text$x:00000AF0 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00000AF0                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00000AF0
.text$x:00000AF0 arg_4           = dword ptr  8
.text$x:00000AF0
.text$x:00000AF0                 mov     edx, [esp+arg_4]
.text$x:00000AF4                 lea     eax, [edx+0Ch]
.text$x:00000AF7                 mov     ecx, [edx-8]
.text$x:00000AFA                 xor     ecx, eax
.text$x:00000AFC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B01                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00000B06                 jmp     ___CxxFrameHandler3
.text$x:00000B06 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00000B06
.text$x:00000B06 ; ---------------------------------------------------------------------------
.text$x:00000B0B                 align 4
.text$x:00000B0B _text$x         ends
.text$x:00000B0B
.text$mn:00000B0C ; ===========================================================================
.text$mn:00000B0C
.text$mn:00000B0C ; Segment type: Pure code
.text$mn:00000B0C ; Segment permissions: Read/Execute
.text$mn:00000B0C _text$mn        segment para public 'CODE' use32
.text$mn:00000B0C                 assume cs:_text$mn
.text$mn:00000B0C                 ;org 0B0Ch
.text$mn:00000B0C ; COMDAT (pick any)
.text$mn:00000B0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B0C
.text$mn:00000B0C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B0C
.text$mn:00000B0C ; Attributes: bp-based frame
.text$mn:00000B0C
.text$mn:00000B0C ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00000B0C                 public ??0error_category@std@@QAE@XZ
.text$mn:00000B0C ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00000B0C
.text$mn:00000B0C var_4           = dword ptr -4
.text$mn:00000B0C
.text$mn:00000B0C                 push    ebp
.text$mn:00000B0D                 mov     ebp, esp
.text$mn:00000B0F                 push    ecx
.text$mn:00000B10                 mov     [ebp+var_4], ecx
.text$mn:00000B13                 mov     eax, [ebp+var_4]
.text$mn:00000B16                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000B1C                 mov     eax, [ebp+var_4]
.text$mn:00000B1F                 mov     esp, ebp
.text$mn:00000B21                 pop     ebp
.text$mn:00000B22                 retn
.text$mn:00000B22 ??0error_category@std@@QAE@XZ endp
.text$mn:00000B22
.text$mn:00000B22 ; ---------------------------------------------------------------------------
.text$mn:00000B23                 align 4
.text$mn:00000B23 _text$mn        ends
.text$mn:00000B23
.text$mn:00000B24 ; ===========================================================================
.text$mn:00000B24
.text$mn:00000B24 ; Segment type: Pure code
.text$mn:00000B24 ; Segment permissions: Read/Execute
.text$mn:00000B24 _text$mn        segment para public 'CODE' use32
.text$mn:00000B24                 assume cs:_text$mn
.text$mn:00000B24                 ;org 0B24h
.text$mn:00000B24 ; COMDAT (pick any)
.text$mn:00000B24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B24
.text$mn:00000B24 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B24
.text$mn:00000B24 ; Attributes: bp-based frame
.text$mn:00000B24
.text$mn:00000B24 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00000B24                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00000B24 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00000B24                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00000B24                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00000B24
.text$mn:00000B24 var_4           = dword ptr -4
.text$mn:00000B24 arg_0           = dword ptr  8
.text$mn:00000B24 arg_4           = dword ptr  0Ch
.text$mn:00000B24
.text$mn:00000B24                 push    ebp
.text$mn:00000B25                 mov     ebp, esp
.text$mn:00000B27                 push    ecx
.text$mn:00000B28                 mov     [ebp+var_4], ecx
.text$mn:00000B2B                 mov     eax, [ebp+var_4]
.text$mn:00000B2E                 mov     ecx, [ebp+arg_0]
.text$mn:00000B31                 mov     [eax], ecx
.text$mn:00000B33                 mov     edx, [ebp+var_4]
.text$mn:00000B36                 mov     eax, [ebp+arg_4]
.text$mn:00000B39                 mov     [edx+4], eax
.text$mn:00000B3C                 mov     eax, [ebp+var_4]
.text$mn:00000B3F                 mov     esp, ebp
.text$mn:00000B41                 pop     ebp
.text$mn:00000B42                 retn    8
.text$mn:00000B42 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00000B42
.text$mn:00000B42 ; ---------------------------------------------------------------------------
.text$mn:00000B45                 align 4
.text$mn:00000B45 _text$mn        ends
.text$mn:00000B45
.text$mn:00000B48 ; ===========================================================================
.text$mn:00000B48
.text$mn:00000B48 ; Segment type: Pure code
.text$mn:00000B48 ; Segment permissions: Read/Execute
.text$mn:00000B48 _text$mn        segment para public 'CODE' use32
.text$mn:00000B48                 assume cs:_text$mn
.text$mn:00000B48                 ;org 0B48h
.text$mn:00000B48 ; COMDAT (pick any)
.text$mn:00000B48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B48
.text$mn:00000B48 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B48
.text$mn:00000B48 ; Attributes: bp-based frame
.text$mn:00000B48
.text$mn:00000B48 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00000B48                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00000B48 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00000B48                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00000B48
.text$mn:00000B48 var_4           = dword ptr -4
.text$mn:00000B48 arg_0           = dword ptr  8
.text$mn:00000B48
.text$mn:00000B48                 push    ebp
.text$mn:00000B49                 mov     ebp, esp
.text$mn:00000B4B                 push    ecx
.text$mn:00000B4C                 mov     [ebp+var_4], ecx
.text$mn:00000B4F                 mov     eax, [ebp+var_4]
.text$mn:00000B52                 mov     ecx, [ebp+arg_0]
.text$mn:00000B55                 mov     [eax], ecx
.text$mn:00000B57                 mov     eax, [ebp+var_4]
.text$mn:00000B5A                 mov     esp, ebp
.text$mn:00000B5C                 pop     ebp
.text$mn:00000B5D                 retn    4
.text$mn:00000B5D ??0id@locale@std@@QAE@I@Z endp
.text$mn:00000B5D
.text$mn:00000B5D _text$mn        ends
.text$mn:00000B5D
.text$mn:00000B60 ; ===========================================================================
.text$mn:00000B60
.text$mn:00000B60 ; Segment type: Pure code
.text$mn:00000B60 ; Segment permissions: Read/Execute
.text$mn:00000B60 _text$mn        segment para public 'CODE' use32
.text$mn:00000B60                 assume cs:_text$mn
.text$mn:00000B60                 ;org 0B60h
.text$mn:00000B60 ; COMDAT (pick any)
.text$mn:00000B60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B60
.text$mn:00000B60 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B60
.text$mn:00000B60 ; Attributes: bp-based frame
.text$mn:00000B60
.text$mn:00000B60 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const struct std::runtime_error *)
.text$mn:00000B60                 public ??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00000B60 ??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$mn:00000B60                                         ; DATA XREF: .xdata$x:00002D78o
.text$mn:00000B60
.text$mn:00000B60 var_10          = dword ptr -10h
.text$mn:00000B60 var_C           = dword ptr -0Ch
.text$mn:00000B60 var_4           = dword ptr -4
.text$mn:00000B60 arg_0           = dword ptr  8
.text$mn:00000B60
.text$mn:00000B60                 push    ebp
.text$mn:00000B61                 mov     ebp, esp
.text$mn:00000B63                 push    0FFFFFFFFh
.text$mn:00000B65                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00000B6A                 mov     eax, large fs:0
.text$mn:00000B70                 push    eax
.text$mn:00000B71                 push    ecx
.text$mn:00000B72                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000B77                 xor     eax, ebp
.text$mn:00000B79                 push    eax
.text$mn:00000B7A                 lea     eax, [ebp+var_C]
.text$mn:00000B7D                 mov     large fs:0, eax
.text$mn:00000B83                 mov     [ebp+var_10], ecx
.text$mn:00000B86                 mov     eax, [ebp+arg_0]
.text$mn:00000B89                 push    eax             ; struct std::exception *
.text$mn:00000B8A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000B8D                 call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.text$mn:00000B92                 mov     [ebp+var_4], 0
.text$mn:00000B99                 mov     ecx, [ebp+var_10]
.text$mn:00000B9C                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00000BA2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000BA9                 mov     eax, [ebp+var_10]
.text$mn:00000BAC                 mov     ecx, [ebp+var_C]
.text$mn:00000BAF                 mov     large fs:0, ecx
.text$mn:00000BB6                 pop     ecx
.text$mn:00000BB7                 mov     esp, ebp
.text$mn:00000BB9                 pop     ebp
.text$mn:00000BBA                 retn    4
.text$mn:00000BBA ??0runtime_error@std@@QAE@ABV01@@Z endp
.text$mn:00000BBA
.text$mn:00000BBA ; ---------------------------------------------------------------------------
.text$mn:00000BBD                 align 10h
.text$mn:00000BBD _text$mn        ends
.text$mn:00000BBD
.text$x:00000BC0 ; ===========================================================================
.text$x:00000BC0
.text$x:00000BC0 ; Segment type: Pure code
.text$x:00000BC0 ; Segment permissions: Read/Execute
.text$x:00000BC0 _text$x         segment para public 'CODE' use32
.text$x:00000BC0                 assume cs:_text$x
.text$x:00000BC0                 ;org 0BC0h
.text$x:00000BC0 ; COMDAT (pick associative to section at B60)
.text$x:00000BC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000BC0
.text$x:00000BC0 ; =============== S U B R O U T I N E =======================================
.text$x:00000BC0
.text$x:00000BC0
.text$x:00000BC0 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:00000BC0                                         ; DATA XREF: .xdata$x:00002A50o
.text$x:00000BC0                 mov     ecx, [ebp-10h]  ; this
.text$x:00000BC3                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00000BC3 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 endp
.text$x:00000BC3
.text$x:00000BC8
.text$x:00000BC8 ; =============== S U B R O U T I N E =======================================
.text$x:00000BC8
.text$x:00000BC8
.text$x:00000BC8 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$x:00000BC8                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+5o
.text$x:00000BC8
.text$x:00000BC8 arg_4           = dword ptr  8
.text$x:00000BC8
.text$x:00000BC8                 mov     edx, [esp+arg_4]
.text$x:00000BCC                 lea     eax, [edx+0Ch]
.text$x:00000BCF                 mov     ecx, [edx-8]
.text$x:00000BD2                 xor     ecx, eax
.text$x:00000BD4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000BD9                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
.text$x:00000BDE                 jmp     ___CxxFrameHandler3
.text$x:00000BDE __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z endp
.text$x:00000BDE
.text$x:00000BDE ; ---------------------------------------------------------------------------
.text$x:00000BE3                 align 4
.text$x:00000BE3 _text$x         ends
.text$x:00000BE3
.text$mn:00000BE4 ; ===========================================================================
.text$mn:00000BE4
.text$mn:00000BE4 ; Segment type: Pure code
.text$mn:00000BE4 ; Segment permissions: Read/Execute
.text$mn:00000BE4 _text$mn        segment para public 'CODE' use32
.text$mn:00000BE4                 assume cs:_text$mn
.text$mn:00000BE4                 ;org 0BE4h
.text$mn:00000BE4 ; COMDAT (pick any)
.text$mn:00000BE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000BE4
.text$mn:00000BE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BE4
.text$mn:00000BE4 ; Attributes: bp-based frame
.text$mn:00000BE4
.text$mn:00000BE4 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const char *)
.text$mn:00000BE4                 public ??0runtime_error@std@@QAE@PBD@Z
.text$mn:00000BE4 ??0runtime_error@std@@QAE@PBD@Z proc near
.text$mn:00000BE4                                         ; CODE XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+71p
.text$mn:00000BE4
.text$mn:00000BE4 var_10          = dword ptr -10h
.text$mn:00000BE4 var_C           = dword ptr -0Ch
.text$mn:00000BE4 var_4           = dword ptr -4
.text$mn:00000BE4 arg_0           = dword ptr  8
.text$mn:00000BE4
.text$mn:00000BE4                 push    ebp
.text$mn:00000BE5                 mov     ebp, esp
.text$mn:00000BE7                 push    0FFFFFFFFh
.text$mn:00000BE9                 push    offset __ehhandler$??0runtime_error@std@@QAE@PBD@Z
.text$mn:00000BEE                 mov     eax, large fs:0
.text$mn:00000BF4                 push    eax
.text$mn:00000BF5                 push    ecx
.text$mn:00000BF6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000BFB                 xor     eax, ebp
.text$mn:00000BFD                 push    eax
.text$mn:00000BFE                 lea     eax, [ebp+var_C]
.text$mn:00000C01                 mov     large fs:0, eax
.text$mn:00000C07                 mov     [ebp+var_10], ecx
.text$mn:00000C0A                 lea     eax, [ebp+arg_0]
.text$mn:00000C0D                 push    eax             ; char **
.text$mn:00000C0E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000C11                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:00000C16                 mov     [ebp+var_4], 0
.text$mn:00000C1D                 mov     ecx, [ebp+var_10]
.text$mn:00000C20                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00000C26                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C2D                 mov     eax, [ebp+var_10]
.text$mn:00000C30                 mov     ecx, [ebp+var_C]
.text$mn:00000C33                 mov     large fs:0, ecx
.text$mn:00000C3A                 pop     ecx
.text$mn:00000C3B                 mov     esp, ebp
.text$mn:00000C3D                 pop     ebp
.text$mn:00000C3E                 retn    4
.text$mn:00000C3E ??0runtime_error@std@@QAE@PBD@Z endp
.text$mn:00000C3E
.text$mn:00000C3E ; ---------------------------------------------------------------------------
.text$mn:00000C41                 align 4
.text$mn:00000C41 _text$mn        ends
.text$mn:00000C41
.text$x:00000C44 ; ===========================================================================
.text$x:00000C44
.text$x:00000C44 ; Segment type: Pure code
.text$x:00000C44 ; Segment permissions: Read/Execute
.text$x:00000C44 _text$x         segment para public 'CODE' use32
.text$x:00000C44                 assume cs:_text$x
.text$x:00000C44                 ;org 0C44h
.text$x:00000C44 ; COMDAT (pick associative to section at BE4)
.text$x:00000C44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000C44
.text$x:00000C44 ; =============== S U B R O U T I N E =======================================
.text$x:00000C44
.text$x:00000C44
.text$x:00000C44 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 proc near
.text$x:00000C44                                         ; DATA XREF: .xdata$x:000029F8o
.text$x:00000C44                 mov     ecx, [ebp-10h]  ; this
.text$x:00000C47                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00000C47 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 endp
.text$x:00000C47
.text$x:00000C4C
.text$x:00000C4C ; =============== S U B R O U T I N E =======================================
.text$x:00000C4C
.text$x:00000C4C
.text$x:00000C4C __ehhandler$??0runtime_error@std@@QAE@PBD@Z proc near
.text$x:00000C4C                                         ; DATA XREF: std::runtime_error::runtime_error(char const *)+5o
.text$x:00000C4C
.text$x:00000C4C arg_4           = dword ptr  8
.text$x:00000C4C
.text$x:00000C4C                 mov     edx, [esp+arg_4]
.text$x:00000C50                 lea     eax, [edx+0Ch]
.text$x:00000C53                 mov     ecx, [edx-8]
.text$x:00000C56                 xor     ecx, eax
.text$x:00000C58                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C5D                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z
.text$x:00000C62                 jmp     ___CxxFrameHandler3
.text$x:00000C62 __ehhandler$??0runtime_error@std@@QAE@PBD@Z endp
.text$x:00000C62
.text$x:00000C62 ; ---------------------------------------------------------------------------
.text$x:00000C67                 align 4
.text$x:00000C67 _text$x         ends
.text$x:00000C67
.text$mn:00000C68 ; ===========================================================================
.text$mn:00000C68
.text$mn:00000C68 ; Segment type: Pure code
.text$mn:00000C68 ; Segment permissions: Read/Execute
.text$mn:00000C68 _text$mn        segment para public 'CODE' use32
.text$mn:00000C68                 assume cs:_text$mn
.text$mn:00000C68                 ;org 0C68h
.text$mn:00000C68 ; COMDAT (pick any)
.text$mn:00000C68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C68
.text$mn:00000C68 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C68
.text$mn:00000C68 ; Attributes: bp-based frame
.text$mn:00000C68
.text$mn:00000C68 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00000C68                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000C68 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00000C68                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00000C68                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00000C68
.text$mn:00000C68 var_10          = dword ptr -10h
.text$mn:00000C68 var_C           = dword ptr -0Ch
.text$mn:00000C68 var_4           = dword ptr -4
.text$mn:00000C68
.text$mn:00000C68                 push    ebp
.text$mn:00000C69                 mov     ebp, esp
.text$mn:00000C6B                 push    0FFFFFFFFh
.text$mn:00000C6D                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000C72                 mov     eax, large fs:0
.text$mn:00000C78                 push    eax
.text$mn:00000C79                 push    ecx
.text$mn:00000C7A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C7F                 xor     eax, ebp
.text$mn:00000C81                 push    eax
.text$mn:00000C82                 lea     eax, [ebp+var_C]
.text$mn:00000C85                 mov     large fs:0, eax
.text$mn:00000C8B                 mov     [ebp+var_10], ecx
.text$mn:00000C8E                 mov     [ebp+var_4], 0
.text$mn:00000C95                 mov     ecx, [ebp+var_10]
.text$mn:00000C98                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00000C9D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000CA4                 mov     ecx, [ebp+var_10]
.text$mn:00000CA7                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00000CAC                 mov     ecx, [ebp+var_C]
.text$mn:00000CAF                 mov     large fs:0, ecx
.text$mn:00000CB6                 pop     ecx
.text$mn:00000CB7                 mov     esp, ebp
.text$mn:00000CB9                 pop     ebp
.text$mn:00000CBA                 retn
.text$mn:00000CBA ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00000CBA
.text$mn:00000CBA ; ---------------------------------------------------------------------------
.text$mn:00000CBB                 align 4
.text$mn:00000CBB _text$mn        ends
.text$mn:00000CBB
.text$x:00000CBC ; ===========================================================================
.text$x:00000CBC
.text$x:00000CBC ; Segment type: Pure code
.text$x:00000CBC ; Segment permissions: Read/Execute
.text$x:00000CBC _text$x         segment para public 'CODE' use32
.text$x:00000CBC                 assume cs:_text$x
.text$x:00000CBC                 ;org 0CBCh
.text$x:00000CBC ; COMDAT (pick associative to section at C68)
.text$x:00000CBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000CBC
.text$x:00000CBC ; =============== S U B R O U T I N E =======================================
.text$x:00000CBC
.text$x:00000CBC
.text$x:00000CBC __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00000CBC                                         ; DATA XREF: .xdata$x:000028E8o
.text$x:00000CBC                 mov     ecx, [ebp-10h]
.text$x:00000CBF                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000CBF __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00000CBF
.text$x:00000CC4
.text$x:00000CC4 ; =============== S U B R O U T I N E =======================================
.text$x:00000CC4
.text$x:00000CC4
.text$x:00000CC4 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00000CC4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00000CC4
.text$x:00000CC4 arg_4           = dword ptr  8
.text$x:00000CC4
.text$x:00000CC4                 mov     edx, [esp+arg_4]
.text$x:00000CC8                 lea     eax, [edx+0Ch]
.text$x:00000CCB                 mov     ecx, [edx-8]
.text$x:00000CCE                 xor     ecx, eax
.text$x:00000CD0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000CD5                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00000CDA                 jmp     ___CxxFrameHandler3
.text$x:00000CDA __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00000CDA
.text$x:00000CDA ; ---------------------------------------------------------------------------
.text$x:00000CDF                 align 10h
.text$x:00000CDF _text$x         ends
.text$x:00000CDF
.text$mn:00000CE0 ; ===========================================================================
.text$mn:00000CE0
.text$mn:00000CE0 ; Segment type: Pure code
.text$mn:00000CE0 ; Segment permissions: Read/Execute
.text$mn:00000CE0 _text$mn        segment para public 'CODE' use32
.text$mn:00000CE0                 assume cs:_text$mn
.text$mn:00000CE0                 ;org 0CE0h
.text$mn:00000CE0 ; COMDAT (pick any)
.text$mn:00000CE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CE0
.text$mn:00000CE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CE0
.text$mn:00000CE0 ; Attributes: bp-based frame
.text$mn:00000CE0
.text$mn:00000CE0 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000CE0                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000CE0 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000CE0                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00000CE0                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00000CE0
.text$mn:00000CE0 var_10          = dword ptr -10h
.text$mn:00000CE0 var_C           = dword ptr -0Ch
.text$mn:00000CE0 var_4           = dword ptr -4
.text$mn:00000CE0
.text$mn:00000CE0                 push    ebp
.text$mn:00000CE1                 mov     ebp, esp
.text$mn:00000CE3                 push    0FFFFFFFFh
.text$mn:00000CE5                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000CEA                 mov     eax, large fs:0
.text$mn:00000CF0                 push    eax
.text$mn:00000CF1                 push    ecx
.text$mn:00000CF2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000CF7                 xor     eax, ebp
.text$mn:00000CF9                 push    eax
.text$mn:00000CFA                 lea     eax, [ebp+var_C]
.text$mn:00000CFD                 mov     large fs:0, eax
.text$mn:00000D03                 mov     [ebp+var_10], ecx
.text$mn:00000D06                 mov     [ebp+var_4], 0
.text$mn:00000D0D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000D14                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000D17                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00000D1C                 mov     ecx, [ebp+var_C]
.text$mn:00000D1F                 mov     large fs:0, ecx
.text$mn:00000D26                 pop     ecx
.text$mn:00000D27                 mov     esp, ebp
.text$mn:00000D29                 pop     ebp
.text$mn:00000D2A                 retn
.text$mn:00000D2A ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000D2A
.text$mn:00000D2A ; ---------------------------------------------------------------------------
.text$mn:00000D2B                 align 4
.text$mn:00000D2B _text$mn        ends
.text$mn:00000D2B
.text$x:00000D2C ; ===========================================================================
.text$x:00000D2C
.text$x:00000D2C ; Segment type: Pure code
.text$x:00000D2C ; Segment permissions: Read/Execute
.text$x:00000D2C _text$x         segment para public 'CODE' use32
.text$x:00000D2C                 assume cs:_text$x
.text$x:00000D2C                 ;org 0D2Ch
.text$x:00000D2C ; COMDAT (pick associative to section at CE0)
.text$x:00000D2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000D2C
.text$x:00000D2C ; =============== S U B R O U T I N E =======================================
.text$x:00000D2C
.text$x:00000D2C
.text$x:00000D2C __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000D2C                                         ; DATA XREF: .xdata$x:00002890o
.text$x:00000D2C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000D2F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000D2F __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000D2F
.text$x:00000D34
.text$x:00000D34 ; =============== S U B R O U T I N E =======================================
.text$x:00000D34
.text$x:00000D34
.text$x:00000D34 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000D34                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000D34
.text$x:00000D34 arg_4           = dword ptr  8
.text$x:00000D34
.text$x:00000D34                 mov     edx, [esp+arg_4]
.text$x:00000D38                 lea     eax, [edx+0Ch]
.text$x:00000D3B                 mov     ecx, [edx-8]
.text$x:00000D3E                 xor     ecx, eax
.text$x:00000D40                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000D45                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000D4A                 jmp     ___CxxFrameHandler3
.text$x:00000D4A __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000D4A
.text$x:00000D4A ; ---------------------------------------------------------------------------
.text$x:00000D4F                 align 10h
.text$x:00000D4F _text$x         ends
.text$x:00000D4F
.text$mn:00000D50 ; ===========================================================================
.text$mn:00000D50
.text$mn:00000D50 ; Segment type: Pure code
.text$mn:00000D50 ; Segment permissions: Read/Execute
.text$mn:00000D50 _text$mn        segment para public 'CODE' use32
.text$mn:00000D50                 assume cs:_text$mn
.text$mn:00000D50                 ;org 0D50h
.text$mn:00000D50 ; COMDAT (pick any)
.text$mn:00000D50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D50
.text$mn:00000D50 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D50
.text$mn:00000D50 ; Attributes: bp-based frame
.text$mn:00000D50
.text$mn:00000D50 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00000D50                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000D50 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00000D50                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00000D50                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00000D50
.text$mn:00000D50 var_10          = dword ptr -10h
.text$mn:00000D50 var_C           = dword ptr -0Ch
.text$mn:00000D50 var_4           = dword ptr -4
.text$mn:00000D50
.text$mn:00000D50                 push    ebp
.text$mn:00000D51                 mov     ebp, esp
.text$mn:00000D53                 push    0FFFFFFFFh
.text$mn:00000D55                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000D5A                 mov     eax, large fs:0
.text$mn:00000D60                 push    eax
.text$mn:00000D61                 push    ecx
.text$mn:00000D62                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D67                 xor     eax, ebp
.text$mn:00000D69                 push    eax
.text$mn:00000D6A                 lea     eax, [ebp+var_C]
.text$mn:00000D6D                 mov     large fs:0, eax
.text$mn:00000D73                 mov     [ebp+var_10], ecx
.text$mn:00000D76                 mov     [ebp+var_4], 0
.text$mn:00000D7D                 push    0               ; Size
.text$mn:00000D7F                 push    1               ; char
.text$mn:00000D81                 mov     ecx, [ebp+var_10]
.text$mn:00000D84                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000D89                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000D90                 mov     ecx, [ebp+var_10]
.text$mn:00000D93                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00000D98                 mov     ecx, [ebp+var_C]
.text$mn:00000D9B                 mov     large fs:0, ecx
.text$mn:00000DA2                 pop     ecx
.text$mn:00000DA3                 mov     esp, ebp
.text$mn:00000DA5                 pop     ebp
.text$mn:00000DA6                 retn
.text$mn:00000DA6 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00000DA6
.text$mn:00000DA6 ; ---------------------------------------------------------------------------
.text$mn:00000DA7                 align 4
.text$mn:00000DA7 _text$mn        ends
.text$mn:00000DA7
.text$x:00000DA8 ; ===========================================================================
.text$x:00000DA8
.text$x:00000DA8 ; Segment type: Pure code
.text$x:00000DA8 ; Segment permissions: Read/Execute
.text$x:00000DA8 _text$x         segment para public 'CODE' use32
.text$x:00000DA8                 assume cs:_text$x
.text$x:00000DA8                 ;org 0DA8h
.text$x:00000DA8 ; COMDAT (pick associative to section at D50)
.text$x:00000DA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000DA8
.text$x:00000DA8 ; =============== S U B R O U T I N E =======================================
.text$x:00000DA8
.text$x:00000DA8
.text$x:00000DA8 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00000DA8                                         ; DATA XREF: .xdata$x:00002940o
.text$x:00000DA8                 mov     ecx, [ebp-10h]
.text$x:00000DAB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000DAB __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00000DAB
.text$x:00000DB0
.text$x:00000DB0 ; =============== S U B R O U T I N E =======================================
.text$x:00000DB0
.text$x:00000DB0
.text$x:00000DB0 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00000DB0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00000DB0
.text$x:00000DB0 arg_4           = dword ptr  8
.text$x:00000DB0
.text$x:00000DB0                 mov     edx, [esp+arg_4]
.text$x:00000DB4                 lea     eax, [edx+0Ch]
.text$x:00000DB7                 mov     ecx, [edx-8]
.text$x:00000DBA                 xor     ecx, eax
.text$x:00000DBC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000DC1                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00000DC6                 jmp     ___CxxFrameHandler3
.text$x:00000DC6 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00000DC6
.text$x:00000DC6 ; ---------------------------------------------------------------------------
.text$x:00000DCB                 align 4
.text$x:00000DCB _text$x         ends
.text$x:00000DCB
.text$mn:00000DCC ; ===========================================================================
.text$mn:00000DCC
.text$mn:00000DCC ; Segment type: Pure code
.text$mn:00000DCC ; Segment permissions: Read/Execute
.text$mn:00000DCC _text$mn        segment para public 'CODE' use32
.text$mn:00000DCC                 assume cs:_text$mn
.text$mn:00000DCC                 ;org 0DCCh
.text$mn:00000DCC ; COMDAT (pick any)
.text$mn:00000DCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DCC
.text$mn:00000DCC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DCC
.text$mn:00000DCC ; Attributes: bp-based frame
.text$mn:00000DCC
.text$mn:00000DCC ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000DCC                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00000DCC ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00000DCC                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00000DCC                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00000DCC
.text$mn:00000DCC var_4           = dword ptr -4
.text$mn:00000DCC
.text$mn:00000DCC                 push    ebp
.text$mn:00000DCD                 mov     ebp, esp
.text$mn:00000DCF                 push    ecx
.text$mn:00000DD0                 mov     [ebp+var_4], ecx
.text$mn:00000DD3                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000DD6                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00000DDB                 mov     esp, ebp
.text$mn:00000DDD                 pop     ebp
.text$mn:00000DDE                 retn
.text$mn:00000DDE ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00000DDE
.text$mn:00000DDE ; ---------------------------------------------------------------------------
.text$mn:00000DDF                 align 10h
.text$mn:00000DDF _text$mn        ends
.text$mn:00000DDF
.text$mn:00000DE0 ; ===========================================================================
.text$mn:00000DE0
.text$mn:00000DE0 ; Segment type: Pure code
.text$mn:00000DE0 ; Segment permissions: Read/Execute
.text$mn:00000DE0 _text$mn        segment para public 'CODE' use32
.text$mn:00000DE0                 assume cs:_text$mn
.text$mn:00000DE0                 ;org 0DE0h
.text$mn:00000DE0 ; COMDAT (pick any)
.text$mn:00000DE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DE0
.text$mn:00000DE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000DE0
.text$mn:00000DE0 ; Attributes: bp-based frame
.text$mn:00000DE0
.text$mn:00000DE0 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000DE0                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000DE0 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00000DE0                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00000DE0                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00000DE0
.text$mn:00000DE0 var_10          = dword ptr -10h
.text$mn:00000DE0 var_C           = dword ptr -0Ch
.text$mn:00000DE0 var_4           = dword ptr -4
.text$mn:00000DE0
.text$mn:00000DE0                 push    ebp
.text$mn:00000DE1                 mov     ebp, esp
.text$mn:00000DE3                 push    0FFFFFFFFh
.text$mn:00000DE5                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000DEA                 mov     eax, large fs:0
.text$mn:00000DF0                 push    eax
.text$mn:00000DF1                 push    ecx
.text$mn:00000DF2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000DF7                 xor     eax, ebp
.text$mn:00000DF9                 push    eax
.text$mn:00000DFA                 lea     eax, [ebp+var_C]
.text$mn:00000DFD                 mov     large fs:0, eax
.text$mn:00000E03                 mov     [ebp+var_10], ecx
.text$mn:00000E06                 mov     [ebp+var_4], 0
.text$mn:00000E0D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E14                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000E17                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000E1C                 mov     ecx, [ebp+var_C]
.text$mn:00000E1F                 mov     large fs:0, ecx
.text$mn:00000E26                 pop     ecx
.text$mn:00000E27                 mov     esp, ebp
.text$mn:00000E29                 pop     ebp
.text$mn:00000E2A                 retn
.text$mn:00000E2A ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00000E2A
.text$mn:00000E2A ; ---------------------------------------------------------------------------
.text$mn:00000E2B                 align 4
.text$mn:00000E2B _text$mn        ends
.text$mn:00000E2B
.text$x:00000E2C ; ===========================================================================
.text$x:00000E2C
.text$x:00000E2C ; Segment type: Pure code
.text$x:00000E2C ; Segment permissions: Read/Execute
.text$x:00000E2C _text$x         segment para public 'CODE' use32
.text$x:00000E2C                 assume cs:_text$x
.text$x:00000E2C                 ;org 0E2Ch
.text$x:00000E2C ; COMDAT (pick associative to section at DE0)
.text$x:00000E2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000E2C
.text$x:00000E2C ; =============== S U B R O U T I N E =======================================
.text$x:00000E2C
.text$x:00000E2C
.text$x:00000E2C __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00000E2C                                         ; DATA XREF: .xdata$x:00002AD4o
.text$x:00000E2C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000E2F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000E2F __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00000E2F
.text$x:00000E34
.text$x:00000E34 ; =============== S U B R O U T I N E =======================================
.text$x:00000E34
.text$x:00000E34
.text$x:00000E34 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00000E34                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00000E34
.text$x:00000E34 arg_4           = dword ptr  8
.text$x:00000E34
.text$x:00000E34                 mov     edx, [esp+arg_4]
.text$x:00000E38                 lea     eax, [edx+0Ch]
.text$x:00000E3B                 mov     ecx, [edx-8]
.text$x:00000E3E                 xor     ecx, eax
.text$x:00000E40                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E45                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00000E4A                 jmp     ___CxxFrameHandler3
.text$x:00000E4A __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00000E4A
.text$x:00000E4A ; ---------------------------------------------------------------------------
.text$x:00000E4F                 align 10h
.text$x:00000E4F _text$x         ends
.text$x:00000E4F
.text$mn:00000E50 ; ===========================================================================
.text$mn:00000E50
.text$mn:00000E50 ; Segment type: Pure code
.text$mn:00000E50 ; Segment permissions: Read/Execute
.text$mn:00000E50 _text$mn        segment para public 'CODE' use32
.text$mn:00000E50                 assume cs:_text$mn
.text$mn:00000E50                 ;org 0E50h
.text$mn:00000E50 ; COMDAT (pick any)
.text$mn:00000E50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E50
.text$mn:00000E50 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E50
.text$mn:00000E50 ; Attributes: bp-based frame
.text$mn:00000E50
.text$mn:00000E50 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000E50                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000E50 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00000E50                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000E50                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000E50
.text$mn:00000E50 var_10          = dword ptr -10h
.text$mn:00000E50 var_C           = dword ptr -0Ch
.text$mn:00000E50 var_4           = dword ptr -4
.text$mn:00000E50
.text$mn:00000E50                 push    ebp
.text$mn:00000E51                 mov     ebp, esp
.text$mn:00000E53                 push    0FFFFFFFFh
.text$mn:00000E55                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000E5A                 mov     eax, large fs:0
.text$mn:00000E60                 push    eax
.text$mn:00000E61                 push    ecx
.text$mn:00000E62                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000E67                 xor     eax, ebp
.text$mn:00000E69                 push    eax
.text$mn:00000E6A                 lea     eax, [ebp+var_C]
.text$mn:00000E6D                 mov     large fs:0, eax
.text$mn:00000E73                 mov     [ebp+var_10], ecx
.text$mn:00000E76                 mov     [ebp+var_4], 0
.text$mn:00000E7D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E84                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000E87                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000E8C                 mov     ecx, [ebp+var_C]
.text$mn:00000E8F                 mov     large fs:0, ecx
.text$mn:00000E96                 pop     ecx
.text$mn:00000E97                 mov     esp, ebp
.text$mn:00000E99                 pop     ebp
.text$mn:00000E9A                 retn
.text$mn:00000E9A ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00000E9A
.text$mn:00000E9A ; ---------------------------------------------------------------------------
.text$mn:00000E9B                 align 4
.text$mn:00000E9B _text$mn        ends
.text$mn:00000E9B
.text$x:00000E9C ; ===========================================================================
.text$x:00000E9C
.text$x:00000E9C ; Segment type: Pure code
.text$x:00000E9C ; Segment permissions: Read/Execute
.text$x:00000E9C _text$x         segment para public 'CODE' use32
.text$x:00000E9C                 assume cs:_text$x
.text$x:00000E9C                 ;org 0E9Ch
.text$x:00000E9C ; COMDAT (pick associative to section at E50)
.text$x:00000E9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000E9C
.text$x:00000E9C ; =============== S U B R O U T I N E =======================================
.text$x:00000E9C
.text$x:00000E9C
.text$x:00000E9C __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00000E9C                                         ; DATA XREF: .xdata$x:00002B58o
.text$x:00000E9C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000E9F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000E9F __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00000E9F
.text$x:00000EA4
.text$x:00000EA4 ; =============== S U B R O U T I N E =======================================
.text$x:00000EA4
.text$x:00000EA4
.text$x:00000EA4 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00000EA4                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00000EA4
.text$x:00000EA4 arg_4           = dword ptr  8
.text$x:00000EA4
.text$x:00000EA4                 mov     edx, [esp+arg_4]
.text$x:00000EA8                 lea     eax, [edx+0Ch]
.text$x:00000EAB                 mov     ecx, [edx-8]
.text$x:00000EAE                 xor     ecx, eax
.text$x:00000EB0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000EB5                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00000EBA                 jmp     ___CxxFrameHandler3
.text$x:00000EBA __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00000EBA
.text$x:00000EBA ; ---------------------------------------------------------------------------
.text$x:00000EBF                 align 10h
.text$x:00000EBF _text$x         ends
.text$x:00000EBF
.text$mn:00000EC0 ; ===========================================================================
.text$mn:00000EC0
.text$mn:00000EC0 ; Segment type: Pure code
.text$mn:00000EC0 ; Segment permissions: Read/Execute
.text$mn:00000EC0 _text$mn        segment para public 'CODE' use32
.text$mn:00000EC0                 assume cs:_text$mn
.text$mn:00000EC0                 ;org 0EC0h
.text$mn:00000EC0 ; COMDAT (pick any)
.text$mn:00000EC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000EC0
.text$mn:00000EC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EC0
.text$mn:00000EC0 ; Attributes: bp-based frame
.text$mn:00000EC0
.text$mn:00000EC0 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000EC0                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00000EC0 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00000EC0                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000EC0                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000EC0
.text$mn:00000EC0 var_10          = dword ptr -10h
.text$mn:00000EC0 var_C           = dword ptr -0Ch
.text$mn:00000EC0 var_4           = dword ptr -4
.text$mn:00000EC0
.text$mn:00000EC0                 push    ebp
.text$mn:00000EC1                 mov     ebp, esp
.text$mn:00000EC3                 push    0FFFFFFFFh
.text$mn:00000EC5                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00000ECA                 mov     eax, large fs:0
.text$mn:00000ED0                 push    eax
.text$mn:00000ED1                 push    ecx
.text$mn:00000ED2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000ED7                 xor     eax, ebp
.text$mn:00000ED9                 push    eax
.text$mn:00000EDA                 lea     eax, [ebp+var_C]
.text$mn:00000EDD                 mov     large fs:0, eax
.text$mn:00000EE3                 mov     [ebp+var_10], ecx
.text$mn:00000EE6                 mov     [ebp+var_4], 0
.text$mn:00000EED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000EF4                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000EF7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000EFC                 mov     ecx, [ebp+var_C]
.text$mn:00000EFF                 mov     large fs:0, ecx
.text$mn:00000F06                 pop     ecx
.text$mn:00000F07                 mov     esp, ebp
.text$mn:00000F09                 pop     ebp
.text$mn:00000F0A                 retn
.text$mn:00000F0A ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00000F0A
.text$mn:00000F0A ; ---------------------------------------------------------------------------
.text$mn:00000F0B                 align 4
.text$mn:00000F0B _text$mn        ends
.text$mn:00000F0B
.text$x:00000F0C ; ===========================================================================
.text$x:00000F0C
.text$x:00000F0C ; Segment type: Pure code
.text$x:00000F0C ; Segment permissions: Read/Execute
.text$x:00000F0C _text$x         segment para public 'CODE' use32
.text$x:00000F0C                 assume cs:_text$x
.text$x:00000F0C                 ;org 0F0Ch
.text$x:00000F0C ; COMDAT (pick associative to section at EC0)
.text$x:00000F0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000F0C
.text$x:00000F0C ; =============== S U B R O U T I N E =======================================
.text$x:00000F0C
.text$x:00000F0C
.text$x:00000F0C __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00000F0C                                         ; DATA XREF: .xdata$x:00002BDCo
.text$x:00000F0C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000F0F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000F0F __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00000F0F
.text$x:00000F14
.text$x:00000F14 ; =============== S U B R O U T I N E =======================================
.text$x:00000F14
.text$x:00000F14
.text$x:00000F14 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00000F14                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00000F14
.text$x:00000F14 arg_4           = dword ptr  8
.text$x:00000F14
.text$x:00000F14                 mov     edx, [esp+arg_4]
.text$x:00000F18                 lea     eax, [edx+0Ch]
.text$x:00000F1B                 mov     ecx, [edx-8]
.text$x:00000F1E                 xor     ecx, eax
.text$x:00000F20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000F25                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00000F2A                 jmp     ___CxxFrameHandler3
.text$x:00000F2A __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00000F2A
.text$x:00000F2A ; ---------------------------------------------------------------------------
.text$x:00000F2F                 align 10h
.text$x:00000F2F _text$x         ends
.text$x:00000F2F
.text$mn:00000F30 ; ===========================================================================
.text$mn:00000F30
.text$mn:00000F30 ; Segment type: Pure code
.text$mn:00000F30 ; Segment permissions: Read/Execute
.text$mn:00000F30 _text$mn        segment para public 'CODE' use32
.text$mn:00000F30                 assume cs:_text$mn
.text$mn:00000F30                 ;org 0F30h
.text$mn:00000F30 ; COMDAT (pick any)
.text$mn:00000F30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F30
.text$mn:00000F30 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F30
.text$mn:00000F30 ; Attributes: bp-based frame
.text$mn:00000F30
.text$mn:00000F30 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00000F30                 public ??1error_category@std@@UAE@XZ
.text$mn:00000F30 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00000F30                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00000F30
.text$mn:00000F30 var_4           = dword ptr -4
.text$mn:00000F30
.text$mn:00000F30                 push    ebp
.text$mn:00000F31                 mov     ebp, esp
.text$mn:00000F33                 push    ecx
.text$mn:00000F34                 mov     [ebp+var_4], ecx
.text$mn:00000F37                 mov     eax, [ebp+var_4]
.text$mn:00000F3A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000F40                 mov     esp, ebp
.text$mn:00000F42                 pop     ebp
.text$mn:00000F43                 retn
.text$mn:00000F43 ??1error_category@std@@UAE@XZ endp
.text$mn:00000F43
.text$mn:00000F43 _text$mn        ends
.text$mn:00000F43
.text$mn:00000F44 ; ===========================================================================
.text$mn:00000F44
.text$mn:00000F44 ; Segment type: Pure code
.text$mn:00000F44 ; Segment permissions: Read/Execute
.text$mn:00000F44 _text$mn        segment para public 'CODE' use32
.text$mn:00000F44                 assume cs:_text$mn
.text$mn:00000F44                 ;org 0F44h
.text$mn:00000F44 ; COMDAT (pick any)
.text$mn:00000F44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F44
.text$mn:00000F44 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F44
.text$mn:00000F44 ; Attributes: bp-based frame
.text$mn:00000F44
.text$mn:00000F44 ; _DWORD __thiscall std::runtime_error::~runtime_error(std::runtime_error *__hidden this)
.text$mn:00000F44                 public ??1runtime_error@std@@UAE@XZ
.text$mn:00000F44 ??1runtime_error@std@@UAE@XZ proc near  ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+Ap
.text$mn:00000F44                                         ; DATA XREF: .xdata$x:00002D28o
.text$mn:00000F44
.text$mn:00000F44 var_10          = dword ptr -10h
.text$mn:00000F44 var_C           = dword ptr -0Ch
.text$mn:00000F44 var_4           = dword ptr -4
.text$mn:00000F44
.text$mn:00000F44                 push    ebp
.text$mn:00000F45                 mov     ebp, esp
.text$mn:00000F47                 push    0FFFFFFFFh
.text$mn:00000F49                 push    offset __ehhandler$??1runtime_error@std@@UAE@XZ
.text$mn:00000F4E                 mov     eax, large fs:0
.text$mn:00000F54                 push    eax
.text$mn:00000F55                 push    ecx
.text$mn:00000F56                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F5B                 xor     eax, ebp
.text$mn:00000F5D                 push    eax
.text$mn:00000F5E                 lea     eax, [ebp+var_C]
.text$mn:00000F61                 mov     large fs:0, eax
.text$mn:00000F67                 mov     [ebp+var_10], ecx
.text$mn:00000F6A                 mov     [ebp+var_4], 0
.text$mn:00000F71                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F78                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000F7B                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:00000F80                 mov     ecx, [ebp+var_C]
.text$mn:00000F83                 mov     large fs:0, ecx
.text$mn:00000F8A                 pop     ecx
.text$mn:00000F8B                 mov     esp, ebp
.text$mn:00000F8D                 pop     ebp
.text$mn:00000F8E                 retn
.text$mn:00000F8E ??1runtime_error@std@@UAE@XZ endp
.text$mn:00000F8E
.text$mn:00000F8E ; ---------------------------------------------------------------------------
.text$mn:00000F8F                 align 10h
.text$mn:00000F8F _text$mn        ends
.text$mn:00000F8F
.text$x:00000F90 ; ===========================================================================
.text$x:00000F90
.text$x:00000F90 ; Segment type: Pure code
.text$x:00000F90 ; Segment permissions: Read/Execute
.text$x:00000F90 _text$x         segment para public 'CODE' use32
.text$x:00000F90                 assume cs:_text$x
.text$x:00000F90                 ;org 0F90h
.text$x:00000F90 ; COMDAT (pick associative to section at F44)
.text$x:00000F90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000F90
.text$x:00000F90 ; =============== S U B R O U T I N E =======================================
.text$x:00000F90
.text$x:00000F90
.text$x:00000F90 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 proc near
.text$x:00000F90                                         ; DATA XREF: .xdata$x:00002A24o
.text$x:00000F90                 mov     ecx, [ebp-10h]  ; this
.text$x:00000F93                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00000F93 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 endp
.text$x:00000F93
.text$x:00000F98
.text$x:00000F98 ; =============== S U B R O U T I N E =======================================
.text$x:00000F98
.text$x:00000F98
.text$x:00000F98 __ehhandler$??1runtime_error@std@@UAE@XZ proc near
.text$x:00000F98                                         ; DATA XREF: std::runtime_error::~runtime_error(void)+5o
.text$x:00000F98
.text$x:00000F98 arg_4           = dword ptr  8
.text$x:00000F98
.text$x:00000F98                 mov     edx, [esp+arg_4]
.text$x:00000F9C                 lea     eax, [edx+0Ch]
.text$x:00000F9F                 mov     ecx, [edx-8]
.text$x:00000FA2                 xor     ecx, eax
.text$x:00000FA4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000FA9                 mov     eax, offset __ehfuncinfo$??1runtime_error@std@@UAE@XZ
.text$x:00000FAE                 jmp     ___CxxFrameHandler3
.text$x:00000FAE __ehhandler$??1runtime_error@std@@UAE@XZ endp
.text$x:00000FAE
.text$x:00000FAE ; ---------------------------------------------------------------------------
.text$x:00000FB3                 align 4
.text$x:00000FB3 _text$x         ends
.text$x:00000FB3
.text$mn:00000FB4 ; ===========================================================================
.text$mn:00000FB4
.text$mn:00000FB4 ; Segment type: Pure code
.text$mn:00000FB4 ; Segment permissions: Read/Execute
.text$mn:00000FB4 _text$mn        segment para public 'CODE' use32
.text$mn:00000FB4                 assume cs:_text$mn
.text$mn:00000FB4                 ;org 0FB4h
.text$mn:00000FB4 ; COMDAT (pick any)
.text$mn:00000FB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FB4
.text$mn:00000FB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FB4
.text$mn:00000FB4 ; Attributes: bp-based frame
.text$mn:00000FB4
.text$mn:00000FB4 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00000FB4                 public ??2@YAPAXIPAX@Z
.text$mn:00000FB4 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00000FB4                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+2Ep ...
.text$mn:00000FB4
.text$mn:00000FB4 arg_4           = dword ptr  0Ch
.text$mn:00000FB4
.text$mn:00000FB4                 push    ebp
.text$mn:00000FB5                 mov     ebp, esp
.text$mn:00000FB7                 mov     eax, [ebp+arg_4]
.text$mn:00000FBA                 pop     ebp
.text$mn:00000FBB                 retn
.text$mn:00000FBB ??2@YAPAXIPAX@Z endp
.text$mn:00000FBB
.text$mn:00000FBB _text$mn        ends
.text$mn:00000FBB
.text$mn:00000FBC ; ===========================================================================
.text$mn:00000FBC
.text$mn:00000FBC ; Segment type: Pure code
.text$mn:00000FBC ; Segment permissions: Read/Execute
.text$mn:00000FBC _text$mn        segment para public 'CODE' use32
.text$mn:00000FBC                 assume cs:_text$mn
.text$mn:00000FBC                 ;org 0FBCh
.text$mn:00000FBC ; COMDAT (pick any)
.text$mn:00000FBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FBC
.text$mn:00000FBC ; =============== S U B R O U T I N E =======================================
.text$mn:00000FBC
.text$mn:00000FBC ; Attributes: bp-based frame
.text$mn:00000FBC
.text$mn:00000FBC ; void __cdecl operator delete(void *)
.text$mn:00000FBC                 public ??3@YAXPAX0@Z
.text$mn:00000FBC ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00000FBC                                         ; __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0+8p ...
.text$mn:00000FBC                 push    ebp
.text$mn:00000FBD                 mov     ebp, esp
.text$mn:00000FBF                 pop     ebp
.text$mn:00000FC0                 retn
.text$mn:00000FC0 ??3@YAXPAX0@Z   endp
.text$mn:00000FC0
.text$mn:00000FC0 ; ---------------------------------------------------------------------------
.text$mn:00000FC1                 align 4
.text$mn:00000FC1 _text$mn        ends
.text$mn:00000FC1
.text$mn:00000FC4 ; ===========================================================================
.text$mn:00000FC4
.text$mn:00000FC4 ; Segment type: Pure code
.text$mn:00000FC4 ; Segment permissions: Read/Execute
.text$mn:00000FC4 _text$mn        segment para public 'CODE' use32
.text$mn:00000FC4                 assume cs:_text$mn
.text$mn:00000FC4                 ;org 0FC4h
.text$mn:00000FC4 ; COMDAT (pick any)
.text$mn:00000FC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FC4
.text$mn:00000FC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FC4
.text$mn:00000FC4 ; Attributes: bp-based frame
.text$mn:00000FC4
.text$mn:00000FC4 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t *Str)
.text$mn:00000FC4                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:00000FC4 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:00000FC4                                         ; CODE XREF: StatusBar::setText(wchar_t const *,int)+22p
.text$mn:00000FC4                                         ; StatusBar::setOwnerDrawText(wchar_t const *)+13p
.text$mn:00000FC4
.text$mn:00000FC4 var_4           = dword ptr -4
.text$mn:00000FC4 Str             = dword ptr  8
.text$mn:00000FC4
.text$mn:00000FC4                 push    ebp
.text$mn:00000FC5                 mov     ebp, esp
.text$mn:00000FC7                 push    ecx
.text$mn:00000FC8                 mov     [ebp+var_4], ecx
.text$mn:00000FCB                 mov     eax, [ebp+Str]
.text$mn:00000FCE                 push    eax             ; Str
.text$mn:00000FCF                 mov     ecx, [ebp+var_4]
.text$mn:00000FD2                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00000FD7                 mov     esp, ebp
.text$mn:00000FD9                 pop     ebp
.text$mn:00000FDA                 retn    4
.text$mn:00000FDA ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:00000FDA
.text$mn:00000FDA ; ---------------------------------------------------------------------------
.text$mn:00000FDD                 align 10h
.text$mn:00000FDD _text$mn        ends
.text$mn:00000FDD
.text$mn:00000FE0 ; ===========================================================================
.text$mn:00000FE0
.text$mn:00000FE0 ; Segment type: Pure code
.text$mn:00000FE0 ; Segment permissions: Read/Execute
.text$mn:00000FE0 _text$mn        segment para public 'CODE' use32
.text$mn:00000FE0                 assume cs:_text$mn
.text$mn:00000FE0                 ;org 0FE0h
.text$mn:00000FE0 ; COMDAT (pick any)
.text$mn:00000FE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FE0
.text$mn:00000FE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FE0
.text$mn:00000FE0 ; Attributes: bp-based frame
.text$mn:00000FE0
.text$mn:00000FE0 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00000FE0                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00000FE0 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00000FE0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00000FE0                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00000FE0
.text$mn:00000FE0 var_8           = dword ptr -8
.text$mn:00000FE0 var_4           = dword ptr -4
.text$mn:00000FE0 arg_0           = dword ptr  8
.text$mn:00000FE0
.text$mn:00000FE0                 push    ebp
.text$mn:00000FE1                 mov     ebp, esp
.text$mn:00000FE3                 sub     esp, 8
.text$mn:00000FE6                 mov     [ebp+var_8], ecx
.text$mn:00000FE9                 mov     eax, [ebp+var_8]
.text$mn:00000FEC                 cmp     eax, [ebp+arg_0]
.text$mn:00000FEF                 jnz     short loc_FFA
.text$mn:00000FF1                 mov     [ebp+var_4], 1
.text$mn:00000FF8                 jmp     short loc_1001
.text$mn:00000FFA ; ---------------------------------------------------------------------------
.text$mn:00000FFA
.text$mn:00000FFA loc_FFA:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00000FFA                 mov     [ebp+var_4], 0
.text$mn:00001001
.text$mn:00001001 loc_1001:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00001001                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001004                 mov     esp, ebp
.text$mn:00001006                 pop     ebp
.text$mn:00001007                 retn    4
.text$mn:00001007 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00001007
.text$mn:00001007 ; ---------------------------------------------------------------------------
.text$mn:0000100A                 align 4
.text$mn:0000100A _text$mn        ends
.text$mn:0000100A
.text$mn:0000100C ; ===========================================================================
.text$mn:0000100C
.text$mn:0000100C ; Segment type: Pure code
.text$mn:0000100C ; Segment permissions: Read/Execute
.text$mn:0000100C _text$mn        segment para public 'CODE' use32
.text$mn:0000100C                 assume cs:_text$mn
.text$mn:0000100C                 ;org 100Ch
.text$mn:0000100C ; COMDAT (pick any)
.text$mn:0000100C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000100C
.text$mn:0000100C ; =============== S U B R O U T I N E =======================================
.text$mn:0000100C
.text$mn:0000100C ; Attributes: bp-based frame
.text$mn:0000100C
.text$mn:0000100C ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:0000100C                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:0000100C ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:0000100C                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:0000100C
.text$mn:0000100C var_8           = dword ptr -8
.text$mn:0000100C var_4           = dword ptr -4
.text$mn:0000100C arg_0           = dword ptr  8
.text$mn:0000100C
.text$mn:0000100C                 push    ebp
.text$mn:0000100D                 mov     ebp, esp
.text$mn:0000100F                 sub     esp, 8
.text$mn:00001012                 push    esi
.text$mn:00001013                 mov     [ebp+var_4], ecx
.text$mn:00001016                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001019                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000101E                 push    eax
.text$mn:0000101F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001022                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001027                 mov     ecx, eax
.text$mn:00001029                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000102E                 movzx   eax, al
.text$mn:00001031                 test    eax, eax
.text$mn:00001033                 jz      short loc_1054
.text$mn:00001035                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001038                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:0000103D                 mov     esi, eax
.text$mn:0000103F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001042                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001047                 cmp     esi, eax
.text$mn:00001049                 jnz     short loc_1054
.text$mn:0000104B                 mov     [ebp+var_8], 1
.text$mn:00001052                 jmp     short loc_105B
.text$mn:00001054 ; ---------------------------------------------------------------------------
.text$mn:00001054
.text$mn:00001054 loc_1054:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00001054                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00001054                 mov     [ebp+var_8], 0
.text$mn:0000105B
.text$mn:0000105B loc_105B:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:0000105B                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000105E                 pop     esi
.text$mn:0000105F                 mov     esp, ebp
.text$mn:00001061                 pop     ebp
.text$mn:00001062                 retn    4
.text$mn:00001062 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00001062
.text$mn:00001062 ; ---------------------------------------------------------------------------
.text$mn:00001065                 align 4
.text$mn:00001065 _text$mn        ends
.text$mn:00001065
.text$mn:00001068 ; ===========================================================================
.text$mn:00001068
.text$mn:00001068 ; Segment type: Pure code
.text$mn:00001068 ; Segment permissions: Read/Execute
.text$mn:00001068 _text$mn        segment para public 'CODE' use32
.text$mn:00001068                 assume cs:_text$mn
.text$mn:00001068                 ;org 1068h
.text$mn:00001068 ; COMDAT (pick any)
.text$mn:00001068                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001068
.text$mn:00001068 ; =============== S U B R O U T I N E =======================================
.text$mn:00001068
.text$mn:00001068 ; Attributes: bp-based frame
.text$mn:00001068
.text$mn:00001068 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001068                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00001068 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001068
.text$mn:00001068 var_4           = dword ptr -4
.text$mn:00001068 arg_0           = dword ptr  8
.text$mn:00001068
.text$mn:00001068                 push    ebp
.text$mn:00001069                 mov     ebp, esp
.text$mn:0000106B                 push    ecx
.text$mn:0000106C                 mov     [ebp+var_4], ecx
.text$mn:0000106F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001072                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001077                 mov     eax, [ebp+arg_0]
.text$mn:0000107A                 and     eax, 1
.text$mn:0000107D                 jz      short loc_108B
.text$mn:0000107F                 mov     ecx, [ebp+var_4]
.text$mn:00001082                 push    ecx             ; void *
.text$mn:00001083                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001088                 add     esp, 4
.text$mn:0000108B
.text$mn:0000108B loc_108B:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000108B                 mov     eax, [ebp+var_4]
.text$mn:0000108E                 mov     esp, ebp
.text$mn:00001090                 pop     ebp
.text$mn:00001091                 retn    4
.text$mn:00001091 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00001091
.text$mn:00001091 _text$mn        ends
.text$mn:00001091
.text$mn:00001094 ; ===========================================================================
.text$mn:00001094
.text$mn:00001094 ; Segment type: Pure code
.text$mn:00001094 ; Segment permissions: Read/Execute
.text$mn:00001094 _text$mn        segment para public 'CODE' use32
.text$mn:00001094                 assume cs:_text$mn
.text$mn:00001094                 ;org 1094h
.text$mn:00001094 ; COMDAT (pick any)
.text$mn:00001094                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001094
.text$mn:00001094 ; =============== S U B R O U T I N E =======================================
.text$mn:00001094
.text$mn:00001094 ; Attributes: bp-based frame
.text$mn:00001094
.text$mn:00001094 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001094                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00001094 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001094
.text$mn:00001094 var_4           = dword ptr -4
.text$mn:00001094 arg_0           = dword ptr  8
.text$mn:00001094
.text$mn:00001094                 push    ebp
.text$mn:00001095                 mov     ebp, esp
.text$mn:00001097                 push    ecx
.text$mn:00001098                 mov     [ebp+var_4], ecx
.text$mn:0000109B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000109E                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:000010A3                 mov     eax, [ebp+arg_0]
.text$mn:000010A6                 and     eax, 1
.text$mn:000010A9                 jz      short loc_10B7
.text$mn:000010AB                 mov     ecx, [ebp+var_4]
.text$mn:000010AE                 push    ecx             ; void *
.text$mn:000010AF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000010B4                 add     esp, 4
.text$mn:000010B7
.text$mn:000010B7 loc_10B7:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000010B7                 mov     eax, [ebp+var_4]
.text$mn:000010BA                 mov     esp, ebp
.text$mn:000010BC                 pop     ebp
.text$mn:000010BD                 retn    4
.text$mn:000010BD ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:000010BD
.text$mn:000010BD _text$mn        ends
.text$mn:000010BD
.text$mn:000010C0 ; ===========================================================================
.text$mn:000010C0
.text$mn:000010C0 ; Segment type: Pure code
.text$mn:000010C0 ; Segment permissions: Read/Execute
.text$mn:000010C0 _text$mn        segment para public 'CODE' use32
.text$mn:000010C0                 assume cs:_text$mn
.text$mn:000010C0                 ;org 10C0h
.text$mn:000010C0 ; COMDAT (pick any)
.text$mn:000010C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010C0
.text$mn:000010C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000010C0
.text$mn:000010C0 ; Attributes: bp-based frame
.text$mn:000010C0
.text$mn:000010C0 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000010C0                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:000010C0 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:000010C0
.text$mn:000010C0 var_4           = dword ptr -4
.text$mn:000010C0 arg_0           = dword ptr  8
.text$mn:000010C0
.text$mn:000010C0                 push    ebp
.text$mn:000010C1                 mov     ebp, esp
.text$mn:000010C3                 push    ecx
.text$mn:000010C4                 mov     [ebp+var_4], ecx
.text$mn:000010C7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000010CA                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:000010CF                 mov     eax, [ebp+arg_0]
.text$mn:000010D2                 and     eax, 1
.text$mn:000010D5                 jz      short loc_10E3
.text$mn:000010D7                 mov     ecx, [ebp+var_4]
.text$mn:000010DA                 push    ecx             ; void *
.text$mn:000010DB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000010E0                 add     esp, 4
.text$mn:000010E3
.text$mn:000010E3 loc_10E3:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000010E3                 mov     eax, [ebp+var_4]
.text$mn:000010E6                 mov     esp, ebp
.text$mn:000010E8                 pop     ebp
.text$mn:000010E9                 retn    4
.text$mn:000010E9 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:000010E9
.text$mn:000010E9 _text$mn        ends
.text$mn:000010E9
.text$mn:000010EC ; ===========================================================================
.text$mn:000010EC
.text$mn:000010EC ; Segment type: Pure code
.text$mn:000010EC ; Segment permissions: Read/Execute
.text$mn:000010EC _text$mn        segment para public 'CODE' use32
.text$mn:000010EC                 assume cs:_text$mn
.text$mn:000010EC                 ;org 10ECh
.text$mn:000010EC ; COMDAT (pick any)
.text$mn:000010EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010EC
.text$mn:000010EC ; =============== S U B R O U T I N E =======================================
.text$mn:000010EC
.text$mn:000010EC ; Attributes: bp-based frame
.text$mn:000010EC
.text$mn:000010EC ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000010EC                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:000010EC ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:000010EC
.text$mn:000010EC var_4           = dword ptr -4
.text$mn:000010EC arg_0           = dword ptr  8
.text$mn:000010EC
.text$mn:000010EC                 push    ebp
.text$mn:000010ED                 mov     ebp, esp
.text$mn:000010EF                 push    ecx
.text$mn:000010F0                 mov     [ebp+var_4], ecx
.text$mn:000010F3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000010F6                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000010FB                 mov     eax, [ebp+arg_0]
.text$mn:000010FE                 and     eax, 1
.text$mn:00001101                 jz      short loc_110F
.text$mn:00001103                 mov     ecx, [ebp+var_4]
.text$mn:00001106                 push    ecx             ; void *
.text$mn:00001107                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000110C                 add     esp, 4
.text$mn:0000110F
.text$mn:0000110F loc_110F:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000110F                 mov     eax, [ebp+var_4]
.text$mn:00001112                 mov     esp, ebp
.text$mn:00001114                 pop     ebp
.text$mn:00001115                 retn    4
.text$mn:00001115 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00001115
.text$mn:00001115 _text$mn        ends
.text$mn:00001115
.text$mn:00001118 ; ===========================================================================
.text$mn:00001118
.text$mn:00001118 ; Segment type: Pure code
.text$mn:00001118 ; Segment permissions: Read/Execute
.text$mn:00001118 _text$mn        segment para public 'CODE' use32
.text$mn:00001118                 assume cs:_text$mn
.text$mn:00001118                 ;org 1118h
.text$mn:00001118 ; COMDAT (pick any)
.text$mn:00001118                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001118
.text$mn:00001118 ; =============== S U B R O U T I N E =======================================
.text$mn:00001118
.text$mn:00001118 ; Attributes: bp-based frame
.text$mn:00001118
.text$mn:00001118 ; public: virtual void * __thiscall std::runtime_error::`scalar deleting destructor'(unsigned int)
.text$mn:00001118                 public ??_Gruntime_error@std@@UAEPAXI@Z
.text$mn:00001118 ??_Gruntime_error@std@@UAEPAXI@Z proc near
.text$mn:00001118
.text$mn:00001118 var_4           = dword ptr -4
.text$mn:00001118 arg_0           = dword ptr  8
.text$mn:00001118
.text$mn:00001118                 push    ebp
.text$mn:00001119                 mov     ebp, esp
.text$mn:0000111B                 push    ecx
.text$mn:0000111C                 mov     [ebp+var_4], ecx
.text$mn:0000111F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001122                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:00001127                 mov     eax, [ebp+arg_0]
.text$mn:0000112A                 and     eax, 1
.text$mn:0000112D                 jz      short loc_113B
.text$mn:0000112F                 mov     ecx, [ebp+var_4]
.text$mn:00001132                 push    ecx             ; void *
.text$mn:00001133                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001138                 add     esp, 4
.text$mn:0000113B
.text$mn:0000113B loc_113B:                               ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+15j
.text$mn:0000113B                 mov     eax, [ebp+var_4]
.text$mn:0000113E                 mov     esp, ebp
.text$mn:00001140                 pop     ebp
.text$mn:00001141                 retn    4
.text$mn:00001141 ??_Gruntime_error@std@@UAEPAXI@Z endp
.text$mn:00001141
.text$mn:00001141 _text$mn        ends
.text$mn:00001141
.text$di:00001144 ; ===========================================================================
.text$di:00001144
.text$di:00001144 ; Segment type: Pure code
.text$di:00001144 ; Segment permissions: Read/Execute
.text$di:00001144 _text$di        segment para public 'CODE' use32
.text$di:00001144                 assume cs:_text$di
.text$di:00001144                 ;org 1144h
.text$di:00001144 ; COMDAT (pick any)
.text$di:00001144                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001144
.text$di:00001144 ; =============== S U B R O U T I N E =======================================
.text$di:00001144
.text$di:00001144 ; Attributes: bp-based frame
.text$di:00001144
.text$di:00001144 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00001144 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00001144                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00001144                 push    ebp
.text$di:00001145                 mov     ebp, esp
.text$di:00001147                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:0000114C                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00001151                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001156                 call    _atexit
.text$di:0000115B                 add     esp, 4
.text$di:0000115E                 pop     ebp
.text$di:0000115F                 retn
.text$di:0000115F ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:0000115F
.text$di:0000115F _text$di        ends
.text$di:0000115F
.text$di:00001160 ; ===========================================================================
.text$di:00001160
.text$di:00001160 ; Segment type: Pure code
.text$di:00001160 ; Segment permissions: Read/Execute
.text$di:00001160 _text$di        segment para public 'CODE' use32
.text$di:00001160                 assume cs:_text$di
.text$di:00001160                 ;org 1160h
.text$di:00001160 ; COMDAT (pick any)
.text$di:00001160                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001160
.text$di:00001160 ; =============== S U B R O U T I N E =======================================
.text$di:00001160
.text$di:00001160 ; Attributes: bp-based frame
.text$di:00001160
.text$di:00001160 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00001160 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00001160                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00001160                 push    ebp
.text$di:00001161                 mov     ebp, esp
.text$di:00001163                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00001168                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:0000116D                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001172                 call    _atexit
.text$di:00001177                 add     esp, 4
.text$di:0000117A                 pop     ebp
.text$di:0000117B                 retn
.text$di:0000117B ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:0000117B
.text$di:0000117B _text$di        ends
.text$di:0000117B
.text$di:0000117C ; ===========================================================================
.text$di:0000117C
.text$di:0000117C ; Segment type: Pure code
.text$di:0000117C ; Segment permissions: Read/Execute
.text$di:0000117C _text$di        segment para public 'CODE' use32
.text$di:0000117C                 assume cs:_text$di
.text$di:0000117C                 ;org 117Ch
.text$di:0000117C ; COMDAT (pick any)
.text$di:0000117C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000117C
.text$di:0000117C ; =============== S U B R O U T I N E =======================================
.text$di:0000117C
.text$di:0000117C ; Attributes: bp-based frame
.text$di:0000117C
.text$di:0000117C ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:0000117C ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:0000117C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:0000117C                 push    ebp
.text$di:0000117D                 mov     ebp, esp
.text$di:0000117F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00001184                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00001189                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000118E                 call    _atexit
.text$di:00001193                 add     esp, 4
.text$di:00001196                 pop     ebp
.text$di:00001197                 retn
.text$di:00001197 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00001197
.text$di:00001197 _text$di        ends
.text$di:00001197
.text$di:00001198 ; ===========================================================================
.text$di:00001198
.text$di:00001198 ; Segment type: Pure code
.text$di:00001198 ; Segment permissions: Read/Execute
.text$di:00001198 _text$di        segment para public 'CODE' use32
.text$di:00001198                 assume cs:_text$di
.text$di:00001198                 ;org 1198h
.text$di:00001198 ; COMDAT (pick any)
.text$di:00001198                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001198
.text$di:00001198 ; =============== S U B R O U T I N E =======================================
.text$di:00001198
.text$di:00001198 ; Attributes: bp-based frame
.text$di:00001198
.text$di:00001198 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00001198 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001198                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00001198                 push    ebp
.text$di:00001199                 mov     ebp, esp
.text$di:0000119B                 push    0               ; unsigned int
.text$di:0000119D                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000011A2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000011A7                 pop     ebp
.text$di:000011A8                 retn
.text$di:000011A8 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000011A8
.text$di:000011A8 ; ---------------------------------------------------------------------------
.text$di:000011A9                 align 4
.text$di:000011A9 _text$di        ends
.text$di:000011A9
.text$di:000011AC ; ===========================================================================
.text$di:000011AC
.text$di:000011AC ; Segment type: Pure code
.text$di:000011AC ; Segment permissions: Read/Execute
.text$di:000011AC _text$di        segment para public 'CODE' use32
.text$di:000011AC                 assume cs:_text$di
.text$di:000011AC                 ;org 11ACh
.text$di:000011AC ; COMDAT (pick any)
.text$di:000011AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000011AC
.text$di:000011AC ; =============== S U B R O U T I N E =======================================
.text$di:000011AC
.text$di:000011AC ; Attributes: bp-based frame
.text$di:000011AC
.text$di:000011AC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:000011AC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000011AC                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:000011AC                 push    ebp
.text$di:000011AD                 mov     ebp, esp
.text$di:000011AF                 push    0               ; unsigned int
.text$di:000011B1                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000011B6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000011BB                 pop     ebp
.text$di:000011BC                 retn
.text$di:000011BC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000011BC
.text$di:000011BC ; ---------------------------------------------------------------------------
.text$di:000011BD                 align 10h
.text$di:000011BD _text$di        ends
.text$di:000011BD
.text$di:000011C0 ; ===========================================================================
.text$di:000011C0
.text$di:000011C0 ; Segment type: Pure code
.text$di:000011C0 ; Segment permissions: Read/Execute
.text$di:000011C0 _text$di        segment para public 'CODE' use32
.text$di:000011C0                 assume cs:_text$di
.text$di:000011C0                 ;org 11C0h
.text$di:000011C0 ; COMDAT (pick any)
.text$di:000011C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000011C0
.text$di:000011C0 ; =============== S U B R O U T I N E =======================================
.text$di:000011C0
.text$di:000011C0 ; Attributes: bp-based frame
.text$di:000011C0
.text$di:000011C0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:000011C0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000011C0                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:000011C0                 push    ebp
.text$di:000011C1                 mov     ebp, esp
.text$di:000011C3                 push    0               ; unsigned int
.text$di:000011C5                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:000011CA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000011CF                 pop     ebp
.text$di:000011D0                 retn
.text$di:000011D0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000011D0
.text$di:000011D0 ; ---------------------------------------------------------------------------
.text$di:000011D1                 align 4
.text$di:000011D1 _text$di        ends
.text$di:000011D1
.text$di:000011D4 ; ===========================================================================
.text$di:000011D4
.text$di:000011D4 ; Segment type: Pure code
.text$di:000011D4 ; Segment permissions: Read/Execute
.text$di:000011D4 _text$di        segment para public 'CODE' use32
.text$di:000011D4                 assume cs:_text$di
.text$di:000011D4                 ;org 11D4h
.text$di:000011D4 ; COMDAT (pick any)
.text$di:000011D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000011D4
.text$di:000011D4 ; =============== S U B R O U T I N E =======================================
.text$di:000011D4
.text$di:000011D4 ; Attributes: bp-based frame
.text$di:000011D4
.text$di:000011D4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:000011D4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000011D4                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:000011D4                 push    ebp
.text$di:000011D5                 mov     ebp, esp
.text$di:000011D7                 push    0               ; unsigned int
.text$di:000011D9                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:000011DE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000011E3                 pop     ebp
.text$di:000011E4                 retn
.text$di:000011E4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000011E4
.text$di:000011E4 ; ---------------------------------------------------------------------------
.text$di:000011E5                 align 4
.text$di:000011E5 _text$di        ends
.text$di:000011E5
.text$di:000011E8 ; ===========================================================================
.text$di:000011E8
.text$di:000011E8 ; Segment type: Pure code
.text$di:000011E8 ; Segment permissions: Read/Execute
.text$di:000011E8 _text$di        segment para public 'CODE' use32
.text$di:000011E8                 assume cs:_text$di
.text$di:000011E8                 ;org 11E8h
.text$di:000011E8 ; COMDAT (pick any)
.text$di:000011E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000011E8
.text$di:000011E8 ; =============== S U B R O U T I N E =======================================
.text$di:000011E8
.text$di:000011E8 ; Attributes: bp-based frame
.text$di:000011E8
.text$di:000011E8 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:000011E8 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:000011E8
.text$di:000011E8 var_1           = byte ptr -1
.text$di:000011E8
.text$di:000011E8                 push    ebp
.text$di:000011E9                 mov     ebp, esp
.text$di:000011EB                 push    ecx
.text$di:000011EC                 xor     eax, eax
.text$di:000011EE                 mov     [ebp+var_1], al
.text$di:000011F1                 mov     esp, ebp
.text$di:000011F3                 pop     ebp
.text$di:000011F4                 retn
.text$di:000011F4 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:000011F4
.text$di:000011F4 ; ---------------------------------------------------------------------------
.text$di:000011F5                 align 4
.text$di:000011F5 _text$di        ends
.text$di:000011F5
.text$di:000011F8 ; ===========================================================================
.text$di:000011F8
.text$di:000011F8 ; Segment type: Pure code
.text$di:000011F8 ; Segment permissions: Read/Execute
.text$di:000011F8 _text$di        segment para public 'CODE' use32
.text$di:000011F8                 assume cs:_text$di
.text$di:000011F8                 ;org 11F8h
.text$di:000011F8 ; COMDAT (pick any)
.text$di:000011F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000011F8
.text$di:000011F8 ; =============== S U B R O U T I N E =======================================
.text$di:000011F8
.text$di:000011F8 ; Attributes: bp-based frame
.text$di:000011F8
.text$di:000011F8 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:000011F8 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:000011F8                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:000011F8
.text$di:000011F8 var_1           = byte ptr -1
.text$di:000011F8
.text$di:000011F8                 push    ebp
.text$di:000011F9                 mov     ebp, esp
.text$di:000011FB                 push    ecx
.text$di:000011FC                 xor     eax, eax
.text$di:000011FE                 mov     [ebp+var_1], al
.text$di:00001201                 mov     esp, ebp
.text$di:00001203                 pop     ebp
.text$di:00001204                 retn
.text$di:00001204 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00001204
.text$di:00001204 ; ---------------------------------------------------------------------------
.text$di:00001205                 align 4
.text$di:00001205 _text$di        ends
.text$di:00001205
.text$yd:00001208 ; ===========================================================================
.text$yd:00001208
.text$yd:00001208 ; Segment type: Pure code
.text$yd:00001208 ; Segment permissions: Read/Execute
.text$yd:00001208 _text$yd        segment para public 'CODE' use32
.text$yd:00001208                 assume cs:_text$yd
.text$yd:00001208                 ;org 1208h
.text$yd:00001208 ; COMDAT (pick any)
.text$yd:00001208                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00001208
.text$yd:00001208 ; =============== S U B R O U T I N E =======================================
.text$yd:00001208
.text$yd:00001208 ; Attributes: bp-based frame
.text$yd:00001208
.text$yd:00001208 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00001208 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00001208                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00001208                 push    ebp
.text$yd:00001209                 mov     ebp, esp
.text$yd:0000120B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00001210                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00001215                 pop     ebp
.text$yd:00001216                 retn
.text$yd:00001216 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00001216
.text$yd:00001216 ; ---------------------------------------------------------------------------
.text$yd:00001217                 align 4
.text$yd:00001217 _text$yd        ends
.text$yd:00001217
.text$yd:00001218 ; ===========================================================================
.text$yd:00001218
.text$yd:00001218 ; Segment type: Pure code
.text$yd:00001218 ; Segment permissions: Read/Execute
.text$yd:00001218 _text$yd        segment para public 'CODE' use32
.text$yd:00001218                 assume cs:_text$yd
.text$yd:00001218                 ;org 1218h
.text$yd:00001218 ; COMDAT (pick any)
.text$yd:00001218                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00001218
.text$yd:00001218 ; =============== S U B R O U T I N E =======================================
.text$yd:00001218
.text$yd:00001218 ; Attributes: bp-based frame
.text$yd:00001218
.text$yd:00001218 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00001218 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00001218                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00001218                 push    ebp
.text$yd:00001219                 mov     ebp, esp
.text$yd:0000121B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00001220                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00001225                 pop     ebp
.text$yd:00001226                 retn
.text$yd:00001226 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00001226
.text$yd:00001226 ; ---------------------------------------------------------------------------
.text$yd:00001227                 align 4
.text$yd:00001227 _text$yd        ends
.text$yd:00001227
.text$yd:00001228 ; ===========================================================================
.text$yd:00001228
.text$yd:00001228 ; Segment type: Pure code
.text$yd:00001228 ; Segment permissions: Read/Execute
.text$yd:00001228 _text$yd        segment para public 'CODE' use32
.text$yd:00001228                 assume cs:_text$yd
.text$yd:00001228                 ;org 1228h
.text$yd:00001228 ; COMDAT (pick any)
.text$yd:00001228                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00001228
.text$yd:00001228 ; =============== S U B R O U T I N E =======================================
.text$yd:00001228
.text$yd:00001228 ; Attributes: bp-based frame
.text$yd:00001228
.text$yd:00001228 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00001228 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00001228                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00001228                 push    ebp
.text$yd:00001229                 mov     ebp, esp
.text$yd:0000122B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00001230                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00001235                 pop     ebp
.text$yd:00001236                 retn
.text$yd:00001236 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00001236
.text$yd:00001236 ; ---------------------------------------------------------------------------
.text$yd:00001237                 align 4
.text$yd:00001237 _text$yd        ends
.text$yd:00001237
.text$mn:00001238 ; ===========================================================================
.text$mn:00001238
.text$mn:00001238 ; Segment type: Pure code
.text$mn:00001238 ; Segment permissions: Read/Execute
.text$mn:00001238 _text$mn        segment para public 'CODE' use32
.text$mn:00001238                 assume cs:_text$mn
.text$mn:00001238                 ;org 1238h
.text$mn:00001238 ; COMDAT (pick any)
.text$mn:00001238                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001238
.text$mn:00001238 ; =============== S U B R O U T I N E =======================================
.text$mn:00001238
.text$mn:00001238 ; Attributes: bp-based frame
.text$mn:00001238
.text$mn:00001238 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00001238                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001238 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001238                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00001238
.text$mn:00001238 var_10          = byte ptr -10h
.text$mn:00001238 var_8           = dword ptr -8
.text$mn:00001238 var_1           = byte ptr -1
.text$mn:00001238
.text$mn:00001238                 push    ebp
.text$mn:00001239                 mov     ebp, esp
.text$mn:0000123B                 sub     esp, 10h
.text$mn:0000123E                 mov     [ebp+var_8], ecx
.text$mn:00001241                 lea     ecx, [ebp+var_1]
.text$mn:00001244                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001249                 push    1
.text$mn:0000124B                 lea     ecx, [ebp+var_1]
.text$mn:0000124E                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00001253                 mov     ecx, [ebp+var_8]
.text$mn:00001256                 mov     [ecx], eax
.text$mn:00001258                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000125B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001260                 push    eax             ; int
.text$mn:00001261                 mov     edx, [ebp+var_8]
.text$mn:00001264                 mov     eax, [edx]
.text$mn:00001266                 push    eax             ; void *
.text$mn:00001267                 lea     ecx, [ebp+var_1]
.text$mn:0000126A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000126F                 mov     ecx, [ebp+var_8]
.text$mn:00001272                 mov     edx, [ecx]
.text$mn:00001274                 mov     eax, [ebp+var_8]
.text$mn:00001277                 mov     [edx], eax
.text$mn:00001279                 mov     esp, ebp
.text$mn:0000127B                 pop     ebp
.text$mn:0000127C                 retn
.text$mn:0000127C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000127C
.text$mn:0000127C ; ---------------------------------------------------------------------------
.text$mn:0000127D                 align 10h
.text$mn:0000127D _text$mn        ends
.text$mn:0000127D
.text$mn:00001280 ; ===========================================================================
.text$mn:00001280
.text$mn:00001280 ; Segment type: Pure code
.text$mn:00001280 ; Segment permissions: Read/Execute
.text$mn:00001280 _text$mn        segment para public 'CODE' use32
.text$mn:00001280                 assume cs:_text$mn
.text$mn:00001280                 ;org 1280h
.text$mn:00001280 ; COMDAT (pick any)
.text$mn:00001280                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001280
.text$mn:00001280 ; =============== S U B R O U T I N E =======================================
.text$mn:00001280
.text$mn:00001280 ; Attributes: bp-based frame
.text$mn:00001280
.text$mn:00001280 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00001280                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001280 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00001280                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00001280
.text$mn:00001280 var_20          = dword ptr -20h
.text$mn:00001280 var_1C          = dword ptr -1Ch
.text$mn:00001280 var_18          = dword ptr -18h
.text$mn:00001280 var_11          = byte ptr -11h
.text$mn:00001280 var_10          = dword ptr -10h
.text$mn:00001280 var_C           = byte ptr -0Ch
.text$mn:00001280 var_4           = dword ptr -4
.text$mn:00001280 arg_0           = dword ptr  8
.text$mn:00001280
.text$mn:00001280 ; FUNCTION CHUNK AT .text$mn:000013A2 SIZE 00000009 BYTES
.text$mn:00001280
.text$mn:00001280                 push    ebp
.text$mn:00001281                 mov     ebp, esp
.text$mn:00001283                 push    0FFFFFFFFh
.text$mn:00001285                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000128A                 mov     eax, large fs:0
.text$mn:00001290                 push    eax
.text$mn:00001291                 push    ecx
.text$mn:00001292                 sub     esp, 10h
.text$mn:00001295                 push    ebx
.text$mn:00001296                 push    esi
.text$mn:00001297                 push    edi
.text$mn:00001298                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000129D                 xor     eax, ebp
.text$mn:0000129F                 push    eax
.text$mn:000012A0                 lea     eax, [ebp+var_C]
.text$mn:000012A3                 mov     large fs:0, eax
.text$mn:000012A9                 mov     [ebp+var_10], esp
.text$mn:000012AC                 mov     [ebp+var_18], ecx
.text$mn:000012AF                 mov     eax, [ebp+arg_0]
.text$mn:000012B2                 or      eax, 0Fh
.text$mn:000012B5                 mov     [ebp+var_1C], eax
.text$mn:000012B8                 mov     ecx, [ebp+var_18]
.text$mn:000012BB                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000012C0                 cmp     eax, [ebp+var_1C]
.text$mn:000012C3                 jnb     short loc_12CD
.text$mn:000012C5                 mov     ecx, [ebp+arg_0]
.text$mn:000012C8                 mov     [ebp+var_1C], ecx
.text$mn:000012CB                 jmp     short loc_131F
.text$mn:000012CD ; ---------------------------------------------------------------------------
.text$mn:000012CD
.text$mn:000012CD loc_12CD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:000012CD                 mov     edx, [ebp+var_18]
.text$mn:000012D0                 mov     ecx, [edx+18h]
.text$mn:000012D3                 shr     ecx, 1
.text$mn:000012D5                 mov     eax, [ebp+var_1C]
.text$mn:000012D8                 xor     edx, edx
.text$mn:000012DA                 mov     esi, 3
.text$mn:000012DF                 div     esi
.text$mn:000012E1                 cmp     ecx, eax
.text$mn:000012E3                 ja      short loc_12E7
.text$mn:000012E5                 jmp     short loc_131F
.text$mn:000012E7 ; ---------------------------------------------------------------------------
.text$mn:000012E7
.text$mn:000012E7 loc_12E7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:000012E7                 mov     ecx, [ebp+var_18]
.text$mn:000012EA                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000012EF                 mov     edx, [ebp+var_18]
.text$mn:000012F2                 mov     ecx, [edx+18h]
.text$mn:000012F5                 shr     ecx, 1
.text$mn:000012F7                 sub     eax, ecx
.text$mn:000012F9                 mov     edx, [ebp+var_18]
.text$mn:000012FC                 cmp     [edx+18h], eax
.text$mn:000012FF                 ja      short loc_1314
.text$mn:00001301                 mov     eax, [ebp+var_18]
.text$mn:00001304                 mov     ecx, [eax+18h]
.text$mn:00001307                 shr     ecx, 1
.text$mn:00001309                 mov     edx, [ebp+var_18]
.text$mn:0000130C                 add     ecx, [edx+18h]
.text$mn:0000130F                 mov     [ebp+var_1C], ecx
.text$mn:00001312                 jmp     short loc_131F
.text$mn:00001314 ; ---------------------------------------------------------------------------
.text$mn:00001314
.text$mn:00001314 loc_1314:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00001314                 mov     ecx, [ebp+var_18]
.text$mn:00001317                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000131C                 mov     [ebp+var_1C], eax
.text$mn:0000131F
.text$mn:0000131F loc_131F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:0000131F                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:0000131F                 mov     [ebp+var_4], 0
.text$mn:00001326                 mov     eax, [ebp+var_1C]
.text$mn:00001329                 add     eax, 1
.text$mn:0000132C                 push    eax
.text$mn:0000132D                 lea     ecx, [ebp+var_11]
.text$mn:00001330                 push    ecx
.text$mn:00001331                 mov     ecx, [ebp+var_18]
.text$mn:00001334                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001339                 mov     ecx, eax
.text$mn:0000133B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001340                 mov     [ebp+var_20], eax
.text$mn:00001343                 jmp     short loc_13A2
.text$mn:00001343 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00001343
.text$mn:00001345
.text$mn:00001345 ; =============== S U B R O U T I N E =======================================
.text$mn:00001345
.text$mn:00001345
.text$mn:00001345 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00001345                                         ; DATA XREF: .xdata$x:00002974o
.text$mn:00001345
.text$mn:00001345 ; FUNCTION CHUNK AT .text$mn:0000138C SIZE 00000009 BYTES
.text$mn:00001345 ; FUNCTION CHUNK AT .text$mn:0000139C SIZE 00000006 BYTES
.text$mn:00001345
.text$mn:00001345                 mov     [ebp-10h], esp
.text$mn:00001348                 mov     edx, [ebp+8]
.text$mn:0000134B                 mov     [ebp-1Ch], edx
.text$mn:0000134E                 mov     byte ptr [ebp-4], 2
.text$mn:00001352                 mov     eax, [ebp-1Ch]
.text$mn:00001355                 add     eax, 1
.text$mn:00001358                 push    eax
.text$mn:00001359                 lea     ecx, [ebp-12h]
.text$mn:0000135C                 push    ecx
.text$mn:0000135D                 mov     ecx, [ebp-18h]
.text$mn:00001360                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001365                 mov     ecx, eax
.text$mn:00001367                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:0000136C                 mov     [ebp-20h], eax
.text$mn:0000136F                 jmp     short loc_138C
.text$mn:0000136F __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:0000136F
.text$mn:00001371
.text$mn:00001371 ; =============== S U B R O U T I N E =======================================
.text$mn:00001371
.text$mn:00001371 ; Attributes: noreturn
.text$mn:00001371
.text$mn:00001371 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00001371                                         ; DATA XREF: .xdata$x:00002984o
.text$mn:00001371                 push    0               ; Size
.text$mn:00001373                 push    1               ; char
.text$mn:00001375                 mov     ecx, [ebp-18h]
.text$mn:00001378                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000137D                 push    0
.text$mn:0000137F                 push    0
.text$mn:00001381                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001381 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00001381
.text$mn:00001386 ; ---------------------------------------------------------------------------
.text$mn:00001386                 mov     eax, offset $LN17
.text$mn:0000138B                 retn
.text$mn:0000138C ; ---------------------------------------------------------------------------
.text$mn:0000138C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000138C
.text$mn:0000138C loc_138C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:0000138C                 mov     dword ptr [ebp-4], 1
.text$mn:00001393                 jmp     short loc_139C
.text$mn:00001393 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001395
.text$mn:00001395 ; =============== S U B R O U T I N E =======================================
.text$mn:00001395
.text$mn:00001395
.text$mn:00001395 $LN17           proc near               ; DATA XREF: .text$mn:00001386o
.text$mn:00001395                 mov     dword ptr [ebp-4], 1
.text$mn:00001395 $LN17           endp ; sp-analysis failed
.text$mn:00001395
.text$mn:0000139C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000139C
.text$mn:0000139C loc_139C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:0000139C                 mov     eax, offset $LN19
.text$mn:000013A1                 retn
.text$mn:000013A1 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000013A2 ; ---------------------------------------------------------------------------
.text$mn:000013A2 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000013A2
.text$mn:000013A2 loc_13A2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:000013A2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000013A9                 jmp     short loc_13B2
.text$mn:000013A9 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000013AB
.text$mn:000013AB ; =============== S U B R O U T I N E =======================================
.text$mn:000013AB
.text$mn:000013AB
.text$mn:000013AB $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_139Co
.text$mn:000013AB                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000013B2
.text$mn:000013B2 loc_13B2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:000013B2                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:000013B6                 jbe     short loc_13D1
.text$mn:000013B8                 mov     edx, [ebp+0Ch]
.text$mn:000013BB                 push    edx             ; Size
.text$mn:000013BC                 mov     ecx, [ebp-18h]
.text$mn:000013BF                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000013C4                 push    eax             ; Src
.text$mn:000013C5                 mov     eax, [ebp-20h]
.text$mn:000013C8                 push    eax             ; Dst
.text$mn:000013C9                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000013CE                 add     esp, 0Ch
.text$mn:000013D1
.text$mn:000013D1 loc_13D1:                               ; CODE XREF: $LN19+Bj
.text$mn:000013D1                 push    0               ; Size
.text$mn:000013D3                 push    1               ; char
.text$mn:000013D5                 mov     ecx, [ebp-18h]
.text$mn:000013D8                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000013DD                 lea     ecx, [ebp-20h]
.text$mn:000013E0                 push    ecx             ; int
.text$mn:000013E1                 mov     edx, [ebp-18h]
.text$mn:000013E4                 add     edx, 4
.text$mn:000013E7                 push    edx             ; void *
.text$mn:000013E8                 lea     eax, [ebp-13h]
.text$mn:000013EB                 push    eax
.text$mn:000013EC                 mov     ecx, [ebp-18h]
.text$mn:000013EF                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000013F4                 mov     ecx, eax
.text$mn:000013F6                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000013FB                 mov     ecx, [ebp-18h]
.text$mn:000013FE                 mov     edx, [ebp-1Ch]
.text$mn:00001401                 mov     [ecx+18h], edx
.text$mn:00001404                 mov     eax, [ebp+0Ch]
.text$mn:00001407                 push    eax
.text$mn:00001408                 mov     ecx, [ebp-18h]
.text$mn:0000140B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001410                 mov     ecx, [ebp-0Ch]
.text$mn:00001413                 mov     large fs:0, ecx
.text$mn:0000141A                 pop     ecx
.text$mn:0000141B                 pop     edi
.text$mn:0000141C                 pop     esi
.text$mn:0000141D                 pop     ebx
.text$mn:0000141E                 mov     esp, ebp
.text$mn:00001420                 pop     ebp
.text$mn:00001421                 retn    8
.text$mn:00001421 $LN19           endp ; sp-analysis failed
.text$mn:00001421
.text$mn:00001421 _text$mn        ends
.text$mn:00001421
.text$x:00001424 ; ===========================================================================
.text$x:00001424
.text$x:00001424 ; Segment type: Pure code
.text$x:00001424 ; Segment permissions: Read/Execute
.text$x:00001424 _text$x         segment para public 'CODE' use32
.text$x:00001424                 assume cs:_text$x
.text$x:00001424                 ;org 1424h
.text$x:00001424 ; COMDAT (pick associative to section at 1280)
.text$x:00001424                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001424
.text$x:00001424 ; =============== S U B R O U T I N E =======================================
.text$x:00001424
.text$x:00001424
.text$x:00001424 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00001424                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00001424
.text$x:00001424 arg_4           = dword ptr  8
.text$x:00001424
.text$x:00001424                 mov     edx, [esp+arg_4]
.text$x:00001428                 lea     eax, [edx+0Ch]
.text$x:0000142B                 mov     ecx, [edx-24h]
.text$x:0000142E                 xor     ecx, eax
.text$x:00001430                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001435                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:0000143A                 jmp     ___CxxFrameHandler3
.text$x:0000143A __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:0000143A
.text$x:0000143A ; ---------------------------------------------------------------------------
.text$x:0000143F                 align 10h
.text$x:0000143F _text$x         ends
.text$x:0000143F
.text$mn:00001440 ; ===========================================================================
.text$mn:00001440
.text$mn:00001440 ; Segment type: Pure code
.text$mn:00001440 ; Segment permissions: Read/Execute
.text$mn:00001440 _text$mn        segment para public 'CODE' use32
.text$mn:00001440                 assume cs:_text$mn
.text$mn:00001440                 ;org 1440h
.text$mn:00001440 ; COMDAT (pick any)
.text$mn:00001440                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001440
.text$mn:00001440 ; =============== S U B R O U T I N E =======================================
.text$mn:00001440
.text$mn:00001440 ; Attributes: bp-based frame
.text$mn:00001440
.text$mn:00001440 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:00001440                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00001440 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:00001440                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:00001440
.text$mn:00001440 var_20          = dword ptr -20h
.text$mn:00001440 var_1C          = dword ptr -1Ch
.text$mn:00001440 var_18          = dword ptr -18h
.text$mn:00001440 var_11          = byte ptr -11h
.text$mn:00001440 var_10          = dword ptr -10h
.text$mn:00001440 var_C           = byte ptr -0Ch
.text$mn:00001440 var_4           = dword ptr -4
.text$mn:00001440 arg_0           = dword ptr  8
.text$mn:00001440
.text$mn:00001440 ; FUNCTION CHUNK AT .text$mn:00001562 SIZE 00000009 BYTES
.text$mn:00001440
.text$mn:00001440                 push    ebp
.text$mn:00001441                 mov     ebp, esp
.text$mn:00001443                 push    0FFFFFFFFh
.text$mn:00001445                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000144A                 mov     eax, large fs:0
.text$mn:00001450                 push    eax
.text$mn:00001451                 push    ecx
.text$mn:00001452                 sub     esp, 10h
.text$mn:00001455                 push    ebx
.text$mn:00001456                 push    esi
.text$mn:00001457                 push    edi
.text$mn:00001458                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000145D                 xor     eax, ebp
.text$mn:0000145F                 push    eax
.text$mn:00001460                 lea     eax, [ebp+var_C]
.text$mn:00001463                 mov     large fs:0, eax
.text$mn:00001469                 mov     [ebp+var_10], esp
.text$mn:0000146C                 mov     [ebp+var_18], ecx
.text$mn:0000146F                 mov     eax, [ebp+arg_0]
.text$mn:00001472                 or      eax, 7
.text$mn:00001475                 mov     [ebp+var_1C], eax
.text$mn:00001478                 mov     ecx, [ebp+var_18]
.text$mn:0000147B                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00001480                 cmp     eax, [ebp+var_1C]
.text$mn:00001483                 jnb     short loc_148D
.text$mn:00001485                 mov     ecx, [ebp+arg_0]
.text$mn:00001488                 mov     [ebp+var_1C], ecx
.text$mn:0000148B                 jmp     short loc_14DF
.text$mn:0000148D ; ---------------------------------------------------------------------------
.text$mn:0000148D
.text$mn:0000148D loc_148D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:0000148D                 mov     edx, [ebp+var_18]
.text$mn:00001490                 mov     ecx, [edx+18h]
.text$mn:00001493                 shr     ecx, 1
.text$mn:00001495                 mov     eax, [ebp+var_1C]
.text$mn:00001498                 xor     edx, edx
.text$mn:0000149A                 mov     esi, 3
.text$mn:0000149F                 div     esi
.text$mn:000014A1                 cmp     ecx, eax
.text$mn:000014A3                 ja      short loc_14A7
.text$mn:000014A5                 jmp     short loc_14DF
.text$mn:000014A7 ; ---------------------------------------------------------------------------
.text$mn:000014A7
.text$mn:000014A7 loc_14A7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:000014A7                 mov     ecx, [ebp+var_18]
.text$mn:000014AA                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000014AF                 mov     edx, [ebp+var_18]
.text$mn:000014B2                 mov     ecx, [edx+18h]
.text$mn:000014B5                 shr     ecx, 1
.text$mn:000014B7                 sub     eax, ecx
.text$mn:000014B9                 mov     edx, [ebp+var_18]
.text$mn:000014BC                 cmp     [edx+18h], eax
.text$mn:000014BF                 ja      short loc_14D4
.text$mn:000014C1                 mov     eax, [ebp+var_18]
.text$mn:000014C4                 mov     ecx, [eax+18h]
.text$mn:000014C7                 shr     ecx, 1
.text$mn:000014C9                 mov     edx, [ebp+var_18]
.text$mn:000014CC                 add     ecx, [edx+18h]
.text$mn:000014CF                 mov     [ebp+var_1C], ecx
.text$mn:000014D2                 jmp     short loc_14DF
.text$mn:000014D4 ; ---------------------------------------------------------------------------
.text$mn:000014D4
.text$mn:000014D4 loc_14D4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:000014D4                 mov     ecx, [ebp+var_18]
.text$mn:000014D7                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000014DC                 mov     [ebp+var_1C], eax
.text$mn:000014DF
.text$mn:000014DF loc_14DF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:000014DF                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:000014DF                 mov     [ebp+var_4], 0
.text$mn:000014E6                 mov     eax, [ebp+var_1C]
.text$mn:000014E9                 add     eax, 1
.text$mn:000014EC                 push    eax
.text$mn:000014ED                 lea     ecx, [ebp+var_11]
.text$mn:000014F0                 push    ecx
.text$mn:000014F1                 mov     ecx, [ebp+var_18]
.text$mn:000014F4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000014F9                 mov     ecx, eax
.text$mn:000014FB                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00001500                 mov     [ebp+var_20], eax
.text$mn:00001503                 jmp     short loc_1562
.text$mn:00001503 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:00001503
.text$mn:00001505
.text$mn:00001505 ; =============== S U B R O U T I N E =======================================
.text$mn:00001505
.text$mn:00001505
.text$mn:00001505 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:00001505                                         ; DATA XREF: .xdata$x:00002C10o
.text$mn:00001505
.text$mn:00001505 ; FUNCTION CHUNK AT .text$mn:0000154C SIZE 00000009 BYTES
.text$mn:00001505 ; FUNCTION CHUNK AT .text$mn:0000155C SIZE 00000006 BYTES
.text$mn:00001505
.text$mn:00001505                 mov     [ebp-10h], esp
.text$mn:00001508                 mov     edx, [ebp+8]
.text$mn:0000150B                 mov     [ebp-1Ch], edx
.text$mn:0000150E                 mov     byte ptr [ebp-4], 2
.text$mn:00001512                 mov     eax, [ebp-1Ch]
.text$mn:00001515                 add     eax, 1
.text$mn:00001518                 push    eax
.text$mn:00001519                 lea     ecx, [ebp-12h]
.text$mn:0000151C                 push    ecx
.text$mn:0000151D                 mov     ecx, [ebp-18h]
.text$mn:00001520                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001525                 mov     ecx, eax
.text$mn:00001527                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:0000152C                 mov     [ebp-20h], eax
.text$mn:0000152F                 jmp     short loc_154C
.text$mn:0000152F __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:0000152F
.text$mn:00001531
.text$mn:00001531 ; =============== S U B R O U T I N E =======================================
.text$mn:00001531
.text$mn:00001531 ; Attributes: noreturn
.text$mn:00001531
.text$mn:00001531 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:00001531                                         ; DATA XREF: .xdata$x:00002C20o
.text$mn:00001531                 push    0
.text$mn:00001533                 push    1
.text$mn:00001535                 mov     ecx, [ebp-18h]
.text$mn:00001538                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000153D                 push    0
.text$mn:0000153F                 push    0
.text$mn:00001541                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001541 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:00001541
.text$mn:00001546 ; ---------------------------------------------------------------------------
.text$mn:00001546                 mov     eax, offset $LN17_0
.text$mn:0000154B                 retn
.text$mn:0000154C ; ---------------------------------------------------------------------------
.text$mn:0000154C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000154C
.text$mn:0000154C loc_154C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:0000154C                 mov     dword ptr [ebp-4], 1
.text$mn:00001553                 jmp     short loc_155C
.text$mn:00001553 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00001555
.text$mn:00001555 ; =============== S U B R O U T I N E =======================================
.text$mn:00001555
.text$mn:00001555
.text$mn:00001555 $LN17_0         proc near               ; DATA XREF: .text$mn:00001546o
.text$mn:00001555                 mov     dword ptr [ebp-4], 1
.text$mn:00001555 $LN17_0         endp ; sp-analysis failed
.text$mn:00001555
.text$mn:0000155C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000155C
.text$mn:0000155C loc_155C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:0000155C                 mov     eax, offset $LN19_0
.text$mn:00001561                 retn
.text$mn:00001561 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00001562 ; ---------------------------------------------------------------------------
.text$mn:00001562 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00001562
.text$mn:00001562 loc_1562:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:00001562                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001569                 jmp     short loc_1572
.text$mn:00001569 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000156B
.text$mn:0000156B ; =============== S U B R O U T I N E =======================================
.text$mn:0000156B
.text$mn:0000156B
.text$mn:0000156B $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_155Co
.text$mn:0000156B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001572
.text$mn:00001572 loc_1572:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:00001572                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00001576                 jbe     short loc_1591
.text$mn:00001578                 mov     edx, [ebp+0Ch]
.text$mn:0000157B                 push    edx             ; int
.text$mn:0000157C                 mov     ecx, [ebp-18h]
.text$mn:0000157F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001584                 push    eax             ; Src
.text$mn:00001585                 mov     eax, [ebp-20h]
.text$mn:00001588                 push    eax             ; Dst
.text$mn:00001589                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000158E                 add     esp, 0Ch
.text$mn:00001591
.text$mn:00001591 loc_1591:                               ; CODE XREF: $LN19_0+Bj
.text$mn:00001591                 push    0
.text$mn:00001593                 push    1
.text$mn:00001595                 mov     ecx, [ebp-18h]
.text$mn:00001598                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000159D                 lea     ecx, [ebp-20h]
.text$mn:000015A0                 push    ecx             ; int
.text$mn:000015A1                 mov     edx, [ebp-18h]
.text$mn:000015A4                 add     edx, 4
.text$mn:000015A7                 push    edx             ; void *
.text$mn:000015A8                 lea     eax, [ebp-13h]
.text$mn:000015AB                 push    eax
.text$mn:000015AC                 mov     ecx, [ebp-18h]
.text$mn:000015AF                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000015B4                 mov     ecx, eax
.text$mn:000015B6                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:000015BB                 mov     ecx, [ebp-18h]
.text$mn:000015BE                 mov     edx, [ebp-1Ch]
.text$mn:000015C1                 mov     [ecx+18h], edx
.text$mn:000015C4                 mov     eax, [ebp+0Ch]
.text$mn:000015C7                 push    eax
.text$mn:000015C8                 mov     ecx, [ebp-18h]
.text$mn:000015CB                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000015D0                 mov     ecx, [ebp-0Ch]
.text$mn:000015D3                 mov     large fs:0, ecx
.text$mn:000015DA                 pop     ecx
.text$mn:000015DB                 pop     edi
.text$mn:000015DC                 pop     esi
.text$mn:000015DD                 pop     ebx
.text$mn:000015DE                 mov     esp, ebp
.text$mn:000015E0                 pop     ebp
.text$mn:000015E1                 retn    8
.text$mn:000015E1 $LN19_0         endp ; sp-analysis failed
.text$mn:000015E1
.text$mn:000015E1 _text$mn        ends
.text$mn:000015E1
.text$x:000015E4 ; ===========================================================================
.text$x:000015E4
.text$x:000015E4 ; Segment type: Pure code
.text$x:000015E4 ; Segment permissions: Read/Execute
.text$x:000015E4 _text$x         segment para public 'CODE' use32
.text$x:000015E4                 assume cs:_text$x
.text$x:000015E4                 ;org 15E4h
.text$x:000015E4 ; COMDAT (pick associative to section at 1440)
.text$x:000015E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000015E4
.text$x:000015E4 ; =============== S U B R O U T I N E =======================================
.text$x:000015E4
.text$x:000015E4
.text$x:000015E4 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:000015E4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:000015E4
.text$x:000015E4 arg_4           = dword ptr  8
.text$x:000015E4
.text$x:000015E4                 mov     edx, [esp+arg_4]
.text$x:000015E8                 lea     eax, [edx+0Ch]
.text$x:000015EB                 mov     ecx, [edx-24h]
.text$x:000015EE                 xor     ecx, eax
.text$x:000015F0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000015F5                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:000015FA                 jmp     ___CxxFrameHandler3
.text$x:000015FA __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:000015FA
.text$x:000015FA ; ---------------------------------------------------------------------------
.text$x:000015FF                 align 10h
.text$x:000015FF _text$x         ends
.text$x:000015FF
.text$mn:00001600 ; ===========================================================================
.text$mn:00001600
.text$mn:00001600 ; Segment type: Pure code
.text$mn:00001600 ; Segment permissions: Read/Execute
.text$mn:00001600 _text$mn        segment para public 'CODE' use32
.text$mn:00001600                 assume cs:_text$mn
.text$mn:00001600                 ;org 1600h
.text$mn:00001600 ; COMDAT (pick any)
.text$mn:00001600                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001600
.text$mn:00001600 ; =============== S U B R O U T I N E =======================================
.text$mn:00001600
.text$mn:00001600 ; Attributes: bp-based frame
.text$mn:00001600
.text$mn:00001600 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00001600                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00001600 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00001600                                         ; CODE XREF: $LN19+60p
.text$mn:00001600                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00001600
.text$mn:00001600 var_8           = dword ptr -8
.text$mn:00001600 var_1           = byte ptr -1
.text$mn:00001600 arg_0           = dword ptr  8
.text$mn:00001600
.text$mn:00001600                 push    ebp
.text$mn:00001601                 mov     ebp, esp
.text$mn:00001603                 sub     esp, 8
.text$mn:00001606                 mov     [ebp+var_8], ecx
.text$mn:00001609                 mov     [ebp+var_1], 0
.text$mn:0000160D                 mov     eax, [ebp+var_8]
.text$mn:00001610                 mov     ecx, [ebp+arg_0]
.text$mn:00001613                 mov     [eax+14h], ecx
.text$mn:00001616                 lea     edx, [ebp+var_1]
.text$mn:00001619                 push    edx
.text$mn:0000161A                 mov     ecx, [ebp+var_8]
.text$mn:0000161D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001622                 add     eax, [ebp+arg_0]
.text$mn:00001625                 push    eax
.text$mn:00001626                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:0000162B                 add     esp, 8
.text$mn:0000162E                 mov     esp, ebp
.text$mn:00001630                 pop     ebp
.text$mn:00001631                 retn    4
.text$mn:00001631 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00001631
.text$mn:00001631 _text$mn        ends
.text$mn:00001631
.text$mn:00001634 ; ===========================================================================
.text$mn:00001634
.text$mn:00001634 ; Segment type: Pure code
.text$mn:00001634 ; Segment permissions: Read/Execute
.text$mn:00001634 _text$mn        segment para public 'CODE' use32
.text$mn:00001634                 assume cs:_text$mn
.text$mn:00001634                 ;org 1634h
.text$mn:00001634 ; COMDAT (pick any)
.text$mn:00001634                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001634
.text$mn:00001634 ; =============== S U B R O U T I N E =======================================
.text$mn:00001634
.text$mn:00001634 ; Attributes: bp-based frame
.text$mn:00001634
.text$mn:00001634 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:00001634                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:00001634 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:00001634                                         ; CODE XREF: $LN19_0+60p
.text$mn:00001634                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:00001634
.text$mn:00001634 var_8           = dword ptr -8
.text$mn:00001634 var_2           = word ptr -2
.text$mn:00001634 arg_0           = dword ptr  8
.text$mn:00001634
.text$mn:00001634                 push    ebp
.text$mn:00001635                 mov     ebp, esp
.text$mn:00001637                 sub     esp, 8
.text$mn:0000163A                 mov     [ebp+var_8], ecx
.text$mn:0000163D                 xor     eax, eax
.text$mn:0000163F                 mov     [ebp+var_2], ax
.text$mn:00001643                 mov     ecx, [ebp+var_8]
.text$mn:00001646                 mov     edx, [ebp+arg_0]
.text$mn:00001649                 mov     [ecx+14h], edx
.text$mn:0000164C                 lea     eax, [ebp+var_2]
.text$mn:0000164F                 push    eax
.text$mn:00001650                 mov     ecx, [ebp+var_8]
.text$mn:00001653                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001658                 mov     ecx, [ebp+arg_0]
.text$mn:0000165B                 lea     edx, [eax+ecx*2]
.text$mn:0000165E                 push    edx
.text$mn:0000165F                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:00001664                 add     esp, 8
.text$mn:00001667                 mov     esp, ebp
.text$mn:00001669                 pop     ebp
.text$mn:0000166A                 retn    4
.text$mn:0000166A ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:0000166A
.text$mn:0000166A ; ---------------------------------------------------------------------------
.text$mn:0000166D                 align 10h
.text$mn:0000166D _text$mn        ends
.text$mn:0000166D
.text$mn:00001670 ; ===========================================================================
.text$mn:00001670
.text$mn:00001670 ; Segment type: Pure code
.text$mn:00001670 ; Segment permissions: Read/Execute
.text$mn:00001670 _text$mn        segment para public 'CODE' use32
.text$mn:00001670                 assume cs:_text$mn
.text$mn:00001670                 ;org 1670h
.text$mn:00001670 ; COMDAT (pick any)
.text$mn:00001670                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001670
.text$mn:00001670 ; =============== S U B R O U T I N E =======================================
.text$mn:00001670
.text$mn:00001670 ; Attributes: bp-based frame
.text$mn:00001670
.text$mn:00001670 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001670                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001670 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001670                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00001670
.text$mn:00001670 var_8           = dword ptr -8
.text$mn:00001670 var_1           = byte ptr -1
.text$mn:00001670
.text$mn:00001670                 push    ebp
.text$mn:00001671                 mov     ebp, esp
.text$mn:00001673                 sub     esp, 8
.text$mn:00001676                 mov     [ebp+var_8], ecx
.text$mn:00001679                 lea     ecx, [ebp+var_1]
.text$mn:0000167C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001681                 mov     ecx, [ebp+var_8] ; this
.text$mn:00001684                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001689                 mov     eax, [ebp+var_8]
.text$mn:0000168C                 mov     ecx, [eax]
.text$mn:0000168E                 push    ecx
.text$mn:0000168F                 lea     ecx, [ebp+var_1]
.text$mn:00001692                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00001697                 push    1               ; int
.text$mn:00001699                 mov     edx, [ebp+var_8]
.text$mn:0000169C                 mov     eax, [edx]
.text$mn:0000169E                 push    eax             ; void *
.text$mn:0000169F                 lea     ecx, [ebp+var_1]
.text$mn:000016A2                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000016A7                 mov     ecx, [ebp+var_8]
.text$mn:000016AA                 mov     dword ptr [ecx], 0
.text$mn:000016B0                 mov     esp, ebp
.text$mn:000016B2                 pop     ebp
.text$mn:000016B3                 retn
.text$mn:000016B3 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000016B3
.text$mn:000016B3 _text$mn        ends
.text$mn:000016B3
.text$mn:000016B4 ; ===========================================================================
.text$mn:000016B4
.text$mn:000016B4 ; Segment type: Pure code
.text$mn:000016B4 ; Segment permissions: Read/Execute
.text$mn:000016B4 _text$mn        segment para public 'CODE' use32
.text$mn:000016B4                 assume cs:_text$mn
.text$mn:000016B4                 ;org 16B4h
.text$mn:000016B4 ; COMDAT (pick any)
.text$mn:000016B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016B4
.text$mn:000016B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000016B4
.text$mn:000016B4 ; Attributes: bp-based frame
.text$mn:000016B4
.text$mn:000016B4 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:000016B4                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:000016B4 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:000016B4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:000016B4                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:000016B4
.text$mn:000016B4 var_4           = dword ptr -4
.text$mn:000016B4 arg_0           = dword ptr  8
.text$mn:000016B4
.text$mn:000016B4                 push    ebp
.text$mn:000016B5                 mov     ebp, esp
.text$mn:000016B7                 push    ecx
.text$mn:000016B8                 mov     [ebp+var_4], ecx
.text$mn:000016BB                 mov     ecx, [ebp+arg_0]
.text$mn:000016BE                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:000016C3                 mov     eax, [ebp+arg_0]
.text$mn:000016C6                 mov     esp, ebp
.text$mn:000016C8                 pop     ebp
.text$mn:000016C9                 retn    4
.text$mn:000016C9 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:000016C9
.text$mn:000016C9 _text$mn        ends
.text$mn:000016C9
.text$mn:000016CC ; ===========================================================================
.text$mn:000016CC
.text$mn:000016CC ; Segment type: Pure code
.text$mn:000016CC ; Segment permissions: Read/Execute
.text$mn:000016CC _text$mn        segment para public 'CODE' use32
.text$mn:000016CC                 assume cs:_text$mn
.text$mn:000016CC                 ;org 16CCh
.text$mn:000016CC ; COMDAT (pick any)
.text$mn:000016CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016CC
.text$mn:000016CC ; =============== S U B R O U T I N E =======================================
.text$mn:000016CC
.text$mn:000016CC ; Attributes: bp-based frame
.text$mn:000016CC
.text$mn:000016CC ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:000016CC                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:000016CC ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:000016CC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+B4p
.text$mn:000016CC                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:000016CC
.text$mn:000016CC var_4           = dword ptr -4
.text$mn:000016CC arg_0           = dword ptr  8
.text$mn:000016CC
.text$mn:000016CC                 push    ebp
.text$mn:000016CD                 mov     ebp, esp
.text$mn:000016CF                 push    ecx
.text$mn:000016D0                 mov     [ebp+var_4], ecx
.text$mn:000016D3                 mov     ecx, [ebp+arg_0]
.text$mn:000016D6                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:000016DB                 mov     eax, [ebp+arg_0]
.text$mn:000016DE                 mov     esp, ebp
.text$mn:000016E0                 pop     ebp
.text$mn:000016E1                 retn    4
.text$mn:000016E1 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:000016E1
.text$mn:000016E1 _text$mn        ends
.text$mn:000016E1
.text$mn:000016E4 ; ===========================================================================
.text$mn:000016E4
.text$mn:000016E4 ; Segment type: Pure code
.text$mn:000016E4 ; Segment permissions: Read/Execute
.text$mn:000016E4 _text$mn        segment para public 'CODE' use32
.text$mn:000016E4                 assume cs:_text$mn
.text$mn:000016E4                 ;org 16E4h
.text$mn:000016E4 ; COMDAT (pick any)
.text$mn:000016E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016E4
.text$mn:000016E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000016E4
.text$mn:000016E4 ; Attributes: bp-based frame
.text$mn:000016E4
.text$mn:000016E4 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:000016E4                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:000016E4 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:000016E4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:000016E4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:000016E4
.text$mn:000016E4 var_C           = dword ptr -0Ch
.text$mn:000016E4 Size            = dword ptr -8
.text$mn:000016E4 var_4           = dword ptr -4
.text$mn:000016E4 arg_0           = dword ptr  8
.text$mn:000016E4 arg_4           = byte ptr  0Ch
.text$mn:000016E4
.text$mn:000016E4                 push    ebp
.text$mn:000016E5                 mov     ebp, esp
.text$mn:000016E7                 sub     esp, 0Ch
.text$mn:000016EA                 mov     [ebp+var_4], ecx
.text$mn:000016ED                 mov     ecx, [ebp+var_4]
.text$mn:000016F0                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000016F5                 cmp     eax, [ebp+arg_0]
.text$mn:000016F8                 jnb     short loc_1702
.text$mn:000016FA                 mov     ecx, [ebp+var_4]
.text$mn:000016FD                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00001702
.text$mn:00001702 loc_1702:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00001702                 mov     eax, [ebp+var_4]
.text$mn:00001705                 mov     ecx, [eax+18h]
.text$mn:00001708                 cmp     ecx, [ebp+arg_0]
.text$mn:0000170B                 jnb     short loc_1722
.text$mn:0000170D                 mov     edx, [ebp+var_4]
.text$mn:00001710                 mov     eax, [edx+14h]
.text$mn:00001713                 push    eax
.text$mn:00001714                 mov     ecx, [ebp+arg_0]
.text$mn:00001717                 push    ecx
.text$mn:00001718                 mov     ecx, [ebp+var_4]
.text$mn:0000171B                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00001720                 jmp     short loc_176C
.text$mn:00001722 ; ---------------------------------------------------------------------------
.text$mn:00001722
.text$mn:00001722 loc_1722:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00001722                 movzx   edx, [ebp+arg_4]
.text$mn:00001726                 test    edx, edx
.text$mn:00001728                 jz      short loc_175C
.text$mn:0000172A                 cmp     [ebp+arg_0], 10h
.text$mn:0000172E                 jnb     short loc_175C
.text$mn:00001730                 mov     eax, [ebp+var_4]
.text$mn:00001733                 mov     ecx, [ebp+arg_0]
.text$mn:00001736                 cmp     ecx, [eax+14h]
.text$mn:00001739                 jnb     short loc_1743
.text$mn:0000173B                 mov     edx, [ebp+arg_0]
.text$mn:0000173E                 mov     [ebp+Size], edx
.text$mn:00001741                 jmp     short loc_174C
.text$mn:00001743 ; ---------------------------------------------------------------------------
.text$mn:00001743
.text$mn:00001743 loc_1743:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00001743                 mov     eax, [ebp+var_4]
.text$mn:00001746                 mov     ecx, [eax+14h]
.text$mn:00001749                 mov     [ebp+Size], ecx
.text$mn:0000174C
.text$mn:0000174C loc_174C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:0000174C                 mov     edx, [ebp+Size]
.text$mn:0000174F                 push    edx             ; Size
.text$mn:00001750                 push    1               ; char
.text$mn:00001752                 mov     ecx, [ebp+var_4]
.text$mn:00001755                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000175A                 jmp     short loc_176C
.text$mn:0000175C ; ---------------------------------------------------------------------------
.text$mn:0000175C
.text$mn:0000175C loc_175C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:0000175C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:0000175C                 cmp     [ebp+arg_0], 0
.text$mn:00001760                 jnz     short loc_176C
.text$mn:00001762                 push    0
.text$mn:00001764                 mov     ecx, [ebp+var_4]
.text$mn:00001767                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000176C
.text$mn:0000176C loc_176C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:0000176C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:0000176C                 cmp     [ebp+arg_0], 0
.text$mn:00001770                 jbe     short loc_177B
.text$mn:00001772                 mov     [ebp+var_C], 1
.text$mn:00001779                 jmp     short loc_1782
.text$mn:0000177B ; ---------------------------------------------------------------------------
.text$mn:0000177B
.text$mn:0000177B loc_177B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000177B                 mov     [ebp+var_C], 0
.text$mn:00001782
.text$mn:00001782 loc_1782:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00001782                 mov     al, byte ptr [ebp+var_C]
.text$mn:00001785                 mov     esp, ebp
.text$mn:00001787                 pop     ebp
.text$mn:00001788                 retn    8
.text$mn:00001788 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00001788
.text$mn:00001788 ; ---------------------------------------------------------------------------
.text$mn:0000178B                 align 4
.text$mn:0000178B _text$mn        ends
.text$mn:0000178B
.text$mn:0000178C ; ===========================================================================
.text$mn:0000178C
.text$mn:0000178C ; Segment type: Pure code
.text$mn:0000178C ; Segment permissions: Read/Execute
.text$mn:0000178C _text$mn        segment para public 'CODE' use32
.text$mn:0000178C                 assume cs:_text$mn
.text$mn:0000178C                 ;org 178Ch
.text$mn:0000178C ; COMDAT (pick any)
.text$mn:0000178C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000178C
.text$mn:0000178C ; =============== S U B R O U T I N E =======================================
.text$mn:0000178C
.text$mn:0000178C ; Attributes: bp-based frame
.text$mn:0000178C
.text$mn:0000178C ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:0000178C                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:0000178C ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:0000178C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Ap
.text$mn:0000178C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+61p
.text$mn:0000178C
.text$mn:0000178C var_C           = dword ptr -0Ch
.text$mn:0000178C var_8           = dword ptr -8
.text$mn:0000178C var_4           = dword ptr -4
.text$mn:0000178C arg_0           = dword ptr  8
.text$mn:0000178C arg_4           = byte ptr  0Ch
.text$mn:0000178C
.text$mn:0000178C                 push    ebp
.text$mn:0000178D                 mov     ebp, esp
.text$mn:0000178F                 sub     esp, 0Ch
.text$mn:00001792                 mov     [ebp+var_4], ecx
.text$mn:00001795                 mov     ecx, [ebp+var_4]
.text$mn:00001798                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:0000179D                 cmp     eax, [ebp+arg_0]
.text$mn:000017A0                 jnb     short loc_17AA
.text$mn:000017A2                 mov     ecx, [ebp+var_4]
.text$mn:000017A5                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:000017AA
.text$mn:000017AA loc_17AA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:000017AA                 mov     eax, [ebp+var_4]
.text$mn:000017AD                 mov     ecx, [eax+18h]
.text$mn:000017B0                 cmp     ecx, [ebp+arg_0]
.text$mn:000017B3                 jnb     short loc_17CA
.text$mn:000017B5                 mov     edx, [ebp+var_4]
.text$mn:000017B8                 mov     eax, [edx+14h]
.text$mn:000017BB                 push    eax
.text$mn:000017BC                 mov     ecx, [ebp+arg_0]
.text$mn:000017BF                 push    ecx
.text$mn:000017C0                 mov     ecx, [ebp+var_4]
.text$mn:000017C3                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:000017C8                 jmp     short loc_1814
.text$mn:000017CA ; ---------------------------------------------------------------------------
.text$mn:000017CA
.text$mn:000017CA loc_17CA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:000017CA                 movzx   edx, [ebp+arg_4]
.text$mn:000017CE                 test    edx, edx
.text$mn:000017D0                 jz      short loc_1804
.text$mn:000017D2                 cmp     [ebp+arg_0], 8
.text$mn:000017D6                 jnb     short loc_1804
.text$mn:000017D8                 mov     eax, [ebp+var_4]
.text$mn:000017DB                 mov     ecx, [ebp+arg_0]
.text$mn:000017DE                 cmp     ecx, [eax+14h]
.text$mn:000017E1                 jnb     short loc_17EB
.text$mn:000017E3                 mov     edx, [ebp+arg_0]
.text$mn:000017E6                 mov     [ebp+var_8], edx
.text$mn:000017E9                 jmp     short loc_17F4
.text$mn:000017EB ; ---------------------------------------------------------------------------
.text$mn:000017EB
.text$mn:000017EB loc_17EB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:000017EB                 mov     eax, [ebp+var_4]
.text$mn:000017EE                 mov     ecx, [eax+14h]
.text$mn:000017F1                 mov     [ebp+var_8], ecx
.text$mn:000017F4
.text$mn:000017F4 loc_17F4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:000017F4                 mov     edx, [ebp+var_8]
.text$mn:000017F7                 push    edx
.text$mn:000017F8                 push    1
.text$mn:000017FA                 mov     ecx, [ebp+var_4]
.text$mn:000017FD                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00001802                 jmp     short loc_1814
.text$mn:00001804 ; ---------------------------------------------------------------------------
.text$mn:00001804
.text$mn:00001804 loc_1804:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:00001804                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:00001804                 cmp     [ebp+arg_0], 0
.text$mn:00001808                 jnz     short loc_1814
.text$mn:0000180A                 push    0
.text$mn:0000180C                 mov     ecx, [ebp+var_4]
.text$mn:0000180F                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00001814
.text$mn:00001814 loc_1814:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:00001814                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:00001814                 cmp     [ebp+arg_0], 0
.text$mn:00001818                 jbe     short loc_1823
.text$mn:0000181A                 mov     [ebp+var_C], 1
.text$mn:00001821                 jmp     short loc_182A
.text$mn:00001823 ; ---------------------------------------------------------------------------
.text$mn:00001823
.text$mn:00001823 loc_1823:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:00001823                 mov     [ebp+var_C], 0
.text$mn:0000182A
.text$mn:0000182A loc_182A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:0000182A                 mov     al, byte ptr [ebp+var_C]
.text$mn:0000182D                 mov     esp, ebp
.text$mn:0000182F                 pop     ebp
.text$mn:00001830                 retn    8
.text$mn:00001830 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:00001830
.text$mn:00001830 ; ---------------------------------------------------------------------------
.text$mn:00001833                 align 4
.text$mn:00001833 _text$mn        ends
.text$mn:00001833
.text$mn:00001834 ; ===========================================================================
.text$mn:00001834
.text$mn:00001834 ; Segment type: Pure code
.text$mn:00001834 ; Segment permissions: Read/Execute
.text$mn:00001834 _text$mn        segment para public 'CODE' use32
.text$mn:00001834                 assume cs:_text$mn
.text$mn:00001834                 ;org 1834h
.text$mn:00001834 ; COMDAT (pick any)
.text$mn:00001834                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001834
.text$mn:00001834 ; =============== S U B R O U T I N E =======================================
.text$mn:00001834
.text$mn:00001834 ; Attributes: bp-based frame
.text$mn:00001834
.text$mn:00001834 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00001834                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00001834 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00001834                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00001834
.text$mn:00001834 var_4           = dword ptr -4
.text$mn:00001834 arg_0           = dword ptr  8
.text$mn:00001834
.text$mn:00001834                 push    ebp
.text$mn:00001835                 mov     ebp, esp
.text$mn:00001837                 push    ecx
.text$mn:00001838                 mov     [ebp+var_4], ecx
.text$mn:0000183B                 cmp     [ebp+arg_0], 0
.text$mn:0000183F                 jz      short loc_1861
.text$mn:00001841                 mov     ecx, [ebp+var_4]
.text$mn:00001844                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001849                 cmp     [ebp+arg_0], eax
.text$mn:0000184C                 jb      short loc_1861
.text$mn:0000184E                 mov     ecx, [ebp+var_4]
.text$mn:00001851                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001856                 mov     ecx, [ebp+var_4]
.text$mn:00001859                 add     eax, [ecx+14h]
.text$mn:0000185C                 cmp     eax, [ebp+arg_0]
.text$mn:0000185F                 ja      short loc_1867
.text$mn:00001861
.text$mn:00001861 loc_1861:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00001861                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00001861                 xor     al, al
.text$mn:00001863                 jmp     short loc_1869
.text$mn:00001865 ; ---------------------------------------------------------------------------
.text$mn:00001865                 jmp     short loc_1869
.text$mn:00001867 ; ---------------------------------------------------------------------------
.text$mn:00001867
.text$mn:00001867 loc_1867:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00001867                 mov     al, 1
.text$mn:00001869
.text$mn:00001869 loc_1869:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00001869                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00001869                 mov     esp, ebp
.text$mn:0000186B                 pop     ebp
.text$mn:0000186C                 retn    4
.text$mn:0000186C ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:0000186C
.text$mn:0000186C ; ---------------------------------------------------------------------------
.text$mn:0000186F                 align 10h
.text$mn:0000186F _text$mn        ends
.text$mn:0000186F
.text$mn:00001870 ; ===========================================================================
.text$mn:00001870
.text$mn:00001870 ; Segment type: Pure code
.text$mn:00001870 ; Segment permissions: Read/Execute
.text$mn:00001870 _text$mn        segment para public 'CODE' use32
.text$mn:00001870                 assume cs:_text$mn
.text$mn:00001870                 ;org 1870h
.text$mn:00001870 ; COMDAT (pick any)
.text$mn:00001870                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001870
.text$mn:00001870 ; =============== S U B R O U T I N E =======================================
.text$mn:00001870
.text$mn:00001870 ; Attributes: bp-based frame
.text$mn:00001870
.text$mn:00001870 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00001870                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:00001870 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:00001870                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap
.text$mn:00001870
.text$mn:00001870 var_4           = dword ptr -4
.text$mn:00001870 arg_0           = dword ptr  8
.text$mn:00001870
.text$mn:00001870                 push    ebp
.text$mn:00001871                 mov     ebp, esp
.text$mn:00001873                 push    ecx
.text$mn:00001874                 mov     [ebp+var_4], ecx
.text$mn:00001877                 cmp     [ebp+arg_0], 0
.text$mn:0000187B                 jz      short loc_18A0
.text$mn:0000187D                 mov     ecx, [ebp+var_4]
.text$mn:00001880                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001885                 cmp     [ebp+arg_0], eax
.text$mn:00001888                 jb      short loc_18A0
.text$mn:0000188A                 mov     ecx, [ebp+var_4]
.text$mn:0000188D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001892                 mov     ecx, [ebp+var_4]
.text$mn:00001895                 mov     edx, [ecx+14h]
.text$mn:00001898                 lea     eax, [eax+edx*2]
.text$mn:0000189B                 cmp     eax, [ebp+arg_0]
.text$mn:0000189E                 ja      short loc_18A6
.text$mn:000018A0
.text$mn:000018A0 loc_18A0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:000018A0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:000018A0                 xor     al, al
.text$mn:000018A2                 jmp     short loc_18A8
.text$mn:000018A4 ; ---------------------------------------------------------------------------
.text$mn:000018A4                 jmp     short loc_18A8
.text$mn:000018A6 ; ---------------------------------------------------------------------------
.text$mn:000018A6
.text$mn:000018A6 loc_18A6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:000018A6                 mov     al, 1
.text$mn:000018A8
.text$mn:000018A8 loc_18A8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:000018A8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:000018A8                 mov     esp, ebp
.text$mn:000018AA                 pop     ebp
.text$mn:000018AB                 retn    4
.text$mn:000018AB ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:000018AB
.text$mn:000018AB ; ---------------------------------------------------------------------------
.text$mn:000018AE                 align 10h
.text$mn:000018AE _text$mn        ends
.text$mn:000018AE
.text$mn:000018B0 ; ===========================================================================
.text$mn:000018B0
.text$mn:000018B0 ; Segment type: Pure code
.text$mn:000018B0 ; Segment permissions: Read/Execute
.text$mn:000018B0 _text$mn        segment para public 'CODE' use32
.text$mn:000018B0                 assume cs:_text$mn
.text$mn:000018B0                 ;org 18B0h
.text$mn:000018B0 ; COMDAT (pick any)
.text$mn:000018B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018B0
.text$mn:000018B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000018B0
.text$mn:000018B0 ; Attributes: bp-based frame
.text$mn:000018B0
.text$mn:000018B0 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:000018B0                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:000018B0 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:000018B0                                         ; CODE XREF: $LN19+14p
.text$mn:000018B0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:000018B0
.text$mn:000018B0 var_8           = dword ptr -8
.text$mn:000018B0 var_4           = dword ptr -4
.text$mn:000018B0
.text$mn:000018B0                 push    ebp
.text$mn:000018B1                 mov     ebp, esp
.text$mn:000018B3                 sub     esp, 8
.text$mn:000018B6                 mov     [ebp+var_4], ecx
.text$mn:000018B9                 mov     eax, [ebp+var_4]
.text$mn:000018BC                 cmp     dword ptr [eax+18h], 10h
.text$mn:000018C0                 jb      short loc_18D6
.text$mn:000018C2                 mov     ecx, [ebp+var_4]
.text$mn:000018C5                 mov     edx, [ecx+4]
.text$mn:000018C8                 push    edx
.text$mn:000018C9                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000018CE                 add     esp, 4
.text$mn:000018D1                 mov     [ebp+var_8], eax
.text$mn:000018D4                 jmp     short loc_18DF
.text$mn:000018D6 ; ---------------------------------------------------------------------------
.text$mn:000018D6
.text$mn:000018D6 loc_18D6:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000018D6                 mov     eax, [ebp+var_4]
.text$mn:000018D9                 add     eax, 4
.text$mn:000018DC                 mov     [ebp+var_8], eax
.text$mn:000018DF
.text$mn:000018DF loc_18DF:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000018DF                 mov     eax, [ebp+var_8]
.text$mn:000018E2                 mov     esp, ebp
.text$mn:000018E4                 pop     ebp
.text$mn:000018E5                 retn
.text$mn:000018E5 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:000018E5
.text$mn:000018E5 ; ---------------------------------------------------------------------------
.text$mn:000018E6                 align 4
.text$mn:000018E6 _text$mn        ends
.text$mn:000018E6
.text$mn:000018E8 ; ===========================================================================
.text$mn:000018E8
.text$mn:000018E8 ; Segment type: Pure code
.text$mn:000018E8 ; Segment permissions: Read/Execute
.text$mn:000018E8 _text$mn        segment para public 'CODE' use32
.text$mn:000018E8                 assume cs:_text$mn
.text$mn:000018E8                 ;org 18E8h
.text$mn:000018E8 ; COMDAT (pick any)
.text$mn:000018E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018E8
.text$mn:000018E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000018E8
.text$mn:000018E8 ; Attributes: bp-based frame
.text$mn:000018E8
.text$mn:000018E8 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:000018E8                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:000018E8 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:000018E8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:000018E8
.text$mn:000018E8 var_8           = dword ptr -8
.text$mn:000018E8 var_4           = dword ptr -4
.text$mn:000018E8
.text$mn:000018E8                 push    ebp
.text$mn:000018E9                 mov     ebp, esp
.text$mn:000018EB                 sub     esp, 8
.text$mn:000018EE                 mov     [ebp+var_4], ecx
.text$mn:000018F1                 mov     eax, [ebp+var_4]
.text$mn:000018F4                 cmp     dword ptr [eax+18h], 10h
.text$mn:000018F8                 jb      short loc_190E
.text$mn:000018FA                 mov     ecx, [ebp+var_4]
.text$mn:000018FD                 mov     edx, [ecx+4]
.text$mn:00001900                 push    edx
.text$mn:00001901                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001906                 add     esp, 4
.text$mn:00001909                 mov     [ebp+var_8], eax
.text$mn:0000190C                 jmp     short loc_1917
.text$mn:0000190E ; ---------------------------------------------------------------------------
.text$mn:0000190E
.text$mn:0000190E loc_190E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000190E                 mov     eax, [ebp+var_4]
.text$mn:00001911                 add     eax, 4
.text$mn:00001914                 mov     [ebp+var_8], eax
.text$mn:00001917
.text$mn:00001917 loc_1917:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00001917                 mov     eax, [ebp+var_8]
.text$mn:0000191A                 mov     esp, ebp
.text$mn:0000191C                 pop     ebp
.text$mn:0000191D                 retn
.text$mn:0000191D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:0000191D
.text$mn:0000191D ; ---------------------------------------------------------------------------
.text$mn:0000191E                 align 10h
.text$mn:0000191E _text$mn        ends
.text$mn:0000191E
.text$mn:00001920 ; ===========================================================================
.text$mn:00001920
.text$mn:00001920 ; Segment type: Pure code
.text$mn:00001920 ; Segment permissions: Read/Execute
.text$mn:00001920 _text$mn        segment para public 'CODE' use32
.text$mn:00001920                 assume cs:_text$mn
.text$mn:00001920                 ;org 1920h
.text$mn:00001920 ; COMDAT (pick any)
.text$mn:00001920                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001920
.text$mn:00001920 ; =============== S U B R O U T I N E =======================================
.text$mn:00001920
.text$mn:00001920 ; Attributes: bp-based frame
.text$mn:00001920
.text$mn:00001920 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001920                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:00001920 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:00001920                                         ; CODE XREF: $LN19_0+14p
.text$mn:00001920                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp ...
.text$mn:00001920
.text$mn:00001920 var_8           = dword ptr -8
.text$mn:00001920 var_4           = dword ptr -4
.text$mn:00001920
.text$mn:00001920                 push    ebp
.text$mn:00001921                 mov     ebp, esp
.text$mn:00001923                 sub     esp, 8
.text$mn:00001926                 mov     [ebp+var_4], ecx
.text$mn:00001929                 mov     eax, [ebp+var_4]
.text$mn:0000192C                 cmp     dword ptr [eax+18h], 8
.text$mn:00001930                 jb      short loc_1946
.text$mn:00001932                 mov     ecx, [ebp+var_4]
.text$mn:00001935                 mov     edx, [ecx+4]
.text$mn:00001938                 push    edx
.text$mn:00001939                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000193E                 add     esp, 4
.text$mn:00001941                 mov     [ebp+var_8], eax
.text$mn:00001944                 jmp     short loc_194F
.text$mn:00001946 ; ---------------------------------------------------------------------------
.text$mn:00001946
.text$mn:00001946 loc_1946:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00001946                 mov     eax, [ebp+var_4]
.text$mn:00001949                 add     eax, 4
.text$mn:0000194C                 mov     [ebp+var_8], eax
.text$mn:0000194F
.text$mn:0000194F loc_194F:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:0000194F                 mov     eax, [ebp+var_8]
.text$mn:00001952                 mov     esp, ebp
.text$mn:00001954                 pop     ebp
.text$mn:00001955                 retn
.text$mn:00001955 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:00001955
.text$mn:00001955 ; ---------------------------------------------------------------------------
.text$mn:00001956                 align 4
.text$mn:00001956 _text$mn        ends
.text$mn:00001956
.text$mn:00001958 ; ===========================================================================
.text$mn:00001958
.text$mn:00001958 ; Segment type: Pure code
.text$mn:00001958 ; Segment permissions: Read/Execute
.text$mn:00001958 _text$mn        segment para public 'CODE' use32
.text$mn:00001958                 assume cs:_text$mn
.text$mn:00001958                 ;org 1958h
.text$mn:00001958 ; COMDAT (pick any)
.text$mn:00001958                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001958
.text$mn:00001958 ; =============== S U B R O U T I N E =======================================
.text$mn:00001958
.text$mn:00001958 ; Attributes: bp-based frame
.text$mn:00001958
.text$mn:00001958 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:00001958                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:00001958 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:00001958                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp
.text$mn:00001958                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)+Ap
.text$mn:00001958
.text$mn:00001958 var_8           = dword ptr -8
.text$mn:00001958 var_4           = dword ptr -4
.text$mn:00001958
.text$mn:00001958                 push    ebp
.text$mn:00001959                 mov     ebp, esp
.text$mn:0000195B                 sub     esp, 8
.text$mn:0000195E                 mov     [ebp+var_4], ecx
.text$mn:00001961                 mov     eax, [ebp+var_4]
.text$mn:00001964                 cmp     dword ptr [eax+18h], 8
.text$mn:00001968                 jb      short loc_197E
.text$mn:0000196A                 mov     ecx, [ebp+var_4]
.text$mn:0000196D                 mov     edx, [ecx+4]
.text$mn:00001970                 push    edx
.text$mn:00001971                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00001976                 add     esp, 4
.text$mn:00001979                 mov     [ebp+var_8], eax
.text$mn:0000197C                 jmp     short loc_1987
.text$mn:0000197E ; ---------------------------------------------------------------------------
.text$mn:0000197E
.text$mn:0000197E loc_197E:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:0000197E                 mov     eax, [ebp+var_4]
.text$mn:00001981                 add     eax, 4
.text$mn:00001984                 mov     [ebp+var_8], eax
.text$mn:00001987
.text$mn:00001987 loc_1987:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00001987                 mov     eax, [ebp+var_8]
.text$mn:0000198A                 mov     esp, ebp
.text$mn:0000198C                 pop     ebp
.text$mn:0000198D                 retn
.text$mn:0000198D ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:0000198D
.text$mn:0000198D ; ---------------------------------------------------------------------------
.text$mn:0000198E                 align 10h
.text$mn:0000198E _text$mn        ends
.text$mn:0000198E
.text$mn:00001990 ; ===========================================================================
.text$mn:00001990
.text$mn:00001990 ; Segment type: Pure code
.text$mn:00001990 ; Segment permissions: Read/Execute
.text$mn:00001990 _text$mn        segment para public 'CODE' use32
.text$mn:00001990                 assume cs:_text$mn
.text$mn:00001990                 ;org 1990h
.text$mn:00001990 ; COMDAT (pick any)
.text$mn:00001990                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001990
.text$mn:00001990 ; =============== S U B R O U T I N E =======================================
.text$mn:00001990
.text$mn:00001990 ; Attributes: bp-based frame
.text$mn:00001990
.text$mn:00001990 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00001990                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001990 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00001990                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00001990                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:00001990
.text$mn:00001990 var_18          = byte ptr -18h
.text$mn:00001990 var_14          = dword ptr -14h
.text$mn:00001990 var_10          = dword ptr -10h
.text$mn:00001990 var_C           = dword ptr -0Ch
.text$mn:00001990 var_4           = dword ptr -4
.text$mn:00001990
.text$mn:00001990                 push    ebp
.text$mn:00001991                 mov     ebp, esp
.text$mn:00001993                 push    0FFFFFFFFh
.text$mn:00001995                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000199A                 mov     eax, large fs:0
.text$mn:000019A0                 push    eax
.text$mn:000019A1                 sub     esp, 0Ch
.text$mn:000019A4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000019A9                 xor     eax, ebp
.text$mn:000019AB                 push    eax
.text$mn:000019AC                 lea     eax, [ebp+var_C]
.text$mn:000019AF                 mov     large fs:0, eax
.text$mn:000019B5                 mov     [ebp+var_14], ecx
.text$mn:000019B8                 mov     eax, [ebp+var_14]
.text$mn:000019BB                 cmp     dword ptr [eax], 0
.text$mn:000019BE                 jz      short loc_1A1B
.text$mn:000019C0                 push    3               ; int
.text$mn:000019C2                 lea     ecx, [ebp+var_18] ; this
.text$mn:000019C5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000019CA                 mov     [ebp+var_4], 0
.text$mn:000019D1                 mov     ecx, [ebp+var_14]
.text$mn:000019D4                 mov     edx, [ecx]
.text$mn:000019D6                 add     edx, 4
.text$mn:000019D9                 mov     [ebp+var_10], edx
.text$mn:000019DC                 jmp     short loc_19EB
.text$mn:000019DE ; ---------------------------------------------------------------------------
.text$mn:000019DE
.text$mn:000019DE loc_19DE:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:000019DE                 mov     eax, [ebp+var_10]
.text$mn:000019E1                 mov     ecx, [eax]
.text$mn:000019E3                 mov     edx, [ebp+var_10]
.text$mn:000019E6                 mov     eax, [ecx+4]
.text$mn:000019E9                 mov     [edx], eax
.text$mn:000019EB
.text$mn:000019EB loc_19EB:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:000019EB                 mov     ecx, [ebp+var_10]
.text$mn:000019EE                 cmp     dword ptr [ecx], 0
.text$mn:000019F1                 jz      short loc_1A00
.text$mn:000019F3                 mov     edx, [ebp+var_10]
.text$mn:000019F6                 mov     eax, [edx]
.text$mn:000019F8                 mov     dword ptr [eax], 0
.text$mn:000019FE                 jmp     short loc_19DE
.text$mn:00001A00 ; ---------------------------------------------------------------------------
.text$mn:00001A00
.text$mn:00001A00 loc_1A00:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00001A00                 mov     ecx, [ebp+var_14]
.text$mn:00001A03                 mov     edx, [ecx]
.text$mn:00001A05                 mov     dword ptr [edx+4], 0
.text$mn:00001A0C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A13                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001A16                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00001A1B
.text$mn:00001A1B loc_1A1B:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00001A1B                 mov     ecx, [ebp+var_C]
.text$mn:00001A1E                 mov     large fs:0, ecx
.text$mn:00001A25                 pop     ecx
.text$mn:00001A26                 mov     esp, ebp
.text$mn:00001A28                 pop     ebp
.text$mn:00001A29                 retn
.text$mn:00001A29 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00001A29
.text$mn:00001A29 ; ---------------------------------------------------------------------------
.text$mn:00001A2A                 align 4
.text$mn:00001A2A _text$mn        ends
.text$mn:00001A2A
.text$x:00001A2C ; ===========================================================================
.text$x:00001A2C
.text$x:00001A2C ; Segment type: Pure code
.text$x:00001A2C ; Segment permissions: Read/Execute
.text$x:00001A2C _text$x         segment para public 'CODE' use32
.text$x:00001A2C                 assume cs:_text$x
.text$x:00001A2C                 ;org 1A2Ch
.text$x:00001A2C ; COMDAT (pick associative to section at 1990)
.text$x:00001A2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001A2C
.text$x:00001A2C ; =============== S U B R O U T I N E =======================================
.text$x:00001A2C
.text$x:00001A2C
.text$x:00001A2C __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00001A2C                                         ; DATA XREF: .xdata$x:00002838o
.text$x:00001A2C                 lea     ecx, [ebp-18h]  ; this
.text$x:00001A2F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00001A2F __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00001A2F
.text$x:00001A34
.text$x:00001A34 ; =============== S U B R O U T I N E =======================================
.text$x:00001A34
.text$x:00001A34
.text$x:00001A34 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00001A34                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00001A34
.text$x:00001A34 arg_4           = dword ptr  8
.text$x:00001A34
.text$x:00001A34                 mov     edx, [esp+arg_4]
.text$x:00001A38                 lea     eax, [edx+0Ch]
.text$x:00001A3B                 mov     ecx, [edx-10h]
.text$x:00001A3E                 xor     ecx, eax
.text$x:00001A40                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A45                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00001A4A                 jmp     ___CxxFrameHandler3
.text$x:00001A4A __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00001A4A
.text$x:00001A4A ; ---------------------------------------------------------------------------
.text$x:00001A4F                 align 10h
.text$x:00001A4F _text$x         ends
.text$x:00001A4F
.text$mn:00001A50 ; ===========================================================================
.text$mn:00001A50
.text$mn:00001A50 ; Segment type: Pure code
.text$mn:00001A50 ; Segment permissions: Read/Execute
.text$mn:00001A50 _text$mn        segment para public 'CODE' use32
.text$mn:00001A50                 assume cs:_text$mn
.text$mn:00001A50                 ;org 1A50h
.text$mn:00001A50 ; COMDAT (pick any)
.text$mn:00001A50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A50
.text$mn:00001A50 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A50
.text$mn:00001A50 ; Attributes: bp-based frame
.text$mn:00001A50
.text$mn:00001A50 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00001A50                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00001A50 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00001A50                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00001A50                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00001A50
.text$mn:00001A50 var_C           = dword ptr -0Ch
.text$mn:00001A50 var_8           = dword ptr -8
.text$mn:00001A50 var_2           = byte ptr -2
.text$mn:00001A50 var_1           = byte ptr -1
.text$mn:00001A50 arg_0           = byte ptr  8
.text$mn:00001A50 Size            = dword ptr  0Ch
.text$mn:00001A50
.text$mn:00001A50                 push    ebp
.text$mn:00001A51                 mov     ebp, esp
.text$mn:00001A53                 sub     esp, 0Ch
.text$mn:00001A56                 mov     [ebp+var_8], ecx
.text$mn:00001A59                 movzx   eax, [ebp+arg_0]
.text$mn:00001A5D                 test    eax, eax
.text$mn:00001A5F                 jnz     short loc_1A63
.text$mn:00001A61                 jmp     short loc_1AD6
.text$mn:00001A63 ; ---------------------------------------------------------------------------
.text$mn:00001A63
.text$mn:00001A63 loc_1A63:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00001A63                 mov     ecx, [ebp+var_8]
.text$mn:00001A66                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00001A6A                 jb      short loc_1AD6
.text$mn:00001A6C                 mov     edx, [ebp+var_8]
.text$mn:00001A6F                 mov     eax, [edx+4]
.text$mn:00001A72                 mov     [ebp+var_C], eax
.text$mn:00001A75                 mov     ecx, [ebp+var_8]
.text$mn:00001A78                 add     ecx, 4
.text$mn:00001A7B                 push    ecx
.text$mn:00001A7C                 lea     edx, [ebp+var_1]
.text$mn:00001A7F                 push    edx
.text$mn:00001A80                 mov     ecx, [ebp+var_8]
.text$mn:00001A83                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001A88                 mov     ecx, eax
.text$mn:00001A8A                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001A8F                 cmp     [ebp+Size], 0
.text$mn:00001A93                 jbe     short loc_1AB5
.text$mn:00001A95                 mov     eax, [ebp+Size]
.text$mn:00001A98                 push    eax             ; Size
.text$mn:00001A99                 mov     ecx, [ebp+var_C]
.text$mn:00001A9C                 push    ecx
.text$mn:00001A9D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001AA2                 add     esp, 4
.text$mn:00001AA5                 push    eax             ; Src
.text$mn:00001AA6                 mov     edx, [ebp+var_8]
.text$mn:00001AA9                 add     edx, 4
.text$mn:00001AAC                 push    edx             ; Dst
.text$mn:00001AAD                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001AB2                 add     esp, 0Ch
.text$mn:00001AB5
.text$mn:00001AB5 loc_1AB5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00001AB5                 mov     eax, [ebp+var_8]
.text$mn:00001AB8                 mov     ecx, [eax+18h]
.text$mn:00001ABB                 add     ecx, 1
.text$mn:00001ABE                 push    ecx             ; int
.text$mn:00001ABF                 mov     edx, [ebp+var_C]
.text$mn:00001AC2                 push    edx             ; void *
.text$mn:00001AC3                 lea     eax, [ebp+var_2]
.text$mn:00001AC6                 push    eax
.text$mn:00001AC7                 mov     ecx, [ebp+var_8]
.text$mn:00001ACA                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001ACF                 mov     ecx, eax
.text$mn:00001AD1                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00001AD6
.text$mn:00001AD6 loc_1AD6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00001AD6                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00001AD6                 mov     ecx, [ebp+var_8]
.text$mn:00001AD9                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00001AE0                 mov     edx, [ebp+Size]
.text$mn:00001AE3                 push    edx
.text$mn:00001AE4                 mov     ecx, [ebp+var_8]
.text$mn:00001AE7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001AEC                 mov     esp, ebp
.text$mn:00001AEE                 pop     ebp
.text$mn:00001AEF                 retn    8
.text$mn:00001AEF ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00001AEF
.text$mn:00001AEF ; ---------------------------------------------------------------------------
.text$mn:00001AF2                 align 4
.text$mn:00001AF2 _text$mn        ends
.text$mn:00001AF2
.text$mn:00001AF4 ; ===========================================================================
.text$mn:00001AF4
.text$mn:00001AF4 ; Segment type: Pure code
.text$mn:00001AF4 ; Segment permissions: Read/Execute
.text$mn:00001AF4 _text$mn        segment para public 'CODE' use32
.text$mn:00001AF4                 assume cs:_text$mn
.text$mn:00001AF4                 ;org 1AF4h
.text$mn:00001AF4 ; COMDAT (pick any)
.text$mn:00001AF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AF4
.text$mn:00001AF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AF4
.text$mn:00001AF4 ; Attributes: bp-based frame
.text$mn:00001AF4
.text$mn:00001AF4 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:00001AF4                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:00001AF4 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:00001AF4                                         ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1+7p
.text$mn:00001AF4                                         ; $LN19_0+2Dp ...
.text$mn:00001AF4
.text$mn:00001AF4 var_C           = dword ptr -0Ch
.text$mn:00001AF4 var_8           = dword ptr -8
.text$mn:00001AF4 var_2           = byte ptr -2
.text$mn:00001AF4 var_1           = byte ptr -1
.text$mn:00001AF4 arg_0           = byte ptr  8
.text$mn:00001AF4 arg_4           = dword ptr  0Ch
.text$mn:00001AF4
.text$mn:00001AF4                 push    ebp
.text$mn:00001AF5                 mov     ebp, esp
.text$mn:00001AF7                 sub     esp, 0Ch
.text$mn:00001AFA                 mov     [ebp+var_8], ecx
.text$mn:00001AFD                 movzx   eax, [ebp+arg_0]
.text$mn:00001B01                 test    eax, eax
.text$mn:00001B03                 jnz     short loc_1B07
.text$mn:00001B05                 jmp     short loc_1B7A
.text$mn:00001B07 ; ---------------------------------------------------------------------------
.text$mn:00001B07
.text$mn:00001B07 loc_1B07:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:00001B07                 mov     ecx, [ebp+var_8]
.text$mn:00001B0A                 cmp     dword ptr [ecx+18h], 8
.text$mn:00001B0E                 jb      short loc_1B7A
.text$mn:00001B10                 mov     edx, [ebp+var_8]
.text$mn:00001B13                 mov     eax, [edx+4]
.text$mn:00001B16                 mov     [ebp+var_C], eax
.text$mn:00001B19                 mov     ecx, [ebp+var_8]
.text$mn:00001B1C                 add     ecx, 4
.text$mn:00001B1F                 push    ecx
.text$mn:00001B20                 lea     edx, [ebp+var_1]
.text$mn:00001B23                 push    edx
.text$mn:00001B24                 mov     ecx, [ebp+var_8]
.text$mn:00001B27                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001B2C                 mov     ecx, eax
.text$mn:00001B2E                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00001B33                 cmp     [ebp+arg_4], 0
.text$mn:00001B37                 jbe     short loc_1B59
.text$mn:00001B39                 mov     eax, [ebp+arg_4]
.text$mn:00001B3C                 push    eax             ; int
.text$mn:00001B3D                 mov     ecx, [ebp+var_C]
.text$mn:00001B40                 push    ecx
.text$mn:00001B41                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00001B46                 add     esp, 4
.text$mn:00001B49                 push    eax             ; Src
.text$mn:00001B4A                 mov     edx, [ebp+var_8]
.text$mn:00001B4D                 add     edx, 4
.text$mn:00001B50                 push    edx             ; Dst
.text$mn:00001B51                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00001B56                 add     esp, 0Ch
.text$mn:00001B59
.text$mn:00001B59 loc_1B59:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:00001B59                 mov     eax, [ebp+var_8]
.text$mn:00001B5C                 mov     ecx, [eax+18h]
.text$mn:00001B5F                 add     ecx, 1
.text$mn:00001B62                 push    ecx             ; int
.text$mn:00001B63                 mov     edx, [ebp+var_C]
.text$mn:00001B66                 push    edx             ; void *
.text$mn:00001B67                 lea     eax, [ebp+var_2]
.text$mn:00001B6A                 push    eax
.text$mn:00001B6B                 mov     ecx, [ebp+var_8]
.text$mn:00001B6E                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001B73                 mov     ecx, eax
.text$mn:00001B75                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:00001B7A
.text$mn:00001B7A loc_1B7A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:00001B7A                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:00001B7A                 mov     ecx, [ebp+var_8]
.text$mn:00001B7D                 mov     dword ptr [ecx+18h], 7
.text$mn:00001B84                 mov     edx, [ebp+arg_4]
.text$mn:00001B87                 push    edx
.text$mn:00001B88                 mov     ecx, [ebp+var_8]
.text$mn:00001B8B                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00001B90                 mov     esp, ebp
.text$mn:00001B92                 pop     ebp
.text$mn:00001B93                 retn    8
.text$mn:00001B93 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:00001B93
.text$mn:00001B93 ; ---------------------------------------------------------------------------
.text$mn:00001B96                 align 4
.text$mn:00001B96 _text$mn        ends
.text$mn:00001B96
.text$mn:00001B98 ; ===========================================================================
.text$mn:00001B98
.text$mn:00001B98 ; Segment type: Pure code
.text$mn:00001B98 ; Segment permissions: Read/Execute
.text$mn:00001B98 _text$mn        segment para public 'CODE' use32
.text$mn:00001B98                 assume cs:_text$mn
.text$mn:00001B98                 ;org 1B98h
.text$mn:00001B98 ; COMDAT (pick any)
.text$mn:00001B98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B98
.text$mn:00001B98 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B98
.text$mn:00001B98 ; Attributes: bp-based frame
.text$mn:00001B98
.text$mn:00001B98 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00001B98                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001B98 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001B98                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00001B98
.text$mn:00001B98 var_4           = dword ptr -4
.text$mn:00001B98
.text$mn:00001B98                 push    ebp
.text$mn:00001B99                 mov     ebp, esp
.text$mn:00001B9B                 push    ecx
.text$mn:00001B9C                 mov     [ebp+var_4], ecx
.text$mn:00001B9F                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00001BA4                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00001BA9                 mov     esp, ebp
.text$mn:00001BAB                 pop     ebp
.text$mn:00001BAC                 retn
.text$mn:00001BAC ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001BAC
.text$mn:00001BAC ; ---------------------------------------------------------------------------
.text$mn:00001BAD                 align 10h
.text$mn:00001BAD _text$mn        ends
.text$mn:00001BAD
.text$mn:00001BB0 ; ===========================================================================
.text$mn:00001BB0
.text$mn:00001BB0 ; Segment type: Pure code
.text$mn:00001BB0 ; Segment permissions: Read/Execute
.text$mn:00001BB0 _text$mn        segment para public 'CODE' use32
.text$mn:00001BB0                 assume cs:_text$mn
.text$mn:00001BB0                 ;org 1BB0h
.text$mn:00001BB0 ; COMDAT (pick any)
.text$mn:00001BB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BB0
.text$mn:00001BB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BB0
.text$mn:00001BB0 ; Attributes: bp-based frame
.text$mn:00001BB0
.text$mn:00001BB0 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:00001BB0                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00001BB0 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00001BB0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:00001BB0
.text$mn:00001BB0 var_4           = dword ptr -4
.text$mn:00001BB0
.text$mn:00001BB0                 push    ebp
.text$mn:00001BB1                 mov     ebp, esp
.text$mn:00001BB3                 push    ecx
.text$mn:00001BB4                 mov     [ebp+var_4], ecx
.text$mn:00001BB7                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00001BBC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00001BC1                 mov     esp, ebp
.text$mn:00001BC3                 pop     ebp
.text$mn:00001BC4                 retn
.text$mn:00001BC4 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00001BC4
.text$mn:00001BC4 ; ---------------------------------------------------------------------------
.text$mn:00001BC5                 align 4
.text$mn:00001BC5 _text$mn        ends
.text$mn:00001BC5
.text$mn:00001BC8 ; ===========================================================================
.text$mn:00001BC8
.text$mn:00001BC8 ; Segment type: Pure code
.text$mn:00001BC8 ; Segment permissions: Read/Execute
.text$mn:00001BC8 _text$mn        segment para public 'CODE' use32
.text$mn:00001BC8                 assume cs:_text$mn
.text$mn:00001BC8                 ;org 1BC8h
.text$mn:00001BC8 ; COMDAT (pick any)
.text$mn:00001BC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BC8
.text$mn:00001BC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BC8
.text$mn:00001BC8 ; Attributes: bp-based frame
.text$mn:00001BC8
.text$mn:00001BC8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00001BC8                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001BC8 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001BC8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00001BC8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00001BC8
.text$mn:00001BC8 var_4           = dword ptr -4
.text$mn:00001BC8
.text$mn:00001BC8                 push    ebp
.text$mn:00001BC9                 mov     ebp, esp
.text$mn:00001BCB                 push    ecx
.text$mn:00001BCC                 mov     [ebp+var_4], ecx
.text$mn:00001BCF                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00001BD4                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00001BD9                 mov     esp, ebp
.text$mn:00001BDB                 pop     ebp
.text$mn:00001BDC                 retn
.text$mn:00001BDC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001BDC
.text$mn:00001BDC ; ---------------------------------------------------------------------------
.text$mn:00001BDD                 align 10h
.text$mn:00001BDD _text$mn        ends
.text$mn:00001BDD
.text$mn:00001BE0 ; ===========================================================================
.text$mn:00001BE0
.text$mn:00001BE0 ; Segment type: Pure code
.text$mn:00001BE0 ; Segment permissions: Read/Execute
.text$mn:00001BE0 _text$mn        segment para public 'CODE' use32
.text$mn:00001BE0                 assume cs:_text$mn
.text$mn:00001BE0                 ;org 1BE0h
.text$mn:00001BE0 ; COMDAT (pick any)
.text$mn:00001BE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BE0
.text$mn:00001BE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BE0
.text$mn:00001BE0 ; Attributes: bp-based frame
.text$mn:00001BE0
.text$mn:00001BE0 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:00001BE0                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00001BE0 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00001BE0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:00001BE0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+15p ...
.text$mn:00001BE0
.text$mn:00001BE0 var_4           = dword ptr -4
.text$mn:00001BE0
.text$mn:00001BE0                 push    ebp
.text$mn:00001BE1                 mov     ebp, esp
.text$mn:00001BE3                 push    ecx
.text$mn:00001BE4                 mov     [ebp+var_4], ecx
.text$mn:00001BE7                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00001BEC                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00001BF1                 mov     esp, ebp
.text$mn:00001BF3                 pop     ebp
.text$mn:00001BF4                 retn
.text$mn:00001BF4 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00001BF4
.text$mn:00001BF4 ; ---------------------------------------------------------------------------
.text$mn:00001BF5                 align 4
.text$mn:00001BF5 _text$mn        ends
.text$mn:00001BF5
.text$mn:00001BF8 ; ===========================================================================
.text$mn:00001BF8
.text$mn:00001BF8 ; Segment type: Pure code
.text$mn:00001BF8 ; Segment permissions: Read/Execute
.text$mn:00001BF8 _text$mn        segment para public 'CODE' use32
.text$mn:00001BF8                 assume cs:_text$mn
.text$mn:00001BF8                 ;org 1BF8h
.text$mn:00001BF8 ; COMDAT (pick any)
.text$mn:00001BF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BF8
.text$mn:00001BF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BF8
.text$mn:00001BF8 ; Attributes: bp-based frame
.text$mn:00001BF8
.text$mn:00001BF8 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00001BF8                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00001BF8 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00001BF8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00001BF8                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00001BF8
.text$mn:00001BF8 var_4           = dword ptr -4
.text$mn:00001BF8 arg_0           = dword ptr  8
.text$mn:00001BF8
.text$mn:00001BF8                 push    ebp
.text$mn:00001BF9                 mov     ebp, esp
.text$mn:00001BFB                 push    ecx
.text$mn:00001BFC                 mov     [ebp+var_4], ecx
.text$mn:00001BFF                 mov     eax, [ebp+arg_0]
.text$mn:00001C02                 push    eax
.text$mn:00001C03                 mov     ecx, [ebp+var_4]
.text$mn:00001C06                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00001C0B                 mov     esp, ebp
.text$mn:00001C0D                 pop     ebp
.text$mn:00001C0E                 retn    4
.text$mn:00001C0E ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00001C0E
.text$mn:00001C0E ; ---------------------------------------------------------------------------
.text$mn:00001C11                 align 4
.text$mn:00001C11 _text$mn        ends
.text$mn:00001C11
.text$mn:00001C14 ; ===========================================================================
.text$mn:00001C14
.text$mn:00001C14 ; Segment type: Pure code
.text$mn:00001C14 ; Segment permissions: Read/Execute
.text$mn:00001C14 _text$mn        segment para public 'CODE' use32
.text$mn:00001C14                 assume cs:_text$mn
.text$mn:00001C14                 ;org 1C14h
.text$mn:00001C14 ; COMDAT (pick any)
.text$mn:00001C14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C14
.text$mn:00001C14 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C14
.text$mn:00001C14 ; Attributes: bp-based frame
.text$mn:00001C14
.text$mn:00001C14 ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:00001C14                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:00001C14 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:00001C14                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:00001C14                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:00001C14
.text$mn:00001C14 var_4           = dword ptr -4
.text$mn:00001C14 arg_0           = dword ptr  8
.text$mn:00001C14
.text$mn:00001C14                 push    ebp
.text$mn:00001C15                 mov     ebp, esp
.text$mn:00001C17                 push    ecx
.text$mn:00001C18                 mov     [ebp+var_4], ecx
.text$mn:00001C1B                 mov     eax, [ebp+arg_0]
.text$mn:00001C1E                 push    eax
.text$mn:00001C1F                 mov     ecx, [ebp+var_4]
.text$mn:00001C22                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:00001C27                 mov     esp, ebp
.text$mn:00001C29                 pop     ebp
.text$mn:00001C2A                 retn    4
.text$mn:00001C2A ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:00001C2A
.text$mn:00001C2A ; ---------------------------------------------------------------------------
.text$mn:00001C2D                 align 10h
.text$mn:00001C2D _text$mn        ends
.text$mn:00001C2D
.text$mn:00001C30 ; ===========================================================================
.text$mn:00001C30
.text$mn:00001C30 ; Segment type: Pure code
.text$mn:00001C30 ; Segment permissions: Read/Execute
.text$mn:00001C30 _text$mn        segment para public 'CODE' use32
.text$mn:00001C30                 assume cs:_text$mn
.text$mn:00001C30                 ;org 1C30h
.text$mn:00001C30 ; COMDAT (pick any)
.text$mn:00001C30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C30
.text$mn:00001C30 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C30
.text$mn:00001C30 ; Attributes: bp-based frame
.text$mn:00001C30
.text$mn:00001C30 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00001C30                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00001C30 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00001C30                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00001C30
.text$mn:00001C30 var_4           = dword ptr -4
.text$mn:00001C30 arg_0           = dword ptr  8
.text$mn:00001C30
.text$mn:00001C30                 push    ebp
.text$mn:00001C31                 mov     ebp, esp
.text$mn:00001C33                 push    ecx
.text$mn:00001C34                 mov     [ebp+var_4], ecx
.text$mn:00001C37                 push    0
.text$mn:00001C39                 mov     eax, [ebp+arg_0]
.text$mn:00001C3C                 push    eax
.text$mn:00001C3D                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00001C42                 add     esp, 8
.text$mn:00001C45                 mov     esp, ebp
.text$mn:00001C47                 pop     ebp
.text$mn:00001C48                 retn    4
.text$mn:00001C48 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00001C48
.text$mn:00001C48 ; ---------------------------------------------------------------------------
.text$mn:00001C4B                 align 4
.text$mn:00001C4B _text$mn        ends
.text$mn:00001C4B
.text$mn:00001C4C ; ===========================================================================
.text$mn:00001C4C
.text$mn:00001C4C ; Segment type: Pure code
.text$mn:00001C4C ; Segment permissions: Read/Execute
.text$mn:00001C4C _text$mn        segment para public 'CODE' use32
.text$mn:00001C4C                 assume cs:_text$mn
.text$mn:00001C4C                 ;org 1C4Ch
.text$mn:00001C4C ; COMDAT (pick any)
.text$mn:00001C4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C4C
.text$mn:00001C4C ; =============== S U B R O U T I N E =======================================
.text$mn:00001C4C
.text$mn:00001C4C ; Attributes: bp-based frame
.text$mn:00001C4C
.text$mn:00001C4C ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00001C4C                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00001C4C ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00001C4C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00001C4C
.text$mn:00001C4C var_4           = dword ptr -4
.text$mn:00001C4C arg_0           = dword ptr  8
.text$mn:00001C4C
.text$mn:00001C4C                 push    ebp
.text$mn:00001C4D                 mov     ebp, esp
.text$mn:00001C4F                 push    ecx
.text$mn:00001C50                 mov     [ebp+var_4], ecx
.text$mn:00001C53                 push    0
.text$mn:00001C55                 mov     eax, [ebp+arg_0]
.text$mn:00001C58                 push    eax
.text$mn:00001C59                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00001C5E                 add     esp, 8
.text$mn:00001C61                 mov     esp, ebp
.text$mn:00001C63                 pop     ebp
.text$mn:00001C64                 retn    4
.text$mn:00001C64 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00001C64
.text$mn:00001C64 ; ---------------------------------------------------------------------------
.text$mn:00001C67                 align 4
.text$mn:00001C67 _text$mn        ends
.text$mn:00001C67
.text$mn:00001C68 ; ===========================================================================
.text$mn:00001C68
.text$mn:00001C68 ; Segment type: Pure code
.text$mn:00001C68 ; Segment permissions: Read/Execute
.text$mn:00001C68 _text$mn        segment para public 'CODE' use32
.text$mn:00001C68                 assume cs:_text$mn
.text$mn:00001C68                 ;org 1C68h
.text$mn:00001C68 ; COMDAT (pick any)
.text$mn:00001C68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C68
.text$mn:00001C68 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C68
.text$mn:00001C68 ; Attributes: bp-based frame
.text$mn:00001C68
.text$mn:00001C68 ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:00001C68                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:00001C68 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:00001C68                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:00001C68
.text$mn:00001C68 var_4           = dword ptr -4
.text$mn:00001C68 arg_0           = dword ptr  8
.text$mn:00001C68
.text$mn:00001C68                 push    ebp
.text$mn:00001C69                 mov     ebp, esp
.text$mn:00001C6B                 push    ecx
.text$mn:00001C6C                 mov     [ebp+var_4], ecx
.text$mn:00001C6F                 push    0
.text$mn:00001C71                 mov     eax, [ebp+arg_0]
.text$mn:00001C74                 push    eax
.text$mn:00001C75                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:00001C7A                 add     esp, 8
.text$mn:00001C7D                 mov     esp, ebp
.text$mn:00001C7F                 pop     ebp
.text$mn:00001C80                 retn    4
.text$mn:00001C80 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:00001C80
.text$mn:00001C80 ; ---------------------------------------------------------------------------
.text$mn:00001C83                 align 4
.text$mn:00001C83 _text$mn        ends
.text$mn:00001C83
.text$mn:00001C84 ; ===========================================================================
.text$mn:00001C84
.text$mn:00001C84 ; Segment type: Pure code
.text$mn:00001C84 ; Segment permissions: Read/Execute
.text$mn:00001C84 _text$mn        segment para public 'CODE' use32
.text$mn:00001C84                 assume cs:_text$mn
.text$mn:00001C84                 ;org 1C84h
.text$mn:00001C84 ; COMDAT (pick any)
.text$mn:00001C84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C84
.text$mn:00001C84 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C84
.text$mn:00001C84 ; Attributes: bp-based frame
.text$mn:00001C84
.text$mn:00001C84 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00001C84                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00001C84 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00001C84                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00001C84
.text$mn:00001C84 Size            = dword ptr -8
.text$mn:00001C84 var_4           = dword ptr -4
.text$mn:00001C84 arg_0           = dword ptr  8
.text$mn:00001C84 arg_4           = dword ptr  0Ch
.text$mn:00001C84 arg_8           = dword ptr  10h
.text$mn:00001C84
.text$mn:00001C84                 push    ebp
.text$mn:00001C85                 mov     ebp, esp
.text$mn:00001C87                 sub     esp, 8
.text$mn:00001C8A                 mov     [ebp+var_4], ecx
.text$mn:00001C8D                 mov     ecx, [ebp+arg_0]
.text$mn:00001C90                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001C95                 cmp     eax, [ebp+arg_4]
.text$mn:00001C98                 jnb     short loc_1CA2
.text$mn:00001C9A                 mov     ecx, [ebp+var_4]
.text$mn:00001C9D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001CA2
.text$mn:00001CA2 loc_1CA2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00001CA2                 mov     ecx, [ebp+arg_0]
.text$mn:00001CA5                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001CAA                 sub     eax, [ebp+arg_4]
.text$mn:00001CAD                 mov     [ebp+Size], eax
.text$mn:00001CB0                 mov     eax, [ebp+arg_8]
.text$mn:00001CB3                 cmp     eax, [ebp+Size]
.text$mn:00001CB6                 jnb     short loc_1CBE
.text$mn:00001CB8                 mov     ecx, [ebp+arg_8]
.text$mn:00001CBB                 mov     [ebp+Size], ecx
.text$mn:00001CBE
.text$mn:00001CBE loc_1CBE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00001CBE                 mov     edx, [ebp+var_4]
.text$mn:00001CC1                 cmp     edx, [ebp+arg_0]
.text$mn:00001CC4                 jnz     short loc_1CE5
.text$mn:00001CC6                 mov     eax, [ebp+arg_4]
.text$mn:00001CC9                 add     eax, [ebp+Size]
.text$mn:00001CCC                 push    eax
.text$mn:00001CCD                 mov     ecx, [ebp+var_4]
.text$mn:00001CD0                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00001CD5                 mov     ecx, [ebp+arg_4]
.text$mn:00001CD8                 push    ecx
.text$mn:00001CD9                 push    0
.text$mn:00001CDB                 mov     ecx, [ebp+var_4]
.text$mn:00001CDE                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00001CE3                 jmp     short loc_1D27
.text$mn:00001CE5 ; ---------------------------------------------------------------------------
.text$mn:00001CE5
.text$mn:00001CE5 loc_1CE5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00001CE5                 push    0
.text$mn:00001CE7                 mov     edx, [ebp+Size]
.text$mn:00001CEA                 push    edx
.text$mn:00001CEB                 mov     ecx, [ebp+var_4]
.text$mn:00001CEE                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001CF3                 movzx   eax, al
.text$mn:00001CF6                 test    eax, eax
.text$mn:00001CF8                 jz      short loc_1D27
.text$mn:00001CFA                 mov     ecx, [ebp+Size]
.text$mn:00001CFD                 push    ecx             ; Size
.text$mn:00001CFE                 mov     ecx, [ebp+arg_0]
.text$mn:00001D01                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001D06                 add     eax, [ebp+arg_4]
.text$mn:00001D09                 push    eax             ; Src
.text$mn:00001D0A                 mov     ecx, [ebp+var_4]
.text$mn:00001D0D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001D12                 push    eax             ; Dst
.text$mn:00001D13                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001D18                 add     esp, 0Ch
.text$mn:00001D1B                 mov     edx, [ebp+Size]
.text$mn:00001D1E                 push    edx
.text$mn:00001D1F                 mov     ecx, [ebp+var_4]
.text$mn:00001D22                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001D27
.text$mn:00001D27 loc_1D27:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00001D27                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00001D27                 mov     eax, [ebp+var_4]
.text$mn:00001D2A                 mov     esp, ebp
.text$mn:00001D2C                 pop     ebp
.text$mn:00001D2D                 retn    0Ch
.text$mn:00001D2D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00001D2D
.text$mn:00001D2D _text$mn        ends
.text$mn:00001D2D
.text$mn:00001D30 ; ===========================================================================
.text$mn:00001D30
.text$mn:00001D30 ; Segment type: Pure code
.text$mn:00001D30 ; Segment permissions: Read/Execute
.text$mn:00001D30 _text$mn        segment para public 'CODE' use32
.text$mn:00001D30                 assume cs:_text$mn
.text$mn:00001D30                 ;org 1D30h
.text$mn:00001D30 ; COMDAT (pick any)
.text$mn:00001D30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D30
.text$mn:00001D30 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D30
.text$mn:00001D30 ; Attributes: bp-based frame
.text$mn:00001D30
.text$mn:00001D30 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00001D30                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00001D30 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00001D30                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00001D30
.text$mn:00001D30 var_4           = dword ptr -4
.text$mn:00001D30 Str             = dword ptr  8
.text$mn:00001D30
.text$mn:00001D30                 push    ebp
.text$mn:00001D31                 mov     ebp, esp
.text$mn:00001D33                 push    ecx
.text$mn:00001D34                 mov     [ebp+var_4], ecx
.text$mn:00001D37                 push    490h            ; unsigned int
.text$mn:00001D3C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001D41                 mov     eax, [ebp+Str]
.text$mn:00001D44                 push    eax             ; int
.text$mn:00001D45                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001D4A                 add     esp, 0Ch
.text$mn:00001D4D                 mov     ecx, [ebp+Str]
.text$mn:00001D50                 push    ecx             ; Str
.text$mn:00001D51                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00001D56                 add     esp, 4
.text$mn:00001D59                 push    eax             ; Size
.text$mn:00001D5A                 mov     edx, [ebp+Str]
.text$mn:00001D5D                 push    edx             ; Src
.text$mn:00001D5E                 mov     ecx, [ebp+var_4]
.text$mn:00001D61                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00001D66                 mov     esp, ebp
.text$mn:00001D68                 pop     ebp
.text$mn:00001D69                 retn    4
.text$mn:00001D69 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00001D69
.text$mn:00001D69 _text$mn        ends
.text$mn:00001D69
.text$mn:00001D6C ; ===========================================================================
.text$mn:00001D6C
.text$mn:00001D6C ; Segment type: Pure code
.text$mn:00001D6C ; Segment permissions: Read/Execute
.text$mn:00001D6C _text$mn        segment para public 'CODE' use32
.text$mn:00001D6C                 assume cs:_text$mn
.text$mn:00001D6C                 ;org 1D6Ch
.text$mn:00001D6C ; COMDAT (pick any)
.text$mn:00001D6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D6C
.text$mn:00001D6C ; =============== S U B R O U T I N E =======================================
.text$mn:00001D6C
.text$mn:00001D6C ; Attributes: bp-based frame
.text$mn:00001D6C
.text$mn:00001D6C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00001D6C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00001D6C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00001D6C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00001D6C
.text$mn:00001D6C var_4           = dword ptr -4
.text$mn:00001D6C Src             = dword ptr  8
.text$mn:00001D6C Size            = dword ptr  0Ch
.text$mn:00001D6C
.text$mn:00001D6C                 push    ebp
.text$mn:00001D6D                 mov     ebp, esp
.text$mn:00001D6F                 push    ecx
.text$mn:00001D70                 mov     [ebp+var_4], ecx
.text$mn:00001D73                 cmp     [ebp+Size], 0
.text$mn:00001D77                 jz      short loc_1D8F
.text$mn:00001D79                 push    47Fh            ; unsigned int
.text$mn:00001D7E                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001D83                 mov     eax, [ebp+Src]
.text$mn:00001D86                 push    eax             ; int
.text$mn:00001D87                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001D8C                 add     esp, 0Ch
.text$mn:00001D8F
.text$mn:00001D8F loc_1D8F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00001D8F                 mov     ecx, [ebp+Src]
.text$mn:00001D92                 push    ecx
.text$mn:00001D93                 mov     ecx, [ebp+var_4]
.text$mn:00001D96                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00001D9B                 movzx   edx, al
.text$mn:00001D9E                 test    edx, edx
.text$mn:00001DA0                 jz      short loc_1DC2
.text$mn:00001DA2                 mov     eax, [ebp+Size]
.text$mn:00001DA5                 push    eax
.text$mn:00001DA6                 mov     ecx, [ebp+var_4]
.text$mn:00001DA9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001DAE                 mov     ecx, [ebp+Src]
.text$mn:00001DB1                 sub     ecx, eax
.text$mn:00001DB3                 push    ecx
.text$mn:00001DB4                 mov     edx, [ebp+var_4]
.text$mn:00001DB7                 push    edx
.text$mn:00001DB8                 mov     ecx, [ebp+var_4]
.text$mn:00001DBB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00001DC0                 jmp     short loc_1DFF
.text$mn:00001DC2 ; ---------------------------------------------------------------------------
.text$mn:00001DC2
.text$mn:00001DC2 loc_1DC2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00001DC2                 push    0
.text$mn:00001DC4                 mov     eax, [ebp+Size]
.text$mn:00001DC7                 push    eax
.text$mn:00001DC8                 mov     ecx, [ebp+var_4]
.text$mn:00001DCB                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001DD0                 movzx   ecx, al
.text$mn:00001DD3                 test    ecx, ecx
.text$mn:00001DD5                 jz      short loc_1DFC
.text$mn:00001DD7                 mov     edx, [ebp+Size]
.text$mn:00001DDA                 push    edx             ; Size
.text$mn:00001DDB                 mov     eax, [ebp+Src]
.text$mn:00001DDE                 push    eax             ; Src
.text$mn:00001DDF                 mov     ecx, [ebp+var_4]
.text$mn:00001DE2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001DE7                 push    eax             ; Dst
.text$mn:00001DE8                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001DED                 add     esp, 0Ch
.text$mn:00001DF0                 mov     ecx, [ebp+Size]
.text$mn:00001DF3                 push    ecx
.text$mn:00001DF4                 mov     ecx, [ebp+var_4]
.text$mn:00001DF7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001DFC
.text$mn:00001DFC loc_1DFC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00001DFC                 mov     eax, [ebp+var_4]
.text$mn:00001DFF
.text$mn:00001DFF loc_1DFF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00001DFF                 mov     esp, ebp
.text$mn:00001E01                 pop     ebp
.text$mn:00001E02                 retn    8
.text$mn:00001E02 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00001E02
.text$mn:00001E02 ; ---------------------------------------------------------------------------
.text$mn:00001E05                 align 4
.text$mn:00001E05 _text$mn        ends
.text$mn:00001E05
.text$mn:00001E08 ; ===========================================================================
.text$mn:00001E08
.text$mn:00001E08 ; Segment type: Pure code
.text$mn:00001E08 ; Segment permissions: Read/Execute
.text$mn:00001E08 _text$mn        segment para public 'CODE' use32
.text$mn:00001E08                 assume cs:_text$mn
.text$mn:00001E08                 ;org 1E08h
.text$mn:00001E08 ; COMDAT (pick any)
.text$mn:00001E08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E08
.text$mn:00001E08 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E08
.text$mn:00001E08 ; Attributes: bp-based frame
.text$mn:00001E08
.text$mn:00001E08 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:00001E08                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00001E08 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00001E08                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+51p
.text$mn:00001E08
.text$mn:00001E08 var_8           = dword ptr -8
.text$mn:00001E08 var_4           = dword ptr -4
.text$mn:00001E08 arg_0           = dword ptr  8
.text$mn:00001E08 arg_4           = dword ptr  0Ch
.text$mn:00001E08 arg_8           = dword ptr  10h
.text$mn:00001E08
.text$mn:00001E08                 push    ebp
.text$mn:00001E09                 mov     ebp, esp
.text$mn:00001E0B                 sub     esp, 8
.text$mn:00001E0E                 mov     [ebp+var_4], ecx
.text$mn:00001E11                 mov     ecx, [ebp+arg_0]
.text$mn:00001E14                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00001E19                 cmp     eax, [ebp+arg_4]
.text$mn:00001E1C                 jnb     short loc_1E26
.text$mn:00001E1E                 mov     ecx, [ebp+var_4]
.text$mn:00001E21                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00001E26
.text$mn:00001E26 loc_1E26:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:00001E26                 mov     ecx, [ebp+arg_0]
.text$mn:00001E29                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00001E2E                 sub     eax, [ebp+arg_4]
.text$mn:00001E31                 mov     [ebp+var_8], eax
.text$mn:00001E34                 mov     eax, [ebp+arg_8]
.text$mn:00001E37                 cmp     eax, [ebp+var_8]
.text$mn:00001E3A                 jnb     short loc_1E42
.text$mn:00001E3C                 mov     ecx, [ebp+arg_8]
.text$mn:00001E3F                 mov     [ebp+var_8], ecx
.text$mn:00001E42
.text$mn:00001E42 loc_1E42:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:00001E42                 mov     edx, [ebp+var_4]
.text$mn:00001E45                 cmp     edx, [ebp+arg_0]
.text$mn:00001E48                 jnz     short loc_1E69
.text$mn:00001E4A                 mov     eax, [ebp+arg_4]
.text$mn:00001E4D                 add     eax, [ebp+var_8]
.text$mn:00001E50                 push    eax
.text$mn:00001E51                 mov     ecx, [ebp+var_4]
.text$mn:00001E54                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00001E59                 mov     ecx, [ebp+arg_4]
.text$mn:00001E5C                 push    ecx
.text$mn:00001E5D                 push    0
.text$mn:00001E5F                 mov     ecx, [ebp+var_4]
.text$mn:00001E62                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:00001E67                 jmp     short loc_1EAE
.text$mn:00001E69 ; ---------------------------------------------------------------------------
.text$mn:00001E69
.text$mn:00001E69 loc_1E69:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:00001E69                 push    0
.text$mn:00001E6B                 mov     edx, [ebp+var_8]
.text$mn:00001E6E                 push    edx
.text$mn:00001E6F                 mov     ecx, [ebp+var_4]
.text$mn:00001E72                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00001E77                 movzx   eax, al
.text$mn:00001E7A                 test    eax, eax
.text$mn:00001E7C                 jz      short loc_1EAE
.text$mn:00001E7E                 mov     ecx, [ebp+var_8]
.text$mn:00001E81                 push    ecx             ; int
.text$mn:00001E82                 mov     ecx, [ebp+arg_0]
.text$mn:00001E85                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001E8A                 mov     edx, [ebp+arg_4]
.text$mn:00001E8D                 lea     eax, [eax+edx*2]
.text$mn:00001E90                 push    eax             ; Src
.text$mn:00001E91                 mov     ecx, [ebp+var_4]
.text$mn:00001E94                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001E99                 push    eax             ; Dst
.text$mn:00001E9A                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00001E9F                 add     esp, 0Ch
.text$mn:00001EA2                 mov     ecx, [ebp+var_8]
.text$mn:00001EA5                 push    ecx
.text$mn:00001EA6                 mov     ecx, [ebp+var_4]
.text$mn:00001EA9                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00001EAE
.text$mn:00001EAE loc_1EAE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:00001EAE                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:00001EAE                 mov     eax, [ebp+var_4]
.text$mn:00001EB1                 mov     esp, ebp
.text$mn:00001EB3                 pop     ebp
.text$mn:00001EB4                 retn    0Ch
.text$mn:00001EB4 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00001EB4
.text$mn:00001EB4 ; ---------------------------------------------------------------------------
.text$mn:00001EB7                 align 4
.text$mn:00001EB7 _text$mn        ends
.text$mn:00001EB7
.text$mn:00001EB8 ; ===========================================================================
.text$mn:00001EB8
.text$mn:00001EB8 ; Segment type: Pure code
.text$mn:00001EB8 ; Segment permissions: Read/Execute
.text$mn:00001EB8 _text$mn        segment para public 'CODE' use32
.text$mn:00001EB8                 assume cs:_text$mn
.text$mn:00001EB8                 ;org 1EB8h
.text$mn:00001EB8 ; COMDAT (pick any)
.text$mn:00001EB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EB8
.text$mn:00001EB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EB8
.text$mn:00001EB8 ; Attributes: bp-based frame
.text$mn:00001EB8
.text$mn:00001EB8 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:00001EB8                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:00001EB8 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:00001EB8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)+Ep
.text$mn:00001EB8
.text$mn:00001EB8 var_4           = dword ptr -4
.text$mn:00001EB8 Str             = dword ptr  8
.text$mn:00001EB8
.text$mn:00001EB8                 push    ebp
.text$mn:00001EB9                 mov     ebp, esp
.text$mn:00001EBB                 push    ecx
.text$mn:00001EBC                 mov     [ebp+var_4], ecx
.text$mn:00001EBF                 push    490h            ; unsigned int
.text$mn:00001EC4                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001EC9                 mov     eax, [ebp+Str]
.text$mn:00001ECC                 push    eax             ; int
.text$mn:00001ECD                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00001ED2                 add     esp, 0Ch
.text$mn:00001ED5                 mov     ecx, [ebp+Str]
.text$mn:00001ED8                 push    ecx             ; Str
.text$mn:00001ED9                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:00001EDE                 add     esp, 4
.text$mn:00001EE1                 push    eax             ; int
.text$mn:00001EE2                 mov     edx, [ebp+Str]
.text$mn:00001EE5                 push    edx             ; Src
.text$mn:00001EE6                 mov     ecx, [ebp+var_4]
.text$mn:00001EE9                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:00001EEE                 mov     esp, ebp
.text$mn:00001EF0                 pop     ebp
.text$mn:00001EF1                 retn    4
.text$mn:00001EF1 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:00001EF1
.text$mn:00001EF1 _text$mn        ends
.text$mn:00001EF1
.text$mn:00001EF4 ; ===========================================================================
.text$mn:00001EF4
.text$mn:00001EF4 ; Segment type: Pure code
.text$mn:00001EF4 ; Segment permissions: Read/Execute
.text$mn:00001EF4 _text$mn        segment para public 'CODE' use32
.text$mn:00001EF4                 assume cs:_text$mn
.text$mn:00001EF4                 ;org 1EF4h
.text$mn:00001EF4 ; COMDAT (pick any)
.text$mn:00001EF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EF4
.text$mn:00001EF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EF4
.text$mn:00001EF4 ; Attributes: bp-based frame
.text$mn:00001EF4
.text$mn:00001EF4 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:00001EF4                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:00001EF4 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:00001EF4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:00001EF4
.text$mn:00001EF4 var_4           = dword ptr -4
.text$mn:00001EF4 Src             = dword ptr  8
.text$mn:00001EF4 arg_4           = dword ptr  0Ch
.text$mn:00001EF4
.text$mn:00001EF4                 push    ebp
.text$mn:00001EF5                 mov     ebp, esp
.text$mn:00001EF7                 push    ecx
.text$mn:00001EF8                 mov     [ebp+var_4], ecx
.text$mn:00001EFB                 cmp     [ebp+arg_4], 0
.text$mn:00001EFF                 jz      short loc_1F17
.text$mn:00001F01                 push    47Fh            ; unsigned int
.text$mn:00001F06                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001F0B                 mov     eax, [ebp+Src]
.text$mn:00001F0E                 push    eax             ; int
.text$mn:00001F0F                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00001F14                 add     esp, 0Ch
.text$mn:00001F17
.text$mn:00001F17 loc_1F17:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:00001F17                 mov     ecx, [ebp+Src]
.text$mn:00001F1A                 push    ecx
.text$mn:00001F1B                 mov     ecx, [ebp+var_4]
.text$mn:00001F1E                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00001F23                 movzx   edx, al
.text$mn:00001F26                 test    edx, edx
.text$mn:00001F28                 jz      short loc_1F4C
.text$mn:00001F2A                 mov     eax, [ebp+arg_4]
.text$mn:00001F2D                 push    eax
.text$mn:00001F2E                 mov     ecx, [ebp+var_4]
.text$mn:00001F31                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001F36                 mov     ecx, [ebp+Src]
.text$mn:00001F39                 sub     ecx, eax
.text$mn:00001F3B                 sar     ecx, 1
.text$mn:00001F3D                 push    ecx
.text$mn:00001F3E                 mov     edx, [ebp+var_4]
.text$mn:00001F41                 push    edx
.text$mn:00001F42                 mov     ecx, [ebp+var_4]
.text$mn:00001F45                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00001F4A                 jmp     short loc_1F89
.text$mn:00001F4C ; ---------------------------------------------------------------------------
.text$mn:00001F4C
.text$mn:00001F4C loc_1F4C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:00001F4C                 push    0
.text$mn:00001F4E                 mov     eax, [ebp+arg_4]
.text$mn:00001F51                 push    eax
.text$mn:00001F52                 mov     ecx, [ebp+var_4]
.text$mn:00001F55                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00001F5A                 movzx   ecx, al
.text$mn:00001F5D                 test    ecx, ecx
.text$mn:00001F5F                 jz      short loc_1F86
.text$mn:00001F61                 mov     edx, [ebp+arg_4]
.text$mn:00001F64                 push    edx             ; int
.text$mn:00001F65                 mov     eax, [ebp+Src]
.text$mn:00001F68                 push    eax             ; Src
.text$mn:00001F69                 mov     ecx, [ebp+var_4]
.text$mn:00001F6C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001F71                 push    eax             ; Dst
.text$mn:00001F72                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00001F77                 add     esp, 0Ch
.text$mn:00001F7A                 mov     ecx, [ebp+arg_4]
.text$mn:00001F7D                 push    ecx
.text$mn:00001F7E                 mov     ecx, [ebp+var_4]
.text$mn:00001F81                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00001F86
.text$mn:00001F86 loc_1F86:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:00001F86                 mov     eax, [ebp+var_4]
.text$mn:00001F89
.text$mn:00001F89 loc_1F89:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:00001F89                 mov     esp, ebp
.text$mn:00001F8B                 pop     ebp
.text$mn:00001F8C                 retn    8
.text$mn:00001F8C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:00001F8C
.text$mn:00001F8C ; ---------------------------------------------------------------------------
.text$mn:00001F8F                 align 10h
.text$mn:00001F8F _text$mn        ends
.text$mn:00001F8F
.text$mn:00001F90 ; ===========================================================================
.text$mn:00001F90
.text$mn:00001F90 ; Segment type: Pure code
.text$mn:00001F90 ; Segment permissions: Read/Execute
.text$mn:00001F90 _text$mn        segment para public 'CODE' use32
.text$mn:00001F90                 assume cs:_text$mn
.text$mn:00001F90                 ;org 1F90h
.text$mn:00001F90 ; COMDAT (pick any)
.text$mn:00001F90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F90
.text$mn:00001F90 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F90
.text$mn:00001F90 ; Attributes: bp-based frame
.text$mn:00001F90
.text$mn:00001F90 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00001F90                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00001F90 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00001F90                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00001F90
.text$mn:00001F90 arg_0           = dword ptr  8
.text$mn:00001F90 arg_4           = dword ptr  0Ch
.text$mn:00001F90
.text$mn:00001F90                 push    ebp
.text$mn:00001F91                 mov     ebp, esp
.text$mn:00001F93                 mov     eax, [ebp+arg_0]
.text$mn:00001F96                 mov     ecx, [ebp+arg_4]
.text$mn:00001F99                 mov     dl, [ecx]
.text$mn:00001F9B                 mov     [eax], dl
.text$mn:00001F9D                 pop     ebp
.text$mn:00001F9E                 retn
.text$mn:00001F9E ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00001F9E
.text$mn:00001F9E ; ---------------------------------------------------------------------------
.text$mn:00001F9F                 align 10h
.text$mn:00001F9F _text$mn        ends
.text$mn:00001F9F
.text$mn:00001FA0 ; ===========================================================================
.text$mn:00001FA0
.text$mn:00001FA0 ; Segment type: Pure code
.text$mn:00001FA0 ; Segment permissions: Read/Execute
.text$mn:00001FA0 _text$mn        segment para public 'CODE' use32
.text$mn:00001FA0                 assume cs:_text$mn
.text$mn:00001FA0                 ;org 1FA0h
.text$mn:00001FA0 ; COMDAT (pick any)
.text$mn:00001FA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FA0
.text$mn:00001FA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FA0
.text$mn:00001FA0 ; Attributes: bp-based frame
.text$mn:00001FA0
.text$mn:00001FA0 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:00001FA0                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:00001FA0 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:00001FA0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:00001FA0
.text$mn:00001FA0 arg_0           = dword ptr  8
.text$mn:00001FA0 arg_4           = dword ptr  0Ch
.text$mn:00001FA0
.text$mn:00001FA0                 push    ebp
.text$mn:00001FA1                 mov     ebp, esp
.text$mn:00001FA3                 mov     eax, [ebp+arg_0]
.text$mn:00001FA6                 mov     ecx, [ebp+arg_4]
.text$mn:00001FA9                 mov     dx, [ecx]
.text$mn:00001FAC                 mov     [eax], dx
.text$mn:00001FAF                 pop     ebp
.text$mn:00001FB0                 retn
.text$mn:00001FB0 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:00001FB0
.text$mn:00001FB0 ; ---------------------------------------------------------------------------
.text$mn:00001FB1                 align 4
.text$mn:00001FB1 _text$mn        ends
.text$mn:00001FB1
.text$mn:00001FB4 ; ===========================================================================
.text$mn:00001FB4
.text$mn:00001FB4 ; Segment type: Pure code
.text$mn:00001FB4 ; Segment permissions: Read/Execute
.text$mn:00001FB4 _text$mn        segment para public 'CODE' use32
.text$mn:00001FB4                 assume cs:_text$mn
.text$mn:00001FB4                 ;org 1FB4h
.text$mn:00001FB4 ; COMDAT (pick any)
.text$mn:00001FB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FB4
.text$mn:00001FB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FB4
.text$mn:00001FB4 ; Attributes: bp-based frame
.text$mn:00001FB4
.text$mn:00001FB4 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:00001FB4                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:00001FB4 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:00001FB4                                         ; CODE XREF: StatusBar::setText(wchar_t const *,int)+2Dp
.text$mn:00001FB4                                         ; StatusBar::setOwnerDrawText(wchar_t const *)+1Ep
.text$mn:00001FB4
.text$mn:00001FB4 var_4           = dword ptr -4
.text$mn:00001FB4
.text$mn:00001FB4                 push    ebp
.text$mn:00001FB5                 mov     ebp, esp
.text$mn:00001FB7                 push    ecx
.text$mn:00001FB8                 mov     [ebp+var_4], ecx
.text$mn:00001FBB                 mov     ecx, [ebp+var_4]
.text$mn:00001FBE                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001FC3                 mov     esp, ebp
.text$mn:00001FC5                 pop     ebp
.text$mn:00001FC6                 retn
.text$mn:00001FC6 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:00001FC6
.text$mn:00001FC6 ; ---------------------------------------------------------------------------
.text$mn:00001FC7                 align 4
.text$mn:00001FC7 _text$mn        ends
.text$mn:00001FC7
.text$mn:00001FC8 ; ===========================================================================
.text$mn:00001FC8
.text$mn:00001FC8 ; Segment type: Pure code
.text$mn:00001FC8 ; Segment permissions: Read/Execute
.text$mn:00001FC8 _text$mn        segment para public 'CODE' use32
.text$mn:00001FC8                 assume cs:_text$mn
.text$mn:00001FC8                 ;org 1FC8h
.text$mn:00001FC8 ; COMDAT (pick any)
.text$mn:00001FC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FC8
.text$mn:00001FC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FC8
.text$mn:00001FC8 ; Attributes: bp-based frame
.text$mn:00001FC8
.text$mn:00001FC8 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00001FC8                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00001FC8 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001FC8                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00001FC8
.text$mn:00001FC8 var_4           = dword ptr -4
.text$mn:00001FC8
.text$mn:00001FC8                 push    ebp
.text$mn:00001FC9                 mov     ebp, esp
.text$mn:00001FCB                 push    ecx
.text$mn:00001FCC                 mov     [ebp+var_4], ecx
.text$mn:00001FCF                 mov     eax, [ebp+var_4]
.text$mn:00001FD2                 mov     eax, [eax+4]
.text$mn:00001FD5                 mov     esp, ebp
.text$mn:00001FD7                 pop     ebp
.text$mn:00001FD8                 retn
.text$mn:00001FD8 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001FD8
.text$mn:00001FD8 ; ---------------------------------------------------------------------------
.text$mn:00001FD9                 align 4
.text$mn:00001FD9 _text$mn        ends
.text$mn:00001FD9
.text$mn:00001FDC ; ===========================================================================
.text$mn:00001FDC
.text$mn:00001FDC ; Segment type: Pure code
.text$mn:00001FDC ; Segment permissions: Read/Execute
.text$mn:00001FDC _text$mn        segment para public 'CODE' use32
.text$mn:00001FDC                 assume cs:_text$mn
.text$mn:00001FDC                 ;org 1FDCh
.text$mn:00001FDC ; COMDAT (pick any)
.text$mn:00001FDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FDC
.text$mn:00001FDC ; =============== S U B R O U T I N E =======================================
.text$mn:00001FDC
.text$mn:00001FDC ; Attributes: bp-based frame
.text$mn:00001FDC
.text$mn:00001FDC ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00001FDC                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00001FDC ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001FDC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00001FDC                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00001FDC
.text$mn:00001FDC var_4           = dword ptr -4
.text$mn:00001FDC
.text$mn:00001FDC                 push    ebp
.text$mn:00001FDD                 mov     ebp, esp
.text$mn:00001FDF                 push    ecx
.text$mn:00001FE0                 mov     [ebp+var_4], ecx
.text$mn:00001FE3                 mov     eax, [ebp+var_4]
.text$mn:00001FE6                 mov     eax, [eax+4]
.text$mn:00001FE9                 mov     esp, ebp
.text$mn:00001FEB                 pop     ebp
.text$mn:00001FEC                 retn
.text$mn:00001FEC ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001FEC
.text$mn:00001FEC ; ---------------------------------------------------------------------------
.text$mn:00001FED                 align 10h
.text$mn:00001FED _text$mn        ends
.text$mn:00001FED
.text$mn:00001FF0 ; ===========================================================================
.text$mn:00001FF0
.text$mn:00001FF0 ; Segment type: Pure code
.text$mn:00001FF0 ; Segment permissions: Read/Execute
.text$mn:00001FF0 _text$mn        segment para public 'CODE' use32
.text$mn:00001FF0                 assume cs:_text$mn
.text$mn:00001FF0                 ;org 1FF0h
.text$mn:00001FF0 ; COMDAT (pick any)
.text$mn:00001FF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FF0
.text$mn:00001FF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FF0
.text$mn:00001FF0 ; Attributes: bp-based frame
.text$mn:00001FF0
.text$mn:00001FF0 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00001FF0                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001FF0 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00001FF0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00001FF0
.text$mn:00001FF0 var_4           = dword ptr -4
.text$mn:00001FF0 Dst             = dword ptr  8
.text$mn:00001FF0 Src             = dword ptr  0Ch
.text$mn:00001FF0 Size            = dword ptr  10h
.text$mn:00001FF0
.text$mn:00001FF0                 push    ebp
.text$mn:00001FF1                 mov     ebp, esp
.text$mn:00001FF3                 push    ecx
.text$mn:00001FF4                 cmp     [ebp+Size], 0
.text$mn:00001FF8                 jnz     short loc_2002
.text$mn:00001FFA                 mov     eax, [ebp+Dst]
.text$mn:00001FFD                 mov     [ebp+var_4], eax
.text$mn:00002000                 jmp     short loc_2019
.text$mn:00002002 ; ---------------------------------------------------------------------------
.text$mn:00002002
.text$mn:00002002 loc_2002:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00002002                 mov     ecx, [ebp+Size]
.text$mn:00002005                 push    ecx             ; Size
.text$mn:00002006                 mov     edx, [ebp+Src]
.text$mn:00002009                 push    edx             ; Src
.text$mn:0000200A                 mov     eax, [ebp+Dst]
.text$mn:0000200D                 push    eax             ; Dst
.text$mn:0000200E                 call    _memcpy
.text$mn:00002013                 add     esp, 0Ch
.text$mn:00002016                 mov     [ebp+var_4], eax
.text$mn:00002019
.text$mn:00002019 loc_2019:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00002019                 mov     eax, [ebp+var_4]
.text$mn:0000201C                 mov     esp, ebp
.text$mn:0000201E                 pop     ebp
.text$mn:0000201F                 retn
.text$mn:0000201F ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000201F
.text$mn:0000201F _text$mn        ends
.text$mn:0000201F
.text$mn:00002020 ; ===========================================================================
.text$mn:00002020
.text$mn:00002020 ; Segment type: Pure code
.text$mn:00002020 ; Segment permissions: Read/Execute
.text$mn:00002020 _text$mn        segment para public 'CODE' use32
.text$mn:00002020                 assume cs:_text$mn
.text$mn:00002020                 ;org 2020h
.text$mn:00002020 ; COMDAT (pick any)
.text$mn:00002020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002020
.text$mn:00002020 ; =============== S U B R O U T I N E =======================================
.text$mn:00002020
.text$mn:00002020 ; Attributes: bp-based frame
.text$mn:00002020
.text$mn:00002020 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:00002020                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00002020 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00002020                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:00002020                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00002020
.text$mn:00002020 var_4           = dword ptr -4
.text$mn:00002020 Dst             = dword ptr  8
.text$mn:00002020 Src             = dword ptr  0Ch
.text$mn:00002020 arg_8           = dword ptr  10h
.text$mn:00002020
.text$mn:00002020                 push    ebp
.text$mn:00002021                 mov     ebp, esp
.text$mn:00002023                 push    ecx
.text$mn:00002024                 cmp     [ebp+arg_8], 0
.text$mn:00002028                 jnz     short loc_2032
.text$mn:0000202A                 mov     eax, [ebp+Dst]
.text$mn:0000202D                 mov     [ebp+var_4], eax
.text$mn:00002030                 jmp     short loc_2049
.text$mn:00002032 ; ---------------------------------------------------------------------------
.text$mn:00002032
.text$mn:00002032 loc_2032:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00002032                 mov     ecx, [ebp+arg_8]
.text$mn:00002035                 push    ecx             ; int
.text$mn:00002036                 mov     edx, [ebp+Src]
.text$mn:00002039                 push    edx             ; Src
.text$mn:0000203A                 mov     eax, [ebp+Dst]
.text$mn:0000203D                 push    eax             ; Dst
.text$mn:0000203E                 call    _wmemcpy
.text$mn:00002043                 add     esp, 0Ch
.text$mn:00002046                 mov     [ebp+var_4], eax
.text$mn:00002049
.text$mn:00002049 loc_2049:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00002049                 mov     eax, [ebp+var_4]
.text$mn:0000204C                 mov     esp, ebp
.text$mn:0000204E                 pop     ebp
.text$mn:0000204F                 retn
.text$mn:0000204F ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000204F
.text$mn:0000204F _text$mn        ends
.text$mn:0000204F
.text$mn:00002050 ; ===========================================================================
.text$mn:00002050
.text$mn:00002050 ; Segment type: Pure code
.text$mn:00002050 ; Segment permissions: Read/Execute
.text$mn:00002050 _text$mn        segment para public 'CODE' use32
.text$mn:00002050                 assume cs:_text$mn
.text$mn:00002050                 ;org 2050h
.text$mn:00002050 ; COMDAT (pick any)
.text$mn:00002050                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002050
.text$mn:00002050 ; =============== S U B R O U T I N E =======================================
.text$mn:00002050
.text$mn:00002050 ; Attributes: bp-based frame
.text$mn:00002050
.text$mn:00002050 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00002050                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00002050 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00002050                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00002050
.text$mn:00002050 var_4           = dword ptr -4
.text$mn:00002050 arg_0           = dword ptr  8
.text$mn:00002050 arg_4           = dword ptr  0Ch
.text$mn:00002050
.text$mn:00002050                 push    ebp
.text$mn:00002051                 mov     ebp, esp
.text$mn:00002053                 push    ecx
.text$mn:00002054                 mov     [ebp+var_4], ecx
.text$mn:00002057                 mov     eax, [ebp+arg_4]
.text$mn:0000205A                 push    eax             ; int
.text$mn:0000205B                 mov     ecx, [ebp+arg_0]
.text$mn:0000205E                 push    ecx             ; void *
.text$mn:0000205F                 mov     ecx, [ebp+var_4]
.text$mn:00002062                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00002067                 mov     esp, ebp
.text$mn:00002069                 pop     ebp
.text$mn:0000206A                 retn    8
.text$mn:0000206A ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000206A
.text$mn:0000206A ; ---------------------------------------------------------------------------
.text$mn:0000206D                 align 10h
.text$mn:0000206D _text$mn        ends
.text$mn:0000206D
.text$mn:00002070 ; ===========================================================================
.text$mn:00002070
.text$mn:00002070 ; Segment type: Pure code
.text$mn:00002070 ; Segment permissions: Read/Execute
.text$mn:00002070 _text$mn        segment para public 'CODE' use32
.text$mn:00002070                 assume cs:_text$mn
.text$mn:00002070                 ;org 2070h
.text$mn:00002070 ; COMDAT (pick any)
.text$mn:00002070                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002070
.text$mn:00002070 ; =============== S U B R O U T I N E =======================================
.text$mn:00002070
.text$mn:00002070 ; Attributes: bp-based frame
.text$mn:00002070
.text$mn:00002070 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:00002070                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:00002070 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:00002070                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:00002070
.text$mn:00002070 var_4           = dword ptr -4
.text$mn:00002070 arg_0           = dword ptr  8
.text$mn:00002070 arg_4           = dword ptr  0Ch
.text$mn:00002070
.text$mn:00002070                 push    ebp
.text$mn:00002071                 mov     ebp, esp
.text$mn:00002073                 push    ecx
.text$mn:00002074                 mov     [ebp+var_4], ecx
.text$mn:00002077                 mov     eax, [ebp+arg_4]
.text$mn:0000207A                 push    eax             ; int
.text$mn:0000207B                 mov     ecx, [ebp+arg_0]
.text$mn:0000207E                 push    ecx             ; void *
.text$mn:0000207F                 mov     ecx, [ebp+var_4]
.text$mn:00002082                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:00002087                 mov     esp, ebp
.text$mn:00002089                 pop     ebp
.text$mn:0000208A                 retn    8
.text$mn:0000208A ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:0000208A
.text$mn:0000208A ; ---------------------------------------------------------------------------
.text$mn:0000208D                 align 10h
.text$mn:0000208D _text$mn        ends
.text$mn:0000208D
.text$mn:00002090 ; ===========================================================================
.text$mn:00002090
.text$mn:00002090 ; Segment type: Pure code
.text$mn:00002090 ; Segment permissions: Read/Execute
.text$mn:00002090 _text$mn        segment para public 'CODE' use32
.text$mn:00002090                 assume cs:_text$mn
.text$mn:00002090                 ;org 2090h
.text$mn:00002090 ; COMDAT (pick any)
.text$mn:00002090                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002090
.text$mn:00002090 ; =============== S U B R O U T I N E =======================================
.text$mn:00002090
.text$mn:00002090 ; Attributes: bp-based frame
.text$mn:00002090
.text$mn:00002090 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00002090                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00002090 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00002090                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00002090
.text$mn:00002090 var_4           = dword ptr -4
.text$mn:00002090 arg_0           = dword ptr  8
.text$mn:00002090
.text$mn:00002090                 push    ebp
.text$mn:00002091                 mov     ebp, esp
.text$mn:00002093                 push    ecx
.text$mn:00002094                 mov     [ebp+var_4], ecx
.text$mn:00002097                 mov     eax, [ebp+arg_0]
.text$mn:0000209A                 push    eax             ; void *
.text$mn:0000209B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000020A0                 add     esp, 4
.text$mn:000020A3                 mov     esp, ebp
.text$mn:000020A5                 pop     ebp
.text$mn:000020A6                 retn    8
.text$mn:000020A6 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:000020A6
.text$mn:000020A6 ; ---------------------------------------------------------------------------
.text$mn:000020A9                 align 4
.text$mn:000020A9 _text$mn        ends
.text$mn:000020A9
.text$mn:000020AC ; ===========================================================================
.text$mn:000020AC
.text$mn:000020AC ; Segment type: Pure code
.text$mn:000020AC ; Segment permissions: Read/Execute
.text$mn:000020AC _text$mn        segment para public 'CODE' use32
.text$mn:000020AC                 assume cs:_text$mn
.text$mn:000020AC                 ;org 20ACh
.text$mn:000020AC ; COMDAT (pick any)
.text$mn:000020AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020AC
.text$mn:000020AC ; =============== S U B R O U T I N E =======================================
.text$mn:000020AC
.text$mn:000020AC ; Attributes: bp-based frame
.text$mn:000020AC
.text$mn:000020AC ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:000020AC                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:000020AC ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:000020AC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:000020AC
.text$mn:000020AC var_4           = dword ptr -4
.text$mn:000020AC arg_0           = dword ptr  8
.text$mn:000020AC
.text$mn:000020AC                 push    ebp
.text$mn:000020AD                 mov     ebp, esp
.text$mn:000020AF                 push    ecx
.text$mn:000020B0                 mov     [ebp+var_4], ecx
.text$mn:000020B3                 mov     eax, [ebp+arg_0]
.text$mn:000020B6                 push    eax             ; void *
.text$mn:000020B7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000020BC                 add     esp, 4
.text$mn:000020BF                 mov     esp, ebp
.text$mn:000020C1                 pop     ebp
.text$mn:000020C2                 retn    8
.text$mn:000020C2 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:000020C2
.text$mn:000020C2 ; ---------------------------------------------------------------------------
.text$mn:000020C5                 align 4
.text$mn:000020C5 _text$mn        ends
.text$mn:000020C5
.text$mn:000020C8 ; ===========================================================================
.text$mn:000020C8
.text$mn:000020C8 ; Segment type: Pure code
.text$mn:000020C8 ; Segment permissions: Read/Execute
.text$mn:000020C8 _text$mn        segment para public 'CODE' use32
.text$mn:000020C8                 assume cs:_text$mn
.text$mn:000020C8                 ;org 20C8h
.text$mn:000020C8 ; COMDAT (pick any)
.text$mn:000020C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020C8
.text$mn:000020C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000020C8
.text$mn:000020C8 ; Attributes: bp-based frame
.text$mn:000020C8
.text$mn:000020C8 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:000020C8                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:000020C8 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:000020C8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:000020C8
.text$mn:000020C8 var_4           = dword ptr -4
.text$mn:000020C8 arg_0           = dword ptr  8
.text$mn:000020C8
.text$mn:000020C8                 push    ebp
.text$mn:000020C9                 mov     ebp, esp
.text$mn:000020CB                 push    ecx
.text$mn:000020CC                 mov     [ebp+var_4], ecx
.text$mn:000020CF                 mov     eax, [ebp+arg_0]
.text$mn:000020D2                 push    eax             ; void *
.text$mn:000020D3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000020D8                 add     esp, 4
.text$mn:000020DB                 mov     esp, ebp
.text$mn:000020DD                 pop     ebp
.text$mn:000020DE                 retn    8
.text$mn:000020DE ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:000020DE
.text$mn:000020DE ; ---------------------------------------------------------------------------
.text$mn:000020E1                 align 4
.text$mn:000020E1 _text$mn        ends
.text$mn:000020E1
.text$mn:000020E4 ; ===========================================================================
.text$mn:000020E4
.text$mn:000020E4 ; Segment type: Pure code
.text$mn:000020E4 ; Segment permissions: Read/Execute
.text$mn:000020E4 _text$mn        segment para public 'CODE' use32
.text$mn:000020E4                 assume cs:_text$mn
.text$mn:000020E4                 ;org 20E4h
.text$mn:000020E4 ; COMDAT (pick any)
.text$mn:000020E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020E4
.text$mn:000020E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000020E4
.text$mn:000020E4 ; Attributes: bp-based frame
.text$mn:000020E4
.text$mn:000020E4 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:000020E4                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000020E4 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000020E4                                         ; DATA XREF: .rdata:00002E54o
.text$mn:000020E4
.text$mn:000020E4 var_4           = dword ptr -4
.text$mn:000020E4 arg_0           = dword ptr  8
.text$mn:000020E4 arg_4           = dword ptr  0Ch
.text$mn:000020E4
.text$mn:000020E4                 push    ebp
.text$mn:000020E5                 mov     ebp, esp
.text$mn:000020E7                 push    ecx
.text$mn:000020E8                 mov     [ebp+var_4], ecx
.text$mn:000020EB                 mov     eax, [ebp+arg_4]
.text$mn:000020EE                 push    eax             ; int
.text$mn:000020EF                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000020F4                 add     esp, 4
.text$mn:000020F7                 test    eax, eax
.text$mn:000020F9                 jz      short loc_2114
.text$mn:000020FB                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00002100                 push    eax             ; struct std::error_category *
.text$mn:00002101                 mov     ecx, [ebp+arg_4]
.text$mn:00002104                 push    ecx             ; int
.text$mn:00002105                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002108                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000210D                 mov     eax, [ebp+arg_0]
.text$mn:00002110                 jmp     short loc_2129
.text$mn:00002112 ; ---------------------------------------------------------------------------
.text$mn:00002112                 jmp     short loc_2129
.text$mn:00002114 ; ---------------------------------------------------------------------------
.text$mn:00002114
.text$mn:00002114 loc_2114:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00002114                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00002119                 push    eax             ; struct std::error_category *
.text$mn:0000211A                 mov     edx, [ebp+arg_4]
.text$mn:0000211D                 push    edx             ; int
.text$mn:0000211E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002121                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002126                 mov     eax, [ebp+arg_0]
.text$mn:00002129
.text$mn:00002129 loc_2129:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00002129                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00002129                 mov     esp, ebp
.text$mn:0000212B                 pop     ebp
.text$mn:0000212C                 retn    8
.text$mn:0000212C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000212C
.text$mn:0000212C ; ---------------------------------------------------------------------------
.text$mn:0000212F                 align 10h
.text$mn:0000212F _text$mn        ends
.text$mn:0000212F
.text$mn:00002130 ; ===========================================================================
.text$mn:00002130
.text$mn:00002130 ; Segment type: Pure code
.text$mn:00002130 ; Segment permissions: Read/Execute
.text$mn:00002130 _text$mn        segment para public 'CODE' use32
.text$mn:00002130                 assume cs:_text$mn
.text$mn:00002130                 ;org 2130h
.text$mn:00002130 ; COMDAT (pick any)
.text$mn:00002130                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002130
.text$mn:00002130 ; =============== S U B R O U T I N E =======================================
.text$mn:00002130
.text$mn:00002130 ; Attributes: bp-based frame
.text$mn:00002130
.text$mn:00002130 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00002130                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002130 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002130                                         ; DATA XREF: .rdata:00002DC4o
.text$mn:00002130                                         ; .rdata:00002DE0o ...
.text$mn:00002130
.text$mn:00002130 var_4           = dword ptr -4
.text$mn:00002130 arg_0           = dword ptr  8
.text$mn:00002130 arg_4           = dword ptr  0Ch
.text$mn:00002130
.text$mn:00002130                 push    ebp
.text$mn:00002131                 mov     ebp, esp
.text$mn:00002133                 push    ecx
.text$mn:00002134                 mov     [ebp+var_4], ecx
.text$mn:00002137                 mov     eax, [ebp+var_4]
.text$mn:0000213A                 push    eax             ; struct std::error_category *
.text$mn:0000213B                 mov     ecx, [ebp+arg_4]
.text$mn:0000213E                 push    ecx             ; int
.text$mn:0000213F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002142                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002147                 mov     eax, [ebp+arg_0]
.text$mn:0000214A                 mov     esp, ebp
.text$mn:0000214C                 pop     ebp
.text$mn:0000214D                 retn    8
.text$mn:0000214D ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000214D
.text$mn:0000214D _text$mn        ends
.text$mn:0000214D
.text$mn:00002150 ; ===========================================================================
.text$mn:00002150
.text$mn:00002150 ; Segment type: Pure code
.text$mn:00002150 ; Segment permissions: Read/Execute
.text$mn:00002150 _text$mn        segment para public 'CODE' use32
.text$mn:00002150                 assume cs:_text$mn
.text$mn:00002150                 ;org 2150h
.text$mn:00002150 ; COMDAT (pick any)
.text$mn:00002150                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002150
.text$mn:00002150 ; =============== S U B R O U T I N E =======================================
.text$mn:00002150
.text$mn:00002150 ; Attributes: bp-based frame
.text$mn:00002150
.text$mn:00002150 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00002150                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00002150 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00002150                                         ; DATA XREF: .rdata:00002DC8o
.text$mn:00002150                                         ; .rdata:00002DE4o ...
.text$mn:00002150
.text$mn:00002150 var_8           = dword ptr -8
.text$mn:00002150 var_4           = dword ptr -4
.text$mn:00002150 arg_0           = dword ptr  8
.text$mn:00002150 arg_4           = dword ptr  0Ch
.text$mn:00002150
.text$mn:00002150                 push    ebp
.text$mn:00002151                 mov     ebp, esp
.text$mn:00002153                 sub     esp, 8
.text$mn:00002156                 mov     [ebp+var_8], ecx
.text$mn:00002159                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000215C                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00002161                 push    eax
.text$mn:00002162                 mov     ecx, [ebp+var_8]
.text$mn:00002165                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000216A                 movzx   eax, al
.text$mn:0000216D                 test    eax, eax
.text$mn:0000216F                 jz      short loc_2187
.text$mn:00002171                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002174                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00002179                 cmp     eax, [ebp+arg_4]
.text$mn:0000217C                 jnz     short loc_2187
.text$mn:0000217E                 mov     [ebp+var_4], 1
.text$mn:00002185                 jmp     short loc_218E
.text$mn:00002187 ; ---------------------------------------------------------------------------
.text$mn:00002187
.text$mn:00002187 loc_2187:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00002187                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00002187                 mov     [ebp+var_4], 0
.text$mn:0000218E
.text$mn:0000218E loc_218E:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:0000218E                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002191                 mov     esp, ebp
.text$mn:00002193                 pop     ebp
.text$mn:00002194                 retn    8
.text$mn:00002194 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00002194
.text$mn:00002194 ; ---------------------------------------------------------------------------
.text$mn:00002197                 align 4
.text$mn:00002197 _text$mn        ends
.text$mn:00002197
.text$mn:00002198 ; ===========================================================================
.text$mn:00002198
.text$mn:00002198 ; Segment type: Pure code
.text$mn:00002198 ; Segment permissions: Read/Execute
.text$mn:00002198 _text$mn        segment para public 'CODE' use32
.text$mn:00002198                 assume cs:_text$mn
.text$mn:00002198                 ;org 2198h
.text$mn:00002198 ; COMDAT (pick any)
.text$mn:00002198                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002198
.text$mn:00002198 ; =============== S U B R O U T I N E =======================================
.text$mn:00002198
.text$mn:00002198 ; Attributes: bp-based frame
.text$mn:00002198
.text$mn:00002198 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00002198                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00002198 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00002198                                         ; DATA XREF: .rdata:00002DCCo
.text$mn:00002198                                         ; .rdata:00002DE8o ...
.text$mn:00002198
.text$mn:00002198 var_C           = byte ptr -0Ch
.text$mn:00002198 var_4           = dword ptr -4
.text$mn:00002198 arg_0           = dword ptr  8
.text$mn:00002198 arg_4           = dword ptr  0Ch
.text$mn:00002198
.text$mn:00002198                 push    ebp
.text$mn:00002199                 mov     ebp, esp
.text$mn:0000219B                 sub     esp, 0Ch
.text$mn:0000219E                 mov     [ebp+var_4], ecx
.text$mn:000021A1                 mov     eax, [ebp+arg_4]
.text$mn:000021A4                 push    eax             ; std::error_condition *
.text$mn:000021A5                 mov     ecx, [ebp+arg_0]
.text$mn:000021A8                 push    ecx
.text$mn:000021A9                 lea     edx, [ebp+var_C]
.text$mn:000021AC                 push    edx
.text$mn:000021AD                 mov     eax, [ebp+var_4]
.text$mn:000021B0                 mov     edx, [eax]
.text$mn:000021B2                 mov     ecx, [ebp+var_4]
.text$mn:000021B5                 mov     eax, [edx+0Ch]
.text$mn:000021B8                 call    eax
.text$mn:000021BA                 mov     ecx, eax
.text$mn:000021BC                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:000021C1                 mov     esp, ebp
.text$mn:000021C3                 pop     ebp
.text$mn:000021C4                 retn    8
.text$mn:000021C4 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:000021C4
.text$mn:000021C4 ; ---------------------------------------------------------------------------
.text$mn:000021C7                 align 4
.text$mn:000021C7 _text$mn        ends
.text$mn:000021C7
.text$mn:000021C8 ; ===========================================================================
.text$mn:000021C8
.text$mn:000021C8 ; Segment type: Pure code
.text$mn:000021C8 ; Segment permissions: Read/Execute
.text$mn:000021C8 _text$mn        segment para public 'CODE' use32
.text$mn:000021C8                 assume cs:_text$mn
.text$mn:000021C8                 ;org 21C8h
.text$mn:000021C8 ; COMDAT (pick any)
.text$mn:000021C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021C8
.text$mn:000021C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000021C8
.text$mn:000021C8 ; Attributes: bp-based frame
.text$mn:000021C8
.text$mn:000021C8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:000021C8                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:000021C8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000021C8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:000021C8
.text$mn:000021C8 var_4           = dword ptr -4
.text$mn:000021C8 arg_0           = dword ptr  8
.text$mn:000021C8
.text$mn:000021C8                 push    ebp
.text$mn:000021C9                 mov     ebp, esp
.text$mn:000021CB                 push    ecx
.text$mn:000021CC                 mov     [ebp+var_4], ecx
.text$mn:000021CF                 mov     eax, [ebp+var_4]
.text$mn:000021D2                 mov     ecx, [eax+14h]
.text$mn:000021D5                 cmp     ecx, [ebp+arg_0]
.text$mn:000021D8                 jnb     short loc_21E2
.text$mn:000021DA                 mov     ecx, [ebp+var_4]
.text$mn:000021DD                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000021E2
.text$mn:000021E2 loc_21E2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:000021E2                 mov     edx, [ebp+arg_0]
.text$mn:000021E5                 push    edx
.text$mn:000021E6                 mov     ecx, [ebp+var_4]
.text$mn:000021E9                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000021EE                 mov     eax, [ebp+var_4]
.text$mn:000021F1                 mov     esp, ebp
.text$mn:000021F3                 pop     ebp
.text$mn:000021F4                 retn    4
.text$mn:000021F4 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:000021F4
.text$mn:000021F4 ; ---------------------------------------------------------------------------
.text$mn:000021F7                 align 4
.text$mn:000021F7 _text$mn        ends
.text$mn:000021F7
.text$mn:000021F8 ; ===========================================================================
.text$mn:000021F8
.text$mn:000021F8 ; Segment type: Pure code
.text$mn:000021F8 ; Segment permissions: Read/Execute
.text$mn:000021F8 _text$mn        segment para public 'CODE' use32
.text$mn:000021F8                 assume cs:_text$mn
.text$mn:000021F8                 ;org 21F8h
.text$mn:000021F8 ; COMDAT (pick any)
.text$mn:000021F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021F8
.text$mn:000021F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000021F8
.text$mn:000021F8 ; Attributes: bp-based frame
.text$mn:000021F8
.text$mn:000021F8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:000021F8                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:000021F8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:000021F8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:000021F8
.text$mn:000021F8 var_C           = dword ptr -0Ch
.text$mn:000021F8 Dst             = dword ptr -8
.text$mn:000021F8 var_4           = dword ptr -4
.text$mn:000021F8 arg_0           = dword ptr  8
.text$mn:000021F8 arg_4           = dword ptr  0Ch
.text$mn:000021F8
.text$mn:000021F8                 push    ebp
.text$mn:000021F9                 mov     ebp, esp
.text$mn:000021FB                 sub     esp, 0Ch
.text$mn:000021FE                 mov     [ebp+var_4], ecx
.text$mn:00002201                 mov     eax, [ebp+var_4]
.text$mn:00002204                 mov     ecx, [eax+14h]
.text$mn:00002207                 cmp     ecx, [ebp+arg_0]
.text$mn:0000220A                 jnb     short loc_2214
.text$mn:0000220C                 mov     ecx, [ebp+var_4]
.text$mn:0000220F                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002214
.text$mn:00002214 loc_2214:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00002214                 mov     edx, [ebp+var_4]
.text$mn:00002217                 mov     eax, [edx+14h]
.text$mn:0000221A                 sub     eax, [ebp+arg_0]
.text$mn:0000221D                 cmp     eax, [ebp+arg_4]
.text$mn:00002220                 ja      short loc_2230
.text$mn:00002222                 mov     ecx, [ebp+arg_0]
.text$mn:00002225                 push    ecx
.text$mn:00002226                 mov     ecx, [ebp+var_4]
.text$mn:00002229                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000222E                 jmp     short loc_2276
.text$mn:00002230 ; ---------------------------------------------------------------------------
.text$mn:00002230
.text$mn:00002230 loc_2230:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00002230                 cmp     [ebp+arg_4], 0
.text$mn:00002234                 jbe     short loc_2276
.text$mn:00002236                 mov     ecx, [ebp+var_4]
.text$mn:00002239                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000223E                 add     eax, [ebp+arg_0]
.text$mn:00002241                 mov     [ebp+Dst], eax
.text$mn:00002244                 mov     edx, [ebp+var_4]
.text$mn:00002247                 mov     eax, [edx+14h]
.text$mn:0000224A                 sub     eax, [ebp+arg_4]
.text$mn:0000224D                 mov     [ebp+var_C], eax
.text$mn:00002250                 mov     ecx, [ebp+var_C]
.text$mn:00002253                 sub     ecx, [ebp+arg_0]
.text$mn:00002256                 push    ecx             ; Size
.text$mn:00002257                 mov     edx, [ebp+Dst]
.text$mn:0000225A                 add     edx, [ebp+arg_4]
.text$mn:0000225D                 push    edx             ; Src
.text$mn:0000225E                 mov     eax, [ebp+Dst]
.text$mn:00002261                 push    eax             ; Dst
.text$mn:00002262                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00002267                 add     esp, 0Ch
.text$mn:0000226A                 mov     ecx, [ebp+var_C]
.text$mn:0000226D                 push    ecx
.text$mn:0000226E                 mov     ecx, [ebp+var_4]
.text$mn:00002271                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002276
.text$mn:00002276 loc_2276:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00002276                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00002276                 mov     eax, [ebp+var_4]
.text$mn:00002279                 mov     esp, ebp
.text$mn:0000227B                 pop     ebp
.text$mn:0000227C                 retn    8
.text$mn:0000227C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:0000227C
.text$mn:0000227C ; ---------------------------------------------------------------------------
.text$mn:0000227F                 align 10h
.text$mn:0000227F _text$mn        ends
.text$mn:0000227F
.text$mn:00002280 ; ===========================================================================
.text$mn:00002280
.text$mn:00002280 ; Segment type: Pure code
.text$mn:00002280 ; Segment permissions: Read/Execute
.text$mn:00002280 _text$mn        segment para public 'CODE' use32
.text$mn:00002280                 assume cs:_text$mn
.text$mn:00002280                 ;org 2280h
.text$mn:00002280 ; COMDAT (pick any)
.text$mn:00002280                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002280
.text$mn:00002280 ; =============== S U B R O U T I N E =======================================
.text$mn:00002280
.text$mn:00002280 ; Attributes: bp-based frame
.text$mn:00002280
.text$mn:00002280 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:00002280                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:00002280 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00002280                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:00002280
.text$mn:00002280 var_4           = dword ptr -4
.text$mn:00002280 arg_0           = dword ptr  8
.text$mn:00002280
.text$mn:00002280                 push    ebp
.text$mn:00002281                 mov     ebp, esp
.text$mn:00002283                 push    ecx
.text$mn:00002284                 mov     [ebp+var_4], ecx
.text$mn:00002287                 mov     eax, [ebp+var_4]
.text$mn:0000228A                 mov     ecx, [eax+14h]
.text$mn:0000228D                 cmp     ecx, [ebp+arg_0]
.text$mn:00002290                 jnb     short loc_229A
.text$mn:00002292                 mov     ecx, [ebp+var_4]
.text$mn:00002295                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000229A
.text$mn:0000229A loc_229A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:0000229A                 mov     edx, [ebp+arg_0]
.text$mn:0000229D                 push    edx
.text$mn:0000229E                 mov     ecx, [ebp+var_4]
.text$mn:000022A1                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000022A6                 mov     eax, [ebp+var_4]
.text$mn:000022A9                 mov     esp, ebp
.text$mn:000022AB                 pop     ebp
.text$mn:000022AC                 retn    4
.text$mn:000022AC ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:000022AC
.text$mn:000022AC ; ---------------------------------------------------------------------------
.text$mn:000022AF                 align 10h
.text$mn:000022AF _text$mn        ends
.text$mn:000022AF
.text$mn:000022B0 ; ===========================================================================
.text$mn:000022B0
.text$mn:000022B0 ; Segment type: Pure code
.text$mn:000022B0 ; Segment permissions: Read/Execute
.text$mn:000022B0 _text$mn        segment para public 'CODE' use32
.text$mn:000022B0                 assume cs:_text$mn
.text$mn:000022B0                 ;org 22B0h
.text$mn:000022B0 ; COMDAT (pick any)
.text$mn:000022B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022B0
.text$mn:000022B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022B0
.text$mn:000022B0 ; Attributes: bp-based frame
.text$mn:000022B0
.text$mn:000022B0 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:000022B0                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:000022B0 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:000022B0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:000022B0
.text$mn:000022B0 var_C           = dword ptr -0Ch
.text$mn:000022B0 Dst             = dword ptr -8
.text$mn:000022B0 var_4           = dword ptr -4
.text$mn:000022B0 arg_0           = dword ptr  8
.text$mn:000022B0 arg_4           = dword ptr  0Ch
.text$mn:000022B0
.text$mn:000022B0                 push    ebp
.text$mn:000022B1                 mov     ebp, esp
.text$mn:000022B3                 sub     esp, 0Ch
.text$mn:000022B6                 mov     [ebp+var_4], ecx
.text$mn:000022B9                 mov     eax, [ebp+var_4]
.text$mn:000022BC                 mov     ecx, [eax+14h]
.text$mn:000022BF                 cmp     ecx, [ebp+arg_0]
.text$mn:000022C2                 jnb     short loc_22CC
.text$mn:000022C4                 mov     ecx, [ebp+var_4]
.text$mn:000022C7                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:000022CC
.text$mn:000022CC loc_22CC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:000022CC                 mov     edx, [ebp+var_4]
.text$mn:000022CF                 mov     eax, [edx+14h]
.text$mn:000022D2                 sub     eax, [ebp+arg_0]
.text$mn:000022D5                 cmp     eax, [ebp+arg_4]
.text$mn:000022D8                 ja      short loc_22E8
.text$mn:000022DA                 mov     ecx, [ebp+arg_0]
.text$mn:000022DD                 push    ecx
.text$mn:000022DE                 mov     ecx, [ebp+var_4]
.text$mn:000022E1                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000022E6                 jmp     short loc_2334
.text$mn:000022E8 ; ---------------------------------------------------------------------------
.text$mn:000022E8
.text$mn:000022E8 loc_22E8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:000022E8                 cmp     [ebp+arg_4], 0
.text$mn:000022EC                 jbe     short loc_2334
.text$mn:000022EE                 mov     ecx, [ebp+var_4]
.text$mn:000022F1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000022F6                 mov     edx, [ebp+arg_0]
.text$mn:000022F9                 lea     eax, [eax+edx*2]
.text$mn:000022FC                 mov     [ebp+Dst], eax
.text$mn:000022FF                 mov     ecx, [ebp+var_4]
.text$mn:00002302                 mov     edx, [ecx+14h]
.text$mn:00002305                 sub     edx, [ebp+arg_4]
.text$mn:00002308                 mov     [ebp+var_C], edx
.text$mn:0000230B                 mov     eax, [ebp+var_C]
.text$mn:0000230E                 sub     eax, [ebp+arg_0]
.text$mn:00002311                 push    eax             ; int
.text$mn:00002312                 mov     ecx, [ebp+arg_4]
.text$mn:00002315                 mov     edx, [ebp+Dst]
.text$mn:00002318                 lea     eax, [edx+ecx*2]
.text$mn:0000231B                 push    eax             ; Src
.text$mn:0000231C                 mov     ecx, [ebp+Dst]
.text$mn:0000231F                 push    ecx             ; Dst
.text$mn:00002320                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00002325                 add     esp, 0Ch
.text$mn:00002328                 mov     edx, [ebp+var_C]
.text$mn:0000232B                 push    edx
.text$mn:0000232C                 mov     ecx, [ebp+var_4]
.text$mn:0000232F                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00002334
.text$mn:00002334 loc_2334:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:00002334                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:00002334                 mov     eax, [ebp+var_4]
.text$mn:00002337                 mov     esp, ebp
.text$mn:00002339                 pop     ebp
.text$mn:0000233A                 retn    8
.text$mn:0000233A ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:0000233A
.text$mn:0000233A ; ---------------------------------------------------------------------------
.text$mn:0000233D                 align 10h
.text$mn:0000233D _text$mn        ends
.text$mn:0000233D
.text$mn:00002340 ; ===========================================================================
.text$mn:00002340
.text$mn:00002340 ; Segment type: Pure code
.text$mn:00002340 ; Segment permissions: Read/Execute
.text$mn:00002340 _text$mn        segment para public 'CODE' use32
.text$mn:00002340                 assume cs:_text$mn
.text$mn:00002340                 ;org 2340h
.text$mn:00002340 ; COMDAT (pick any)
.text$mn:00002340                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002340
.text$mn:00002340 ; =============== S U B R O U T I N E =======================================
.text$mn:00002340
.text$mn:00002340 ; Attributes: bp-based frame
.text$mn:00002340
.text$mn:00002340 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00002340                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00002340 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002340                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00002340                 push    ebp
.text$mn:00002341                 mov     ebp, esp
.text$mn:00002343                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00002348                 pop     ebp
.text$mn:00002349                 retn
.text$mn:00002349 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002349
.text$mn:00002349 ; ---------------------------------------------------------------------------
.text$mn:0000234A                 align 4
.text$mn:0000234A _text$mn        ends
.text$mn:0000234A
.text$mn:0000234C ; ===========================================================================
.text$mn:0000234C
.text$mn:0000234C ; Segment type: Pure code
.text$mn:0000234C ; Segment permissions: Read/Execute
.text$mn:0000234C _text$mn        segment para public 'CODE' use32
.text$mn:0000234C                 assume cs:_text$mn
.text$mn:0000234C                 ;org 234Ch
.text$mn:0000234C ; COMDAT (pick any)
.text$mn:0000234C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000234C
.text$mn:0000234C ; =============== S U B R O U T I N E =======================================
.text$mn:0000234C
.text$mn:0000234C ; Attributes: bp-based frame
.text$mn:0000234C
.text$mn:0000234C ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:0000234C                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:0000234C ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:0000234C                                         ; CODE XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+1Ep
.text$mn:0000234C
.text$mn:0000234C var_4           = dword ptr -4
.text$mn:0000234C arg_0           = dword ptr  8
.text$mn:0000234C arg_4           = dword ptr  0Ch
.text$mn:0000234C
.text$mn:0000234C                 push    ebp
.text$mn:0000234D                 mov     ebp, esp
.text$mn:0000234F                 push    ecx
.text$mn:00002350                 mov     [ebp+var_4], ecx
.text$mn:00002353                 mov     eax, [ebp+var_4]
.text$mn:00002356                 mov     ecx, [ebp+arg_0]
.text$mn:00002359                 mov     [eax+4], ecx
.text$mn:0000235C                 mov     edx, [ebp+var_4]
.text$mn:0000235F                 mov     eax, [ebp+arg_4]
.text$mn:00002362                 mov     [edx+8], eax
.text$mn:00002365                 mov     esp, ebp
.text$mn:00002367                 pop     ebp
.text$mn:00002368                 retn    8
.text$mn:00002368 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:00002368
.text$mn:00002368 ; ---------------------------------------------------------------------------
.text$mn:0000236B                 align 4
.text$mn:0000236B _text$mn        ends
.text$mn:0000236B
.text$mn:0000236C ; ===========================================================================
.text$mn:0000236C
.text$mn:0000236C ; Segment type: Pure code
.text$mn:0000236C ; Segment permissions: Read/Execute
.text$mn:0000236C _text$mn        segment para public 'CODE' use32
.text$mn:0000236C                 assume cs:_text$mn
.text$mn:0000236C                 ;org 236Ch
.text$mn:0000236C ; COMDAT (pick any)
.text$mn:0000236C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000236C
.text$mn:0000236C ; =============== S U B R O U T I N E =======================================
.text$mn:0000236C
.text$mn:0000236C ; Attributes: bp-based frame
.text$mn:0000236C
.text$mn:0000236C ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:0000236C                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:0000236C ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:0000236C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:0000236C
.text$mn:0000236C var_4           = dword ptr -4
.text$mn:0000236C Str             = dword ptr  8
.text$mn:0000236C
.text$mn:0000236C                 push    ebp
.text$mn:0000236D                 mov     ebp, esp
.text$mn:0000236F                 push    ecx
.text$mn:00002370                 mov     eax, [ebp+Str]
.text$mn:00002373                 movsx   ecx, byte ptr [eax]
.text$mn:00002376                 test    ecx, ecx
.text$mn:00002378                 jnz     short loc_2383
.text$mn:0000237A                 mov     [ebp+var_4], 0
.text$mn:00002381                 jmp     short loc_2392
.text$mn:00002383 ; ---------------------------------------------------------------------------
.text$mn:00002383
.text$mn:00002383 loc_2383:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00002383                 mov     edx, [ebp+Str]
.text$mn:00002386                 push    edx             ; Str
.text$mn:00002387                 call    _strlen
.text$mn:0000238C                 add     esp, 4
.text$mn:0000238F                 mov     [ebp+var_4], eax
.text$mn:00002392
.text$mn:00002392 loc_2392:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00002392                 mov     eax, [ebp+var_4]
.text$mn:00002395                 mov     esp, ebp
.text$mn:00002397                 pop     ebp
.text$mn:00002398                 retn
.text$mn:00002398 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00002398
.text$mn:00002398 ; ---------------------------------------------------------------------------
.text$mn:00002399                 align 4
.text$mn:00002399 _text$mn        ends
.text$mn:00002399
.text$mn:0000239C ; ===========================================================================
.text$mn:0000239C
.text$mn:0000239C ; Segment type: Pure code
.text$mn:0000239C ; Segment permissions: Read/Execute
.text$mn:0000239C _text$mn        segment para public 'CODE' use32
.text$mn:0000239C                 assume cs:_text$mn
.text$mn:0000239C                 ;org 239Ch
.text$mn:0000239C ; COMDAT (pick any)
.text$mn:0000239C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000239C
.text$mn:0000239C ; =============== S U B R O U T I N E =======================================
.text$mn:0000239C
.text$mn:0000239C ; Attributes: bp-based frame
.text$mn:0000239C
.text$mn:0000239C ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:0000239C                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:0000239C ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:0000239C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p
.text$mn:0000239C
.text$mn:0000239C var_4           = dword ptr -4
.text$mn:0000239C Str             = dword ptr  8
.text$mn:0000239C
.text$mn:0000239C                 push    ebp
.text$mn:0000239D                 mov     ebp, esp
.text$mn:0000239F                 push    ecx
.text$mn:000023A0                 mov     eax, [ebp+Str]
.text$mn:000023A3                 movzx   ecx, word ptr [eax]
.text$mn:000023A6                 test    ecx, ecx
.text$mn:000023A8                 jnz     short loc_23B3
.text$mn:000023AA                 mov     [ebp+var_4], 0
.text$mn:000023B1                 jmp     short loc_23C2
.text$mn:000023B3 ; ---------------------------------------------------------------------------
.text$mn:000023B3
.text$mn:000023B3 loc_23B3:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:000023B3                 mov     edx, [ebp+Str]
.text$mn:000023B6                 push    edx             ; Str
.text$mn:000023B7                 call    _wcslen
.text$mn:000023BC                 add     esp, 4
.text$mn:000023BF                 mov     [ebp+var_4], eax
.text$mn:000023C2
.text$mn:000023C2 loc_23C2:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:000023C2                 mov     eax, [ebp+var_4]
.text$mn:000023C5                 mov     esp, ebp
.text$mn:000023C7                 pop     ebp
.text$mn:000023C8                 retn
.text$mn:000023C8 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:000023C8
.text$mn:000023C8 ; ---------------------------------------------------------------------------
.text$mn:000023C9                 align 4
.text$mn:000023C9 _text$mn        ends
.text$mn:000023C9
.text$mn:000023CC ; ===========================================================================
.text$mn:000023CC
.text$mn:000023CC ; Segment type: Pure code
.text$mn:000023CC ; Segment permissions: Read/Execute
.text$mn:000023CC _text$mn        segment para public 'CODE' use32
.text$mn:000023CC                 assume cs:_text$mn
.text$mn:000023CC                 ;org 23CCh
.text$mn:000023CC ; COMDAT (pick any)
.text$mn:000023CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023CC
.text$mn:000023CC ; =============== S U B R O U T I N E =======================================
.text$mn:000023CC
.text$mn:000023CC ; Attributes: bp-based frame
.text$mn:000023CC
.text$mn:000023CC ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:000023CC                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:000023CC ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:000023CC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:000023CC
.text$mn:000023CC var_4           = dword ptr -4
.text$mn:000023CC
.text$mn:000023CC                 push    ebp
.text$mn:000023CD                 mov     ebp, esp
.text$mn:000023CF                 push    ecx
.text$mn:000023D0                 mov     [ebp+var_4], ecx
.text$mn:000023D3                 mov     eax, [ebp+var_4]
.text$mn:000023D6                 push    eax
.text$mn:000023D7                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:000023DC                 add     esp, 4
.text$mn:000023DF                 mov     esp, ebp
.text$mn:000023E1                 pop     ebp
.text$mn:000023E2                 retn
.text$mn:000023E2 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:000023E2
.text$mn:000023E2 ; ---------------------------------------------------------------------------
.text$mn:000023E3                 align 4
.text$mn:000023E3 _text$mn        ends
.text$mn:000023E3
.text$mn:000023E4 ; ===========================================================================
.text$mn:000023E4
.text$mn:000023E4 ; Segment type: Pure code
.text$mn:000023E4 ; Segment permissions: Read/Execute
.text$mn:000023E4 _text$mn        segment para public 'CODE' use32
.text$mn:000023E4                 assume cs:_text$mn
.text$mn:000023E4                 ;org 23E4h
.text$mn:000023E4 ; COMDAT (pick any)
.text$mn:000023E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023E4
.text$mn:000023E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023E4
.text$mn:000023E4 ; Attributes: bp-based frame
.text$mn:000023E4
.text$mn:000023E4 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:000023E4                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:000023E4 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:000023E4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:000023E4
.text$mn:000023E4 var_4           = dword ptr -4
.text$mn:000023E4
.text$mn:000023E4                 push    ebp
.text$mn:000023E5                 mov     ebp, esp
.text$mn:000023E7                 push    ecx
.text$mn:000023E8                 mov     [ebp+var_4], ecx
.text$mn:000023EB                 mov     eax, [ebp+var_4]
.text$mn:000023EE                 push    eax
.text$mn:000023EF                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:000023F4                 add     esp, 4
.text$mn:000023F7                 mov     esp, ebp
.text$mn:000023F9                 pop     ebp
.text$mn:000023FA                 retn
.text$mn:000023FA ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:000023FA
.text$mn:000023FA ; ---------------------------------------------------------------------------
.text$mn:000023FB                 align 4
.text$mn:000023FB _text$mn        ends
.text$mn:000023FB
.text$mn:000023FC ; ===========================================================================
.text$mn:000023FC
.text$mn:000023FC ; Segment type: Pure code
.text$mn:000023FC ; Segment permissions: Read/Execute
.text$mn:000023FC _text$mn        segment para public 'CODE' use32
.text$mn:000023FC                 assume cs:_text$mn
.text$mn:000023FC                 ;org 23FCh
.text$mn:000023FC ; COMDAT (pick any)
.text$mn:000023FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023FC
.text$mn:000023FC ; =============== S U B R O U T I N E =======================================
.text$mn:000023FC
.text$mn:000023FC ; Attributes: bp-based frame
.text$mn:000023FC
.text$mn:000023FC ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:000023FC                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:000023FC ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:000023FC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:000023FC
.text$mn:000023FC var_4           = dword ptr -4
.text$mn:000023FC
.text$mn:000023FC                 push    ebp
.text$mn:000023FD                 mov     ebp, esp
.text$mn:000023FF                 push    ecx
.text$mn:00002400                 mov     [ebp+var_4], ecx
.text$mn:00002403                 or      eax, 0FFFFFFFFh
.text$mn:00002406                 mov     esp, ebp
.text$mn:00002408                 pop     ebp
.text$mn:00002409                 retn
.text$mn:00002409 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00002409
.text$mn:00002409 ; ---------------------------------------------------------------------------
.text$mn:0000240A                 align 4
.text$mn:0000240A _text$mn        ends
.text$mn:0000240A
.text$mn:0000240C ; ===========================================================================
.text$mn:0000240C
.text$mn:0000240C ; Segment type: Pure code
.text$mn:0000240C ; Segment permissions: Read/Execute
.text$mn:0000240C _text$mn        segment para public 'CODE' use32
.text$mn:0000240C                 assume cs:_text$mn
.text$mn:0000240C                 ;org 240Ch
.text$mn:0000240C ; COMDAT (pick any)
.text$mn:0000240C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000240C
.text$mn:0000240C ; =============== S U B R O U T I N E =======================================
.text$mn:0000240C
.text$mn:0000240C ; Attributes: bp-based frame
.text$mn:0000240C
.text$mn:0000240C ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:0000240C                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:0000240C ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:0000240C                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:0000240C
.text$mn:0000240C var_4           = dword ptr -4
.text$mn:0000240C
.text$mn:0000240C                 push    ebp
.text$mn:0000240D                 mov     ebp, esp
.text$mn:0000240F                 push    ecx
.text$mn:00002410                 mov     [ebp+var_4], ecx
.text$mn:00002413                 mov     eax, 7FFFFFFFh
.text$mn:00002418                 mov     esp, ebp
.text$mn:0000241A                 pop     ebp
.text$mn:0000241B                 retn
.text$mn:0000241B ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:0000241B
.text$mn:0000241B _text$mn        ends
.text$mn:0000241B
.text$mn:0000241C ; ===========================================================================
.text$mn:0000241C
.text$mn:0000241C ; Segment type: Pure code
.text$mn:0000241C ; Segment permissions: Read/Execute
.text$mn:0000241C _text$mn        segment para public 'CODE' use32
.text$mn:0000241C                 assume cs:_text$mn
.text$mn:0000241C                 ;org 241Ch
.text$mn:0000241C ; COMDAT (pick any)
.text$mn:0000241C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000241C
.text$mn:0000241C ; =============== S U B R O U T I N E =======================================
.text$mn:0000241C
.text$mn:0000241C ; Attributes: bp-based frame
.text$mn:0000241C
.text$mn:0000241C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:0000241C                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:0000241C ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:0000241C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:0000241C
.text$mn:0000241C arg_0           = dword ptr  8
.text$mn:0000241C
.text$mn:0000241C                 push    ebp
.text$mn:0000241D                 mov     ebp, esp
.text$mn:0000241F                 mov     ecx, [ebp+arg_0]
.text$mn:00002422                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00002427                 pop     ebp
.text$mn:00002428                 retn
.text$mn:00002428 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00002428
.text$mn:00002428 ; ---------------------------------------------------------------------------
.text$mn:00002429                 align 4
.text$mn:00002429 _text$mn        ends
.text$mn:00002429
.text$mn:0000242C ; ===========================================================================
.text$mn:0000242C
.text$mn:0000242C ; Segment type: Pure code
.text$mn:0000242C ; Segment permissions: Read/Execute
.text$mn:0000242C _text$mn        segment para public 'CODE' use32
.text$mn:0000242C                 assume cs:_text$mn
.text$mn:0000242C                 ;org 242Ch
.text$mn:0000242C ; COMDAT (pick any)
.text$mn:0000242C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000242C
.text$mn:0000242C ; =============== S U B R O U T I N E =======================================
.text$mn:0000242C
.text$mn:0000242C ; Attributes: bp-based frame
.text$mn:0000242C
.text$mn:0000242C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:0000242C                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:0000242C ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:0000242C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:0000242C
.text$mn:0000242C arg_0           = dword ptr  8
.text$mn:0000242C
.text$mn:0000242C                 push    ebp
.text$mn:0000242D                 mov     ebp, esp
.text$mn:0000242F                 mov     ecx, [ebp+arg_0]
.text$mn:00002432                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:00002437                 pop     ebp
.text$mn:00002438                 retn
.text$mn:00002438 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:00002438
.text$mn:00002438 ; ---------------------------------------------------------------------------
.text$mn:00002439                 align 4
.text$mn:00002439 _text$mn        ends
.text$mn:00002439
.text$mn:0000243C ; ===========================================================================
.text$mn:0000243C
.text$mn:0000243C ; Segment type: Pure code
.text$mn:0000243C ; Segment permissions: Read/Execute
.text$mn:0000243C _text$mn        segment para public 'CODE' use32
.text$mn:0000243C                 assume cs:_text$mn
.text$mn:0000243C                 ;org 243Ch
.text$mn:0000243C ; COMDAT (pick any)
.text$mn:0000243C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000243C
.text$mn:0000243C ; =============== S U B R O U T I N E =======================================
.text$mn:0000243C
.text$mn:0000243C ; Attributes: bp-based frame
.text$mn:0000243C
.text$mn:0000243C ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:0000243C                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000243C ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000243C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:0000243C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000243C
.text$mn:0000243C var_10          = dword ptr -10h
.text$mn:0000243C var_C           = dword ptr -0Ch
.text$mn:0000243C var_8           = dword ptr -8
.text$mn:0000243C var_1           = byte ptr -1
.text$mn:0000243C
.text$mn:0000243C                 push    ebp
.text$mn:0000243D                 mov     ebp, esp
.text$mn:0000243F                 sub     esp, 10h
.text$mn:00002442                 mov     [ebp+var_10], ecx
.text$mn:00002445                 lea     eax, [ebp+var_1]
.text$mn:00002448                 push    eax
.text$mn:00002449                 mov     ecx, [ebp+var_10]
.text$mn:0000244C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002451                 mov     ecx, eax
.text$mn:00002453                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00002458                 mov     [ebp+var_8], eax
.text$mn:0000245B                 cmp     [ebp+var_8], 1
.text$mn:0000245F                 ja      short loc_246A
.text$mn:00002461                 mov     [ebp+var_C], 1
.text$mn:00002468                 jmp     short loc_2473
.text$mn:0000246A ; ---------------------------------------------------------------------------
.text$mn:0000246A
.text$mn:0000246A loc_246A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:0000246A                 mov     ecx, [ebp+var_8]
.text$mn:0000246D                 sub     ecx, 1
.text$mn:00002470                 mov     [ebp+var_C], ecx
.text$mn:00002473
.text$mn:00002473 loc_2473:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00002473                 mov     eax, [ebp+var_C]
.text$mn:00002476                 mov     esp, ebp
.text$mn:00002478                 pop     ebp
.text$mn:00002479                 retn
.text$mn:00002479 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002479
.text$mn:00002479 ; ---------------------------------------------------------------------------
.text$mn:0000247A                 align 4
.text$mn:0000247A _text$mn        ends
.text$mn:0000247A
.text$mn:0000247C ; ===========================================================================
.text$mn:0000247C
.text$mn:0000247C ; Segment type: Pure code
.text$mn:0000247C ; Segment permissions: Read/Execute
.text$mn:0000247C _text$mn        segment para public 'CODE' use32
.text$mn:0000247C                 assume cs:_text$mn
.text$mn:0000247C                 ;org 247Ch
.text$mn:0000247C ; COMDAT (pick any)
.text$mn:0000247C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000247C
.text$mn:0000247C ; =============== S U B R O U T I N E =======================================
.text$mn:0000247C
.text$mn:0000247C ; Attributes: bp-based frame
.text$mn:0000247C
.text$mn:0000247C ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000247C                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000247C ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000247C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:0000247C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000247C
.text$mn:0000247C var_10          = dword ptr -10h
.text$mn:0000247C var_C           = dword ptr -0Ch
.text$mn:0000247C var_8           = dword ptr -8
.text$mn:0000247C var_1           = byte ptr -1
.text$mn:0000247C
.text$mn:0000247C                 push    ebp
.text$mn:0000247D                 mov     ebp, esp
.text$mn:0000247F                 sub     esp, 10h
.text$mn:00002482                 mov     [ebp+var_10], ecx
.text$mn:00002485                 lea     eax, [ebp+var_1]
.text$mn:00002488                 push    eax
.text$mn:00002489                 mov     ecx, [ebp+var_10]
.text$mn:0000248C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002491                 mov     ecx, eax
.text$mn:00002493                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:00002498                 mov     [ebp+var_8], eax
.text$mn:0000249B                 cmp     [ebp+var_8], 1
.text$mn:0000249F                 ja      short loc_24AA
.text$mn:000024A1                 mov     [ebp+var_C], 1
.text$mn:000024A8                 jmp     short loc_24B3
.text$mn:000024AA ; ---------------------------------------------------------------------------
.text$mn:000024AA
.text$mn:000024AA loc_24AA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:000024AA                 mov     ecx, [ebp+var_8]
.text$mn:000024AD                 sub     ecx, 1
.text$mn:000024B0                 mov     [ebp+var_C], ecx
.text$mn:000024B3
.text$mn:000024B3 loc_24B3:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:000024B3                 mov     eax, [ebp+var_C]
.text$mn:000024B6                 mov     esp, ebp
.text$mn:000024B8                 pop     ebp
.text$mn:000024B9                 retn
.text$mn:000024B9 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:000024B9
.text$mn:000024B9 ; ---------------------------------------------------------------------------
.text$mn:000024BA                 align 4
.text$mn:000024BA _text$mn        ends
.text$mn:000024BA
.text$mn:000024BC ; ===========================================================================
.text$mn:000024BC
.text$mn:000024BC ; Segment type: Pure code
.text$mn:000024BC ; Segment permissions: Read/Execute
.text$mn:000024BC _text$mn        segment para public 'CODE' use32
.text$mn:000024BC                 assume cs:_text$mn
.text$mn:000024BC                 ;org 24BCh
.text$mn:000024BC ; COMDAT (pick any)
.text$mn:000024BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024BC
.text$mn:000024BC ; =============== S U B R O U T I N E =======================================
.text$mn:000024BC
.text$mn:000024BC ; Attributes: bp-based frame
.text$mn:000024BC
.text$mn:000024BC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:000024BC                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000024BC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000024BC                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:000024BC                                         ; DATA XREF: .rdata:00002DDCo
.text$mn:000024BC
.text$mn:000024BC var_1C          = dword ptr -1Ch
.text$mn:000024BC var_18          = dword ptr -18h
.text$mn:000024BC Str             = dword ptr -14h
.text$mn:000024BC var_10          = dword ptr -10h
.text$mn:000024BC var_C           = dword ptr -0Ch
.text$mn:000024BC var_4           = dword ptr -4
.text$mn:000024BC arg_0           = dword ptr  8
.text$mn:000024BC arg_4           = dword ptr  0Ch
.text$mn:000024BC
.text$mn:000024BC                 push    ebp
.text$mn:000024BD                 mov     ebp, esp
.text$mn:000024BF                 push    0FFFFFFFFh
.text$mn:000024C1                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000024C6                 mov     eax, large fs:0
.text$mn:000024CC                 push    eax
.text$mn:000024CD                 sub     esp, 10h
.text$mn:000024D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000024D5                 xor     eax, ebp
.text$mn:000024D7                 push    eax
.text$mn:000024D8                 lea     eax, [ebp+var_C]
.text$mn:000024DB                 mov     large fs:0, eax
.text$mn:000024E1                 mov     [ebp+var_1C], ecx
.text$mn:000024E4                 mov     [ebp+var_18], 0
.text$mn:000024EB                 mov     eax, [ebp+arg_4]
.text$mn:000024EE                 push    eax             ; int
.text$mn:000024EF                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000024F4                 add     esp, 4
.text$mn:000024F7                 mov     [ebp+var_10], eax
.text$mn:000024FA                 cmp     [ebp+var_10], 0
.text$mn:000024FE                 jz      short loc_2508
.text$mn:00002500                 mov     ecx, [ebp+var_10]
.text$mn:00002503                 mov     [ebp+Str], ecx
.text$mn:00002506                 jmp     short loc_250F
.text$mn:00002508 ; ---------------------------------------------------------------------------
.text$mn:00002508
.text$mn:00002508 loc_2508:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00002508                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000250F
.text$mn:0000250F loc_250F:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0000250F                 mov     edx, [ebp+Str]
.text$mn:00002512                 push    edx             ; Str
.text$mn:00002513                 mov     ecx, [ebp+arg_0]
.text$mn:00002516                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000251B                 mov     [ebp+var_4], 0
.text$mn:00002522                 mov     eax, [ebp+var_18]
.text$mn:00002525                 or      eax, 1
.text$mn:00002528                 mov     [ebp+var_18], eax
.text$mn:0000252B                 mov     eax, [ebp+arg_0]
.text$mn:0000252E                 mov     ecx, [ebp+var_C]
.text$mn:00002531                 mov     large fs:0, ecx
.text$mn:00002538                 pop     ecx
.text$mn:00002539                 mov     esp, ebp
.text$mn:0000253B                 pop     ebp
.text$mn:0000253C                 retn    8
.text$mn:0000253C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000253C
.text$mn:0000253C ; ---------------------------------------------------------------------------
.text$mn:0000253F                 align 10h
.text$mn:0000253F _text$mn        ends
.text$mn:0000253F
.text$x:00002540 ; ===========================================================================
.text$x:00002540
.text$x:00002540 ; Segment type: Pure code
.text$x:00002540 ; Segment permissions: Read/Execute
.text$x:00002540 _text$x         segment para public 'CODE' use32
.text$x:00002540                 assume cs:_text$x
.text$x:00002540                 ;org 2540h
.text$x:00002540 ; COMDAT (pick associative to section at 24BC)
.text$x:00002540                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002540
.text$x:00002540 ; =============== S U B R O U T I N E =======================================
.text$x:00002540
.text$x:00002540
.text$x:00002540 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002540                                         ; DATA XREF: .xdata$x:00002AA8o
.text$x:00002540                 mov     eax, [ebp-18h]
.text$x:00002543                 and     eax, 1
.text$x:00002546                 jz      $LN6
.text$x:0000254C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002550                 mov     ecx, [ebp+8]
.text$x:00002553                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002558 ; ---------------------------------------------------------------------------
.text$x:00002558
.text$x:00002558 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002558                 retn
.text$x:00002558 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002558
.text$x:00002559
.text$x:00002559 ; =============== S U B R O U T I N E =======================================
.text$x:00002559
.text$x:00002559
.text$x:00002559 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002559                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00002559
.text$x:00002559 arg_4           = dword ptr  8
.text$x:00002559
.text$x:00002559                 mov     edx, [esp+arg_4]
.text$x:0000255D                 lea     eax, [edx+0Ch]
.text$x:00002560                 mov     ecx, [edx-14h]
.text$x:00002563                 xor     ecx, eax
.text$x:00002565                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000256A                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000256F                 jmp     ___CxxFrameHandler3
.text$x:0000256F __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000256F
.text$x:0000256F _text$x         ends
.text$x:0000256F
.text$mn:00002574 ; ===========================================================================
.text$mn:00002574
.text$mn:00002574 ; Segment type: Pure code
.text$mn:00002574 ; Segment permissions: Read/Execute
.text$mn:00002574 _text$mn        segment para public 'CODE' use32
.text$mn:00002574                 assume cs:_text$mn
.text$mn:00002574                 ;org 2574h
.text$mn:00002574 ; COMDAT (pick any)
.text$mn:00002574                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002574
.text$mn:00002574 ; =============== S U B R O U T I N E =======================================
.text$mn:00002574
.text$mn:00002574 ; Attributes: bp-based frame
.text$mn:00002574
.text$mn:00002574 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00002574                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002574 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002574                                         ; DATA XREF: .rdata:00002E10o
.text$mn:00002574
.text$mn:00002574 var_14          = dword ptr -14h
.text$mn:00002574 var_10          = dword ptr -10h
.text$mn:00002574 var_C           = dword ptr -0Ch
.text$mn:00002574 var_4           = dword ptr -4
.text$mn:00002574 arg_0           = dword ptr  8
.text$mn:00002574 arg_4           = dword ptr  0Ch
.text$mn:00002574
.text$mn:00002574                 push    ebp
.text$mn:00002575                 mov     ebp, esp
.text$mn:00002577                 push    0FFFFFFFFh
.text$mn:00002579                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000257E                 mov     eax, large fs:0
.text$mn:00002584                 push    eax
.text$mn:00002585                 sub     esp, 8
.text$mn:00002588                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000258D                 xor     eax, ebp
.text$mn:0000258F                 push    eax
.text$mn:00002590                 lea     eax, [ebp+var_C]
.text$mn:00002593                 mov     large fs:0, eax
.text$mn:00002599                 mov     [ebp+var_14], ecx
.text$mn:0000259C                 mov     [ebp+var_10], 0
.text$mn:000025A3                 cmp     [ebp+arg_4], 1
.text$mn:000025A7                 jnz     short loc_25CD
.text$mn:000025A9                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:000025AE                 mov     ecx, [ebp+arg_0]
.text$mn:000025B1                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000025B6                 mov     [ebp+var_4], 0
.text$mn:000025BD                 mov     eax, [ebp+var_10]
.text$mn:000025C0                 or      eax, 1
.text$mn:000025C3                 mov     [ebp+var_10], eax
.text$mn:000025C6                 mov     eax, [ebp+arg_0]
.text$mn:000025C9                 jmp     short loc_25F0
.text$mn:000025CB ; ---------------------------------------------------------------------------
.text$mn:000025CB                 jmp     short loc_25F0
.text$mn:000025CD ; ---------------------------------------------------------------------------
.text$mn:000025CD
.text$mn:000025CD loc_25CD:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:000025CD                 mov     ecx, [ebp+arg_4]
.text$mn:000025D0                 push    ecx
.text$mn:000025D1                 mov     edx, [ebp+arg_0]
.text$mn:000025D4                 push    edx
.text$mn:000025D5                 mov     ecx, [ebp+var_14]
.text$mn:000025D8                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:000025DD                 mov     [ebp+var_4], 0
.text$mn:000025E4                 mov     eax, [ebp+var_10]
.text$mn:000025E7                 or      eax, 1
.text$mn:000025EA                 mov     [ebp+var_10], eax
.text$mn:000025ED                 mov     eax, [ebp+arg_0]
.text$mn:000025F0
.text$mn:000025F0 loc_25F0:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:000025F0                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:000025F0                 mov     ecx, [ebp+var_C]
.text$mn:000025F3                 mov     large fs:0, ecx
.text$mn:000025FA                 pop     ecx
.text$mn:000025FB                 mov     esp, ebp
.text$mn:000025FD                 pop     ebp
.text$mn:000025FE                 retn    8
.text$mn:000025FE ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000025FE
.text$mn:000025FE ; ---------------------------------------------------------------------------
.text$mn:00002601                 align 4
.text$mn:00002601 _text$mn        ends
.text$mn:00002601
.text$x:00002604 ; ===========================================================================
.text$x:00002604
.text$x:00002604 ; Segment type: Pure code
.text$x:00002604 ; Segment permissions: Read/Execute
.text$x:00002604 _text$x         segment para public 'CODE' use32
.text$x:00002604                 assume cs:_text$x
.text$x:00002604                 ;org 2604h
.text$x:00002604 ; COMDAT (pick associative to section at 2574)
.text$x:00002604                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002604
.text$x:00002604 ; =============== S U B R O U T I N E =======================================
.text$x:00002604
.text$x:00002604
.text$x:00002604 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002604                                         ; DATA XREF: .xdata$x:00002B2Co
.text$x:00002604                 mov     eax, [ebp-10h]
.text$x:00002607                 and     eax, 1
.text$x:0000260A                 jz      $LN6_0
.text$x:00002610                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002614                 mov     ecx, [ebp+8]
.text$x:00002617                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000261C ; ---------------------------------------------------------------------------
.text$x:0000261C
.text$x:0000261C $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000261C                 retn
.text$x:0000261C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000261C
.text$x:0000261D
.text$x:0000261D ; =============== S U B R O U T I N E =======================================
.text$x:0000261D
.text$x:0000261D
.text$x:0000261D __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000261D                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:0000261D
.text$x:0000261D arg_4           = dword ptr  8
.text$x:0000261D
.text$x:0000261D                 mov     edx, [esp+arg_4]
.text$x:00002621                 lea     eax, [edx+0Ch]
.text$x:00002624                 mov     ecx, [edx-0Ch]
.text$x:00002627                 xor     ecx, eax
.text$x:00002629                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000262E                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002633                 jmp     ___CxxFrameHandler3
.text$x:00002633 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002633
.text$x:00002633 _text$x         ends
.text$x:00002633
.text$mn:00002638 ; ===========================================================================
.text$mn:00002638
.text$mn:00002638 ; Segment type: Pure code
.text$mn:00002638 ; Segment permissions: Read/Execute
.text$mn:00002638 _text$mn        segment para public 'CODE' use32
.text$mn:00002638                 assume cs:_text$mn
.text$mn:00002638                 ;org 2638h
.text$mn:00002638 ; COMDAT (pick any)
.text$mn:00002638                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002638
.text$mn:00002638 ; =============== S U B R O U T I N E =======================================
.text$mn:00002638
.text$mn:00002638 ; Attributes: bp-based frame
.text$mn:00002638
.text$mn:00002638 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00002638                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002638 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002638                                         ; DATA XREF: .rdata:00002E50o
.text$mn:00002638
.text$mn:00002638 var_1C          = dword ptr -1Ch
.text$mn:00002638 var_18          = dword ptr -18h
.text$mn:00002638 Str             = dword ptr -14h
.text$mn:00002638 var_10          = dword ptr -10h
.text$mn:00002638 var_C           = dword ptr -0Ch
.text$mn:00002638 var_4           = dword ptr -4
.text$mn:00002638 arg_0           = dword ptr  8
.text$mn:00002638 arg_4           = dword ptr  0Ch
.text$mn:00002638
.text$mn:00002638                 push    ebp
.text$mn:00002639                 mov     ebp, esp
.text$mn:0000263B                 push    0FFFFFFFFh
.text$mn:0000263D                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002642                 mov     eax, large fs:0
.text$mn:00002648                 push    eax
.text$mn:00002649                 sub     esp, 10h
.text$mn:0000264C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002651                 xor     eax, ebp
.text$mn:00002653                 push    eax
.text$mn:00002654                 lea     eax, [ebp+var_C]
.text$mn:00002657                 mov     large fs:0, eax
.text$mn:0000265D                 mov     [ebp+var_1C], ecx
.text$mn:00002660                 mov     [ebp+var_18], 0
.text$mn:00002667                 mov     eax, [ebp+arg_4]
.text$mn:0000266A                 push    eax             ; int
.text$mn:0000266B                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00002670                 add     esp, 4
.text$mn:00002673                 mov     [ebp+var_10], eax
.text$mn:00002676                 cmp     [ebp+var_10], 0
.text$mn:0000267A                 jz      short loc_2684
.text$mn:0000267C                 mov     ecx, [ebp+var_10]
.text$mn:0000267F                 mov     [ebp+Str], ecx
.text$mn:00002682                 jmp     short loc_268B
.text$mn:00002684 ; ---------------------------------------------------------------------------
.text$mn:00002684
.text$mn:00002684 loc_2684:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00002684                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000268B
.text$mn:0000268B loc_268B:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:0000268B                 mov     edx, [ebp+Str]
.text$mn:0000268E                 push    edx             ; Str
.text$mn:0000268F                 mov     ecx, [ebp+arg_0]
.text$mn:00002692                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002697                 mov     [ebp+var_4], 0
.text$mn:0000269E                 mov     eax, [ebp+var_18]
.text$mn:000026A1                 or      eax, 1
.text$mn:000026A4                 mov     [ebp+var_18], eax
.text$mn:000026A7                 mov     eax, [ebp+arg_0]
.text$mn:000026AA                 mov     ecx, [ebp+var_C]
.text$mn:000026AD                 mov     large fs:0, ecx
.text$mn:000026B4                 pop     ecx
.text$mn:000026B5                 mov     esp, ebp
.text$mn:000026B7                 pop     ebp
.text$mn:000026B8                 retn    8
.text$mn:000026B8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000026B8
.text$mn:000026B8 ; ---------------------------------------------------------------------------
.text$mn:000026BB                 align 4
.text$mn:000026BB _text$mn        ends
.text$mn:000026BB
.text$x:000026BC ; ===========================================================================
.text$x:000026BC
.text$x:000026BC ; Segment type: Pure code
.text$x:000026BC ; Segment permissions: Read/Execute
.text$x:000026BC _text$x         segment para public 'CODE' use32
.text$x:000026BC                 assume cs:_text$x
.text$x:000026BC                 ;org 26BCh
.text$x:000026BC ; COMDAT (pick associative to section at 2638)
.text$x:000026BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000026BC
.text$x:000026BC ; =============== S U B R O U T I N E =======================================
.text$x:000026BC
.text$x:000026BC
.text$x:000026BC __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000026BC                                         ; DATA XREF: .xdata$x:00002BB0o
.text$x:000026BC                 mov     eax, [ebp-18h]
.text$x:000026BF                 and     eax, 1
.text$x:000026C2                 jz      $LN6_1
.text$x:000026C8                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000026CC                 mov     ecx, [ebp+8]
.text$x:000026CF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000026D4 ; ---------------------------------------------------------------------------
.text$x:000026D4
.text$x:000026D4 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000026D4                 retn
.text$x:000026D4 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000026D4
.text$x:000026D5
.text$x:000026D5 ; =============== S U B R O U T I N E =======================================
.text$x:000026D5
.text$x:000026D5
.text$x:000026D5 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000026D5                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:000026D5
.text$x:000026D5 arg_4           = dword ptr  8
.text$x:000026D5
.text$x:000026D5                 mov     edx, [esp+arg_4]
.text$x:000026D9                 lea     eax, [edx+0Ch]
.text$x:000026DC                 mov     ecx, [edx-14h]
.text$x:000026DF                 xor     ecx, eax
.text$x:000026E1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000026E6                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000026EB                 jmp     ___CxxFrameHandler3
.text$x:000026EB __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000026EB
.text$x:000026EB _text$x         ends
.text$x:000026EB
.text$mn:000026F0 ; ===========================================================================
.text$mn:000026F0
.text$mn:000026F0 ; Segment type: Pure code
.text$mn:000026F0 ; Segment permissions: Read/Execute
.text$mn:000026F0 _text$mn        segment para public 'CODE' use32
.text$mn:000026F0                 assume cs:_text$mn
.text$mn:000026F0                 ;org 26F0h
.text$mn:000026F0 ; COMDAT (pick any)
.text$mn:000026F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026F0
.text$mn:000026F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000026F0
.text$mn:000026F0 ; Attributes: bp-based frame
.text$mn:000026F0
.text$mn:000026F0 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:000026F0                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000026F0 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:000026F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:000026F0
.text$mn:000026F0 var_4           = dword ptr -4
.text$mn:000026F0 Dst             = dword ptr  8
.text$mn:000026F0 Src             = dword ptr  0Ch
.text$mn:000026F0 Size            = dword ptr  10h
.text$mn:000026F0
.text$mn:000026F0                 push    ebp
.text$mn:000026F1                 mov     ebp, esp
.text$mn:000026F3                 push    ecx
.text$mn:000026F4                 cmp     [ebp+Size], 0
.text$mn:000026F8                 jnz     short loc_2702
.text$mn:000026FA                 mov     eax, [ebp+Dst]
.text$mn:000026FD                 mov     [ebp+var_4], eax
.text$mn:00002700                 jmp     short loc_2719
.text$mn:00002702 ; ---------------------------------------------------------------------------
.text$mn:00002702
.text$mn:00002702 loc_2702:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00002702                 mov     ecx, [ebp+Size]
.text$mn:00002705                 push    ecx             ; Size
.text$mn:00002706                 mov     edx, [ebp+Src]
.text$mn:00002709                 push    edx             ; Src
.text$mn:0000270A                 mov     eax, [ebp+Dst]
.text$mn:0000270D                 push    eax             ; Dst
.text$mn:0000270E                 call    _memmove
.text$mn:00002713                 add     esp, 0Ch
.text$mn:00002716                 mov     [ebp+var_4], eax
.text$mn:00002719
.text$mn:00002719 loc_2719:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00002719                 mov     eax, [ebp+var_4]
.text$mn:0000271C                 mov     esp, ebp
.text$mn:0000271E                 pop     ebp
.text$mn:0000271F                 retn
.text$mn:0000271F ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000271F
.text$mn:0000271F _text$mn        ends
.text$mn:0000271F
.text$mn:00002720 ; ===========================================================================
.text$mn:00002720
.text$mn:00002720 ; Segment type: Pure code
.text$mn:00002720 ; Segment permissions: Read/Execute
.text$mn:00002720 _text$mn        segment para public 'CODE' use32
.text$mn:00002720                 assume cs:_text$mn
.text$mn:00002720                 ;org 2720h
.text$mn:00002720 ; COMDAT (pick any)
.text$mn:00002720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002720
.text$mn:00002720 ; =============== S U B R O U T I N E =======================================
.text$mn:00002720
.text$mn:00002720 ; Attributes: bp-based frame
.text$mn:00002720
.text$mn:00002720 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:00002720                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00002720 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00002720                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:00002720
.text$mn:00002720 var_4           = dword ptr -4
.text$mn:00002720 Dst             = dword ptr  8
.text$mn:00002720 Src             = dword ptr  0Ch
.text$mn:00002720 arg_8           = dword ptr  10h
.text$mn:00002720
.text$mn:00002720                 push    ebp
.text$mn:00002721                 mov     ebp, esp
.text$mn:00002723                 push    ecx
.text$mn:00002724                 cmp     [ebp+arg_8], 0
.text$mn:00002728                 jnz     short loc_2732
.text$mn:0000272A                 mov     eax, [ebp+Dst]
.text$mn:0000272D                 mov     [ebp+var_4], eax
.text$mn:00002730                 jmp     short loc_2749
.text$mn:00002732 ; ---------------------------------------------------------------------------
.text$mn:00002732
.text$mn:00002732 loc_2732:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00002732                 mov     ecx, [ebp+arg_8]
.text$mn:00002735                 push    ecx             ; int
.text$mn:00002736                 mov     edx, [ebp+Src]
.text$mn:00002739                 push    edx             ; Src
.text$mn:0000273A                 mov     eax, [ebp+Dst]
.text$mn:0000273D                 push    eax             ; Dst
.text$mn:0000273E                 call    _wmemmove
.text$mn:00002743                 add     esp, 0Ch
.text$mn:00002746                 mov     [ebp+var_4], eax
.text$mn:00002749
.text$mn:00002749 loc_2749:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00002749                 mov     eax, [ebp+var_4]
.text$mn:0000274C                 mov     esp, ebp
.text$mn:0000274E                 pop     ebp
.text$mn:0000274F                 retn
.text$mn:0000274F ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000274F
.text$mn:0000274F _text$mn        ends
.text$mn:0000274F
.text$mn:00002750 ; ===========================================================================
.text$mn:00002750
.text$mn:00002750 ; Segment type: Pure code
.text$mn:00002750 ; Segment permissions: Read/Execute
.text$mn:00002750 _text$mn        segment para public 'CODE' use32
.text$mn:00002750                 assume cs:_text$mn
.text$mn:00002750                 ;org 2750h
.text$mn:00002750 ; COMDAT (pick any)
.text$mn:00002750                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002750
.text$mn:00002750 ; =============== S U B R O U T I N E =======================================
.text$mn:00002750
.text$mn:00002750 ; Attributes: bp-based frame
.text$mn:00002750
.text$mn:00002750 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00002750                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00002750 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00002750                                         ; DATA XREF: .rdata:00002DD8o
.text$mn:00002750
.text$mn:00002750 var_4           = dword ptr -4
.text$mn:00002750
.text$mn:00002750                 push    ebp
.text$mn:00002751                 mov     ebp, esp
.text$mn:00002753                 push    ecx
.text$mn:00002754                 mov     [ebp+var_4], ecx
.text$mn:00002757                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:0000275C                 mov     esp, ebp
.text$mn:0000275E                 pop     ebp
.text$mn:0000275F                 retn
.text$mn:0000275F ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000275F
.text$mn:0000275F _text$mn        ends
.text$mn:0000275F
.text$mn:00002760 ; ===========================================================================
.text$mn:00002760
.text$mn:00002760 ; Segment type: Pure code
.text$mn:00002760 ; Segment permissions: Read/Execute
.text$mn:00002760 _text$mn        segment para public 'CODE' use32
.text$mn:00002760                 assume cs:_text$mn
.text$mn:00002760                 ;org 2760h
.text$mn:00002760 ; COMDAT (pick any)
.text$mn:00002760                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002760
.text$mn:00002760 ; =============== S U B R O U T I N E =======================================
.text$mn:00002760
.text$mn:00002760 ; Attributes: bp-based frame
.text$mn:00002760
.text$mn:00002760 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00002760                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00002760 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00002760                                         ; DATA XREF: .rdata:00002E0Co
.text$mn:00002760
.text$mn:00002760 var_4           = dword ptr -4
.text$mn:00002760
.text$mn:00002760                 push    ebp
.text$mn:00002761                 mov     ebp, esp
.text$mn:00002763                 push    ecx
.text$mn:00002764                 mov     [ebp+var_4], ecx
.text$mn:00002767                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:0000276C                 mov     esp, ebp
.text$mn:0000276E                 pop     ebp
.text$mn:0000276F                 retn
.text$mn:0000276F ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000276F
.text$mn:0000276F _text$mn        ends
.text$mn:0000276F
.text$mn:00002770 ; ===========================================================================
.text$mn:00002770
.text$mn:00002770 ; Segment type: Pure code
.text$mn:00002770 ; Segment permissions: Read/Execute
.text$mn:00002770 _text$mn        segment para public 'CODE' use32
.text$mn:00002770                 assume cs:_text$mn
.text$mn:00002770                 ;org 2770h
.text$mn:00002770 ; COMDAT (pick any)
.text$mn:00002770                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002770
.text$mn:00002770 ; =============== S U B R O U T I N E =======================================
.text$mn:00002770
.text$mn:00002770 ; Attributes: bp-based frame
.text$mn:00002770
.text$mn:00002770 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00002770                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00002770 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00002770                                         ; DATA XREF: .rdata:00002E4Co
.text$mn:00002770
.text$mn:00002770 var_4           = dword ptr -4
.text$mn:00002770
.text$mn:00002770                 push    ebp
.text$mn:00002771                 mov     ebp, esp
.text$mn:00002773                 push    ecx
.text$mn:00002774                 mov     [ebp+var_4], ecx
.text$mn:00002777                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:0000277C                 mov     esp, ebp
.text$mn:0000277E                 pop     ebp
.text$mn:0000277F                 retn
.text$mn:0000277F ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000277F
.text$mn:0000277F _text$mn        ends
.text$mn:0000277F
.text$mn:00002780 ; ===========================================================================
.text$mn:00002780
.text$mn:00002780 ; Segment type: Pure code
.text$mn:00002780 ; Segment permissions: Read/Execute
.text$mn:00002780 _text$mn        segment para public 'CODE' use32
.text$mn:00002780                 assume cs:_text$mn
.text$mn:00002780                 ;org 2780h
.text$mn:00002780 ; COMDAT (pick any)
.text$mn:00002780                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002780
.text$mn:00002780 ; =============== S U B R O U T I N E =======================================
.text$mn:00002780
.text$mn:00002780 ; Attributes: bp-based frame
.text$mn:00002780
.text$mn:00002780 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00002780                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002780 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002780                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00002780                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00002780
.text$mn:00002780 var_4           = dword ptr -4
.text$mn:00002780
.text$mn:00002780                 push    ebp
.text$mn:00002781                 mov     ebp, esp
.text$mn:00002783                 push    ecx
.text$mn:00002784                 mov     [ebp+var_4], ecx
.text$mn:00002787                 mov     eax, [ebp+var_4]
.text$mn:0000278A                 mov     eax, [eax+14h]
.text$mn:0000278D                 mov     esp, ebp
.text$mn:0000278F                 pop     ebp
.text$mn:00002790                 retn
.text$mn:00002790 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002790
.text$mn:00002790 ; ---------------------------------------------------------------------------
.text$mn:00002791                 align 4
.text$mn:00002791 _text$mn        ends
.text$mn:00002791
.text$mn:00002794 ; ===========================================================================
.text$mn:00002794
.text$mn:00002794 ; Segment type: Pure code
.text$mn:00002794 ; Segment permissions: Read/Execute
.text$mn:00002794 _text$mn        segment para public 'CODE' use32
.text$mn:00002794                 assume cs:_text$mn
.text$mn:00002794                 ;org 2794h
.text$mn:00002794 ; COMDAT (pick any)
.text$mn:00002794                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002794
.text$mn:00002794 ; =============== S U B R O U T I N E =======================================
.text$mn:00002794
.text$mn:00002794 ; Attributes: bp-based frame
.text$mn:00002794
.text$mn:00002794 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:00002794                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00002794 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00002794                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:00002794                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p
.text$mn:00002794
.text$mn:00002794 var_4           = dword ptr -4
.text$mn:00002794
.text$mn:00002794                 push    ebp
.text$mn:00002795                 mov     ebp, esp
.text$mn:00002797                 push    ecx
.text$mn:00002798                 mov     [ebp+var_4], ecx
.text$mn:0000279B                 mov     eax, [ebp+var_4]
.text$mn:0000279E                 mov     eax, [eax+14h]
.text$mn:000027A1                 mov     esp, ebp
.text$mn:000027A3                 pop     ebp
.text$mn:000027A4                 retn
.text$mn:000027A4 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:000027A4
.text$mn:000027A4 ; ---------------------------------------------------------------------------
.text$mn:000027A5                 align 4
.text$mn:000027A5 _text$mn        ends
.text$mn:000027A5
.text$mn:000027A8 ; ===========================================================================
.text$mn:000027A8
.text$mn:000027A8 ; Segment type: Pure code
.text$mn:000027A8 ; Segment permissions: Read/Execute
.text$mn:000027A8 _text$mn        segment para public 'CODE' use32
.text$mn:000027A8                 assume cs:_text$mn
.text$mn:000027A8                 ;org 27A8h
.text$mn:000027A8 ; COMDAT (pick any)
.text$mn:000027A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027A8
.text$mn:000027A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000027A8
.text$mn:000027A8 ; Attributes: bp-based frame
.text$mn:000027A8
.text$mn:000027A8 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:000027A8                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:000027A8 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000027A8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_2114p
.text$mn:000027A8                 push    ebp
.text$mn:000027A9                 mov     ebp, esp
.text$mn:000027AB                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:000027B0                 pop     ebp
.text$mn:000027B1                 retn
.text$mn:000027B1 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000027B1
.text$mn:000027B1 ; ---------------------------------------------------------------------------
.text$mn:000027B2                 align 4
.text$mn:000027B2 _text$mn        ends
.text$mn:000027B2
.text$mn:000027B4 ; ===========================================================================
.text$mn:000027B4
.text$mn:000027B4 ; Segment type: Pure code
.text$mn:000027B4 ; Segment permissions: Read/Execute
.text$mn:000027B4 _text$mn        segment para public 'CODE' use32
.text$mn:000027B4                 assume cs:_text$mn
.text$mn:000027B4                 ;org 27B4h
.text$mn:000027B4 ; COMDAT (pick any)
.text$mn:000027B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027B4
.text$mn:000027B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027B4
.text$mn:000027B4 ; Attributes: bp-based frame
.text$mn:000027B4
.text$mn:000027B4 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:000027B4                 public ?value@error_code@std@@QBEHXZ
.text$mn:000027B4 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:000027B4
.text$mn:000027B4 var_4           = dword ptr -4
.text$mn:000027B4
.text$mn:000027B4                 push    ebp
.text$mn:000027B5                 mov     ebp, esp
.text$mn:000027B7                 push    ecx
.text$mn:000027B8                 mov     [ebp+var_4], ecx
.text$mn:000027BB                 mov     eax, [ebp+var_4]
.text$mn:000027BE                 mov     eax, [eax]
.text$mn:000027C0                 mov     esp, ebp
.text$mn:000027C2                 pop     ebp
.text$mn:000027C3                 retn
.text$mn:000027C3 ?value@error_code@std@@QBEHXZ endp
.text$mn:000027C3
.text$mn:000027C3 _text$mn        ends
.text$mn:000027C3
.text$mn:000027C4 ; ===========================================================================
.text$mn:000027C4
.text$mn:000027C4 ; Segment type: Pure code
.text$mn:000027C4 ; Segment permissions: Read/Execute
.text$mn:000027C4 _text$mn        segment para public 'CODE' use32
.text$mn:000027C4                 assume cs:_text$mn
.text$mn:000027C4                 ;org 27C4h
.text$mn:000027C4 ; COMDAT (pick any)
.text$mn:000027C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027C4
.text$mn:000027C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027C4
.text$mn:000027C4 ; Attributes: bp-based frame
.text$mn:000027C4
.text$mn:000027C4 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:000027C4                 public ?value@error_condition@std@@QBEHXZ
.text$mn:000027C4 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:000027C4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:000027C4                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:000027C4
.text$mn:000027C4 var_4           = dword ptr -4
.text$mn:000027C4
.text$mn:000027C4                 push    ebp
.text$mn:000027C5                 mov     ebp, esp
.text$mn:000027C7                 push    ecx
.text$mn:000027C8                 mov     [ebp+var_4], ecx
.text$mn:000027CB                 mov     eax, [ebp+var_4]
.text$mn:000027CE                 mov     eax, [eax]
.text$mn:000027D0                 mov     esp, ebp
.text$mn:000027D2                 pop     ebp
.text$mn:000027D3                 retn
.text$mn:000027D3 ?value@error_condition@std@@QBEHXZ endp
.text$mn:000027D3
.text$mn:000027D3 _text$mn        ends
.text$mn:000027D3
.text$mn:000027D4 ; ===========================================================================
.text$mn:000027D4
.text$mn:000027D4 ; Segment type: Pure code
.text$mn:000027D4 ; Segment permissions: Read/Execute
.text$mn:000027D4 _text$mn        segment para public 'CODE' use32
.text$mn:000027D4                 assume cs:_text$mn
.text$mn:000027D4                 ;org 27D4h
.text$mn:000027D4 ; COMDAT (pick any)
.text$mn:000027D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027D4
.text$mn:000027D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027D4
.text$mn:000027D4 ; Attributes: bp-based frame
.text$mn:000027D4
.text$mn:000027D4                 public _hypot
.text$mn:000027D4 _hypot          proc near
.text$mn:000027D4
.text$mn:000027D4 var_10          = qword ptr -10h
.text$mn:000027D4 var_8           = qword ptr -8
.text$mn:000027D4 arg_0           = qword ptr  8
.text$mn:000027D4 arg_8           = qword ptr  10h
.text$mn:000027D4
.text$mn:000027D4                 push    ebp
.text$mn:000027D5                 mov     ebp, esp
.text$mn:000027D7                 sub     esp, 8
.text$mn:000027DA                 movsd   xmm0, [ebp+arg_8]
.text$mn:000027DF                 movsd   [esp+8+var_8], xmm0
.text$mn:000027E4                 sub     esp, 8
.text$mn:000027E7                 movsd   xmm0, [ebp+arg_0]
.text$mn:000027EC                 movsd   [esp+10h+var_10], xmm0
.text$mn:000027F1                 call    __hypot
.text$mn:000027F6                 add     esp, 10h
.text$mn:000027F9                 pop     ebp
.text$mn:000027FA                 retn
.text$mn:000027FA _hypot          endp
.text$mn:000027FA
.text$mn:000027FA ; ---------------------------------------------------------------------------
.text$mn:000027FB                 align 4
.text$mn:000027FB _text$mn        ends
.text$mn:000027FB
.text$mn:000027FC ; ===========================================================================
.text$mn:000027FC
.text$mn:000027FC ; Segment type: Pure code
.text$mn:000027FC ; Segment permissions: Read/Execute
.text$mn:000027FC _text$mn        segment para public 'CODE' use32
.text$mn:000027FC                 assume cs:_text$mn
.text$mn:000027FC                 ;org 27FCh
.text$mn:000027FC ; COMDAT (pick any)
.text$mn:000027FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027FC
.text$mn:000027FC ; =============== S U B R O U T I N E =======================================
.text$mn:000027FC
.text$mn:000027FC ; Attributes: bp-based frame
.text$mn:000027FC
.text$mn:000027FC ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:000027FC                 public _wmemcpy
.text$mn:000027FC _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:000027FC
.text$mn:000027FC Dst             = dword ptr  8
.text$mn:000027FC Src             = dword ptr  0Ch
.text$mn:000027FC arg_8           = dword ptr  10h
.text$mn:000027FC
.text$mn:000027FC                 push    ebp
.text$mn:000027FD                 mov     ebp, esp
.text$mn:000027FF                 mov     eax, [ebp+arg_8]
.text$mn:00002802                 shl     eax, 1
.text$mn:00002804                 push    eax             ; Size
.text$mn:00002805                 mov     ecx, [ebp+Src]
.text$mn:00002808                 push    ecx             ; Src
.text$mn:00002809                 mov     edx, [ebp+Dst]
.text$mn:0000280C                 push    edx             ; Dst
.text$mn:0000280D                 call    _memcpy
.text$mn:00002812                 add     esp, 0Ch
.text$mn:00002815                 pop     ebp
.text$mn:00002816                 retn
.text$mn:00002816 _wmemcpy        endp
.text$mn:00002816
.text$mn:00002816 ; ---------------------------------------------------------------------------
.text$mn:00002817                 align 4
.text$mn:00002817 _text$mn        ends
.text$mn:00002817
.text$mn:00002818 ; ===========================================================================
.text$mn:00002818
.text$mn:00002818 ; Segment type: Pure code
.text$mn:00002818 ; Segment permissions: Read/Execute
.text$mn:00002818 _text$mn        segment para public 'CODE' use32
.text$mn:00002818                 assume cs:_text$mn
.text$mn:00002818                 ;org 2818h
.text$mn:00002818 ; COMDAT (pick any)
.text$mn:00002818                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002818
.text$mn:00002818 ; =============== S U B R O U T I N E =======================================
.text$mn:00002818
.text$mn:00002818 ; Attributes: bp-based frame
.text$mn:00002818
.text$mn:00002818 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:00002818                 public _wmemmove
.text$mn:00002818 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00002818
.text$mn:00002818 Dst             = dword ptr  8
.text$mn:00002818 Src             = dword ptr  0Ch
.text$mn:00002818 arg_8           = dword ptr  10h
.text$mn:00002818
.text$mn:00002818                 push    ebp
.text$mn:00002819                 mov     ebp, esp
.text$mn:0000281B                 mov     eax, [ebp+arg_8]
.text$mn:0000281E                 shl     eax, 1
.text$mn:00002820                 push    eax             ; Size
.text$mn:00002821                 mov     ecx, [ebp+Src]
.text$mn:00002824                 push    ecx             ; Src
.text$mn:00002825                 mov     edx, [ebp+Dst]
.text$mn:00002828                 push    edx             ; Dst
.text$mn:00002829                 call    _memmove
.text$mn:0000282E                 add     esp, 0Ch
.text$mn:00002831                 pop     ebp
.text$mn:00002832                 retn
.text$mn:00002832 _wmemmove       endp
.text$mn:00002832
.text$mn:00002832 ; ---------------------------------------------------------------------------
.text$mn:00002833                 align 4
.text$mn:00002833 _text$mn        ends
.text$mn:00002833
.xdata$x:00002834 ; ===========================================================================
.xdata$x:00002834
.xdata$x:00002834 ; Segment type: Pure data
.xdata$x:00002834 ; Segment permissions: Read
.xdata$x:00002834 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002834                 assume cs:_xdata$x
.xdata$x:00002834                 ;org 2834h
.xdata$x:00002834 ; COMDAT (pick associative to section at 1990)
.xdata$x:00002834 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00002834                                         ; DATA XREF: .xdata$x:00002844o
.xdata$x:00002835                 db 0FFh
.xdata$x:00002836                 db 0FFh
.xdata$x:00002837                 db 0FFh
.xdata$x:00002838                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:0000283C __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:0000283C                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:0000283D                 db    5
.xdata$x:0000283E                 db  93h ; ô
.xdata$x:0000283F                 db  19h
.xdata$x:00002840                 db    1
.xdata$x:00002841                 db    0
.xdata$x:00002842                 db    0
.xdata$x:00002843                 db    0
.xdata$x:00002844                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00002848                 align 20h
.xdata$x:00002848 _xdata$x        ends
.xdata$x:00002848
.xdata$x:00002860 ; ===========================================================================
.xdata$x:00002860
.xdata$x:00002860 ; Segment type: Pure data
.xdata$x:00002860 ; Segment permissions: Read
.xdata$x:00002860 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002860                 assume cs:_xdata$x
.xdata$x:00002860                 ;org 2860h
.xdata$x:00002860 ; COMDAT (pick associative to section at 7DC)
.xdata$x:00002860 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002860                                         ; DATA XREF: .xdata$x:00002870o
.xdata$x:00002861                 db 0FFh
.xdata$x:00002862                 db 0FFh
.xdata$x:00002863                 db 0FFh
.xdata$x:00002864                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002868 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002868                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002869                 db    5
.xdata$x:0000286A                 db  93h ; ô
.xdata$x:0000286B                 db  19h
.xdata$x:0000286C                 db    1
.xdata$x:0000286D                 db    0
.xdata$x:0000286E                 db    0
.xdata$x:0000286F                 db    0
.xdata$x:00002870                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002874                 db    0
.xdata$x:00002875                 db    0
.xdata$x:00002876                 db    0
.xdata$x:00002877                 db    0
.xdata$x:00002878                 db    0
.xdata$x:00002879                 db    0
.xdata$x:0000287A                 db    0
.xdata$x:0000287B                 db    0
.xdata$x:0000287C                 db    0
.xdata$x:0000287D                 db    0
.xdata$x:0000287E                 db    0
.xdata$x:0000287F                 db    0
.xdata$x:00002880                 db    0
.xdata$x:00002881                 db    0
.xdata$x:00002882                 db    0
.xdata$x:00002883                 db    0
.xdata$x:00002884                 db    0
.xdata$x:00002885                 db    0
.xdata$x:00002886                 db    0
.xdata$x:00002887                 db    0
.xdata$x:00002888                 db    0
.xdata$x:00002889                 db    0
.xdata$x:0000288A                 db    0
.xdata$x:0000288B                 db    0
.xdata$x:0000288B _xdata$x        ends
.xdata$x:0000288B
.xdata$x:0000288C ; ===========================================================================
.xdata$x:0000288C
.xdata$x:0000288C ; Segment type: Pure data
.xdata$x:0000288C ; Segment permissions: Read
.xdata$x:0000288C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000288C                 assume cs:_xdata$x
.xdata$x:0000288C                 ;org 288Ch
.xdata$x:0000288C ; COMDAT (pick associative to section at CE0)
.xdata$x:0000288C __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000288C                                         ; DATA XREF: .xdata$x:0000289Co
.xdata$x:0000288D                 db 0FFh
.xdata$x:0000288E                 db 0FFh
.xdata$x:0000288F                 db 0FFh
.xdata$x:00002890                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002894 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002894                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002895                 db    5
.xdata$x:00002896                 db  93h ; ô
.xdata$x:00002897                 db  19h
.xdata$x:00002898                 db    1
.xdata$x:00002899                 db    0
.xdata$x:0000289A                 db    0
.xdata$x:0000289B                 db    0
.xdata$x:0000289C                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:000028A0                 db    0
.xdata$x:000028A1                 db    0
.xdata$x:000028A2                 db    0
.xdata$x:000028A3                 db    0
.xdata$x:000028A4                 db    0
.xdata$x:000028A5                 db    0
.xdata$x:000028A6                 db    0
.xdata$x:000028A7                 db    0
.xdata$x:000028A8                 db    0
.xdata$x:000028A9                 db    0
.xdata$x:000028AA                 db    0
.xdata$x:000028AB                 db    0
.xdata$x:000028AC                 db    0
.xdata$x:000028AD                 db    0
.xdata$x:000028AE                 db    0
.xdata$x:000028AF                 db    0
.xdata$x:000028B0                 db    0
.xdata$x:000028B1                 db    0
.xdata$x:000028B2                 db    0
.xdata$x:000028B3                 db    0
.xdata$x:000028B4                 db    0
.xdata$x:000028B5                 db    0
.xdata$x:000028B6                 db    0
.xdata$x:000028B7                 db    0
.xdata$x:000028B7 _xdata$x        ends
.xdata$x:000028B7
.xdata$x:000028B8 ; ===========================================================================
.xdata$x:000028B8
.xdata$x:000028B8 ; Segment type: Pure data
.xdata$x:000028B8 ; Segment permissions: Read
.xdata$x:000028B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000028B8                 assume cs:_xdata$x
.xdata$x:000028B8                 ;org 28B8h
.xdata$x:000028B8 ; COMDAT (pick associative to section at 760)
.xdata$x:000028B8 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:000028B8                                         ; DATA XREF: .xdata$x:000028C8o
.xdata$x:000028B9                 db 0FFh
.xdata$x:000028BA                 db 0FFh
.xdata$x:000028BB                 db 0FFh
.xdata$x:000028BC                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:000028C0 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:000028C0                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:000028C1                 db    5
.xdata$x:000028C2                 db  93h ; ô
.xdata$x:000028C3                 db  19h
.xdata$x:000028C4                 db    1
.xdata$x:000028C5                 db    0
.xdata$x:000028C6                 db    0
.xdata$x:000028C7                 db    0
.xdata$x:000028C8                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:000028CC                 db    0
.xdata$x:000028CD                 db    0
.xdata$x:000028CE                 db    0
.xdata$x:000028CF                 db    0
.xdata$x:000028D0                 db    0
.xdata$x:000028D1                 db    0
.xdata$x:000028D2                 db    0
.xdata$x:000028D3                 db    0
.xdata$x:000028D4                 db    0
.xdata$x:000028D5                 db    0
.xdata$x:000028D6                 db    0
.xdata$x:000028D7                 db    0
.xdata$x:000028D8                 db    0
.xdata$x:000028D9                 db    0
.xdata$x:000028DA                 db    0
.xdata$x:000028DB                 db    0
.xdata$x:000028DC                 db    0
.xdata$x:000028DD                 db    0
.xdata$x:000028DE                 db    0
.xdata$x:000028DF                 db    0
.xdata$x:000028E0                 db    0
.xdata$x:000028E1                 db    0
.xdata$x:000028E2                 db    0
.xdata$x:000028E3                 db    0
.xdata$x:000028E3 _xdata$x        ends
.xdata$x:000028E3
.xdata$x:000028E4 ; ===========================================================================
.xdata$x:000028E4
.xdata$x:000028E4 ; Segment type: Pure data
.xdata$x:000028E4 ; Segment permissions: Read
.xdata$x:000028E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000028E4                 assume cs:_xdata$x
.xdata$x:000028E4                 ;org 28E4h
.xdata$x:000028E4 ; COMDAT (pick associative to section at C68)
.xdata$x:000028E4 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000028E4                                         ; DATA XREF: .xdata$x:000028F4o
.xdata$x:000028E5                 db 0FFh
.xdata$x:000028E6                 db 0FFh
.xdata$x:000028E7                 db 0FFh
.xdata$x:000028E8                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000028EC __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000028EC                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000028ED                 db    5
.xdata$x:000028EE                 db  93h ; ô
.xdata$x:000028EF                 db  19h
.xdata$x:000028F0                 db    1
.xdata$x:000028F1                 db    0
.xdata$x:000028F2                 db    0
.xdata$x:000028F3                 db    0
.xdata$x:000028F4                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:000028F8                 db    0
.xdata$x:000028F9                 db    0
.xdata$x:000028FA                 db    0
.xdata$x:000028FB                 db    0
.xdata$x:000028FC                 db    0
.xdata$x:000028FD                 db    0
.xdata$x:000028FE                 db    0
.xdata$x:000028FF                 db    0
.xdata$x:00002900                 db    0
.xdata$x:00002901                 db    0
.xdata$x:00002902                 db    0
.xdata$x:00002903                 db    0
.xdata$x:00002904                 db    0
.xdata$x:00002905                 db    0
.xdata$x:00002906                 db    0
.xdata$x:00002907                 db    0
.xdata$x:00002908                 db    0
.xdata$x:00002909                 db    0
.xdata$x:0000290A                 db    0
.xdata$x:0000290B                 db    0
.xdata$x:0000290C                 db    0
.xdata$x:0000290D                 db    0
.xdata$x:0000290E                 db    0
.xdata$x:0000290F                 db    0
.xdata$x:0000290F _xdata$x        ends
.xdata$x:0000290F
.xdata$x:00002910 ; ===========================================================================
.xdata$x:00002910
.xdata$x:00002910 ; Segment type: Pure data
.xdata$x:00002910 ; Segment permissions: Read
.xdata$x:00002910 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002910                 assume cs:_xdata$x
.xdata$x:00002910                 ;org 2910h
.xdata$x:00002910 ; COMDAT (pick associative to section at 8C4)
.xdata$x:00002910 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002910                                         ; DATA XREF: .xdata$x:00002920o
.xdata$x:00002911                 db 0FFh
.xdata$x:00002912                 db 0FFh
.xdata$x:00002913                 db 0FFh
.xdata$x:00002914                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00002918 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00002918                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00002919                 db    5
.xdata$x:0000291A                 db  93h ; ô
.xdata$x:0000291B                 db  19h
.xdata$x:0000291C                 db    1
.xdata$x:0000291D                 db    0
.xdata$x:0000291E                 db    0
.xdata$x:0000291F                 db    0
.xdata$x:00002920                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00002924                 db    0
.xdata$x:00002925                 db    0
.xdata$x:00002926                 db    0
.xdata$x:00002927                 db    0
.xdata$x:00002928                 db    0
.xdata$x:00002929                 db    0
.xdata$x:0000292A                 db    0
.xdata$x:0000292B                 db    0
.xdata$x:0000292C                 db    0
.xdata$x:0000292D                 db    0
.xdata$x:0000292E                 db    0
.xdata$x:0000292F                 db    0
.xdata$x:00002930                 db    0
.xdata$x:00002931                 db    0
.xdata$x:00002932                 db    0
.xdata$x:00002933                 db    0
.xdata$x:00002934                 db    0
.xdata$x:00002935                 db    0
.xdata$x:00002936                 db    0
.xdata$x:00002937                 db    0
.xdata$x:00002938                 db    0
.xdata$x:00002939                 db    0
.xdata$x:0000293A                 db    0
.xdata$x:0000293B                 db    0
.xdata$x:0000293B _xdata$x        ends
.xdata$x:0000293B
.xdata$x:0000293C ; ===========================================================================
.xdata$x:0000293C
.xdata$x:0000293C ; Segment type: Pure data
.xdata$x:0000293C ; Segment permissions: Read
.xdata$x:0000293C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000293C                 assume cs:_xdata$x
.xdata$x:0000293C                 ;org 293Ch
.xdata$x:0000293C ; COMDAT (pick associative to section at D50)
.xdata$x:0000293C __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000293C                                         ; DATA XREF: .xdata$x:0000294Co
.xdata$x:0000293D                 db 0FFh
.xdata$x:0000293E                 db 0FFh
.xdata$x:0000293F                 db 0FFh
.xdata$x:00002940                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00002944 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00002944                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00002945                 db    5
.xdata$x:00002946                 db  93h ; ô
.xdata$x:00002947                 db  19h
.xdata$x:00002948                 db    1
.xdata$x:00002949                 db    0
.xdata$x:0000294A                 db    0
.xdata$x:0000294B                 db    0
.xdata$x:0000294C                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00002950                 db    0
.xdata$x:00002951                 db    0
.xdata$x:00002952                 db    0
.xdata$x:00002953                 db    0
.xdata$x:00002954                 db    0
.xdata$x:00002955                 db    0
.xdata$x:00002956                 db    0
.xdata$x:00002957                 db    0
.xdata$x:00002958                 db    0
.xdata$x:00002959                 db    0
.xdata$x:0000295A                 db    0
.xdata$x:0000295B                 db    0
.xdata$x:0000295C                 db    0
.xdata$x:0000295D                 db    0
.xdata$x:0000295E                 db    0
.xdata$x:0000295F                 db    0
.xdata$x:00002960                 db    0
.xdata$x:00002961                 db    0
.xdata$x:00002962                 db    0
.xdata$x:00002963                 db    0
.xdata$x:00002964                 db    0
.xdata$x:00002965                 db    0
.xdata$x:00002966                 db    0
.xdata$x:00002967                 db    0
.xdata$x:00002967 _xdata$x        ends
.xdata$x:00002967
.xdata$x:00002968 ; ===========================================================================
.xdata$x:00002968
.xdata$x:00002968 ; Segment type: Pure data
.xdata$x:00002968 ; Segment permissions: Read
.xdata$x:00002968 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002968                 assume cs:_xdata$x
.xdata$x:00002968                 ;org 2968h
.xdata$x:00002968 ; COMDAT (pick associative to section at 1280)
.xdata$x:00002968 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00002968                                         ; DATA XREF: .xdata$x:000029F0o
.xdata$x:00002969                 db    0
.xdata$x:0000296A                 db    0
.xdata$x:0000296B                 db    0
.xdata$x:0000296C                 db    0
.xdata$x:0000296D                 db    0
.xdata$x:0000296E                 db    0
.xdata$x:0000296F                 db    0
.xdata$x:00002970                 db    0
.xdata$x:00002971                 db    0
.xdata$x:00002972                 db    0
.xdata$x:00002973                 db    0
.xdata$x:00002974                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00002978 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00002978                                         ; DATA XREF: .xdata$x:000029DCo
.xdata$x:00002979                 db    0
.xdata$x:0000297A                 db    0
.xdata$x:0000297B                 db    0
.xdata$x:0000297C                 db    0
.xdata$x:0000297D                 db    0
.xdata$x:0000297E                 db    0
.xdata$x:0000297F                 db    0
.xdata$x:00002980                 db    0
.xdata$x:00002981                 db    0
.xdata$x:00002982                 db    0
.xdata$x:00002983                 db    0
.xdata$x:00002984                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00002988 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00002988                                         ; DATA XREF: .xdata$x:000029B0o
.xdata$x:00002989                 db 0FFh
.xdata$x:0000298A                 db 0FFh
.xdata$x:0000298B                 db 0FFh
.xdata$x:0000298C                 db    0
.xdata$x:0000298D                 db    0
.xdata$x:0000298E                 db    0
.xdata$x:0000298F                 db    0
.xdata$x:00002990                 db 0FFh
.xdata$x:00002991                 db 0FFh
.xdata$x:00002992                 db 0FFh
.xdata$x:00002993                 db 0FFh
.xdata$x:00002994                 db    0
.xdata$x:00002995                 db    0
.xdata$x:00002996                 db    0
.xdata$x:00002997                 db    0
.xdata$x:00002998                 db    1
.xdata$x:00002999                 db    0
.xdata$x:0000299A                 db    0
.xdata$x:0000299B                 db    0
.xdata$x:0000299C                 db    0
.xdata$x:0000299D                 db    0
.xdata$x:0000299E                 db    0
.xdata$x:0000299F                 db    0
.xdata$x:000029A0                 db    1
.xdata$x:000029A1                 db    0
.xdata$x:000029A2                 db    0
.xdata$x:000029A3                 db    0
.xdata$x:000029A4                 db    0
.xdata$x:000029A5                 db    0
.xdata$x:000029A6                 db    0
.xdata$x:000029A7                 db    0
.xdata$x:000029A8 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:000029A8                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:000029A9                 db    5
.xdata$x:000029AA                 db  93h ; ô
.xdata$x:000029AB                 db  19h
.xdata$x:000029AC                 db    4
.xdata$x:000029AD                 db    0
.xdata$x:000029AE                 db    0
.xdata$x:000029AF                 db    0
.xdata$x:000029B0                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:000029B4                 db    2
.xdata$x:000029B5                 db    0
.xdata$x:000029B6                 db    0
.xdata$x:000029B7                 db    0
.xdata$x:000029B8                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:000029BC                 db    0
.xdata$x:000029BD                 db    0
.xdata$x:000029BE                 db    0
.xdata$x:000029BF                 db    0
.xdata$x:000029C0                 db    0
.xdata$x:000029C1                 db    0
.xdata$x:000029C2                 db    0
.xdata$x:000029C3                 db    0
.xdata$x:000029C4                 db    0
.xdata$x:000029C5                 db    0
.xdata$x:000029C6                 db    0
.xdata$x:000029C7                 db    0
.xdata$x:000029C8                 db    0
.xdata$x:000029C9                 db    0
.xdata$x:000029CA                 db    0
.xdata$x:000029CB                 db    0
.xdata$x:000029CC __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:000029CC                                         ; DATA XREF: .xdata$x:000029B8o
.xdata$x:000029CD                 db    0
.xdata$x:000029CE                 db    0
.xdata$x:000029CF                 db    0
.xdata$x:000029D0                 db    2
.xdata$x:000029D1                 db    0
.xdata$x:000029D2                 db    0
.xdata$x:000029D3                 db    0
.xdata$x:000029D4                 db    3
.xdata$x:000029D5                 db    0
.xdata$x:000029D6                 db    0
.xdata$x:000029D7                 db    0
.xdata$x:000029D8                 db    1
.xdata$x:000029D9                 db    0
.xdata$x:000029DA                 db    0
.xdata$x:000029DB                 db    0
.xdata$x:000029DC                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:000029E0                 db    0
.xdata$x:000029E1                 db    0
.xdata$x:000029E2                 db    0
.xdata$x:000029E3                 db    0
.xdata$x:000029E4                 db    0
.xdata$x:000029E5                 db    0
.xdata$x:000029E6                 db    0
.xdata$x:000029E7                 db    0
.xdata$x:000029E8                 db    3
.xdata$x:000029E9                 db    0
.xdata$x:000029EA                 db    0
.xdata$x:000029EB                 db    0
.xdata$x:000029EC                 db    1
.xdata$x:000029ED                 db    0
.xdata$x:000029EE                 db    0
.xdata$x:000029EF                 db    0
.xdata$x:000029F0                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:000029F0 _xdata$x        ends
.xdata$x:000029F0
.xdata$x:000029F4 ; ===========================================================================
.xdata$x:000029F4
.xdata$x:000029F4 ; Segment type: Pure data
.xdata$x:000029F4 ; Segment permissions: Read
.xdata$x:000029F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000029F4                 assume cs:_xdata$x
.xdata$x:000029F4                 ;org 29F4h
.xdata$x:000029F4 ; COMDAT (pick associative to section at BE4)
.xdata$x:000029F4 __unwindtable$??0runtime_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:000029F4                                         ; DATA XREF: .xdata$x:00002A04o
.xdata$x:000029F5                 db 0FFh
.xdata$x:000029F6                 db 0FFh
.xdata$x:000029F7                 db 0FFh
.xdata$x:000029F8                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0
.xdata$x:000029FC __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:000029FC                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@PBD@Z+11o
.xdata$x:000029FD                 db    5
.xdata$x:000029FE                 db  93h ; ô
.xdata$x:000029FF                 db  19h
.xdata$x:00002A00                 db    1
.xdata$x:00002A01                 db    0
.xdata$x:00002A02                 db    0
.xdata$x:00002A03                 db    0
.xdata$x:00002A04                 dd offset __unwindtable$??0runtime_error@std@@QAE@PBD@Z
.xdata$x:00002A08                 align 20h
.xdata$x:00002A08 _xdata$x        ends
.xdata$x:00002A08
.xdata$x:00002A20 ; ===========================================================================
.xdata$x:00002A20
.xdata$x:00002A20 ; Segment type: Pure data
.xdata$x:00002A20 ; Segment permissions: Read
.xdata$x:00002A20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002A20                 assume cs:_xdata$x
.xdata$x:00002A20                 ;org 2A20h
.xdata$x:00002A20 ; COMDAT (pick associative to section at F44)
.xdata$x:00002A20 __unwindtable$??1runtime_error@std@@UAE@XZ db 0FFh
.xdata$x:00002A20                                         ; DATA XREF: .xdata$x:00002A30o
.xdata$x:00002A21                 db 0FFh
.xdata$x:00002A22                 db 0FFh
.xdata$x:00002A23                 db 0FFh
.xdata$x:00002A24                 dd offset __unwindfunclet$??1runtime_error@std@@UAE@XZ$0
.xdata$x:00002A28 __ehfuncinfo$??1runtime_error@std@@UAE@XZ db  22h ; "
.xdata$x:00002A28                                         ; DATA XREF: __ehhandler$??1runtime_error@std@@UAE@XZ+11o
.xdata$x:00002A29                 db    5
.xdata$x:00002A2A                 db  93h ; ô
.xdata$x:00002A2B                 db  19h
.xdata$x:00002A2C                 db    1
.xdata$x:00002A2D                 db    0
.xdata$x:00002A2E                 db    0
.xdata$x:00002A2F                 db    0
.xdata$x:00002A30                 dd offset __unwindtable$??1runtime_error@std@@UAE@XZ
.xdata$x:00002A34                 db    0
.xdata$x:00002A35                 db    0
.xdata$x:00002A36                 db    0
.xdata$x:00002A37                 db    0
.xdata$x:00002A38                 db    0
.xdata$x:00002A39                 db    0
.xdata$x:00002A3A                 db    0
.xdata$x:00002A3B                 db    0
.xdata$x:00002A3C                 db    0
.xdata$x:00002A3D                 db    0
.xdata$x:00002A3E                 db    0
.xdata$x:00002A3F                 db    0
.xdata$x:00002A40                 db    0
.xdata$x:00002A41                 db    0
.xdata$x:00002A42                 db    0
.xdata$x:00002A43                 db    0
.xdata$x:00002A44                 db    0
.xdata$x:00002A45                 db    0
.xdata$x:00002A46                 db    0
.xdata$x:00002A47                 db    0
.xdata$x:00002A48                 db    0
.xdata$x:00002A49                 db    0
.xdata$x:00002A4A                 db    0
.xdata$x:00002A4B                 db    0
.xdata$x:00002A4B _xdata$x        ends
.xdata$x:00002A4B
.xdata$x:00002A4C ; ===========================================================================
.xdata$x:00002A4C
.xdata$x:00002A4C ; Segment type: Pure data
.xdata$x:00002A4C ; Segment permissions: Read
.xdata$x:00002A4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002A4C                 assume cs:_xdata$x
.xdata$x:00002A4C                 ;org 2A4Ch
.xdata$x:00002A4C ; COMDAT (pick associative to section at B60)
.xdata$x:00002A4C __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00002A4C                                         ; DATA XREF: .xdata$x:00002A5Co
.xdata$x:00002A4D                 db 0FFh
.xdata$x:00002A4E                 db 0FFh
.xdata$x:00002A4F                 db 0FFh
.xdata$x:00002A50                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
.xdata$x:00002A54 __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00002A54                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z+11o
.xdata$x:00002A55                 db    5
.xdata$x:00002A56                 db  93h ; ô
.xdata$x:00002A57                 db  19h
.xdata$x:00002A58                 db    1
.xdata$x:00002A59                 db    0
.xdata$x:00002A5A                 db    0
.xdata$x:00002A5B                 db    0
.xdata$x:00002A5C                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
.xdata$x:00002A60                 db    0
.xdata$x:00002A61                 db    0
.xdata$x:00002A62                 db    0
.xdata$x:00002A63                 db    0
.xdata$x:00002A64                 db    0
.xdata$x:00002A65                 db    0
.xdata$x:00002A66                 db    0
.xdata$x:00002A67                 db    0
.xdata$x:00002A68                 db    0
.xdata$x:00002A69                 db    0
.xdata$x:00002A6A                 db    0
.xdata$x:00002A6B                 db    0
.xdata$x:00002A6C                 db    0
.xdata$x:00002A6D                 db    0
.xdata$x:00002A6E                 db    0
.xdata$x:00002A6F                 db    0
.xdata$x:00002A70                 db    0
.xdata$x:00002A71                 db    0
.xdata$x:00002A72                 db    0
.xdata$x:00002A73                 db    0
.xdata$x:00002A74                 db    0
.xdata$x:00002A75                 db    0
.xdata$x:00002A76                 db    0
.xdata$x:00002A77                 db    0
.xdata$x:00002A77 _xdata$x        ends
.xdata$x:00002A77
.xdata$x:00002A78 ; ===========================================================================
.xdata$x:00002A78
.xdata$x:00002A78 ; Segment type: Pure data
.xdata$x:00002A78 ; Segment permissions: Read
.xdata$x:00002A78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002A78                 assume cs:_xdata$x
.xdata$x:00002A78                 ;org 2A78h
.xdata$x:00002A78 ; COMDAT (pick associative to section at 998)
.xdata$x:00002A78 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002A78                                         ; DATA XREF: .xdata$x:00002A88o
.xdata$x:00002A79                 db 0FFh
.xdata$x:00002A7A                 db 0FFh
.xdata$x:00002A7B                 db 0FFh
.xdata$x:00002A7C                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00002A80 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002A80                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00002A81                 db    5
.xdata$x:00002A82                 db  93h ; ô
.xdata$x:00002A83                 db  19h
.xdata$x:00002A84                 db    1
.xdata$x:00002A85                 db    0
.xdata$x:00002A86                 db    0
.xdata$x:00002A87                 db    0
.xdata$x:00002A88                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00002A8C                 db    0
.xdata$x:00002A8D                 db    0
.xdata$x:00002A8E                 db    0
.xdata$x:00002A8F                 db    0
.xdata$x:00002A90                 db    0
.xdata$x:00002A91                 db    0
.xdata$x:00002A92                 db    0
.xdata$x:00002A93                 db    0
.xdata$x:00002A94                 db    0
.xdata$x:00002A95                 db    0
.xdata$x:00002A96                 db    0
.xdata$x:00002A97                 db    0
.xdata$x:00002A98                 db    0
.xdata$x:00002A99                 db    0
.xdata$x:00002A9A                 db    0
.xdata$x:00002A9B                 db    0
.xdata$x:00002A9C                 db    0
.xdata$x:00002A9D                 db    0
.xdata$x:00002A9E                 db    0
.xdata$x:00002A9F                 db    0
.xdata$x:00002AA0                 db    0
.xdata$x:00002AA1                 db    0
.xdata$x:00002AA2                 db    0
.xdata$x:00002AA3                 db    0
.xdata$x:00002AA3 _xdata$x        ends
.xdata$x:00002AA3
.xdata$x:00002AA4 ; ===========================================================================
.xdata$x:00002AA4
.xdata$x:00002AA4 ; Segment type: Pure data
.xdata$x:00002AA4 ; Segment permissions: Read
.xdata$x:00002AA4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002AA4                 assume cs:_xdata$x
.xdata$x:00002AA4                 ;org 2AA4h
.xdata$x:00002AA4 ; COMDAT (pick associative to section at 24BC)
.xdata$x:00002AA4 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002AA4                                         ; DATA XREF: .xdata$x:00002AB4o
.xdata$x:00002AA5                 db 0FFh
.xdata$x:00002AA6                 db 0FFh
.xdata$x:00002AA7                 db 0FFh
.xdata$x:00002AA8                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002AAC __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002AAC                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002AAD                 db    5
.xdata$x:00002AAE                 db  93h ; ô
.xdata$x:00002AAF                 db  19h
.xdata$x:00002AB0                 db    1
.xdata$x:00002AB1                 db    0
.xdata$x:00002AB2                 db    0
.xdata$x:00002AB3                 db    0
.xdata$x:00002AB4                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002AB8                 db    0
.xdata$x:00002AB9                 db    0
.xdata$x:00002ABA                 db    0
.xdata$x:00002ABB                 db    0
.xdata$x:00002ABC                 db    0
.xdata$x:00002ABD                 db    0
.xdata$x:00002ABE                 db    0
.xdata$x:00002ABF                 db    0
.xdata$x:00002AC0                 db    0
.xdata$x:00002AC1                 db    0
.xdata$x:00002AC2                 db    0
.xdata$x:00002AC3                 db    0
.xdata$x:00002AC4                 db    0
.xdata$x:00002AC5                 db    0
.xdata$x:00002AC6                 db    0
.xdata$x:00002AC7                 db    0
.xdata$x:00002AC8                 db    0
.xdata$x:00002AC9                 db    0
.xdata$x:00002ACA                 db    0
.xdata$x:00002ACB                 db    0
.xdata$x:00002ACC                 db    0
.xdata$x:00002ACD                 db    0
.xdata$x:00002ACE                 db    0
.xdata$x:00002ACF                 db    0
.xdata$x:00002ACF _xdata$x        ends
.xdata$x:00002ACF
.xdata$x:00002AD0 ; ===========================================================================
.xdata$x:00002AD0
.xdata$x:00002AD0 ; Segment type: Pure data
.xdata$x:00002AD0 ; Segment permissions: Read
.xdata$x:00002AD0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002AD0                 assume cs:_xdata$x
.xdata$x:00002AD0                 ;org 2AD0h
.xdata$x:00002AD0 ; COMDAT (pick associative to section at DE0)
.xdata$x:00002AD0 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002AD0                                         ; DATA XREF: .xdata$x:00002AE0o
.xdata$x:00002AD1                 db 0FFh
.xdata$x:00002AD2                 db 0FFh
.xdata$x:00002AD3                 db 0FFh
.xdata$x:00002AD4                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00002AD8 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002AD8                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00002AD9                 db    5
.xdata$x:00002ADA                 db  93h ; ô
.xdata$x:00002ADB                 db  19h
.xdata$x:00002ADC                 db    1
.xdata$x:00002ADD                 db    0
.xdata$x:00002ADE                 db    0
.xdata$x:00002ADF                 db    0
.xdata$x:00002AE0                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00002AE4                 db    0
.xdata$x:00002AE5                 db    0
.xdata$x:00002AE6                 db    0
.xdata$x:00002AE7                 db    0
.xdata$x:00002AE8                 db    0
.xdata$x:00002AE9                 db    0
.xdata$x:00002AEA                 db    0
.xdata$x:00002AEB                 db    0
.xdata$x:00002AEC                 db    0
.xdata$x:00002AED                 db    0
.xdata$x:00002AEE                 db    0
.xdata$x:00002AEF                 db    0
.xdata$x:00002AF0                 db    0
.xdata$x:00002AF1                 db    0
.xdata$x:00002AF2                 db    0
.xdata$x:00002AF3                 db    0
.xdata$x:00002AF4                 db    0
.xdata$x:00002AF5                 db    0
.xdata$x:00002AF6                 db    0
.xdata$x:00002AF7                 db    0
.xdata$x:00002AF8                 db    0
.xdata$x:00002AF9                 db    0
.xdata$x:00002AFA                 db    0
.xdata$x:00002AFB                 db    0
.xdata$x:00002AFB _xdata$x        ends
.xdata$x:00002AFB
.xdata$x:00002AFC ; ===========================================================================
.xdata$x:00002AFC
.xdata$x:00002AFC ; Segment type: Pure data
.xdata$x:00002AFC ; Segment permissions: Read
.xdata$x:00002AFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002AFC                 assume cs:_xdata$x
.xdata$x:00002AFC                 ;org 2AFCh
.xdata$x:00002AFC ; COMDAT (pick associative to section at A14)
.xdata$x:00002AFC __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002AFC                                         ; DATA XREF: .xdata$x:00002B0Co
.xdata$x:00002AFD                 db 0FFh
.xdata$x:00002AFE                 db 0FFh
.xdata$x:00002AFF                 db 0FFh
.xdata$x:00002B00                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002B04 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002B04                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002B05                 db    5
.xdata$x:00002B06                 db  93h ; ô
.xdata$x:00002B07                 db  19h
.xdata$x:00002B08                 db    1
.xdata$x:00002B09                 db    0
.xdata$x:00002B0A                 db    0
.xdata$x:00002B0B                 db    0
.xdata$x:00002B0C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00002B10                 db    0
.xdata$x:00002B11                 db    0
.xdata$x:00002B12                 db    0
.xdata$x:00002B13                 db    0
.xdata$x:00002B14                 db    0
.xdata$x:00002B15                 db    0
.xdata$x:00002B16                 db    0
.xdata$x:00002B17                 db    0
.xdata$x:00002B18                 db    0
.xdata$x:00002B19                 db    0
.xdata$x:00002B1A                 db    0
.xdata$x:00002B1B                 db    0
.xdata$x:00002B1C                 db    0
.xdata$x:00002B1D                 db    0
.xdata$x:00002B1E                 db    0
.xdata$x:00002B1F                 db    0
.xdata$x:00002B20                 db    0
.xdata$x:00002B21                 db    0
.xdata$x:00002B22                 db    0
.xdata$x:00002B23                 db    0
.xdata$x:00002B24                 db    0
.xdata$x:00002B25                 db    0
.xdata$x:00002B26                 db    0
.xdata$x:00002B27                 db    0
.xdata$x:00002B27 _xdata$x        ends
.xdata$x:00002B27
.xdata$x:00002B28 ; ===========================================================================
.xdata$x:00002B28
.xdata$x:00002B28 ; Segment type: Pure data
.xdata$x:00002B28 ; Segment permissions: Read
.xdata$x:00002B28 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B28                 assume cs:_xdata$x
.xdata$x:00002B28                 ;org 2B28h
.xdata$x:00002B28 ; COMDAT (pick associative to section at 2574)
.xdata$x:00002B28 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002B28                                         ; DATA XREF: .xdata$x:00002B38o
.xdata$x:00002B29                 db 0FFh
.xdata$x:00002B2A                 db 0FFh
.xdata$x:00002B2B                 db 0FFh
.xdata$x:00002B2C                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002B30 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002B30                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002B31                 db    5
.xdata$x:00002B32                 db  93h ; ô
.xdata$x:00002B33                 db  19h
.xdata$x:00002B34                 db    1
.xdata$x:00002B35                 db    0
.xdata$x:00002B36                 db    0
.xdata$x:00002B37                 db    0
.xdata$x:00002B38                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002B3C                 db    0
.xdata$x:00002B3D                 db    0
.xdata$x:00002B3E                 db    0
.xdata$x:00002B3F                 db    0
.xdata$x:00002B40                 db    0
.xdata$x:00002B41                 db    0
.xdata$x:00002B42                 db    0
.xdata$x:00002B43                 db    0
.xdata$x:00002B44                 db    0
.xdata$x:00002B45                 db    0
.xdata$x:00002B46                 db    0
.xdata$x:00002B47                 db    0
.xdata$x:00002B48                 db    0
.xdata$x:00002B49                 db    0
.xdata$x:00002B4A                 db    0
.xdata$x:00002B4B                 db    0
.xdata$x:00002B4C                 db    0
.xdata$x:00002B4D                 db    0
.xdata$x:00002B4E                 db    0
.xdata$x:00002B4F                 db    0
.xdata$x:00002B50                 db    0
.xdata$x:00002B51                 db    0
.xdata$x:00002B52                 db    0
.xdata$x:00002B53                 db    0
.xdata$x:00002B53 _xdata$x        ends
.xdata$x:00002B53
.xdata$x:00002B54 ; ===========================================================================
.xdata$x:00002B54
.xdata$x:00002B54 ; Segment type: Pure data
.xdata$x:00002B54 ; Segment permissions: Read
.xdata$x:00002B54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B54                 assume cs:_xdata$x
.xdata$x:00002B54                 ;org 2B54h
.xdata$x:00002B54 ; COMDAT (pick associative to section at E50)
.xdata$x:00002B54 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002B54                                         ; DATA XREF: .xdata$x:00002B64o
.xdata$x:00002B55                 db 0FFh
.xdata$x:00002B56                 db 0FFh
.xdata$x:00002B57                 db 0FFh
.xdata$x:00002B58                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00002B5C __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002B5C                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00002B5D                 db    5
.xdata$x:00002B5E                 db  93h ; ô
.xdata$x:00002B5F                 db  19h
.xdata$x:00002B60                 db    1
.xdata$x:00002B61                 db    0
.xdata$x:00002B62                 db    0
.xdata$x:00002B63                 db    0
.xdata$x:00002B64                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00002B68                 align 20h
.xdata$x:00002B68 _xdata$x        ends
.xdata$x:00002B68
.xdata$x:00002B80 ; ===========================================================================
.xdata$x:00002B80
.xdata$x:00002B80 ; Segment type: Pure data
.xdata$x:00002B80 ; Segment permissions: Read
.xdata$x:00002B80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B80                 assume cs:_xdata$x
.xdata$x:00002B80                 ;org 2B80h
.xdata$x:00002B80 ; COMDAT (pick associative to section at A90)
.xdata$x:00002B80 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002B80                                         ; DATA XREF: .xdata$x:00002B90o
.xdata$x:00002B81                 db 0FFh
.xdata$x:00002B82                 db 0FFh
.xdata$x:00002B83                 db 0FFh
.xdata$x:00002B84                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00002B88 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002B88                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00002B89                 db    5
.xdata$x:00002B8A                 db  93h ; ô
.xdata$x:00002B8B                 db  19h
.xdata$x:00002B8C                 db    1
.xdata$x:00002B8D                 db    0
.xdata$x:00002B8E                 db    0
.xdata$x:00002B8F                 db    0
.xdata$x:00002B90                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00002B94                 db    0
.xdata$x:00002B95                 db    0
.xdata$x:00002B96                 db    0
.xdata$x:00002B97                 db    0
.xdata$x:00002B98                 db    0
.xdata$x:00002B99                 db    0
.xdata$x:00002B9A                 db    0
.xdata$x:00002B9B                 db    0
.xdata$x:00002B9C                 db    0
.xdata$x:00002B9D                 db    0
.xdata$x:00002B9E                 db    0
.xdata$x:00002B9F                 db    0
.xdata$x:00002BA0                 db    0
.xdata$x:00002BA1                 db    0
.xdata$x:00002BA2                 db    0
.xdata$x:00002BA3                 db    0
.xdata$x:00002BA4                 db    0
.xdata$x:00002BA5                 db    0
.xdata$x:00002BA6                 db    0
.xdata$x:00002BA7                 db    0
.xdata$x:00002BA8                 db    0
.xdata$x:00002BA9                 db    0
.xdata$x:00002BAA                 db    0
.xdata$x:00002BAB                 db    0
.xdata$x:00002BAB _xdata$x        ends
.xdata$x:00002BAB
.xdata$x:00002BAC ; ===========================================================================
.xdata$x:00002BAC
.xdata$x:00002BAC ; Segment type: Pure data
.xdata$x:00002BAC ; Segment permissions: Read
.xdata$x:00002BAC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002BAC                 assume cs:_xdata$x
.xdata$x:00002BAC                 ;org 2BACh
.xdata$x:00002BAC ; COMDAT (pick associative to section at 2638)
.xdata$x:00002BAC __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002BAC                                         ; DATA XREF: .xdata$x:00002BBCo
.xdata$x:00002BAD                 db 0FFh
.xdata$x:00002BAE                 db 0FFh
.xdata$x:00002BAF                 db 0FFh
.xdata$x:00002BB0                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002BB4 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002BB4                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002BB5                 db    5
.xdata$x:00002BB6                 db  93h ; ô
.xdata$x:00002BB7                 db  19h
.xdata$x:00002BB8                 db    1
.xdata$x:00002BB9                 db    0
.xdata$x:00002BBA                 db    0
.xdata$x:00002BBB                 db    0
.xdata$x:00002BBC                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002BC0                 db    0
.xdata$x:00002BC1                 db    0
.xdata$x:00002BC2                 db    0
.xdata$x:00002BC3                 db    0
.xdata$x:00002BC4                 db    0
.xdata$x:00002BC5                 db    0
.xdata$x:00002BC6                 db    0
.xdata$x:00002BC7                 db    0
.xdata$x:00002BC8                 db    0
.xdata$x:00002BC9                 db    0
.xdata$x:00002BCA                 db    0
.xdata$x:00002BCB                 db    0
.xdata$x:00002BCC                 db    0
.xdata$x:00002BCD                 db    0
.xdata$x:00002BCE                 db    0
.xdata$x:00002BCF                 db    0
.xdata$x:00002BD0                 db    0
.xdata$x:00002BD1                 db    0
.xdata$x:00002BD2                 db    0
.xdata$x:00002BD3                 db    0
.xdata$x:00002BD4                 db    0
.xdata$x:00002BD5                 db    0
.xdata$x:00002BD6                 db    0
.xdata$x:00002BD7                 db    0
.xdata$x:00002BD7 _xdata$x        ends
.xdata$x:00002BD7
.xdata$x:00002BD8 ; ===========================================================================
.xdata$x:00002BD8
.xdata$x:00002BD8 ; Segment type: Pure data
.xdata$x:00002BD8 ; Segment permissions: Read
.xdata$x:00002BD8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002BD8                 assume cs:_xdata$x
.xdata$x:00002BD8                 ;org 2BD8h
.xdata$x:00002BD8 ; COMDAT (pick associative to section at EC0)
.xdata$x:00002BD8 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002BD8                                         ; DATA XREF: .xdata$x:00002BE8o
.xdata$x:00002BD9                 db 0FFh
.xdata$x:00002BDA                 db 0FFh
.xdata$x:00002BDB                 db 0FFh
.xdata$x:00002BDC                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00002BE0 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002BE0                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00002BE1                 db    5
.xdata$x:00002BE2                 db  93h ; ô
.xdata$x:00002BE3                 db  19h
.xdata$x:00002BE4                 db    1
.xdata$x:00002BE5                 db    0
.xdata$x:00002BE6                 db    0
.xdata$x:00002BE7                 db    0
.xdata$x:00002BE8                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00002BEC                 db    0
.xdata$x:00002BED                 db    0
.xdata$x:00002BEE                 db    0
.xdata$x:00002BEF                 db    0
.xdata$x:00002BF0                 db    0
.xdata$x:00002BF1                 db    0
.xdata$x:00002BF2                 db    0
.xdata$x:00002BF3                 db    0
.xdata$x:00002BF4                 db    0
.xdata$x:00002BF5                 db    0
.xdata$x:00002BF6                 db    0
.xdata$x:00002BF7                 db    0
.xdata$x:00002BF8                 db    0
.xdata$x:00002BF9                 db    0
.xdata$x:00002BFA                 db    0
.xdata$x:00002BFB                 db    0
.xdata$x:00002BFC                 db    0
.xdata$x:00002BFD                 db    0
.xdata$x:00002BFE                 db    0
.xdata$x:00002BFF                 db    0
.xdata$x:00002C00                 db    0
.xdata$x:00002C01                 db    0
.xdata$x:00002C02                 db    0
.xdata$x:00002C03                 db    0
.xdata$x:00002C03 _xdata$x        ends
.xdata$x:00002C03
.xdata$x:00002C04 ; ===========================================================================
.xdata$x:00002C04
.xdata$x:00002C04 ; Segment type: Pure data
.xdata$x:00002C04 ; Segment permissions: Read
.xdata$x:00002C04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C04                 assume cs:_xdata$x
.xdata$x:00002C04                 ;org 2C04h
.xdata$x:00002C04 ; COMDAT (pick associative to section at 1440)
.xdata$x:00002C04 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00002C04                                         ; DATA XREF: .xdata$x:00002C8Co
.xdata$x:00002C05                 db    0
.xdata$x:00002C06                 db    0
.xdata$x:00002C07                 db    0
.xdata$x:00002C08                 db    0
.xdata$x:00002C09                 db    0
.xdata$x:00002C0A                 db    0
.xdata$x:00002C0B                 db    0
.xdata$x:00002C0C                 db    0
.xdata$x:00002C0D                 db    0
.xdata$x:00002C0E                 db    0
.xdata$x:00002C0F                 db    0
.xdata$x:00002C10                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:00002C14 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00002C14                                         ; DATA XREF: .xdata$x:00002C78o
.xdata$x:00002C15                 db    0
.xdata$x:00002C16                 db    0
.xdata$x:00002C17                 db    0
.xdata$x:00002C18                 db    0
.xdata$x:00002C19                 db    0
.xdata$x:00002C1A                 db    0
.xdata$x:00002C1B                 db    0
.xdata$x:00002C1C                 db    0
.xdata$x:00002C1D                 db    0
.xdata$x:00002C1E                 db    0
.xdata$x:00002C1F                 db    0
.xdata$x:00002C20                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:00002C24 __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00002C24                                         ; DATA XREF: .xdata$x:00002C4Co
.xdata$x:00002C25                 db 0FFh
.xdata$x:00002C26                 db 0FFh
.xdata$x:00002C27                 db 0FFh
.xdata$x:00002C28                 db    0
.xdata$x:00002C29                 db    0
.xdata$x:00002C2A                 db    0
.xdata$x:00002C2B                 db    0
.xdata$x:00002C2C                 db 0FFh
.xdata$x:00002C2D                 db 0FFh
.xdata$x:00002C2E                 db 0FFh
.xdata$x:00002C2F                 db 0FFh
.xdata$x:00002C30                 db    0
.xdata$x:00002C31                 db    0
.xdata$x:00002C32                 db    0
.xdata$x:00002C33                 db    0
.xdata$x:00002C34                 db    1
.xdata$x:00002C35                 db    0
.xdata$x:00002C36                 db    0
.xdata$x:00002C37                 db    0
.xdata$x:00002C38                 db    0
.xdata$x:00002C39                 db    0
.xdata$x:00002C3A                 db    0
.xdata$x:00002C3B                 db    0
.xdata$x:00002C3C                 db    1
.xdata$x:00002C3D                 db    0
.xdata$x:00002C3E                 db    0
.xdata$x:00002C3F                 db    0
.xdata$x:00002C40                 db    0
.xdata$x:00002C41                 db    0
.xdata$x:00002C42                 db    0
.xdata$x:00002C43                 db    0
.xdata$x:00002C44 __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00002C44                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:00002C45                 db    5
.xdata$x:00002C46                 db  93h ; ô
.xdata$x:00002C47                 db  19h
.xdata$x:00002C48                 db    4
.xdata$x:00002C49                 db    0
.xdata$x:00002C4A                 db    0
.xdata$x:00002C4B                 db    0
.xdata$x:00002C4C                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00002C50                 db    2
.xdata$x:00002C51                 db    0
.xdata$x:00002C52                 db    0
.xdata$x:00002C53                 db    0
.xdata$x:00002C54                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00002C58                 db    0
.xdata$x:00002C59                 db    0
.xdata$x:00002C5A                 db    0
.xdata$x:00002C5B                 db    0
.xdata$x:00002C5C                 db    0
.xdata$x:00002C5D                 db    0
.xdata$x:00002C5E                 db    0
.xdata$x:00002C5F                 db    0
.xdata$x:00002C60                 db    0
.xdata$x:00002C61                 db    0
.xdata$x:00002C62                 db    0
.xdata$x:00002C63                 db    0
.xdata$x:00002C64                 db    0
.xdata$x:00002C65                 db    0
.xdata$x:00002C66                 db    0
.xdata$x:00002C67                 db    0
.xdata$x:00002C68 __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:00002C68                                         ; DATA XREF: .xdata$x:00002C54o
.xdata$x:00002C69                 db    0
.xdata$x:00002C6A                 db    0
.xdata$x:00002C6B                 db    0
.xdata$x:00002C6C                 db    2
.xdata$x:00002C6D                 db    0
.xdata$x:00002C6E                 db    0
.xdata$x:00002C6F                 db    0
.xdata$x:00002C70                 db    3
.xdata$x:00002C71                 db    0
.xdata$x:00002C72                 db    0
.xdata$x:00002C73                 db    0
.xdata$x:00002C74                 db    1
.xdata$x:00002C75                 db    0
.xdata$x:00002C76                 db    0
.xdata$x:00002C77                 db    0
.xdata$x:00002C78                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:00002C7C                 db    0
.xdata$x:00002C7D                 db    0
.xdata$x:00002C7E                 db    0
.xdata$x:00002C7F                 db    0
.xdata$x:00002C80                 db    0
.xdata$x:00002C81                 db    0
.xdata$x:00002C82                 db    0
.xdata$x:00002C83                 db    0
.xdata$x:00002C84                 db    3
.xdata$x:00002C85                 db    0
.xdata$x:00002C86                 db    0
.xdata$x:00002C87                 db    0
.xdata$x:00002C88                 db    1
.xdata$x:00002C89                 db    0
.xdata$x:00002C8A                 db    0
.xdata$x:00002C8B                 db    0
.xdata$x:00002C8C                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:00002C8C _xdata$x        ends
.xdata$x:00002C8C
.xdata$x:00002C90 ; ===========================================================================
.xdata$x:00002C90
.xdata$x:00002C90 ; Segment type: Pure data
.xdata$x:00002C90 ; Segment permissions: Read
.xdata$x:00002C90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C90                 assume cs:_xdata$x
.xdata$x:00002C90                 ;org 2C90h
.xdata$x:00002C90 ; COMDAT (pick associative to section at 5F8)
.xdata$x:00002C90 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002C90                                         ; DATA XREF: .xdata$x:00002CA0o
.xdata$x:00002C91                 db 0FFh
.xdata$x:00002C92                 db 0FFh
.xdata$x:00002C93                 db 0FFh
.xdata$x:00002C94                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00002C98 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00002C98                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00002C99                 db    5
.xdata$x:00002C9A                 db  93h ; ô
.xdata$x:00002C9B                 db  19h
.xdata$x:00002C9C                 db    1
.xdata$x:00002C9D                 db    0
.xdata$x:00002C9E                 db    0
.xdata$x:00002C9F                 db    0
.xdata$x:00002CA0                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00002CA4                 db    0
.xdata$x:00002CA5                 db    0
.xdata$x:00002CA6                 db    0
.xdata$x:00002CA7                 db    0
.xdata$x:00002CA8                 db    0
.xdata$x:00002CA9                 db    0
.xdata$x:00002CAA                 db    0
.xdata$x:00002CAB                 db    0
.xdata$x:00002CAC                 db    0
.xdata$x:00002CAD                 db    0
.xdata$x:00002CAE                 db    0
.xdata$x:00002CAF                 db    0
.xdata$x:00002CB0                 db    0
.xdata$x:00002CB1                 db    0
.xdata$x:00002CB2                 db    0
.xdata$x:00002CB3                 db    0
.xdata$x:00002CB4                 db    0
.xdata$x:00002CB5                 db    0
.xdata$x:00002CB6                 db    0
.xdata$x:00002CB7                 db    0
.xdata$x:00002CB8                 db    0
.xdata$x:00002CB9                 db    0
.xdata$x:00002CBA                 db    0
.xdata$x:00002CBB                 db    0
.xdata$x:00002CBB _xdata$x        ends
.xdata$x:00002CBB
.xdata$x:00002CBC ; ===========================================================================
.xdata$x:00002CBC
.xdata$x:00002CBC ; Segment type: Pure data
.xdata$x:00002CBC ; Segment permissions: Read
.xdata$x:00002CBC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002CBC                 assume cs:_xdata$x
.xdata$x:00002CBC                 ;org 2CBCh
.xdata$x:00002CBC ; COMDAT (pick associative to section at 424)
.xdata$x:00002CBC __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00002CBC                                         ; DATA XREF: .xdata$x:00002CCCo
.xdata$x:00002CBD                 db 0FFh
.xdata$x:00002CBE                 db 0FFh
.xdata$x:00002CBF                 db 0FFh
.xdata$x:00002CC0                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00002CC4 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00002CC4                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00002CC5                 db    5
.xdata$x:00002CC6                 db  93h ; ô
.xdata$x:00002CC7                 db  19h
.xdata$x:00002CC8                 db    1
.xdata$x:00002CC9                 db    0
.xdata$x:00002CCA                 db    0
.xdata$x:00002CCB                 db    0
.xdata$x:00002CCC                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00002CD0                 db    0
.xdata$x:00002CD1                 db    0
.xdata$x:00002CD2                 db    0
.xdata$x:00002CD3                 db    0
.xdata$x:00002CD4                 db    0
.xdata$x:00002CD5                 db    0
.xdata$x:00002CD6                 db    0
.xdata$x:00002CD7                 db    0
.xdata$x:00002CD8                 db    0
.xdata$x:00002CD9                 db    0
.xdata$x:00002CDA                 db    0
.xdata$x:00002CDB                 db    0
.xdata$x:00002CDC                 db    0
.xdata$x:00002CDD                 db    0
.xdata$x:00002CDE                 db    0
.xdata$x:00002CDF                 db    0
.xdata$x:00002CE0                 db    0
.xdata$x:00002CE1                 db    0
.xdata$x:00002CE2                 db    0
.xdata$x:00002CE3                 db    0
.xdata$x:00002CE4                 db    0
.xdata$x:00002CE5                 db    0
.xdata$x:00002CE6                 db    0
.xdata$x:00002CE7                 db    0
.xdata$x:00002CE7 _xdata$x        ends
.xdata$x:00002CE7
.xdata$x:00002CE8 ; ===========================================================================
.xdata$x:00002CE8
.xdata$x:00002CE8 ; Segment type: Pure data
.xdata$x:00002CE8 ; Segment permissions: Read
.xdata$x:00002CE8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002CE8                 assume cs:_xdata$x
.xdata$x:00002CE8                 ;org 2CE8h
.xdata$x:00002CE8 ; COMDAT (pick associative to section at 524)
.xdata$x:00002CE8 __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:00002CE8                                         ; DATA XREF: .xdata$x:00002CF8o
.xdata$x:00002CE9                 db 0FFh
.xdata$x:00002CEA                 db 0FFh
.xdata$x:00002CEB                 db 0FFh
.xdata$x:00002CEC                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:00002CF0 __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:00002CF0                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:00002CF1                 db    5
.xdata$x:00002CF2                 db  93h ; ô
.xdata$x:00002CF3                 db  19h
.xdata$x:00002CF4                 db    1
.xdata$x:00002CF5                 db    0
.xdata$x:00002CF6                 db    0
.xdata$x:00002CF7                 db    0
.xdata$x:00002CF8                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:00002CFC                 db    0
.xdata$x:00002CFD                 db    0
.xdata$x:00002CFE                 db    0
.xdata$x:00002CFF                 db    0
.xdata$x:00002D00                 db    0
.xdata$x:00002D01                 db    0
.xdata$x:00002D02                 db    0
.xdata$x:00002D03                 db    0
.xdata$x:00002D04                 db    0
.xdata$x:00002D05                 db    0
.xdata$x:00002D06                 db    0
.xdata$x:00002D07                 db    0
.xdata$x:00002D08                 db    0
.xdata$x:00002D09                 db    0
.xdata$x:00002D0A                 db    0
.xdata$x:00002D0B                 db    0
.xdata$x:00002D0C                 db    0
.xdata$x:00002D0D                 db    0
.xdata$x:00002D0E                 db    0
.xdata$x:00002D0F                 db    0
.xdata$x:00002D10                 db    0
.xdata$x:00002D11                 db    0
.xdata$x:00002D12                 db    0
.xdata$x:00002D13                 db    0
.xdata$x:00002D13 _xdata$x        ends
.xdata$x:00002D13
.bss:00002D14 ; ===========================================================================
.bss:00002D14
.bss:00002D14 ; Segment type: Uninitialized
.bss:00002D14 ; Segment permissions: Read/Write
.bss:00002D14 _bss            segment byte public 'BSS' use32
.bss:00002D14                 assume cs:_bss
.bss:00002D14                 ;org 2D14h
.bss:00002D14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002D14 _allocator_arg  db    ? ;
.bss:00002D15 _piecewise_construct db    ? ;
.bss:00002D16                 align 4
.bss:00002D16 _bss            ends
.bss:00002D16
.rdata:00002D18 ; ===========================================================================
.rdata:00002D18
.rdata:00002D18 ; Segment type: Pure data
.rdata:00002D18 ; Segment permissions: Read
.rdata:00002D18 _rdata          segment dword public 'DATA' use32
.rdata:00002D18                 assume cs:_rdata
.rdata:00002D18                 ;org 2D18h
.rdata:00002D18 ; COMDAT (pick largest)
.rdata:00002D18                 dd offset ??_R4runtime_error@std@@6B@ ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata:00002D1C                 public ??_7runtime_error@std@@6B@
.rdata:00002D1C ; const std::runtime_error::`vftable'
.rdata:00002D1C ??_7runtime_error@std@@6B@ dd offset ??_Eruntime_error@std@@UAEPAXI@Z
.rdata:00002D1C                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+3Co
.rdata:00002D1C                                         ; std::runtime_error::runtime_error(char const *)+3Co
.rdata:00002D1C                                         ; std::runtime_error::`vector deleting destructor'(uint)
.rdata:00002D20                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:00002D20 _rdata          ends
.rdata:00002D20
.xdata$x:00002D24 ; ===========================================================================
.xdata$x:00002D24
.xdata$x:00002D24 ; Segment type: Pure data
.xdata$x:00002D24 ; Segment permissions: Read
.xdata$x:00002D24 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D24                 assume cs:_xdata$x
.xdata$x:00002D24                 ;org 2D24h
.xdata$x:00002D24 ; COMDAT (pick any)
.xdata$x:00002D24                 public __TI2?AVruntime_error@std@@
.xdata$x:00002D24 __TI2?AVruntime_error@std@@ db    0     ; DATA XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+76o
.xdata$x:00002D25                 db    0
.xdata$x:00002D26                 db    0
.xdata$x:00002D27                 db    0
.xdata$x:00002D28                 dd offset ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.xdata$x:00002D2C                 align 10h
.xdata$x:00002D30                 dd offset __CTA2?AVruntime_error@std@@
.xdata$x:00002D30 _xdata$x        ends
.xdata$x:00002D30
.xdata$x:00002D34 ; ===========================================================================
.xdata$x:00002D34
.xdata$x:00002D34 ; Segment type: Pure data
.xdata$x:00002D34 ; Segment permissions: Read
.xdata$x:00002D34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D34                 assume cs:_xdata$x
.xdata$x:00002D34                 ;org 2D34h
.xdata$x:00002D34 ; COMDAT (pick any)
.xdata$x:00002D34                 public __CTA2?AVruntime_error@std@@
.xdata$x:00002D34 __CTA2?AVruntime_error@std@@ db    2    ; DATA XREF: .xdata$x:00002D30o
.xdata$x:00002D35                 db    0
.xdata$x:00002D36                 db    0
.xdata$x:00002D37                 db    0
.xdata$x:00002D38                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00002D3C                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00002D3C _xdata$x        ends
.xdata$x:00002D3C
.data$r:00002D40 ; ===========================================================================
.data$r:00002D40
.data$r:00002D40 ; Segment type: Pure data
.data$r:00002D40 ; Segment permissions: Read/Write
.data$r:00002D40 _data$r         segment dword public 'DATA' use32
.data$r:00002D40                 assume cs:_data$r
.data$r:00002D40                 ;org 2D40h
.data$r:00002D40 ; COMDAT (pick any)
.data$r:00002D40                 public ??_R0?AVruntime_error@std@@@8
.data$r:00002D40 ; class std::runtime_error `RTTI Type Descriptor'
.data$r:00002D40 ??_R0?AVruntime_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002D40                                         ; DATA XREF: .xdata$x:00002D64o
.data$r:00002D40                                         ; .rdata$r:00002FA8o ...
.data$r:00002D40                                         ; const type_info::`vftable'
.data$r:00002D44                 align 8
.data$r:00002D48 a_?avruntime_er db '.?AVruntime_error@std@@',0
.data$r:00002D48 _data$r         ends
.data$r:00002D48
.xdata$x:00002D60 ; ===========================================================================
.xdata$x:00002D60
.xdata$x:00002D60 ; Segment type: Pure data
.xdata$x:00002D60 ; Segment permissions: Read
.xdata$x:00002D60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D60                 assume cs:_xdata$x
.xdata$x:00002D60                 ;org 2D60h
.xdata$x:00002D60 ; COMDAT (pick any)
.xdata$x:00002D60                 public __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00002D60 __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00002D60                                         ; DATA XREF: .xdata$x:00002D38o
.xdata$x:00002D61                 db    0
.xdata$x:00002D62                 db    0
.xdata$x:00002D63                 db    0
.xdata$x:00002D64                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.xdata$x:00002D68                 db    0
.xdata$x:00002D69                 db    0
.xdata$x:00002D6A                 db    0
.xdata$x:00002D6B                 db    0
.xdata$x:00002D6C                 db 0FFh
.xdata$x:00002D6D                 db 0FFh
.xdata$x:00002D6E                 db 0FFh
.xdata$x:00002D6F                 db 0FFh
.xdata$x:00002D70                 db    0
.xdata$x:00002D71                 db    0
.xdata$x:00002D72                 db    0
.xdata$x:00002D73                 db    0
.xdata$x:00002D74                 db  0Ch
.xdata$x:00002D75                 db    0
.xdata$x:00002D76                 db    0
.xdata$x:00002D77                 db    0
.xdata$x:00002D78                 dd offset ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.xdata$x:00002D78 _xdata$x        ends
.xdata$x:00002D78
.data$r:00002D7C ; ===========================================================================
.data$r:00002D7C
.data$r:00002D7C ; Segment type: Pure data
.data$r:00002D7C ; Segment permissions: Read/Write
.data$r:00002D7C _data$r         segment dword public 'DATA' use32
.data$r:00002D7C                 assume cs:_data$r
.data$r:00002D7C                 ;org 2D7Ch
.data$r:00002D7C ; COMDAT (pick any)
.data$r:00002D7C                 public ??_R0?AVexception@std@@@8
.data$r:00002D7C ; class std::exception `RTTI Type Descriptor'
.data$r:00002D7C ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002D7C                                         ; DATA XREF: .xdata$x:00002D9Co
.data$r:00002D7C                                         ; .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002D7C                                         ; const type_info::`vftable'
.data$r:00002D80                 db    0
.data$r:00002D81                 db    0
.data$r:00002D82                 db    0
.data$r:00002D83                 db    0
.data$r:00002D84                 db  2Eh ; .
.data$r:00002D85                 db  3Fh ; ?
.data$r:00002D86                 db  41h ; A
.data$r:00002D87                 db  56h ; V
.data$r:00002D88                 db  65h ; e
.data$r:00002D89                 db  78h ; x
.data$r:00002D8A                 db  63h ; c
.data$r:00002D8B                 db  65h ; e
.data$r:00002D8C                 db  70h ; p
.data$r:00002D8D                 db  74h ; t
.data$r:00002D8E                 db  69h ; i
.data$r:00002D8F                 db  6Fh ; o
.data$r:00002D90                 db  6Eh ; n
.data$r:00002D91                 db  40h ; @
.data$r:00002D92                 db  73h ; s
.data$r:00002D93                 db  74h ; t
.data$r:00002D94                 db  64h ; d
.data$r:00002D95                 db  40h ; @
.data$r:00002D96                 db  40h ; @
.data$r:00002D97                 db    0
.data$r:00002D97 _data$r         ends
.data$r:00002D97
.xdata$x:00002D98 ; ===========================================================================
.xdata$x:00002D98
.xdata$x:00002D98 ; Segment type: Pure data
.xdata$x:00002D98 ; Segment permissions: Read
.xdata$x:00002D98 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D98                 assume cs:_xdata$x
.xdata$x:00002D98                 ;org 2D98h
.xdata$x:00002D98 ; COMDAT (pick any)
.xdata$x:00002D98                 public __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00002D98 __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00002D98                                         ; DATA XREF: .xdata$x:00002D3Co
.xdata$x:00002D99                 db    0
.xdata$x:00002D9A                 db    0
.xdata$x:00002D9B                 db    0
.xdata$x:00002D9C                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:00002DA0                 db    0
.xdata$x:00002DA1                 db    0
.xdata$x:00002DA2                 db    0
.xdata$x:00002DA3                 db    0
.xdata$x:00002DA4                 db 0FFh
.xdata$x:00002DA5                 db 0FFh
.xdata$x:00002DA6                 db 0FFh
.xdata$x:00002DA7                 db 0FFh
.xdata$x:00002DA8                 db    0
.xdata$x:00002DA9                 db    0
.xdata$x:00002DAA                 db    0
.xdata$x:00002DAB                 db    0
.xdata$x:00002DAC                 db  0Ch
.xdata$x:00002DAD                 db    0
.xdata$x:00002DAE                 db    0
.xdata$x:00002DAF                 db    0
.xdata$x:00002DB0                 dd offset ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.xdata$x:00002DB0 _xdata$x        ends
.xdata$x:00002DB0
.rdata:00002DB4 ; ===========================================================================
.rdata:00002DB4
.rdata:00002DB4 ; Segment type: Pure data
.rdata:00002DB4 ; Segment permissions: Read
.rdata:00002DB4 _rdata          segment dword public 'DATA' use32
.rdata:00002DB4                 assume cs:_rdata
.rdata:00002DB4                 ;org 2DB4h
.rdata:00002DB4 ; COMDAT (pick largest)
.rdata:00002DB4                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00002DB8                 public ??_7error_category@std@@6B@
.rdata:00002DB8 ; const std::error_category::`vftable'
.rdata:00002DB8 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00002DB8                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00002DB8                                         ; std::error_category::~error_category(void)+Ao
.rdata:00002DB8                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00002DBC                 dd offset __purecall
.rdata:00002DC0                 dd offset __purecall
.rdata:00002DC4                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002DC8                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002DCC                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002DCC _rdata          ends
.rdata:00002DCC
.rdata:00002DD0 ; ===========================================================================
.rdata:00002DD0
.rdata:00002DD0 ; Segment type: Pure data
.rdata:00002DD0 ; Segment permissions: Read
.rdata:00002DD0 _rdata          segment dword public 'DATA' use32
.rdata:00002DD0                 assume cs:_rdata
.rdata:00002DD0                 ;org 2DD0h
.rdata:00002DD0 ; COMDAT (pick largest)
.rdata:00002DD0                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00002DD4                 public ??_7_Generic_error_category@std@@6B@
.rdata:00002DD4 ; const std::_Generic_error_category::`vftable'
.rdata:00002DD4 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00002DD4                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00002DD4                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00002DD8                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00002DDC                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00002DE0                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002DE4                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002DE8                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002DE8 _rdata          ends
.rdata:00002DE8
.rdata:00002DEC ; ===========================================================================
.rdata:00002DEC
.rdata:00002DEC ; Segment type: Pure data
.rdata:00002DEC ; Segment permissions: Read
.rdata:00002DEC _rdata          segment dword public 'DATA' use32
.rdata:00002DEC                 assume cs:_rdata
.rdata:00002DEC                 ;org 2DECh
.rdata:00002DEC ; COMDAT (pick any)
.rdata:00002DEC                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00002DEC ; `string'
.rdata:00002DEC ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00002DEC                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00002DEC _rdata          ends
.rdata:00002DEC
.rdata:00002DF4 ; ===========================================================================
.rdata:00002DF4
.rdata:00002DF4 ; Segment type: Pure data
.rdata:00002DF4 ; Segment permissions: Read
.rdata:00002DF4 _rdata          segment dword public 'DATA' use32
.rdata:00002DF4                 assume cs:_rdata
.rdata:00002DF4                 ;org 2DF4h
.rdata:00002DF4 ; COMDAT (pick any)
.rdata:00002DF4                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00002DF4 ; `string'
.rdata:00002DF4 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00002DF4                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_2508o
.rdata:00002DF4                                         ; std::_System_error_category::message(int):loc_2684o
.rdata:00002E02                 align 4
.rdata:00002E02 _rdata          ends
.rdata:00002E02
.rdata:00002E04 ; ===========================================================================
.rdata:00002E04
.rdata:00002E04 ; Segment type: Pure data
.rdata:00002E04 ; Segment permissions: Read
.rdata:00002E04 _rdata          segment dword public 'DATA' use32
.rdata:00002E04                 assume cs:_rdata
.rdata:00002E04                 ;org 2E04h
.rdata:00002E04 ; COMDAT (pick largest)
.rdata:00002E04                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00002E08                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00002E08 ; const std::_Iostream_error_category::`vftable'
.rdata:00002E08 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00002E08                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00002E08                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00002E0C                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00002E10                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00002E14                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002E18                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002E1C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002E1C _rdata          ends
.rdata:00002E1C
.rdata:00002E20 ; ===========================================================================
.rdata:00002E20
.rdata:00002E20 ; Segment type: Pure data
.rdata:00002E20 ; Segment permissions: Read
.rdata:00002E20 _rdata          segment dword public 'DATA' use32
.rdata:00002E20                 assume cs:_rdata
.rdata:00002E20                 ;org 2E20h
.rdata:00002E20 ; COMDAT (pick any)
.rdata:00002E20                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00002E20 ; `string'
.rdata:00002E20 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00002E20                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00002E29                 align 4
.rdata:00002E29 _rdata          ends
.rdata:00002E29
.rdata:00002E2C ; ===========================================================================
.rdata:00002E2C
.rdata:00002E2C ; Segment type: Pure data
.rdata:00002E2C ; Segment permissions: Read
.rdata:00002E2C _rdata          segment dword public 'DATA' use32
.rdata:00002E2C                 assume cs:_rdata
.rdata:00002E2C                 ;org 2E2Ch
.rdata:00002E2C ; COMDAT (pick any)
.rdata:00002E2C                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00002E2C ; char `string'[]
.rdata:00002E2C ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00002E2C                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00002E42                 align 4
.rdata:00002E42 _rdata          ends
.rdata:00002E42
.rdata:00002E44 ; ===========================================================================
.rdata:00002E44
.rdata:00002E44 ; Segment type: Pure data
.rdata:00002E44 ; Segment permissions: Read
.rdata:00002E44 _rdata          segment dword public 'DATA' use32
.rdata:00002E44                 assume cs:_rdata
.rdata:00002E44                 ;org 2E44h
.rdata:00002E44 ; COMDAT (pick largest)
.rdata:00002E44                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00002E48                 public ??_7_System_error_category@std@@6B@
.rdata:00002E48 ; const std::_System_error_category::`vftable'
.rdata:00002E48 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00002E48                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00002E48                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00002E4C                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00002E50                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00002E54                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00002E58                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002E5C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002E5C _rdata          ends
.rdata:00002E5C
.rdata:00002E60 ; ===========================================================================
.rdata:00002E60
.rdata:00002E60 ; Segment type: Pure data
.rdata:00002E60 ; Segment permissions: Read
.rdata:00002E60 _rdata          segment dword public 'DATA' use32
.rdata:00002E60                 assume cs:_rdata
.rdata:00002E60                 ;org 2E60h
.rdata:00002E60 ; COMDAT (pick any)
.rdata:00002E60                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00002E60 ; `string'
.rdata:00002E60 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00002E60                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00002E67                 align 4
.rdata:00002E67 _rdata          ends
.rdata:00002E67
.bss:00002E68 ; ===========================================================================
.bss:00002E68
.bss:00002E68 ; Segment type: Uninitialized
.bss:00002E68 ; Segment permissions: Read/Write
.bss:00002E68 _bss            segment dword public 'BSS' use32
.bss:00002E68                 assume cs:_bss
.bss:00002E68                 ;org 2E68h
.bss:00002E68 ; COMDAT (pick any)
.bss:00002E68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002E68                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00002E68 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00002E68 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00002E68                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00002E68                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00002E69                 db    ? ;
.bss:00002E6A                 db    ? ;
.bss:00002E6B                 db    ? ;
.bss:00002E6B _bss            ends
.bss:00002E6B
.bss:00002E6C ; ===========================================================================
.bss:00002E6C
.bss:00002E6C ; Segment type: Uninitialized
.bss:00002E6C ; Segment permissions: Read/Write
.bss:00002E6C _bss            segment dword public 'BSS' use32
.bss:00002E6C                 assume cs:_bss
.bss:00002E6C                 ;org 2E6Ch
.bss:00002E6C ; COMDAT (pick any)
.bss:00002E6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002E6C                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00002E6C ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00002E6C ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00002E6C                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002E6C                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002E6D                 db    ? ;
.bss:00002E6E                 db    ? ;
.bss:00002E6F                 db    ? ;
.bss:00002E6F _bss            ends
.bss:00002E6F
.bss:00002E70 ; ===========================================================================
.bss:00002E70
.bss:00002E70 ; Segment type: Uninitialized
.bss:00002E70 ; Segment permissions: Read/Write
.bss:00002E70 _bss            segment dword public 'BSS' use32
.bss:00002E70                 assume cs:_bss
.bss:00002E70                 ;org 2E70h
.bss:00002E70 ; COMDAT (pick any)
.bss:00002E70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002E70                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00002E70 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00002E70 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00002E70                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00002E70                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00002E71                 db    ? ;
.bss:00002E72                 db    ? ;
.bss:00002E73                 db    ? ;
.bss:00002E73 _bss            ends
.bss:00002E73
.bss:00002E74 ; ===========================================================================
.bss:00002E74
.bss:00002E74 ; Segment type: Uninitialized
.bss:00002E74 ; Segment permissions: Read/Write
.bss:00002E74 _bss            segment dword public 'BSS' use32
.bss:00002E74                 assume cs:_bss
.bss:00002E74                 ;org 2E74h
.bss:00002E74 ; COMDAT (pick any)
.bss:00002E74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002E74                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002E74 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00002E74 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002E74                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00002E75                 db    ? ;
.bss:00002E76                 db    ? ;
.bss:00002E77                 db    ? ;
.bss:00002E77 _bss            ends
.bss:00002E77
.bss:00002E78 ; ===========================================================================
.bss:00002E78
.bss:00002E78 ; Segment type: Uninitialized
.bss:00002E78 ; Segment permissions: Read/Write
.bss:00002E78 _bss            segment dword public 'BSS' use32
.bss:00002E78                 assume cs:_bss
.bss:00002E78                 ;org 2E78h
.bss:00002E78 ; COMDAT (pick any)
.bss:00002E78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002E78                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002E78 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00002E78 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002E78                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00002E79                 db    ? ;
.bss:00002E7A                 db    ? ;
.bss:00002E7B                 db    ? ;
.bss:00002E7B _bss            ends
.bss:00002E7B
.rdata:00002E7C ; ===========================================================================
.rdata:00002E7C
.rdata:00002E7C ; Segment type: Pure data
.rdata:00002E7C ; Segment permissions: Read
.rdata:00002E7C ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002E7C _rdata          segment para public 'DATA' use32
.rdata:00002E7C                 assume cs:_rdata
.rdata:00002E7C                 ;org 2E7Ch
.rdata:00002E7C ; COMDAT (pick any)
.rdata:00002E7C                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00002E7C ; wchar_t `string'
.rdata:00002E7C ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00002E7C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00002E7C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o ...
.rdata:00002E7C                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00002E7C                 unicode 0, <clude\xstring>,0
.rdata:00002F0A                 align 4
.rdata:00002F0A _rdata          ends
.rdata:00002F0A
.bss:00002F0C ; ===========================================================================
.bss:00002F0C
.bss:00002F0C ; Segment type: Uninitialized
.bss:00002F0C ; Segment permissions: Read/Write
.bss:00002F0C _bss            segment dword public 'BSS' use32
.bss:00002F0C                 assume cs:_bss
.bss:00002F0C                 ;org 2F0Ch
.bss:00002F0C ; COMDAT (pick any)
.bss:00002F0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002F0C                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00002F0C ; std::locale::id std::numpunct<char>::id
.bss:00002F0C ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00002F0C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00002F0D                 db    ? ;
.bss:00002F0E                 db    ? ;
.bss:00002F0F                 db    ? ;
.bss:00002F0F _bss            ends
.bss:00002F0F
.bss:00002F10 ; ===========================================================================
.bss:00002F10
.bss:00002F10 ; Segment type: Uninitialized
.bss:00002F10 ; Segment permissions: Read/Write
.bss:00002F10 _bss            segment dword public 'BSS' use32
.bss:00002F10                 assume cs:_bss
.bss:00002F10                 ;org 2F10h
.bss:00002F10 ; COMDAT (pick any)
.bss:00002F10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002F10                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00002F10 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00002F10 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00002F10                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00002F11                 db    ? ;
.bss:00002F12                 db    ? ;
.bss:00002F13                 db    ? ;
.bss:00002F13 _bss            ends
.bss:00002F13
.rdata:00002F14 ; ===========================================================================
.rdata:00002F14
.rdata:00002F14 ; Segment type: Pure data
.rdata:00002F14 ; Segment permissions: Read
.rdata:00002F14 _rdata          segment dword public 'DATA' use32
.rdata:00002F14                 assume cs:_rdata
.rdata:00002F14                 ;org 2F14h
.rdata:00002F14 ; COMDAT (pick any)
.rdata:00002F14                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00002F14 ; char `string'[]
.rdata:00002F14 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00002F14                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00002F14                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:00002F14 _rdata          ends
.rdata:00002F14
.rdata:00002F24 ; ===========================================================================
.rdata:00002F24
.rdata:00002F24 ; Segment type: Pure data
.rdata:00002F24 ; Segment permissions: Read
.rdata:00002F24 _rdata          segment dword public 'DATA' use32
.rdata:00002F24                 assume cs:_rdata
.rdata:00002F24                 ;org 2F24h
.rdata:00002F24 ; COMDAT (pick any)
.rdata:00002F24                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00002F24 ; char `string'[]
.rdata:00002F24 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00002F24                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00002F24                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:00002F24 _rdata          ends
.rdata:00002F24
.rdata:00002F3C ; ===========================================================================
.rdata:00002F3C
.rdata:00002F3C ; Segment type: Pure data
.rdata:00002F3C ; Segment permissions: Read
.rdata:00002F3C _rdata          segment dword public 'DATA' use32
.rdata:00002F3C                 assume cs:_rdata
.rdata:00002F3C                 ;org 2F3Ch
.rdata:00002F3C ; COMDAT (pick any)
.rdata:00002F3C                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00002F3C ; wchar_t `string'
.rdata:00002F3C ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00002F3C                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00002F3C                                         ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+11o
.rdata:00002F3C                 unicode 0, <invalid null pointer>,0
.rdata:00002F66                 align 4
.rdata:00002F66 _rdata          ends
.rdata:00002F66
.rdata$r:00002F68 ; ===========================================================================
.rdata$r:00002F68
.rdata$r:00002F68 ; Segment type: Pure data
.rdata$r:00002F68 ; Segment permissions: Read
.rdata$r:00002F68 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F68                 assume cs:_rdata$r
.rdata$r:00002F68                 ;org 2F68h
.rdata$r:00002F68 ; COMDAT (pick any)
.rdata$r:00002F68                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00002F68 ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002F68 ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:00002F68                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:00002F68                                         ; .rdata$r:00002FC4o
.rdata$r:00002F68                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:00002F6C                 db    0
.rdata$r:00002F6D                 db    0
.rdata$r:00002F6E                 db    0
.rdata$r:00002F6F                 db    0
.rdata$r:00002F70                 db    0
.rdata$r:00002F71                 db    0
.rdata$r:00002F72                 db    0
.rdata$r:00002F73                 db    0
.rdata$r:00002F74                 db 0FFh
.rdata$r:00002F75                 db 0FFh
.rdata$r:00002F76                 db 0FFh
.rdata$r:00002F77                 db 0FFh
.rdata$r:00002F78                 db    0
.rdata$r:00002F79                 db    0
.rdata$r:00002F7A                 db    0
.rdata$r:00002F7B                 db    0
.rdata$r:00002F7C                 db  40h ; @
.rdata$r:00002F7D                 db    0
.rdata$r:00002F7E                 db    0
.rdata$r:00002F7F                 db    0
.rdata$r:00002F80                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F80 _rdata$r        ends
.rdata$r:00002F80
.rdata$r:00002F84 ; ===========================================================================
.rdata$r:00002F84
.rdata$r:00002F84 ; Segment type: Pure data
.rdata$r:00002F84 ; Segment permissions: Read
.rdata$r:00002F84 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F84                 assume cs:_rdata$r
.rdata$r:00002F84                 ;org 2F84h
.rdata$r:00002F84 ; COMDAT (pick any)
.rdata$r:00002F84                 public ??_R3exception@std@@8
.rdata$r:00002F84 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F84 ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:00002F80o
.rdata$r:00002F85                 db    0
.rdata$r:00002F86                 db    0
.rdata$r:00002F87                 db    0
.rdata$r:00002F88                 db    0
.rdata$r:00002F89                 db    0
.rdata$r:00002F8A                 db    0
.rdata$r:00002F8B                 db    0
.rdata$r:00002F8C                 db    1
.rdata$r:00002F8D                 db    0
.rdata$r:00002F8E                 db    0
.rdata$r:00002F8F                 db    0
.rdata$r:00002F90                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:00002F90 _rdata$r        ends
.rdata$r:00002F90
.rdata$r:00002F94 ; ===========================================================================
.rdata$r:00002F94
.rdata$r:00002F94 ; Segment type: Pure data
.rdata$r:00002F94 ; Segment permissions: Read
.rdata$r:00002F94 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F94                 assume cs:_rdata$r
.rdata$r:00002F94                 ;org 2F94h
.rdata$r:00002F94 ; COMDAT (pick any)
.rdata$r:00002F94                 public ??_R2exception@std@@8
.rdata$r:00002F94 ; std::exception::`RTTI Base Class Array'
.rdata$r:00002F94 ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00002F94                                         ; DATA XREF: .rdata$r:00002F90o
.rdata$r:00002F94                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002F98                 db    0
.rdata$r:00002F99                 align 4
.rdata$r:00002F99 _rdata$r        ends
.rdata$r:00002F99
.rdata$r:00002F9C ; ===========================================================================
.rdata$r:00002F9C
.rdata$r:00002F9C ; Segment type: Pure data
.rdata$r:00002F9C ; Segment permissions: Read
.rdata$r:00002F9C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F9C                 assume cs:_rdata$r
.rdata$r:00002F9C                 ;org 2F9Ch
.rdata$r:00002F9C ; COMDAT (pick any)
.rdata$r:00002F9C                 public ??_R4runtime_error@std@@6B@
.rdata$r:00002F9C ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata$r:00002F9C ??_R4runtime_error@std@@6B@ db    0     ; DATA XREF: .rdata:00002D18o
.rdata$r:00002F9D                 db    0
.rdata$r:00002F9E                 db    0
.rdata$r:00002F9F                 db    0
.rdata$r:00002FA0                 db    0
.rdata$r:00002FA1                 db    0
.rdata$r:00002FA2                 db    0
.rdata$r:00002FA3                 db    0
.rdata$r:00002FA4                 db    0
.rdata$r:00002FA5                 db    0
.rdata$r:00002FA6                 db    0
.rdata$r:00002FA7                 db    0
.rdata$r:00002FA8                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00002FAC                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002FAC _rdata$r        ends
.rdata$r:00002FAC
.rdata$r:00002FB0 ; ===========================================================================
.rdata$r:00002FB0
.rdata$r:00002FB0 ; Segment type: Pure data
.rdata$r:00002FB0 ; Segment permissions: Read
.rdata$r:00002FB0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002FB0                 assume cs:_rdata$r
.rdata$r:00002FB0                 ;org 2FB0h
.rdata$r:00002FB0 ; COMDAT (pick any)
.rdata$r:00002FB0                 public ??_R3runtime_error@std@@8
.rdata$r:00002FB0 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002FB0 ??_R3runtime_error@std@@8 db    0       ; DATA XREF: .rdata$r:00002FACo
.rdata$r:00002FB0                                         ; .rdata$r:00002FE4o
.rdata$r:00002FB1                 db    0
.rdata$r:00002FB2                 db    0
.rdata$r:00002FB3                 db    0
.rdata$r:00002FB4                 db    0
.rdata$r:00002FB5                 db    0
.rdata$r:00002FB6                 db    0
.rdata$r:00002FB7                 db    0
.rdata$r:00002FB8                 db    2
.rdata$r:00002FB9                 db    0
.rdata$r:00002FBA                 db    0
.rdata$r:00002FBB                 db    0
.rdata$r:00002FBC                 dd offset ??_R2runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00002FBC _rdata$r        ends
.rdata$r:00002FBC
.rdata$r:00002FC0 ; ===========================================================================
.rdata$r:00002FC0
.rdata$r:00002FC0 ; Segment type: Pure data
.rdata$r:00002FC0 ; Segment permissions: Read
.rdata$r:00002FC0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002FC0                 assume cs:_rdata$r
.rdata$r:00002FC0                 ;org 2FC0h
.rdata$r:00002FC0 ; COMDAT (pick any)
.rdata$r:00002FC0                 public ??_R2runtime_error@std@@8
.rdata$r:00002FC0 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00002FC0 ??_R2runtime_error@std@@8 dd offset ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00002FC0                                         ; DATA XREF: .rdata$r:00002FBCo
.rdata$r:00002FC0                                         ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002FC4                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002FC8                 db    0
.rdata$r:00002FC9                 align 4
.rdata$r:00002FC9 _rdata$r        ends
.rdata$r:00002FC9
.rdata$r:00002FCC ; ===========================================================================
.rdata$r:00002FCC
.rdata$r:00002FCC ; Segment type: Pure data
.rdata$r:00002FCC ; Segment permissions: Read
.rdata$r:00002FCC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002FCC                 assume cs:_rdata$r
.rdata$r:00002FCC                 ;org 2FCCh
.rdata$r:00002FCC ; COMDAT (pick any)
.rdata$r:00002FCC                 public ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00002FCC ; std::runtime_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002FCC ??_R1A@?0A@EA@runtime_error@std@@8 dd offset ??_R0?AVruntime_error@std@@@8
.rdata$r:00002FCC                                         ; DATA XREF: .rdata$r:std::runtime_error::`RTTI Base Class Array'o
.rdata$r:00002FCC                                         ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00002FD0                 db    1
.rdata$r:00002FD1                 db    0
.rdata$r:00002FD2                 db    0
.rdata$r:00002FD3                 db    0
.rdata$r:00002FD4                 db    0
.rdata$r:00002FD5                 db    0
.rdata$r:00002FD6                 db    0
.rdata$r:00002FD7                 db    0
.rdata$r:00002FD8                 db 0FFh
.rdata$r:00002FD9                 db 0FFh
.rdata$r:00002FDA                 db 0FFh
.rdata$r:00002FDB                 db 0FFh
.rdata$r:00002FDC                 db    0
.rdata$r:00002FDD                 db    0
.rdata$r:00002FDE                 db    0
.rdata$r:00002FDF                 db    0
.rdata$r:00002FE0                 db  40h ; @
.rdata$r:00002FE1                 db    0
.rdata$r:00002FE2                 db    0
.rdata$r:00002FE3                 db    0
.rdata$r:00002FE4                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002FE4 _rdata$r        ends
.rdata$r:00002FE4
.rdata$r:00002FE8 ; ===========================================================================
.rdata$r:00002FE8
.rdata$r:00002FE8 ; Segment type: Pure data
.rdata$r:00002FE8 ; Segment permissions: Read
.rdata$r:00002FE8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002FE8                 assume cs:_rdata$r
.rdata$r:00002FE8                 ;org 2FE8h
.rdata$r:00002FE8 ; COMDAT (pick any)
.rdata$r:00002FE8                 public ??_R4error_category@std@@6B@
.rdata$r:00002FE8 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00002FE8 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00002DB4o
.rdata$r:00002FE9                 db    0
.rdata$r:00002FEA                 db    0
.rdata$r:00002FEB                 db    0
.rdata$r:00002FEC                 db    0
.rdata$r:00002FED                 db    0
.rdata$r:00002FEE                 db    0
.rdata$r:00002FEF                 db    0
.rdata$r:00002FF0                 db    0
.rdata$r:00002FF1                 db    0
.rdata$r:00002FF2                 db    0
.rdata$r:00002FF3                 db    0
.rdata$r:00002FF4                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002FF8                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002FF8 _rdata$r        ends
.rdata$r:00002FF8
.data$r:00002FFC ; ===========================================================================
.data$r:00002FFC
.data$r:00002FFC ; Segment type: Pure data
.data$r:00002FFC ; Segment permissions: Read/Write
.data$r:00002FFC _data$r         segment dword public 'DATA' use32
.data$r:00002FFC                 assume cs:_data$r
.data$r:00002FFC                 ;org 2FFCh
.data$r:00002FFC ; COMDAT (pick any)
.data$r:00002FFC                 public ??_R0?AVerror_category@std@@@8
.data$r:00002FFC ; class std::error_category `RTTI Type Descriptor'
.data$r:00002FFC ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002FFC                                         ; DATA XREF: .rdata$r:00002FF4o
.data$r:00002FFC                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002FFC                                         ; const type_info::`vftable'
.data$r:00003000                 db    0
.data$r:00003001                 db    0
.data$r:00003002                 db    0
.data$r:00003003                 db    0
.data$r:00003004                 db  2Eh ; .
.data$r:00003005                 db  3Fh ; ?
.data$r:00003006                 db  41h ; A
.data$r:00003007                 db  56h ; V
.data$r:00003008                 db  65h ; e
.data$r:00003009                 db  72h ; r
.data$r:0000300A                 db  72h ; r
.data$r:0000300B                 db  6Fh ; o
.data$r:0000300C                 db  72h ; r
.data$r:0000300D                 db  5Fh ; _
.data$r:0000300E                 db  63h ; c
.data$r:0000300F                 db  61h ; a
.data$r:00003010                 db  74h ; t
.data$r:00003011                 db  65h ; e
.data$r:00003012                 db  67h ; g
.data$r:00003013                 db  6Fh ; o
.data$r:00003014                 db  72h ; r
.data$r:00003015                 db  79h ; y
.data$r:00003016                 db  40h ; @
.data$r:00003017                 db  73h ; s
.data$r:00003018                 db  74h ; t
.data$r:00003019                 db  64h ; d
.data$r:0000301A                 db  40h ; @
.data$r:0000301B                 db  40h ; @
.data$r:0000301C                 db    0
.data$r:0000301D                 align 10h
.data$r:0000301D _data$r         ends
.data$r:0000301D
.rdata$r:00003020 ; ===========================================================================
.rdata$r:00003020
.rdata$r:00003020 ; Segment type: Pure data
.rdata$r:00003020 ; Segment permissions: Read
.rdata$r:00003020 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003020                 assume cs:_rdata$r
.rdata$r:00003020                 ;org 3020h
.rdata$r:00003020 ; COMDAT (pick any)
.rdata$r:00003020                 public ??_R3error_category@std@@8
.rdata$r:00003020 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003020 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00002FF8o
.rdata$r:00003020                                         ; .rdata$r:00003050o
.rdata$r:00003021                 db    0
.rdata$r:00003022                 db    0
.rdata$r:00003023                 db    0
.rdata$r:00003024                 db    0
.rdata$r:00003025                 db    0
.rdata$r:00003026                 db    0
.rdata$r:00003027                 db    0
.rdata$r:00003028                 db    1
.rdata$r:00003029                 db    0
.rdata$r:0000302A                 db    0
.rdata$r:0000302B                 db    0
.rdata$r:0000302C                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000302C _rdata$r        ends
.rdata$r:0000302C
.rdata$r:00003030 ; ===========================================================================
.rdata$r:00003030
.rdata$r:00003030 ; Segment type: Pure data
.rdata$r:00003030 ; Segment permissions: Read
.rdata$r:00003030 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003030                 assume cs:_rdata$r
.rdata$r:00003030                 ;org 3030h
.rdata$r:00003030 ; COMDAT (pick any)
.rdata$r:00003030                 public ??_R2error_category@std@@8
.rdata$r:00003030 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00003030 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00003030                                         ; DATA XREF: .rdata$r:0000302Co
.rdata$r:00003030                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003034                 db    0
.rdata$r:00003035                 align 4
.rdata$r:00003035 _rdata$r        ends
.rdata$r:00003035
.rdata$r:00003038 ; ===========================================================================
.rdata$r:00003038
.rdata$r:00003038 ; Segment type: Pure data
.rdata$r:00003038 ; Segment permissions: Read
.rdata$r:00003038 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003038                 assume cs:_rdata$r
.rdata$r:00003038                 ;org 3038h
.rdata$r:00003038 ; COMDAT (pick any)
.rdata$r:00003038                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00003038 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003038 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00003038                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00003038                                         ; .rdata$r:000030A8o ...
.rdata$r:00003038                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000303C                 db    0
.rdata$r:0000303D                 db    0
.rdata$r:0000303E                 db    0
.rdata$r:0000303F                 db    0
.rdata$r:00003040                 db    0
.rdata$r:00003041                 db    0
.rdata$r:00003042                 db    0
.rdata$r:00003043                 db    0
.rdata$r:00003044                 db 0FFh
.rdata$r:00003045                 db 0FFh
.rdata$r:00003046                 db 0FFh
.rdata$r:00003047                 db 0FFh
.rdata$r:00003048                 db    0
.rdata$r:00003049                 db    0
.rdata$r:0000304A                 db    0
.rdata$r:0000304B                 db    0
.rdata$r:0000304C                 db  40h ; @
.rdata$r:0000304D                 db    0
.rdata$r:0000304E                 db    0
.rdata$r:0000304F                 db    0
.rdata$r:00003050                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003050 _rdata$r        ends
.rdata$r:00003050
.rdata$r:00003054 ; ===========================================================================
.rdata$r:00003054
.rdata$r:00003054 ; Segment type: Pure data
.rdata$r:00003054 ; Segment permissions: Read
.rdata$r:00003054 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003054                 assume cs:_rdata$r
.rdata$r:00003054                 ;org 3054h
.rdata$r:00003054 ; COMDAT (pick any)
.rdata$r:00003054                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00003054 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00003054 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00003054                                         ; DATA XREF: .rdata:00002DD0o
.rdata$r:00003055                 db    0
.rdata$r:00003056                 db    0
.rdata$r:00003057                 db    0
.rdata$r:00003058                 db    0
.rdata$r:00003059                 db    0
.rdata$r:0000305A                 db    0
.rdata$r:0000305B                 db    0
.rdata$r:0000305C                 db    0
.rdata$r:0000305D                 db    0
.rdata$r:0000305E                 db    0
.rdata$r:0000305F                 db    0
.rdata$r:00003060                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00003064                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003064 _rdata$r        ends
.rdata$r:00003064
.data$r:00003068 ; ===========================================================================
.data$r:00003068
.data$r:00003068 ; Segment type: Pure data
.data$r:00003068 ; Segment permissions: Read/Write
.data$r:00003068 _data$r         segment dword public 'DATA' use32
.data$r:00003068                 assume cs:_data$r
.data$r:00003068                 ;org 3068h
.data$r:00003068 ; COMDAT (pick any)
.data$r:00003068                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00003068 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00003068 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003068                                         ; DATA XREF: .rdata$r:00003060o
.data$r:00003068                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003068                                         ; const type_info::`vftable'
.data$r:0000306C                 align 10h
.data$r:00003070 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:00003092                 align 4
.data$r:00003092 _data$r         ends
.data$r:00003092
.rdata$r:00003094 ; ===========================================================================
.rdata$r:00003094
.rdata$r:00003094 ; Segment type: Pure data
.rdata$r:00003094 ; Segment permissions: Read
.rdata$r:00003094 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003094                 assume cs:_rdata$r
.rdata$r:00003094                 ;org 3094h
.rdata$r:00003094 ; COMDAT (pick any)
.rdata$r:00003094                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00003094 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003094 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00003094                                         ; DATA XREF: .rdata$r:00003064o
.rdata$r:00003094                                         ; .rdata$r:000030C8o
.rdata$r:00003095                 db    0
.rdata$r:00003096                 db    0
.rdata$r:00003097                 db    0
.rdata$r:00003098                 db    0
.rdata$r:00003099                 db    0
.rdata$r:0000309A                 db    0
.rdata$r:0000309B                 db    0
.rdata$r:0000309C                 db    2
.rdata$r:0000309D                 db    0
.rdata$r:0000309E                 db    0
.rdata$r:0000309F                 db    0
.rdata$r:000030A0                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000030A0 _rdata$r        ends
.rdata$r:000030A0
.rdata$r:000030A4 ; ===========================================================================
.rdata$r:000030A4
.rdata$r:000030A4 ; Segment type: Pure data
.rdata$r:000030A4 ; Segment permissions: Read
.rdata$r:000030A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000030A4                 assume cs:_rdata$r
.rdata$r:000030A4                 ;org 30A4h
.rdata$r:000030A4 ; COMDAT (pick any)
.rdata$r:000030A4                 public ??_R2_Generic_error_category@std@@8
.rdata$r:000030A4 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000030A4 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000030A4                                         ; DATA XREF: .rdata$r:000030A0o
.rdata$r:000030A4                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000030A8                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000030AC                 db    0
.rdata$r:000030AD                 align 10h
.rdata$r:000030AD _rdata$r        ends
.rdata$r:000030AD
.rdata$r:000030B0 ; ===========================================================================
.rdata$r:000030B0
.rdata$r:000030B0 ; Segment type: Pure data
.rdata$r:000030B0 ; Segment permissions: Read
.rdata$r:000030B0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000030B0                 assume cs:_rdata$r
.rdata$r:000030B0                 ;org 30B0h
.rdata$r:000030B0 ; COMDAT (pick any)
.rdata$r:000030B0                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000030B0 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000030B0 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:000030B0                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:000030B0                                         ; .rdata$r:00003120o ...
.rdata$r:000030B0                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000030B4                 db    1
.rdata$r:000030B5                 db    0
.rdata$r:000030B6                 db    0
.rdata$r:000030B7                 db    0
.rdata$r:000030B8                 db    0
.rdata$r:000030B9                 db    0
.rdata$r:000030BA                 db    0
.rdata$r:000030BB                 db    0
.rdata$r:000030BC                 db 0FFh
.rdata$r:000030BD                 db 0FFh
.rdata$r:000030BE                 db 0FFh
.rdata$r:000030BF                 db 0FFh
.rdata$r:000030C0                 db    0
.rdata$r:000030C1                 db    0
.rdata$r:000030C2                 db    0
.rdata$r:000030C3                 db    0
.rdata$r:000030C4                 db  40h ; @
.rdata$r:000030C5                 db    0
.rdata$r:000030C6                 db    0
.rdata$r:000030C7                 db    0
.rdata$r:000030C8                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000030C8 _rdata$r        ends
.rdata$r:000030C8
.rdata$r:000030CC ; ===========================================================================
.rdata$r:000030CC
.rdata$r:000030CC ; Segment type: Pure data
.rdata$r:000030CC ; Segment permissions: Read
.rdata$r:000030CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000030CC                 assume cs:_rdata$r
.rdata$r:000030CC                 ;org 30CCh
.rdata$r:000030CC ; COMDAT (pick any)
.rdata$r:000030CC                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:000030CC ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:000030CC ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:000030CC                                         ; DATA XREF: .rdata:00002E04o
.rdata$r:000030CD                 db    0
.rdata$r:000030CE                 db    0
.rdata$r:000030CF                 db    0
.rdata$r:000030D0                 db    0
.rdata$r:000030D1                 db    0
.rdata$r:000030D2                 db    0
.rdata$r:000030D3                 db    0
.rdata$r:000030D4                 db    0
.rdata$r:000030D5                 db    0
.rdata$r:000030D6                 db    0
.rdata$r:000030D7                 db    0
.rdata$r:000030D8                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000030DC                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000030DC _rdata$r        ends
.rdata$r:000030DC
.data$r:000030E0 ; ===========================================================================
.data$r:000030E0
.data$r:000030E0 ; Segment type: Pure data
.data$r:000030E0 ; Segment permissions: Read/Write
.data$r:000030E0 _data$r         segment dword public 'DATA' use32
.data$r:000030E0                 assume cs:_data$r
.data$r:000030E0                 ;org 30E0h
.data$r:000030E0 ; COMDAT (pick any)
.data$r:000030E0                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:000030E0 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:000030E0 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000030E0                                         ; DATA XREF: .rdata$r:000030D8o
.data$r:000030E0                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000030E0                                         ; const type_info::`vftable'
.data$r:000030E4                 align 8
.data$r:000030E8 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:0000310B                 align 4
.data$r:0000310B _data$r         ends
.data$r:0000310B
.rdata$r:0000310C ; ===========================================================================
.rdata$r:0000310C
.rdata$r:0000310C ; Segment type: Pure data
.rdata$r:0000310C ; Segment permissions: Read
.rdata$r:0000310C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000310C                 assume cs:_rdata$r
.rdata$r:0000310C                 ;org 310Ch
.rdata$r:0000310C ; COMDAT (pick any)
.rdata$r:0000310C                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:0000310C ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000310C ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:0000310C                                         ; DATA XREF: .rdata$r:000030DCo
.rdata$r:0000310C                                         ; .rdata$r:00003144o
.rdata$r:0000310D                 db    0
.rdata$r:0000310E                 db    0
.rdata$r:0000310F                 db    0
.rdata$r:00003110                 db    0
.rdata$r:00003111                 db    0
.rdata$r:00003112                 db    0
.rdata$r:00003113                 db    0
.rdata$r:00003114                 db    3
.rdata$r:00003115                 db    0
.rdata$r:00003116                 db    0
.rdata$r:00003117                 db    0
.rdata$r:00003118                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00003118 _rdata$r        ends
.rdata$r:00003118
.rdata$r:0000311C ; ===========================================================================
.rdata$r:0000311C
.rdata$r:0000311C ; Segment type: Pure data
.rdata$r:0000311C ; Segment permissions: Read
.rdata$r:0000311C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000311C                 assume cs:_rdata$r
.rdata$r:0000311C                 ;org 311Ch
.rdata$r:0000311C ; COMDAT (pick any)
.rdata$r:0000311C                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:0000311C ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000311C ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000311C                                         ; DATA XREF: .rdata$r:00003118o
.rdata$r:0000311C                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003120                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003124                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003128                 db    0
.rdata$r:00003129                 align 4
.rdata$r:00003129 _rdata$r        ends
.rdata$r:00003129
.rdata$r:0000312C ; ===========================================================================
.rdata$r:0000312C
.rdata$r:0000312C ; Segment type: Pure data
.rdata$r:0000312C ; Segment permissions: Read
.rdata$r:0000312C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000312C                 assume cs:_rdata$r
.rdata$r:0000312C                 ;org 312Ch
.rdata$r:0000312C ; COMDAT (pick any)
.rdata$r:0000312C                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000312C ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000312C ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:0000312C                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:0000312C                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00003130                 db    2
.rdata$r:00003131                 db    0
.rdata$r:00003132                 db    0
.rdata$r:00003133                 db    0
.rdata$r:00003134                 db    0
.rdata$r:00003135                 db    0
.rdata$r:00003136                 db    0
.rdata$r:00003137                 db    0
.rdata$r:00003138                 db 0FFh
.rdata$r:00003139                 db 0FFh
.rdata$r:0000313A                 db 0FFh
.rdata$r:0000313B                 db 0FFh
.rdata$r:0000313C                 db    0
.rdata$r:0000313D                 db    0
.rdata$r:0000313E                 db    0
.rdata$r:0000313F                 db    0
.rdata$r:00003140                 db  40h ; @
.rdata$r:00003141                 db    0
.rdata$r:00003142                 db    0
.rdata$r:00003143                 db    0
.rdata$r:00003144                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003144 _rdata$r        ends
.rdata$r:00003144
.rdata$r:00003148 ; ===========================================================================
.rdata$r:00003148
.rdata$r:00003148 ; Segment type: Pure data
.rdata$r:00003148 ; Segment permissions: Read
.rdata$r:00003148 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003148                 assume cs:_rdata$r
.rdata$r:00003148                 ;org 3148h
.rdata$r:00003148 ; COMDAT (pick any)
.rdata$r:00003148                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00003148 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00003148 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00002E44o
.rdata$r:00003149                 db    0
.rdata$r:0000314A                 db    0
.rdata$r:0000314B                 db    0
.rdata$r:0000314C                 db    0
.rdata$r:0000314D                 db    0
.rdata$r:0000314E                 db    0
.rdata$r:0000314F                 db    0
.rdata$r:00003150                 db    0
.rdata$r:00003151                 db    0
.rdata$r:00003152                 db    0
.rdata$r:00003153                 db    0
.rdata$r:00003154                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00003158                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003158 _rdata$r        ends
.rdata$r:00003158
.data$r:0000315C ; ===========================================================================
.data$r:0000315C
.data$r:0000315C ; Segment type: Pure data
.data$r:0000315C ; Segment permissions: Read/Write
.data$r:0000315C _data$r         segment dword public 'DATA' use32
.data$r:0000315C                 assume cs:_data$r
.data$r:0000315C                 ;org 315Ch
.data$r:0000315C ; COMDAT (pick any)
.data$r:0000315C                 public ??_R0?AV_System_error_category@std@@@8
.data$r:0000315C ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:0000315C ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000315C                                         ; DATA XREF: .rdata$r:00003154o
.data$r:0000315C                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000315C                                         ; const type_info::`vftable'
.data$r:00003160                 db    0
.data$r:00003161                 db    0
.data$r:00003162                 db    0
.data$r:00003163                 db    0
.data$r:00003164                 db  2Eh ; .
.data$r:00003165                 db  3Fh ; ?
.data$r:00003166                 db  41h ; A
.data$r:00003167                 db  56h ; V
.data$r:00003168                 db  5Fh ; _
.data$r:00003169                 db  53h ; S
.data$r:0000316A                 db  79h ; y
.data$r:0000316B                 db  73h ; s
.data$r:0000316C                 db  74h ; t
.data$r:0000316D                 db  65h ; e
.data$r:0000316E                 db  6Dh ; m
.data$r:0000316F                 db  5Fh ; _
.data$r:00003170                 db  65h ; e
.data$r:00003171                 db  72h ; r
.data$r:00003172                 db  72h ; r
.data$r:00003173                 db  6Fh ; o
.data$r:00003174                 db  72h ; r
.data$r:00003175                 db  5Fh ; _
.data$r:00003176                 db  63h ; c
.data$r:00003177                 db  61h ; a
.data$r:00003178                 db  74h ; t
.data$r:00003179                 db  65h ; e
.data$r:0000317A                 db  67h ; g
.data$r:0000317B                 db  6Fh ; o
.data$r:0000317C                 db  72h ; r
.data$r:0000317D                 db  79h ; y
.data$r:0000317E                 db  40h ; @
.data$r:0000317F                 db  73h ; s
.data$r:00003180                 db  74h ; t
.data$r:00003181                 db  64h ; d
.data$r:00003182                 db  40h ; @
.data$r:00003183                 db  40h ; @
.data$r:00003184                 db    0
.data$r:00003185                 align 4
.data$r:00003185 _data$r         ends
.data$r:00003185
.rdata$r:00003188 ; ===========================================================================
.rdata$r:00003188
.rdata$r:00003188 ; Segment type: Pure data
.rdata$r:00003188 ; Segment permissions: Read
.rdata$r:00003188 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003188                 assume cs:_rdata$r
.rdata$r:00003188                 ;org 3188h
.rdata$r:00003188 ; COMDAT (pick any)
.rdata$r:00003188                 public ??_R3_System_error_category@std@@8
.rdata$r:00003188 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003188 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00003158o
.rdata$r:00003188                                         ; .rdata$r:000031C0o
.rdata$r:00003189                 db    0
.rdata$r:0000318A                 db    0
.rdata$r:0000318B                 db    0
.rdata$r:0000318C                 db    0
.rdata$r:0000318D                 db    0
.rdata$r:0000318E                 db    0
.rdata$r:0000318F                 db    0
.rdata$r:00003190                 db    3
.rdata$r:00003191                 db    0
.rdata$r:00003192                 db    0
.rdata$r:00003193                 db    0
.rdata$r:00003194                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00003194 _rdata$r        ends
.rdata$r:00003194
.rdata$r:00003198 ; ===========================================================================
.rdata$r:00003198
.rdata$r:00003198 ; Segment type: Pure data
.rdata$r:00003198 ; Segment permissions: Read
.rdata$r:00003198 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003198                 assume cs:_rdata$r
.rdata$r:00003198                 ;org 3198h
.rdata$r:00003198 ; COMDAT (pick any)
.rdata$r:00003198                 public ??_R2_System_error_category@std@@8
.rdata$r:00003198 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00003198 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00003198                                         ; DATA XREF: .rdata$r:00003194o
.rdata$r:00003198                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000319C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000031A0                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000031A4                 db    0
.rdata$r:000031A5                 align 4
.rdata$r:000031A5 _rdata$r        ends
.rdata$r:000031A5
.rdata$r:000031A8 ; ===========================================================================
.rdata$r:000031A8
.rdata$r:000031A8 ; Segment type: Pure data
.rdata$r:000031A8 ; Segment permissions: Read
.rdata$r:000031A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000031A8                 assume cs:_rdata$r
.rdata$r:000031A8                 ;org 31A8h
.rdata$r:000031A8 ; COMDAT (pick any)
.rdata$r:000031A8                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000031A8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000031A8 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:000031A8                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:000031A8                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000031AC                 db    2
.rdata$r:000031AD                 db    0
.rdata$r:000031AE                 db    0
.rdata$r:000031AF                 db    0
.rdata$r:000031B0                 db    0
.rdata$r:000031B1                 db    0
.rdata$r:000031B2                 db    0
.rdata$r:000031B3                 db    0
.rdata$r:000031B4                 db 0FFh
.rdata$r:000031B5                 db 0FFh
.rdata$r:000031B6                 db 0FFh
.rdata$r:000031B7                 db 0FFh
.rdata$r:000031B8                 db    0
.rdata$r:000031B9                 db    0
.rdata$r:000031BA                 db    0
.rdata$r:000031BB                 db    0
.rdata$r:000031BC                 db  40h ; @
.rdata$r:000031BD                 db    0
.rdata$r:000031BE                 db    0
.rdata$r:000031BF                 db    0
.rdata$r:000031C0                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000031C0 _rdata$r        ends
.rdata$r:000031C0
.CRT$XCU:000031C4 ; ===========================================================================
.CRT$XCU:000031C4
.CRT$XCU:000031C4 ; Segment type: Pure data
.CRT$XCU:000031C4 ; Segment permissions: Read
.CRT$XCU:000031C4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000031C4                 assume cs:_CRT$XCU
.CRT$XCU:000031C4                 ;org 31C4h
.CRT$XCU:000031C4 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:000031C8 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:000031C8 _CRT$XCU        ends
.CRT$XCU:000031C8
.CRT$XCU:000031CC ; ===========================================================================
.CRT$XCU:000031CC
.CRT$XCU:000031CC ; Segment type: Pure data
.CRT$XCU:000031CC ; Segment permissions: Read
.CRT$XCU:000031CC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000031CC                 assume cs:_CRT$XCU
.CRT$XCU:000031CC                 ;org 31CCh
.CRT$XCU:000031CC ; COMDAT (pick associative to section at 2E68)
.CRT$XCU:000031CC ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:000031CC ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:000031CC _CRT$XCU        ends
.CRT$XCU:000031CC
.CRT$XCU:000031D0 ; ===========================================================================
.CRT$XCU:000031D0
.CRT$XCU:000031D0 ; Segment type: Pure data
.CRT$XCU:000031D0 ; Segment permissions: Read
.CRT$XCU:000031D0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000031D0                 assume cs:_CRT$XCU
.CRT$XCU:000031D0                 ;org 31D0h
.CRT$XCU:000031D0 ; COMDAT (pick associative to section at 2E6C)
.CRT$XCU:000031D0 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:000031D0 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:000031D0 _CRT$XCU        ends
.CRT$XCU:000031D0
.CRT$XCU:000031D4 ; ===========================================================================
.CRT$XCU:000031D4
.CRT$XCU:000031D4 ; Segment type: Pure data
.CRT$XCU:000031D4 ; Segment permissions: Read
.CRT$XCU:000031D4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000031D4                 assume cs:_CRT$XCU
.CRT$XCU:000031D4                 ;org 31D4h
.CRT$XCU:000031D4 ; COMDAT (pick associative to section at 2E70)
.CRT$XCU:000031D4 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:000031D4 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:000031D4 _CRT$XCU        ends
.CRT$XCU:000031D4
.CRT$XCU:000031D8 ; ===========================================================================
.CRT$XCU:000031D8
.CRT$XCU:000031D8 ; Segment type: Pure data
.CRT$XCU:000031D8 ; Segment permissions: Read
.CRT$XCU:000031D8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000031D8                 assume cs:_CRT$XCU
.CRT$XCU:000031D8                 ;org 31D8h
.CRT$XCU:000031D8 ; COMDAT (pick associative to section at 2E74)
.CRT$XCU:000031D8 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:000031D8 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:000031D8 _CRT$XCU        ends
.CRT$XCU:000031D8
.CRT$XCU:000031DC ; ===========================================================================
.CRT$XCU:000031DC
.CRT$XCU:000031DC ; Segment type: Pure data
.CRT$XCU:000031DC ; Segment permissions: Read
.CRT$XCU:000031DC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000031DC                 assume cs:_CRT$XCU
.CRT$XCU:000031DC                 ;org 31DCh
.CRT$XCU:000031DC ; COMDAT (pick associative to section at 2E78)
.CRT$XCU:000031DC ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:000031DC ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:000031DC _CRT$XCU        ends
.CRT$XCU:000031DC
.CRT$XCU:000031E0 ; ===========================================================================
.CRT$XCU:000031E0
.CRT$XCU:000031E0 ; Segment type: Pure data
.CRT$XCU:000031E0 ; Segment permissions: Read
.CRT$XCU:000031E0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000031E0                 assume cs:_CRT$XCU
.CRT$XCU:000031E0                 ;org 31E0h
.CRT$XCU:000031E0 ; COMDAT (pick associative to section at 2F0C)
.CRT$XCU:000031E0 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:000031E0 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:000031E0 _CRT$XCU        ends
.CRT$XCU:000031E0
.CRT$XCU:000031E4 ; ===========================================================================
.CRT$XCU:000031E4
.CRT$XCU:000031E4 ; Segment type: Pure data
.CRT$XCU:000031E4 ; Segment permissions: Read
.CRT$XCU:000031E4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000031E4                 assume cs:_CRT$XCU
.CRT$XCU:000031E4                 ;org 31E4h
.CRT$XCU:000031E4 ; COMDAT (pick associative to section at 2F10)
.CRT$XCU:000031E4 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:000031E4 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:000031E4 _CRT$XCU        ends
.CRT$XCU:000031E4
UNDEF:000031F0 ; ===========================================================================
UNDEF:000031F0
UNDEF:000031F0 ; Segment type: Externs
UNDEF:000031F0 ; UNDEF
UNDEF:000031F0                 extrn __purecall:near   ; DATA XREF: .rdata:00002DBCo
UNDEF:000031F0                                         ; .rdata:00002DC0o
UNDEF:000031F4 ; void *__cdecl operator new(unsigned int)
UNDEF:000031F4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:000031F4                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p ...
UNDEF:000031F8 ; void __cdecl operator delete(void *)
UNDEF:000031F8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:000031F8                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:000031FC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:000031FC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:000031FC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00003200 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00003200                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00003200                                         ; _wmemcpy+11p
UNDEF:00003204 ; size_t __cdecl strlen(const char *Str)
UNDEF:00003204                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00003208 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00003208                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00003208                                         ; _wmemmove+11p
UNDEF:0000320C ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:0000320C                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:00003210 ; HLOCAL __stdcall LocalAlloc(UINT uFlags, SIZE_T uBytes)
UNDEF:00003210                 extrn __imp__LocalAlloc@8:near
UNDEF:00003210                                         ; CODE XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+F3p
UNDEF:00003210                                         ; DATA XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+F3r
UNDEF:00003214 ; LPVOID __stdcall LocalLock(HLOCAL hMem)
UNDEF:00003214                 extrn __imp__LocalLock@4:near
UNDEF:00003214                                         ; CODE XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+106p
UNDEF:00003214                                         ; DATA XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+106r
UNDEF:00003218 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00003218                 extrn __imp__SendMessageW@16:near
UNDEF:00003218                                         ; CODE XREF: StatusBar::setText(wchar_t const *,int)+43p
UNDEF:00003218                                         ; StatusBar::setOwnerDrawText(wchar_t const *)+35p ...
UNDEF:0000321C ; HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
UNDEF:0000321C                 extrn __imp__CreateWindowExW@48:near
UNDEF:0000321C                                         ; CODE XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+54p
UNDEF:0000321C                                         ; DATA XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+54r
UNDEF:00003220 ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:00003220                 extrn __imp__GetClientRect@8:near
UNDEF:00003220                                         ; CODE XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+11Dp
UNDEF:00003220                                         ; DATA XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+11Dr
UNDEF:00003224 ; void __stdcall InitCommonControls()
UNDEF:00003224                 extrn __imp__InitCommonControls@0:near
UNDEF:00003224                                         ; CODE XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+23p
UNDEF:00003224                                         ; DATA XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+23r
UNDEF:00003228 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00003228                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00003228                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:0000322C ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:0000322C                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:0000322C                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:0000322C                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00003230                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00003234 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:00003234                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:00003234                                         ; CODE XREF: std::runtime_error::runtime_error(char const *)+2Dp
UNDEF:00003238 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *)
UNDEF:00003238                 extrn ??0exception@std@@QAE@ABV01@@Z:near
UNDEF:00003238                                         ; CODE XREF: std::runtime_error::runtime_error(std::runtime_error const &)+2Dp
UNDEF:00003238                                         ; DATA XREF: .xdata$x:00002DB0o
UNDEF:0000323C ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:0000323C                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:0000323C                                         ; CODE XREF: __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0+3j
UNDEF:0000323C                                         ; __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0+3j ...
UNDEF:00003240 ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:00003240                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:00003240                                         ; DATA XREF: .rdata:00002D20o
UNDEF:00003244 ; void *__cdecl operator new[](unsigned int)
UNDEF:00003244                 extrn ??_U@YAPAXI@Z:near
UNDEF:00003244                                         ; CODE XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+A4p
UNDEF:00003248 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00003248                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00003248                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00003248                                         ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+16p
UNDEF:0000324C ; void __cdecl std::_Xbad_alloc()
UNDEF:0000324C                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000324C                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_31Ap
UNDEF:0000324C                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_35Cp ...
UNDEF:00003250 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00003250                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00003250                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00003250                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp
UNDEF:00003254 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00003254                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00003254                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00003254                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp
UNDEF:00003258 ; public: virtual void * __thiscall std::runtime_error::`vector deleting destructor'(unsigned int)
UNDEF:00003258                 extrn ??_Eruntime_error@std@@UAEPAXI@Z:near ; weak
UNDEF:00003258                                         ; DATA XREF: .rdata:const std::runtime_error::`vftable'o
UNDEF:0000325C ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000325C                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000325C                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00003260 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00003260                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00003260                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00003260                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00003264 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00003264                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00003264                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00003268 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003268                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003268                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000326C ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000326C                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000326C                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00003270 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003270                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003270                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00003274 ; __fastcall __security_check_cookie(x)
UNDEF:00003274                 extrn @__security_check_cookie@4:near
UNDEF:00003274                                         ; CODE XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+134p
UNDEF:00003274                                         ; __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp ...
UNDEF:00003278 ; __stdcall _CxxThrowException(x, x)
UNDEF:00003278                 extrn __CxxThrowException@8:near
UNDEF:00003278                                         ; CODE XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+7Fp
UNDEF:00003278                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p ...
UNDEF:0000327C                 extrn ___CxxFrameHandler3:near
UNDEF:0000327C                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:0000327C                                         ; __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+16j ...
UNDEF:00003280 ; const type_info::`vftable'
UNDEF:00003280                 extrn ??_7type_info@@6B@:near
UNDEF:00003280                                         ; DATA XREF: .data$r:std::runtime_error `RTTI Type Descriptor'o
UNDEF:00003280                                         ; .data$r:std::exception `RTTI Type Descriptor'o ...
UNDEF:00003284                 extrn ___security_cookie:near
UNDEF:00003284                                         ; DATA XREF: StatusBar::init(HINSTANCE__ *,HWND__ *,int)+6r
UNDEF:00003284                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r ...
UNDEF:00003288                 extrn __fltused:near
UNDEF:00003288
UNDEF:00003288
UNDEF:00003288                 end